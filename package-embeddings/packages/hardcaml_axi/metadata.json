{
  "package": "hardcaml_axi",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 631,
  "creation_timestamp": "2025-07-16T00:38:32.711549",
  "modules": [
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register bank fields to an association list using field names as keys, enabling direct access and manipulation of register values by their string identifiers. It operates on `O.t` interface types and converts them to or from lists of string-keyed values. This is useful for dynamically inspecting or configuring register banks by name, such as in testbenches or runtime configuration systems.",
      "description_length": 409,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking signals to vectors, multiplexing, concatenation, and selection functions like priority and one-hot decoding. It works with a `comb` type representing combinational signals and an interface type `t` that defines field-level access to registers. Concrete use cases include constructing and validating register layouts, dynamically selecting between multiple register banks, and transforming register values using constant assignments or vector operations.",
      "description_length": 576,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and transforming combinatorial read-enable signals in AXI4-Lite register banks, including signal manipulation (e.g., packing, concatenation, multiplexing) and control logic (e.g., pipelining, register assignment). It operates on register fields represented as `Read_enable.Of_signal.comb` and `t` types, interfacing with AXI4-Lite master protocols, and is used for scenarios requiring precise read transaction control in memory-mapped hardware designs with named signal ports and structured wiring conventions.",
      "description_length": 559,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank interfaces using bit vectors. It supports constant initialization, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with support for valid signals. These functions are used to implement AXI4-Lite register banks with precise bit-level control and validation.",
      "description_length": 375,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable and specification, and applying naming conventions to interface fields. Concrete use cases include defining hardware register banks with named signals, initializing wires with default values, and managing signal assignments within always blocks.",
      "description_length": 452,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic register interfaces into a monadic interface over a collection of registers, enabling bulk register access. It operates on register interfaces (`I.t`) within a monadic context (`M.t`), aggregating individual register operations into a single structured transaction. This is particularly useful for reading or writing multiple AXI4-Lite registers in a coordinated manner, ensuring that the transaction is framed correctly using `_valid`, `_first`, and `_ready` signals.",
      "description_length": 546,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and validating structured register interfaces with combinational and registered signal fields, primarily through signal routing (muxing, concatenation, assignment), constant embedding, and pipeline/register creation. It works with `I.Of_signal` types representing AXI4-Lite register banks, handling bitvector manipulations, field selections, and RTL signal naming with prefix/suffix conventions. Specific use cases include implementing control/status register banks in AXI4-Lite slaves, ensuring correct signal widths during synthesis, and creating hierarchical signal assignments with debug-friendly naming.",
      "description_length": 657,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions with support for valid signals. It works with `comb` and `t` types representing register bank fields, supporting constant assignment, width validation, and bit-level operations. Concrete use cases include constructing and validating register banks, implementing multiplexed register access, and converting register interfaces to flat vectors for serialization or bus interfacing.",
      "description_length": 567,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags, used to describe the interface of an AXI4-Lite register bank. It provides direct access to lists of port names, their corresponding bit widths, and associated tags, enabling introspection and automated wiring of register banks in hardware designs. These values are used during synthesis to generate correct-by-construction register interfaces connected to an AXI4-Lite master.",
      "description_length": 460,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register layout for a write-only AXI4-Lite register bank by specifying field names, widths, and associated tags. It works with string and integer types to describe register port configurations. Concrete use cases include generating register maps for hardware blocks that require write operations with validity signaling, such as control registers in FPGA peripherals.",
      "description_length": 391,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module suite enables register interface construction, signal routing, and RTL transformations for AXI4-Lite register banks, operating on combinational and registered signal types (`O.Of_signal.comb O.t` and `O.Of_signal.t`). It supports use cases such as implementing control/status registers, pipelined data paths, and structured signal wiring with naming conventions in hardware designs interfacing with a master via AXI4-Lite. Key operations include constant",
      "description_length": 466,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank with read-enable functionality, specifying port names, widths, and associated tags. It provides concrete signal names and bit-widths for each register port, enabling precise hardware register mapping. This is used to generate or interface with AXI4-Lite compliant register banks in hardware designs where individual registers require read-enable control.",
      "description_length": 421,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with read-enable functionality. It supports data types like `comb Read_enable.t` for representing register fields and includes functions for packing/unpacking, multiplexing, concatenation, and validation of signal widths. Concrete use cases include constructing and validating register banks connected to AXI4-Lite masters, enabling dynamic selection and routing of register data based on control signals.",
      "description_length": 499,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags, for AXI4-Lite interfaces. It provides direct access to lists of port names, widths, and associated tags for hardware register bank implementations. Useful for generating documentation, validating register layouts, and driving tooling that consumes register bank descriptions.",
      "description_length": 359,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating register bank interfaces connected to an AXI4-Lite master. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations on register fields with precise bit-width control. Concrete use cases include building complex register maps, implementing priority-encoded signal routing, and synthesizing constant or dynamic register configurations in hardware designs.",
      "description_length": 474,
      "index": 14,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values into a single monadic value containing a collection, effectively lifting the monad outside the interface structure. It operates on data types involving interfaces (`O.t`) and monads (`M.t`), specifically handling combinations of interface-driven values within a monadic context. A concrete use case is aggregating multiple register read or write operations into a unified transaction while preserving the interface structure and monadic sequencing.",
      "description_length": 533,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a register bank interface and an association list mapping field names to values. It operates on the `Write_with_valid.t` type, which represents a register bank with write capabilities and validity signaling. Use this module to serialize or deserialize register bank data for testing, configuration, or integration with systems that consume or produce named register-value pairs.",
      "description_length": 428,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Use cases include building AXI4-Lite register banks with named signals, connecting hardware modules using structured interfaces, and managing synchronous logic with register variables.",
      "description_length": 430,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate register bank interfaces with bit-level representations. It supports register-level operations such as packing/unpacking to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection between register interfaces. Concrete use cases include assembling register banks for AXI4-Lite slaves, validating signal widths during simulation or synthesis, and dynamically selecting or routing register data based on control signals.",
      "description_length": 510,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Lite write transactions with valid signaling. It supports data types representing register banks with write interfaces, enabling tasks like constant assignment, packing/unpacking, multiplexing, and priority or one-hot selection of write signals. Concrete use cases include building configurable register banks with dynamic input selection, validating signal widths, and assembling complex write transactions from multiple sources.",
      "description_length": 521,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate write interfaces with valid signaling in an always block context. It supports operations like assigning signals to variables, creating registers with optional enable, and applying names to interface fields. Use cases include implementing AXI4-Lite register banks with synchronous logic, where write transactions are controlled by valid and ready handshakes.",
      "description_length": 413,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with read-enable functionality. It supports data types including integer constants, bit vectors, and valid-ready handshaking signals, with functions for packing, unpacking, multiplexing, and priority or one-hot selection of register bank signals. Concrete use cases include constructing and validating register banks, selecting between multiple register sources based on control signals, and converting between structured register interfaces and flat bit vectors for AXI4-Lite communication.",
      "description_length": 585,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register bank fields to an interface by associating them with port names using unsafe operations. It works with string-indexed association lists and register bank interfaces. It is used to dynamically construct or deconstruct register banks from named field-value pairs, enabling runtime configuration of register mappings.",
      "description_length": 340,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank write interfaces with valid signaling, using bit vectors. It supports constant initialization, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection logic for register transactions. These operations are used to implement AXI4-Lite register banks with precise bit-level control and transaction framing.",
      "description_length": 403,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic value containing a structure, specifically for read-enable interfaces. It operates on types `'a M.t Read_enable.t` and lifts the monad `M` outside the `Read_enable` interface type. A concrete use case is aggregating multiple register reads under a single monadic context while preserving the interface structure.",
      "description_length": 419,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interface values, and validating signal widths. It supports data types such as `comb I.t` for representing register bank fields and `comb` for vector operations, with functions like `mux`, `concat`, and `pack` enabling direct signal routing and transformation. Concrete use cases include constructing dynamic register mappings, implementing priority or one-hot signal selection, and ensuring signal integrity during interface translation.",
      "description_length": 614,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Lite write register interfaces with validity signals. It supports data types representing register banks with write transactions framed by `_valid` and `_first` signals, and works with packed vectors and multiplexed inputs. Concrete use cases include building register banks with constant initialization, dynamic multiplexing of write data based on select signals, and validating interface signal widths during design elaboration.",
      "description_length": 521,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register fields to string keys in an association list, enabling dynamic access to register values by name. It operates on `Read_enable.t` structures, which represent register banks with read capabilities. Use cases include runtime inspection or configuration of hardware registers through named field lookups, such as retrieving or updating specific register values in a testbench or control logic.",
      "description_length": 415,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and validating AXI4-Lite write transactions using valid/ready handshaking protocols, focusing on register bank interactions. It manipulates structured signal interfaces composed of data, valid, first, and ready control signals, enabling tasks like priority-encoded multiplexing, signal concatenation, and register configuration. Specific use cases include building memory-mapped register banks with AXI4-Lite compliance, where write operations require explicit transaction framing via _valid and _first signals to coordinate data transfers between master and slave hardware components.",
      "description_length": 634,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic write operations into a monadic write operation over a structure, effectively combining multiple register write transactions into a single transaction. It operates on `Write_with_valid.t` values, which represent write operations with validity signaling, and lifts monadic actions across these transactions. It is useful for synchronizing bulk register updates in AXI4-Lite slave modules, ensuring that all writes occur together as part of a single logical transaction.",
      "description_length": 545,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite register banks with named signals, connecting hardware modules using wire interfaces, and managing synchronous logic with register variables.",
      "description_length": 456,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate register bank interfaces as bit vectors, enabling operations like packing, unpacking, multiplexing, and concatenation of register fields. It works with `comb` types representing bit-level signals and structured register interfaces (`t`), supporting concrete tasks such as setting register values from integers, validating signal widths, and selecting between multiple register banks using priority or one-hot encoding. Use cases include configuring and managing AXI4-Lite register banks in hardware designs, particularly for control and status register handling.",
      "description_length": 607,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic value of a record, specifically for read-enable interfaces. It works with data structures that conform to the `Read_enable.t` type, lifting monadic operations through the structure. A concrete use case is aggregating multiple register reads in an AXI4-Lite interface, where each register read may involve a side effect such as a clock cycle or a state update.",
      "description_length": 455,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register bank fields to an interface using string associations, enabling dynamic access and manipulation of register values by name. It operates on interfaces and register banks, specifically handling conversions between these structures and association lists. Use this to simplify register bank initialization and introspection when field names are known but structure varies.",
      "description_length": 403,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Lite register bank interfaces with write and valid signals. It supports data types including packed vectors and record-like register interfaces, enabling direct mapping to hardware signals. Concrete use cases include building register banks with dynamic field selection, priority-encoded multiplexing, and constant initialization for AXI4-Lite memory-mapped peripherals.",
      "description_length": 461,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names, widths, and tags for AXI4-Lite internal bus interfaces. It provides concrete signal identifiers and bit-widths used in register transactions, enabling precise signal mapping and bus construction. Useful for generating register interface logic and ensuring correct signal alignment in AXI4-Lite slave implementations.",
      "description_length": 357,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between integer values and bit representations for AXI4-Lite register interfaces, supporting operations like packing, unpacking, and multiplexing register values. It works with `comb` types representing combinational logic bits and structured register types that model the datapath of an internal bus. Concrete use cases include constructing register files, decoding memory-mapped control signals, and implementing configuration registers in hardware designs.",
      "description_length": 501,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversion between register bank interfaces and association lists indexed by field names, enabling programmatic access and construction of register values using string keys. It operates on the `Write_with_valid.t` type, which represents a register bank interface with write and valid signals. Use cases include dynamically generating register configurations from string-keyed data or inspecting register states by field name during simulation or testing.",
      "description_length": 482,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces for AXI4-Lite register banks using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable and reset specifications, and applying naming conventions to interface fields. Concrete use cases include defining hardware register banks with synchronous logic and wiring default signals in an AXI4-Lite memory-mapped design.",
      "description_length": 462,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to an association list, enabling conversion between register banks and string-keyed value lists. It operates on `O.t` interface types, using strings and arbitrary values to represent register names and contents. Use this to dynamically inspect or configure register banks by field name, such as during testing or when mapping hardware registers to software representations.",
      "description_length": 415,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces in a simplified AXI4-Lite bus protocol. It supports data types like `comb` and `t`, enabling bit-level operations, multiplexing, and priority/one-hot selection with signals tied to transaction control. Concrete use cases include constructing register read/write paths, decoding bus signals, and managing data alignment and routing in hardware designs.",
      "description_length": 440,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a register structure and an association list, where each register is mapped to a string key. It operates on the `Internal_bus.Register.O.t` type, which represents a collection of registers with string-based port names. Use this module to serialize or deserialize register states for debugging, configuration, or dynamic register mapping in AXI4-Lite slave implementations.",
      "description_length": 420,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI4-Lite register bank interfaces with read enable signals. It supports construction, validation, packing/unpacking, and multiplexing of register bank signals, enabling direct hardware mapping and selection logic. Concrete use cases include implementing register file outputs, conditional signal routing, and static configuration logic in AXI4-Lite peripherals.",
      "description_length": 438,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names, widths, and tags for read-enable ports in a 32-bit AXI register bank. It provides direct access to port metadata as lists, specifically tailored for AXI4-Lite and AXI4-Stream interfaces where register access requires explicit read enable signals. Use cases include generating register port declarations and configuring bus interfaces with precise signal widths and names.",
      "description_length": 402,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to construct and manage AXI register banks using signal-based interfaces, focusing on write operations with valid signals. It handles tasks like constant assignment, signal packing/unpacking, multiplexing, and validation, operating on AXI write channels (`Write_with_valid`) and Hardcaml signal/register primitives. Specific use cases include implementing AXI4-Lite register banks with structured signal naming, ensuring correct width validation, and connecting hardware interfaces with pipelined or prioritized data paths.",
      "description_length": 554,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to and from association lists, enabling dynamic access and construction of register banks using string keys corresponding to field names. It operates on lists of string-value pairs, where each string identifies a register field. Use this to serialize, deserialize, or introspect register bank contents by field name without fixed structural constraints.",
      "description_length": 395,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register interfaces, including packing/unpacking signals to/from bit vectors, multiplexing, concatenation, and selection logic. It works directly with `comb` and `t` types representing register bank interfaces, supporting constant assignment, width validation, and structural transformations. Concrete use cases include constructing and validating AXI4-Lite register banks, implementing multiplexed register access, and generating constant or dynamic signal assignments in hardware descriptions.",
      "description_length": 575,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic structure containing write operations into a write operation containing a monadic structure, specifically for 32-bit AXI register banks. It works with monads and AXI4-Lite write interfaces that include a valid signal, enabling composition of multiple write operations. A concrete use case is aggregating writes across multiple registers in a single transaction while preserving validity signaling.",
      "description_length": 461,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to string keys in an association list, enabling dynamic lookup and manipulation of register values by name. It operates on `Read_enable.t` structures paired with string-indexed values, specifically for handling register banks with named fields. Use this when interfacing with AXI4-Lite register banks where register access needs to be dynamically driven by field names, such as in testbenches or configuration scripts.",
      "description_length": 460,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register interfaces to and from string-keyed associations, enabling direct access to register fields by port name. It operates on register structures that represent AXI4-Lite memory-mapped slaves, using valid and first signals to frame transactions. Use this when dynamically inspecting or configuring register fields by name, such as in testbenches or runtime configuration systems.",
      "description_length": 400,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API, specifically for 32-bit AXI4-Lite register banks. It supports operations like assigning signals to variables, creating registers with optional enable, and naming interface fields. Concrete use cases include defining hardware registers with initial values, connecting signals in an always block, and generating named signals for better debugging and synthesis output.",
      "description_length": 473,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to create and manipulate register interfaces for AXI4-Lite buses, specifically handling signal assignment, registration with optional enable, and wire creation. It works with types like `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Reg_spec.t` to model register behavior in hardware designs. Concrete use cases include defining register inputs and outputs in AXI4-Lite slave modules, assigning signals to registers with controlled timing, and applying naming conventions for signal tracing and debugging.",
      "description_length": 546,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with read-enable functionality. It supports values of type `comb Read_enable.t`, enabling operations like packing/unpacking to bit vectors, multiplexing, concatenation, and priority/one-hot selection across register fields. Concrete use cases include constructing register banks with dynamic field selection, implementing register file read logic, and validating signal widths during hardware compilation.",
      "description_length": 499,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register interfaces for AXI4-Lite internal bus transactions. It works with signals and variables representing read and write operations, using valid/first control signals to frame transactions. Use it to implement register-based slaves that respond to AXI4-Lite read and write requests with named signal assignments and optional enable conditions.",
      "description_length": 403,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite register interfaces using the Always API. It works with 32-bit wide write interfaces that include a valid signal, supporting operations like register instantiation, signal assignment, and wire creation. Concrete use cases include defining memory-mapped register banks with synchronous updates and connecting them to AXI4-Lite masters.",
      "description_length": 400,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert integer values to bit representations and manipulate bit-level data structures for AXI4-Lite register interfaces. It supports operations like packing, unpacking, concatenation, and multiplexing of register values, ensuring correct bit widths and enabling hardware-friendly data flow. Concrete use cases include constructing and decoding register fields for AXI4-Lite slave devices, such as control registers or status registers in FPGA designs.",
      "description_length": 486,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces connected to an AXI master. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. These functions are used to implement complex control logic for AXI4-Lite register banks with precise bit-level control.",
      "description_length": 400,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module manages individual slave instances within a demultiplexed AXI4-Lite bus structure. It provides functions to access and assign the master-to-slave and slave-to-master signal interfaces for a specific slave. Use this module to define how each slave connects to the internal bus, enabling precise control over signal routing in hardware designs with multiple memory-mapped peripherals.",
      "description_length": 394,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate 32-bit AXI4 register bank interfaces using bit-level representations. It supports constant initialization, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with support for valid signals and optional branching factors. These functions are used to implement and verify memory-mapped register banks with fixed-width fields in hardware designs.",
      "description_length": 431,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational signal manipulation and register interface transformation operations, focusing on validation, multiplexing, and hierarchical interface construction. It works with signal types (`I.Of_signal.t`) and register banks connected to AXI buses, enabling structured routing and naming of input/output ports. Key use cases include implementing AXI4-Lite register banks with named signal hierarchies, creating pipelined data paths, and synthesizing address-decoded register access logic for memory-mapped peripherals.",
      "description_length": 541,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values within an interface into a monadic interface value, enabling sequential composition of register operations. It works with 32-bit AXI4-Lite register banks, handling read and write transactions over a memory-mapped interface. Concrete use cases include aggregating multiple register reads or writes into a single transaction sequence for hardware control and status monitoring.",
      "description_length": 460,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite register banks with named signals and managing synchronous logic in hardware designs.",
      "description_length": 377,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces connected to an AXI master. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. These functions are used to implement complex control logic and data routing in AXI-based hardware designs.",
      "description_length": 387,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module structures and transforms register banks with read-enable logic for memory-mapped interfaces, supporting operations like mapping, zipping, and aggregating port metadata while synchronizing with AXI4-Lite transactions. It operates on `Read_enable.t` structures, enabling precise control over per-port read-enable conditions and metadata consistency. Child modules handle signal manipulation, interface construction, bit-level operations, and dynamic field access, with concrete use cases including synthesizing control logic, defining named register banks, validating signal widths, and aggregating register reads under monadic contexts. Key data types include `comb`, `t`, and monadic lifted interfaces, with operations for packing, multiplexing, and naming signals across AXI4-Lite compliant designs.",
      "description_length": 813,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4 register bank interfaces with write and valid signals. It supports data packing, unpacking, multiplexing, concatenation, and selection operations on register bank interfaces, enabling precise control over signal routing and data flow in AXI4-based memory-mapped systems. Use cases include building complex register banks with dynamic signal selection, validating signal widths, and generating constant or multiplexed register configurations.",
      "description_length": 532,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a 32-bit AXI4-Lite register bank interface, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works directly with `comb I.t` types representing register bank fields and supports concrete operations like setting fields from integers, validating signal widths, and constructing priority or one-hot multiplexed interfaces. Use cases include building custom register maps, implementing control/status registers, and managing AXI4-Lite slave devices with fixed or dynamic field configurations.",
      "description_length": 604,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate 32-bit AXI4 register bank interfaces using bit-level combinational logic. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection based on priority or one-hot encoding. These functions are used to implement register banks with fixed-width fields for AXI4-Lite or AXI4 memory-mapped control and status registers.",
      "description_length": 448,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation that distributes a single register state across multiple parallel register instances, enabling independent tracking of individual data paths. It operates on register types defined within the internal bus protocol, which include control signals like valid, first, and ready. A concrete use case is managing separate register states for multiple parallel AXI4-Lite slave interfaces within a hardware design.",
      "description_length": 443,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to and from association lists, enabling straightforward serialization and deserialization of register bank interfaces by field name. It operates on `I.t` interfaces and string-indexed lists of values, specifically supporting configuration and inspection of 32-bit AXI4-Lite register banks. Use this to dynamically construct or extract register values for testing, debugging, or runtime configuration.",
      "description_length": 442,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and their bit widths for an AXI4-Lite internal bus interface. It provides concrete values for port metadata, including lists of port names, widths, and tags used to identify register fields. These values are used to generate and manage register interfaces in hardware designs that use the internal bus protocol for configuration and control.",
      "description_length": 381,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API, specifically for building AXI4-Lite register banks. It supports operations like assigning signals to variables, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include defining hardware registers with initial values, connecting signals in an always block, and generating named signals for easier debugging in AXI4-Lite peripherals.",
      "description_length": 503,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. It works directly with `Always.Variable.t` and `Signal.t` types structured in a `Read_enable.t` interface, enabling precise control over AXI register banks in hardware designs.",
      "description_length": 445,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags, for a 32-bit AXI4-Lite interface. It provides direct access to lists of port names, widths, and associated tags used in register bank configuration. Concrete use cases include generating register maps, validating interface signal widths, and driving automated test or documentation tools.",
      "description_length": 372,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Lite register banks with 32-bit data and address buses. It supports operations such as packing/unpacking register interfaces to/from bit vectors, multiplexing, concatenation, and selection based on valid signals, with concrete use in hardware description for FPGA or ASIC designs. The module works directly with `Write_with_valid.t` interfaces, enabling precise control over register field widths and signal routing in memory-mapped systems.",
      "description_length": 532,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation that distributes a single input register interface across all elements of a parameterized module `M`. It operates on AXI4-Lite internal bus register interfaces, enabling per-element registration control while maintaining correct handshaking signals. Use this when implementing per-channel register slices in a multi-channel AXI-Lite slave device.",
      "description_length": 384,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register values in an AXI4-Lite internal bus interface. It supports data types like `comb` and `t`, offering functions for packing, unpacking, muxing, concatenation, and priority/onehot selection on register values. Concrete use cases include constructing and validating register transactions, selecting between multiple register inputs based on control signals, and converting between integer and register representations for hardware synthesis.",
      "description_length": 515,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for defining and manipulating read-enable signal interfaces in AXI4-Lite register banks, focusing on signal creation, naming, and connection logic. It operates on `Read_enable.t` structures composed of combinational signals, enabling field-level configuration, validation, and RTL wiring for 32-bit memory-mapped register banks. Specific use cases include hardware design tasks like register bank instantiation, signal multiplexing, and pipeline construction with named signal assignments.",
      "description_length": 520,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation of register bank interfaces connected to AXI4-Lite masters through combinators that support mapping, zipping, folding, and error aggregation across tagged fields. It operates on interfaces represented as typed signals grouped by port names and bit widths, allowing transformations between list-based and signal-based representations, and is used to synthesize register banks from always blocks, define memory-mapped I/O with symbolic register names, and implement type-safe read/write logic. Submodules provide combinational logic operations like multiplexing, concatenation, and priority decoding; bulk register access via monadic aggregation; signal routing and pipeline creation; port metadata handling; and bitvector-level manipulation for tasks like dynamic register mapping and signal validation. Examples include constructing control/status registers, coordinating multi-register AXI4-Lite transactions, and generating debug-friendly hierarchical signal assignments.",
      "description_length": 1017,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles bit-level manipulation and validation of write register interfaces with valid signals, providing operations like packing, unpacking, multiplexing, and concatenation of register banks. It works with 32-bit data and address buses, using combinational logic signals (`comb`) and structured register types (`t`). Concrete use cases include constructing and validating AXI4-Lite register banks, dynamically selecting or routing register inputs using priority or one-hot encoded control signals, and converting between register values and bit vectors for hardware synthesis.",
      "description_length": 588,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating 32-bit AXI4-Lite register bank interfaces. It supports signal packing, unpacking, multiplexing, concatenation, and selection functions tailored for register bank configurations. Use cases include implementing control/status register banks with precise bit-width handling and valid signal management in AXI4-Lite memory-mapped designs.",
      "description_length": 420,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a 32-bit register bank interface, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works directly with `comb` and `t` types representing register bank signals and their interfaces, enforcing width validation and constant assignment. Concrete use cases include constructing and validating AXI4-Lite register maps, implementing control logic for memory-mapped peripherals, and managing signal routing in hardware descriptions.",
      "description_length": 585,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values within an interface structure into a single monadic value containing the combined interface. It operates on data types involving interfaces (`O.t`) and monads (`M.t`), specifically lifting monadic effects outside the interface structure. A concrete use case is aggregating multiple register read or write operations connected to a master interface into a unified transaction, enabling synchronized access to a register bank over AXI4 or AXI4-Lite.",
      "description_length": 532,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming and connecting structured combinational logic signals that model register interfaces, enabling patterns like multiplexing, priority selection, and pipelining. It works with `O.Of_signal.comb O.t` values, which represent hierarchical signal groupings that map to AXI-connected register banks. These capabilities are used to implement control logic and data path components in hardware designs where structured signal manipulation and explicit naming are required for synthesis and debugging.",
      "description_length": 539,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic structure over a write interface into a write interface over a monadic structure, enabling simultaneous handling of multiple write operations with validity signals. It operates on data types involving `Write_with_valid.t` and a monad `M`, typically used for aggregating AXI4-Lite register writes. A concrete use case includes combining multiple register write operations into a single transaction, ensuring atomic updates across a register bank connected to an AXI master interface.",
      "description_length": 546,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with `I.Of_bits.comb I.t` types, representing register fields as bit-level signals. Concrete use cases include implementing AXI4-Lite register maps, decoding memory-mapped control signals, and synthesizing configurable hardware blocks from bit-level representations.",
      "description_length": 504,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a read-enable interface containing monadic values into a monadic value containing a read-enable interface, effectively sequencing the monadic effects across the interface. It operates on 32-bit register banks connected to a master interface, specifically handling read-enable signals in AXI4-Lite and AXI4 memory-mapped contexts. A concrete use case includes aggregating register reads from multiple slave devices into a single synchronized operation, ensuring correct timing and data flow in hardware designs.",
      "description_length": 564,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for transforming and composing register write transactions with validity signaling, enabling structured manipulation of AXI4-Lite register banks through operations like mapping, zipping, and folding. It supports data types that represent register interfaces with named fields, bit-widths, and values, synchronized via valid/ready handshaking to ensure transaction consistency across hierarchical designs. Child modules enhance this functionality by defining register layouts, converting to and from association lists, implementing combinational logic for transaction assembly, and supporting bit-vector operations for precise control over write signals and interface naming. Specific capabilities include synthesizing write-only register banks, validating signal widths, multiplexing inputs, and coordinating bulk register updates under a single transaction using monadic lifting.",
      "description_length": 913,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI register interfaces using the Always API. It supports operations like assigning signals to register variables, creating registers with optional enable signals, and applying naming conventions to interface fields. It works with AXI write interfaces containing valid signals and is used to implement memory-mapped register banks with named signals in hardware designs.",
      "description_length": 426,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces connected to an AXI master. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. These functions are used to implement control logic for AXI4-Lite register banks, such as configuring hardware registers from constants or multiplexed inputs.",
      "description_length": 438,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces in an AXI4-Lite internal bus, including packing, unpacking, multiplexing, and concatenation of register values. It works with types `comb` and `t`, supporting operations like `mux`, `concat`, and priority/onehot selection for register value routing. Concrete use cases include constructing register file datapaths and implementing control logic for AXI4-Lite slave devices.",
      "description_length": 462,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports constructing and managing AXI4-Lite write register interfaces with 32-bit data and address buses, focusing on signal validity handling. It provides operations for constant assignment, signal packing/unpacking, multiplexing, and register creation, working with `Write_with_valid.Of_signal.t` values to represent AXI write signals. These tools are used to build hardware modules that interface with AXI4-Lite for lightweight memory-mapped transactions, ensuring correct signal widths and enabling hierarchical wiring with named interfaces.",
      "description_length": 558,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation and introspection of AXI4-Lite register banks using applicative and monadic combinators that operate on tuples of hardware interfaces, signals, and register metadata. It supports layout conversions, bit-level transformations, and port naming/width tracking, with core data types representing register fields, combinational logic, and signal-driven interfaces. Operations include mapping, folding, and zipping register values, as well as aggregating monadic register transactions and constructing register banks from always blocks. Specific examples include synthesizing control/status registers with named fields, validating interface consistency across hierarchical designs, and bridging AXI4-Lite masters with complex register maps using bit vectors and valid signals.",
      "description_length": 814,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a 32-bit register bank interface, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works directly with register bank interfaces composed of 32-bit data and address buses, using combinational logic types for signal manipulation. Concrete use cases include constructing and validating register bank layouts, routing signals between AXI4-Lite interfaces, and implementing control logic for memory-mapped peripherals.",
      "description_length": 527,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces with read-enable signals, packed as bit vectors. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with valid signals. These functions are used to implement AXI4-Lite register banks with precise bit-level control and validation.",
      "description_length": 377,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, validate, and manipulate register bank interfaces with read-enable signals encoded as bit vectors. It supports concrete tasks such as packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating register banks, and validating field widths. These operations are used when implementing AXI4-Lite register banks with 32-bit data and address buses, particularly for hardware synthesis and simulation where precise bit-level control is required.",
      "description_length": 506,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface into an interface of monadic values, effectively combining and lifting the monadic structure outside the interface. It operates on data types involving interfaces (`I.t`) and monads (`M.t`), specifically handling values of type `'a M.t I.t`. A concrete use case is aggregating multiple register operations within a monadic context, enabling sequential composition of register reads or writes over an AXI interface.",
      "description_length": 488,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI register banks with read-enable interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` typed vectors and `Read_enable.t` interface types to manage register field widths and values. Concrete use cases include constructing register banks with dynamic field selection, implementing priority-encoded multiplexing, and validating signal widths during register interface synthesis.",
      "description_length": 504,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank interface that supports write operations with validity signals. It specifies port names, widths, and associated tags for signals involved in AXI4 register transactions. It is used to generate or analyze register banks where each register has a defined bit width and a corresponding valid signal.",
      "description_length": 362,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and route read-enable signals (`Hardcaml.Signal.t`) in AXI4 register banks through concatenation, multiplexing, priority encoding, and pipelining, while supporting structured interface creation with named signals and connection operators. It works with register banks of defined bit widths, enabling precise control over memory-mapped register access patterns. These capabilities are critical for implementing AXI4-Lite peripherals and high-throughput memory-mapped systems where dynamic read enablement and signal prioritization are required.",
      "description_length": 589,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port configurations for AXI4-Lite write operations with valid signaling. It specifies port names, widths, and associated tags for 32-bit data and address buses. Used to generate register bank interfaces with write enable signals in memory-mapped AXI designs.",
      "description_length": 292,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface value into an interface of monadic values, effectively combining and lifting monads outside the interface structure. It operates on data types involving interfaces (`I.t`) and monadic types (`M.t`), specifically handling values of type `'a M.t I.t`. A concrete use case is when working with AXI4-Lite register banks, where this function simplifies handling multiple register reads or writes concurrently within a monadic context.",
      "description_length": 503,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides register manipulation and signal transformation operations for AXI4-Lite internal bus protocols, including signal packing/unpacking, multiplexing, concatenation, and priority selection. It operates on combinatorial signals and register structures (`t`), enabling transaction validation, pipelining, and register control through functions like `reg`, `pipeline`, and `assign`. It is specifically used to implement AXI4-Lite slave interfaces with synchronized data path management, handling framed transactions via _valid/_first signals and integrating register state machines into hardware designs.",
      "description_length": 618,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to an association list, enabling conversion between register banks and string-keyed lists. It operates on `Read_enable.t` and list types with string keys and arbitrary values. Use this when dynamically constructing register banks from named field-value pairs or extracting register contents into a lookup table.",
      "description_length": 353,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags. It provides direct access to lists of port names, widths, and associated tags for AXI register banks. Useful for generating documentation or validating register layouts in AXI4 or AXI4-Lite memory-mapped interfaces.",
      "description_length": 299,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a 32-bit AXI4-Lite register bank interface with read enable signals. It supports constant assignment, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. Use cases include constructing and validating register bank logic, routing register outputs based on control signals, and integrating register interfaces into larger AXI4 memory-mapped systems.",
      "description_length": 487,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating 32-bit AXI4 register bank interfaces using signal-level abstractions. It works with structured register fields represented as `O.Of_signal.comb O.t` and `O.Of_signal.t` types, enabling precise bit-level control and hierarchical signal wiring. Specific use cases include building pipelined register banks for memory-mapped AXI4-Lite peripherals, connecting master interfaces to register arrays, and automating signal naming conventions for synthesis-friendly hardware descriptions.",
      "description_length": 546,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and read-enable tags, for AXI4-Lite interfaces. It provides direct access to signal names, bit widths, and control tags required for register port connections. Use this module to configure and map register ports in AXI4-Lite slave devices where precise signal alignment and width are required.",
      "description_length": 367,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps string-indexed association lists to AXI4 register bank write operations with valid signals. It converts field name-value pairs into hardware register write transactions, ensuring valid signals align with named fields. Use when dynamically constructing register write sequences from named configurations, such as initializing peripheral registers from a symbolic map.",
      "description_length": 392,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces connected to an AXI master. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection, with validation of signal widths and construction from integer constants. It works with fixed-width bit vectors and structured register fields, enabling direct control and routing of AXI-connected hardware components.",
      "description_length": 478,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port metadata for a 32-bit AXI4-Lite register bank, including port names, widths, and associated tags. It provides direct access to lists of port names, widths, and type tags used in register interface generation. This module is used during register bank compilation to map software-visible register fields to hardware signals.",
      "description_length": 356,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides register manipulation and combinational logic operations for AXI4-Lite internal bus signals, enabling tasks like signal packing, multiplexing, and priority selection. It operates on `comb` and `t` types representing unregistered signal combinations and registered bus values, with utilities for transaction framing via `_valid`, `_first`, and `_ready` signals. It is specifically used to implement lightweight memory-mapped register interfaces in AXI4-Lite slaves where single-cycle transactions require minimal logic overhead.",
      "description_length": 548,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with `comb` signals representing register fields and supports constant initialization, width validation, and selection logic like priority or one-hot encoding. Concrete use cases include constructing and validating AXI4-Lite register banks from bit vectors, dynamically selecting between register configurations, and ensuring signal widths match interface specifications.",
      "description_length": 530,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces in a simplified AXI4-Lite bus protocol. It supports data types like `comb` and `t`, enabling bit-level operations, multiplexing, and priority/one-hot selection with signals like `_valid`, `_ready`, and `_first`. Concrete use cases include constructing register read/write paths, decoding bus transactions, and managing data routing in hardware designs.",
      "description_length": 441,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags, for AXI4-Lite and AXI4-Stream interfaces. It provides direct access to lists of port names, widths, and associated tags used in hardware register bank implementations. Concrete use cases include generating signal declarations, validating interface connections, and driving automated testbench generation based on register bank specifications.",
      "description_length": 426,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces in the context of AXI4-Lite register banks. It supports operations like assigning signals to variables, creating registers with optional enable, and naming interface fields. Concrete use cases include defining hardware registers with default values, connecting signals in an always block, and applying consistent naming conventions to interface elements for synthesis and debugging.",
      "description_length": 467,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank interfaces for AXI4-Lite write transactions with valid signals. It supports data packing/unpacking, multiplexing, concatenation, and selection logic for register fields represented as bit vectors. Concrete use cases include implementing memory-mapped register banks with fixed or dynamic field values, validation of signal widths, and hierarchical bus multiplexing.",
      "description_length": 439,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides `to_alist` and `of_alist` functions that convert between a registered AXI stream interface and an association list indexed by field names. It operates on the `Datapath_register.I.t` type, which represents a fully registered AXI stream interface with `tvalid/tready` handshake signals. These functions enable direct mapping between interface signals and named values, useful for introspection, configuration, or dynamic signal routing in AXI stream pipelines.",
      "description_length": 479,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module connects a register bank to an AXI4-Lite master interface, enabling memory-mapped register access with support for pipelined reads and write transactions. It provides data types like `comb`, `t`, and tagged field structures to represent register interfaces, signals, and metadata, with operations for mapping, zipping, folding, and monadic aggregation across both direct and child modules. You can define named register banks with precise bit-widths, synthesize control logic, validate signal widths, and coordinate multi-register transactions while maintaining AXI4-Lite compliance. Child modules enhance this by enabling dynamic field access, error aggregation, priority decoding, and hierarchical signal routing, supporting concrete tasks like constructing debug-friendly register maps and bridging hardware peripherals with software-visible interfaces.",
      "description_length": 868,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master-to-slave interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with the `comb` type and structured interface types containing valid and first signals. Concrete use cases include building complex AXI4-Lite bus logic, routing transactions between masters and slaves, and constructing test scenarios with predefined constant or prioritized inputs.",
      "description_length": 491,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-Lite slave state machines into a unified interface for handling memory-mapped transactions. Works with AXI4-Lite protocol signals and internal bus representations. Used to implement register banks or memory-mapped peripherals where each state machine corresponds to a specific address range.",
      "description_length": 321,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Stream interfaces, including packing/unpacking signals, multiplexing, concatenation, and priority/one-hot selection. It works with registered AXI4-Stream datapath signals, ensuring correct signal width validation and constant initialization. Concrete use cases include building flexible stream multiplexers, constructing constant stream sources, and managing complex signal routing in AXI4-Stream pipelines.",
      "description_length": 481,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate AXI4-Lite write interfaces with valid signals using bit vectors. It supports tasks such as packing/unpacking interfaces to/from bit vectors, multiplexing multiple interfaces, concatenation, and selecting between interfaces using priority or one-hot encoding. Concrete use cases include building register banks with AXI4-Lite write channels, implementing control logic for memory-mapped peripherals, and managing signal routing in hardware designs.",
      "description_length": 518,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4 register bank fields to and from association lists, using field names as keys. It operates on `O.t` interface values and string-indexed lists of values, enabling straightforward serialization and deserialization of register bank states. Use it to dynamically construct or inspect register banks from named field-value pairs, such as when loading configurations or dumping register states for debugging.",
      "description_length": 433,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module manages individual slave instances within a demultiplexer setup, allowing a single AXI4 master to communicate with multiple slaves over a 32-bit bus. It provides functions to access and assign the master-to-slave and slave-to-master AXI4 interface signals for a specific slave instance. Use this module when constructing a demultiplexed AXI4 memory-mapped system where each slave device must be individually addressed and connected to the shared master interface.",
      "description_length": 475,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit register interfaces, including packing, unpacking, multiplexing, and concatenation of register values. It supports data types such as `comb` and structured register types with field access, enabling precise control over AXI4-Lite and AXI4-Stream register datapaths. Concrete use cases include constructing register files, implementing control/status registers, and managing memory-mapped I/O in hardware designs.",
      "description_length": 488,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manage and manipulate register interfaces within an AXI4 bus implementation. It supports creating registers with optional enable signals, assigning values to registers, and generating named signals for clarity in hardware descriptions. The module works directly with AXI register structures, using signals and variables to represent data paths and control logic. Use cases include implementing AXI4-Lite slave registers, handling burst transactions in AXI4 memory-mapped interfaces, and managing AXI4-Stream data paths without address phases.",
      "description_length": 577,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between register structures and association lists keyed by port names. It operates on 32-bit AXI register types, enabling easy serialization and deserialization of register states. Concrete use cases include debugging register contents and dynamically configuring register blocks from named value lists.",
      "description_length": 343,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate register bank interfaces with read enable signals. It works with bit vectors (`comb`) and structured register bank types (`t`), supporting operations like packing/unpacking to/from vectors, multiplexing, concatenation, and selection logic. Concrete use cases include building AXI4-Lite register banks with precise bit-width control, implementing multiplexed register access, and validating signal widths during design synthesis.",
      "description_length": 499,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for encoding and decoding master-to-slave transactions in a simplified AXI4-Lite compatible internal bus. It supports signal packing/unpacking, multiplexing, concatenation, and selection logic for transaction interfaces with support for _valid, _first, and _ready handshaking. Concrete use cases include constructing and validating bus signals from constants, routing multiple transaction sources using priority or one-hot selection, and verifying signal widths during simulation or synthesis.",
      "description_length": 535,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite slave state machine signals. It supports data transformation through functions like `pack`, `unpack`, `mux`, and `concat`, working directly with bit vectors and structured transaction types. Use cases include implementing control logic for AXI4-Lite peripherals, routing data between AXI components, and constructing complex state transitions from simpler signal primitives.",
      "description_length": 453,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI interface signals, including packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interface values, and selecting between multiple interfaces using priority or one-hot encoding. It works with the `comb` type representing combinational signals and `t` as the interface type composed of fields with defined bit widths. Concrete use cases include constructing register banks with dynamic field selection, validating signal widths during simulation, and efficiently routing AXI data paths in hardware designs.",
      "description_length": 593,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manage a slave instance in a demultiplexed AXI bus, allowing retrieval and assignment of master-to-slave and slave-to-master signal interfaces. It works with AXI4 signal types, specifically `Hardcaml.Signal.t Master_to_slave.t` and `Hardcaml.Signal.t Slave_to_master.t`, to facilitate data transfer between components. Concrete use cases include configuring and connecting AXI slaves in a hardware design where a single master is routed to multiple slaves based on address decoding.",
      "description_length": 517,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite slave state machine signals, including packing, unpacking, multiplexing, and priority/one-hot selection. It works with the `comb` type and structured AXI4-Lite transaction data represented by `t`. Use this module to implement control logic that routes or transforms AXI4-Lite read and write transfers based on valid signals and selection criteria.",
      "description_length": 426,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master interface signals, including packing, unpacking, multiplexing, and priority/one-hot selection. It works with the `comb` type and structured transaction types defined in the AXI4-Lite interface. Concrete use cases include building control logic for memory-mapped peripherals, routing AXI4-Lite transactions based on address decoding, and implementing arbitration schemes for multiple AXI4-Lite masters.",
      "description_length": 487,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to AXI4-Lite slave-to-master interfaces using the Always API. It supports operations on data types encapsulating signals and variables, specifically tailored for AXI4-Lite read and write transactions. Concrete use cases include defining register and wire interfaces, assigning signal values within always blocks, and applying naming conventions to interface fields for clarity in hardware descriptions.",
      "description_length": 465,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate 32-bit AXI register values from bit-level representations. It includes functions for packing, unpacking, concatenation, and multiplexing of register fields, along with validation and width assertion utilities. Concrete use cases include assembling AXI output signals from individual bit fields, selecting between multiple register values using priority or one-hot encoding, and converting between integer and bit-level register representations.",
      "description_length": 504,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the AXI4-Lite interface ports when implementing a state machine that converts Ibus transactions to AXI4-Lite protocol. It works with string and integer data types to represent port names and their bit widths, along with a list of tags for state machine control signals. It is used to generate consistent signal declarations and wiring in hardware description code for AXI4-Lite master interfaces.",
      "description_length": 448,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manage and manipulate register outputs in an AXI bus interface. It supports creating registers with optional enable signals, assigning values to registers, and applying naming conventions to signals. The module works with types like `Hardcaml.Always.Variable.t Register.O.t` and `Hardcaml.Signal.t`, and is used to implement register logic in AXI4 or AXI4-Lite memory-mapped interfaces.",
      "description_length": 421,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines port names and widths for AXI4 interface signals, providing direct access to signal identifiers and their bit-widths. It works with lists of strings and integers to represent signal metadata. Use this to generate signal declarations or interface descriptions for AXI4 components in hardware designs.",
      "description_length": 319,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4 write interfaces with valid signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with fixed-width signal types represented as `comb` and structured using `Write_with_valid.t`, which encapsulates write data and valid control signals. Concrete use cases include building register banks, routing AXI write transactions, and constructing complex AXI interface logic with safe width validation and signal manipulation.",
      "description_length": 522,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing AXI4-Lite slave state machines using signal-level primitives like packing/unpacking, multiplexing, and stateful register assignments. It operates on `Hardcaml.Signal.t` values within a structured state machine framework, supporting combinational logic, priority selection, and pipelined dataflow. It is used to implement lightweight memory-mapped interfaces in FPGA peripherals, bridging AXI4-Lite transactions to simpler internal protocols for efficient CPU-peripheral communication with minimal logic overhead.",
      "description_length": 561,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in a simplified master-to-slave interface derived from AXI4-Lite. It provides concrete lists of port names, widths, and associated tags for use in hardware design implementations where memory-mapped transactions are reduced to a minimal control protocol. These values directly support the generation of signal declarations and interface wiring in RTL code.",
      "description_length": 411,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the ports used in the AXI4-Lite slave state machine interface. It provides concrete lists of port names, their corresponding bit widths, and a list of tags representing internal signals used during the conversion between AXI4-Lite transactions and the simplified internal bus protocol. These values are used directly in constructing and verifying the signal connections within the state machine implementation.",
      "description_length": 462,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation that aggregates all fields of a register interface into a single value, working with 32-bit AXI4-Lite register structures. It enables use cases such as flattening register state for easier inspection or serialization, particularly during simulation or debugging. The `all` function takes a register interface and returns a new interface where each field is combined into a single data type.",
      "description_length": 428,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and validate register bank interfaces with read enable signals. It supports packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. These operations are used to build complex register banks connected to AXI4-Lite or AXI4 memory-mapped interfaces, where precise control over register field widths and data flow is required.",
      "description_length": 474,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for a state machine that converts Ibus transactions to AXI4-Lite protocol. It supports construction, manipulation, and validation of AXI4-Lite control signals using combinational logic, including functions for packing, unpacking, multiplexing, and selecting between signal vectors. Use this module to implement AXI4-Lite master interfaces in hardware designs where precise control over memory-mapped I/O is required.",
      "description_length": 458,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces for AXI4 write operations with valid signaling, using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite or AXI4-Stream write interfaces with structured signal handling and register state management.",
      "description_length": 449,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic value of structures, specifically for AXI4-Stream interfaces where all output signals are registered. It works with AXI4-Stream data types wrapped in a monad `M`, enabling composition of streams while preserving the tvalid/tready handshake protocol. A concrete use case is aggregating multiple AXI4-Stream channels into a single stream interface for synchronized data transfer in hardware pipelines.",
      "description_length": 498,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces when working with the Always API, specifically for AXI4-Stream datapath components. It supports operations like assigning signals within an always block, creating registered or wire-based interface containers, and applying naming conventions to interface fields. Concrete use cases include building and connecting AXI4-Stream pipelines with registered control signals and named data paths in hardware designs.",
      "description_length": 494,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb` and `t` types representing combinational values and register interfaces. Concrete use cases include building control logic for AXI4-Lite register buses, routing data between register fields, and implementing dynamic register selection based on control signals.",
      "description_length": 454,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite slave state machine signals. It supports data types like `comb` and `t`, enabling tasks such as signal packing, unpacking, multiplexing, and priority selection. Use cases include implementing control logic for AXI4-Lite peripherals, routing data based on valid/ready handshakes, and constructing complex signal transformations from simpler components.",
      "description_length": 430,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register's interface by specifying the names and widths of its ports as well as a list of tags associated with the register. It operates on string and integer data types to describe port configurations and uses a custom tag type to classify register behavior. This information is used to generate or validate the structure of a 32-bit AXI register interface in hardware descriptions.",
      "description_length": 407,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-Lite interface signals and string-labeled values using port names as keys. Converts interface values to and from association lists of `(string * value)` pairs, enabling dynamic signal routing or configuration based on named ports. Useful for runtime signal mapping or debugging where port names must align with external representations.",
      "description_length": 354,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for managing a slave state machine in an AXI4-Lite interface, including functions to pack, unpack, and manipulate register values as bit vectors. It supports data types like `comb` for combinational logic and `t` for state machine transitions, enabling precise control over signal routing and state transitions. Use cases include implementing register banks, handling AXI4-Lite read/write transactions, and managing control/status registers in hardware designs.",
      "description_length": 503,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports operations for constructing and manipulating AXI4-Stream interfaces with registered outputs, focusing on signal-level transformations like multiplexing, concatenation, and pipelining while adhering to the `tvalid/tready` handshake protocol. It works with AXI4-Stream signal datapaths represented as `t` types, enabling use cases such as high-throughput streaming data paths in FPGA designs where registered synchronization between producer-consumer stages is critical. Key applications include implementing pipelined data transfers between peripherals or processing units without address-phase overhead.",
      "description_length": 624,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for register signal manipulation, including packing, unpacking, multiplexing, concatenation, and priority/one-hot encoding, alongside assignment and signal naming utilities. It operates on two core types: `comb` for combinational logic tied to register interfaces, and `t` for structured hardware registers within a signal graph. These capabilities are used to construct and validate register blocks in AXI4 register datapaths, manage signal connectivity with hierarchical naming, and implement burst-capable memory-mapped or streaming interfaces.",
      "description_length": 599,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables signal-level manipulation of AXI4-Lite master-to-slave interfaces, including operations like constant assignment, packing/unpacking, multiplexing, and register management. It operates on structured signal types that represent transactions framed by validity, readiness, and first-cycle indicators. These capabilities are used in hardware designs to implement memory-mapped communication between processing units and peripherals, particularly in FPGA or ASIC development where lightweight AXI4-Lite protocols are required.",
      "description_length": 541,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to define and manipulate 32-bit AXI4-Lite register interfaces using imperative-style always blocks. It supports creating registers with optional enable signals, assigning values to them, and managing signal wiring with bit-width specifications. Concrete use cases include implementing AXI4-Lite slave registers for control/status registers in hardware designs where memory-mapped access is required.",
      "description_length": 431,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a data path register interface containing monadic values into a monadic value containing a data path register interface, effectively lifting the monad outside the interface. It operates on the `Datapath_register.IO.t` type, which represents registered AXI4-Stream handshake signals (tvalid/tready). A concrete use case is combining multiple concurrent AXI4-Stream register stages into a single monadic structure for synchronized control flow in hardware description.",
      "description_length": 520,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and manipulation of 32-bit AXI4 register banks through combinators that support mapping, zipping, folding, and conversion of structured register interfaces. It provides core operations for transforming register fields tagged with names and bit widths, while submodules handle dynamic access via association lists, monadic composition of register transactions, bit-level combinational logic, and signal-level abstractions for hierarchical wiring. Concrete uses include defining memory-mapped control registers, aggregating read/write operations into sequences, packing and unpacking register fields to bit vectors, and generating synthesis-friendly hardware with validated signal widths and naming conventions. Key data types include structured register fields, `comb` types for combinational logic, and tagged port metadata used across operations for interface validation and transformation.",
      "description_length": 928,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate state machine interfaces for AXI4-Lite masters using Hardcaml's `Always` DSL. It supports working with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types, enabling direct signal assignment, register creation, and wire instantiation. Concrete use cases include implementing control logic for AXI4-Lite memory-mapped transactions, such as managing read/write sequences and state transitions in FPGA designs.",
      "description_length": 473,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces in the context of AXI4 read-enable logic. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building memory-mapped register banks with controlled read-enable behavior for AXI4-Lite or AXI4 interfaces.",
      "description_length": 403,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines port names, widths, and tags for AXI4 register banks with write-with-valid semantics. It provides concrete signal identifiers and bit-widths required to interface with AXI4-Lite and AXI4-Stream hardware components. These values are used to generate correct-by-construction register mappings and connect signals in memory-mapped and streaming contexts.",
      "description_length": 371,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I",
      "library": "hardcaml_axi",
      "description": "This module enables functional manipulation and structural composition of tagged register interfaces through combinators like map, fold, and zip, while supporting serialization, equality checks, and conversions with structured formats. It centers on `Internal_bus.Register.I.t`, representing hardware register descriptions with port metadata, and is used to build and manage AXI4-Lite register maps, interface with always blocks, and control data paths with validity signaling. Submodules provide concrete signal definitions, combinational logic for data routing, named field access via associations, and bit-level manipulation for AXI4-Lite transactions. Examples include decoding bus signals, dynamically configuring registers by name, implementing multi-channel register slices, and constructing control/status registers with precise bit-widths and signal mappings.",
      "description_length": 868,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4 interface signals, including packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interface values, and selecting between prioritized or one-hot encoded inputs. It works with fixed-width signal types represented as `comb` and structured interface descriptions in `t`. Concrete use cases include constructing register banks with dynamic field selection, implementing control logic for AXI4-Lite slaves, and managing data routing in AXI4-Stream pipelines.",
      "description_length": 542,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to convert between integer values and bit-level representations of a register interface, supporting packing, unpacking, and multiplexing of bit vectors. It works with fixed-width bit vectors and structured register types to enable precise control over data path operations in AXI4 register logic. Concrete use cases include constructing and deconstructing register values for AXI4-Lite memory-mapped interfaces and implementing register file logic with strict width validation.",
      "description_length": 509,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple monadic values within a slave-to-master interface into a single monadic value, effectively lifting the monad outside the interface structure. It operates on data types representing AXI4-Lite transactions, specifically framed read and write operations signaled by _valid, _first, and _ready control signals. A concrete use case is aggregating responses from multiple AXI4-Lite slave components into a unified response for a master interface, ensuring correct transaction framing and completion signaling.",
      "description_length": 564,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module defines bit-level operations and state transitions for an AXI4-Lite master interface, specifically handling signal routing and control logic. It works with `comb` types representing combinational logic signals and structured transaction types `t` for AXI protocol fields like addresses, data, and control signals. Use this to implement AXI4-Lite master state machines with precise bit-level control, such as managing read/write bursts, arbitration, and handshake protocols in hardware designs.",
      "description_length": 505,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register interface for a 32-bit AXI4-Lite bus, specifying the names and widths of its ports. It provides direct access to signal metadata such as port names, widths, and associated tags for hardware register connections. Concrete use cases include configuring register mappings and generating signal declarations for AXI4-Lite compliant hardware blocks.",
      "description_length": 377,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions for manipulating registered AXI stream signals, including packing/unpacking, multiplexing, concatenation, priority selection, and AXI handshaking (tvalid/tready) protocols, alongside utilities for wiring, naming, and pipelining signal interfaces. It operates on `Datapath_register.IO.Of_signal.t` interfaces, which represent registered AXI4-Stream signals, enabling high-throughput data transfer between components without address phases, such as connecting hardware modules with synchronized data paths or implementing streaming pipelines with validated signal handshakes.",
      "description_length": 604,
      "index": 169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works directly with 32-bit wide data structures and supports operations like `mux`, `concat`, and priority/one-hot selection for control logic in AXI register datapaths. Concrete use cases include implementing register file read/write datapaths, bus multiplexing, and control signal routing in AXI4-Lite or AXI4-Stream designs.",
      "description_length": 514,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that lifts monadic values from within an internal bus master-to-slave interface, enabling composition of transactions where each signal in the interface is treated as a monadic value. It operates on data structures representing AXI4-Lite master-to-slave transactions, specifically `Internal_bus.Master_to_slave.t` values parameterized over a monad `M`. A concrete use case includes combining multiple signal-level computations into a single transaction while preserving signal alignment and timing constraints.",
      "description_length": 548,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides `to_alist` and `of_alist` functions that convert between a datapath register interface and an association list indexed by field names. It operates on the `Datapath_register.IO.t` type, which represents registered AXI4-Stream interface signals. These functions enable direct, name-based mapping of interface fields to values, useful for serialization, configuration, or dynamic signal routing in AXI4-Stream pipelines.",
      "description_length": 438,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and widths for AXI interface signals, providing direct access to signal identifiers and their bit-widths. It works with string and integer data types to represent signal metadata, alongside a list of register tags for hardware synthesis. Concrete use cases include configuring register interfaces in AXI4 or AXI4-Lite buses, ensuring correct signal widths and names during hardware generation.",
      "description_length": 433,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and managing register bank interfaces with read-enable functionality in AXI4 designs, focusing on signal manipulation tasks like packing/unpacking, multiplexing, concatenation, and pipeline creation. It operates on `comb` and `t` types representing hardware signals and register interfaces, enabling structured handling of input/output signal naming, connection logic, and hierarchical register bank composition. Specific use cases include implementing AXI4-Lite register maps with precise read-enable control, optimizing signal routing in pipelined data paths, and generating debug-friendly named signal hierarchies for complex AXI4-based hardware systems.",
      "description_length": 706,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign signals within an always block using interface descriptions. It supports creating register and wire variables with named fields, enabling direct signal assignment and structured interface handling. Use cases include building AXI4-Lite control registers or AXI4-Stream data paths with named signal fields for clarity.",
      "description_length": 372,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and manipulation of typed register structures for AXI4-Lite interfaces, combining combinators for mapping, zipping, and folding with support for memory-mapped register banks and signal management. It provides data types like `comb`, `t`, and `Reg_spec.t` to model combinational logic, register states, and signal assignments, with operations for bit-level transformations, serialization, and transaction handling. Child modules enhance this functionality by enabling register-to-integer conversions, association list serialization, parallel state distribution, port metadata definition, and combinational logic construction. Examples include implementing configuration registers, decoding control signals, managing multiple AXI4-Lite slave interfaces, and synthesizing memory-mapped register transactions with validity and readiness signaling.",
      "description_length": 880,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces when working with AXI4-Stream components, specifically integrating with the Always API for signal assignment and naming. It operates on `Datapath_register.IO` interfaces, which contain signals wrapped in `Always.Variable.t` for simulation and synthesis purposes. Concrete use cases include defining named signal wires with default values, registering interface signals with optional enable and clock specifications, and assigning values within an always block while ensuring correct handshake protocol compliance.",
      "description_length": 598,
      "index": 177,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines port names, widths, and tags for AXI4-Lite register banks with read enable functionality. It provides concrete signal identifiers used in hardware description for register bank instantiations. These values specify the interface signals' naming and bit-widths for synthesis and simulation purposes.",
      "description_length": 317,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a record or tuple of monadic values into a monadic value of records or tuples, effectively flipping the structure. It operates on data types like records and tuples where each field is wrapped in a monad `M`. A typical use case is combining multiple signal wires in a hardware description into a single signal structure, enabling more structured and ergonomic handling of parallel computations.",
      "description_length": 448,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-Lite slave state machine signals and associative lists keyed by port names. Converts state machine signals to and from string-keyed lists of values, enabling dynamic inspection or configuration of AXI4-Lite interface signals by name rather than position. Useful for debugging or runtime signal manipulation where port names are known and direct signal access is required.",
      "description_length": 389,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate register bank interfaces as bit vectors, enabling operations like packing, unpacking, multiplexing, and concatenation of register fields. It works with fixed-width bit vectors and structured register interfaces, supporting constant initialization, width validation, and selection logic for hardware design. Concrete use cases include implementing AXI4-Lite register maps, handling memory-mapped I/O, and constructing configurable hardware blocks with strict bit-width requirements.",
      "description_length": 526,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Stream interfaces with registered datapaths, handling signal routing and validation. It operates on `t` values representing AXI4-Stream signals, using `Bits.t` for signal values, and supports operations like packing/unpacking, multiplexing, concatenation, and selection. Concrete use cases include constructing and validating AXI4-Stream pipelines, routing data between streaming components, and setting constant or controlled signal values.",
      "description_length": 491,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master state machine signals. It supports data transformations such as packing, unpacking, multiplexing, concatenation, and selection using one-hot or priority-encoded control signals. Concrete use cases include building control logic for AXI4-Lite memory-mapped transactions, routing data between AXI4-Lite components, and implementing register banks or peripheral interfaces.",
      "description_length": 456,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the AXI4-Lite interface ports when implementing a state machine that converts an Ibus master into an AXI4-Lite master. It provides concrete lists of port names, their corresponding bit widths, and a list of tags used to identify signal groups within the state machine logic. These values are used directly in constructing and verifying the interface signals during simulation and synthesis.",
      "description_length": 442,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI register interfaces, including packing/unpacking values, multiplexing, concatenation, and selection functions. It works with `comb` types and register structures to manage data paths in AXI4-Lite and AXI4-Stream designs. Concrete use cases include constructing control logic for register-based AXI data routing and implementing dynamic data selection in AXI peripherals.",
      "description_length": 430,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation function `all` that maps a register structure across a module's input bus, enabling per-channel register propagation. It operates on types `'a M.t Register.I.t` and `'a Register.I.t M.t`, where `M` is a module parameter. It is used to apply register stages to each channel of an input bus in AXI4-Lite or AXI4 memory-mapped interface designs, ensuring correct timing and synchronization.",
      "description_length": 425,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a interface containing monadic values into a monadic interface, effectively lifting the monad out of the interface structure. It operates on data types involving interfaces (`I.t`) and monads (`M.t`), specifically handling values of type `'a M.t I.t` to produce `'a I.t M.t`. A concrete use case is aggregating multiple register fields within an AXI4 interface where each field is wrapped in a monad, allowing them to be manipulated collectively as a single interface under the same monadic context.",
      "description_length": 553,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines and exposes register port metadata, specifically the names and bit-widths of ports, along with associated tags. It provides direct access to lists of port names, port widths, and register tags for introspection or dynamic interface generation. Concrete use cases include generating signal declarations, validating register layouts, and driving automated testbench or documentation tools.",
      "description_length": 407,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps fields of an AXI4 interface to and from an association list, using field names as keys. It operates on `I.t` interface values and string-indexed lists of key-value pairs. Use this to dynamically inspect or construct AXI4 interfaces from named field data, such as for runtime configuration or debugging.",
      "description_length": 328,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module provides functional transformations, structural introspection, and error handling for 32-bit AXI4 register interfaces, enabling tasks like register definition synthesis, memory-mapped field validation, and interface conversion between list and struct representations. Its child modules offer combinational logic, bit-level manipulation, and monadic lifting operations, supporting concrete tasks such as constructing multiplexed register fields, mapping register values to association lists, and extracting port metadata for synthesis. Key data types include `'a I.t` for register interfaces, `comb` for combinational signals, and monadic interface values `'a M.t I.t`, with operations for packing, multiplexing, naming, and validating register fields. Examples include generating constant signal assignments, defining registers with enable signals, dynamically configuring register banks at runtime, and lifting monadic effects across interface structures.",
      "description_length": 968,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 interface signals as packed vectors, enabling tasks like packing/unpacking, multiplexing, concatenation, and register insertion. It works with `Hardcaml.Signal.t` values structured for AXI4, AXI4-Lite, and AXI4-Stream protocols, supporting simulation, RTL generation, and signal connection workflows. Specific use cases include building register banks connected to memory-mapped AXI interfaces, defining named signal interfaces for clarity, and managing stream-based data transfers without address phases.",
      "description_length": 556,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert integer values to bit-level representations, pack and unpack bit vectors, and perform multiplexing and selection operations on 32-bit data paths. It operates on 32-bit wide data structures used in AXI4-Lite register interfaces, specifically for handling register input signals. Concrete use cases include register initialization from integers, bit vector manipulation during register read/write operations, and selecting between multiple register inputs based on control signals.",
      "description_length": 521,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit AXI4-Lite output register interface for synchronous data capture and assignment. It supports register creation with optional enable control, signal assignment within an always block, and wire instantiation with bit-width specification. Use cases include AXI4-Lite peripheral register files, status/control registers, and memory-mapped I/O interfaces in FPGA designs.",
      "description_length": 398,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module facilitates constructing and manipulating 32-bit AXI register interfaces through operations like signal conversion (`of_int`, `pack/unpack`), multiplexing (`mux`, `priority_select`), concatenation, and sequential register control (`pipeline`). It operates on combinational signals and register structures within a 32-bit AXI bus framework, supporting tasks like signal routing, hierarchical naming, and input/output transformation. These capabilities are particularly useful for implementing memory-mapped peripherals or control logic in AXI4-Lite systems where precise data path management and register state handling are critical.",
      "description_length": 644,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for encoding and manipulating AXI4-Lite slave-to-master transactions. It supports signal packing, unpacking, multiplexing, and priority/one-hot selection, working directly with bit vectors and valid-ready handshake protocols. Concrete use cases include constructing and validating AXI4-Lite responses from slave components within a hardware design.",
      "description_length": 400,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master interface signals, including packing, unpacking, multiplexing, and concatenation of data structures. It works with types representing AXI4-Lite interface transactions, using `comb` as the underlying combinational logic type. Concrete use cases include constructing and deconstructing AXI4-Lite request/response signals, selecting between multiple AXI4-Lite data paths based on control signals, and validating signal widths during design elaboration.",
      "description_length": 535,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and registered signal operations for AXI4 register interfaces, including packing/unpacking, multiplexing, concatenation, and priority selection. It manipulates `Signal.t` values within register interface structures to support hardware modeling tasks like data path control, pipeline insertion, and signal routing. These operations are specifically used for low-level register management, input/output handling, and structural transformations in AXI4-based designs.",
      "description_length": 499,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module enables functional manipulation of AXI4 register bank interfaces with validity signals through transformations like mapping, zipping, and folding over `Write_with_valid.t` values. It supports structured register ports with named fields, widths, and tags, and provides conversions between interfaces, lists, and association lists for flexible register bank construction. Submodules handle combinational logic, signal packing/unpacking, multiplexing, and monadic aggregation of write operations, enabling use cases such as dynamic field selection, priority-encoded multiplexing, and atomic register updates. Specific applications include building AXI4-Lite register banks with named signals, validating signal widths, and combining multiple write transactions into structured, valid signal-driven updates.",
      "description_length": 815,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master-to-slave interfaces. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations on interfaces with defined bit widths. Concrete use cases include constructing and validating AXI4-Lite request signals, routing transactions between components, and creating constant or dynamic interface values for simulation or synthesis.",
      "description_length": 439,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a master-to-slave interface and an association list indexed by field names. It operates on transaction data structured with signals such as _valid, _first, and _ready, along with associated data fields. Use this to dynamically map or inspect interface signals by name during simulation or testbench setup.",
      "description_length": 355,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and validate fixed-width bit vector interfaces used in AXI4-Stream datapaths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interface values, and setting fields to constant integers. These capabilities enable precise control over data transport and transformation in streaming hardware designs.",
      "description_length": 402,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic value of a record, specifically for read-enabled interfaces. It works with types involving `'a M.t Read_enable.t`, combining monadic effects across a structure while preserving the read-enable semantics. A concrete use case is aggregating multiple AXI4 register reads into a single monadic operation, enabling sequential or conditional register access patterns based on input conditions.",
      "description_length": 483,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a write interface with valid signal and an association list indexed by field names. It operates on records representing AXI4 register banks, specifically handling write transactions with validity flags. Use cases include serializing register bank writes for testing or debugging, and dynamically constructing write transactions from named field-value pairs.",
      "description_length": 407,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports operations for signal manipulation and state machine construction in AXI4-Lite interfaces, including packing/unpacking, multiplexing, register pipelining, and signal renaming/assignment. It works with `comb` and `t` types representing signal combinators and state machine components, designed for hardware description tasks like connecting AXI4-Lite masters to slaves. Specific use cases include implementing lightweight memory-mapped transactions with minimal logic overhead, such as integrating peripherals in FPGA designs requiring single-address-phase data transfers.",
      "description_length": 592,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a read-enable interface and an association list indexed by field names, using string keys. It operates on the `Read_enable.t` type, which represents AXI4-Lite register banks with read capabilities. Use this module to serialize or deserialize register bank data for debugging, configuration, or integration with external systems that consume key-value representations.",
      "description_length": 415,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of signal ports for a simplified slave-to-master interface protocol. It provides concrete lists of port names, their bit widths, and associated tags used in the internal bus communication. These values are used to construct and manage the signal mappings during transactions between slave and master components in a hardware design.",
      "description_length": 373,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite register bank interfaces, including packing/unpacking signals to vectors, multiplexing and concatenating interfaces, and validation of signal widths. It supports data types such as `comb I.t` for representing register bank fields and `comb` for vector operations, with utilities for constant assignment and width-aware transformations. Concrete use cases include constructing and validating AXI4-Lite register maps, implementing multiplexed register access, and serializing register bank signals for test or integration purposes.",
      "description_length": 608,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables structured manipulation of typed register banks with named hardware ports, supporting bit-level operations, combinational logic, and AXI-connected interface modeling. It provides core data types like `'a O.t` for register interfaces, alongside utilities for transformation, serialization, and error handling. Child modules extend this foundation with specific capabilities: converting register banks to association lists, defining combinational logic for AXI masters, building register banks with Always blocks, aggregating monadic register operations, and manipulating structured signals with explicit naming. Examples include synthesizing control logic via multiplexing and priority selection, mapping register fields to software representations, validating signal widths, and generating testbenches from port metadata.",
      "description_length": 841,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate state machine components for AXI4-Lite slave interfaces, specifically translating AXI transactions into a simplified internal protocol. It works with signals and variables representing AXI4-Lite interface signals, including read and write address, data, and control signals. Concrete use cases include implementing register read/write logic, connecting AXI4-Lite slaves to internal bus structures, and managing handshake protocols for memory-mapped peripherals.",
      "description_length": 521,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Stream interfaces, including packing/unpacking signals, multiplexing, concatenation, and priority/one-hot selection. It works with the `comb` type and structured `t` type representations of AXI4-Stream signals to enable direct hardware modeling. Concrete use cases include building flexible data path logic for routing and transforming AXI4-Stream data in FPGA designs, such as implementing arbiters, crossbars, or packet processors.",
      "description_length": 507,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to internal bus interfaces using the Always API. It supports operations like registering signals with optional enables, creating wire variables with default values, and applying naming conventions to interface fields. These utilities are used when implementing synchronous logic for AXI4-Lite master-to-slave transactions within a hardware design.",
      "description_length": 410,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank interfaces with read enable functionality using a combinatorial logic type. It supports data types including combinatorial signals and register bank interfaces with fields of fixed bit widths. Concrete use cases include building AXI4-Lite register banks with dynamic field selection, implementing multiplexed register access paths, and validating hardware register layouts during design synthesis.",
      "description_length": 471,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides signal-level combinational and sequential operations for manipulating AXI4-Lite slave-to-master interfaces, including packing/unpacking, multiplexing, register pipelining, and signal wiring. It operates on `Internal_bus.Slave_to_master.t` structures composed of `Signal.t` values, with support for handshaking via _valid/_ready signals. These utilities are used to implement hardware designs that interface with AXI4-Lite slaves, enabling tasks like data transfer control, signal routing, and synchronization between master and slave components.",
      "description_length": 566,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between register interfaces and association lists keyed by port names. It operates on register structures that map string identifiers to values of a uniform type. Use this when flattening or reconstructing register states for serialization, debugging, or dynamic configuration.",
      "description_length": 317,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with `t` values representing register banks, where each field is a `comb` signal, and supports constant initialization, width validation, and selection logic. Concrete use cases include constructing and validating AXI4-Lite register banks, implementing dynamic register field updates, and routing register bank signals through multiplexers or priority encoders.",
      "description_length": 520,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a string-keyed association list and a structured interface representation used in AXI4-Lite slave state machines. It operates on data types involving string-labeled records of signal values, enabling explicit mapping between named ports and their associated data. It is specifically used to serialize or deserialize AXI4-Lite interface signals for configuration, debugging, or dynamic construction of hardware components.",
      "description_length": 469,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in the AXI4-Lite slave state machine, providing direct access to signal identifiers and their bit widths. It works with basic data types like strings for port names, integers for widths, and a list of tags representing internal state machine signals. These values are used to generate hardware descriptions that map AXI4-Lite protocol signals to internal bus structures in a synthesisable design.",
      "description_length": 451,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and managing 32-bit AXI register interfaces using combinatorial signals, enabling tasks like signal conversion (`of_int`, `pack`), multiplexing (`mux`, `priority_select`), concatenation, and pipelining. It works with `comb` signals and register interface structures (`t`) to implement hardware logic such as datapath routing, selection circuits, and synchronized register stages. Specific applications include building register-based control logic, signal arbitration, and pipelined data transfer units in memory-mapped AXI4 designs.",
      "description_length": 582,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module enables transformation and traversal of structured register bank interfaces through mapping, folding, and zipping operations on tuples and lists of interfaces. It supports typed interface descriptions (`'a I.t`), conversion between list-based and structured forms, port metadata extraction, and error propagation across register fields, facilitating tasks like AXI4 register bank construction and field offset computation. Submodules handle dynamic field access by name, signal manipulation, AXI-connected logic, bit-vector operations, monadic interface lifting, and metadata definition, enabling concrete applications such as memory-mapped peripheral synthesis, pipelined data path creation, and named signal hierarchy management in hardware designs.",
      "description_length": 763,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.All",
      "library": "hardcaml_axi",
      "description": "Transforms a register structure defined over a bus module into a register structure spanning all elements of the bus. Works with AXI4-Lite and AXI4-Stream interfaces, enabling bulk register operations across memory-mapped or streaming data paths. Useful for configuring or monitoring multiple bus channels simultaneously through a unified register interface.",
      "description_length": 358,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and validate a register bank interface using a combinatorial logic type. It supports packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. Concrete use cases include constructing and verifying memory-mapped AXI4-Lite register banks with fixed field widths and implementing control logic that dynamically selects or combines register interface signals.",
      "description_length": 505,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines port names and widths for AXI4 register banks, providing direct access to signal identifiers and their bit-widths. It works with lists of strings and integers to represent interface signals and their properties. Use this module to generate signal declarations or interface mappings for AXI4, AXI4-Lite, or AXI4-Stream hardware components.",
      "description_length": 358,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream interfaces, including packing/unpacking signals to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with fixed-width signal types represented as `comb` and structured data types conforming to AXI4-Stream protocol, such as `tvalid`, `tready`, and `tdata`. Concrete use cases include building arbitration logic between streaming data sources, implementing data routing logic, and constructing constant or dynamic signal assignments in AXI4-Stream datapaths.",
      "description_length": 581,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate state machine outputs for an AXI4-Lite master interface using Hardcaml's `Always` domain. It works with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types wrapped in the `Master_statemachine.O.t` structure. Use this module to define register assignments, wire connections, and signal naming within the state machine that translates Ibus transactions to AXI4-Lite protocol.",
      "description_length": 440,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert, pack, and unpack AXI4-Lite slave-to-master interface signals to and from bit vectors. It supports operations like multiplexing, concatenation, and priority-based selection of interfaces, with validation of signal widths and utilities for constant initialization. It works directly with `comb` type signals representing hardware bits and structured transaction interfaces framed by valid/ready handshaking.",
      "description_length": 448,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for constructing and manipulating AXI4-Lite slave state machine interfaces using `Bits.t` values. It includes functions for packing/unpacking, multiplexing, concatenation, and priority/one-hot selection of interface signals, along with validation and width manipulation utilities. Concrete use cases include implementing custom AXI4-Lite slave logic, routing data between AXI and internal buses, and building register file interfaces with precise bit control.",
      "description_length": 501,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for structural manipulation and connectivity of AXI4 interface signals in hardware designs. It supports operations like packing/unpacking, multiplexing, register pipelining, and signal concatenation on typed signal interfaces (`O.Of_signal.t`), ensuring correct signal widths and enabling RTL transformations such as validation and constant injection. These capabilities are particularly useful for implementing memory-mapped register banks with AXI4-Lite or managing burst data flows in AXI4-Stream pipelines.",
      "description_length": 541,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite write interfaces with valid signals. It supports multiplexing, concatenation, and selection of register bank interfaces using one-hot or priority-encoded control signals. Key functions include packing/unpacking interfaces to/from bit vectors, validating signal widths, and constructing constant or muxed register values for hardware synthesis.",
      "description_length": 409,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.All",
      "library": "hardcaml_axi",
      "description": "Converts a state machine interface with a specific internal bus type into one compatible with a generic internal bus type. Works with state machine interfaces and internal bus protocols. Useful when adapting AXI4-Lite slave state machines to different internal bus representations without changing their core logic.",
      "description_length": 315,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides functional combinators for transforming and composing 32-bit AXI4 register bank interfaces with valid signals, supporting operations like mapping, folding, and zipping over `Write_with_valid.t` structures. It enables conversion to and from association lists, aggregation of write transactions across registers, and construction of memory-mapped interfaces with synchronous updates using the Always API. The module supports combinational logic for bit-level manipulation, signal routing, and validity-preserving composition, with concrete operations such as packing/unpacking register fields, multiplexing based on control signals, and generating hierarchical register banks with named ports and precise bit-width handling. These capabilities are used to describe AXI4-Lite peripherals, FPGA register configurations, and hardware modules requiring valid/ready signaling.",
      "description_length": 890,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite master state machine signals, including packing, unpacking, multiplexing, and concatenation of signal bundles. It works with bit vectors and valid-ready handshaking protocols to manage data flow in memory-mapped transactions. Concrete use cases include routing AXI4-Lite read/write requests based on address decoding and prioritizing or selecting between multiple AXI4-Lite request sources in hardware designs.",
      "description_length": 489,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and manipulation of register banks with read-enable functionality by combining structural transformations, combinational logic, and interface routing. It supports key operations like lifting monadic actions across register structures, packing/unpacking fields to bit vectors, multiplexing, concatenation, and mapping named register fields to association lists. Data types such as `Read_enable.t`, `comb`, and `Signal.t` underpin use cases including AXI4-Lite register aggregation, dynamic field selection, and memory-mapped peripheral design. Submodules enhance this capability with bit-level control, port metadata handling, and structured signal routing for high-throughput register banks.",
      "description_length": 728,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-Lite master state machines into a single combined state machine, operating over a shared interface. Works with polymorphic state machine types parameterized by a module `M`, enabling structured control flow for AXI4-Lite transactions. Useful for coordinating multiple AXI4-Lite masters into a unified control path during hardware synthesis.",
      "description_length": 370,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "This module constructs and configures a demultiplexer for routing AXI4-Lite transactions from a single master to multiple slaves, managing address decoding and signal routing based on slave address ranges. It enables the creation of memory-mapped register banks where each slave handles a distinct address region, with support for defining and connecting individual slave instances through its child module. The child module allows precise control over master-to-slave and slave-to-master signal interfaces, facilitating complex hardware designs with multiple peripherals. Example usage includes implementing a system where a CPU core (master) communicates with multiple memory-mapped devices (slaves) through a single AXI4-Lite bus.",
      "description_length": 733,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a slave-to-master interface and an association list indexed by field names, enabling straightforward access and manipulation of interface fields by name. It operates on the `Internal_bus.Slave_to_master.t` type, which represents a simplified read/write protocol with validity and readiness signals. Use this to dynamically inspect or construct slave-to-master transactions by field identifiers, such as during debugging, configuration, or runtime composition of interface values.",
      "description_length": 527,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-Lite master state machines into a single unified state machine by aggregating their input signals. It operates on `Master_statemachine.I.t` values, which represent the input interface of an AXI4-Lite master state machine. This function is useful when coordinating multiple AXI4-Lite masters into a single control path, such as in a bus multiplexer or arbitration logic.",
      "description_length": 399,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unchecked access to register fields by string name, enabling dynamic manipulation of register values through associative list conversions. It operates on register structures that map string identifiers to values of a given type, supporting construction and deconstruction via `of_alist` and `to_alist`. Concrete use cases include runtime configuration of AXI register interfaces and inspection of register states during simulation or debugging.",
      "description_length": 473,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register interfaces, including packing, unpacking, multiplexing, concatenation, and priority/one-hot selection. It works with 32-bit data and address buses, supporting operations such as `mux`, `concat`, and `priority_select` for constructing and validating register-based datapaths. Concrete use cases include building AXI4-Lite register maps, handling AXI burst transfers, and implementing control/status registers in hardware designs.",
      "description_length": 517,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential logic operations for managing AXI4-Lite master state machines, including signal packing/unpacking, multiplexing, pipeline control, and state assignment. It operates on hardware signals (`Hardcaml.Signal.t`) encapsulated in a structured interface, enabling precise manipulation of AXI4-Lite transactions with support for branching and validation. These capabilities are used to implement efficient memory-mapped communication bridges between Ibus and AXI4-Lite protocols in hardware designs.",
      "description_length": 540,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit register data in AXI4-Lite memory-mapped interfaces. It supports operations like packing, unpacking, multiplexing, concatenation, and priority/one-hot selection on 32-bit wide data paths, specifically for use in hardware description and register transfer level design. Concrete use cases include constructing register file datapaths, implementing control logic for AXI4-Lite peripherals, and managing data routing in FPGA soft cores.",
      "description_length": 509,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite slave-to-master interfaces. It supports signal validation, packing/unpacking, multiplexing, and selection functions for working with memory-mapped transactions in hardware designs. Concrete use cases include constructing and validating AXI response signals, routing slave responses to masters, and generating constant or multiplexed interface values for simulation or synthesis.",
      "description_length": 457,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to convert between integer values and bit-level representations of register data, supporting tasks like packing and unpacking register fields into bit vectors. It works with types such as `comb` (bit vectors) and `t` (register structures built from bit vectors), enabling precise bit-level manipulation and selection logic. Concrete use cases include constructing register layouts for AXI4-Lite interfaces, implementing multiplexing logic for register inputs, and validating bit widths during hardware compilation.",
      "description_length": 546,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-Lite master state machine components and string-labeled ports using an association list. It supports conversion to and from a list of string-value pairs, enabling direct access to specific hardware ports by name during simulation or testing. This is useful for debugging and traceability in AXI4-Lite bus transactions.",
      "description_length": 336,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a write interface with valid signals into a monadic structure, allowing sequential composition of AXI4 write operations. It works with AXI4 memory-mapped interfaces that include valid signals for data synchronization. A concrete use case is coordinating multiple AXI4 write transactions with validity checks in hardware designs, ensuring data is written only when valid.",
      "description_length": 424,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation that distributes a given monadic value across all fields of a 32-bit AXI register interface, effectively enabling per-field customization of register behavior. It operates on register interfaces with 32-bit data and address buses, specifically within the context of AXI4-Lite and AXI4 memory-mapped protocols. A concrete use case includes applying individualized read or write side-effects to each register field during hardware synthesis in Hardcaml-based designs.",
      "description_length": 503,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the interface for a registered AXI4-Stream datapath by specifying port names, widths, and tags. It provides concrete signal definitions for AXI4-Stream handshake signals (tvalid, tready) and associated data channels, ensuring correct synchronization and data transfer. Use this when implementing or verifying AXI4-Stream compliant modules that require registered outputs for timing and protocol compliance.",
      "description_length": 426,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with types `comb` and `t` representing combinational signals and register interface values. Concrete use cases include constructing and validating register paths, selecting between multiple register inputs based on priority or one-hot encoding, and converting between integer values and register representations.",
      "description_length": 494,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of the signals in the datapath register interface for AXI4-Stream. It provides concrete values for signal names, their bit widths, and associated tags used during the streaming data transfer. These values are essential for generating correct signal declarations and ensuring proper handshake protocol implementation in AXI4-Stream components.",
      "description_length": 383,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign signal values within an always block, specifically for register and wire variables in an interface. It supports operations like creating register containers with optional enable signals, assigning signals to variables, and applying naming conventions to interface fields. Use cases include building AXI4-Lite control registers with named fields and managing signal assignments in a structured interface.",
      "description_length": 459,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite slave state machine signals. It supports data type conversions, signal packing/unpacking, multiplexing, and selection logic for integrating AXI4-Lite interfaces with internal bus protocols. Concrete use cases include building register maps, handling memory-mapped I/O, and routing AXI4-Lite transactions in FPGA designs.",
      "description_length": 399,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream interfaces, including multiplexing, priority selection, concatenation, and packing/unpacking of data signals. It works with registered AXI4-Stream datapath interfaces, ensuring correct signal handshaking and width validation. Concrete use cases include building flexible data routing logic, merging multiple AXI4-Stream sources into one, and constructing complex data paths with dynamic selection based on valid/ready signaling.",
      "description_length": 496,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential logic operations for implementing AXI4-Lite slave state machines, including signal packing/unpacking, multiplexing, priority selection, and register pipelining. It operates on `Hardcaml.Signal.t` values structured within a record-based framework, enabling precise control over signal branching, validation, and bit-width management. These capabilities are used to translate AXI4-Lite protocol interactions into simplified internal bus operations, while supporting named signal assignment with customizable naming conventions for hardware design clarity.",
      "description_length": 603,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate signals within a slave state machine for AXI4-Lite interfaces. It supports signal assignment, register creation, and naming of internal variables, working with types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`. Concrete use cases include implementing register logic and control paths that interface with AXI4-Lite slaves, such as configuring hardware registers or managing read/write transactions.",
      "description_length": 471,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register data in AXI4 bus interfaces. It supports values of type `comb` and `t`, enabling bit-level operations like packing, unpacking, concatenation, and multiplexing, along with validation and width assertion. Concrete use cases include constructing and decoding AXI4 register fields, handling data routing in AXI bus multiplexers, and implementing control logic for AXI register transactions.",
      "description_length": 464,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between register interfaces and association lists, enabling straightforward serialization and deserialization of register state by port name. It operates on 32-bit AXI4-Lite register interfaces, mapping each register to a named entry in a list. Use this when debugging, initializing, or dynamically reconfiguring register values through named ports in a memory-mapped system.",
      "description_length": 415,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module transforms and traverses 32-bit AXI register bank interfaces with read-enable logic, supporting structural operations like zipping, folding, and conversion between lists and interfaces. It provides combinational logic for constructing, validating, and multiplexing register banks, along with utilities for naming, wiring, and dynamically accessing register fields by string keys. Operations include bit vector packing, signal sequencing across interfaces, and field-level configuration, enabling tasks like register bank instantiation, testbench scripting, and AXI4-Lite peripheral design. Submodules handle low-level port definitions, monadic effect sequencing, and direct RTL wiring with explicit read enable signals.",
      "description_length": 731,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in an AXI4-Lite master-to-slave interface. It provides concrete lists of port names, their corresponding bit widths, and a list of tags representing individual signal fields. These values are used to describe the interface structure for simulation, testing, or integration with hardware description tools.",
      "description_length": 360,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI slave-to-master signal interfaces, including constant assignment, multiplexing, packing/unpacking, and structural validation. It works with combinational (`comb`) and registered (`t`) AXI slave-to-master signal types, enabling bidirectional signal connections and hierarchical naming. These capabilities are used to implement memory-mapped AXI4-Lite or AXI4 interfaces where slave devices respond to master transactions, ensuring correct signal encoding and synchronization.",
      "description_length": 544,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating slave-to-master AXI interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb` signals and `Slave_to_master.t` interface types, enabling direct bit-level transformations and routing. Concrete use cases include building AXI4 multiplexers, constructing constant test interfaces, and validating signal widths during hardware compilation.",
      "description_length": 460,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Lite master-to-slave interfaces represented as bit vectors. It supports operations such as packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. These capabilities are used to build and control memory-mapped communication paths in hardware designs.",
      "description_length": 414,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for mapping, zipping, and folding structured register interfaces, integrating operations to convert register data to and from lists and S-expressions. It supports hardware registers with tagged fields, port names, and bit-width metadata, enabling combinational logic construction and error handling for AXI4-Lite and AXI4-Stream designs. Child modules enhance this functionality by offering direct register manipulation, signal combinators, port metadata access, and bit-level conversions, supporting tasks like dynamic configuration, control logic construction, and interface validation. Examples include creating named registers with enable signals, packing register fields into bit vectors, validating AXI data paths, and generating testbenches from register layouts.",
      "description_length": 803,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O",
      "library": "hardcaml_axi",
      "description": "This module organizes tagged signal bundles for AXI4-Lite master state machines, enabling structural transformations, introspection, and mapping across tuples and lists of signal groups. It supports operations like zipping, combinational logic synthesis, and port metadata extraction, working alongside child modules that handle bit-level control, signal routing, and state machine composition. You can bridge Ibus masters with AXI4-Lite peripherals, generate RTL with consistent naming, and manage burst transactions using combinators and stateful components. Specific capabilities include multiplexing signal vectors, synthesizing control logic with one-hot encodings, and combining multiple AXI4-Lite masters into a shared interface.",
      "description_length": 736,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential signal manipulation operations for AXI master-to-slave interfaces, including bit-width-aware packing/unpacking, multiplexing, concatenation, and register insertion. It operates on `Master_to_slave.t` interfaces composed of `Hardcaml.Signal.t` values, ensuring correct RTL-level behavior for memory-mapped or streaming data paths. These utilities are used to implement AXI4, AXI4-Lite, or AXI4-Stream interfaces with precise signal wiring, hierarchical naming, and bidirectional connectivity in hardware designs.",
      "description_length": 561,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module transforms and composes AXI register interfaces with validity flags, enabling structured manipulation of write operations through mapping, zipping, and list-to-structure conversions. It centers on `Write_with_valid.t`, a type that bundles write data and valid signals, and supports operations like packing/unpacking, multiplexing, and selection, often using bit vectors or priority-encoded controls. Submodules extend this core with combinational logic, signal routing, register creation using Always blocks, and port definitions that enforce correct signal widths and naming. Examples include building AXI4-Lite register banks, dynamically constructing named write transactions, and sequencing valid-dependent writes using monadic composition.",
      "description_length": 756,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports the creation and manipulation of AXI4-Lite slave-to-master interface signals within a 32-bit memory-mapped bus framework. It operates on combinational signal types (`comb`) to implement core logic operations like multiplexing, concatenation, and validation, while enabling structured signal wiring and naming conventions. It is particularly useful for lightweight peripheral control or register interfaces where simplicity and strict alignment with AXI4-Lite's single-transaction semantics are prioritized over burst capabilities.",
      "description_length": 551,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I",
      "library": "hardcaml_axi",
      "description": "This module orchestrates register interface management within AXI4-based hardware designs, integrating creation, transformation, and signal manipulation capabilities. It supports structured data path operations through combinational logic, bit-level conversions, and port metadata handling, enabling tasks like register routing, dynamic selection, and AXI4-Lite slave configuration. Key data types include `t`, `comb`, and signal-based representations, used alongside integers and bit vectors for precise control over register fields and widths. Functionality spans from low-level signal transformations to structured register propagation across channels, supporting use cases such as pipeline insertion, burst transaction handling, and register state serialization.",
      "description_length": 766,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of the data and control signals for an AXI4-Stream destination interface. It provides concrete signal metadata such as port names, bit widths, and associated tags, used in hardware construction and simulation. These values are essential for generating correct interface declarations and for tooling that relies on signal metadata, like waveform viewers or netlist generators.",
      "description_length": 416,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure of AXI4-Stream source interfaces by specifying port names and their corresponding bit widths. It provides concrete values for retrieving port names, widths, and tags associated with the stream source configuration. This enables direct mapping of signal names and sizes to hardware description code for AXI4-Stream data sources.",
      "description_length": 361,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformations and synchronous signal processing for AXI4-Lite slave interfaces, handling memory-mapped transactions with single-cycle bursts over structured tagged port representations (`t`), signal streams, and bit-level encodings. It supports protocol conversion, register mapping, and synchronization through combinational logic, multiplexing, and stateful register assignments, with operations for packing, unpacking, and priority selection on AXI4-Lite signals. Submodules unify multiple slave state machines into a single interface, map signals to named ports, define port widths, and implement lightweight memory-mapped interfaces with minimal logic overhead. Examples include constructing register banks, bridging AXI4-Lite to internal protocols, and managing control/status registers using bit-level operations and dynamic signal inspection by name.",
      "description_length": 891,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.State",
      "library": "hardcaml_axi",
      "description": "This module defines the state machine states used to manage AXI4-Lite slave transactions, converting them to and from an internal bus protocol. It provides operations to convert states to and from integers and S-expressions, along with string representations. It is used to track and serialize the progression of AXI4-Lite read and write operations within a hardware design.",
      "description_length": 374,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation of simplified AXI4-Lite master-to-slave interfaces, focusing on signal transformation, port metadata access, and combinational logic construction. It operates on interface values framed by _valid/_first signals, handling data/address bus widths and port attributes like names and bit widths, while child modules extend its capabilities with bit-level operations, signal routing, and transaction composition. You can build complex bus logic, route transactions between components, generate RTL signal declarations, and compose monadic signal computations, all while maintaining alignment with AXI4-Lite transaction semantics. Specific uses include FPGA control plane development, testbench creation, and synthesis-friendly interface construction with constant or dynamic signal sources.",
      "description_length": 829,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Stream destination interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works with data types such as `Always.Variable.t`, `Signal.t`, `Reg_spec.t`, and string-based identifiers, specifically for hardware design tasks involving AXI4-Stream protocols. Use cases include constructing and managing AXI4-Stream destination interfaces in a register-transfer level (RTL) design, assigning control and data signals within always blocks, and ensuring consistent naming for simulation or synthesis purposes.",
      "description_length": 711,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformations over 32-bit AXI register interfaces, supporting operations like mapping, folding, and combining structured data such as tuples and tagged register values. It provides utilities for constructing register banks with bit-level precision, generating address-decoded logic, and handling metadata like field widths and error conditions. Submodules offer combinational logic for data manipulation, register-to-association-list conversion, bit-level packing and unpacking, and synchronous register assignment, enabling tasks like control/status register implementation, memory-mapped I/O management, and datapath synthesis in AXI4-Lite systems. Specific capabilities include flattening register interfaces, converting between integer and bit-level representations, and building hierarchical register structures with named ports and behavioral tags.",
      "description_length": 887,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit master-to-slave AXI interfaces using the Always API, including variable assignment, register creation, and signal naming. It works with `Hardcaml_axi.Internal_bus.W32.Master_to_slave.t` interface containers composed of `Always.Variable.t` and `Signal.t`. Concrete use cases include building and wiring AXI-compliant memory-mapped interfaces with registered or combinational signals, such as connecting a CPU to peripherals or managing DMA transfers.",
      "description_length": 501,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module implements a memory-mapped register bank with AXI4-Lite compliant read and write control logic, generating signals for pipelined register access with configurable delays. It defines core data types like `comb`, `t`, and tagged field structures to model register interfaces, supporting operations such as mapping, zipping, and monadic aggregation across register sets. Child modules extend this functionality with dynamic field access, error handling, and hierarchical routing, enabling tasks like constructing debuggable register maps and bridging peripherals with software interfaces. You can define register banks with precise bit-widths, validate signal widths, and coordinate multi-register transactions while maintaining protocol compliance.",
      "description_length": 758,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine to manage the data path of an internal bus, handling read and write transactions over AXI4-Lite compatible interfaces using valid, first, and ready signals. It supports hierarchical bus structures with write response signaling and configurable timeouts, while its child modules provide combinators for manipulating register interfaces, including map, fold, zip, and bit-level operations. Core data types like `t`, `comb`, and `Reg_spec.t` model register states, combinational logic, and signal assignments, enabling tasks such as decoding bus signals, dynamically configuring registers by name, and constructing control registers with precise bit-widths. Examples include synthesizing memory-mapped register transactions, managing multi-channel register slices, and implementing AXI4-Lite slave interfaces with structured signal mappings.",
      "description_length": 877,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in a 32-bit master-to-slave interface derived from AXI4 specifications. It provides direct access to port metadata through lists of string-name and integer-width pairs, individual port names, and widths. These values are used to describe interface signals for hardware synthesis and simulation, specifically mapping AXI4 master transactions to simpler slave interfaces.",
      "description_length": 424,
      "index": 277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module facilitates signal manipulation and interface bridging for AXI4-Lite slave-to-master communication, offering combinational logic operations (e.g., packing/unpacking, multiplexing, concatenation) and sequential elements like pipeline registers. It operates on AXI4-Lite signal structures (`comb` for combinational logic and `t` for interface signals), enabling efficient translation between hardware description primitives and AXI4-Lite protocol requirements. Use cases include FPGA-based system designs where lightweight memory-mapped interfaces connect peripherals to processors, requiring precise signal routing and synchronization.",
      "description_length": 646,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation of AXI4-Stream interfaces with a focus on registered datapath operations, consistent tagging, and handshake protocol enforcement. It operates on `'a Datapath_register.I.t` types, which encapsulate AXI4-Stream signals and support bit-level composition, list conversions, and error handling, allowing synchronization of producer-consumer components, implementation of register-based AXI stream modules, and management of signal metadata. Submodules provide combinational logic for signal manipulation, monadic composition of stream structures, register and wire interface creation, and fixed-width bit vector operations, enabling concrete use cases like stream multiplexing, pipelining, and FPGA-based data path routing. Named signal conversions, interface packing, and signal width validation ensure synthesis-friendly hardware descriptions with precise control over data transport.",
      "description_length": 925,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a slave-to-master interface containing monadic values into a monadic value containing a slave-to-master interface. It works with AXI4-compatible data structures, specifically handling transactions and responses in a memory-mapped context. Use this to sequence multiple AXI4 slave responses into a single master transaction, such as aggregating burst read responses into a unified result.",
      "description_length": 441,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a slave-to-master interface containing monadic values into a monadic value containing a slave-to-master interface. It works with AXI4-Lite slave-to-master signal types wrapped in a monad `M`, allowing sequencing of monadic actions across all signals in the interface. A concrete use case is lifting a collection of register-read operations into a single monadic action that reads all register values at once.",
      "description_length": 462,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for converting, packing, and unpacking master-to-slave AXI interface signals. It supports multiplexing, concatenation, and selection logic for AXI interfaces with functions like `mux`, `concat`, and `priority_select`. These operations are used to manipulate AXI signals in hardware descriptions where precise control over data paths and signal widths is required.",
      "description_length": 405,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to AXI master-to-slave interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. These functions are used to build and manage AXI-compliant interface logic within hardware description code.",
      "description_length": 365,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit AXI master-to-slave signals through operations like packing, multiplexing, register pipelining, and bidirectional signal wiring, alongside utilities for naming interfaces with customizable prefixes. It operates on combinatorial signals and structured interface types to enable RTL generation and validation for AXI4-Lite and AXI4 memory-mapped communication. Use cases include designing and connecting hardware interfaces that manage address phases, data transfers, and burst transactions in memory-mapped systems.",
      "description_length": 566,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for a 32-bit AXI4 slave-to-master interface. It provides concrete lists of port names, widths, and associated tags used during AXI response encoding. These values are used directly when mapping internal signals to AXI-compliant interface definitions.",
      "description_length": 298,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a master-to-slave interface containing monadic values into a monadic value containing a master-to-slave interface. It works with AXI4-Lite master-to-slave transaction types wrapped in a monad. A concrete use case is combining multiple AXI4-Lite read or write operations into a single monadic structure for sequential execution.",
      "description_length": 381,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a simplified master-to-slave interface derived from AXI4. It supports signal packing/unpacking, multiplexing, concatenation, and selection logic, working with a record-based interface that includes fields like address, data, and control signals. Use cases include building custom bus multiplexers, routing AXI-like transactions, and validating signal widths in hardware description code.",
      "description_length": 456,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in a slave-to-master AXI interface conversion. It provides direct access to port metadata as lists of strings and integers, along with a list of tags representing transaction identifiers. It is used to map internal bus signals to AXI-compliant responses with precise bit-width and naming information.",
      "description_length": 355,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module enables functional manipulation of AXI4 register bank read-enable signals through combinators and transformations, supporting mapping, zipping, folding, and scanning over structured port configurations. It operates on types like `comb` and `t`, representing hardware signals and register interfaces, and includes operations for packing/unpacking, multiplexing, concatenation, and pipeline creation, with support for signal naming, field tagging, and bit-width validation. Submodules enhance this core functionality by adding monadic aggregation, key-value serialization, interface construction, and combinational logic handling, enabling tasks such as synthesizing AXI4-Lite register maps, optimizing pipelined data paths, and generating debuggable, named signal hierarchies. Specific applications include dynamic register selection, multiplexed access control, and converting between structural and vector representations for synthesis and simulation.",
      "description_length": 964,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of signal ports used in a simplified master-to-slave bus interface derived from AXI4. It provides direct access to signal metadata such as port names, widths, and associated tags, enabling precise signal handling and interface generation. It is used to configure and manage the data signals passed between master and slave components in a memory-mapped bus system.",
      "description_length": 405,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Stream destination interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating multiple interfaces, and validating signal widths. Concrete use cases include constructing and validating AXI4-Stream destination logic, routing data streams using priority or one-hot selection, and initializing interfaces with constant values for hardware synthesis.",
      "description_length": 484,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit master-to-slave AXI interfaces, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions with support for valid signals and one-hot/priority encoding. It works with 32-bit wide AXI master-to-slave signals represented using the `comb` type from the `Comb` module. Concrete use cases include constructing and validating AXI request signals, routing AXI transactions between components, and implementing arbitration logic for AXI-based memory-mapped systems.",
      "description_length": 576,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation of AXI4 interface components through a suite of combinators that support mapping, conversion, and comparison of interface values with precise handling of port names, bit widths, and tag-based associations. It provides core operations for working with `'a I.t` structures\u2014such as iteration, list conversion, and error propagation\u2014while integrating with register bank generation via procedural extraction and width tracking. Child modules extend this foundation with specialized functionality: combinational logic for signal manipulation, port metadata handling, register bank bit vector operations, monadic interface transformation, association list mapping, packed vector operations, AXI4-Lite register logic, and always-block signal assignment. These tools enable concrete use cases like synthesizing register banks from behavioral code, constructing memory-mapped I/O interfaces, dynamically configuring AXI4 components, and ensuring type-safe transformations across combinational and sequential logic.",
      "description_length": 1048,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "This module routes transactions from a single master interface to multiple slaves based on address decoding, using signals and lists of signals to manage communication. It supports the creation of memory-mapped register banks where each slave handles a specific address range, allowing a master like a CPU core to communicate with multiple peripherals over a single AXI4-Lite bus. Child modules enable defining and connecting individual slaves, specifying address regions, and controlling signal routing with fine-grained interface management. Example use cases include demultiplexing AXI4-Lite transactions to multiple memory-mapped devices, with each slave handling its own address space and signal paths.",
      "description_length": 707,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple destination interfaces into a single interface, lifting the monadic structure outside. It operates on destination interfaces with a monadic type `M`. A concrete use case is aggregating separate AXI4-Stream destination channels into a unified channel for synchronized data handling.",
      "description_length": 342,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to `Slave_to_master` interface signals using the `Always` API. It supports creating registers, wires, and named signal fields for AXI4-Lite and AXI4 memory-mapped interfaces. Use cases include building synchronous logic blocks that interface with AXI slaves, such as register banks or memory controllers, by abstracting signal assignment and naming.",
      "description_length": 412,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit AXI slave-to-master interfaces using the Always API, including variable assignment, register and wire creation, and signal naming. It works with `Hardcaml_axi.Internal_bus.W32.Slave_to_master.t` interface values containing `Always.Variable.t` elements. Use cases include building and managing AXI-compliant hardware blocks with registered or combinational signals, such as memory-mapped peripherals or data path components.",
      "description_length": 475,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions like priority and one-hot decoding. It works directly with `comb`-typed signals and structured interface types containing valid/ready handshaking signals. Concrete use cases include building control logic for memory-mapped peripherals, routing AXI4-Lite transactions between multiple masters and slaves, and synthesizing constant or dynamic AXI4-Lite responses.",
      "description_length": 557,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple AXI4-Stream source interfaces, each wrapped in a monadic context, into a single interface where the monad is lifted outside. It operates on data types involving AXI4-Stream source ports and is useful for synchronizing and aggregating multiple data streams into a unified structure. A concrete use case includes merging several independent AXI4-Stream sources into a single interface for batch processing or parallel data handling.",
      "description_length": 491,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Stream source interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. These capabilities are used to implement AXI4-Stream data sources with precise control over signal behavior and naming in hardware designs.",
      "description_length": 416,
      "index": 300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Stream source interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from vectors, multiplexing, concatenation, and selecting between sources using priority or one-hot encoding. Concrete use cases include constructing and validating AXI4-Stream source signals, dynamically routing data streams, and embedding AXI-Stream interfaces in hardware descriptions.",
      "description_length": 450,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module transforms and composes AXI4-Lite slave-to-master interface values, offering data mapping, structural manipulation, and signal encoding for AXI transactions. It supports operations on structured signal groups, bit vectors, and association lists, handling validity and transaction framing via `_valid` and `_first` signals. The child modules enable always-block assignments, monadic aggregation of responses, combinational encoding, port configuration, signal wiring, bit vector conversions, named field access, and logic validation. Together, they implement AXI4-Lite slave logic that encodes responses, routes transactions, and ensures compatibility with the single-cycle protocol through signal packing, multiplexing, and handshake management.",
      "description_length": 757,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate AXI4-Lite slave-to-master interfaces represented as bit vectors. It supports constant assignment, packing/unpacking to and from bit vectors, multiplexing, concatenation, and priority/one-hot selection between interfaces. These operations are used to implement control logic and data routing in AXI4-Lite memory-mapped hardware designs.",
      "description_length": 406,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "This module constructs and manages a demultiplexer for routing AXI4 transactions from a single master to multiple slaves based on address decoding, integrating directly with AXI4 signal types and Hardcaml's register specifications to generate control logic. It defines key data types such as `Hardcaml.Signal.t Master_to_slave.t` and `Hardcaml.Signal.t Slave_to_master.t`, enabling precise signal interface management between master and slaves. Child modules allow configuration of individual slave instances, supporting operations like signal assignment and retrieval to connect slaves within a memory-mapped bus hierarchy. Example usage includes implementing a memory-mapped system where a CPU routes memory accesses to distinct peripherals based on their address ranges.",
      "description_length": 773,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformations and aggregations over AXI interface structures and hardware signals, supporting operations like mapping, zipping, folding, and combining values of type `'a t`. It works with AXI4 interface descriptions, register banks, and signal-based data representations, allowing type-safe manipulation of field positions, list structures, and signal aggregations. Child modules provide combinational logic for signal routing, serialization and deserialization of register banks via association lists, structured signal assignment in always blocks, and structural transformations of monadic records and tuples. Additional utilities support bit vector manipulation, port width validation, and RTL-level connectivity for AXI4-Lite and AXI4-Stream designs, enabling tasks like dynamic register updates, control logic selection, and pipeline construction.",
      "description_length": 885,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI master-to-slave interface signals. It supports signal packing/unpacking, multiplexing, concatenation, and selection based on valid bits and one-hot encoding. The module works with fixed-width bit vectors and structured interface types to enable precise signal routing and control in AXI-based hardware designs.",
      "description_length": 383,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Stream source interfaces. It supports data transformations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection operations including priority and one-hot selection. These functions are used to build and validate AXI4-Stream source signals with precise bit-width control, enabling direct hardware synthesis and verification.",
      "description_length": 462,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly converts between a 32-bit AXI slave-to-master interface and an association list indexed by field names. It provides `to_alist` to serialize interface signals into named key-value pairs and `of_alist` to reconstruct the interface from such a list. This supports dynamic configuration or inspection of AXI signals using string-based field identifiers.",
      "description_length": 370,
      "index": 308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating AXI4-Lite slave-to-master interfaces. It supports signal packing, unpacking, multiplexing, and concatenation, along with validation and width assertion for interface signals. Use cases include building and transforming AXI4-Lite register maps, implementing control/status registers, and routing AXI-Lite transactions in FPGA designs.",
      "description_length": 417,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and bit widths for AXI4-Lite slave-to-master interface ports. It provides concrete lists of port names, widths, and tags used to construct and identify interface signals in hardware descriptions. These values are used directly when creating signal groups or wiring components in AXI4-Lite slave-to-master communication logic.",
      "description_length": 362,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO",
      "library": "hardcaml_axi",
      "description": "This module orchestrates structural transformations and combinational logic synthesis for AXI4-Stream interfaces with registered outputs, supporting operations like mapping, zipping, and bidirectional conversion between list-based and signal-based representations. It enables signal manipulation through functions for packing, multiplexing, concatenation, and priority selection, operating on types like `Datapath_register.IO.t` and `Bits.t` to enforce tvalid/tready handshaking and support high-throughput streaming pipelines. Submodules allow lifting monadic structures, converting interfaces to association lists, defining register and wire interfaces with the Always API, and creating combinational logic for data routing and arbitration. Examples include synchronizing concurrent AXI4-Stream register stages, dynamically routing signals by name, and constructing validated AXI pipelines with constant or controlled signal assignments.",
      "description_length": 939,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for encoding and manipulating 32-bit AXI slave-to-master interface signals. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations with support for one-hot and priority-encoded control signals. Concrete use cases include constructing AXI response encodings from slave components, validating signal widths, and routing AXI data paths using constant or dynamic control signals.",
      "description_length": 464,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables construction and manipulation of AXI4-Lite master-to-slave interfaces through signal operations like constant assignment, multiplexing, pipeline insertion, and interface packing/unpacking. It operates on combinational signal structures representing AXI4-Lite transactions, supporting use cases such as memory-mapped register access and control path implementation in hardware designs. Key features include bidirectional signal connection, hierarchical naming conventions, and selection logic for interface composition.",
      "description_length": 538,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module creates and manipulates AXI4-Lite master-to-slave interfaces using association lists keyed by field names. It converts interface values to and from string-indexed lists of field data. Use this when dynamically constructing or inspecting AXI4-Lite transactions with named fields, such as during testbench setup or runtime configuration.",
      "description_length": 347,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Lite slave-to-master interfaces using the Always API, enabling direct signal assignment, register creation, and naming of interface fields. It works with `Slave_to_master.t` interface containers composed of `Always.Variable.t` elements, representing hardware signals in a design. Concrete use cases include building AXI4-Lite slave logic that drives master interface signals, such as responding to read/write requests and managing handshake protocols.",
      "description_length": 501,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing/unpacking, multiplexing, concatenation, and selection functions. It works with the `comb` type and `t` records containing integer or signal fields. Concrete use cases include constructing and validating AXI4-Lite control paths, routing data between AXI4-Lite components, and generating constant or conditional interface values.",
      "description_length": 446,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps fields of an AXI slave-to-master interface to and from association lists using string keys, enabling straightforward serialization and deserialization of interface signals. It operates on `Slave_to_master.t` and string-indexed key-value pairs, facilitating dynamic signal manipulation and configuration. Concrete use cases include generating debug representations, dynamically constructing AXI responses, and mapping interface fields to external data sources like configuration files or runtime parameters.",
      "description_length": 532,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and manipulation of AXI4-Stream source interfaces using combinational signals, offering functions for validation, packing/unpacking, multiplexing, and signal routing. It operates on AXI4-Stream signals and interface configurations, facilitating use cases such as high-throughput data pipelines and FIFO-based communication where address phases are unnecessary. The module also supports structural design tasks like signal naming, connection management, and pipelining to integrate seamlessly into hardware workflows.",
      "description_length": 553,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a RAM with per-byte write enables and configurable size, designed for use in AXI4-Lite slave interfaces. It supports read and write transactions via a simplified internal bus protocol, using signals for validity, readiness, and first-cycle indication. The `create` function instantiates the RAM given a register specification, master input signals, and size, while `sexp_of_t` provides S-expression serialization for debugging or configuration purposes.",
      "description_length": 476,
      "index": 319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.Pipeline_stage_descr",
      "library": "hardcaml_axi",
      "description": "This module describes a single pipeline register stage within a fully registered AXI4-Stream datapath. It defines the configuration for a register, including an optional instance name and a clear signal, to be used in pipelining AXI4-Stream signals. It is used to insert registered stages between AXI4-Stream components while maintaining correct handshake protocol behavior.",
      "description_length": 374,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream destination interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types representing hardware signals and `Dest.t` interface descriptions. Concrete use cases include constructing and validating AXI4-Stream destination logic, routing data streams based on control signals, and assembling/disassembling interface vectors for hardware synthesis.",
      "description_length": 480,
      "index": 321,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream destination interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and selecting between multiple streams using priority or one-hot encoding. It works directly with the `comb` type representing combinational signals and `t` as the destination interface type. Concrete use cases include constructing complex stream routing logic, validating signal widths, and implementing stream multiplexers or demultiplexers in hardware designs.",
      "description_length": 548,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I",
      "library": "hardcaml_axi",
      "description": "This module manipulates tagged data representations of AXI4-Lite slave interface signals through structural and combinational operations, enabling protocol conversion and state machine logic. It operates on polymorphic tagged structures (`'a t`), association lists mapping ports to values, and bit-width definitions, supporting functions like `pack`, `mux`, and `concat` for signal transformation and routing. Child modules provide concrete signal names and widths, bit-level operations, combinational logic for state transitions, and conversions between structured and associative representations. Specific applications include synthesizing control logic for AXI4-Lite peripherals, adapting state machines to different internal bus types, and constructing register interfaces with precise bit-level and signal management.",
      "description_length": 822,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI master-to-slave interface fields to values using string keys, enabling dynamic access and construction of interface signals by port name. It operates on association lists pairing strings with arbitrary values, specifically supporting the `Master_to_slave.t` type for AXI signal routing. Use it to programmatically wire or inspect AXI signals by name without static field accessors.",
      "description_length": 411,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a master-to-slave interface and an association list indexed by field names, using `to_alist` and `of_alist`. It operates on 32-bit AXI4 master-to-slave interface values, enabling straightforward mapping to and from named fields. Use this when you need to dynamically construct or inspect interfaces by field name, such as in testbenches or configuration systems.",
      "description_length": 410,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank with AXI4-Lite compatible interfaces for hardware configuration and control, supporting operations like address definition, write data handling with validity signals, and pipelined read responses. It enables structured manipulation of typed register banks with named ports through transformations, combinational logic, and bit-level operations, allowing tasks like dynamic field selection, priority-encoded multiplexing, and atomic updates. Concrete data types such as `'a O.t`, `Read_enable.t`, and `Signal.t` facilitate mapping register fields to software representations, synthesizing control logic, and generating testbenches from port metadata. Use cases include building memory-mapped peripherals, validating signal widths, and aggregating AXI4-Lite register transactions into structured, valid-driven updates.",
      "description_length": 855,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "This module constructs and manages a 32-bit AXI4-Lite demultiplexer that routes transactions from a single master to multiple slaves based on address decoding. It works directly with AXI4-Lite master and slave signal types, using address ranges to determine routing, and is used to implement memory-mapped register banks where different address regions map to different peripheral devices. The child module manages individual slave instances, providing functions to access and assign the master-to-slave and slave-to-master AXI4 interface signals for each slave. Together, they enable the creation and configuration of a demultiplexed AXI4 memory-mapped system where a single master communicates with multiple slaves over a shared bus.",
      "description_length": 735,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-Stream destination interfaces using combinational or registered signal types, focusing on tasks like signal packing/unpacking, multiplexing, concatenation, and pipeline insertion. It works with structured signal interface descriptions to manage data acknowledgment ports and field-level connections in streaming data pipelines. Specific use cases include implementing high-throughput streaming pipelines in FPGA designs, such as video processing or network packet streaming, where address phases are omitted for continuous data transfer.",
      "description_length": 608,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit AXI slave-to-master interface signals encoded as bit vectors. It supports operations like packing/unpacking signals to and from vectors, multiplexing, concatenation, and selection with priority or one-hot encoding. Use cases include constructing and validating AXI responses from slave components, converting constant values to properly sized interface signals, and routing AXI transactions through multiplexed paths.",
      "description_length": 469,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank for AXI4-Lite interfaces, allowing direct connection to an AXI bus for memory-mapped register access. It provides functions to define and manage register read and write operations, supporting address mapping and data transfer between the AXI master and slave components. Use cases include configuring hardware registers in FPGA peripherals or managing control/status registers in AXI4-Lite compliant IP cores.",
      "description_length": 448,
      "index": 330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation and transformation of 32-bit AXI4-Lite register interfaces, supporting functional traversal, port association, and layout construction with bit-width and field annotations. It provides core operations for defining, wiring, and converting register signals, including imperative-style register creation, combinational logic functions like `mux`, `concat`, and `priority_select`, and transformations that apply per-field customizations or serialize register state via association lists. Concrete uses include implementing control/status registers, building register file datapaths, configuring AXI4-Lite peripherals with named ports, and converting between integer and bit-level representations for memory-mapped access. Submodules extend these capabilities with specialized support for imperative blocks, signal metadata, bit vector operations, and Hardcaml-specific transformations.",
      "description_length": 925,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic master-to-slave AXI4-Lite interface operations into a single monadic operation, effectively lifting the monad outside the interface structure. It works with 32-bit AXI4-Lite master-to-slave request types, enabling composition of multiple interface actions into a unified effectful computation. A concrete use case is aggregating multiple AXI4-Lite memory-mapped read or write requests into a single transactional operation while preserving interface consistency.",
      "description_length": 539,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple monadic slave-to-master interface values into a single monadic interface, effectively lifting the monad outwards. It operates on 32-bit AXI internal bus structures, specifically handling slave-to-master responses in a way that aligns with AXI4-Lite and AXI4-Stream protocols. A concrete use case is aggregating multiple AXI slave responses into a unified response structure before encoding it into an AXI master signal.",
      "description_length": 480,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module orchestrates a register bank connected to a 32-bit AXI4-Lite master interface, enabling configuration of address mappings and pipelined read operations with customizable access modes. It supports structured transformations of register interfaces through combinators for mapping, zipping, and folding, while submodules handle bit-level logic, monadic composition, and validity-preserving operations. Key data types include `comb` for combinational signals, `'a I.t` for register interfaces, and `Write_with_valid.t` for synchronous updates, allowing tasks like memory-mapped register configuration, FPGA peripheral design, and synthesis-friendly hardware generation. Concrete uses span defining control registers with enable signals, packing/unpacking bit fields, dynamically configuring register banks, and constructing AXI4-Lite compliant device drivers with validated signal widths and hierarchical wiring.",
      "description_length": 920,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a master-to-slave interface containing monadic values into a monadic value containing a master-to-slave interface. It operates on data structures representing AXI4 master-to-slave transactions, lifting monadic effects from individual signals to the entire interface level. A concrete use case is aggregating multiple AXI4 request signals that are individually wrapped in a monad (such as a simulation or hardware description monad) into a single monadic interface, simplifying composition and manipulation of AXI4 transactions.",
      "description_length": 581,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite master-to-slave interfaces using the Always API. It supports operations like assigning signals to interface variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. These capabilities are used when implementing AXI4-Lite communication logic where signal assignments and variable management must align with synchronous design rules.",
      "description_length": 460,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for encoding and manipulating 32-bit AXI slave-to-master interfaces. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations with priority and one-hot encoding. Use cases include constructing and validating AXI response signals, routing data between AXI components, and implementing control logic for AXI-based memory-mapped systems.",
      "description_length": 421,
      "index": 337,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for converting, packing, unpacking, and multiplexing 32-bit AXI master-to-slave interface signals. It works directly with `comb` and `t` types representing AXI signal fields, enabling concrete tasks like constant initialization, signal concatenation, priority/one-hot selection, and width validation. Use cases include constructing AXI-compatible control signals, validating interface widths, and routing AXI transactions using multiplexers or priority encoders.",
      "description_length": 504,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an AXI4-Lite slave-to-master interface and an association list indexed by field names. It supports runtime inspection and dynamic construction of AXI4-Lite interfaces using string keys. Concrete use cases include debugging interface state, dynamically configuring hardware components, and integrating with external systems that use string-based field identifiers.",
      "description_length": 411,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an AXI4-Stream source interface and an association list indexed by field names. It operates on `Source.t` and string-keyed lists, enabling dynamic access to interface fields by name. Use it to programmatically inspect or construct AXI4-Stream source interfaces from named signal collections.",
      "description_length": 339,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between an AXI4-Stream destination interface and an association list indexed by field names. It operates on the `Dest.t` type, which represents the data and acknowledgment signals of an AXI4-Stream destination port. Use cases include dynamically constructing or inspecting AXI4-Stream destination interfaces using string-labeled fields, such as when integrating with configuration systems or debugging signal connections.",
      "description_length": 463,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for encoding and manipulating slave-to-master AXI responses. It supports signal packing, unpacking, multiplexing, and validation, working with fixed-width bit vectors and interface types defined by the AXI specification. Use cases include constructing and validating AXI response signals, multiplexing multiple response sources, and converting between structured interfaces and flat bit vectors.",
      "description_length": 447,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI master-to-slave interfaces, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions. It works directly with the `comb` type and structured interface types that represent AXI signals with defined bit widths. Concrete use cases include building multiplexed AXI data paths, validating signal widths during simulation, and converting structured AXI requests to flat vectors for routing or serialization.",
      "description_length": 525,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and validate AXI4 slave-to-master interface signals represented as bit vectors. It supports packing/unpacking of interface fields, multiplexing, concatenation, and selection operations with combinational logic. Concrete use cases include constructing constant AXI responses, validating signal widths, and implementing control logic for bus arbitration and data routing in hardware designs.",
      "description_length": 435,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream source interfaces, including packing/unpacking signals to vectors, multiplexing and concatenating interfaces, and priority/one-hot selection logic. It works with `comb` types representing combinational signals and `t` as the source interface type. Concrete use cases include constructing complex AXI4-Stream data paths, routing data between streams based on control signals, and validating signal widths during interface composition.",
      "description_length": 501,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating AXI4-Lite slave-to-master interfaces. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations with one-hot or priority-encoded inputs, working directly with `comb` and `t` types representing AXI4-Lite signals. Concrete use cases include building control logic for AXI4-Lite peripherals, routing register access signals, and implementing register file read/write paths.",
      "description_length": 488,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I",
      "library": "hardcaml_axi",
      "description": "This module orchestrates AXI4-Lite master interface logic through combinational and sequential operations, structured state machines, and signal manipulation. It centers on the `comb` type for combinational logic and structured transaction types like `t` for AXI4-Lite fields, supporting operations such as packing, multiplexing, and state transitions using Hardcaml's `Always` DSL and signal types. Submodules handle address-based routing, signal mapping via port names, and aggregation of multiple master interfaces for arbitration or multiplexing. Examples include building control logic for memory-mapped peripherals, converting Ibus transactions to AXI4-Lite protocol, and dynamically configuring signal paths using named port associations.",
      "description_length": 745,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between packed arrays and association lists indexed by field names, enabling easy serialization and deserialization of register bank fields. It operates on packed arrays\u2014flattened representations of register interfaces as arrays of 32-bit vectors\u2014and string-indexed lists of values. Use this when mapping register fields to named entries in a list, such as for external configuration or debugging purposes.",
      "description_length": 446,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module provides functional combinators and transformations for AXI4-Lite master-to-slave interfaces, supporting operations like mapping, zipping, folding, and serialization over structured transactions. It works with signals, bit vectors, and combinational logic, exposing metadata such as port names, widths, and constants for address and data buses. Submodules enable dynamic construction via field-name association lists, monadic aggregation of transactions, and combinational logic for multiplexing, packing, and selection. Specific applications include implementing memory-mapped register access, routing AXI4-Lite transactions, and generating control logic for FPGA peripherals with minimal overhead.",
      "description_length": 711,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a packed array of monadic values into a monadic packed array, effectively lifting the monad outside the array structure. It operates on packed arrays, which are arrays of 32-bit vectors used to represent flattened hardware register interfaces. A concrete use case is combining multiple register fields within an AXI4-Lite interface where each field is in a monadic context, allowing them to be handled as a single monadic unit.",
      "description_length": 481,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite slave-to-master interface signals using the Always API. It supports operations like assigning values to interface fields, creating registers and wires with specified properties, and applying naming conventions to signals. Concrete use cases include building memory-mapped AXI4-Lite interfaces with registered or combinational signals, and structuring signal assignments within always blocks for hardware description.",
      "description_length": 482,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module connects a bank of read/write registers to an AXI4 master interface, enabling memory-mapped access with pipelined reads and synchronized updates. It supports typed register manipulation through data structures like `'a O.t` and `Read_enable.t`, allowing operations such as dynamic field selection, atomic updates, and priority-encoded multiplexing. Child modules provide AXI4-Lite compatibility, handling address decoding, write data validity, and structured transformations for control logic synthesis and testbench generation. Use this to implement configurable hardware peripherals accessible via software, with precise signal handling and register field mapping.",
      "description_length": 678,
      "index": 352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names, widths, and associated tags for AXI4-Lite interface signals when converting from slave to master configurations. It provides direct access to signal metadata as lists of string-name/integer-width pairs, individual names, widths, and strongly-typed tags. This is used to generate or inspect AXI4-Lite signal interfaces programmatically, particularly during hardware description or simulation setup.",
      "description_length": 428,
      "index": 353,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside. It operates on data structures composed of records and tuples where each field is wrapped in a monad `M`. A concrete use case is combining multiple AXI4-Lite slave interface signals into a single master interface signal, enabling synchronized data transfer between components in a hardware design.",
      "description_length": 440,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite slave-to-master signal manipulation, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions. It works with `comb` types representing combinational signals and structured AXI4-Lite interfaces. Concrete use cases include constructing and validating AXI4-Lite request/response paths, building multiplexed bus interfaces, and generating constant or one-hot control signals for hardware blocks.",
      "description_length": 504,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the manipulation of packed arrays of 32-bit signals as register interfaces, offering operations such as packing/unpacking, multiplexing, concatenation, and validation. It operates on combinational and registered signal types to facilitate hierarchical wiring, field-level assignments, and pipeline construction, with a focus on structured data encoding in memory-mapped contexts. These capabilities are particularly suited for implementing AXI4-Lite register banks in hardware designs requiring efficient, grouped field access and signal hierarchy management.",
      "description_length": 579,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface",
      "library": "hardcaml_axi",
      "description": "This module creates and manages register banks for AXI4 memory-mapped interfaces, handling address decoding, access control, and pipelined read operations. It provides core types like `Write_with_valid.t` for structured write operations, and combinators for manipulating read-enable signals, interface structures, and bit vectors, enabling tasks like dynamic register selection and signal routing. Submodules support composing AXI register interfaces with validity flags, transforming read pipelines, and structurally manipulating interface components with precise bit-width and port handling. Examples include synthesizing AXI4-Lite register maps, building named write transactions, and generating type-safe, synthesizable logic for control and status registers.",
      "description_length": 763,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module structures and encodes AXI4 slave-to-master response interfaces through direct manipulation of `Slave_to_master.t` values and associated list and associative list representations. It supports mapping, zipping, folding, and combinational transformations using bit vectors, alongside structural validation, signal packing/unpacking, and multiplexing for memory-mapped and burst-capable designs. Submodules handle monadic interface sequencing, port metadata definition, register and wire creation via the `Always` API, and dynamic signal mapping using association lists. Use cases include constructing AXI4 multiplexers, aggregating burst read responses, generating debug representations, and mapping internal signals to AXI-compliant responses with precise naming and bit-width control.",
      "description_length": 796,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4-Lite master-to-slave port signals by associating them with string keys derived from port names. It provides `to_alist` to convert a record of signals into a list of named signal pairs and `of_alist` to reconstruct the record from such a list. These operations are useful when dynamically routing or inspecting AXI4-Lite interface signals based on their string-identified ports.",
      "description_length": 408,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module implements structural transformations and protocol decoding for AXI4 master-to-slave communication, supporting operations like mapping, folding, and converting signal representations between bit-level, tuples, and lists. It centers around the parameterized `t` type for AXI signal bundles, integrating metadata such as port names, widths, and tags, and enables combinational logic construction and error handling for memory-mapped or streaming interfaces. Submodules provide bit-level manipulation, signal assignment with the Always API, record-based combinational logic, port metadata configuration, dynamic signal access by name, and monadic interface transformation. Example uses include decoding AXI requests into control signals, building custom bus multiplexers, and aggregating monadic AXI transactions for simulation or synthesis.",
      "description_length": 850,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a RAM with per-byte write enables and configurable size, designed for use in AXI4 slave interfaces. It supports read and write operations aligned with AXI4 memory-mapped protocols, using signals for communication between master and slave. Use it to model on-chip memory with byte-level write control in AXI4-based hardware designs.",
      "description_length": 354,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "This module routes transactions from a single AXI4-Lite master interface to multiple internal slave interfaces based on address decoding. It takes an AXI master interface, a list of internal slave interfaces, and an address offset, then generates the necessary control signals to select the appropriate slave for each transaction. The demultiplexer ensures that each slave only responds to accesses within its assigned address range, enabling memory-mapped peripherals to coexist on the same bus.",
      "description_length": 496,
      "index": 362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "Implements a RAM with per-byte write enables and configurable size, designed for AXI4-Lite memory-mapped interfaces. It accepts read and write transactions from an AXI4-Lite master, handling byte-level write enables to allow partial word updates. Useful in hardware designs where efficient, fine-grained memory access is required, such as register files or configuration memory blocks.",
      "description_length": 385,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between AXI4-Lite slave and master interfaces represented as bit vectors. It supports operations like packing and unpacking interfaces into vectors, multiplexing, concatenation, and selecting between interfaces using priority or one-hot encoding. These functions are used to implement logic that translates or manipulates AXI4-Lite signals in hardware designs, particularly when interfacing between different components in a register-transfer level (RTL) description.",
      "description_length": 509,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine to manage the data path of a 32-bit internal bus with synchronous logic, supporting control signals like `wready` and configurable parameters such as timeout and pipeline depth. It enables safe synchronization of AXI4-Lite bus transactions while providing direct access to register interfaces for operations like mapping, folding, and bit-level manipulation. Submodules facilitate structural transformations, register bank construction, and memory-mapped I/O management, allowing tasks such as control register implementation, datapath synthesis, and field-level customization of register layouts. Specific examples include converting between integer and bit-level representations, building hierarchical register structures with named ports, and generating address-decoded logic for AXI4-Lite peripherals.",
      "description_length": 844,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module provides functional combinators and structural transformations for 32-bit AXI slave-to-master interfaces, supporting operations like mapping, zipping, and folding over tagged AXI signal fields. It enables conversions between interfaces and linear data representations such as bits, signals, and association lists, while enforcing AXI4-Lite constraints. Submodules handle signal creation, naming, and manipulation using combinational logic or the Always API, supporting use cases like synthesizing AXI response logic for register banks or implementing burst-capable memory slaves. Specific operations include packing/unpacking signals, multiplexing, concatenation, and dynamic configuration via association lists.",
      "description_length": 724,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to register and wire interfaces within an `Always` block, specifically handling packed arrays of 32-bit signals. It supports creating register containers with optional enable signals, assigning signal values to variable interfaces, and applying naming conventions to signal fields. Concrete use cases include defining AXI4 register banks with structured, flattened signal arrays and managing their behavioral assignments in synchronous logic blocks.",
      "description_length": 512,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert AXI4-Lite master-to-slave interface signals to and from bit vectors, enabling direct manipulation of hardware signals in a memory-mapped interface. It supports operations like packing and unpacking interfaces, multiplexing, concatenation, and validation of signal widths, working specifically with `comb` and `t` types representing AXI4-Lite signals. Concrete use cases include constructing and validating AXI4-Lite transactions, implementing multiplexed bus interfaces, and converting constant values into correctly sized signal interfaces for simulation or synthesis.",
      "description_length": 611,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module connects a bank of read/write registers to a 32-bit AXI4-Lite master interface, supporting configurable write modes, pipelined reads, and alignment handling. It provides data types like `comb`, `'a I.t`, and `Write_with_valid.t` for managing combinational signals, register interfaces, and synchronous updates, enabling memory-mapped register blocks for FPGA peripherals and device drivers. Submodules allow structured transformations via mapping, zipping, and folding, while handling bit-level logic and validity-preserving operations. Examples include defining control registers with enable signals, packing bit fields, and dynamically configuring register banks with hierarchical wiring.",
      "description_length": 702,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module connects a list of signals to an AXI4-Lite bus, enabling memory-mapped register access for control and status monitoring in FPGA designs. It supports configurable register modes and integrates with Hardcaml's signal and scope system, allowing direct interaction with AXI master and slave components. Key operations include defining register layouts, mapping addresses, and handling read/write transactions. Example uses include configuring peripheral registers or exposing internal state for debugging via AXI4-Lite compliant interfaces.",
      "description_length": 549,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and registered signal manipulation for AXI4-Lite slave-to-master interfaces, including constant assignment, multiplexing, pipelining, and interface packing/unpacking. It operates on structured signal types (`comb`, `t`) that enforce width correctness, supporting use cases like peripheral register control and memory-mapped data routing in FPGA designs. Key operations include signal wiring (`<==`), hierarchical naming, and synthesis-optimized transformations for AXI4-Lite's lightweight address-mapped transactions.",
      "description_length": 552,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit wide RAM with byte-level write enables, allowing partial writes aligned to AXI4-Lite memory-mapped interface operations. It handles AXI4 read and write transactions over a 32-bit data and address bus, supporting configurable RAM sizes and byte enable decoding for precise memory updates. Concrete use cases include implementing register files or small memory buffers in FPGA designs where byte-granularity writes are required.",
      "description_length": 458,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module combines multiple AXI4-Lite interface values within a monadic context, lifting the monad outside the interface structure. It operates on AXI4-Lite master-to-slave interfaces, transforming a collection of monadic interface components into a single monadic interface. Use this to construct complex AXI4-Lite interfaces from individual signal components, each potentially dependent on a shared context such as a clock or configuration.",
      "description_length": 444,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names, widths, and associated tags for AXI4-Lite master-to-slave interface signals. It provides direct access to signal metadata used for generating or analyzing AXI4-Lite ports in hardware descriptions. Use this module when inspecting or constructing AXI4-Lite interfaces where precise signal widths and naming are required for synthesis or verification.",
      "description_length": 379,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit AXI4-Lite and AXI4-Stream demultiplexer that routes transactions from a single master to multiple slaves based on address offsets, enabling memory-mapped systems where distinct address ranges target different peripherals. It provides data types for AXI4 master and slave signals, along with operations to define address mappings and manage routing logic. The child module specializes in constructing and managing individual AXI4-Lite slave interfaces, allowing precise control over signal connections and address decoding. For example, it can route register reads from a CPU to different peripheral devices, each mapped to a unique address region, while maintaining clean signal isolation between slaves.",
      "description_length": 736,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing, unpacking, multiplexing, and concatenation. It works with `comb` and `t` types representing interface signals and their configurations. Concrete use cases include constructing and validating AXI4-Lite signal bundles, routing data between AXI4-Lite components, and dynamically selecting or combining interface signals based on control logic.",
      "description_length": 460,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus",
      "library": "hardcaml_axi",
      "description": "This module implements a complete AXI4-Lite compatible internal bus system for hardware design, enabling structured manipulation of master-slave transactions through signal-based interfaces. It defines core data types like `t`, `comb`, and `Reg_spec.t` to model register states, combinational logic, and signal assignments, supporting operations such as mapping, zipping, and bit-level manipulation across register banks and memory-mapped slaves. You can build complex bus logic, route transactions between multiple peripherals, generate RTL declarations, and synthesize memory-mapped register access with configurable delays and per-byte write enables. Specific applications include FPGA control planes, testbenches with structured signal mappings, and synthesis-friendly register banks with dynamic configuration and debug support.",
      "description_length": 833,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "This module routes AXI4-Lite and AXI4-Stream transactions from a single master to multiple slaves using address decoding, managing signal interfaces and control logic via Hardcaml registers. It defines core types like `Master_to_slave.t` and `Slave_to_master.t` for precise signal handling, and supports slave configuration through submodules that enable address-based routing and signal assignment. Operations include connecting slaves to a memory-mapped bus, retrieving transaction signals, and generating control logic based on register specs. An example use case is implementing a CPU-driven system that directs memory accesses to peripherals based on address ranges.",
      "description_length": 671,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating packed arrays of 32-bit vectors, primarily used in AXI register interfaces. It supports packing and unpacking data, multiplexing, concatenation, and selection operations with strict width validation. Concrete use cases include encoding/decoding register fields, building multiplexed control paths, and validating signal widths in AXI4-Lite or AXI4-Stream register banks.",
      "description_length": 439,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite master-to-slave interfaces using Hardcaml's Always API. It supports working with register and wire variables, enabling direct assignment and naming of interface signals within always blocks. Concrete use cases include building memory-mapped AXI4-Lite slave interfaces with named signals, initializing wires to default values, and registering interface fields with enable conditions.",
      "description_length": 448,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine that translates AXI4-Lite read and write transactions into a simplified internal bus protocol, managing address decoding, data transfer, and response generation for memory-mapped peripherals. It provides data types for representing AXI signals as tagged structures (`'a t`), association lists mapping ports to values, and bit-width definitions, with operations like `pack`, `mux`, and `concat` for signal transformation and routing. The state machine states are tracked and serialized using integer and S-expression conversions, enabling dynamic inspection and control of AXI4-Lite transaction progression. Examples include constructing register banks, bridging AXI4-Lite to internal protocols, and managing control/status registers using bit-level operations and signal multiplexing.",
      "description_length": 823,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest",
      "library": "hardcaml_axi",
      "description": "This module suite manages AXI4-Stream destination ports through transformation, combination, and signal-level manipulation, supporting both combinational and registered logic. It centers on the `'a Dest.t` type, which encapsulates port metadata and validity logic, and provides operations like mapping, zipping, folding, and scanning to build complex streaming data paths. Child modules enable bit-vector conversions, association list serialization, interface aggregation, and signal routing, with utilities for naming, packing, and validation. Examples include constructing multiplexed stream interfaces, converting port configurations to bit vectors for synthesis, and aggregating multiple destination channels into a unified interface for synchronized data handling.",
      "description_length": 769,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformation and structural manipulation of AXI4-Lite interface signals through mapping, zipping, folding, and list conversions, while supporting bit-level composition and error aggregation. It operates on `t` values representing memory-mapped interface signals, incorporating metadata such as port names, widths, and address/data configuration constants for static bus parameter setup. Submodules provide combinational logic operations, monadic lifting via `all`, bit vector construction and validation, signal packing/unpacking, and integration with the Always API for direct signal assignment and register creation. Specific applications include bridging peripherals to processors in FPGA designs, implementing control/status registers, and dynamically inspecting or configuring AXI4-Lite interfaces via association lists.",
      "description_length": 858,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite slave-to-master port manipulation, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with `comb t` types representing AXI4-Lite interface signals and supports operations based on integer constants and bit-width validation. Concrete use cases include constructing and validating AXI4-Lite interface logic, implementing multiplexed bus slaves, and generating control logic for memory-mapped peripherals.",
      "description_length": 566,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly associates AXI4-Lite slave interface signals with their corresponding master interface signals by port name, using unsafe operations. It provides `to_alist` to convert an interface into a list of named signal pairs and `of_alist` to reconstruct an interface from such a list. Use this when mapping signals between slave and master interfaces in low-level hardware descriptions where port names must align exactly.",
      "description_length": 434,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine to convert Ibus master transactions into AXI4-Lite protocol, managing address and data phase handshaking, burst alignment, and response handling for memory-mapped I/O. It provides data types like `t` for AXI4-Lite fields and `comb` for combinational logic, enabling operations such as packing, multiplexing, and state transitions using Hardcaml's `Always` DSL. Child modules organize tagged signal bundles for structural transformations, support bit-level control and signal routing, and allow combining multiple AXI4-Lite masters into a shared interface. You can use it to bridge Ibus masters with AXI4-Lite peripherals, generate RTL with consistent naming, and build control logic for memory-mapped devices with dynamic signal path configuration.",
      "description_length": 787,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines lists of port names and their corresponding widths, along with a list of tags, used to describe the structure of packed arrays in AXI register banks. It works with string and integer lists to represent field names and bit widths, alongside custom tag types. These values are used directly in hardware description to define register layouts and generate corresponding interface logic.",
      "description_length": 403,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source",
      "library": "hardcaml_axi",
      "description": "This module enables functional and structural manipulation of AXI4-Stream source interfaces through transformations like mapping, zipping, and combining streams with up to five inputs. It operates on `'a t` values, supporting conversions between lists, tuples, and validity signals for flow control, with direct applications in data pipelines and streaming accelerators. Submodules provide concrete interface definitions, monadic combination via `all`, Always-based signal manipulation, bit vector operations, combinational logic for routing and selection, dynamic field access via association lists, and integration with combinational signals. These capabilities allow constructing, validating, and routing AXI4-Stream sources with precise control over signal naming, behavior, and hardware synthesis.",
      "description_length": 802,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate packed arrays of 32-bit vectors as AXI4-Lite register interfaces. It supports packing and unpacking interfaces to and from vectors, multiplexing and concatenation of interfaces, and validation of field widths. Concrete use cases include defining register banks with fixed-size fields for AXI4-Lite memory-mapped peripherals, and encoding grouped control or status signals in hardware designs.",
      "description_length": 438,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register",
      "library": "hardcaml_axi",
      "description": "This module implements registered datapath components for AXI4-Stream interfaces, ensuring proper tvalid/tready handshake protocol synchronization across pipeline stages. It provides functions to create and wire single or multi-stage pipelines with configurable pipeline stage descriptions, instance names, and clock/clear signals. The child modules enable structural manipulation of AXI4-Stream interfaces, combinational logic synthesis, and pipeline register stage configuration, supporting operations like mapping, zipping, multiplexing, and signal routing. Concrete use cases include inserting registered stages between streaming components to meet timing, building synchronized FIFO pipelines, segmenting high-latency data paths, and dynamically routing AXI4-Stream signals with validated handshake protocols.",
      "description_length": 814,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to pack, unpack, and manipulate arrays of 32-bit vectors as flattened register interfaces. It supports constant initialization, multiplexing, concatenation, and selection operations with strict width validation. Concrete use cases include encoding and decoding register fields for AXI4-Lite interfaces, implementing register banks with fixed-size data fields, and managing grouped control signals in hardware descriptions.",
      "description_length": 454,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module structures and transforms 32-bit AXI master-to-slave interfaces using combinators for mapping, zipping, and list conversions, while supporting combinational logic, bit-level manipulation, and memory-mapped transaction handling. It provides core operations for decoding AXI requests, configuring signal routing, and managing burst transfers, working with interface types like `t` and `comb` that represent structured or flat signal layouts. Child modules enhance this functionality with port metadata definitions, signal naming, register creation, and monadic composition, enabling tasks like connecting CPUs to peripherals, validating interface widths, or aggregating AXI transactions into unified operations. Specific capabilities include packing/unpacking bit vectors, implementing priority encoders, constructing testbenches with field-based interface inspection, and generating RTL for AXI4-Lite or AXI4 memory-mapped systems.",
      "description_length": 942,
      "index": 392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing, unpacking, multiplexing, and validation. It works with interface types composed of signals like `comb t`, where each field represents a bus signal with a defined bit width. Use it to construct and manipulate AXI4-Lite control signals in a hard-coded or dynamic manner, such as routing slave responses based on address decoding or validating signal widths during simulation.",
      "description_length": 493,
      "index": 393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine to manage data path registration for an input bus interface, synchronizing AXI4 or AXI4-Lite data transfers through custom `I` and `O` signal types. It provides combinators for structured register interfaces, supporting operations like mapping, zipping, and converting register data to bit vectors or S-expressions, with support for tagged fields, port metadata, and bit-width tracking. Child modules enable register routing, dynamic configuration, and signal manipulation using types like `t` and `comb`, facilitating tasks such as pipeline insertion, AXI slave setup, and interface validation. Examples include creating named registers with enable signals, packing fields into bit vectors, and generating testbenches from register layouts.",
      "description_length": 780,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module handles register bank operations for AXI interfaces using a combinatorial logic type. It provides functions to pack, unpack, mux, and validate register interfaces, ensuring correct signal widths and enabling concatenation or selection logic. Use cases include constructing and validating AXI register banks with precise bit-level control, and implementing multiplexing or priority selection logic for AXI register fields.",
      "description_length": 433,
      "index": 395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I",
      "library": "hardcaml_axi",
      "description": "This module supports functional transformations of AXI interface structures through combinators that enable mapping, folding, and multi-argument operations, alongside introspection of port properties like widths, names, and tags. It operates on AXI interface values (`I.t`), signals, and registers, facilitating conversions between list-based and structured representations while ensuring error aggregation and alignment with hardware naming conventions. These capabilities are particularly useful for implementing register banks in memory-mapped AXI4 systems, optimizing AXI4-Lite's lightweight transactions, and managing AXI4-Stream's addressless data bursts.",
      "description_length": 661,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module handles register bank operations for AXI interfaces using a combinatorial logic type. It provides functions to pack, unpack, mux, and concatenate interface signals, along with validation and width assertion utilities. Use cases include constructing and manipulating AXI register banks with precise bit-level control and signal routing.",
      "description_length": 347,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4 register banks using signal-level representations, including packing/unpacking, multiplexing, concatenation, and priority/onehot selection. It works with AXI4 interface fields encoded as `O.Of_signal.t` values, which model hardware signals with combinational logic and register specifications. These capabilities are used to implement memory-mapped AXI4 interfaces, validate signal widths, create register pipelines, and manage signal routing in hardware designs with burst-capable data transfers.",
      "description_length": 568,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite register banks with write ports that include a valid signal. It supports data packing/unpacking, multiplexing, concatenation, and selection operations on register interfaces with precise bit-width control. Concrete use cases include constructing AXI4-Lite register maps with dynamic field updates, implementing priority-encoded register access, and validating register field widths during design elaboration.",
      "description_length": 474,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides register and signal manipulation operations for AXI4 interface implementations, focusing on combinational logic transformations like packing, unpacking, multiplexing, and priority/onehot selection. It operates on register interfaces and signals in Hardcaml's RTL design context, enabling pipeline insertion, naming conventions, and value transformations. These utilities are particularly useful for optimizing memory-mapped AXI4 bursts, simplifying AXI4-Lite interfaces, and managing AXI4-Stream data flows with customizable signal strategies.",
      "description_length": 564,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a structured interface and an association list indexed by field names, enabling programmatic access and manipulation of interface fields by their string identifiers. It operates on the `Datapath_register.IO.t` type, which represents a hardware register interface with typed fields. Use cases include dynamically inspecting or constructing register interfaces from external data sources like configuration files or runtime-generated field mappings.",
      "description_length": 497,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I",
      "library": "hardcaml_axi",
      "description": "This module provides structural manipulation and functional transformation of AXI4 interface values, supporting operations like traversal, mapping, equality checks, and conversion between lists and S-expressions. It works with hardware description types such as signals, registers, and tuples of interface components, enabling RTL design tasks like register bank synthesis, signal width calculation, and error handling across memory-mapped and streaming data paths. Specific use cases include implementing AXI4-Lite register banks with combinatorial logic, managing burst transfers in AXI4-Stream interfaces, and automating signal naming conventions during hardware verification.",
      "description_length": 679,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source",
      "library": "hardcaml_axi",
      "description": "Provides functions for transforming, combining, and inspecting AXI4-Stream source interfaces through operations like `map`, `zip`, `fold`, and `scan` across multiple inputs. It works with structured data types such as `'a Source.t` (representing RTL signal sources), port metadata (names, widths, tags), and bit-level interface lists, enabling use cases like constructing high-throughput data paths for continuous, address-free bursts in hardware designs. Utilities for converting between association lists and interfaces, error aggregation, and defining constant-value streams further support low-level AXI4-Stream protocol implementation.",
      "description_length": 640,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces for AXI4 slave-to-master signals using the Always API. It supports operations like assigning values, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include building memory-mapped AXI4-Lite peripherals with register banks and implementing AXI4-Stream interfaces with named signal wires.",
      "description_length": 444,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface.Make",
      "library": "hardcaml_axi",
      "description": "This module generates C structures and address offset definitions for a memory-mapped register interface. It operates on register descriptions provided via the `Regs` module to produce C-compatible output for use in software drivers or firmware. Concrete use cases include generating header files for interacting with FPGA-based peripherals from C code.",
      "description_length": 353,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Lite register interfaces with write signals and validity. It supports data types including bit vectors (`comb`) and structured register banks with field-level access. Concrete use cases include building memory-mapped control registers, validating signal widths, and multiplexing or concatenating register interfaces in hardware designs.",
      "description_length": 427,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register banks for AXI4-Lite interfaces with read-enable control, specifying port names, widths, and associated tags for signal handling. It structures data as lists of strings and integers for port configurations, alongside read-enable tags to manage register access. Concrete use cases include generating hardware descriptions for memory-mapped peripherals with controlled register read operations in FPGA designs.",
      "description_length": 436,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S",
      "library": "hardcaml_axi",
      "description": "This module defines the internal bus protocol for AXI4 interfaces, managing data transfer between masters and slaves. It implements operations for address and data phase synchronization, burst handling, and channel arbitration. It is used to build memory-mapped systems with AXI4, AXI4-Lite, and AXI4-Stream components, enabling efficient communication in FPGA designs.",
      "description_length": 369,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Demultiplexer-Builder",
      "library": "hardcaml_axi",
      "description": "Constructs and manages a demultiplexer for routing AXI4-Lite slave interface signals based on address decoding. Works with `Hardcaml.Signal.t`-based AXI master-to-slave and slave-to-master signal types, along with register specifications and demultiplexer builder structures. Used to implement memory-mapped register access in hardware designs where multiple slave devices share a single AXI master interface.",
      "description_length": 409,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module represents a register bank interface with read-enable functionality for AXI4-Lite compliant hardware designs. It provides operations to convert between a structured register bank and an association list indexed by field names, enabling dynamic access to register fields by string identifiers. This is particularly useful for testbenches or runtime configuration logic where register values need to be inspected or modified by name rather than by fixed offsets.",
      "description_length": 472,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array",
      "library": "hardcaml_axi",
      "description": "This module structures the manipulation of flattened 32-bit vector arrays derived from hierarchical register interfaces, offering transformations such as mapping, folding, and multi-argument combinators while bridging to signals, association lists, and AXI register banks. It supports operations like latching, field extraction, and monadic aggregation, enabling tasks such as encoding grouped control signals in AXI4-Lite interfaces or validating widths in burst-friendly AXI4-Stream pipelines. Submodules handle signal-level wiring, behavioral assignments in synchronous blocks, port description with width metadata, and combinational logic with strict width enforcement. Examples include mapping named register fields to configuration lists, lifting monadic register fields into a single unit, and packing/unpacking register interfaces for memory-mapped peripherals.",
      "description_length": 869,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides register interface manipulation capabilities for AXI4-compatible hardware designs, including signal packing/unpacking, multiplexing, concatenation, and register creation. It operates on structured interfaces composed of `Hardcaml.Signal.t` values, supporting operations like signal wiring (`<==`), field naming with prefix/suffix conventions, and validation of interface widths. Specifically used for building memory-mapped AXI4 register banks with combinational signal logic, enabling efficient hardware description of AXI4-Lite and AXI4-Stream compatible components.",
      "description_length": 589,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite register interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. It works with fixed-width signal types represented as `comb` and structured register interfaces of type `t`. These operations are used to build complex register banks and control logic for AXI4-Lite peripherals, enabling tasks like hardware register configuration, status readback, and interrupt routing.",
      "description_length": 566,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic value of structures, specifically for interfaces with read enables. It works with types involving `'a M.t Read_enable.t`, lifting the monad outside the read enable wrapper. A concrete use case is aggregating multiple register reads under a single monadic context, ensuring read operations are combined and processed together.",
      "description_length": 424,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports constructing and manipulating AXI4-Stream source interfaces through operations like signal bundling, multiplexing, concatenation, and priority/onehot selection, alongside utilities for creating combinational logic, registers, and pipelines. It operates on `Of_signal.comb t` and `Of_signal.t` types representing AXI4-Stream signal interfaces with combinational or registered behavior. Typical use cases include modeling streaming data paths in hardware designs, connecting signal interfaces hierarchically, and generating named signal hierarchies for simulation or synthesis.",
      "description_length": 596,
      "index": 415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values into a monadic collection, effectively lifting the monad outside the interface structure. It operates on data types involving a nested combination of a monad `M` and an interface type `'a O.t`. Use this to sequence multiple interface operations that return monadic results, aggregating them into a single monadic result that yields a complete interface value.",
      "description_length": 444,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register banks with AXI4-Lite compliant interfaces, specifying port names, widths, and associated tags for hardware register access. It structures data as lists of strings and integers to represent register metadata, alongside tag values for identification. Concrete use cases include generating register interface logic for IP blocks in FPGA designs, enabling software to interact with hardware registers via memory-mapped reads and writes.",
      "description_length": 461,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface into an interface of monadic values, effectively combining and lifting the monad outside the interface structure. It operates on interfaces where each signal is wrapped in a monad `M`, restructuring them so the entire interface is within the monadic context. This is particularly useful when sequencing operations across an AXI interface where each signal may represent a computation or stateful action.",
      "description_length": 477,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in an AXI4-Stream interface, providing direct access to port metadata as lists of strings and integers. It includes functions to retrieve port names, widths, and associated tags, enabling precise configuration and inspection of stream interface signals. Concrete use cases include generating signal declarations, validating interface compatibility, and debugging stream connections in hardware designs.",
      "description_length": 457,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4-Lite master-to-slave register interfaces using a combinational logic type. It supports constant initialization, packing/unpacking to vectors, multiplexing, concatenation, and selection operations with support for priority and one-hot encoding. Concrete use cases include building register banks with dynamic field selection, creating constant register maps, and transforming register interfaces for hardware synthesis.",
      "description_length": 469,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module handles register bank interfaces with read enable signals in a memory-mapped AXI4 context. It provides operations for packing, unpacking, multiplexing, and validating register fields, working directly with `comb` and `t` types representing hardware signals. Use cases include constructing and manipulating AXI4-Lite register banks with precise bit-level control and validation.",
      "description_length": 389,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_space",
      "library": "hardcaml_axi",
      "description": "This module provides operations for defining and manipulating memory-mapped address ranges, including base address and size specifications, with support for comparison, range-checking, and clamping operations. It works with integer-based memory regions (`Base.int`) to represent AXI4 address spaces, enabling precise validation and alignment of memory access boundaries. These capabilities are particularly useful in constructing address decoders for AXI4 memory-mapped interfaces, ensuring correct routing of transactions to designated hardware components.",
      "description_length": 557,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a destination interface and an association list indexed by field names, enabling direct mapping of data fields to string keys. It operates on the `Dest.t` type, which represents an AXI4-Stream destination interface, and lists of key-value pairs. These functions are useful for dynamically constructing or inspecting stream interfaces using named fields, such as when integrating with configuration systems or debugging data paths.",
      "description_length": 480,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream destination interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and selecting between multiple streams using priority or one-hot encoding. It works directly with combinational signals and destination interfaces defined by the AXI4-Stream protocol, ensuring correct signal widths and validation. Concrete use cases include building multiplexed data paths, stream routing logic, and constant initialization for testbenches or hardware generators.",
      "description_length": 565,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables manipulation and connection of AXI4 master-to-slave signals, providing validation, multiplexing, register pipeline creation, and bidirectional signal wiring. It operates on signal types representing AXI interface fields, supporting both AXI4-Lite and AXI4-Stream protocols through structured data representations. Use cases include validating AXI4-Lite peripheral connections, pipelining AXI4-Stream data paths, and managing hierarchical signal naming in memory-mapped FPGA designs.",
      "description_length": 502,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Lite master-to-slave interfaces using the Always API, including variable assignment, register and wire creation, and signal naming. It operates on `Master_to_slave.t` interface values containing signals and variables. Use cases include building register banks for AXI4-Lite peripherals with named signals and controlled data flow in synchronous logic blocks.",
      "description_length": 408,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles register bank interfaces with read enable signals, operating on bit vectors for AXI4-Lite and AXI4 memory-mapped configurations. It provides functions to pack, unpack, multiplex, and validate register fields, ensuring correct bit widths and enabling priority or one-hot selection logic. Use cases include constructing and validating register maps for hardware blocks with multiple read-enabled fields.",
      "description_length": 421,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register banks represented as bit vectors, supporting construction, validation, and transformation of register interfaces. It includes functions for packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection operations with support for valid signals and optional branching factors. Concrete use cases include implementing AXI4-Lite register interfaces, handling memory-mapped control/status registers, and constructing configurable register banks from constants or dynamic values.",
      "description_length": 560,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-Stream datapath register interfaces using a combinational logic layer. It supports data types including vectors, integers, and valid-qualified signal pairs, with functions for packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building AXI4-Stream register stages, routing logic for stream data, and validation of signal widths in datapath designs.",
      "description_length": 475,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles register bank interfaces with read enable signals, operating on bit vectors for AXI4-Lite and AXI4 memory-mapped designs. It provides functions to pack, unpack, multiplex, and validate register fields, ensuring correct bit widths and enabling dynamic selection logic for register access. Use cases include constructing and managing register banks with runtime-configurable values, prioritized or one-hot selection of register inputs, and validating signal widths during simulation or synthesis.",
      "description_length": 514,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a structured interface with write and valid signals and an association list indexed by field names. It operates on data types that represent AXI4 register banks, specifically handling write transactions with validity flags. Concrete use cases include serializing and deserializing register bank states for debugging, configuration, or interfacing with external systems using string-keyed data maps.",
      "description_length": 448,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank interfaces with read enable functionality using combinational logic. It works with types representing register fields, such as `comb Read_enable.t`, and supports operations like packing/unpacking to bit vectors, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building memory-mapped register banks for AXI4-Lite interfaces, where individual register fields can be conditionally read and selected based on control signals.",
      "description_length": 535,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module transforms AXI4-Lite slave interface signals into master-compatible representations, enabling bidirectional communication across memory-mapped interfaces. It supports structured signal manipulation with operations like mapping, folding, and zipping tuples of interface signals, and includes error-aware conversions between list-based and port-aware data formats. The module enables synthesis of register-abstractions for AXI control paths, alignment of data/address bus widths, and management of hierarchical signal hierarchies with bit-level offset tracking. Submodules provide combinational logic operations, signal wiring, monadic record transformations, port-level signal pairing, and metadata access for programmatically generating and inspecting AXI4-Lite interfaces in RTL descriptions.",
      "description_length": 805,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformations and associative operations on AXI4 register bank interfaces, specifically handling `Read_enable.t` structures that encapsulate port names, widths, and tagged field values. It supports bit-level and signal-level manipulations through combinators like mapping, folding, and zipping, while providing utilities for automated register bank generation and name/width tracking. These capabilities are used in hardware abstraction layers to streamline AXI-based system design, ensuring safe or explicit unsafe port associations during register field composition.",
      "description_length": 601,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI slave-to-master interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with fixed-width bit vectors and interface types defined in the AXI specification, ensuring correct signal widths and values. Use cases include building and validating AXI4 or AXI4-Lite interfaces, routing data between AXI components, and constructing constant or conditional AXI control signals.",
      "description_length": 484,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Stream interface signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with fixed-width bit vectors and structured interface types defined in `Datapath_register.I`. Concrete use cases include building data path logic for streaming applications, such as routing data between AXI4-Stream sources and destinations, and implementing control logic for data selection and validation.",
      "description_length": 498,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate fixed-width bit vector interfaces, including packing/unpacking to and from vectors, multiplexing, concatenation, and selection functions with support for valid signals. It works with data types representing register input/output interfaces composed of bit vectors, where each field has a defined width. Concrete use cases include constructing and validating register interfaces for AXI4-Stream datapaths, routing data between modules using multiplexers, and initializing register fields from integer values.",
      "description_length": 553,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names, enabling easy serialization and deserialization of register bank data. It operates on types that represent AXI4 register banks and their associated string-indexed values. Use this when mapping hardware register fields to a list structure for debugging, configuration, or dynamic interface construction.",
      "description_length": 421,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable",
      "library": "hardcaml_axi",
      "description": "This module provides functional transformations such as mapping, zipping, and folding over `Read_enable.t` structures, which model AXI4 register bank interfaces with read-enable signals. It operates on tuples and lists of these structures, along with associated metadata like port names, widths, and tags, enabling structured manipulation of hardware description data. Specific use cases include synthesizing read-enable logic from always blocks, generating register banks for AXI4-Lite interfaces, and converting between interface representations (e.g., signals, bits) during hardware design.",
      "description_length": 593,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between register interfaces and associative lists, enabling straightforward serialization and deserialization of register data. It operates on register interface values and string-keyed lists of arbitrary data. These functions are useful for inspecting or reconstructing register states during simulation or debugging, particularly when mapping register contents to named fields dynamically.",
      "description_length": 431,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines a register bank interface for AXI4-Lite write operations with valid signaling, specifying port names and their bit widths. It includes functions to access individual register fields by name and retrieve their widths, supporting precise hardware register configuration. Concrete use cases include implementing memory-mapped control registers in FPGA designs where each register field corresponds to a specific hardware configuration parameter.",
      "description_length": 462,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and route AXI4 slave-to-master interface signals using combinational logic. It supports functions like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interface signals, and priority or one-hot selection between multiple sources. Concrete use cases include building register banks that map AXI4-Lite slave accesses to master transactions, or implementing arbitration logic for AXI4 memory-mapped data paths.",
      "description_length": 486,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_spaces",
      "library": "hardcaml_axi",
      "description": "This module manages a collection of non-overlapping address spaces, ensuring they are stored in sorted order. It provides operations to create and serialize address space collections, validating their correctness during construction. It is used when defining memory-mapped regions in AXI4 or AXI4-Lite interfaces to ensure distinct and ordered address ranges.",
      "description_length": 359,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module defines register interfaces for AXI4 protocols using bit vectors, supporting operations like packing/unpacking bit representations, multiplexing, concatenation, and selection logic. It works with types such as `t` for register interfaces and `comb` for combinational logic using `Bits.t`. Use cases include constructing and validating AXI4 register interfaces, selecting data paths based on priority or one-hot encoding, and converting between integer and bit-level register representations.",
      "description_length": 503,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with fixed-width bit vectors and structured register interfaces defined by the `O.Of_bits` module. Concrete use cases include building and validating AXI4 register banks, routing data between interfaces using multiplexers, and initializing register fields from integers.",
      "description_length": 429,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a given interface structure. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite register banks with named signals, connecting interface fields to logic in always blocks, and initializing wire variables with default values.",
      "description_length": 469,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing, unpacking, multiplexing, and concatenation. It works with fixed-width signal types represented as `comb t`, supporting operations like constant assignment, priority selection, and one-hot encoding. Concrete use cases include constructing and validating AXI4-Lite interface signals, routing data between AXI4-Lite masters and slaves, and implementing control logic for memory-mapped peripherals.",
      "description_length": 514,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module orchestrates the manipulation and transformation of AXI4-Lite master-to-slave interfaces through structured signal collections, supporting operations like mapping, zipping, and parallel combinational logic with error handling. It exposes core data types such as `'a t` for structured signals and `comb` for combinational logic, alongside submodules that enable list conversion, bit vector manipulation, monadic interface assembly, metadata access, and Hardcaml Always block integration. With these capabilities, users can dynamically route signals, construct memory-mapped interfaces, validate signal widths, and generate synthesis-ready AXI4-Lite transactions. Specific applications include multiplexing bus interfaces, packing control signals, and building configurable slave components with named, typed fields.",
      "description_length": 826,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides structural and combinational logic operations for AXI4 master-to-slave interface signals, including packing/unpacking, multiplexing, concatenation, and register manipulation. It works with signal vectors, registers, and interface connections, enabling tasks like validating signal widths, creating hierarchical naming conventions, and wiring components in a register bank. Specific use cases include synthesizing AXI4 memory-mapped interfaces, managing burst transactions, and organizing signal hierarchies for clarity in hardware designs.",
      "description_length": 560,
      "index": 449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the data structures and operations for managing port names, widths, and tags in an AXI4-Stream datapath register. It works with lists of strings and integers to represent port metadata, along with a list of tag values from a nested module. It is used to configure and describe the interface of a streaming datapath register in hardware designs.",
      "description_length": 364,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite master-to-slave interfaces using the Always API. It supports working with register and wire variables, enabling direct assignment and naming of interface signals within an always block. Concrete use cases include building memory-mapped control interfaces for hardware modules, where each signal in the interface can be directly tied to a register or wire with explicit naming and assignment.",
      "description_length": 457,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-Lite register banks with write interfaces that include valid signals. It supports data packing/unpacking, multiplexing, concatenation, and selection logic for register interfaces with combinational logic. Concrete use cases include implementing memory-mapped control registers in hardware designs and routing AXI4-Lite write transactions to multiple register targets.",
      "description_length": 438,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a datapath register interface and an association list indexed by field names. It operates on types representing AXI4-Stream datapath registers and string-keyed lists of values. Use this to serialize or deserialize register interfaces for debugging, configuration, or integration with external systems.",
      "description_length": 351,
      "index": 453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface into a monadic interface over a bus, enabling the combination of multiple AXI4 slave-to-master signals into a single structure. It operates on AXI4 slave-to-master bus interfaces, specifically handling bursts and transactions across memory-mapped connections. Use this when aggregating AXI4 slave responses into a unified master interface, such as coordinating multiple AXI4 peripherals into a single bus output.",
      "description_length": 486,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning values to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. It works with `Write_with_valid` interfaces, which are used to model AXI4-Lite write channels with valid signaling. Use cases include building memory-mapped register banks and wiring control logic in AXI-based hardware designs.",
      "description_length": 495,
      "index": 455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface into a monadic interface over an AXI4 master-to-slave signal bundle, effectively lifting the monad through the interface. It operates on AXI4 master-to-slave signal bundles and combines monadic values across the interface. A concrete use case is synchronizing multiple AXI4 master signals into a single monadic structure, enabling structured composition of hardware description logic.",
      "description_length": 458,
      "index": 456,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a register within a module context into a new register structure, reorganizing how register fields are accessed or manipulated. It operates specifically on register types defined within a module `M`, allowing for structured access to register fields in AXI interface implementations. A concrete use case includes re-exporting register fields in a flattened or grouped manner for easier integration with AXI4 or AXI4-Lite memory-mapped interfaces.",
      "description_length": 500,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Stream source interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating multiple interfaces, and selecting between interfaces using priority or one-hot encoding schemes. Concrete use cases include constructing and validating AXI4-Stream signals for hardware simulation, and implementing stream multiplexing logic in FPGA designs.",
      "description_length": 469,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an interface type and association lists indexed by field names, enabling programmatic access and manipulation of register fields by string keys. It operates on data structures representing AXI4-Lite register banks, where each field is associated with a specific port name. Concrete use cases include dynamically generating register configurations from external data sources or introspecting register layouts for debugging and testing purposes.",
      "description_length": 491,
      "index": 459,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that takes a source of monadic values and returns a monadic source of aggregated values, effectively lifting the monad outside the source structure. It operates on data types involving sources and monads, specifically transforming `'a M.t Source.t` into `'a Source.t M.t`. A concrete use case is combining multiple AXI4-Stream sources within a monadic context, such as gathering data from several streams into a single source after applying a monadic computation.",
      "description_length": 501,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides signal manipulation and wiring utilities for AXI4-Lite master-to-slave interfaces, enabling operations like packing/unpacking, multiplexing, pipeline creation, and named signal group connections. It works directly with `Signal.t` values structured as `Of_signal.comb t` and `Of_signal.t` to represent AXI signal interfaces, emphasizing combinational and registered signal handling. These tools are used in hardware designs requiring lightweight memory-mapped communication, such as connecting CPUs to peripherals or implementing FIFOs with minimal logic overhead.",
      "description_length": 584,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module creates and manipulates AXI4-Stream source interfaces using association lists indexed by field names. It provides `to_alist` to convert an interface into a list of field name-value pairs and `of_alist` to reconstruct an interface from such a list. These operations are useful when dynamically configuring or inspecting AXI4-Stream source signals by name, such as during testbench setup or runtime signal routing.",
      "description_length": 424,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API, specifically for AXI4-Stream datapath components. It supports operations like assigning values to registers, creating wire interfaces with default signals, and applying naming conventions to interface fields. Concrete use cases include implementing AXI4-Stream pipelines with registered stages or connecting streaming data paths using named signals for clarity.",
      "description_length": 468,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module defines operations for constructing and manipulating AXI4-Lite register bank interfaces with write signals and validity flags. It supports data transformations such as packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection logic using one-hot or priority-encoded inputs. These functions are used to implement memory-mapped register banks with synchronized write operations in hardware designs targeting FPGAs or ASICs.",
      "description_length": 461,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI register banks with valid/ready handshaking protocols, using combinational and registered signals as primitive building blocks. It supports tasks like signal wiring, pipeline generation, and interface naming through functions that handle multiplexing, concatenation, and priority encoding on AXI write channels. The module is particularly useful for implementing AXI4-Lite slaves or managing burst transactions in AXI4 memory-mapped interfaces where validity signaling and handshake synchronization are critical.",
      "description_length": 582,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a RAM with per-byte write enables and configurable size, designed for use in AXI4 slave interfaces. It provides a `create` function to instantiate the RAM given a register specification, AXI4 master signals, and size, supporting byte-granular writes. Use cases include implementing AXI4 memory-mapped peripherals with fine-grained write control, such as configuration registers or packet buffers.",
      "description_length": 419,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank for AXI4-Lite and AXI4 memory-mapped interfaces, handling address decoding and register access control. It supports read and write operations with configurable pipelining and register modes, using integer addresses and Hardcaml interfaces for input/output signals. Concrete use cases include building memory-mapped control/status registers in hardware designs that interface with AXI4 or AXI4-Lite buses.",
      "description_length": 443,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to register and wire interfaces within an `Always` block. It supports data types like `Signal.t Read_enable.t` and `Always.Variable.t Read_enable.t`, enabling operations such as value assignment, register creation with optional enable signals, and wire initialization. Concrete use cases include building AXI4-Lite register banks with named signals, conditional assignments in sequential logic, and integrating interface signals with default values or custom naming.",
      "description_length": 529,
      "index": 468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in an AXI4-Stream destination interface, providing direct access to individual signal names, their bit widths, and associated tags. It operates on standard OCaml lists of strings and integers, along with a list of tag values representing signal identifiers. Concrete use cases include configuring hardware interfaces, generating signal declarations, and mapping stream data to named ports during synthesis or simulation.",
      "description_length": 475,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic value of a list, effectively lifting the monad outside the interface. It operates on data structures involving interfaces and monads, specifically working with types `'a M.t O.t` and `'a O.t M.t`. A concrete use case is aggregating multiple register fields into a single interface while preserving monadic effects.",
      "description_length": 408,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-Lite register banks with write interfaces that include valid signals. It supports data packing/unpacking, multiplexing, concatenation, and selection operations on register bank interfaces represented as combinational logic. Concrete use cases include building configurable hardware registers with synchronized write operations and generating logic for register bank access arbitration in AXI4-Lite peripherals.",
      "description_length": 481,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Lite slave-to-master interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection based on priority or one-hot encoding. Use cases include building and validating AXI4-Lite register interfaces, routing AXI4-Lite signals, and constructing test stimuli by setting fields to constant integer values.",
      "description_length": 445,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module implements combinational logic operations for register interfaces, supporting values of type `comb Register.O.t`. It provides functions for packing/unpacking, multiplexing, concatenation, and selection operations, including priority and onehot selection with optional branching factors. Use cases include constructing and manipulating register-based control logic and data paths in AXI4 memory-mapped or stream interfaces.",
      "description_length": 434,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4-Lite slave interface signals to a master interface using field names as keys, enabling straightforward signal association. It operates on association lists pairing string field names with signal values, facilitating easy conversion between structured interfaces and flat lists. Use this when connecting AXI4-Lite components where direct port mapping by name is required, such as in testbenches or glue logic between named signals and interface modules.",
      "description_length": 483,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Stream source interfaces. It supports data type transformations using types `comb` and `t`, enabling operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. Concrete use cases include building complex streaming data paths, routing logic for AXI4-Stream signals, and validation of signal widths during interface construction.",
      "description_length": 496,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Of_signal",
      "library": "hardcaml_axi",
      "description": "This interface provides operations for creating and managing register banks, signal routing, and interface manipulation in hardware designs, focusing on memory-mapped and streaming protocols. It works with signal vectors, packed interface types, and hardware signal representations (`I.Of_signal.t`), enabling tasks like burst transfer handling, pipeline stage creation with enable-controlled registers, and protocol-specific signal validation. Specific use cases include implementing AXI4 memory-mapped burst transactions, AXI4-Lite lightweight register interfaces, and AXI4-Stream data pipelines with strict signal width guarantees.",
      "description_length": 634,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides operations to convert between a structured interface and an association list indexed by field names, enabling dynamic access and construction of register bank fields. It works with the `Write_with_valid.t` type representing AXI4 register interfaces, alongside string-keyed data mappings. Concrete use cases include dynamically configuring AXI4 register banks from external data sources or inspecting register field values at runtime.",
      "description_length": 454,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for AXI4-Stream interface ports, including their names, widths, and associated tags. It provides direct access to labeled signal definitions used in datapath register implementations. Use this module to inspect or generate signal mappings for AXI4-Stream connections in hardware descriptions.",
      "description_length": 339,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make",
      "library": "hardcaml_axi",
      "description": "This module suite provides a comprehensive framework for building and manipulating AXI4-Lite memory-mapped interfaces in hardware designs. It centers around data types like `t` for representing AXI4-Lite signals, `comb` for combinational logic, and `Reg_spec.t` for register definitions, supporting operations such as mapping, zipping, packing, and multiplexing signals across buses. Functional combinators enable transformations over structured transactions, while submodules handle routing, byte-level writes, register access, and state machine translation between protocols. Examples include implementing memory-mapped register banks, routing AXI4-Lite transactions to multiple slaves, bridging internal buses to AXI4-Lite peripherals, and constructing FPGA control logic with dynamic configuration and debug support.",
      "description_length": 820,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines a register bank interface with read enable functionality, specifying port names and widths for AXI4-Lite compliant hardware registers. It provides structured access to register fields through typed tags and supports read operations via generated enable signals. This interface is used to implement memory-mapped control and status registers in hardware designs targeting Xilinx FPGAs.",
      "description_length": 404,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-All",
      "library": "hardcaml_axi",
      "description": "This module combines and lifts monadic values within an interface structure, transforming a collection of monadic interface elements into a single monadic interface. It operates on interface types parameterized by a monad, enabling composition of signal or port definitions that carry monadic effects. This is useful when constructing AXI4-Lite interfaces where multiple signals must be synchronized or grouped under a single monadic context, such as bundling master-to-slave signals with shared state or configuration.",
      "description_length": 519,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structural manipulation of AXI4-Stream compliant datapaths, enabling operations like mapping, folding, and zipping over structured register interfaces with named, typed signal fields. It works with hardware interface descriptions represented as first-class values containing typed port mappings and bit-width specifications. These utilities are used to build and transform streaming data pipelines in FPGA designs, particularly for handling unaddressed, high-throughput data transfers between components.",
      "description_length": 541,
      "index": 482,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, enabling tasks like packing, unpacking, and multiplexing register fields. It supports data types representing register interfaces with combinational logic signals, allowing direct bit-level transformations and validation. Concrete use cases include constructing register banks from integer values, validating signal widths, and implementing priority or one-hot selection logic for register interfaces.",
      "description_length": 488,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest",
      "library": "hardcaml_axi",
      "description": "This module provides structural manipulation and dataflow operations for AXI4-Stream destination interfaces, including mapping, zipping, and conversion between streams and lists. It handles combinational logic for data acknowledgment signaling and manages metadata like signal names, bit widths, and port associations. These capabilities enable efficient processing of continuous, address-free data streams in hardware pipelines, such as high-throughput FIFOs or streaming accelerators.",
      "description_length": 486,
      "index": 484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O",
      "library": "hardcaml_axi",
      "description": "This module provides operations for composing, transforming, and analyzing hardware register structures with type-safe combinators, including zipping, mapping, folding, and converting between register lists and structured values. It works with typed registers (`'a Register.O.t`) that encapsulate metadata like port names, widths, and tags, enabling precise structural manipulation and serialization. These capabilities are used to define AXI4 memory-mapped register interfaces, generate signal metadata from always blocks, and construct combinational logic while ensuring correctness across complex register field hierarchies.",
      "description_length": 627,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Handles conversion between AXI4-Stream destination interfaces and association lists indexed by field names. Works with `'a t` and `(string * 'a) list` types. Useful for dynamically constructing or inspecting AXI4-Stream interfaces using string-labeled fields.",
      "description_length": 259,
      "index": 486,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module handles combinational logic operations on register interfaces, supporting values of type `comb` and structured register types. It provides functions for packing, unpacking, muxing, concatenation, and selection operations with optional branching factors. Use cases include constructing and manipulating AXI4-Stream and AXI4-Lite register interfaces in hardware designs.",
      "description_length": 380,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module handles register bank operations for AXI4-Lite read-enable interfaces using combinational logic. It provides functions to pack, unpack, multiplex, and validate register fields, ensuring correct bit widths and enabling efficient data routing. Use cases include implementing memory-mapped register banks with dynamic field selection and validation in AXI4-Lite peripherals.",
      "description_length": 383,
      "index": 488,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4 interface signals, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with fixed-width bit vectors and structured interface types defined in the AXI4 specification. Concrete use cases include building register banks, routing AXI4 signals based on control logic, and validating signal widths during design synthesis.",
      "description_length": 487,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Stream interface signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with fixed-width bit vectors and structured interface types defined by the `Datapath_register.I` signature. Concrete use cases include constructing data paths for streaming applications, such as routing data between FIFOs, applying constant values, or selecting between multiple input streams based on control signals.",
      "description_length": 510,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside. It operates on a polymorphic record type `'a t` where each field is wrapped in a monad `M`. A concrete use case is aggregating multiple AXI4-Lite slave interface signals into a single master interface signal, enabling synchronized signal handling across different data paths.",
      "description_length": 418,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 master-to-slave interface signals represented as bit vectors. It supports packing and unpacking interfaces into vectors, multiplexing and concatenating multiple interfaces, and selecting between interfaces using priority or one-hot encoding. These functions are used to implement and verify memory-mapped AXI4 bus logic in hardware designs.",
      "description_length": 391,
      "index": 492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the interface for translating register bank signals between slave and master components in an AXI4 design. It provides access to signal names, widths, and tags that correspond to the register bank's port connections. Use this module to map register bank ports during hardware synthesis or to inspect signal properties for debugging and integration tasks.",
      "description_length": 374,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Converts register interfaces to and from association lists mapping string names to values. Works with register types structured as associative collections indexed by port names. Useful for dynamically inspecting or reconstructing register configurations from named value pairs.",
      "description_length": 277,
      "index": 494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4 master-to-slave register interfaces. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations on `comb` typed interfaces, enabling direct manipulation of AXI control and data signals. Use cases include constructing and validating AXI register banks, routing AXI signals between components, and implementing register-based control logic in hardware designs.",
      "description_length": 453,
      "index": 495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register banks for AXI4 interfaces by specifying port names, widths, and associated tags. It provides structured access to register fields with concrete naming and bit-width information. Use this to generate hardware registers with well-defined signal names and sizes in AXI4 memory-mapped designs.",
      "description_length": 318,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the creation and manipulation of register interfaces for AXI-based hardware designs through signal-level operations and structural combinational logic. It operates on AXI register bank interfaces represented as `I.Of_signal.comb` and `I.Of_signal.t` types, providing utilities for packing/unpacking, multiplexing, concatenation, validation, and register instantiation to implement memory-mapped AXI4-Lite interfaces or manage high-throughput AXI4 burst transactions. The module also facilitates signal wiring, naming conventions with customizable prefixes/suffixes, and structural organization of complex register banks in memory-mapped or streaming data-path designs.",
      "description_length": 688,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables manipulation of AXI4-Stream source interfaces through combinational logic and registered signal operations, supporting tasks like multiplexing, concatenation, and priority selection. It works directly with AXI4-Stream source types (`Source.t`) and combinational signal representations, facilitating hardware design workflows for streaming data pipelines. Key use cases include constructing and validating stream interfaces, wiring signal sources with named conventions, and implementing pipelined data transfers in FPGA or ASIC designs where address-free burst streaming is required.",
      "description_length": 603,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating register bank interfaces with read enable functionality using a combinatorial logic type. It supports data types including bit vectors, integers, and valid/ready handshaking signals, organized into structured interfaces. Concrete use cases include implementing AXI4-Lite register banks, multiplexing between multiple register interfaces based on select signals, and packing/unpacking register fields to and from flat bit vectors for hardware synthesis.",
      "description_length": 518,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module handles bidirectional signal routing between AXI slave and master interfaces using combinational logic. It supports operations like packing/unpacking signals to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with valid control signals. It works with AXI slave-to-master interface types, using a combinational logic type for signal manipulation. Use cases include constructing complex AXI interconnects, implementing arbitration logic, or mapping AXI signals through configurable routing.",
      "description_length": 530,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for register interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb` and `t` types representing combinational logic signals and register interface values. Concrete use cases include constructing and validating register mappings, selecting between multiple data sources, and converting integer values to register-compatible formats.",
      "description_length": 443,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make",
      "library": "hardcaml_axi",
      "description": "This module instantiates and implements an AXI4-Stream interface for high-throughput streaming applications, managing source and destination ports with support for combinational and registered logic. It provides core operations to connect, transform, and route streaming data through types like `'a t` and `'a Dest.t`, enabling mapping, zipping, folding, and pipeline registration with precise control over validity and ready signals. Child modules handle bit-vector conversions, interface aggregation, and pipeline stage configuration, allowing use cases such as multiplexing stream interfaces, constructing synchronized FIFOs, and segmenting data paths for timing closure. Specific examples include converting port configurations to bit vectors for synthesis, combining multiple streams into a unified interface, and inserting registered pipeline stages to manage handshake protocols across clock domains.",
      "description_length": 907,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential operations for managing AXI4 memory-mapped write interfaces with validity signaling. It supports signal manipulation through assignment, packing, multiplexing, and priority encoding, while working with register and wire types that align with AXI4's protocol for high-throughput burst transfers. These capabilities are used to implement pipelined register banks, validate interface connectivity, and ensure correct signal propagation in hardware designs requiring memory-mapped communication.",
      "description_length": 541,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a given interface structure. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite register banks with named signals, assigning default values to interface wires, and conditionally updating register values in hardware descriptions.",
      "description_length": 475,
      "index": 504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Demultiplexer",
      "library": "hardcaml_axi",
      "description": "Handles demultiplexing a single AXI4 master signal across multiple slave interfaces based on address offsets. Works with AXI signal types encapsulated in `Slave_to_master` and `Master_to_slave` wrappers, using a list of slaves and a single master. Used to route AXI transactions to the correct slave device in memory-mapped systems.",
      "description_length": 332,
      "index": 505,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface.Make_read_write",
      "library": "hardcaml_axi",
      "description": "This module generates a C union for a memory-mapped read/write interface, using the provided Read and Write modules to define register layout and access behavior. It works with register descriptions that specify field offsets, widths, and access types. A concrete use case is generating C headers for hardware register interfaces that must be memory-mapped and accessed via AXI4-Lite in an FPGA design.",
      "description_length": 402,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Pipeline_stage_descr",
      "library": "hardcaml_axi",
      "description": "This module defines a pipeline register for AXI4-Stream interfaces, including an optional instance name and a clear signal. It works with `Hardcaml.Signal.t` to control register behavior in hardware descriptions. Use this to model individual pipeline stages with reset functionality in AXI4-Stream data paths.",
      "description_length": 309,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in an AXI4-Stream interface, providing direct access to port metadata as lists of strings and integers. It includes functions to retrieve port names, widths, and associated tags, enabling precise signal handling in hardware description code. Use this module to configure or inspect AXI4-Stream interface signals in Hardcaml designs without relying on runtime computations.",
      "description_length": 427,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Stream source interfaces using the Always API, including registering signals, assigning values, and applying naming conventions. It works with interface containers composed of `Hardcaml.Always.Variable.t` and associated signal types. Concrete use cases include building and managing AXI4-Stream source logic within an always block, such as connecting streaming data outputs to registered or wired signals with custom naming.",
      "description_length": 485,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank for AXI4-Lite slave interfaces, handling address decoding and data routing for register reads and writes. It works with signals and lists of signals to manage read enables and write values, supporting pipelined read operations with specified external and internal cycle delays. Concrete use cases include connecting memory-mapped hardware registers to AXI4-Lite buses in FPGA designs, such as configuring peripherals or reading sensor data.",
      "description_length": 479,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating hardware register interfaces in AXI4-Stream datapaths, focusing on signal transformations like packing, unpacking, multiplexing, and concatenation. It works with signal interface values of type `Datapath_register.I.Of_signal.t`, enabling precise control over data width validation and hierarchical naming during interface wiring. Specific use cases include building high-throughput streaming data pipelines, managing burst transfers without address phases, and integrating hardware components with AXI4-Stream protocols.",
      "description_length": 586,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 slave-to-master interfaces represented as bit vectors. It supports constant initialization, packing/unpacking, multiplexing, concatenation, and selection operations on these interfaces. Use cases include constructing and validating AXI4 signal bundles, routing data between AXI components, and implementing control logic for AXI-based hardware designs.",
      "description_length": 403,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations for defining and manipulating registers and signals in the context of AXI4 memory-mapped interfaces. It supports data types such as `Register.O.t` for register instances and `Signal.t` for representing values in hardware descriptions. Concrete use cases include creating register variables with optional enable signals, assigning signal values to registers, and applying naming conventions to signals for clarity in generated hardware.",
      "description_length": 467,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for AXI4-Lite write interfaces with valid signals. It supports operations like assigning values to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include implementing AXI4-Lite slave registers with synchronous updates and managing control/status registers in hardware designs.",
      "description_length": 468,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_mode.Mode",
      "library": "hardcaml_axi",
      "description": "This module defines register behavior modes for AXI4 register configuration, including `Toggle_low`, `Toggle_high`, and `Hold`. It provides a `sexp_of_t` function to convert these modes to S-expressions for serialization or debugging. These modes control how a register responds after a write operation, such as holding its value or toggling to a specific state.",
      "description_length": 362,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4 master-to-slave register interfaces to and from association lists, using field names as keys. It provides `to_alist` and `of_alist` functions to convert between these representations, enabling straightforward serialization and deserialization of register bank data. This is particularly useful when interfacing with external systems or configurations that require named field access, such as hardware description files or runtime register programming.",
      "description_length": 482,
      "index": 516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S",
      "library": "hardcaml_axi",
      "description": "This module defines AXI4-Stream source and destination interfaces for streaming data without address phases, supporting unlimited burst sizes. It provides functions to connect sources and destinations, register signals, and manage data paths in a hardware description context. Concrete use cases include implementing high-throughput data pipelines and FIFO-based communication between hardware components.",
      "description_length": 405,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Make",
      "library": "hardcaml_axi",
      "description": "Implements address space decoding logic for AXI4 memory-mapped interfaces using a provided combinational logic module. It operates on address spaces defined by upper and lower bounds and produces a decoder map that selects the appropriate address space based on an input address. Useful for routing AXI4 transactions to the correct hardware component by evaluating address ranges efficiently.",
      "description_length": 392,
      "index": 518,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Stream source interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types representing hardware signals and `t` types structured as AXI4-Stream interfaces. Concrete use cases include constructing and validating AXI4-Stream data paths, routing data streams based on priority or one-hot selection, and converting between structured interfaces and flat bit vectors.",
      "description_length": 493,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a master-to-slave interface containing monadic values into a monadic value containing a master-to-slave interface. It works with AXI4 master-to-slave signal types wrapped in a monad `M`, enabling composition of interfaces where each signal is computed asynchronously or under a computational effect. A concrete use case is aggregating AXI4 register banks with individually computed signals into a single interface once all signals are resolved.",
      "description_length": 498,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to construct and manipulate AXI4-Stream destination interfaces using the Always API. It supports operations like assigning signals to interface variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. These capabilities are useful for implementing AXI4-Stream compatible hardware modules with structured signal handling and clear field naming.",
      "description_length": 437,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module creates and manipulates AXI4-Stream source interfaces using association lists indexed by field names. It supports converting between association lists and stream sources, enabling dynamic field-based data handling. Use it to construct or deconstruct AXI4-Stream signals with named fields for simulation or testbench purposes.",
      "description_length": 337,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Stream source interfaces using the Always API. It supports operations like assigning signals to variable interfaces, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works with data types such as `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, specifically tailored for AXI4-Stream source implementations. Use cases include building and managing streaming data interfaces in hardware designs where address phases are unnecessary and unlimited burst sizes are required.",
      "description_length": 622,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Stream interfaces. It supports data transformations such as packing/unpacking to and from bit vectors, multiplexing, concatenation, and priority/one-hot selection across multiple streams. Concrete use cases include building custom stream multiplexers, routing logic for data pipelines, and constant initialization for testbenches or configuration logic.",
      "description_length": 444,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a list of monadic interface values into a monadic value of a list interface, effectively combining multiple monadic computations into a single one. It operates on data types involving interfaces (`I.t`) and a monad (`M.t`), allowing the lifting of monadic effects from individual interface components to the entire structure. A concrete use case is aggregating multiple AXI register banks with monadic effects into a single unified interface, simplifying control and data flow in hardware description code.",
      "description_length": 560,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating AXI4 slave-to-master interface signals. It supports data packing/unpacking, multiplexing, concatenation, and selection operations on `comb` typed interfaces, enabling direct hardware mapping. Concrete use cases include building register banks, routing AXI signals based on control logic, and constructing complex AXI transactions from smaller components.",
      "description_length": 438,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps between an interface type and an association list of named fields, enabling dynamic access and construction of AXI register banks by field name. It operates on values of type `'a I.t`, converting them to or from lists of string-keyed `'a` values. Use this to programmatically inspect or build AXI interfaces from named field data, such as when generating register maps or configuring hardware blocks from external descriptions.",
      "description_length": 444,
      "index": 527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4 master-to-slave interfaces using the Always API. It supports creating and assigning register and wire variables, applying signal names with optional prefixes/suffixes, and extracting signal values from variables. It works directly with `Master_to_slave.t` interfaces containing `Always.Variable.t` elements, enabling structured interface handling within always blocks.",
      "description_length": 418,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4 memory-mapped interface signals as bit vectors. It supports operations like packing/unpacking signals to/from bit vectors, multiplexing, concatenation, and selection with priority or one-hot encoding. These functions are used to implement register banks and control logic where AXI master-to-slave signals need to be routed or modified based on system state or configuration.",
      "description_length": 425,
      "index": 529,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI slave-to-master signal fields to associative lists using port names as keys. It provides `to_alist` and `of_alist` functions to convert between a record-like structure and a list of string-keyed value pairs. This enables dynamic inspection and construction of AXI interfaces based on field names, useful for introspection or generating signal mappings in testbenches.",
      "description_length": 397,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, applying names to interface fields, and constructing register containers with optional enable signals. It works with `Always.Variable.t` and `Signal.t` types wrapped in a `Read_enable.t` interface, specifically for managing AXI register banks with named fields and structured signal assignments.",
      "description_length": 462,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a structured interface and an association list indexed by field names, enabling dynamic access and manipulation of register fields. It operates on types representing AXI4 register banks, specifically handling conversions to and from string-indexed lists of values. Use this to programmatically inspect or configure register banks using field names as keys, such as in testbenches or dynamic register programming scenarios.",
      "description_length": 472,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Demultiplexer-Builder-Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module handles the creation and manipulation of AXI4 slave instances within a demultiplexer builder, specifically managing signal routing between master and slave interfaces. It operates on AXI4 signal types, including `Master_to_slave.t` and `Slave_to_master.t`, to define interface connections. Concrete use cases include constructing AXI4-based memory-mapped systems where individual slaves are dynamically addressed and data is routed based on address decoding logic.",
      "description_length": 476,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Config",
      "library": "hardcaml_axi",
      "description": "This module defines configuration parameters for AXI4-Stream instantiations, specifying the width of data and user signal bits. It supports configuring data transfer properties for streaming interfaces without address phases. Use this module to set bit widths when implementing or connecting AXI4-Stream sources and destinations in hardware designs.",
      "description_length": 349,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the interface for AXI4-Lite slave-to-master signal mappings by specifying port names, widths, and associated tags. It provides direct access to lists of port names, widths, and typed tags for signal generation and interface alignment. Useful for hardware description in AXI4-Lite memory-mapped designs where precise signal naming and width definitions are required for synthesis and simulation.",
      "description_length": 414,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic value of the same structure, effectively lifting the monad outside. It operates specifically on `Slave_to_master` interfaces wrapped in a monadic type `'a M.t`. Use this when combining multiple AXI slave-to-master signals within a monadic context, such as wiring register banks where each signal must be processed in a specific sequence or context.",
      "description_length": 447,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic value containing the structure, specifically for write-with-valid interfaces. It operates on data types involving `Write_with_valid.t` and a monad `M`, enabling aggregation of multiple write operations into a single monadic context. A concrete use case is combining multiple register write actions into a single transaction, ensuring they are executed together as part of the same AXI4 write burst.",
      "description_length": 505,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4 master-to-slave interfaces, including signal packing/unpacking, multiplexing, concatenation, and validation. It works with bit vectors and structured interface types to manage data transfer control signals like read and write addresses, data, and responses. Use cases include constructing and validating AXI4 memory-mapped transactions, implementing bus multiplexers, and managing burst transfers in hardware designs.",
      "description_length": 478,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for AXI4-Stream destination interfaces, specifying port names and their corresponding bit widths. It provides direct access to lists of port names, widths, and destination tags, enabling precise interface configuration and signal routing. Use this module to generate or inspect AXI4-Stream destination interface definitions in hardware designs requiring streaming data transfer without address phases.",
      "description_length": 448,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides functional transformations for AXI register interfaces with write and validity signals, including mapping, zipping, folding, and bit-level composition operations. It operates on structured types like `'a Write_with_valid.t`, association lists, and bit-level representations to model memory-mapped AXI4 register banks. These capabilities are used to define, manipulate, and synthesize register banks with validity-controlled write operations, such as constructing state elements from procedural code or specifying register field metadata like names and bit widths.",
      "description_length": 584,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-Stream destination interfaces using combinational and sequential logic. It works with structured destination interfaces (`Dest.Of_signal.t`) and `Hardcaml.Signal.t` values, enabling tasks like multiplexing streams, validating signal widths, inserting pipeline registers, and connecting/naming signals with customizable prefixes/suffixes. Use cases include designing hardware systems requiring efficient, unlimited-length data bursts without memory-mapped addressing, such as high-speed communication interfaces or data processing pipelines.",
      "description_length": 611,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-I-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite register bank interfaces, including packing/unpacking signals to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works directly with combinational logic types (`comb`) and structured register bank interfaces (`t`). Concrete use cases include building and validating AXI4-Lite register banks, routing control signals, and implementing register-based configuration logic in hardware designs.",
      "description_length": 521,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4 slave-to-master interfaces using the Always API, enabling direct signal assignment, register creation, and naming of interface fields. It operates on `Slave_to_master.t` interfaces composed of `Always.Variable.t` signals, supporting both synchronous and combinational logic. Concrete use cases include building AXI4 slave logic that responds to master requests, such as memory-mapped register banks or data streaming interfaces.",
      "description_length": 478,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-All",
      "library": "hardcaml_axi",
      "description": "Transforms a register interface within a module context by applying a mapping function to all register fields. It operates on register types structured as `M.t Register.I.t`, producing a new register interface of type `'a Register.I.t M.t`. This function is useful for generating register layouts with consistent field mappings across different modules or configurations.",
      "description_length": 371,
      "index": 544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_space_tree",
      "library": "hardcaml_axi",
      "description": "Represents an address space as a binary tree optimized for decoding AXI4-Lite memory-mapped interfaces. It works with address ranges defined over a fixed number of address bits, organizing them into a structure that enables efficient address decoding. Used to implement hardware address decoders in FPGA designs where fast lookup of slave peripherals is required based on incoming AXI address signals.",
      "description_length": 401,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Of_signal",
      "library": "hardcaml_axi",
      "description": "This interface provides operations for constructing and manipulating AXI4-Stream datapath register interfaces through signal transformations like multiplexing, concatenation, and priority selection, alongside utilities for creating wires, registers, and pipelined stages. It operates on `Datapath_register.IO.Of_signal.t` structures, which represent signal-level AXI4-Stream register interfaces, and includes functionality for connecting signals bidirectionally and applying hierarchical naming conventions. These capabilities are used in hardware designs to manage streaming data paths efficiently, such as implementing FIFOs, data routing logic, or synchronized pipeline stages in high-throughput systems.",
      "description_length": 707,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for structural manipulation and connectivity management of AXI4 slave-to-master interface signals in RTL designs. It supports operations like signal packing/unpacking, multiplexing, concatenation, and register instantiation, while working directly with AXI4 signal interfaces and named hardware registers. These tools are used to implement memory-mapped register banks, connect hardware components via AXI4 protocols, and manage signal routing with customizable naming conventions.",
      "description_length": 512,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-Stream destination interfaces. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations on streams with constant or variable fields. Typical use cases include building data path logic for streaming applications, such as routing or merging data streams based on control signals.",
      "description_length": 404,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4-Stream destination interfaces represented as bit vectors. It supports constant initialization, packing/unpacking, multiplexing, concatenation, and selection operations on stream interfaces. Concrete use cases include constructing and validating AXI4-Stream hardware designs where precise control over dataflow and signal widths is required.",
      "description_length": 391,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate AXI4-Stream source interfaces using bit vectors. It supports constant initialization, packing/unpacking, multiplexing, concatenation, and selection operations on streams of fixed-width data. Concrete use cases include building data pipelines, routing streams based on control signals, and validating signal widths in AXI4-Stream hardware designs.",
      "description_length": 406,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register",
      "library": "hardcaml_axi",
      "description": "Implements a state machine to manage data registration for an input bus, handling control signals and data flow. Works with AXI4 memory-mapped interfaces, specifically for synchronizing input and output data paths. Used in FPGA designs to ensure correct timing and handshaking between bus components during data transfers.",
      "description_length": 322,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Stream interface signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works directly with `comb Datapath_register.IO.t` and `comb` types, representing structured and vectorized hardware signals respectively. Concrete use cases include building data path logic for AXI4-Stream sources and destinations, such as routing logic for data streams, signal width validation, and constant initialization for interface fields.",
      "description_length": 532,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-Lite register interfaces, including packing/unpacking signals to vectors, multiplexing and concatenating interfaces, and selecting between prioritized or one-hot encoded inputs. It works directly with combinational logic types (`comb`) and structured interface types (`t`) representing AXI4-Lite signals. Concrete use cases include building register banks with dynamic field selection, implementing control logic for AXI4-Lite slaves, and constructing complex register maps from constant or runtime-defined values.",
      "description_length": 588,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides register and signal manipulation operations for AXI4 interface logic, including signal packing/unpacking, concatenation, multiplexing, and priority/one-hot selection. It works with `Register.O.Of_signal` types to model hardware registers and signals, enabling precise control over data flow and register transfers. These operations are used to implement AXI4-Lite and AXI4-Stream interfaces, manage burst transactions, and structure control logic patterns in memory-mapped or streaming data contexts.",
      "description_length": 521,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for AXI4 interface implementations. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Lite control registers with named fields or streaming data paths with burst support using AXI4-Stream.",
      "description_length": 441,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API, specifically for AXI4-Stream datapath components. It supports operations like assigning values to registers, creating wire interfaces with default signals, and applying naming conventions to interface fields. Concrete use cases include building AXI4-Stream sources or destinations with registered or combinational signals, such as connecting FIFOs or data pipelines in hardware designs.",
      "description_length": 493,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module implements combinational logic operations for AXI4-Stream destination interfaces, enabling manipulation of stream data through functions like packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. It works with `comb` types representing combinational signals and `t` structures modeling AXI4-Stream destination interfaces. Use it to construct and validate AXI4-Stream destination logic, route stream data between components, and manage valid-ready handshakes in dataflow pipelines.",
      "description_length": 518,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to construct and manipulate AXI4-Stream destination interfaces as signal bundles, enabling structural operations like multiplexing, concatenation, and pipeline insertion. It works with signal-based representations of AXI4-Stream protocols, focusing on combinational logic and hardware signal wiring. Specific use cases include building high-throughput data pipelines, connecting streaming modules, and applying naming conventions to signals in memory-mapped or burst-capable hardware designs.",
      "description_length": 523,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register banks for AXI4-Lite write interfaces with valid signaling, specifying port names and widths. It provides structured access to register fields using tags and supports concrete operations like register updates and read-backs. Use cases include implementing memory-mapped control registers in hardware designs where each register has a defined name, width, and access behavior.",
      "description_length": 403,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles register bank operations for AXI4 interfaces using bit-level representations. It provides functions to pack, unpack, multiplex, and validate register fields, ensuring correct bit widths and enabling efficient register configuration and selection. Use cases include constructing and manipulating AXI4 register banks from integer values or bit vectors, and implementing register-based control logic with priority or one-hot selection schemes.",
      "description_length": 460,
      "index": 560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite slave-to-master port manipulation, including signal packing, unpacking, multiplexing, and concatenation. It works with AXI4-Lite interface types represented as records of signals, where each field corresponds to a specific AXI signal. Concrete use cases include constructing and validating AXI4-Lite interface signals, routing data between AXI components using multiplexers, and converting between structured interfaces and flat bit vectors for synthesis or simulation.",
      "description_length": 535,
      "index": 561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-Pipeline_stage_descr",
      "library": "hardcaml_axi",
      "description": "Represents a single register within a pipeline stage, primarily used to manage signal propagation and state retention in AXI4-Stream data paths. It includes an optional instance name for identification and a clear signal to reset the register's state. This structure is essential for implementing pipelined data processing units where controlled data flow and reset capability are required.",
      "description_length": 390,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in an AXI4 master-to-slave interface, providing direct access to signal identifiers and their bit-widths. It works with string and integer data types to represent port metadata, alongside a list of tags for interface signals. Concrete use cases include generating signal declarations, validating interface configurations, and mapping signals in hardware description code.",
      "description_length": 426,
      "index": 563,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles register bank operations for AXI4-Lite write interfaces with valid signals, operating on bit vectors. It provides functions to pack, unpack, multiplex, and validate register interfaces, ensuring correct signal widths and enabling priority or one-hot selection logic. Use cases include constructing and managing memory-mapped register banks with dynamic signal routing and validation in AXI4-Lite peripherals.",
      "description_length": 428,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4-Stream destination interfaces using combinational logic, including packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces with priority or one-hot encoding. It supports data types such as `comb` (a combinational logic type) and `t`, which represents an AXI4-Stream destination interface with typed fields. Concrete use cases include constructing flexible stream multiplexers, validating signal widths in stream pipelines, and dynamically routing AXI4-Stream data paths based on control signals.",
      "description_length": 616,
      "index": 565,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 slave-to-master interface signals represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating multiple interfaces, and priority or one-hot selection between interfaces based on valid signals. These functions are used to implement complex AXI4 bus multiplexing, routing, and control logic in hardware designs.",
      "description_length": 428,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module provides functions for structural manipulation and conversion of AXI slave-to-master interface signals, enabling operations like mapping, zipping, and folding over collections of interface elements. It works with typed representations of AXI response data, including signal lists, association lists keyed by port names, and bitvector encodings, while exposing metadata such as port widths and identifiers. These utilities are particularly useful for synthesizing AXI-compliant responses, aggregating error states across parallel channels, and dynamically constructing interface hierarchies from bit-level specifications.",
      "description_length": 632,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a data path register interface containing monadic values into a monadic value containing a data path register interface. It operates on types involving `Datapath_register.IO.t` and a monad `M`, effectively reorganizing nested structures. A concrete use case is flattening a collection of register interfaces with deferred computations into a single deferred computation of register interfaces, enabling bulk handling of register updates within a monadic context.",
      "description_length": 516,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to validate, transform, and structure AXI4-Lite interface signals through operations like packing/unpacking, multiplexing, pipeline creation, and signal assignment. It operates on AXI4-Lite transaction types defined in associated modules, enabling hardware designs to implement memory-mapped interfaces for peripherals, manage hierarchical signal naming, and insert register stages to meet timing constraints.",
      "description_length": 440,
      "index": 569,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating register bank interfaces using a combinational logic type. It supports data types like `comb I.t` for representing structured register fields and `comb` for flat bit vectors, with functions for packing, unpacking, multiplexing, and validating signal widths. Concrete use cases include building memory-mapped register banks for AXI4-Lite interfaces, implementing priority-encoded register selection, and generating constant or one-hot register configurations.",
      "description_length": 524,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic value containing the structure, specifically for interfaces with a read enable signal. It works with data types involving `'a M.t Read_enable.t`, lifting the monad outward. A concrete use case is aggregating multiple AXI register reads into a single monadic computation, enabling sequential or conditional read operations across an interface.",
      "description_length": 449,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4 slave-to-master signal interfaces, including constant assignment, packing/unpacking, multiplexing, and register pipelines. It works with `Slave_to_master.Of_signal.comb` and `Slave_to_master.Of_signal.t` types representing AXI signal bundles, enabling efficient handling of memory-mapped transactions and burst transfers. Specific use cases include connecting and naming signal interfaces in hardware designs, with support for bidirectional wiring and hierarchical naming conventions to manage complexity in FPGA or ASIC development flows.",
      "description_length": 610,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate register interfaces for AXI4-Stream datapaths. It supports data transformations such as packing/unpacking to and from bit vectors, multiplexing, concatenation, and priority/one-hot selection across register interfaces. Concrete use cases include building configurable stream datapaths with dynamic signal routing, such as in FIFOs, packet processors, or pipeline stages where field-level control and bit-width consistency are critical.",
      "description_length": 506,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly converts between a structured AXI4 master-to-slave interface and an association list indexed by field names. It supports the `to_alist` and `of_alist` operations, enabling serialization and deserialization of interface data using string keys. This is useful for dynamically constructing or inspecting AXI4 signals by name, such as during testbench setup or runtime configuration.",
      "description_length": 400,
      "index": 574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32",
      "library": "hardcaml_axi",
      "description": "This module manages 32-bit AXI4-Lite and AXI4-Stream data paths with memory-mapped register banks, RAM, and demultiplexing logic, enabling safe synchronization, bit-level manipulation, and structural transformations. It provides data types like `comb`, `'a I.t`, and `Write_with_valid.t` for handling combinational signals, register interfaces, and synchronous updates, along with operations for mapping, zipping, folding, and address decoding. You can build hierarchical register structures, implement burst-capable memory slaves, configure byte-aligned RAM with partial writes, and route AXI transactions to multiple peripherals based on address ranges. Examples include converting between bit vectors and integers, defining control registers with enable signals, and synthesizing AXI response logic for FPGA peripherals.",
      "description_length": 823,
      "index": 575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module handles operations on AXI4 register bank interfaces using combinational logic. It provides functions to pack, unpack, mux, and concatenate interface signals, along with validation and width assertion utilities. Use cases include constructing and manipulating AXI4-Lite and AXI4-Stream register banks in hardware designs.",
      "description_length": 332,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and their corresponding bit widths for AXI4 interface implementations. It provides direct access to lists of port names, widths, and register tags used in hardware register descriptions. These values are used to specify the structure of AXI4-Lite and AXI4-Stream register interfaces in hardware design.",
      "description_length": 342,
      "index": 577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-module-type-Comb",
      "library": "hardcaml_axi",
      "description": "This module handles combinational logic operations for AXI4-Lite slave-to-master interfaces, including signal packing, unpacking, multiplexing, and validation. It works with `comb` and `t` types representing interface signals and their configurations. Concrete use cases include constructing and validating AXI4-Lite signal bundles, multiplexing between multiple slave interfaces, and converting constant values into properly sized signal vectors.",
      "description_length": 447,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module provides functional transformations and structural manipulation of AXI slave-to-master interface values, focusing on combinational logic construction and bit-level composition. It operates on hardware register interfaces with fixed data and address widths, supporting tagged field introspection, zipping, and conversions between association lists, bit vectors, and signal representations. These operations are used to implement memory-mapped register banks, handle burst transactions, and bridge AXI bus communication patterns in hardware designs.",
      "description_length": 559,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-All",
      "library": "hardcaml_axi",
      "description": "Combines multiple AXI4-Stream destination interfaces into a single interface, lifting the monadic context outside. Works with destination stream interfaces containing monadic values. Useful for synchronizing and merging data from multiple streams into one.",
      "description_length": 256,
      "index": 580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for manipulating register interfaces using combinational logic, including packing, unpacking, multiplexing, and concatenation of register values. It works with types like `comb Register.I.t` and `comb`, supporting bit-level operations and structural transformations. Concrete use cases include constructing and validating register transfers, selecting between multiple register inputs based on priority or one-hot encoding, and converting between integer values and register representations.",
      "description_length": 523,
      "index": 581,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-Read_enable-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for constructing and manipulating AXI4-Lite register banks with signal-level control, including operations for packing/unpacking register fields, creating pipelines, and managing read-enable logic. It works with signal-combined register interfaces (`Read_enable.Of_signal.t`) and supports use cases like connecting hierarchical signal interfaces, applying naming conventions, and validating register configurations in memory-mapped hardware designs.",
      "description_length": 480,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4-Lite register banks for managing memory-mapped transactions between master and slave interfaces, handling address decoding, register updates, and read responses. It defines key types like `Write_with_valid.t` and supports operations for signal routing, pipeline control, and bit-vector manipulation, enabling tasks such as dynamic register selection and type-safe register map synthesis. Submodules extend functionality with named write transactions, pipeline transformations, and structural interface manipulation, supporting precise control over bit widths and port connections. Examples include building synthesizable control/status registers and constructing valid, pipelined AXI4-Lite register interfaces with access control.",
      "description_length": 758,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-I-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a data path register interface containing monadic values into a monadic value containing a data path register interface. It operates on the `Datapath_register.I.t` type, lifting monadic operations through the interface structure. A concrete use case is combining multiple register interfaces with effects into a single interface, enabling sequential composition of AXI4-Stream data path stages.",
      "description_length": 448,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Slave_to_master-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in converting a slave-to-master AXI interface. It provides direct access to port metadata as lists of strings and integers, along with a list of tags associated with the slave-to-master signals. These values are used to generate or inspect the structure of AXI interface signals in Hardcaml workflows, particularly when mapping or transforming AXI bus components.",
      "description_length": 418,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations for defining and manipulating register interfaces in AXI4 designs, specifically handling signal assignment, register creation, and naming conventions. It works with register interfaces composed of signals and variables, supporting both synchronous and combinational logic. Concrete use cases include implementing AXI4-Lite control registers with enable signals, creating AXI4-Stream data pipelines with named signals, and managing memory-mapped register banks with dynamic naming.",
      "description_length": 512,
      "index": 586,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic write-with-valid values into a monadic structure of write-with-valid values, effectively combining multiple write operations into a single monadic context. It operates on data types involving `Write_with_valid.t` wrapped within a module `M`, enabling bulk handling of AXI4 write transactions with validity signals. A concrete use case is aggregating multiple AXI4 register write operations into a single transaction for synchronization or control logic in hardware designs.",
      "description_length": 550,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines a register bank interface with explicit port names and widths, providing access to individual register fields through typed accessors. It works with AXI4-Lite interfaces, where each register port is described by a name and bit-width, and grouped into tags for structured access. Concrete use cases include implementing memory-mapped control and status registers in hardware designs that interface with software drivers or configuration logic.",
      "description_length": 462,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface",
      "library": "hardcaml_axi",
      "description": "This module defines register banks compatible with AXI4-Lite and AXI4 memory-mapped interfaces, providing typed read and write address mappings. It supports configuration of register access modes and pipelining depth for efficient hardware synthesis. Use it to implement peripheral register interfaces where AXI protocol compliance is required with customizable read/write behavior.",
      "description_length": 382,
      "index": 589,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register",
      "library": "hardcaml_axi",
      "description": "This module implements a registered datapath for AXI4-Stream interfaces, ensuring proper synchronization between streaming components using the `tvalid`/`tready` handshake. It provides functions to create and wire registered stages, supporting both simple and expert pipeline configurations with customizable control signals and instance names. Concrete use cases include inserting pipeline registers in high-speed AXI4-Stream data paths to meet timing or constructing multi-stage streaming pipelines with consistent control logic.",
      "description_length": 531,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank connected to an AXI4 master interface, enabling synchronized read and write operations with pipelined access. It handles data transfer between the master and a list of registers, supporting configurable write modes and read enable signals. Concrete use cases include managing hardware registers in AXI4-Lite peripheral designs where precise control over register access timing and data flow is required.",
      "description_length": 442,
      "index": 591,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-I-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines a register bank interface with explicit port names and widths for AXI4-Lite and AXI4-Stream protocols. It provides access to signal tags, port names, and bit widths as lists, enabling direct mapping to hardware description primitives. It is used to generate register interfaces with well-defined input/output ports for memory-mapped or streaming data paths.",
      "description_length": 377,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for transforming and composing AXI register bus interfaces with validity signals, focusing on operations like zipping, mapping, folding, and converting between structured data formats (e.g., association lists and signal lists). It works with typed interface descriptions containing port metadata (names, bit widths, tags) and supports error propagation during register bank composition. Specific use cases include defining memory-mapped register blocks with precise field offsets, serializing hardware port descriptions for synthesis, and managing hierarchical signal structures in AXI4-Lite and AXI4 designs.",
      "description_length": 640,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-With_interface-O",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming AXI4 interface structures through mapping, folding, and zipping, while supporting conversions between hardware signals and structured data formats like lists and S-expressions. It handles tuples and lists of interface values (`O.t`) to construct combinational logic, scan signals, and manage bit-level offsets, with specific applications in AXI4 memory-mapped transactions, register bank generation, and hardware register management using named fields and width specifications.",
      "description_length": 526,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing, unpacking, multiplexing, and validation. It works with interface types composed of address, data, and control signals, represented as packed vectors or structured records. Concrete use cases include constructing and validating AXI4-Lite transactions, multiplexing multiple master interfaces onto a single slave interface, and converting between constant values and interface signals.",
      "description_length": 503,
      "index": 595,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave",
      "library": "hardcaml_axi",
      "description": "The module provides functions for mapping, iterating over, and converting AXI master-to-slave interface data, focusing on structural manipulation of per-port values like names, widths, and tags. It operates on memory-mapped AXI4 and AXI4-Lite interfaces, enabling use cases such as signal width aggregation, bit-level serialization, and combinational logic generation for AXI transactions. Specific utilities include converting between interface lists and structured records, error handling during transformations, and defining bus signal widths for hardware synthesis.",
      "description_length": 569,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module handles register bank interfaces with read enable signals, supporting conversion between register fields and association lists indexed by field names. It works with string-indexed key-value pairs to represent register fields and their values. Use it to map register banks to named fields for dynamic access or configuration, such as reading from or writing to specific registers by name during simulation or test.",
      "description_length": 425,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Source-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational operations for constructing and manipulating AXI4-Stream source interfaces. It supports data transformations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection logic. Concrete use cases include building streaming data pipelines, routing logic for AXI4-Stream signals, and testbench generation with constant or controlled data patterns.",
      "description_length": 437,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-Read_enable-Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential operations for managing register interfaces with read-enable control in AXI4-Lite memory-mapped systems, working with `Read_enable.Of_signal.comb` and `Read_enable.Of_signal.t` types to represent hardware signals and register banks. It supports tasks like creating pipelined register stages, multiplexing signal paths, and applying hierarchical naming conventions to signals for clarity in hardware designs. Specific use cases include implementing AXI4-Lite register banks with dynamic read-enable logic, connecting signal interfaces with priority-encoded selection, and structuring complex signal hierarchies using prefix/suffix-based naming.",
      "description_length": 693,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-Lite master-to-slave signal interfaces represented as bit vectors. It supports operations like packing/unpacking signals to/from a vector, multiplexing between multiple interfaces, concatenation, and selecting signals using priority or one-hot encoding schemes. Concrete use cases include constructing and validating AXI4-Lite control paths, implementing register file access, and managing memory-mapped peripherals with fixed-width data transfers.",
      "description_length": 498,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source-All",
      "library": "hardcaml_axi",
      "description": "Combines a product of monadic values into a monadic product, lifting the monad outside the interface structure. Works with any module implementing the `M` monad interface and transforms a record or tuple of monadic values into a monadic record or tuple. Useful for sequencing multiple AXI4-Stream source operations into a single monadic action, ensuring all effects are applied together.",
      "description_length": 387,
      "index": 601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and bit-widths for AXI4-Lite master-to-slave interface ports. It provides concrete lists of port names, widths, and combined name-width pairs used to construct and validate AXI4-Lite interfaces. These values are used directly in hardware design to ensure correct signal alignment and data transfer between master and slave components.",
      "description_length": 371,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Datapath_register-IO",
      "library": "hardcaml_axi",
      "description": "This module type provides combinational and structural operations for transforming hardware interface signals, including mapping, folding, and scanning, alongside conversions between typed field structures and bit-level representations. It operates on `Datapath_register.IO.t` values, which model register interfaces with tracked signal widths and metadata, facilitating precise control over AXI4-Stream data paths. These capabilities are essential in scenarios like constructing register blocks for streaming pipelines, transforming signal data in hardware compilation, and managing metadata for high-throughput data transfers.",
      "description_length": 628,
      "index": 603,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest-All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple destination interfaces into a single interface, lifting the monadic structure outside. It operates on destination interfaces of type `'a M.t Dest.t`, transforming them into a monadic destination interface `'a Dest.t M.t`. This allows for parallel composition of destinations, enabling synchronized data flow handling in AXI4-Stream contexts.",
      "description_length": 402,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Stream destination interfaces using the Always API. It supports operations like assigning signals to interface variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works with interface containers composed of `Hardcaml.Always.Variable.t` values, enabling structured signal handling in hardware descriptions.",
      "description_length": 437,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Master_to_slave-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the interface for translating AXI4 master signals to slave signals by specifying port names, widths, and tags. It provides concrete signal mappings and metadata required for register bank instantiation in AXI4 memory-mapped designs. Use this when generating hardware interfaces that require precise signal alignment between master and slave components in an AXI4-based system.",
      "description_length": 396,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Dest-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to construct and manipulate AXI4-Stream destination interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and validating signal widths. Concrete use cases include implementing stream multiplexers, parsing incoming stream data, and ensuring correct signal widths in hardware designs.",
      "description_length": 419,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.S-Slave_to_master-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly associates AXI4 slave-to-master signal fields by port name using unsafe operations. It provides `to_alist` and `of_alist` functions to convert between record-style interface values and string-indexed association lists. This is used when dynamically mapping AXI signals by name, such as in automated testbench generation or runtime configuration.",
      "description_length": 366,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O",
      "library": "hardcaml_axi",
      "description": "This module provides functional transformations and structural manipulation of AXI interface descriptions and register banks, supporting operations like mapping, folding, zipping, and layout control over hardware signal interfaces. It operates on AXI interface values (`O.t`), register fields, and port metadata structures, enabling precise control over signal routing and register generation. Key use cases include constructing AXI4-Lite memory-mapped interfaces with burst transfer capabilities, combining hardware interfaces with offset alignment, and synthesizing register banks from procedural blocks while tracking field names and widths.",
      "description_length": 644,
      "index": 609,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Source",
      "library": "hardcaml_axi",
      "description": "This module provides operations to transform, combine, and inspect AXI-Stream interfaces through structural manipulations (e.g., mapping, zipping, folding) and validity signal control. It works with tagged hardware port collections (`'a t`) representing AXI-Stream data sources, enabling combinatorial logic construction and bit-level signal handling. Specific use cases include building streaming data pipelines in FPGA designs, synchronizing valid-ready handshakes, and composing hierarchical AXI-Stream interfaces for high-throughput, non-memory-mapped data transfers.",
      "description_length": 571,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-I",
      "library": "hardcaml_axi",
      "description": "This module supports transformations, multi-input combinations, and error handling across register interfaces through type-safe operations like `map`, `zip`, and `fold`, while enabling conversions between register structures and associative lists. It operates on `Register.I.t` values and associated data forms like lists of registers or tagged fields, with utilities for managing port names, bit-widths, and combinational logic. Use cases include implementing AXI4 memory-mapped and stream interfaces, propagating errors across register banks, and synthesizing register modules from always-block logic or named field specifications.",
      "description_length": 633,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations for manipulating register values represented as bit vectors, including packing, unpacking, concatenation, and multiplexing. It supports operations like `mux`, `concat`, and priority/one-hot selection with optional branching factors, working directly on register types with combinational logic. Concrete use cases include constructing and managing register banks, decoding control signals, and handling data path routing in AXI4 memory-mapped interfaces.",
      "description_length": 485,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.S-Dest",
      "library": "hardcaml_axi",
      "description": "This module provides structural manipulation and conversion utilities for AXI4-Stream destination interfaces, enabling operations like zipping, mapping, folding, and transforming signal bundles with combinators for handling 3-5 input arities. It works with interface values represented as tuples of signals, association lists of port names/signals, and bit-level representations, supporting use cases such as streaming data aggregation, protocol conversion, and FPGA pipeline construction where variable-length data bursts require efficient handshake logic and structural composition. Key applications include high-throughput streaming pipelines in networking, digital signal processing, or video processing systems where address-phase elimination enables continuous data transfer.",
      "description_length": 781,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register-O-Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register interfaces by specifying port names and their corresponding bit widths. It provides direct access to lists of port names, widths, and register tags for hardware register descriptions. It is used to describe AXI register blocks with precise field names and sizes for memory-mapped or stream-based register interfaces.",
      "description_length": 345,
      "index": 614,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Master_to_slave-Make_comb",
      "library": "hardcaml_axi",
      "description": "This module defines operations for manipulating AXI4 master-to-slave interface signals using a combinational logic type. It supports signal transformations such as packing/unpacking, multiplexing, concatenation, and selection, with functions that enforce signal width validation and constant assignment. Use cases include constructing and routing AXI4 control and data paths in hardware designs where combinatorial logic drives interface behavior.",
      "description_length": 447,
      "index": 615,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave-Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4-Lite master-to-slave signal fields to an association list structure, enabling direct conversion between record-like representations and named field-value pairs. It operates specifically on AXI4-Lite interface types, using strings as keys to associate signal names with their corresponding values. Concrete use cases include dynamically inspecting or constructing AXI4-Lite interfaces by field name, such as for debugging, configuration, or integration with external systems that reference signals by name.",
      "description_length": 536,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make",
      "library": "hardcaml_axi",
      "description": "This module connects typed register interfaces to AXI4 memory-mapped protocols, enabling structured control logic synthesis and simulation through combinational and sequential operations on signals. It provides data types like `'a O.t`, `Slave_to_master.t`, `Master_to_slave.t`, and `t` for manipulating register fields, routing transactions, and encoding AXI4 responses with bit-level precision. Operations include dynamic field selection, atomic updates, priority-encoded multiplexing, per-byte write enables, and pipeline registration for AXI4, AXI4-Lite, and AXI4-Stream interfaces. Use it to implement configurable peripherals, build AXI multiplexers, decode transactions into control signals, model on-chip RAM, and generate testbenches with precise signal naming and bit-width tracking.",
      "description_length": 793,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-Lite slave-to-master interface signals using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. It works directly with AXI4-Lite interface types, handling signal and variable interactions for hardware description tasks such as connecting components or defining register behavior.",
      "description_length": 474,
      "index": 618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.S-Register_bank-With_interface-O-Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign signals within an always block using a structured interface. It supports operations like creating registers, wires, and assigning values while handling naming conventions for signals. Concrete use cases include building AXI4-Lite register banks with named fields and managing signal assignments in a memory-mapped interface.",
      "description_length": 380,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4-Stream interfaces for high-throughput, address-free data streaming, providing source and destination descriptions along with pipeline stage definitions. It supports structured manipulation of stream interfaces through combinational logic, signal transformations, and monadic lifting, operating on types like `'a Source.t`, `'a Dest.t`, and `Datapath_register.IO.t` to enable tasks such as multiplexing, concatenation, and field-based access via association lists. Concrete use cases include FPGA-based video streaming, network packet handling, and sensor data aggregation, with submodules offering utilities for bit-vector conversion, pipeline registration, and dynamic interface construction. Key operations include `map`, `zip`, `fold`, and `all`, allowing composition and synchronization of multiple streams while maintaining signal width validation and handshake protocol integrity.",
      "description_length": 914,
      "index": 620,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module manages register banks for AXI4-Lite memory-mapped interfaces, enabling precise bit-level definition, access, and manipulation of register fields using packed bit arrays. It provides core operations for reading and writing register fields, along with submodules that extend functionality for combinational logic, signal routing, interface transformations, and dynamic field access by name. Use cases include building configurable control/status registers, implementing AXI4-Lite peripherals with named fields, and synthesizing register banks with runtime-modifiable values or priority-encoded selection logic. Submodules support tasks like mapping interfaces to association lists, packing/unpacking signals, and sequencing monadic interface operations for hardware verification and FPGA configuration.",
      "description_length": 813,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite",
      "library": "hardcaml_axi",
      "description": "This module provides a framework for constructing and managing AXI4-Lite memory-mapped interfaces in hardware. It defines core data types such as `t` for AXI4-Lite signals, `comb` for combinational logic, and `Reg_spec.t` for register specifications, with operations to map, zip, pack, and multiplex signals across buses. Functional combinators allow transformation of structured transactions, while submodules handle routing, byte-level writes, register access, and protocol translation. Use cases include implementing register banks, routing transactions to multiple slaves, bridging internal buses to peripherals, and building FPGA control logic with dynamic configuration.",
      "description_length": 676,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder",
      "library": "hardcaml_axi",
      "description": "This module constructs address space decoders for AXI4 memory-mapped interfaces, supporting both full and partial decoding based on address bit width. It defines memory regions using integer-based ranges and organizes them into non-overlapping, sorted collections to ensure correct transaction routing. The decoder logic evaluates input addresses against defined ranges to select the appropriate hardware component, while the binary tree implementation optimizes decoding speed for AXI4-Lite interfaces in FPGA designs. Example uses include validating memory-mapped configurations, clamping access to defined regions, and generating efficient decoder maps for hardware address lookups.",
      "description_length": 685,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface",
      "library": "hardcaml_axi",
      "description": "This module generates C-compatible memory-mapped register interfaces, producing structures, unions, and offset definitions based on register descriptions. It supports read/write operations through unions that reflect field offsets, widths, and access types, enabling direct hardware interaction. Examples include creating C headers for FPGA peripherals accessed via AXI4-Lite or defining register layouts for software drivers. The output facilitates low-level programming by mapping register spaces into memory for efficient access.",
      "description_length": 532,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports",
      "library": "hardcaml_axi",
      "description": "This module defines the core signal types and accessors for AXI4-Lite communication, structuring master-to-slave and slave-to-master interfaces using records that capture address, data, and control signals. It enables memory-mapped register interfaces and peripheral modeling in FPGAs, with support for bit-width alignment, hierarchical signal management, and field-based signal association. Child modules provide combinational logic, monadic lifting, and wiring utilities that allow structured signal manipulation, such as multiplexing, packing, and named field routing, while also supporting synthesis-ready transformations and testbench integration. Specific operations include mapping interfaces to bit vectors, constructing register abstractions, and dynamically assembling AXI4-Lite transactions with error-aware conversions and metadata access.",
      "description_length": 851,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus",
      "library": "hardcaml_axi",
      "description": "This module implements an internal bus structure for routing AXI4-Lite and AXI4-Stream signals, managing address decoding, data routing, and channel arbitration using combinational and sequential logic. It provides core data types representing AXI4 channels (`aw`, `w`, `b`, `ar`, `r`) and stream signals, along with operations for signal packing, unpacking, multiplexing, concatenation, and priority selection. Submodules support register bank construction, interface transformations, and signal routing, enabling tasks like connecting multiple peripherals to a controller, implementing memory-mapped register banks with dynamic field selection, and building demultiplexers for address-based signal routing. Specific examples include constructing AXI4-Lite slaves with valid/ready handshaking, validating register field widths, and managing burst transactions in AXI4-Stream data paths.",
      "description_length": 887,
      "index": 626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Bus_config",
      "library": "hardcaml_axi",
      "description": "This module defines configuration parameters for AXI4 bus interfaces, specifying the width of data and address signals. It supports AXI4, AXI4-Lite, and AXI4-Stream protocols by setting key bit-widths used in memory-mapped and streaming data transfers. Concrete use cases include configuring bus interfaces in FPGA designs for high-throughput memory access or streaming pipelines.",
      "description_length": 380,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Slave_with_data",
      "library": "hardcaml_axi",
      "description": "This module represents an AXI4 slave interface paired with associated data, providing operations to construct and manipulate slave interface instances along with their data payloads. It works with tuple types combining a slave interface (`Hardcaml_axi.Slave.t`) and arbitrary data types, enabling structured handling of AXI transactions with accompanying data values. Concrete use cases include modeling AXI4 memory-mapped slaves that process read/write requests and manage data transfers in hardware designs targeting FPGAs or ASICs.",
      "description_length": 534,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_mode",
      "library": "hardcaml_axi",
      "description": "This module configures AXI register behavior during write operations, supporting modes like hold, toggle, and internal clear to control how values are stored or modified. It defines core data types such as `t`, representing register modes, and includes operations to serialize these modes using `sexp_of_t` for debugging or configuration purposes. The child module extends this functionality by introducing specific mode variants like `Toggle_low`, `Toggle_high`, and `Hold`, enabling precise control over register responses to writes. Use cases include setting up control registers that self-clear after a write or status registers that latch values for a single cycle.",
      "description_length": 670,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4 protocols for memory-mapped and streaming data transfer, offering components for address decoding, register banks, and slave interfaces across AXI4, AXI4-Lite, and AXI4-Stream variants. It provides data structures for bus configuration, register modes, and signal routing, supporting operations like `map`, `zip`, and `fold` on stream interfaces, as well as bit-level register manipulation and memory-mapped transaction routing. Submodules enable FPGA-based video streaming, register bank synthesis, C header generation, and dynamic field access, while also handling pipeline registration, byte-level writes, and priority-encoded selection logic. Key types include `'a Source.t`, `Reg_spec.t`, and `Slave.t`, with use cases spanning high-throughput data paths, configurable control registers, and AXI peripheral modeling.",
      "description_length": 849,
      "index": 630,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 635,
    "meaningful_modules": 631,
    "filtered_empty_modules": 4,
    "retention_rate": 0.9937007874015747
  },
  "statistics": {
    "max_description_length": 1048,
    "min_description_length": 256,
    "avg_description_length": 511.43898573692553,
    "embedding_file_size_mb": 2.292616844177246
  }
}