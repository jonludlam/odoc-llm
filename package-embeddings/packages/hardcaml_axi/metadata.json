{
  "package": "hardcaml_axi",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 371,
  "creation_timestamp": "2025-08-18T20:13:04.245438",
  "modules": [
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate register bank interfaces with read-enable functionality using bit vectors. It supports concrete operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating register interfaces, and validating signal widths. Use cases include implementing AXI4-lite slave register banks with precise control over read-enable signals and integrating hardware modules with fixed-width data paths.",
      "description_length": 473,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Use cases include building hardware register banks with named signals, connecting master interfaces to slave devices, and managing synchronous logic in AXI4-lite transactions.",
      "description_length": 444,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming and connecting register interfaces through packing, multiplexing, concatenation, and priority/onehot selection, along with creating wires, registers, and pipelines over these interfaces. It manipulates hardware signals and register banks tied to an AXI4-lite internal bus protocol, where transactions are synchronized via `_valid` and `_first` signals. These capabilities are used to implement structured register banks that manage synchronized read/write transactions in hardware components like FPGA peripherals or ASIC subsystems.",
      "description_length": 582,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with read-enable signals. It supports data packing/unpacking, multiplexing, concatenation, and selection operations on register bank signals. Concrete use cases include constructing and validating register banks, routing register signals through multiplexers, and generating constant or dynamic register values for AXI4-lite slave interfaces.",
      "description_length": 436,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API, specifically for AXI4-lite register banks. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Use cases include defining hardware register banks with synchronous or combinational logic, and generating named signals for better debug visibility in FPGA designs.",
      "description_length": 477,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles writing data to AXI4-lite register banks using a simplified protocol with `_valid` and `_first` signals. It provides operations to construct, validate, pack, unpack, and multiplex register write transactions represented as bit vectors. Concrete use cases include setting register values from integers, concatenating or selecting between write transactions, and ensuring signal widths match expected interface definitions.",
      "description_length": 441,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and validating register interfaces in AXI4-lite register banks, focusing on signal routing, register insertion, and multiplexing logic. It works with signal interfaces (`O.Of_signal.t` and `O.Of_signal.comb O.t`), managing transactions via `_valid`/`_ready` handshakes and structured data flow through registers and combinational logic. Specific use cases include building hierarchical register banks connected to a master interface, implementing pipelined or prioritized register access, and ensuring correct signal alignment and width validation in hardware designs.",
      "description_length": 617,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct mapping between register fields and their read-enable signals by associating them with port names. It operates on association lists that pair string identifiers with register values, enabling dynamic access to register bank entries. Use this module to construct or deconstruct register banks where individual fields are accessed or driven by name during AXI4-lite transactions.",
      "description_length": 405,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface value into an interface of monadic values, enabling sequential composition of transactions over AXI4-lite register banks. It operates on data types involving interfaces (`I.t`) and monads (`M.t`), specifically handling transactions framed by `_valid`, `_first`, and `_ready` signals. Concrete use cases include aggregating multiple register reads or writes into a single transaction sequence, such as configuring a block of control registers or collecting status from multiple peripherals in a pipelined fashion.",
      "description_length": 586,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate write interfaces with valid signaling using the Always API. It works with `Write_with_valid.t` interfaces, which include `valid`, `first`, and `data` signals, supporting register and wire variable assignments. Concrete use cases include defining register banks with named fields, assigning signal values in always blocks, and applying naming conventions to interface signals for synthesis and debugging.",
      "description_length": 459,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank with read-enable functionality, providing access to port names, widths, and associated tags. It works with lists of strings and integers to describe register interfaces and their bit widths. Concrete use cases include generating register interface descriptions for hardware synthesis or verification, and driving automated testbenches with known register layouts.",
      "description_length": 430,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and managing AXI4-lite write transactions using valid/ready handshaking protocols, focusing on signal manipulation tasks like concatenation, selection, and pipelining. It operates on hardware signal interfaces with explicit validity and first-cycle indicators, typically used to implement register banks connected to AXI4-lite master interfaces. Specific applications include FPGA/ASIC designs requiring precise control over AXI4-lite write sequences, such as configuring hardware peripherals or synchronizing data transfers with ready/valid flow control.",
      "description_length": 604,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic register interfaces into a monadic interface over a structure of registers, enabling simultaneous access to multiple registers. It operates on register interfaces connected to a master AXI4-lite bus, where each register access is framed by control signals indicating transaction state. Use this module to coordinate bulk register reads or writes across multiple register banks within a hardware design.",
      "description_length": 479,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic write interface into a write interface with monadic values, enabling sequential composition of write operations with validity signaling. It operates on data types involving `Write_with_valid`, which includes signals for data, validity, and first-cycle indication. A concrete use case is aggregating multiple register writes into a coordinated transaction sequence for AXI4-lite slave interfaces.",
      "description_length": 459,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate register interfaces as bit vectors, enabling operations like packing, unpacking, multiplexing, and concatenation of register fields. It works with `t` types representing register banks and `comb` types for bit-level combinational logic. Concrete use cases include constructing register banks from integer constants, validating signal widths, and selecting between multiple register interfaces using priority or one-hot encoded control signals.",
      "description_length": 488,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a structure of monadic read-enable values into a monadic read-enable interface, effectively combining multiple read-enable signals under a single monadic context. It operates on types involving `'a M.t Read_enable.t`, lifting the monad `M` outside the read-enable structure. This enables coordinated handling of read-enable signals across multiple registers or register banks within a hardware design.",
      "description_length": 455,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register bank fields to an association list using field names as keys, enabling direct access and manipulation of register values by their string identifiers. It operates on `O.t` interface values and converts them to or from a list of string-keyed pairs. Use this to dynamically inspect or update register bank fields by name during simulation or testbench setup.",
      "description_length": 381,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for constructing and manipulating AXI4-lite write interfaces with validity signals. It supports data types involving vectors and register interfaces, enabling operations like packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building register banks with dynamic field updates, implementing control logic for hardware slaves, and managing transaction framing with `_valid` and `_first` signals.",
      "description_length": 502,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with types representing register banks (`O.Of_bits.comb O.t`) and bit vectors (`O.Of_bits.comb`). Concrete use cases include constructing and validating register interfaces, selecting between multiple register banks using priority or one-hot encoding, and converting between register banks and flat bit vectors for serialization or configuration purposes.",
      "description_length": 514,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and selecting between prioritized or one-hot encoded inputs. It works with `comb` types representing combinational logic signals and `t` types structured as register bank interfaces with fields of fixed bit widths. Concrete use cases include constructing complex register mappings, routing AXI4-lite transactions through multiplexed paths, and validating signal widths during hardware synthesis.",
      "description_length": 583,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags, for AXI4-lite internal bus interfaces. It provides direct access to lists of port names, widths, and associated tags used in register bank configurations. Concrete use cases include generating signal declarations, validating register maps, and connecting hardware modules to AXI4-lite slaves.",
      "description_length": 376,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unchecked conversion between a write interface with validity signaling and an association list indexed by field names. It operates on string-keyed lists of arbitrary-typed values, mapping each field name to a corresponding write signal. Use this to dynamically construct or deconstruct register write transactions from named fields, such as when interfacing with generated register maps or handling sparse register updates.",
      "description_length": 452,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and selecting between prioritized or one-hot encoded inputs. It works with fixed-width bit vectors and structured register interfaces, ensuring correct signal alignment and width validation. Concrete use cases include building AXI4-lite register banks with dynamic field selection, constant initialization, and bus multiplexing in hardware designs.",
      "description_length": 536,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register layout for a write-only AXI4-lite register bank by specifying port names, widths, and transaction tags. It works with hardware signals tied to write transactions that include `_valid` and `_first` control signals. It is used to configure and expose register metadata for hardware synthesis and simulation, particularly in slave devices expecting framed write operations.",
      "description_length": 403,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for managing and transforming read-enable signals in AXI4-lite register bank interfaces, including operations for signal concatenation, multiplexing, and port creation. It works with register bank interfaces represented as structured signals, enabling precise control over read-enable behavior during hardware design synthesis. These capabilities are particularly useful for implementing AXI4-lite compliant masters or slaves where signal integrity and interface consistency are critical.",
      "description_length": 519,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register bank interfaces to and from association lists, using field names as keys. It provides `to_alist` and `of_alist` for converting between structured register interfaces and string-indexed lists of values. This is useful for dynamically inspecting or configuring register banks by name, such as in testbenches or configuration scripts.",
      "description_length": 357,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces in an always block, specifically for AXI4-lite register banks. It supports operations like assigning values, creating registers with optional enable signals, and applying naming conventions to interface fields. Use cases include defining hardware register banks with synchronous logic and wiring interfaces for AXI4-lite slave devices.",
      "description_length": 420,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags. It provides direct access to lists of port names, widths, and interface tags for hardware register banks connected via an AXI4-lite internal bus. Useful for generating documentation, validating register layouts, or driving tooling that requires explicit signal naming and sizing.",
      "description_length": 363,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an interface type and an association list indexed by field names, enabling programmatic access and construction of register bank interfaces using string keys. It operates on the interface type `I.t` and association lists of string-`'a` pairs. Concrete use cases include dynamically generating register bank configurations from external data sources or introspecting register fields for debugging and serialization.",
      "description_length": 462,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces for a 32-bit AXI4 register bank in an always block context. It supports operations like assigning signals to register interfaces, creating register and wire variables with optional enable control, and applying naming conventions to interface fields. Concrete use cases include defining hardware register banks with read-enable functionality and wiring default signals in AXI4-compliant hardware designs.",
      "description_length": 488,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating a 32-bit AXI register bank interface, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works directly with `comb I.t` and `comb` types, representing structured register bank signals and their vector forms. Concrete use cases include constructing and validating register bank configurations, routing signals between AXI components, and implementing control logic for register-based peripherals.",
      "description_length": 510,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a read-enable interface containing monadic values into a monadic value containing a read-enable interface, effectively sequencing the monadic effects across the interface. It operates on `Read_enable.t` interfaces and a monad `M`, lifting the monad outside the interface structure. A concrete use case is aggregating register reads from multiple AXI-connected peripherals into a single monadic action, enabling compositional register bank access.",
      "description_length": 500,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structural manipulation of register bank interfaces composed of named, sized ports with associated tags. It supports operations like `map`, `zip`, and `fold` to transform and combine interfaces, along with conversions to bit vectors, association lists, and signal representations. These capabilities enable use cases such as defining configurable AXI4-lite register banks, coordinating bulk register operations, and implementing hardware design patterns like prioritized signal routing or tagged metadata handling.",
      "description_length": 551,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, providing access to port names, widths, and tags. It works with lists of strings and integers to describe hardware interface signals. Concrete use cases include generating signal declarations, validating register bank configurations, and mapping hardware ports to software representations.",
      "description_length": 338,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module defines combinational logic operations for a 32-bit AXI register bank interface, supporting signal manipulation such as packing, unpacking, multiplexing, and concatenation. It works with 32-bit wide data and address buses, using a `comb` type to represent combinational signals and `Write_with_valid.t` to handle write data with validity flags. Concrete use cases include constructing and validating AXI write transactions, selecting between multiple write sources with priority or one-hot encoding, and converting between constant values and register bank signals.",
      "description_length": 577,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the manipulation of register interfaces with read-enable functionality in a 32-bit AXI4 bus context, focusing on operations like signal packing/unpacking, muxing, concatenation, and priority/one-hot selection. It operates on register banks and named signal interfaces, supporting hierarchical signal naming conventions and dynamic routing of register signals. Specific use cases include constructing AXI4-compliant peripherals with configurable register banks, implementing pipelined register interfaces, and managing read-enable signals for hardware blocks requiring precise timing control.",
      "description_length": 611,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register interface signal names and widths for AXI4-lite internal bus transactions. It provides lists of port names, widths, and tags used to describe register inputs in hardware designs. Concrete use cases include generating register interface documentation and driving signal allocation during hardware compilation.",
      "description_length": 337,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple write operations with valid signals into a single monadic structure, transforming a collection of individual write actions into a unified write interface. It operates on data types involving `Write_with_valid.t` and a monad `M`, enabling structured handling of concurrent write operations. A concrete use case is aggregating register write signals in hardware designs where validity must be tracked alongside data.",
      "description_length": 475,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for mapping, transforming, and structuring register fields with read-enable signals in AXI4-lite register banks, supporting operations like zipping, folding, and bit-level manipulation. It works with `Read_enable.t` interfaces that encapsulate tagged register fields, enabling dynamic field access by name or tag, and integrates with hardware synthesis flows for register bank configuration and testbench generation. Key use cases include implementing read-enable logic in AXI4-lite slaves, dynamic register port routing, and verification of register bank interactions in hardware designs.",
      "description_length": 622,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and their bit widths for an internal bus interface. It provides direct access to lists of port names, widths, and associated tags for hardware register configuration. Used to map and manage register fields in AXI4-lite compliant hardware designs.",
      "description_length": 286,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register interfaces to a list of key-value pairs, where keys are port names and values are signals. It provides direct conversions between register structures and association lists, enabling programmatic access to register fields by name. Use this when dynamically inspecting or configuring register values in a hardware design, such as during testing or integration with software tools.",
      "description_length": 404,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a interface containing monadic values into a monadic value containing a interface, effectively sequencing monadic effects across all elements of the interface. It operates on types involving `'a M.t I.t`, where `I` represents an interface and `M` is a monad. A concrete use case is lifting AXI register bank operations into a monadic context, allowing composition of register reads and writes within a larger monadic workflow.",
      "description_length": 480,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with 32-bit data and address buses. It supports operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection via priority or one-hot encoding. Concrete use cases include constructing and validating AXI4 register banks, driving constant values into register fields, and dynamically selecting or routing register interface signals based on control inputs.",
      "description_length": 498,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags. It provides direct access to lists of port names, their corresponding bit widths, and associated tags for AXI interface signals. Useful for generating signal declarations or validating register bank configurations against hardware specifications.",
      "description_length": 330,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate register bank interfaces with read enable signals represented as bit vectors. It supports constant initialization, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. These functions are used to implement AXI4 register banks with precise bit-level control and correctness checks for hardware synthesis.",
      "description_length": 449,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate 32-bit AXI register bank interfaces using bit-level representations. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with support for valid signals and one-hot/priority encoding. Use cases include implementing register banks in hardware designs with precise control over field widths and signal routing.",
      "description_length": 429,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a monadic interface value into an interface of monadic values, effectively reordering the monad and interface layers. It operates on data types involving interfaces (`I.t`) and monadic values (`M.t`), specifically for 32-bit register banks connected to a master interface. A concrete use case is aggregating multiple register fields into a single interface while preserving monadic effects.",
      "description_length": 444,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a nested register structure into a flattened register structure, enabling uniform handling of register fields across a bus interface. It operates on types involving nested modules and register configurations, specifically structured for internal bus datapaths. Use this when mapping hierarchical register blocks into a flat register interface for hardware synthesis or simulation.",
      "description_length": 434,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with `t` values representing register banks, where each field is a `comb` signal of bits, and supports constant assignment, width validation, and selection logic. Concrete use cases include constructing AXI4 register banks with precise bit-level control, validating signal widths during simulation, and implementing multiplexed register access in hardware designs.",
      "description_length": 523,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unchecked conversion between register bank interfaces and association lists indexed by field names. It supports operations to_alist and of_alist for transforming register data to and from string-keyed lists. Use this when mapping register contents to named fields for configuration or debugging, without runtime safety checks on field names.",
      "description_length": 370,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps register fields to string keys in an internal bus register, enabling associative list-style access. It supports converting register values to and from a list of (string, value) pairs, where strings correspond to port names. Use this when dynamically accessing or inspecting register fields by name, such as in testbenches or configuration utilities.",
      "description_length": 366,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports combinational and sequential signal manipulation for AXI4 write register interfaces, including constant assignment, multiplexing, and field validation. It operates on structured signal interfaces (`Write_with_valid.Of_signal.t`) to enable register bank construction in AXI4 slaves, with capabilities for wiring connections, port creation, and custom signal naming to manage complex register mappings and ensure correct field widths.",
      "description_length": 453,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between integer values and bit-level representations for use in AXI4-lite register interfaces. It supports operations like packing, unpacking, and multiplexing bit vectors, along with validation and width assertion utilities. Use cases include implementing register file logic and managing control/status registers in hardware designs.",
      "description_length": 377,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions for manipulating register interfaces through signal-level operations like packing/unpacking, multiplexing, concatenation, and validation, as well as constructing register pipelines and control logic involving muxing, priority, or onehot selection. It operates on structured signal interfaces represented by `I.Of_signal.t` and `I.Of_signal.comb I.t` types, enabling precise hardware descriptions with named signal groups and directional interfaces. These tools are used to build AXI4 register banks connected to master interfaces, manage control flow in hardware modules, and define composable signal hierarchies with explicit naming for improved readability and maintainability.",
      "description_length": 710,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic for signal manipulation and sequential logic for register state transitions in AXI4-lite register interfaces, using operations like `mux`, `pack`, `reg`, and signal assignment (`<==`). It operates on `Internal_bus.Register.O.Of_signal.t` values representing register interfaces, handling signal wiring, concatenation, and pipelining within AXI4-lite internal buses. Specific use cases include implementing register blocks that manage read/write transactions framed by `_valid` and `_first` signals, or transforming signal hierarchies through naming and multiplexing operations in RTL designs.",
      "description_length": 633,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a read-enable interface containing monadic values into a monadic value containing a read-enable interface, effectively sequencing read operations across a 32-bit AXI register bank. It works with 32-bit data and address buses, specifically handling register banks connected to an AXI master interface. Use it to coordinate multiple register reads in a monadic context, such as reading from hardware registers in a pipeline or during testbench execution.",
      "description_length": 506,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles bit-level manipulation and routing of 32-bit AXI write data with valid signals, primarily working with `Write_with_valid.t` and `Bits.t` types. It provides operations like packing/unpacking, multiplexing, concatenation, and selection logic for AXI register banks. Use cases include constructing and validating AXI write responses, routing data between AXI components, and managing register bank inputs with precise bit-width control.",
      "description_length": 453,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to define and manipulate register outputs in a hardware design using the internal bus protocol. It supports creating registers with optional enable signals, assigning values to registers, and applying naming conventions to signals. Use cases include implementing control logic for AXI4-lite slave interfaces, managing register state transitions, and generating named signals for debugging and synthesis.",
      "description_length": 435,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to create and manipulate register and wire interfaces in an always block context, specifically for write operations with valid signals. It works with `Write_with_valid.t` interfaces containing `Always.Variable.t` values, supporting signal assignment, register instantiation, and wire creation. Concrete use cases include defining register banks with synchronous updates and connecting interface fields to signals in a structured, named manner.",
      "description_length": 475,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces within an `Always` block, specifically for working with AXI register banks. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include defining hardware registers with default values, connecting interface signals in a structured way, and generating named signals for better debugging and synthesis results.",
      "description_length": 521,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags for AXI4 register interfaces. It provides direct access to lists of port names, their corresponding bit widths, and associated tags for use in hardware description and tooling. These values are used during register bank instantiation and signal mapping in AXI4-based designs.",
      "description_length": 358,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank with read-enable ports, including port names, widths, and associated tags. It works with string and integer types to describe register interfaces and lists of these values to represent multiple ports. Concrete use cases include generating register bank port definitions for hardware description in AXI4-based systems, specifically for read-enable signals.",
      "description_length": 422,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port metadata, including names, widths, and tags for AXI4 interface signals. It provides direct access to signal names, data widths, and associated tags as separate lists, derived from a 32-bit internal bus specification. Use this module to inspect or generate register bank interface details for hardware description or integration with AXI4 peripherals.",
      "description_length": 389,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a nested register structure into a flattened register structure, enabling uniform handling of register fields across a hardware design. It operates on types involving `Internal_bus.Register.O.t` and a module `M` that represents a hardware signal or value. A concrete use case is simplifying hierarchical register definitions in AXI4-lite slave interfaces, where individual register fields need to be accessed as a single unit.",
      "description_length": 480,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating structured register banks with AXI4-compliant signal interfaces, supporting combinational and sequential logic transformations such as signal packing, multiplexing, and pipeline creation. It works with typed signal representations (`O.Of_signal.comb O.t`, `O.Of_signal.t`) that encode field widths and hierarchical mappings, enabling precise hardware signal routing. Key use cases include implementing AXI4 register banks with customizable input/output groupings, applying naming strategies for debug visibility, and synthesizing hardware descriptions with deterministic signal connectivity.",
      "description_length": 657,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces within an AXI4 register bank, specifically for read-enable scenarios. It works with `Read_enable.t` interfaces containing `Always.Variable.t` values, enabling direct assignment and naming operations. Concrete use cases include defining register storage with optional enable signals, wiring default signals, and applying hierarchical names to interface fields in an always block context.",
      "description_length": 471,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values into a monadic value of a collection, specifically for interfaces. It operates on values of type `'a M.t O.t`, where `O` is an interface type, and lifts the monadic structure outside the interface. This enables composing multiple register operations within an interface while preserving their monadic effects, such as building register banks with side effects during construction.",
      "description_length": 465,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential logic operations for implementing AXI4-lite register interfaces, including signal assignment, multiplexing, priority selection, and pipeline control. It operates on signal-based register structures (`Signal.t` and `Internal_bus.Register.I.Of_signal.t`) that model AXI Lite transactions using `_valid`, `_first`, and `_ready` handshaking signals. These utilities are used to construct hierarchical register interfaces, manage data flow in AXI4-lite slave devices, and implement synchronous control logic for hardware register pipelines.",
      "description_length": 585,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to and from an association list, enabling dynamic access and construction of register interfaces by string keys. It operates on lists of key-value pairs where keys correspond to register field names and values represent their data. Use this to programmatically generate or inspect register banks from named field entries without static type constraints.",
      "description_length": 395,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values into a monadic value of a collection, specifically for interfaces. It operates on data structures involving interfaces and monads, enabling the combination of multiple register operations into a single monadic structure. This is useful for aggregating AXI register reads or writes into a unified transaction.",
      "description_length": 393,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register interfaces for AXI4-lite internal bus transactions. It works with signals and variables representing read and write operations, using `_valid`, `_first`, and `_ready` control signals to manage transaction flow. Use it to implement register-based communication between master and slave components in a hardware design, such as configuring control registers or reading status values.",
      "description_length": 446,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces within an `Always` block, specifically for use with the AXI register bank. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include defining hardware registers with default values, connecting signals in a structured interface, and generating named signals for better traceability in synthesis or simulation.",
      "description_length": 524,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for composing and transforming AXI4 register bank interfaces with dynamic read-enable control, focusing on signal-level manipulation. It works with structured register banks and named signal interfaces, enabling tasks like multiplexing between register sources, applying priority-encoded selection, and managing hierarchical signal connections with customizable naming. Specific use cases include constructing complex AXI4 bus fabrics where register access patterns require runtime configurability or implementing hardware pipelines that demand precise read-enable signal coordination.",
      "description_length": 617,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a register bank interface and an association list, using field names as keys. It operates on `Read_enable.t` structures paired with string-keyed lists of values. This enables straightforward serialization and deserialization of register bank data, useful for configuration or state inspection tasks.",
      "description_length": 347,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces with read enable signals. It supports data packing/unpacking, multiplexing, concatenation, and selection operations on register fields with specific bit widths. Concrete use cases include constructing and validating register bank configurations, routing register outputs based on control signals, and converting between scalar values and register field representations.",
      "description_length": 463,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types representing combinational logic signals and `t` types representing register bank interfaces. Concrete use cases include constructing AXI4 register banks with dynamic field routing, implementing priority-encoded signal selection, and validating signal widths during interface synthesis.",
      "description_length": 499,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert integer values to bit-level representations and manipulate them within a register interface context. It supports operations like packing, unpacking, concatenation, and multiplexing of bit vectors, specifically tailored for AXI4-lite register transactions. Use cases include hardware register configuration, bitfield manipulation, and data path control in FPGA designs.",
      "description_length": 410,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces in a hardware design, including functions for packing, unpacking, multiplexing, and concatenating register values. It works with `comb` types and register structures that represent AXI4-lite interface signals, enabling direct control and routing of data paths. Concrete use cases include building multiplexed register access logic, converting integer values to register representations, and validating signal widths during hardware compilation.",
      "description_length": 533,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate AXI4 register bank interfaces with write signals and validity flags. It supports data types representing register fields as bit vectors, enabling precise control over register layouts and signal routing. Use cases include defining memory-mapped register banks, multiplexing register inputs, and validating signal widths during hardware synthesis.",
      "description_length": 406,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module manages individual slave instances within a demultiplexed AXI4-lite bus structure. It provides access to the master-to-slave interface signals and allows setting and retrieving the slave-to-master interface signals for each slave instance. It is used to define how each slave responds to read and write transactions by connecting its interface signals appropriately.",
      "description_length": 378,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unchecked conversions between register bank interfaces and string-keyed association lists. It operates on register bank interface types (`'a I.t`) and lists of string-data pairs, enabling field-by-field access using port names as keys. Use it to dynamically construct or inspect register banks from named field mappings without runtime safety checks.",
      "description_length": 379,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI register banks with write and valid signals. It supports data types including packed vectors and register bank interfaces with field-specific widths. Use cases include multiplexing, priority selection, and constant initialization of register fields for hardware synthesis.",
      "description_length": 332,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register bank interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with interface types parameterized by a combinational logic module, supporting field-level bit width validation and constant initialization. Concrete use cases include constructing AXI4 register banks with precise bit-level control, validating signal widths during simulation, and implementing priority-encoded multiplexers for hardware register access.",
      "description_length": 551,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for mapping, folding, and converting AXI4-lite register write transactions to/from association lists, while managing validity signaling via `_valid` and `_ready` handshake protocols. It operates on tagged field-based data structures representing register banks, enabling dynamic construction and deconstruction of write signals by port name or tag. Specific use cases include hardware designs requiring precise control over register transaction timing, such as FPGA configurations where validity flags coordinate asynchronous slave responses or debug interfaces track transaction progress via `_first` signals.",
      "description_length": 643,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a register bank interface and an association list, using field names as keys. It operates on `Read_enable.t` structures paired with string-keyed lists of values. This enables straightforward serialization and deserialization of register bank states, useful for debugging, configuration, or dynamic register mapping.",
      "description_length": 363,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces in a hardware design, including packing, unpacking, multiplexing, and concatenation of register values. It works with the `comb` type and register structures defined in `Internal_bus.Register.O`, enabling direct transformations and routing of register data. Concrete use cases include constructing complex register mappings from simpler components, implementing conditional data routing with priority or one-hot selection, and converting integer values to and from register representations for AXI4-lite compatible logic.",
      "description_length": 610,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank with read-enable ports, specifically handling 32-bit data and address buses. It provides values for retrieving port names, widths, and read-enable tags, which are essential for hardware synthesis and register mapping. It is used to configure and expose register bank interfaces in AXI4-compliant hardware designs.",
      "description_length": 380,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces within an `Always` block, specifically for 32-bit AXI register banks. It includes operations for assigning signals to variables, creating registers with optional enable, and naming interface fields. Concrete use cases include defining hardware register interfaces with initial values and structured naming, and connecting them to AXI master interfaces for memory-mapped I/O.",
      "description_length": 459,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register layout for a 32-bit AXI write interface with valid signaling. It specifies port names, widths, and tags used to generate corresponding signal accessors. It is used to construct register banks that map directly to hardware registers in an AXI-compliant design.",
      "description_length": 292,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module provides operations for mapping, converting, and structurally manipulating register bank interfaces using port names or tags as keys, supporting dynamic configuration and inspection. It works with typed interface values (`'a I.t`), association lists, bit-level representations, and metadata such as names and widths. Specific use cases include transforming register bank structures in combinational or sequential logic, synchronizing interface creation with synchronous signal assignments, and generating metadata for tooling or documentation purposes.",
      "description_length": 564,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of write operations with validity signals into a single write operation that combines all inputs. It operates on 32-bit register banks connected to a master interface, handling data and address buses. Use this to synchronize and aggregate multiple register writes into one atomic update.",
      "description_length": 354,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, validate, and manipulate 32-bit AXI register bank interfaces with read-enable semantics. It supports concrete operations such as packing/unpacking signals to vectors, multiplexing, concatenation, and priority/one-hot selection, all working directly on `Read_enable.t` structures composed of `Bits.t` signals. Use cases include building configurable register banks with dynamic field selection and validation in AXI4-based hardware designs.",
      "description_length": 485,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unchecked access to register fields by port name through associative list conversions. It operates on register bank interfaces with string-indexed field mappings. Use cases include dynamic register configuration and debugging via named field access.",
      "description_length": 278,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides utilities for constructing and manipulating register interfaces in hardware designs, focusing on 32-bit AXI4 register banks. It operates on signal and register types (`t` and `comb O.t`), offering field-level operations like packing, multiplexing, concatenation, and pipeline creation, alongside signal connection and naming strategies. These tools are particularly useful for implementing validated register banks with AXI4 master interfaces in FPGA or ASIC designs.",
      "description_length": 488,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4 write interfaces with valid signals, focusing on register pipelining, signal concatenation/multiplexing, and interface wiring. It works with tuples of `Signal.t` values representing 32-bit data/address fields and supports hierarchical signal naming for clarity in hardware designs. Specific use cases include implementing register banks connected to AXI4 master interfaces, synchronizing write operations via valid/ready handshakes, and structuring signal graphs with named input/output boundaries.",
      "description_length": 569,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, enabling direct bit-level transformations. It supports functions like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection operations with optional valid signals. Concrete use cases include synthesizing register banks from bit-level representations, implementing dynamic field selection logic, and validating bit-width consistency in AXI4 register interfaces.",
      "description_length": 486,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register bank interfaces with read enable signals. It supports operations like packing/unpacking signals to vectors, multiplexing, concatenation, and priority/one-hot selection, ensuring correct signal width handling. Use cases include building AXI4-Lite register banks with dynamic field selection and constant initialization in hardware designs.",
      "description_length": 427,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for a register bank with write ports that include valid signals. It specifies the names and widths of each port, along with associated tags, enabling precise register configuration and access patterns. It is used to generate or manipulate register banks connected to an AXI master interface, where each write operation includes a valid signal to control data flow.",
      "description_length": 411,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces within an always block, specifically for 32-bit AXI register banks. It supports operations like assigning signals to interface fields, creating registers with optional enable, and naming signals with prefixes or suffixes. Concrete use cases include defining hardware register interfaces with initial values and connecting them to AXI master interfaces in FPGA designs.",
      "description_length": 453,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate 32-bit AXI register interfaces, including packing, unpacking, multiplexing, and validation of signal widths. It supports concrete operations such as setting register fields from integers, concatenating register interfaces, and selecting between multiple interfaces using priority or one-hot encoding. These functions are used to implement and verify AXI-compliant register banks in hardware designs.",
      "description_length": 445,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating register interfaces in AXI4-compatible 32-bit bus systems, focusing on signal-level transformations like packing/unpacking, multiplexing, concatenation, and pipeline creation. It operates on structured register fields (`I.Of_signal.comb I.t` and `I.Of_signal.t`) and signal interfaces, enabling hardware description patterns such as field-width validation, combinational logic routing, and named signal interconnections via operators like `<==`. Specific use cases include implementing register banks with precise signal naming, validating register field widths during hardware synthesis, and structuring AXI4-compliant data paths with explicit signal hierarchy.",
      "description_length": 728,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces using the Always API for 32-bit AXI4 register banks. It supports operations like assigning signals to variable interfaces, creating registers with optional enable signals, and applying naming conventions to interface fields. Concrete use cases include defining AXI4 register banks with named signals, connecting control logic in an always block, and generating structured hardware descriptions with default or custom signal values.",
      "description_length": 516,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct, unsafe conversion between register bank interfaces and association lists indexed by field names. It operates on `Write_with_valid.t` structures, enabling concrete use cases like dynamically generating register configurations from named field-value pairs or debugging by inspecting register state as a list of named entries.",
      "description_length": 352,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an interface value and an association list indexed by field names, enabling programmatic access and construction of interface fields by string keys. It operates on `'a I.t` interface types and string-keyed lists. Use this to dynamically map interface signals to named entries, such as for introspection, serialization, or runtime configuration based on field names.",
      "description_length": 413,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for transforming and structuring 32-bit AXI register bank interfaces through operations like mapping, folding, and bit-level manipulations, enabling tasks such as register field routing and signal packing/unpacking. It operates on typed interface values (`I.t`) representing AXI4 register ports, supporting introspection, dynamic configuration, and RTL-level logic construction. Specific use cases include FPGA peripheral integration, metadata extraction for signal names/widths, and defining register-wire interfaces within always blocks for hardware description.",
      "description_length": 597,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a nested register structure into a flattened register structure, working with types defined in the `Register.I` module. It operates on AXI4-compliant datapath registers, specifically handling the input bus (`Ibus`) state machine. Use this module to simplify hierarchical register configurations when implementing AXI4 slave interfaces with registered inputs.",
      "description_length": 412,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a register structure and an association list, where each register field is mapped to a named value. It operates on 32-bit wide AXI register interfaces with string-labeled ports. Use this module when serializing or deserializing register states for debugging, configuration, or external interface mapping.",
      "description_length": 352,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4 write interfaces with valid signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb` types representing hardware signals and `t` structures modeling AXI4 write transactions. Use cases include constructing and validating AXI4 write paths, building register banks with dynamic field selection, and handling one-hot or priority-encoded input arbitration.",
      "description_length": 468,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the interface for a registered AXI4-stream datapath by specifying port names, widths, and tags. It provides concrete values for listing signal names, their bit widths, and associated tags used in the registered stream interface. Useful for generating hardware descriptions where precise signal naming and sizing are required for integration with downstream tools or documentation.",
      "description_length": 400,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values within an interface into a monadic value of interfaces, effectively combining them. It operates on data structures involving interfaces (`O.t`) and monads (`M.t`), specifically handling computations that need to be lifted and combined across an interface. A concrete use case is aggregating multiple AXI register operations into a single monadic action for execution.",
      "description_length": 452,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-lite slave state machine configurations and string-keyed associations, enabling direct access to internal bus signals by port name. Operates on lists of key-value pairs where keys are port names and values are signal or register types. Useful for dynamically configuring AXI4-lite slave interfaces from named signal mappings, such as during hardware synthesis or testbench setup.",
      "description_length": 397,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and managing AXI4-lite master state machines using combinational signals, focusing on tasks like signal routing, control logic implementation, and register inference. It works with `comb` signals, state machine types, and AXI4-lite interfaces, enabling hardware description workflows for pipelining, multiplexing, and register management. Specific use cases include converting Ibus transactions to AXI4-lite protocols, synchronizing control signals, and synthesizing register-based logic in FPGA or ASIC designs.",
      "description_length": 561,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manage and assign signals to registers in an AXI4-compliant internal bus design. It works with `Always.Variable.t` and `Signal.t` types, enabling register creation with optional enable signals, wire signal assignment, and signal naming conventions. Concrete use cases include implementing register-based state machines, connecting control signals in AXI4 data paths, and managing synchronous register updates in hardware descriptions.",
      "description_length": 469,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port names, widths, and tags for AXI4 read-enable interfaces. It provides direct access to lists of port names, widths, and associated tags used in AXI register bank implementations. Useful for generating register interface signals and managing read-enable logic in AXI-based hardware designs.",
      "description_length": 327,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4 interface signals using the Always API, including assigning values, creating registers, and defining wires with specified defaults. It works with interface types parameterized over `Hardcaml.Always.Variable.t`, enabling structured signal assignment and naming within always blocks. Concrete use cases include building AXI4 register banks with named fields, synchronous signal pipelines, and testbench signal drivers with controlled initialization.",
      "description_length": 497,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 register interfaces as signal vectors, including validation, packing/unpacking, multiplexing, concatenation, and register creation. It operates on structured signal collections (`I.Of_signal.t`) and combinational signals, enabling use cases like constructing register banks, transforming hardware interfaces, and connecting signal groups with naming conventions. Key patterns include modeling hardware components, organizing signal hierarchies, and applying interface transformations in HDL designs.",
      "description_length": 550,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for constructing and manipulating AXI4-lite master state machines, specifically handling signal routing and control logic. It works with `Bits.t` types to represent hardware signals and `t` records that model the state machine's structure. Use this module to implement custom AXI4-lite master interfaces with precise timing and signal control in hardware designs.",
      "description_length": 405,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating state machines that interface with AXI4-lite protocols using `Always` blocks. It supports data types such as `Always.Variable.t` and `Signal.t`, enabling direct assignment, register creation, and signal wiring. Concrete use cases include implementing control logic for AXI4-lite masters, managing register state transitions, and generating named signals for hardware description.",
      "description_length": 445,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for signal packing/unpacking, multiplexing, pipelining, and register creation tailored to AXI4 bus interfaces, focusing on precise control over datapath state machines and signal integrity checks. It operates on `Signal.t` values and register structures (`Register.O.t`), enabling hierarchical naming and connectivity management for hardware simulation and synthesis workflows. Key use cases include constructing register-based datapaths with priority-encoded multiplexers and validating AXI4-compliant signal widths during design verification.",
      "description_length": 576,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the ports used in the AXI4-lite slave state machine. It provides concrete identifiers and bit-widths for each signal in the interface, ensuring alignment with the AXI4-lite protocol. These values are used directly in constructing and verifying the state machine's input/output connections.",
      "description_length": 341,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-lite interface signals and their string names by converting to and from an association list. Works with any type `'a` representing signal values, such as bits or vectors. Used to serialize or deserialize AXI signal states for debugging, configuration, or dynamic signal routing.",
      "description_length": 296,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert integer values to 32-bit register structures and manipulate them using operations like packing, unpacking, concatenation, and multiplexing. It supports data selection through priority and one-hot encoding schemes, ensuring correct bit-width validation and alignment for AXI4 bus communication. Concrete use cases include constructing and managing register interfaces for hardware blocks that interface with a 32-bit AXI bus, such as peripheral controllers or memory-mapped devices.",
      "description_length": 523,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manage register interfaces in an AXI4-compliant internal bus, specifically handling signal assignment, registration with optional enable, and wire creation. It works with data types such as `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t` to model register inputs and their behaviors. Concrete use cases include implementing control logic for register updates, connecting signals in a datapath, and applying naming conventions to signals for clarity in hardware descriptions.",
      "description_length": 538,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides signal-level operations for constructing and managing a state machine that converts Ibus transactions to AXI4-Lite protocol, focusing on tasks like value packing/unpacking, multiplexing, concatenation, and pipeline control. It operates on combinational signals (`comb`) and state machine types (`t`), enabling hierarchical logic synthesis through priority/one-hot selection and register management. These capabilities are particularly useful in hardware designs requiring protocol conversion between internal bus architectures and AXI4-Lite interfaces, such as FPGA peripheral controllers or memory-mapped communication bridges.",
      "description_length": 649,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate interface signals using the Always API, including assigning values, creating registers, and defining wires. It works with interface structures containing signals and variables, enabling precise control over signal assignments and register specifications. Concrete use cases include building AXI4 register banks with named signals, synchronous register updates, and wire signal declarations in hardware descriptions.",
      "description_length": 460,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the ports of an AXI4-lite slave state machine. It provides concrete identifiers and bit-widths for each signal used in the state machine's interface, ensuring alignment with the AXI4-lite protocol. These values are used directly in hardware generation to connect and route signals between the AXI4-lite interface and the internal bus protocol.",
      "description_length": 395,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential operations for manipulating AXI4-stream datapath signals, including multiplexing, concatenation, register pipelining, and width-aware transformations. It works with structured signal groups representing AXI-stream interfaces, handling both individual signals and hierarchically named interface bundles. These capabilities are used to implement pipeline stages between AXI-stream components while ensuring compliance with `tvalid`/`tready` handshaking and maintaining signal integrity across complex hardware hierarchies.",
      "description_length": 570,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to `Internal_bus.Master_to_slave` interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. These utilities are used to implement AXI4-lite master-to-slave communication within hardware designs, particularly during the construction of synchronous logic blocks.",
      "description_length": 436,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module supports manipulation of 32-bit AXI register bank interfaces with validity signaling through combinational logic, list-like transformations (e.g., zipping, folding), and bit-level operations. It works with structured `Write_with_valid.t` types representing register data, port names, and validity metadata, enabling use cases like AXI4 write transaction routing, register layout specification, and synchronization between hardware components. Key applications include defining named register interfaces for AXI buses and converting between signal representations and interface descriptions in hardware-software co-design scenarios.",
      "description_length": 643,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.I",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structural manipulation, serialization, and bit-level transformation of AXI4-lite register interfaces with multi-field data paths. It operates on hierarchical register structures and control signals (`_valid`, `_first`, `_ready`), enabling programmatic access to register fields by name or position. Use cases include flattening hierarchical registers for hardware synthesis, dynamically configuring register maps, and implementing transaction-aware logic for AXI4-lite slaves.",
      "description_length": 514,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI register bank interfaces with read enable signals. It supports signal manipulation via functions like `pack`, `unpack`, `mux`, and `concat`, and includes validation and width-checking utilities. Use cases include building and validating AXI register banks, multiplexing register outputs, and converting between register interfaces and bit vectors.",
      "description_length": 407,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation, metadata inspection, and functional combinators for AXI4 register banks, focusing on port-level transformations, signal routing, and monadic aggregation of register transactions. It operates on interface values (`'a t`) that model AXI4 register banks, handling metadata like port names, widths, and tags for hardware-software co-design. Use cases include synthesizing register banks from bit-level signals, defining synchronous logic with `Always` blocks, and automating signal declarations for hardware verification flows.",
      "description_length": 568,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple monadic slave-to-master transactions into a single transaction, lifting the monad outside the interface. It operates on data structures representing AXI4-lite slave-to-master responses, which include validity and readiness signals. A concrete use case is aggregating several independent AXI read or write operations into a unified response for processing in a hardware pipeline.",
      "description_length": 439,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and route AXI4-lite master-to-slave interface signals encoded as bit vectors. It supports operations such as packing/unpacking signals to/from vectors, multiplexing and concatenating multiple interfaces, and selecting between interfaces using priority or one-hot encoding. These functions are used to implement control logic that routes or modifies AXI4-lite transactions within a hardware design.",
      "description_length": 442,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-lite slave state machines into a single combined state machine, handling protocol translation from AXI transfers to a simplified internal bus representation. Works with state machine types parameterized over a module `M`, enabling aggregation of multiple slave interfaces into a unified control flow. Useful for implementing AXI4-lite slave devices that require internal arbitration or multiplexing of multiple AXI channels.",
      "description_length": 454,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate register bank interfaces with read enable signals represented as bit vectors. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic (priority, one-hot) with valid signals. Use cases include implementing AXI4 register banks with precise bit-level control, configuring register fields from integers, and validating signal widths during simulation or synthesis.",
      "description_length": 514,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate and route AXI4-lite slave-to-master response signals encoded as bit vectors. It supports constant assignment, packing/unpacking, multiplexing, concatenation, and selection logic for these signals. Use cases include implementing bus multiplexers, decoding slave responses, and constructing test stimuli for AXI4-lite interfaces.",
      "description_length": 373,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines monadic values within a `Read_enable.t` interface, lifting the monad to the outer layer. It operates on data types involving `Read_enable.t` interfaces with monadic values. A concrete use case is aggregating multiple AXI4 read operations into a single monadic structure for sequential execution.",
      "description_length": 347,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for constructing and manipulating AXI4-lite slave state machines, specifically handling data transfers between the AXI protocol and an internal bus representation. It works with bit vectors (`comb`) and structured state machine types (`t`) to implement control logic for AXI register access, such as decoding read/write requests and generating responses. Concrete use cases include implementing register file logic, address decoding, and response generation in hardware designs targeting FPGAs or ASICs.",
      "description_length": 545,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation that aggregates all fields of a 32-bit AXI register interface into a single value, maintaining the structure of the input while applying the transformation across all fields. It operates on 32-bit data and address buses, specifically within the context of AXI register state machines. A concrete use case includes consolidating register outputs for downstream logic that requires uniform handling of register fields.",
      "description_length": 454,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a data path register interface containing monadic values into a monadic value containing a data path register interface, effectively lifting the monad outside. It operates specifically on the `Datapath_register.IO.t` type parameterized by a monad `M`. A concrete use case is combining multiple AXI4-stream register stages within a monadic context, such as wiring together signal pipelines in hardware description code where each signal path is handled within a monad like `Scope.t`.",
      "description_length": 536,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces when working with AXI4-stream datapaths. It supports signal assignment, naming, and registration within an `Always` block, using `tvalid`/`tready` handshakes. Use it to build registered AXI-stream components with named signals and controlled enable conditions.",
      "description_length": 345,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct, manipulate, and validate AXI4 write interfaces with valid signals using bit vectors. It supports constant initialization, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. These functions are used to implement register banks and control logic where AXI write channels must be processed or routed based on valid data signals.",
      "description_length": 448,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports signal-level operations for AXI4-lite master-to-slave interfaces, focusing on combinational signal manipulation and structural composition. It works with `comb` signals wrapped in an interface type `t`, using `_valid`/`_ready` handshaking signals to manage transaction framing, and includes utilities for multiplexing, selection logic, pipeline creation, and interface naming. It is particularly useful in hardware designs requiring precise control over AXI4-lite communication patterns, such as implementing SoC peripherals or FPGA-based accelerators with strict signal synchronization requirements.",
      "description_length": 621,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4-compliant register banks and signal interfaces in hardware designs. It works with structured register banks represented as signal fields (`O.Of_signal.comb O.t` and `O.Of_signal.t`), enforcing correct bit-widths and field behaviors through validation, packing, multiplexing, and pipeline creation. Specific use cases include building AXI4 register maps with hierarchical signal groups, applying naming conventions to signals for clarity, and connecting input/output interfaces with combinatorial or registered logic.",
      "description_length": 587,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements register banks connected to an AXI4-lite master interface, supporting read and write transactions framed by `_valid`, `_first`, and `_ready` signals. It provides combinators for structuring register interfaces with named, tagged ports, enabling dynamic field access, signal conversion, and metadata handling. Use cases include FPGA register configuration, debug interface implementation, and hardware verification flows requiring precise transaction control and interface synchronization.",
      "description_length": 511,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for creating and managing register-based datapaths with support for signal concatenation, multiplexing (including priority and one-hot selection), and pipelining, along with wire assignment and signal routing. It operates on signal (`Hardcaml.Signal.t`) and register structures (`Register.I.Of_signal.t`), emphasizing hardware validation tasks like width checking, state management, and hierarchical signal naming. Specific use cases include constructing AXI4-compliant bus interfaces, validating interconnect connectivity, and implementing pipelined control logic with precise signal synchronization requirements.",
      "description_length": 646,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate state machine components for AXI4-lite interfaces using Hardcaml's `Always` DSL. It supports working with `Always.Variable.t` and `Signal.t` values structured according to the AXI4-lite master interface specification. Concrete use cases include defining register and wire logic for AXI4-lite masters, assigning signals, and applying naming conventions to signals within the state machine.",
      "description_length": 448,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to connect, name, and manipulate AXI4-lite slave-to-master signal interfaces, focusing on transaction framing, handshaking, and pipeline control. It operates on signal interfaces with `_valid`, `_first`, and `_ready` control signals, enabling tasks like multiplexing, register insertion, and signal concatenation. Specific use cases include translating slave response logic into AXI-compliant master interfaces and synchronizing transaction completion across hardware pipelines.",
      "description_length": 509,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register interface for a 32-bit AXI bus, specifying port names and widths as lists of strings and integers. It provides direct access to signal tags, names, and widths used in the register's datapath. Concrete use cases include configuring and inspecting register signals during hardware compilation and simulation.",
      "description_length": 339,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module provides combinators and utilities for structured manipulation of AXI4 register bank interfaces with tagged fields, focusing on read-enable signal management. It operates on `Read_enable.t` structures and associated metadata like string/integer port specifications, enabling type-safe transformations between lists, signals, and register banks. Specific use cases include defining register interfaces with precise read-enable control, converting between bit-level representations, and sequencing hardware description effects while preserving AXI4 protocol compliance.",
      "description_length": 579,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate signals within a slave state machine for AXI4-lite interfaces, specifically handling the translation between AXI transfers and an internal bus protocol. It works with data types such as `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, enabling register and wire creation, signal assignment, and naming conventions. Concrete use cases include implementing register logic with optional enable signals, connecting internal signals to AXI interface components, and applying hierarchical naming to generated signals.",
      "description_length": 600,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register interfaces, including packing, unpacking, multiplexing, and concatenation of register values. It supports data types such as `comb` and `t`, where `t` represents a 32-bit register structure with combinational logic. Concrete use cases include constructing and validating register datapaths, selecting between multiple register inputs using priority or one-hot encoding, and converting between integer values and register representations.",
      "description_length": 526,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module constructs and manages individual slave instances within a demultiplexer, enabling the routing of AXI4 master signals to specific slaves. It provides functions to access and assign the master-to-slave and slave-to-master signal interfaces, facilitating precise control over AXI4 communication paths. Use this module to define how each slave connects and interacts with the demultiplexer in an AXI4 bus architecture.",
      "description_length": 427,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port names, widths, and tags for AXI4 interface implementations. It provides direct access to lists of port names, widths, and associated tags for use in hardware description and verification. Concrete use cases include generating signal declarations, checking interface compatibility, and driving testbench stimulus for AXI4 register banks.",
      "description_length": 375,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a collection of monadic values within an interface into a monadic interface value, effectively combining them. It operates on data structures involving interfaces (`I.t`) and monads (`M.t`), specifically handling values of type `'a M.t I.t`. Use this to lift and merge multiple register fields or interface components into a single unified interface wrapped in a monad.",
      "description_length": 423,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides combinational and sequential logic operations for AXI4-lite slave state machines, including value packing/unpacking, multiplexing, priority selection, register pipelining, and signal assignment, operating on `Signal.t`-based representations of AXI protocol signals and internal bus structures. It facilitates hierarchical state machine composition, signal validation, and width manipulation while supporting use cases like AXI-to-internal protocol conversion, hardware description wiring, and naming conventions for design clarity in FPGA or ASIC implementations.",
      "description_length": 584,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a register combinator across a polymorphic module structure, enabling consistent register application within a bus interface. It operates on data types involving `Register.O.t` and is used to manage register state transitions in AXI4 bus datapaths. A concrete use case involves applying a register stage uniformly across all elements of a bus to meet timing constraints in hardware designs.",
      "description_length": 444,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to `Internal_bus.Slave_to_master` interfaces using the Always API. It supports operations like extracting signals from variables, assigning signals to variables within an always block, and creating register or wire variables with optional naming. These utilities are used to implement AXI4-lite slave-to-master logic with signal-level control and precise timing.",
      "description_length": 425,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate state machine signals for AXI4-lite slave interfaces. It works with `Always.Variable.t` and `Signal.t` types, specifically for handling register and wire assignments within the state machine. Concrete use cases include defining register behavior with optional enable signals, assigning signals to variables, and applying naming conventions to signals for clarity in hardware descriptions.",
      "description_length": 448,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a transformation function `all` that maps over the fields of a register interface, converting each field from a polymorphic type `'a M.t` to a concrete type `'a` while preserving the register structure. It operates on 32-bit AXI register interfaces used for hardware register datapaths. A concrete use case is transforming generic register configurations into specific signal types during hardware register file instantiation.",
      "description_length": 447,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI register interfaces, including packing, unpacking, multiplexing, and selection functions. It works with 32-bit data and address buses, using a specified combinational logic module for internal operations. Concrete use cases include constructing and validating register datapaths, selecting between multiple register inputs based on priority or one-hot encoding, and converting integer values to properly sized register types.",
      "description_length": 505,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of signal ports for a simplified slave-to-master interface within an AXI4-lite compatible design. It provides concrete lists of port names, port widths, and tags that describe the structure of the internal bus protocol. These values are used to encode slave responses into AXI-compliant signals during hardware synthesis.",
      "description_length": 362,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI slave state machine interfaces and string-keyed associations of values, using port names as keys. Converts interface signals to or from a list of (port_name, value) pairs. Useful for dynamically inspecting or configuring AXI interface signals by name at runtime.",
      "description_length": 279,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a register interface and an association list mapping port names to values. It operates on 32-bit AXI register structures, specifically for input interfaces. Use this module when you need to serialize or deserialize register state for debugging, configuration, or integration with external systems.",
      "description_length": 345,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-lite slave state machines into a single combined state machine, handling address decoding and routing of transactions to individual slaves. Works with AXI4-lite interfaces and internal bus protocols defined by `Internal_bus`. Used to manage multiple memory-mapped peripherals sharing a common AXI4-lite bus, ensuring correct arbitration and response handling.",
      "description_length": 389,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register bank port names, widths, and tags for AXI4 interface implementations. It provides direct access to lists of port names, widths, and associated tags derived from the interface specification. Useful for generating register bank wiring or documentation from AXI4 components.",
      "description_length": 300,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between an interface and an association list indexed by field names, enabling direct mapping of interface fields to named values. It operates on data structures representing AXI4 interfaces, specifically working with `O.t` types parameterized over any value type `'a`. These functions are used to dynamically construct or inspect AXI4 interfaces by field name, such as when programmatically generating register banks or debugging interface signal values.",
      "description_length": 496,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that lifts monadic values from within an AXI4-lite master-to-slave interface, transforming a structure containing monadic actions into a monadic action containing the interface structure. It operates on the `Internal_bus.Master_to_slave` interface, which includes signals framed by `_valid` and `_first` for transaction control. Use this to sequence or combine AXI4-lite transactions in a monadic context, such as managing register writes or memory updates with dependent steps.",
      "description_length": 516,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports operations such as register instantiation, signal multiplexing, concatenation, and priority selection for AXI4-stream datapath signals. It works with signal-level AXI stream interfaces, enabling precise control over data flow and synchronization via `tvalid`/`tready` handshaking. It is particularly useful in hardware designs requiring registered AXI stream pipelines to meet timing constraints or manage data transfer between clock domains.",
      "description_length": 463,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces when working with AXI4-stream datapaths. It supports operations like assigning signals to variables, applying names to interface fields, and creating registered or combinational signal containers. Concrete use cases include building AXI stream pipelines with registered handshakes and named signal interfaces for clarity in hardware descriptions.",
      "description_length": 431,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register bank interfaces as bit vectors, including packing, unpacking, concatenation, and multiplexing. It works with `t` values representing register banks and `comb` values for combinational signals. Concrete use cases include constructing register banks from constants, validating signal widths, and implementing multiplexed register selection logic.",
      "description_length": 399,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate bit-level register interfaces for AXI4 buses, specifically handling data packing, unpacking, and selection logic. It works with `Bits.t` and register types to manage signal widths and routing in hardware descriptions. Concrete uses include implementing register file access, data path multiplexing, and signal concatenation in AXI4-compliant bus interfaces.",
      "description_length": 417,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Maps between AXI4-lite master state machine components and string-labeled ports using unsafe associations. Converts structured state machine values to and from string-keyed lists of port assignments. Useful for debugging or dynamically inspecting AXI4-lite interface connections by name without safe type enforcement.",
      "description_length": 317,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and widths for a 32-bit AXI bus interface. It provides direct access to signal names, their bit widths, and associated tags for hardware register configuration. Useful for generating register maps or configuring AXI peripherals with fixed data and address widths.",
      "description_length": 303,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports combinational and sequential logic operations for AXI4-lite slave state machines, including signal packing/unpacking, multiplexing, and priority selection. It operates on `comb` (combinational logic) and `t` (state machine interface) types to manage signal validation, pipeline stages, and register control. Specific use cases include translating AXI transactions into internal bus protocol operations, implementing register banks with dynamic signal routing, and constructing pipelined data flows with named signal hierarchies for debug visibility.",
      "description_length": 570,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps association lists to AXI stream interface values by field name, enabling programmatic construction and inspection of stream interfaces. It operates on `Datapath_register.I.t` values, which represent registered AXI stream endpoints, and uses string keys to associate signals with their corresponding interface fields. Use this to dynamically build or deconstruct AXI stream interfaces from named signal lists, such as when integrating with HDL netlists or configuration-driven hardware pipelines.",
      "description_length": 521,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a write interface with validity into a monadic structure, enabling sequential composition of AXI4 write operations. It operates on data types involving `Write_with_valid`, which pairs data with a validity signal, and a monad `M` that sequences operations. A concrete use case is aggregating multiple AXI4 write transactions into a single monadic action, ensuring correct ordering and handshake signaling in hardware descriptions.",
      "description_length": 483,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a write interface with valid signals and an association list indexed by field names. It operates on data structures representing AXI4 register banks, specifically handling writes where each field has an associated valid signal. Use this to easily map register fields to and from named key-value pairs, simplifying configuration and status register management in hardware designs.",
      "description_length": 429,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-lite slave state machine signals. It supports data type conversions, signal packing/unpacking, multiplexing, and priority/one-hot selection for AXI4-lite protocol signals. Concrete use cases include implementing control logic for AXI4-lite slave devices, routing AXI4-lite transactions, and constructing complex AXI4-lite register interfaces.",
      "description_length": 416,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the register bank's write interface by specifying the names and widths of its ports. It provides concrete signal names and bit-widths for each register in the bank, derived from the `Write_with_valid` interface. Use this module to generate register bank port mappings or configure hardware signals in AXI4-compliant designs.",
      "description_length": 344,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate 32-bit AXI register interfaces synchronized with an always block. It works with `Always.Variable.t` and `Signal.t` types, specifically for managing register state machines in AXI data paths. Use it to implement AXI register logic with enable control, naming, and signal assignment in a 32-bit bus context.",
      "description_length": 361,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for mapping, zipping, and transforming AXI4 register interface structures that include validity signals, focusing on field-level operations and port configuration. It works with `Write_with_valid.t` types representing register banks with synchronous write ports, enabling precise control over signal assignment and register instantiation. Use cases include synthesizing AXI-connected register banks with valid-ready handshaking, managing hierarchical port mappings, and generating hardware descriptions with structured combinational or sequential logic.",
      "description_length": 586,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the creation and management of 32-bit AXI register interfaces using combinational and registered signals. It operates on types representing AXI register fields with specified widths, supporting operations like signal conversion (`of_int`, `pack`), multiplexing (`mux`, `priority_select`), concatenation (`concat`), and pipeline control (`reg`, `pipeline`). These capabilities are essential for implementing AXI4 peripherals and managing register banks in FPGA-based systems, such as custom IP cores or hardware accelerators.",
      "description_length": 544,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-stream interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types representing hardware signals and structured `t` types modeling AXI stream datapaths. Concrete use cases include building routing logic for AXI streams, implementing priority or one-hot multiplexers, and validating signal widths in hardware designs.",
      "description_length": 460,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-lite slave state machine signals. It supports data types representing internal bus signals with combinational logic values, including functions for packing, unpacking, multiplexing, and priority/one-hot selection. Concrete use cases include implementing control logic for AXI4-lite slave devices, routing bus signals based on address decoding, and constructing complex register mappings from simpler components.",
      "description_length": 485,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_always",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit AXI register interface with combinational and registered signal assignment capabilities. It operates on 32-bit data and address buses, supporting operations like value assignment, signal registration with optional enable, and wire creation with bit-width specification. Concrete use cases include modeling AXI register slices in hardware designs, such as control/status registers or data path intermediates in AXI-connected peripherals.",
      "description_length": 468,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4 interface signals as bit vectors, including packing, unpacking, multiplexing, and concatenation. It works with types representing AXI4 interface fields (`I.Of_bits.comb I.t`) and bit vectors (`Hardcaml.Bits.t`). Concrete use cases include constructing register banks from bit-level signals, validating signal widths against interface specifications, and implementing control logic with priority or one-hot selection over AXI4 interfaces.",
      "description_length": 488,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between register state and association lists keyed by port names. It operates on register structures containing string-indexed values of a uniform type. Use this when mapping register fields to named ports in AXI4 bus interfaces, such as connecting signal names to hardware registers during bus initialization or testbench setup.",
      "description_length": 369,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to convert between integer values and bit-level representations for a register interface, enabling direct manipulation of hardware registers via bit vectors. It supports packing, unpacking, concatenation, and multiplexing of register values with precise width control, ensuring correct data path handling. Concrete use cases include implementing AXI4 register interfaces with fixed or dynamic bit-widths, and constructing state machines that require bit-accurate register I/O.",
      "description_length": 508,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-lite slave-to-master interfaces, including packing/unpacking signals to/from bit vectors, multiplexing and concatenating interface values, and selecting between multiple interfaces using priority or one-hot encoding. It works with the `comb` type and the `t` type representing AXI4-lite slave-to-master signals. Concrete use cases include implementing control logic for hardware peripherals, routing AXI transactions between components, and constructing test stimuli for AXI-based systems.",
      "description_length": 563,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.All",
      "library": "hardcaml_axi",
      "description": "Converts a collection of AXI4-lite master state machines into a single combined state machine, enabling sequential execution of multiple AXI4-lite transactions. Works with AXI4-lite master interfaces and Ibus protocols, handling address, write, and read operations. Useful for orchestrating complex memory-mapped I/O sequences over AXI4-lite from a master device.",
      "description_length": 363,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and manipulation of 32-bit AXI register interfaces using combinational signals, offering operations for signal conversion, multiplexing, pipelining, and register logic. It works with structured register types and 32-bit AXI buses to implement datapath control and signal routing in hardware designs. Key use cases include synthesizing register blocks with named signals, applying priority-based selection, and managing AXI-compliant interfaces for peripherals.",
      "description_length": 497,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names, widths, and tags for AXI4 bus interfaces. It provides direct access to lists of port names, widths, and associated register tags used in the datapath registration state machine. It is used to configure and manage register mappings in AXI4-compliant hardware designs, specifically aligning with Xilinx AXI4 specifications.",
      "description_length": 362,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation of register interfaces through tag- or name-based mapping, conversion to association lists, and zipping operations, while providing combinators for transforming bit vectors, folding over interfaces, and constructing combinational logic. It works with typed register interface values (`'a O.t`) and 32-bit AXI4 register banks connected to master interfaces, supporting dynamic field access and metadata-driven signal routing. Specific use cases include AXI4 interface generation with named port mappings, register bank construction within hardware description blocks, and multiplexing/concatenation of register fields for FPGA signal mapping.",
      "description_length": 685,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire interfaces in the context of AXI4 read-enable logic. It supports operations like assigning values to variables, creating registers with optional enable signals, and applying naming conventions to interface fields. Use cases include implementing AXI4 slave interfaces with structured signal handling and register banks.",
      "description_length": 392,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps register fields to string keys in an association list, enabling named access to register elements. It supports conversion between register structures and string-keyed lists, facilitating dynamic register configuration and introspection. Use this when associating register fields with port names for simulation or debugging purposes.",
      "description_length": 358,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides `to_alist` and `of_alist` functions that convert between a datapath register interface and an association list indexed by field names. It operates on the `Datapath_register.IO.t` type, which represents registered AXI stream signals. These functions enable dynamic access and construction of signal mappings by string keys, useful for introspection, configuration, or debugging AXI stream interfaces.",
      "description_length": 420,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert integer values to 32-bit register structures and manipulate them using operations like packing, unpacking, concatenation, and multiplexing. It works with 32-bit data structures represented as `comb` types within a register interface, supporting bit-level transformations and selection logic. Concrete use cases include constructing and validating register fields for AXI4 bus interfaces, such as setting control signals or decoding status values from hardware components.",
      "description_length": 513,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the master-to-slave interface in a simplified AXI4-lite bus protocol. It provides lists of port names, port widths, and tags used to decode transactions, enabling precise signal handling during hardware simulation or synthesis. These values are used directly to construct and interpret read and write operations between master and slave components in a hardware design.",
      "description_length": 421,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating AXI4-lite master-to-slave interfaces, including packing/unpacking signals to/from bit vectors, multiplexing and concatenating interface signals, and selecting between multiple interfaces using priority or one-hot encoding. It works with the `comb Internal_bus.Master_to_slave.t` type, representing AXI4-lite control and data signals in a hardware design. Concrete use cases include routing AXI4-lite transactions to multiple slaves, validating signal widths during simulation, and constructing constant or dynamic interface values for testbenches or hardware generators.",
      "description_length": 639,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating register interfaces, including packing/unpacking values, multiplexing, concatenation, and priority/onehot selection. It works with `comb` types and register interface structures, enabling direct hardware modeling for AXI4 datapath logic. Concrete use cases include building register file read/write paths, control signal routing, and data alignment logic in hardware designs.",
      "description_length": 444,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for managing a state machine that converts Ibus transactions to AXI4-Lite protocol. It supports construction, manipulation, and validation of state machine signals using `Bits.t` values, enabling tasks like register access and memory-mapped I/O. Specific functions include packing/unpacking, multiplexing, concatenation, and priority/one-hot selection for AXI4-Lite communication logic.",
      "description_length": 428,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4 register bank interfaces using a combinational logic representation. It supports data types including packed vectors, interface records with typed fields, and multiplexing structures, with concrete operations like packing/unpacking interfaces to vectors, constant assignment, and priority/one-hot selection logic. Use cases include defining AXI4 register banks with fixed or dynamic field widths, validating signal widths during simulation, and building multiplexed register access paths for hardware designs.",
      "description_length": 580,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for managing AXI4-lite master interface signals, including packing, unpacking, multiplexing, and concatenation of signal structures. It works with `comb` types and structured `t` values containing AXI4-lite interface fields. Concrete use cases include constructing and validating signal paths for AXI4-lite communication, selecting between multiple input sources using priority or one-hot encoding, and converting between integer and signal representations.",
      "description_length": 509,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.All",
      "library": "hardcaml_axi",
      "description": "Registers all output signals of an AXI4-stream interface when placed between components, ensuring compliance with the `tvalid`/`tready` handshake protocol. Works with AXI4-stream source/destination interfaces, lifting monadic values across the interface using `all` to combine and propagate them correctly. Useful for pipelining data streams in hardware designs while maintaining protocol correctness.",
      "description_length": 401,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for the AXI4-lite interface ports used in the Ibus-to-AXI conversion state machine. It provides direct access to port metadata such as names, widths, and associated tags, enabling precise signal handling during the conversion process. These values are used to configure and connect the interface signals in hardware description code.",
      "description_length": 381,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-stream interfaces, including signal packing/unpacking, multiplexing, concatenation, and selection. It works with registered AXI stream interfaces containing combinational signals. Concrete use cases include constructing data paths that require precise control over signal routing and transformation in hardware designs.",
      "description_length": 380,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables manipulation of AXI4 read-enable interface signals through operations like packing/unpacking, multiplexing, concatenation, and register management, alongside validation and signal wiring. It works with `Read_enable.Of_signal.t` and `Read_enable.Of_signal.comb` types to handle combinational and registered signal paths. These utilities are used for tasks like connecting hardware components, defining input/output ports, and applying hierarchical naming conventions during register bank implementation.",
      "description_length": 522,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module implements bit-level signal manipulation for AXI4-lite slave state machines, handling protocol conversion between AXI transfers and an internal simplified bus representation. It operates on `comb` signals representing hardware bits and structured `t` values modeling the internal bus protocol. Concrete use cases include packing/unpacking register fields, multiplexing data paths, and implementing priority-encoded signal routing in AXI4-lite slave logic.",
      "description_length": 467,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of the ports in a registered AXI4-stream datapath interface, providing direct access to signal names, their bit-widths, and associated tags. It operates on standard AXI4-stream signals such as `tvalid`, `tready`, and `tdata`, enabling precise control over interface registration and signal alignment. Concrete use cases include configuring synthesis attributes, generating signal documentation, and ensuring consistent interface matching between streaming components.",
      "description_length": 508,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "Constructs and manages a demultiplexed AXI4-lite bus structure by aggregating multiple slave instances. It routes transactions from a single master to the appropriate slave based on address decoding. This module is used to implement memory-mapped register banks where each register block responds to a specific address range.",
      "description_length": 325,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register.O",
      "library": "hardcaml_axi",
      "description": "This module supports register field manipulation through mapping, folding, and zipping operations, along with combinational logic synthesis and bit",
      "description_length": 147,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-stream interfaces with registered outputs, handling bit-level operations such as packing, unpacking, multiplexing, and concatenation. It works with data types representing AXI stream signals (`t`) and bit vectors (`comb`). Concrete use cases include constructing and validating AXI stream datapaths, selecting between multiple input streams using priority or one-hot encoding, and converting between integer constants and bit-level stream representations.",
      "description_length": 505,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI register interfaces, including packing, unpacking, multiplexing, and concatenation of register values. It works with `comb` typed signals and `t` representing registered combinational values. Use this module to implement control logic for AXI data paths, such as selecting between multiple data sources or encoding/decoding register fields.",
      "description_length": 400,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and manipulating AXI4 interface values using a combinational logic type. It supports packing and unpacking interfaces to and from vectors, multiplexing and concatenating interfaces, and creating constant or priority-encoded selections. These operations are used to build complex AXI4-based hardware designs with fixed-width signals and well-defined field layouts.",
      "description_length": 412,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps AXI4-lite master-to-slave transactions to association lists keyed by field names, enabling direct access to slave registers by name. It provides `to_alist` to convert transaction data into named fields and `of_alist` to construct transactions from named register values. Use this when directly manipulating slave register interfaces by name, such as configuring hardware blocks via mapped registers.",
      "description_length": 425,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer.Builder.Slave_instance",
      "library": "hardcaml_axi",
      "description": "This module manages individual slave instances within a demultiplexed AXI4 bus hierarchy. It provides accessors to retrieve the master and slave AXI4 interfaces and a setter to assign the slave response signals. It is used to connect and route AXI4 transactions from a shared master to specific slaves based on address decoding.",
      "description_length": 328,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines port metadata for an AXI4-lite master state machine, including port names, widths, and associated tags. It provides direct access to signal identifiers and their bit-widths used in the Ibus-to-AXI conversion logic. These values are used to configure and connect hardware signals in the state machine implementation.",
      "description_length": 335,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manage AXI4 write interfaces using Hardcaml's Always API, specifically handling register and wire variable creation, assignment, and naming. It operates on `Write_with_valid.t` interface structures, which encapsulate signals with valid bits. Use cases include constructing AXI4-compliant write paths with registered or combinational signals, assigning values within always blocks, and applying consistent signal naming for synthesis and debugging.",
      "description_length": 481,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a computation operating on individual signal types into one that operates on grouped signal types, enabling structured handling of AXI4-lite interface signals during state machine construction. It works with polymorphic tuple-like structures representing hardware signals, specifically those conforming to the `Master_statemachine.I.t` type. Use this when mapping per-signal logic across a collection of related AXI4-lite interface signals in a master state machine.",
      "description_length": 520,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps association lists to internal bus slave-to-master interfaces by field names. It converts lists of key-value pairs into transactional read/write responses for AXI4-lite slaves. Use it to dynamically construct or deconstruct slave responses during simulation or testbench validation.",
      "description_length": 307,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module provides operations for constructing and transforming AXI4 register banks with typed fields, supporting structural manipulations like mapping, zipping, and folding over interface values (`'a I.t`), as well as conversions to bit vectors, signals, or monadic forms. It works with hardware description primitives such as registers, wires, and combinational logic blocks, while enabling metadata-driven workflows for port naming, width specification, and synthesis-friendly interface definitions. Key use cases include building AXI4-compliant register banks with safe/unsafe associative list transformations, defining signal assignments in `Always` blocks, and generating debuggable hardware interfaces with explicit port metadata.",
      "description_length": 739,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-stream interfaces using bit vectors, including packing/unpacking signals into vectors, multiplexing and concatenating interfaces, and validating signal widths. It supports operations like `mux`, `concat`, and `priority_select` for combining or selecting between multiple AXI-stream sources based on control signals. Concrete use cases include building configurable datapaths, routing AXI-stream data between hardware blocks, and ensuring signal width consistency in generated HDL code.",
      "description_length": 535,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations to construct and manipulate AXI4 write interface signals with validity flags, including register pipeline creation, constant assignment, and signal concatenation/multiplexing. It works with `Write_with_valid.Of_signal.t` values, which model AXI4 write channels with explicit valid/ready handshaking, ensuring correct signal widths and synchronization. These utilities are used to implement AXI4-compliant write data paths in RTL designs, such as buffering write transactions or dynamically steering signals through pipeline stages.",
      "description_length": 563,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for constructing and transforming register bank interfaces with read-enable semantics over 32-bit AXI buses, supporting operations like zipping, mapping, and folding across tagged field-level components. It works with structures representing register banks connected to AXI4 master interfaces, handling conversions between bit-level representations, signal routing, and metadata extraction for port names and widths. These utilities are used to implement AXI4-compliant hardware designs with fine-grained read-enable control, such as synthesizing register banks from always-block logic or mapping field names to physical ports during interface configuration.",
      "description_length": 691,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines register port names and widths for an AXI4 internal bus, providing direct access to signal identifiers and their bit-widths. It works with string and integer lists to represent port metadata, alongside a list of register tags. Use this module to generate signal declarations or configure register interfaces in AXI4 bus implementations.",
      "description_length": 356,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for managing AXI4-lite master state machines, including functions for packing/unpacking, multiplexing, concatenation, and priority/one-hot selection of signals. It works with `comb` types and structured state machine types to handle signal routing and control logic in hardware designs. Concrete use cases include implementing bus arbitration, signal selection, and data path control in AXI4-lite master interfaces.",
      "description_length": 467,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides functions to convert between a register bank interface and an association list indexed by field names, using string keys. It operates on the `Read_enable.t` type, which represents a register bank with read-enable signals. Use this module to dynamically construct or inspect register bank interfaces from named field-value pairs, such as when parsing configuration data or generating test vectors.",
      "description_length": 417,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.I",
      "library": "hardcaml_axi",
      "description": "This module enables structured manipulation of AXI4 interface signals through combinators for mapping, zipping, and folding over register banks, while supporting introspection via port metadata (names, widths). It operates on hardware description primitives like bit vectors, signal lists, and string-keyed port associations, facilitating tasks such as synchronous pipeline construction, testbench signal routing, and dynamic register bank composition with type-safe field transformations. Key applications include HDL designs requiring precise control over AXI4 register interfaces and metadata-driven wiring/documentation workflows.",
      "description_length": 634,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Write_with_valid",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structuring and transforming AXI4 write transactions with validity signaling, enabling operations like mapping over register fields, zipping interfaces, and converting between association lists and hardware signals. It works with register fields paired with validity indicators, bit vectors, and port-defined register banks, focusing on sequencing write operations and managing signal assignments. Specific use cases include AXI4 interface configuration, register bank port mapping, and validity-aware transaction sequencing in hardware designs using Hardcaml's Always API.",
      "description_length": 610,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that sequences operations across a 32-bit AXI master-to-slave interface, lifting monadic actions to operate collectively on the interface. It works with 32-bit data and address buses, transforming AXI requests into a decoded master-to-slave signal format. A concrete use case is coordinating multiple memory-mapped register reads or writes in a single AXI transaction.",
      "description_length": 406,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-lite master-to-slave interfaces, including signal packing, unpacking, multiplexing, and concatenation. It works with `comb` type signals and structured `t` type interfaces composed of address, data, and control fields. Use cases include building AXI4-lite multiplexers, routing logic, and testbench stimulus generation for FPGA or ASIC designs.",
      "description_length": 405,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides the `all` function, which lifts monadic actions from within an AXI4-lite master-to-slave interface to the outer monad, effectively flattining a structure of monadic computations. It operates on AXI4-lite master-to-slave interfaces containing values wrapped in a monadic type. A typical use case involves composing multiple AXI4-lite transactions within a monadic context, such as scheduling read and write operations in a hardware description workflow.",
      "description_length": 473,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine to manage register datapaths in an AXI4-lite internal bus, handling read and write transactions via `_valid`, `_first`, and `_ready` control signals. It works with hierarchical register structures and supports operations like field mapping, serialization, and combinational logic synthesis. Concrete uses include flattening register hierarchies for synthesis, configuring register maps dynamically, and implementing transaction-aware logic for AXI4-lite slaves.",
      "description_length": 500,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides `to_alist` and `of_alist` for converting between an AXI4-stream source interface and an association list indexed by field names. It operates on `Source.t` values, which represent AXI4-stream data source ports. Use this to dynamically construct or inspect stream interfaces using string keys corresponding to signal names.",
      "description_length": 342,
      "index": 235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.I",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for transforming and routing AXI4-lite slave state machine signals through structural operations like zipping, mapping, and folding, while supporting dynamic signal configuration via port-based association and named tag inspection. It works with AXI4-lite slave state machine interfaces represented as registers and wires (`Always.Variable.t`, `Signal.t`), alongside predefined signal names and widths to enforce protocol compliance. These tools enable composing complex control logic, translating between AXI4-lite and internal bus protocols, and dynamically reconfiguring signal connections across multiple slaves.",
      "description_length": 649,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements 32-bit AXI register bank interfaces with support for read-enable semantics, validity signaling, and pipelined read configurations. It provides combinators for mapping, zipping, and folding over register fields, along with bit-level operations, signal routing, and interface introspection. Concrete use cases include FPGA peripheral register definition, AXI4 write transaction routing, and hardware-software co-design interface generation with named port mappings and dynamic field access.",
      "description_length": 511,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.Read_enable",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate register banks with read-enable signals through mapping, zipping, and conversions between association lists, bit vectors, and interface descriptions, emphasizing tag-based indexing and structural transformations of port properties like names and widths. It targets AXI4 interface data structures, enabling tasks such as signal wiring, register field configuration with dynamic enable controls, and monadic aggregation of read operations in hardware designs. The utilities support generating synthesizable HDL code for AXI-compliant register banks with customizable port definitions.",
      "description_length": 628,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for manipulating 32-bit AXI master-to-slave interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works directly with `t` type interfaces composed of `comb` signals, representing AXI control and data signals with fixed bit widths. Concrete use cases include building AXI bus multiplexers, generating constant AXI responses, and validating signal widths in AXI interconnects.",
      "description_length": 481,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating AXI master-to-slave interfaces. It supports data transformations such as packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations using one-hot or priority-encoded control signals. Concrete use cases include building custom AXI bus multiplexers, decoding AXI transactions into slave-specific signals, and validating interface signal widths during simulation or synthesis.",
      "description_length": 495,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.I",
      "library": "hardcaml_axi",
      "description": "This module enables structured functional transformations and signal routing for AXI4-lite interface logic, focusing on operations like mapping, zipping, and tuple manipulation over AXI4-lite master state machine signals (`t`). It works with AXI4-lite signal data represented as typed tuples, association lists, and bit vectors, alongside metadata for port names, widths, and tags. Its combinators and modules like `Of_always` and `Names_and_widths` facilitate hardware synthesis tasks such as register/wire logic definition, control flow implementation, and Ibus-to-AXI4-lite interface conversion with precise signal routing.",
      "description_length": 626,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of the data and control signals for an AXI4-stream destination interface. It provides access to signal metadata through values like `port_names_and_widths`, `port_names`, and `port_widths`, which are used to construct and inspect hardware descriptions. These values are essential when generating register-transfer level (RTL) code or debugging signal connections in a stream-based data path.",
      "description_length": 432,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.State",
      "library": "hardcaml_axi",
      "description": "This module defines the state machine states used to manage AXI4-lite slave transactions, converting between AXI protocol signals and an internal simplified bus representation. It includes operations for converting states to strings, S-expressions, and integers, enabling debugging and serialization. Concrete use cases include tracking transaction progress in AXI4-lite slave logic and generating test output or logs from simulation.",
      "description_length": 434,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names and widths of ports used in translating a slave-to-master interface to AXI responses. It provides direct access to port metadata as lists of strings and integers, alongside a list of tags identifying each port's role. It is used when encoding interface signals into AXI-compliant output structures.",
      "description_length": 328,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for a 32-bit AXI master-to-slave interface. It provides concrete lists of port names, widths, and associated tags used in decoding AXI requests. These values are used directly in constructing and interpreting AXI4-compliant bus signals for hardware synthesis.",
      "description_length": 307,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.IO",
      "library": "hardcaml_axi",
      "description": "This module suite enables structural manipulation and transformation of AXI-stream datapath register interfaces through operations like mapping, zipping, and conversion to/from association lists, while enforcing registered signal behavior and `tvalid`/`tready` handshake compliance. It operates on `Datapath_register.IO.t` values representing hardware signal interfaces, supporting combinational logic integration, sequential pipeline construction, and monadic sequencing of register stages. Key use cases include building AXI4-stream pipelines with precise control over port naming, signal registration, and interface composition within hardware description workflows.",
      "description_length": 669,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-stream source interfaces, including packing/unpacking interfaces to vectors, multiplexing and concatenating sources, and priority/one-hot selection logic. It works with `comb` types representing combinational signals and `t` types representing AXI-stream source ports. Concrete use cases include constructing AXI-stream data paths, routing signals based on control logic, and validating signal widths during interface construction.",
      "description_length": 492,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for encoding and decoding 32-bit AXI master-to-slave interfaces. It supports constant assignment, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection logic for interface signals. These functions are used to manipulate and route AXI control signals in hardware designs with fixed-width fields.",
      "description_length": 364,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module creates and manipulates AXI4-lite master-to-slave interfaces using association lists keyed by field names. It provides `to_alist` to convert an interface into a list of field name-value pairs and `of_alist` to reconstruct an interface from such a list. These operations are useful when dynamically configuring or inspecting AXI4-lite transactions based on named fields, such as mapping register addresses or decoding responses.",
      "description_length": 439,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides bit-level operations for encoding and manipulating AXI slave-to-master responses with 32-bit data and address buses. It supports constant assignment, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection logic for interface signals. Use cases include constructing fixed-value responses, routing signals through multiplexers, and validating signal widths during simulation or synthesis.",
      "description_length": 434,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between an AXI4-lite interface and an association list indexed by field names. It operates on `Slave_to_master.t` and string-keyed lists, enabling programmatic access and construction of interface signals by name. Use it to dynamically inspect or build AXI4-lite interfaces from named signal mappings.",
      "description_length": 341,
      "index": 251,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.O",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming structured 32-bit AXI register interfaces with string-labeled fields, including mapping, zipping, folding, and serialization to association lists, alongside combinational and registered signal routing. It works with tagged register values representing AXI bus configurations, enabling tasks like peripheral register aggregation, error handling across fields, and datapath synthesis. These capabilities",
      "description_length": 450,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structural transformation, aggregation, and signal routing of AXI4-lite slave-to-master transactions, including operations like mapping, zipping, folding, and dynamic construction by port name or tag. It works with tagged transactional data structures representing AXI4-lite responses, characterized by `_valid`, `_first`, and `_ready` signals to frame read/write transactions. These utilities are used to encode high-level logic into low-level AXI signals, handle dynamic interface assembly, and manage complex transaction routing in hardware designs requiring precise timing and structural control over AXI4-lite communication.",
      "description_length": 666,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a slave-to-master interface containing monadic values into a monadic interface, effectively lifting the monad outside the interface structure. It operates on data types involving `Slave_to_master.t` and is useful for handling collections of AXI4-lite interface signals within a monadic context. A concrete use case includes aggregating multiple AXI4-lite slave responses into a single master request within a computation pipeline.",
      "description_length": 484,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating slave-to-master AXI interfaces. It supports data types including packed vectors and structured interface types with fields like `valid`, `ready`, and `data`. Use cases include packing and unpacking AXI signals, multiplexing between multiple interfaces, and validating signal widths during design elaboration.",
      "description_length": 392,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple monadic slave-to-master interfaces into a single interface, lifting the monad outside. It operates on 32-bit AXI data and address buses, transforming a structure of monadic responses into a monadic response of a unified interface. Use it when aggregating multiple AXI slave responses into a single master interface within a monadic context.",
      "description_length": 401,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module provides polymorphic transformations and signal routing utilities for AXI4-lite master-to-slave transactions, including mapping, zipping, and conversion to association lists. It operates on structured interfaces with tagged internal bus signals framed by validity and readiness handshaking, supporting register bank construction and hardware multiplexing. Key use cases involve direct register access via named associations, transaction sequencing, and combinational logic generation for address/data bit-width configurations.",
      "description_length": 538,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and bit widths for AXI4-lite interface ports when converting a slave to a master. It provides concrete lists of port names, widths, and tags used in the signal mapping process. These values are used directly in hardware description code to ensure correct signal alignment and routing during interface conversion.",
      "description_length": 349,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for converting and manipulating 32-bit AXI slave-to-master interfaces. It supports signal packing/unpacking, multiplexing, concatenation, and selection logic with priority or one-hot encoding, using a specified combinational logic module. Use cases include building AXI interconnects, implementing bus arbitration, or transforming AXI response signals in hardware designs.",
      "description_length": 424,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-stream destination interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires with customizable defaults, and applying naming conventions to interface fields. Concrete use cases include building AXI4-stream compliant hardware modules with structured signal handling and clear signal naming in FPGA designs.",
      "description_length": 430,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "This module constructs and manages a demultiplexer for routing AXI4 transactions from a single master to multiple slaves based on address decoding. It works with 32-bit AXI4 master and slave interfaces, handling the wiring and signal routing required to connect slaves in a memory-mapped system. Concrete use cases include building memory-mapped peripheral systems where a single AXI master must communicate with multiple slaves at different address ranges.",
      "description_length": 457,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-lite slave-to-master interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types and `t` records representing AXI4-lite interface signals. Concrete use cases include constructing and validating AXI4-lite signal paths, implementing register file read/write logic, and routing AXI4-lite transactions in hardware designs.",
      "description_length": 449,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "Implements a RAM with byte-level write enables and configurable size for use in AXI4-lite internal bus protocols. It provides read and write operations synchronized with `_valid`, `_first`, and `_ready` control signals, managing memory transactions within a slave interface. This module is suitable for hardware designs requiring fine-grained memory updates and alignment with AXI4-lite handshake protocols.",
      "description_length": 407,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.O",
      "library": "hardcaml_axi",
      "description": "This module supports transformations, iterations, and inspections of structured register data with named ports, enabling operations like zipping, mapping, and equality checks on values of type `'a t`. It works with association lists, combinational logic primitives, and signal-level representations to manage bit-level manipulations, pipeline stages, and AXI4-compliant control signal integration. Designed for AXI4 bus designs, it facilitates hardware description of register pipelines, data path synchronization, and metadata-driven port configuration aligned with Xilinx specifications.",
      "description_length": 589,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-stream destination interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with `comb` types representing combinational values and `Dest.t` structures modeling AXI-stream destination ports. Concrete use cases include constructing and validating AXI-stream destination logic, routing data between streams, and implementing control logic for stream multiplexing and prioritization.",
      "description_length": 496,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports operations for constructing and transforming AXI4-lite slave-to-master signal interfaces, including signal generation (constants, registers, pipelines), structural manipulation (packing/unpacking, multiplexing), and interface validation. It operates on combinatorial signal types (`comb`) and structured interface records (`t`), enabling precise control over AXI bus behavior in hardware designs. Typical applications include implementing register-mapped peripherals, signal routing logic, and protocol-conformant data paths in FPGA or ASIC development.",
      "description_length": 574,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI master-to-slave interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection between interfaces. Concrete use cases include decoding AXI requests into simpler slave interfaces, routing AXI signals based on control logic, and validating signal widths during interface construction.",
      "description_length": 444,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register.I",
      "library": "hardcaml_axi",
      "description": "This module enables the manipulation of 32-bit AXI input register interfaces through structural transformations, combinational logic construction, and error handling. It operates on typed register structures with named, width-specified ports, supporting introspection, synchronization via enable-controlled always blocks, and conversion to association lists for serialization. These capabilities are applied in FPGA and ASIC design flows for AXI4 bus interfaces, particularly in register field management, signal transformation, and hardware compilation tasks requiring precise control over register state and datapath connectivity.",
      "description_length": 632,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple AXI4-stream destination interfaces into a single interface, lifting the monadic context to the outer layer. It operates on destination interfaces (`Dest.t`) parameterized by a monad `M`. A concrete use case is aggregating multiple streams of data acknowledgments into a unified stream for coordinated processing or synchronization.",
      "description_length": 392,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit AXI slave-to-master interfaces using the Always API, including variable assignment, register creation, and signal naming. It works with `Hardcaml_axi.Internal_bus.W32.Slave_to_master.t` interface containers that hold `Hardcaml.Always.Variable.t` values. Use this module to build and manage AXI response logic within always blocks, such as registering interface signals or assigning wire defaults.",
      "description_length": 448,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI slave-to-master interfaces encoded as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection with valid signals. Use cases include constructing and validating AXI responses from simpler bit representations, and routing AXI signals through logic that requires dynamic selection or transformation of interface fields.",
      "description_length": 459,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a slave-to-master interface and an association list indexed by field names, using string keys. It operates on the `Slave_to_master.t` type and pairs it with values in a list structure. Use this when mapping interface fields to named values, such as during configuration or serialization steps.",
      "description_length": 341,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module connects a master interface to a bank of read/write registers, enabling register access via a simplified internal bus protocol. It handles transactions using `_valid` and `_first` signals to frame read and write operations, with slaves signaling completion via `_ready`. It is used to implement register banks in hardware designs where precise control over register access timing and pipelining is required.",
      "description_length": 419,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for a 32-bit AXI slave-to-master interface. It provides direct access to port names, their bit widths, and associated tags for encoding responses. It is used to map internal signals to AXI-compliant interface requirements as specified in Xilinx's AXI4 documentation.",
      "description_length": 314,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-lite slave-to-master interfaces using the Always API, including creating and assigning register and wire variables. It works with `Slave_to_master.t` interfaces, which represent AXI4-lite protocol signals. Use cases include building synchronous logic blocks that interface with AXI4-lite slaves, such as register banks or memory-mapped peripherals.",
      "description_length": 398,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for an AXI master-to-slave interface. It provides direct access to lists of port names, widths, and associated tags used in the internal bus encoding. These values are used to construct and decode AXI request signals in hardware descriptions targeting Xilinx FPGAs.",
      "description_length": 313,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a master-to-slave interface and association lists indexed by field names, using string keys. It operates on `Master_to_slave.t` values and pairs them with strings in a list structure. This is useful for dynamically constructing or inspecting interfaces from named field-value pairs, such as parsing configuration data or generating debug representations.",
      "description_length": 402,
      "index": 277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "The demultiplexer routes AXI4-lite transactions from a single master to multiple slaves based on address decoding. It manages signal handshaking with `_valid`, `_first`, and `_ready` to coordinate read and write operations across slaves. This is used to implement memory-mapped register banks where each slave handles a distinct address range.",
      "description_length": 343,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the structure and metadata for AXI4-stream source ports, including their names, widths, and associated tags. It provides direct access to lists of port names, widths, and tag identifiers for configuring and inspecting AXI4-stream sources. Use this module when setting up or analyzing AXI4-stream data paths, particularly when mapping hardware signals to interface definitions.",
      "description_length": 396,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports transformation, routing, and naming of AXI4 slave-to-master signals through operations like assignment (`<==`), packing/unpacking, multiplexing, concatenation, and pipeline creation. It works with signal vectors and structured interface types, generating wire representations for inputs/outputs while enabling customizable field naming via prefixes/suffixes. It is used in RTL design to model AXI4 responses, simplify component integration, and enforce consistent signal naming conventions in FPGA workflows.",
      "description_length": 529,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4-stream source interfaces using the Always API. It supports operations like assigning signals to variables, creating registers and wires, and applying names to interface fields. Concrete use cases include building AXI-stream data sources with named signals, defaulting to zero, or connecting to existing signal logic.",
      "description_length": 377,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-stream destination interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. Concrete use cases include constructing and validating AXI-stream destination ports in hardware designs, ensuring correct signal widths, and dynamically routing data streams based on control signals.",
      "description_length": 497,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions for constructing and manipulating AXI4-stream source interfaces using signal-based operations, including constant assignment, signal packing/unpacking, multiplexing, and wire/register creation, alongside validation checks. It operates on `Source.Of_signal.comb` and `Source.Of_signal.t` types, which represent combinational and registered AXI-stream interfaces, respectively. These capabilities are used to implement and connect AXI-streaming logic in hardware designs, such as data pipelines or communication peripherals, ensuring correct signal handling and interface alignment.",
      "description_length": 611,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides operations to manipulate AXI4-lite master-to-slave interfaces represented as bit vectors. It supports construction from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with support for priority and one-hot encoding. These functions are used to implement and verify hardware logic that interfaces with AXI4-lite slaves, such as memory-mapped peripherals.",
      "description_length": 433,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-lite slave-to-master interfaces represented as bit vectors. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. Use cases include hardware simulation, interface validation, and signal routing in digital design workflows.",
      "description_length": 408,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register.I",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for structural transformations and list-like processing of AXI4-compliant register interfaces, enabling operations like mapping, zipping, and equality checks on register structures. It works with hardware register representations (`Register.I.t`) and supports conversions to association lists, named port access, and bit-width specifications through auxiliary modules. These utilities are used for implementing enable-controlled signal registration, combinational logic synthesis, and interface configuration in AXI4 bus designs.",
      "description_length": 562,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that transforms a master-to-slave interface carrying monadic values into a monad wrapping a master-to-slave interface. It operates on AXI4 request and response signals, enabling collective handling of monadic computations across AXI transactions. Use it to sequence AXI memory operations where each transaction depends on the result of the previous, such as reading from or writing to AXI-connected peripherals in a pipelined fashion.",
      "description_length": 472,
      "index": 287,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate and assign values to AXI slave-to-master interfaces using the Always API. It supports operations on `Slave_to_master.t` interfaces composed of `Always.Variable.t` fields, enabling register and wire variable creation, signal assignment, and naming. Concrete use cases include building AXI-compliant interface logic with named signals, defaulting to zero or custom values, and managing register state within an always block.",
      "description_length": 467,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI master-to-slave interfaces using the Always API, including variable assignment, register and wire creation, and signal naming. It operates on `Always.Variable.t` and `Signal.t` values within the `Master_to_slave` interface structure. Concrete use cases include building and managing AXI interface signals in a hardware description, such as assigning register outputs or naming signals for debugging.",
      "description_length": 448,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface.O",
      "library": "hardcaml_axi",
      "description": "This module supports transformation of AXI4 interfaces through field mapping, list conversions, and bit-level operations, alongside validation via unsafe associative lookups by port name. It operates on structured register banks composed of parameterized interface data (strings, integers, signals) and metadata describing port names, widths, and tags. Key applications include hardware register bank construction, testbench generation, and signal integrity verification in AXI4-based designs.",
      "description_length": 493,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the signal names and widths for AXI4-lite master-to-slave interface ports. It provides concrete lists of port names, widths, and tags used to construct and identify interface signals. Useful for generating register or wire declarations and for introspection during simulation or debugging.",
      "description_length": 309,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module provides functions to construct and manipulate AXI4-stream source interfaces using bit vectors. It supports operations like packing/unpacking interfaces to/from vectors, multiplexing and concatenating streams, and selecting between sources using priority or one-hot encoding. Concrete use cases include building data sources for AXI4-stream pipelines, validating signal widths, and dynamically routing streams based on control signals.",
      "description_length": 447,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine.O",
      "library": "hardcaml_axi",
      "description": "This module provides combinators and transformations for AXI4-lite slave state machine configurations, enabling mapping, zipping, folding, and protocol translation between AXI transfers and internal bus signals. It operates on structured configurations (`t` values), signal metadata (port names, widths, tags), and bit-level representations, supporting use cases like control logic synthesis, data aggregation across AXI channels, and alignment of interface protocols during hardware compilation.",
      "description_length": 496,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.I",
      "library": "hardcaml_axi",
      "description": "This module provides polymorphic transformations and structured manipulation of AXI4-stream interfaces with registered signals, supporting operations like mapping, zipping, folding, and bidirectional conversion between interface values and association lists or bit-level representations. It operates on registered AXI stream endpoints (`tvalid`/`tready` handshaked interfaces) with introspectable port names, widths, and tags, enabling dynamic construction and pipeline-aware signal routing. Key use cases include hardware pipeline construction, AXI protocol-compliant datapath registration, and automated interface documentation through named signal hierarchies.",
      "description_length": 663,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming AXI master-to-slave interface signals through packing/unpacking, multiplexing, concatenation, and creating register or pipeline stages. It manipulates combinatorial and registered signal types, enabling validation, structural modifications, bidirectional signal connections, and naming conventions with prefixes/suffixes. These features are applied in hardware designs to route signals between AXI components, enforce naming standards, and manage timing constraints in interconnect logic.",
      "description_length": 537,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank for AXI4-lite interfaces, handling read and write operations directly on the AXI bus. It works with signal and register specification types to map register accesses to AXI transactions, supporting concrete use cases like hardware register configuration and status monitoring. Key functions include address decoding, transaction creation, and integration with AXI master interfaces for synchronous register access.",
      "description_length": 452,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-lite master-to-slave interfaces using the Always API. It supports creating and assigning register and wire variables, and applying naming conventions to interface fields. Use cases include building AXI4-lite slave logic that responds to master transactions, such as register file access or memory-mapped I/O.",
      "description_length": 358,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that combines multiple monadic slave-to-master interface values into a single monadic interface, lifting the monadic structure outside. It operates on types involving `'a M.t Slave_to_master.t`, transforming them into `'a Slave_to_master.t M.t`. This is useful for aggregating AXI responses across multiple monadic computations, enabling parallel composition of AXI interface interactions.",
      "description_length": 427,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer.Builder",
      "library": "hardcaml_axi",
      "description": "Constructs and configures a demultiplexer for routing AXI4 master signals to multiple slaves based on address decoding. Works with `Hardcaml.Signal.t`-based AXI4 interfaces and manages signal routing logic, register specifications, and slave address spaces. Use to implement address-based slave selection in AXI4 memory-mapped bus systems.",
      "description_length": 339,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register.Pipeline_stage_descr",
      "library": "hardcaml_axi",
      "description": "This module describes a single pipeline register stage within a fully registered AXI4-stream datapath. It defines the configuration for a register instance, including an optional instance name and a clear signal. It is used to specify individual stages in a pipeline where AXI stream signals must be registered and controlled via `tvalid`/`tready` handshaking.",
      "description_length": 360,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine.O",
      "library": "hardcaml_axi",
      "description": "This module provides structural transformations and combinators for composing AXI4-lite master state machines, enabling operations like zipping, mapping, folding, and scanning over transaction sequences. It works with hardware description types such as `Signal.t` and `Always.Variable.t`, along with structured state machine representations (`'a t`) for AXI4-lite interface components. These utilities are used to implement control logic, handle Ibus-to-AXI signal routing, and manage memory-mapped I/O operations with support for unsafe name-based port mapping and error handling in register access scenarios.",
      "description_length": 610,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module enables the construction and transformation of 32-bit AXI master-to-slave interface signals through operations like constant assignment (`of_int`), bidirectional wiring (`<==`), pipeline/register insertion (`pipeline`, `reg`), and multiplexing (e.g., `priority_select`, `mux2`). It operates on `comb`-typed signal structures and AXI bus interfaces, supporting tasks such as FPGA component interconnection, pipelined data path design, and hierarchical signal naming via functions like `apply_names`. Structural manipulations (`pack`, `unpack`, `concat`) further facilitate signal composition and interface adaptation in hardware descriptions.",
      "description_length": 653,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate 32-bit master-to-slave AXI interfaces using the Always API, including variable assignment, register creation, and signal naming. It works with `Hardcaml_axi.Internal_bus.W32.Master_to_slave.t` interface containers holding `Hardcaml.Always.Variable.t` values. Use it to build and manage AXI-compliant interface logic within always blocks, such as connecting master requests to slave responses with named signals or registered state.",
      "description_length": 476,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a master-to-slave interface and an association list indexed by field names, using the `to_alist` and `of_alist` functions. It operates on 32-bit AXI interfaces, mapping interface fields to string-keyed values in a list structure. Use this when you need to dynamically construct or inspect AXI master-to-slave signals by field name, such as in testbenches or configuration-driven setups.",
      "description_length": 434,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source.All",
      "library": "hardcaml_axi",
      "description": "This module provides a function `all` that takes a source interface containing monadic values and returns a monadic source interface, effectively combining and lifting the monadic structure. It operates specifically on `Source.t` interfaces parameterized over a monad `M`. A concrete use case is aggregating multiple AXI4-stream sources within a monadic context, such as combining data streams under a scheduler or resource manager.",
      "description_length": 432,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides direct conversions between a slave-to-master interface and an association list indexed by field names. It operates on 32-bit AXI interfaces, allowing easy mapping of interface fields to named values. Use this when encoding or decoding AXI responses using string-keyed data, such as during simulation or testbench setup.",
      "description_length": 340,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module provides `to_alist` and `of_alist` functions that convert between a destination interface and an association list indexed by field names. It operates on `Dest.t` values, which represent AXI4-stream destination interfaces with data and acknowledgment signals. Use this module to serialize or deserialize destination interface values using string keys corresponding to port names.",
      "description_length": 390,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank.With_interface",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4 register banks with structured read/write port configurations, supporting field-level signal transformations and validity-controlled handshaking. It operates on typed interface values (`I.t`, `O.t`) and register modes, enabling precise synthesis of hardware with synchronous write ports and read-enable logic. Concrete use cases include generating debuggable AXI-connected register banks, managing hierarchical port mappings with validity signals, and defining synthesizable register transactions with tagged metadata.",
      "description_length": 546,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions to manipulate AXI4-lite master-to-slave signal interfaces through operations like validation, packing/unpacking, multiplexing, and register management, alongside utilities for bidirectional signal wiring and hierarchical naming of interface fields. It operates on hardware signal representations of AXI4-lite interfaces, enabling structured connectivity and metadata handling. These capabilities are particularly useful for integrating peripherals in FPGA designs, managing control/status register interfaces, or streamlining signal routing in complex AXI4-based systems.",
      "description_length": 602,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_statemachine",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine for converting Ibus transactions into AXI4-lite protocol, managing read and write operations with signal routing and control flow logic. It operates on AXI4-lite signals represented as structured tuples and bit vectors, alongside hardware description types like `Signal.t` and `Always.Variable.t`. It is used to synthesize register logic, implement memory-mapped I/O, and handle Ibus-to-AXI4-lite interface conversion with precise port mapping.",
      "description_length": 483,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Dest",
      "library": "hardcaml_axi",
      "description": "This module enables structured manipulation of AXI4-stream destination interfaces through transformations, signal routing, and metadata introspection, operating on `Dest.t` interfaces that encapsulate data, acknowledgment signals, and port metadata. It supports hardware modeling tasks like stream synchronization, combinational logic synthesis, and RTL signal management, with utilities for error handling, bit-level operations, and structured module creation using register/wire conventions. Key applications include AXI4-stream protocol implementation, hardware verification via signal equality checks, and automated RTL generation with named, width-aware signal definitions.",
      "description_length": 678,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines the names, widths, and tags for AXI4-Lite master-to-slave interface ports. It provides direct access to signal metadata used in hardware description, specifically for AXI4-Lite protocol implementation. Use this module when generating or inspecting AXI4-Lite interface signals in Hardcaml-based designs.",
      "description_length": 322,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Names_and_widths",
      "library": "hardcaml_axi",
      "description": "This module defines operations to access and manipulate the names and widths of ports in a packed array structure, which represents flattened 32-bit vector fields within a register interface. It provides direct access to port metadata through `port_names_and_widths`, `port_names`, `port_widths`, and `tags`. These values are used to describe the layout and encoding of register fields for hardware synthesis and verification tasks.",
      "description_length": 432,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module implements a register bank connected directly to an AXI4-lite bus, enabling memory-mapped register access. It provides functions to create and serialize register banks, working with signals and register specifications to manage read/write operations. Use it to expose hardware registers over AXI4-lite for configuration and status monitoring in FPGA designs.",
      "description_length": 370,
      "index": 314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "Handles demultiplexing AXI4-lite interface signals from a single master to multiple slave interfaces based on address ranges. Works with `Signal.t` types for AXI master and slave signals, and uses a list of internal slave buses for routing. Useful for implementing memory-mapped register banks where different address regions map to separate hardware modules.",
      "description_length": 359,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module provides combinational logic operations for AXI4-Lite master-to-slave interfaces, including signal packing/unpacking, multiplexing, concatenation, and selection functions. It works with interface values composed of signals of type `comb`, supporting constant assignment, validation, and width manipulation. Concrete use cases include constructing and validating AXI4-Lite request/response paths, building multiplexed bus interfaces, and generating constant or conditional signal values.",
      "description_length": 498,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make.With_interface",
      "library": "hardcaml_axi",
      "description": "This module structures AXI4 register banks with read and write operations tied to validity and enable signals, supporting field transformations, port mapping, and signal sequencing. It works with register fields, bit vectors, and interface descriptions annotated with port metadata like names and widths. Concrete use cases include AXI4 interface configuration, HDL signal routing, and synthesizable register bank implementation with Hardcaml's Always API.",
      "description_length": 456,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Make_comb",
      "library": "hardcaml_axi",
      "description": "This module operates on packed arrays of 32-bit vectors, providing functions to pack, unpack, concatenate, and multiplex register interfaces. It supports constant initialization, width validation, and selection operations like priority and one-hot encoding. Use cases include encoding structured register layouts into flat vectors for AXI4 interface manipulation and hardware synthesis.",
      "description_length": 386,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Datapath_register",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4-stream compliant datapath registers with configurable pipeline stages, supporting operations like signal registration, pipeline construction, and `tvalid`/`tready` handshaking. It works with `Datapath_register.IO.t` and `Datapath_register.I.t` types representing hardware interfaces with named, registered signals. Concrete use cases include building multi-stage AXI-stream pipelines with precise control over clocking, reset, and instance naming, as well as integrating registered AXI components in hardware designs.",
      "description_length": 545,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "Implements a RAM with per-byte write enables and configurable size, designed for AXI4-lite interfaces. It connects to an AXI master, handling read and write transactions where each byte in a word can be selectively updated. Useful for memory-mapped I/O systems requiring fine-grained byte-level writes.",
      "description_length": 302,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "This module routes AXI4 transactions from a single 32-bit master interface to multiple slave interfaces based on address decoding. It manages signal routing and wiring for memory-mapped communication, enabling a master to interact with different slaves at distinct address ranges. Use it to build peripheral systems where a single AXI master connects to multiple memory-mapped slaves.",
      "description_length": 384,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module connects a bank of read/write registers to a 32-bit AXI4 master interface, allowing register values to be written and read through AXI transactions. It generates signals for write data, write strobes, and read enables based on the AXI protocol, handling both pipelined and non-pipelined read configurations. Use this module to implement AXI-accessible register banks in hardware designs where register values are driven from or captured to AXI4 interface signals.",
      "description_length": 475,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module enables functional transformations and structural manipulations of 32-bit AXI master-to-slave interfaces, including mapping, zipping, folding, and pipeline insertion operations. It works with AXI signal containers (`t`) composed of tagged interface fields, supporting dynamic configuration by field name and AXI4-compliant signal construction. Specific use cases include hierarchical bus interface assembly, register management, and pipelined data path implementation in hardware designs.",
      "description_length": 500,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Master_to_slave.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module maps AXI4-Lite master-to-slave interface fields to and from association lists using field names as keys. It supports converting interface values to and from lists of string-keyed pairs, enabling dynamic access or construction of interface signals. Use cases include runtime configuration of AXI4-Lite interfaces from named signal mappings or debugging signal inspection via named fields.",
      "description_length": 399,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "Converts between AXI4 interface values and association lists indexed by field names. Works with polymorphic record-like structures where fields correspond to AXI interface signals. Useful for dynamically inspecting or constructing AXI interfaces from named signal-value pairs, such as during simulation or testbench setup.",
      "description_length": 322,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module provides combinators for transforming, combining, and routing AXI slave-to-master interfaces, manipulating structured values like `Slave_to_master.t` through operations such as mapping, zipping, and bit-level conversions, while supporting metadata access via port names and widths. It enables use cases like AXI response encoding, signal packing/unpacking, and RTL design composition, with utilities for register management (using Always variables) and defining AXI-compliant port configurations based on data and address bit widths.",
      "description_length": 545,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_bits",
      "library": "hardcaml_axi",
      "description": "This module handles the conversion and manipulation of packed arrays of 32-bit vectors, primarily used for register interfaces in AXI4 specifications. It provides functions like `pack`, `unpack`, `mux`, and `concat` to encode, decode, and route register data, with validation and width assertion utilities to ensure correctness. Concrete use cases include defining register banks with fixed-width fields and implementing multiplexed register access in hardware designs.",
      "description_length": 469,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module enables structured manipulation of 32-bit AXI slave-to-master interfaces through operations like mapping, zipping, folding, and conversion to/from association lists, while preserving AXI response signal integrity. It operates on tagged interface fields and containers of `Hardcaml.Always.Variable.t` values, supporting hardware logic construction for AXI response handling. Specific use cases include signal registration, combinatorial interface aggregation, and monadic response transformations in AXI4-compliant designs.",
      "description_length": 534,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.All",
      "library": "hardcaml_axi",
      "description": "This module provides the `all` function, which lifts monadic values within a packed array structure to the outer monad, enabling sequential composition of monadic actions across packed arrays. It operates on types `'a M.t t`, where `t` represents a packed array and `M` is a monad, transforming them into `'a t M.t` values. A concrete use case is flattening and sequencing register bank operations that are parameterized over a monadic context, such as simulation or hardware description effects, while preserving the packed array structure for AXI interface compatibility.",
      "description_length": 573,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a RAM with per-byte write enable signals, allowing fine-grained memory updates. It operates on AXI slave interfaces with data signals, using a register specification to control timing and a master interface to drive inputs. It is suitable for AXI-compliant memory-mapped peripherals requiring byte-level write control, such as register banks or configuration memory.",
      "description_length": 389,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module provides structural transformations, combinators, and hardware description utilities for manipulating AXI master-to-slave interfaces. It operates on interface values composed of signals, registers, and wires, along with metadata such as port names, widths, and positional offsets. These capabilities enable use cases like AXI bus routing, request decoding, pipeline stage insertion, and dynamic signal mapping during hardware synthesis, particularly when handling variable-width address/data buses or generating register/wire declarations from interface specifications.",
      "description_length": 581,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit AXI register interface state machine for managing input and output datapaths with support for enable-controlled synchronization, structural transformations, and error handling. It operates on typed register structures with named, width-specified fields, enabling tasks such as peripheral register aggregation, signal routing, and AXI bus configuration in FPGA and ASIC design flows. Key operations include mapping, zipping, folding over register fields, and converting to association lists for serialization, with direct application in hardware compilation and register field management.",
      "description_length": 619,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate AXI4 interface containers using the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. These functions are used to implement AXI4 slave-to-master logic with precise signal handling and naming control in hardware designs.",
      "description_length": 406,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_statemachine",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine that converts AXI4-lite slave transactions into a simplified internal bus protocol and vice versa. It works with AXI4-lite interfaces, internal bus signals, and state registers to manage read and write operations through structured signal transformations and protocol-aware routing. Use it to build AXI4-lite slave logic that interfaces with custom internal control planes, such as register banks or configuration interfaces, where precise transaction tracking and protocol translation are required.",
      "description_length": 538,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Internal_bus",
      "library": "hardcaml_axi",
      "description": "This module implements the internal bus protocol for AXI4-lite transactions, coordinating read and write operations through `_valid`, `_first`, and `_ready` control signals. It supports structured data transfer between masters and slaves, enabling precise timing control and transaction framing for hardware register access and memory-mapped communication. Use cases include building register banks, routing transactions based on address decoding, and managing byte-enabled memory updates in AXI4-lite compliant hardware designs.",
      "description_length": 529,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports.Slave_to_master.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module provides functions for constructing and transforming AXI4 slave-to-master signal interfaces through operations like signal routing (muxing, concatenation, selection), width validation, constant assignment, and pipeline insertion. It operates on structured signal types (`Of_signal.comb t` and `Of_signal.t`) that represent AXI interface elements, enabling use cases such as connecting hardware blocks, synchronizing data paths, and managing control logic in FPGA/ASIC designs. Specific patterns include mapping AXI protocol signals to bit vectors, enforcing interface constraints, and applying hierarchical naming for debug visibility.",
      "description_length": 647,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Unsafe_assoc_by_port_name",
      "library": "hardcaml_axi",
      "description": "This module directly maps field names to values in a packed array representation, enabling efficient lookup and manipulation of AXI4 register fields by string keys. It operates on arrays of 32-bit vectors and supports conversion to and from association lists for structured field access. Use this when dynamically accessing or configuring AXI4 register fields by name, such as in testbenches or runtime-configurable hardware interfaces.",
      "description_length": 436,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make.Source",
      "library": "hardcaml_axi",
      "description": "This module provides operations for transforming, combining, and routing AXI-stream interfaces using functional mappings, combinational logic, and bit-level manipulations, including zipping, folding, and monadic transformations. It operates on AXI-stream source interfaces, signals, bit vectors, and port metadata (names, widths, tags), enabling hardware interface construction, control signal management (e.g., valid signal configuration), and validation of AXI-stream data paths through structural inspection and signal assignment.",
      "description_length": 533,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_signal",
      "library": "hardcaml_axi",
      "description": "This module supports operations for creating and managing packed arrays of 32-bit signals as register interfaces, including packing/unpacking, multiplexing, concatenation, and pipeline register insertion. It works with arrays of 32-bit vectors and signal types representing combinational or registered logic, enabling structured signal composition and control logic implementation. This is particularly useful in AXI4 peripheral design for encoding complex register fields, grouping signals into unified interfaces, and managing priority-encoded or one-hot control paths.",
      "description_length": 571,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Master_to_slave",
      "library": "hardcaml_axi",
      "description": "This module enables structural manipulation and transformation of AXI4-lite master-to-slave interfaces through mapping, zipping, and port introspection operations. It works with `Master_to_slave.t` structures that model AXI4-lite signals, supporting conversions to lists and associative lists, bit-level manipulation, and combinational logic for hardware description. These capabilities facilitate FPGA and ASIC design tasks such as creating memory-mapped interfaces, composing transactions, and routing signals between components.",
      "description_length": 531,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array.Of_always",
      "library": "hardcaml_axi",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a packed array interface. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to signals. Use cases include building AXI register banks with structured signal assignments and named interface fields.",
      "description_length": 377,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make.Slave_to_master",
      "library": "hardcaml_axi",
      "description": "This module supports structural transformations, combinational logic, and bit-level manipulation of AXI4-lite interfaces, primarily working with `Slave_to_master.t` to represent and process AXI4-lite signals. It provides utilities for introspecting port metadata (names, widths), converting interfaces to/from association lists, and composing transactions using functional combinators. These operations are used in FPGA/ASIC workflows to validate, route, or aggregate AXI4-lite transactions, map ports with precise bit widths, and synthesize register or wire logic for hardware designs.",
      "description_length": 586,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32.Ram_with_byte_enables",
      "library": "hardcaml_axi",
      "description": "This module implements a 32-bit wide RAM with byte-level write enables, allowing selective updates to individual bytes within 32-bit words. It operates on AXI4 slave interfaces, handling read and write transactions with configurable memory size and register specification. Use it to model on-chip memory blocks that support partial writes, such as register files or buffer storage in AXI4-based hardware designs.",
      "description_length": 412,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module implements a bank of read/write registers connected to an AXI4 master interface, handling register access with configurable pipelined read depths. It works with signals and lists of signals to manage write values, read enables, and register specifications. Concrete use cases include managing hardware register banks in FPGA designs where synchronized access to memory-mapped registers is required.",
      "description_length": 410,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Demultiplexer",
      "library": "hardcaml_axi",
      "description": "Constructs and configures a demultiplexer for routing AXI4 master signals to multiple slaves based on address decoding. Works with `Hardcaml.Signal.t`-based AXI4 interfaces and manages signal routing logic, register specifications, and slave address spaces. Use to implement address-based slave selection in AXI4 memory-mapped bus systems.",
      "description_length": 339,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make.Register",
      "library": "hardcaml_axi",
      "description": "This module implements a state machine for registering AXI4-compliant data paths, handling enable-controlled signal registration and synchronization. It operates on register interfaces (`Register.I.t`) with named ports and bit-width specifications, supporting transformations like mapping and zipping. It is used to implement pipeline stages, combinational logic synthesis, and AXI4 control signal integration in hardware designs.",
      "description_length": 430,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Make",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4-stream compliant pipeline registers with configurable stages, enabling signal registration, handshaking control, and pipeline construction. It operates on AXI-stream source and destination interfaces, managing `tvalid`/`tready` signals and supporting hardware design tasks like multi-stage data path implementation and registered AXI component integration. Key functions include pipeline stage insertion, clock/reset management, and AXI-stream signal routing with named, width-aware signal definitions.",
      "description_length": 530,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface.Make_read_write",
      "library": "hardcaml_axi",
      "description": "Generates a C union for a memory-mapped read/write interface, outputting to a given channel. Works with AXI4 register interface specifications, producing C code for register access. Useful for hardware-software co-design where register layouts need to be exposed to C drivers.",
      "description_length": 276,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream.Pipeline_stage_descr",
      "library": "hardcaml_axi",
      "description": "Represents a single pipeline register in an AXI4-stream interface, containing an optional instance name and a clear signal. It works with `Hardcaml.Signal.t` to manage pipeline control signals. Used to define and manage individual pipeline stages in AXI4-stream components, particularly for synchronization and reset behavior in hardware designs.",
      "description_length": 346,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_spaces",
      "library": "hardcaml_axi",
      "description": "This module manages a list of non-overlapping address spaces, ensuring they are sorted and validated at creation time. It provides operations to construct and serialize these address space collections. Use it when defining memory-mapped register blocks or peripheral regions that must not overlap and need runtime decoding.",
      "description_length": 323,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_mode.Mode",
      "library": "hardcaml_axi",
      "description": "This module defines register behavior modes for AXI4 interface configurations, specifying how a register should respond after a write operation. It supports three modes: toggling to low, toggling to high, or holding the written value. These modes are used to control register state transitions in hardware designs implementing AXI4 protocols.",
      "description_length": 342,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Make",
      "library": "hardcaml_axi",
      "description": "This module instantiates functions to create full and partial address space decoders using a provided `Comb` interface. It operates on address spaces and a target address, producing a map of decoded signals indicating which address space is selected. Concrete use cases include implementing AXI4 address decoding logic in hardware designs where precise or approximate address matching is required.",
      "description_length": 397,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Packed_array",
      "library": "hardcaml_axi",
      "description": "This module provides structured manipulation of packed arrays composed of 32-bit vectors, enabling efficient field-level access by name or position in AXI4 register interfaces. It supports transformations between hierarchical register layouts and flat bitvector arrays, with operations like mapping, folding, zipping, and bit-level packing/unpacking to handle encoded values (integers, byte sequences, pipelined signals). These capabilities facilitate register bank synthesis tasks such as field offset tracking, metadata-driven interface conversions, and combinational logic optimizations for hardware design workflows.",
      "description_length": 620,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_space",
      "library": "hardcaml_axi",
      "description": "This module supports operations such as comparison, hashing, clamping, and min/max selection for AXI4 address spaces defined by base addresses and size parameters. It provides a structured representation of memory regions to enable sorting, equality checks, and integration into ordered data structures, primarily serving hardware design workflows. These capabilities are critical for constructing address space decoders that route AXI4 transactions in FPGA or ASIC systems, where precise memory range management is required.",
      "description_length": 525,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Register_bank.Make",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4 register banks that handle pipelined read and write operations between master and slave interfaces. It manages signal propagation, valid assertions, and register state updates based on provided write modes and read values. Use it to implement AXI4-compliant register files with precise timing control in FPGA designs.",
      "description_length": 345,
      "index": 355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.W32",
      "library": "hardcaml_axi",
      "description": "This module implements 32-bit AXI4 bus components for hardware design, providing structured interface manipulation and memory-mapped communication. It includes modules for register banks, RAM with byte enables, demultiplexing, and signal transformations tailored for AXI master-to-slave and slave-to-master interactions. Use it to build configurable AXI-connected peripherals, manage register files, and implement pipelined memory interfaces in FPGA or ASIC designs.",
      "description_length": 466,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus.Make",
      "library": "hardcaml_axi",
      "description": "This module provides combinators and transformations for AXI master-to-slave and slave-to-master interface manipulation, including signal routing, mapping, and bit-level conversions. It works with structured interface values composed of signals, registers, and wires, along with metadata such as port names and widths. Use cases include AXI bus routing, pipeline insertion, response encoding, and implementing memory-mapped register banks with synchronized access.",
      "description_length": 464,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite.Make",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4-lite master and slave interface logic with state machines, signal transformations, and protocol-aware routing. It works with structured AXI4-lite signals, internal bus protocols, and memory-mapped register interfaces to enable FPGA and ASIC design tasks such as building register banks, implementing memory-mapped I/O, and routing transactions between masters and slaves based on address decoding. Specific use cases include synthesizing AXI4-lite slave logic for configuration interfaces, converting internal bus transactions to AXI4-lite protocol, and managing byte-enabled memory updates.",
      "description_length": 619,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface.Make",
      "library": "hardcaml_axi",
      "description": "This module generates C structures and address offset definitions for a memory-mapped register interface. It operates on a register specification provided via the `Regs` module, producing output suitable for hardware-software co-design environments. Concrete use cases include generating C headers for FPGA register access in embedded software.",
      "description_length": 344,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder.Address_space_tree",
      "library": "hardcaml_axi",
      "description": "Represents an address space as a binary tree optimized for decoding. It provides `create` to build the tree from a set of address spaces and `sexp_of_t` for serialization. Used to generate efficient logic for AXI4 address decoding in hardware designs where address ranges are hierarchically nested.",
      "description_length": 298,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Stream",
      "library": "hardcaml_axi",
      "description": "Implements AXI4-stream compliant pipeline registers with configurable stages for managing data flow between source and destination interfaces. Works with AXI-stream signals like `tvalid` and `tready` to control handshaking, insert pipeline stages, and handle clock and reset signals. Used to build registered AXI components, synchronize data paths, and implement multi-stage hardware pipelines with named, width-aware signals.",
      "description_length": 426,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_mode",
      "library": "hardcaml_axi",
      "description": "This module defines register behavior modes for AXI4 interface configurations, specifying how a register should respond after a write operation. It supports three modes: toggling to low, toggling to high, or holding the written value. These modes control register state transitions in hardware designs implementing AXI4 protocols.",
      "description_length": 330,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Address_space_decoder",
      "library": "hardcaml_axi",
      "description": "This module constructs address space decoders for AXI4 memory-mapped systems, supporting both full and partial decoding strategies. It operates on structured address spaces with base and size parameters, organizing them into efficient decoding logic for FPGA or ASIC designs. Concrete use cases include routing AXI4 transactions to non-overlapping memory regions and generating selection signals for hardware peripherals based on address ranges.",
      "description_length": 445,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Slave_with_data",
      "library": "hardcaml_axi",
      "description": "This module combines an AXI4 slave interface with associated data, providing a structured way to handle memory-mapped transactions alongside custom data payloads. It supports operations for reading and writing data while maintaining the state of the AXI interface. Concrete use cases include implementing AXI4 peripherals that require both control registers and data buffers, such as DMA controllers or custom accelerators.",
      "description_length": 423,
      "index": 364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.Internal_bus",
      "library": "hardcaml_axi",
      "description": "This module implements internal bus structures for AXI4-based designs, focusing on signal routing, register synchronization, and interface translation. It operates on AXI master and slave interface types, handling data, address, and control signals with support for pipelining and flow control. Use it to construct AXI interconnects, manage register access synchronization, and implement bus multiplexing or demultiplexing logic in hardware designs.",
      "description_length": 449,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_axi.C_register_interface",
      "library": "hardcaml_axi",
      "description": "This module generates C structures and address offset definitions for a memory-mapped register interface based on a provided register specification. It works with register descriptions to produce C headers used in FPGA register access from embedded software. A concrete use case is enabling software control of hardware registers in AXI4-based FPGA designs.",
      "description_length": 357,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite",
      "library": "hardcaml_axi",
      "description": "Implements AXI4-lite master and slave interface logic with state machines, signal transformations, and protocol-aware routing. Works with structured AXI4-lite signals, internal bus protocols, and memory-mapped register interfaces. Enables FPGA and ASIC design tasks like building register banks, implementing memory-mapped I/O, and routing transactions between masters and slaves based on address decoding.",
      "description_length": 406,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Lite_ports",
      "library": "hardcaml_axi",
      "description": "This module defines the signal interfaces for AXI4-Lite master-to-slave and slave-to-master communication, enabling structured manipulation of address, data, and control signals. It works with polymorphic tuples, bit vectors, and association lists to support type-safe interface composition, signal routing, and protocol validation. Concrete use cases include constructing AXI4-Lite register interfaces, implementing address-decoded slaves, and generating hardware modules with validated signal connections.",
      "description_length": 507,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi.Register_bank",
      "library": "hardcaml_axi",
      "description": "This module implements register banks for AXI4 interfaces by mapping hierarchical register layouts to flat bitvector arrays. It provides operations to define, access, and transform register fields by name or position, supporting bit-level packing, unpacking, and metadata-driven conversions. Use cases include synthesizing AXI4 register interfaces with precise field offsets, managing pipelined control signals, and optimizing combinational logic in hardware designs.",
      "description_length": 467,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_axi",
      "library": "hardcaml_axi",
      "description": "This module implements AXI4 interface components for hardware design, providing address decoding, bus structures, register banks, and stream pipelines. It works with AXI master/slave interfaces, memory-mapped registers, and stream signals to support tasks like building interconnects, implementing peripherals, and synchronizing data paths in FPGA and ASIC designs. Specific use cases include constructing register banks with bit-level access, generating C headers for software control, and implementing AXI4-Lite and stream-compliant hardware modules with precise signal routing.",
      "description_length": 580,
      "index": 370,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 373,
    "meaningful_modules": 371,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9946380697050938
  },
  "statistics": {
    "max_description_length": 739,
    "min_description_length": 147,
    "avg_description_length": 461.33153638814014,
    "embedding_file_size_mb": 5.377030372619629
  }
}