{
  "package": "choice",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 4,
  "creation_timestamp": "2025-08-14T22:49:56.335629",
  "modules": [
    {
      "module_path": "Choice.Enum",
      "library": "choice",
      "description": "This module implements enumerations with non-deterministic choices, supporting operations to construct, combine, and traverse enumerated values. It works with polymorphic enumerated types, allowing element-wise manipulation and pairing via `zip`, conversion to list representations, and counting of distinct enumerations. Concrete use cases include generating test inputs, exploring state spaces in combinatorial problems, and managing branching computations where multiple outcomes are possible at each step.",
      "description_length": 509,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Choice.Array",
      "library": "choice",
      "description": "Generates permutations and combinations of array elements using enumerations. Works with arrays of any type and produces lazy sequences of selected elements. Useful for combinatorial searches and iterative algorithms where element order or selection varies.",
      "description_length": 257,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Choice.List",
      "library": "choice",
      "description": "This module provides operations to generate suffixes, permutations, and combinations of lists. It works with polymorphic lists and produces choice types representing possible outcomes. Use it to explore sequence variations, such as generating all 3-element subsets of a list or enumerating all reorderings of a list's elements.",
      "description_length": 327,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Choice",
      "library": "choice",
      "description": "This library provides a monadic interface for non-deterministic choice-based computations, enabling operations like combining alternatives (depth-first or fairly interleaved), filtering, mapping, and conditional branching over values that may yield multiple results. It works with enumerations, lists, and arrays to generate permutations, combinations, and explore branching state spaces, supporting both applicative and monadic composition. Typical use cases include search algorithms, combinatorial problem solving, and non-deterministic computations requiring result limiting or exhaustive exploration strategies.",
      "description_length": 616,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 616,
    "min_description_length": 257,
    "avg_description_length": 427.25,
    "embedding_file_size_mb": 0.058406829833984375
  }
}