{
  "package": "core_profiler",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 186,
  "creation_timestamp": "2025-07-15T23:42:51.477473",
  "modules": [
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into a set of packed message types and errors. Works with `Sexplib0.Sexp.t` and produces values of type `Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.t`. Used during parsing of profiler header data to construct sets from S-expression representations.",
      "description_length": 293,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.Diff",
      "library": "core_profiler",
      "description": "This module represents set differences for profiler message types and errors, tracking additions and removals of elements. It supports operations to compute, apply, and serialize diffs between two sets of profiler data. Use this to analyze changes in profiler state across versions or configurations.",
      "description_length": 300,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map.Diff",
      "library": "core_profiler",
      "description": "This module represents differences between two versions of a key-value map, where each key and value type is polymorphic. It supports operations to serialize and deserialize diffs, extract changes between two map states, apply diffs to a base map, and construct diffs from a list of changes. It is used to track and apply incremental changes to structured data in profiling or state synchronization contexts.",
      "description_length": 408,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.Elt",
      "library": "core_profiler",
      "description": "This module represents elements of a set of packed message types and errors, providing serialization and deserialization to and from S-expressions. It includes a comparator for ordering elements, enabling efficient set operations. It is used for handling structured message types and error data in profiling contexts where set semantics are required.",
      "description_length": 350,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.Provide_hash",
      "library": "core_profiler",
      "description": "This module provides hash folding and hashing operations for sets of packed message types and errors. It works with the `Set.t` type from the `Message_type_and_errors.Packed` module, using the element type defined by the `Elt` parameter. It enables efficient hashing of set contents, suitable for use in persistent data structures or hash-based collections.",
      "description_length": 357,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Hash_set.Provide_of_sexp",
      "library": "core_profiler",
      "description": "This module defines a function `t_of_sexp` that parses S-expressions into values of a hash set type defined in the `Message_type_and_errors.Packed` module. It is parameterized over a module `X` that provides the element type of the hash set. This function is used to construct hash sets from S-expression representations, typically for deserialization or configuration purposes.",
      "description_length": 378,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for a set type defined in the `Message_type_and_errors.Packed.Set` module. It provides functions to compute binary size, read and write values, and define binary shape and type representations. The operations are specifically tailored for working with sets of elements of type `Elt`, enabling efficient binary I/O for structured data.",
      "description_length": 398,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into values of a map type, using a provided conversion function for the map's value type. Works with polymorphic map structures where keys are defined by the `Key` module and values are of a type that can be constructed from S-expressions. Useful for deserializing map data from textual representations in configuration files or data interchange formats.",
      "description_length": 377,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Hash_set.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for hash set values within a specific protocol header structure. It provides functions to compute binary size, read and write hash set data, and define binary shape and type representations. Use this when transmitting or persisting hash set data in a binary format that matches a predefined protocol.",
      "description_length": 364,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map.Provide_bin_io",
      "library": "core_profiler",
      "description": "Implements binary serialization and deserialization for packed maps with arbitrary value types and a fixed key module. Provides functions to compute binary size, read and write values, and define bin_io type classes for efficient binary protocol handling. Useful for persisting or transmitting structured map data in a compact binary format.",
      "description_length": 341,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Table.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for a table structure that maps keys to values, where the key type is parameterized. It provides functions to compute binary size, read and write binary data, and define bin_io readers and writers for the table type. It is used to efficiently serialize and deserialize tables when communicating over binary protocols or storing binary data.",
      "description_length": 404,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map.Provide_hash",
      "library": "core_profiler",
      "description": "This module provides a function `hash_fold_t` for computing hash values over packed maps with a custom key type. It works with the `Packed.Map.t` data structure, which associates keys with values in a type-safe manner. A concrete use case is enabling efficient hashing of message type and error data stored in packed maps for serialization or comparison purposes.",
      "description_length": 363,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Table.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into values of a table type that maps keys to arbitrary data, using a provided conversion function. It supports deserialization of structured data stored in S-expression format. This is useful for parsing configuration or data files that represent tables with custom key types.",
      "description_length": 300,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map.Key",
      "library": "core_profiler",
      "description": "This module defines a key type for maps based on the packed message type and error definitions. It includes serialization functions to and from S-expressions and provides a comparator for ordering keys. It is used to construct and manipulate maps where keys are instances of the packed message type.",
      "description_length": 299,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Hash_set",
      "library": "core_profiler",
      "description": "This module manages hash sets of `Packed.t` values with operations for creation, comparison, and S-expression serialization. It supports efficient membership checks and set manipulation, enabling tasks like tracking unique message types or aggregating errors in profiling data. The first child module adds S-expression parsing for hash sets parameterized over element types, allowing construction from configuration files or external representations. The second child module extends functionality to binary formats, providing serialization, deserialization, and size computation for use in protocol headers or network transmission.",
      "description_length": 631,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Table",
      "library": "core_profiler",
      "description": "This module provides a hash table implementation optimized for mapping packed message types to associated data, supporting efficient lookups, insertions, and customizable handling of duplicate keys. It includes operations to construct tables from lists, group values by computed keys, and serialize or deserialize tables using either binary or S-expression formats through its submodules. The main data type is a hash table with a parameterized key type, and core operations include creation, folding, and key-based aggregation. For example, it can be used to track message metadata during protocol processing, serialize tables for network transmission, or load structured configuration data from files.",
      "description_length": 703,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Replace_polymorphic_compare",
      "library": "core_profiler",
      "description": "This module defines standard comparison operators and equality checks for values of type `Packed.t`, including functions like `(=)`, `(<)`, `(>)`, `compare`, `equal`, `min`, and `max`. It enables direct comparison and ordering of `Packed.t` values based on their internal structure. This is useful when sorting or making conditional decisions based on the relative values of packed message types and errors.",
      "description_length": 407,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Map",
      "library": "core_profiler",
      "description": "This module manages polymorphic maps with rich operations for construction, transformation, and serialization, supporting key remapping, transposition, and safe population from various data structures. It includes core utilities for handling ordered input, resolving key collisions, and converting maps to and from sequences, trees, and hashtables, with error-aware variants and traversal functions. Child modules extend functionality by tracking and applying map diffs, serializing maps to and from S-expressions and binary formats, hashing map contents, and defining key types based on packed messages with ordering and serialization. Example uses include synchronizing state changes, persisting map data efficiently, and hashing structured error information for comparison or transmission.",
      "description_length": 792,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed.Set",
      "library": "core_profiler",
      "description": "This module handles sets of structured values with rich transformation, comparison, and serialization capabilities. It supports construction from lists, arrays, hash tables, and map keys, and provides set operations like union, intersection, and difference, along with equality checks and comparator-based sorting. The module enables deep integration with profiling workflows through child modules that handle S-expression parsing, binary serialization, diff tracking, element comparison, and hash operations. For example, it can parse profiler header data from S-expressions, compute differences between profiler states, and serialize set contents for storage or transmission.",
      "description_length": 677,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Offline.Probe.Group",
      "library": "core_profiler",
      "description": "This module organizes multiple probes into groups to measure and analyze relationships between them, such as time differences or metric changes. It works with probes and timestamps to track transitions between group members, enabling detailed path-based analysis in profiler data. Use it when you need to understand the timing or metric flow between distinct events in a program, like stages in a pipeline or function calls in a cycle.",
      "description_length": 435,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.End_of_header.Unpacked",
      "library": "core_profiler",
      "description": "This module defines the structure and serialization logic for the end-of-header protocol message. It includes functions to convert between S-expressions and the message type, compute the byte size of a message, and write the message to an Iobuf. It works with the `t` type, which contains a message length and type, and is used in network communication to signal the end of a header during data transmission.",
      "description_length": 408,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Hash_set.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into hash sets of globally unique probe IDs. Works directly with `Sexplib0.Sexp.t` and `Core_profiler.Probe_id.Hash_set.t`. Useful for deserializing stored probe data into efficient lookup structures for performance analysis.",
      "description_length": 248,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_group_point.Unpacked",
      "library": "core_profiler",
      "description": "This module defines data structures and serialization functions for handling new group point messages in a profiling protocol. It works with custom types like `t` and `t_sources`, which include probe IDs, message metadata, and source arrays, and supports operations for converting to/from S-expressions and writing to IO buffers. It is used for efficiently encoding and transmitting profiling data during runtime.",
      "description_length": 413,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Hash_set.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for sets of globally unique timer and probe identifiers. It provides functions to compute binary size, read and write operations, and shape definitions for efficient storage or transmission. Concrete use cases include persisting profiling data to disk or sending it over a network.",
      "description_length": 345,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Set.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into sets of globally unique probe identifiers. Works with `Core_profiler.Probe_id.Set.t` values, parsing them from `Sexplib0.Sexp.t` input. Useful for deserializing stored probe data or configuration files containing probe IDs.",
      "description_length": 251,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_group.Unpacked",
      "library": "core_profiler",
      "description": "This module defines the structure and serialization for a new group header in a profiling protocol. It includes functions to convert the structure to and from S-expressions, calculate its byte size, and write it to an I/O buffer. The module works with fixed-size records containing metadata like message length, type, probe ID, probe type, and name, used for efficient binary serialization in profiling data streams.",
      "description_length": 416,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Map.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for maps keyed by `Core_profiler.Probe_id.t`, preserving their structure and values. It provides functions to compute binary size, read and write map data, and define bin_io type representations. Use this when persisting or transmitting probe data efficiently across systems or storage.",
      "description_length": 350,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Set.Elt",
      "library": "core_profiler",
      "description": "This module represents individual elements of a set of globally unique probe identifiers used for profiling. It supports serialization to and from S-expressions and binary formats, along with comparison operations. It is used to manage and manipulate probe IDs in profiling data structures and persisted output.",
      "description_length": 311,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Epoch.Unpacked",
      "library": "core_profiler",
      "description": "This module defines operations for unpacking and packing profiler epoch data, including serialization to and from S-expressions, byte counting, and writing to Iobuf buffers. It works with the `t` record type containing message length, message type, and profiler epoch data. It is used for efficiently handling binary protocol headers in profiling data streams.",
      "description_length": 360,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Map.Provide_of_sexp",
      "library": "core_profiler",
      "description": "Converts S-expressions into maps keyed by globally unique profiler identifiers, using a provided function to parse values. Works with `Core_profiler.Probe_id.Map.t` structures where keys are profiler IDs and values are arbitrary. Useful for deserializing profiler data from external representations, such as configuration files or network messages, into structured maps for runtime use.",
      "description_length": 386,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors.Packed",
      "library": "core_profiler",
      "description": "This module provides comparison, ordering, and validation operations for a polymorphic packed message type, supporting structured data workflows with maps, sets, and hash tables that use custom comparators. It includes core functions like equality checks, clamping, min/max computation, and hash and sexp conversion for efficient serialization and key-based lookups. Child modules extend this functionality with hash sets for membership tracking, hash tables for keyed data association, and specialized comparison logic, while also supporting map and set transformations with serialization, diff tracking, and binary handling. Example uses include validating message bounds, aggregating structured errors, synchronizing state changes, and serializing protocol data for transmission or storage.",
      "description_length": 793,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Map.Provide_hash",
      "library": "core_profiler",
      "description": "This module provides a function for folding over the hash state of values in a map where keys are globally unique identifiers assigned to profiling entities like timers or probes. It works with maps that bind these identifiers to arbitrary values and supports computing hash states over the map's contents. A concrete use case is enabling efficient, deterministic hashing of profiling data structures for comparison or serialization.",
      "description_length": 433,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Table.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for tables keyed by Core_profiler.Probe_id, mapping to values of a generic type. It provides functions to compute binary size, read and write table data in binary format, and define bin_io type representations for tables. Concrete use cases include persisting profiling data to disk or transmitting it over a network in a compact, efficient format.",
      "description_length": 412,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Table.Provide_of_sexp",
      "library": "core_profiler",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into tables mapping `Probe_id` keys to values. It operates on `Core_profiler.Probe_id.Table.t` data structures, using a provided function to convert the S-expression values. A concrete use case is parsing serialized profiling data from files or network streams into structured tables for analysis.",
      "description_length": 373,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Set.Provide_bin_io",
      "library": "core_profiler",
      "description": "This module implements binary serialization and deserialization for sets of globally unique timer and probe identifiers. It provides functions to compute binary size, read and write set values, and define binary shape and type representations. Concrete use cases include persisting profiling data to disk or transmitting it over a network in a compact, efficient binary format.",
      "description_length": 377,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Online.Timer.Group",
      "library": "core_profiler",
      "description": "This module organizes multiple probes or timers into groups to track timing and metric changes between specific points within the group. It allows defining relationships between probes using source arrays to capture transitions, enabling detailed path-based performance analysis. Use it to measure intervals and deltas between related events in a control flow, such as stages in a pipeline or function calls in a loop.",
      "description_length": 418,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Protocol.Writer.Unsafe_internals",
      "library": "core_profiler",
      "description": "This module provides low-level functions to manipulate internal buffer state during profiling header construction. It works directly with global buffer variables to inject specific markers like epoch and end-of-header signals. These operations are used to simulate header parsing scenarios for testing the Reader module's behavior under controlled conditions.",
      "description_length": 359,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Offline.Timer.Group",
      "library": "core_profiler",
      "description": "This module organizes multiple timers into groups to measure time differences and paths between them, enabling precise analysis of execution flow and performance metrics. It works with timer probes, allowing the definition of source relationships to track transitions between specific points in code. Use it to analyze timing between key stages in a pipeline or to isolate performance characteristics of specific code sections during offline profiling.",
      "description_length": 452,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Map.Key",
      "library": "core_profiler",
      "description": "This module defines a key type for maps based on globally unique identifiers assigned to timers, probes, and groups in the profiler system. It provides comparison, serialization, and binary (de)serialization functions for these keys. It is used to efficiently store and retrieve profiler metadata in structured formats like binary protocol and S-expressions.",
      "description_length": 358,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Map.Diff",
      "library": "core_profiler",
      "description": "This module represents differences between maps keyed by globally unique timer or probe identifiers, supporting operations to compute, apply, and serialize diffs. It works with map-like structures where keys are based on `Core_profiler.Probe_id` and values are tracked with diffable types. Concrete use cases include capturing and applying incremental changes to profiling data over time, such as tracking performance metrics across different execution phases.",
      "description_length": 460,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_single.Unpacked",
      "library": "core_profiler",
      "description": "This module defines the structure and serialization for a profiler header protocol, specifically handling message length, type, probe ID, specification, and name. It provides functions to convert values to and from S-expressions, calculate byte size, and write data to an Iobuf. Useful for serializing and transmitting profiler metadata efficiently.",
      "description_length": 349,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Online.Probe.Group",
      "library": "core_profiler",
      "description": "This module organizes multiple probes into groups to measure and track relationships between them, such as time deltas or metric changes along specified paths. It works with `Probe` and `t` (group) types, enabling structured performance analysis by defining source dependencies between probes. Concrete use cases include tracking execution flow between distinct stages in a pipeline or correlating metric changes across related events within a group.",
      "description_length": 450,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Protocol.Buffer.Unsafe_internals",
      "library": "core_profiler",
      "description": "Resets the internal state of the buffer, ensuring it is empty and ready for new data. Works directly with the Iobuf.t structure to manage buffer allocation and space verification. Useful for reinitializing the buffer before generating or testing new reader scenarios.",
      "description_length": 267,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Probe_id.Set.Diff",
      "library": "core_profiler",
      "description": "This module represents differences between sets of globally unique timer and probe identifiers, supporting operations to compute, apply, and serialize these differences. It works with `Core_profiler.Probe_id.Set.Elt.t` values within a set difference structure, enabling precise tracking of added or removed identifiers between profiling states. Concrete use cases include capturing changes in active probes or timers across profiling intervals and synchronizing profiling state between distributed nodes.",
      "description_length": 504,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Set.Provide_hash",
      "library": "core_profiler",
      "description": "This module hashes sets of globally unique timer and probe identifiers. It provides `hash_fold_t` and `hash` functions to compute hash values for `Core_profiler.Probe_id.Set.t` structures. Use this module when needing to efficiently hash collections of profiling IDs for comparison or storage in hash tables.",
      "description_length": 308,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Hash_queue",
      "library": "core_profiler",
      "description": "This module enables managing a hash queue data structure that combines associative key-value pairs with ordered queue semantics, supporting operations like insertion/removal at both ends, key-based lookups, and ordered traversal. It works with key-value collections where keys are globally unique identifiers, maintaining insertion order while allowing efficient reordering and bulk transformations. Such functionality is useful in profiling systems to track and process ordered event streams with unique identifiers, enabling tasks like prioritizing recent data points or serializing event sequences.",
      "description_length": 601,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Offline.Probe",
      "library": "core_profiler",
      "description": "A probe records integer values with timestamps for offline profiling, enabling analysis of performance metrics like memory usage or operation counts over time. Groups of probes track relationships between metrics, measuring transitions and timing between events such as pipeline stages or function calls. The core operations include creating and updating probes, grouping them for coordinated analysis, and extracting timestamped data for external processing. For example, you can track memory usage at key function exits or analyze timing between request handling stages.",
      "description_length": 572,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_group_point",
      "library": "core_profiler",
      "description": "This module handles structured binary data for profiling group points, offering direct manipulation of metadata like group and probe IDs through field accessors. It serializes and deserializes data using `Iobuf.t` for efficiency, with support for S-expression conversions for analysis. Child modules extend this with custom types such as `t` and `t_sources`, enabling efficient encoding and transmission of profiling messages. Together, they facilitate hierarchical timing data management and probe configuration cross-referencing in performance-critical systems.",
      "description_length": 563,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Message_type_and_errors",
      "library": "core_profiler",
      "description": "This module defines a polymorphic variant type for message types and errors in a binary protocol, with conversions to wire format and dense integer indices. It supports precise parsing and serialization through variants like `New_single`, `New_group`, and `End_of_header`, along with structured error handling. The child module adds comparison, ordering, and validation operations, enabling efficient use of maps, sets, and hash tables with custom comparators. Together, they support tasks like message validation, error aggregation, and protocol data serialization with index-based lookups and diff tracking.",
      "description_length": 609,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Online.Timer",
      "library": "core_profiler",
      "description": "A timer captures timestamps for performance tracking, either individually or as part of a group that defines relationships between events. It supports creating and managing timer objects to record execution times and sample performance data at key points in application logic. Groups organize multiple timers to measure intervals and transitions, such as stages in a pipeline or repeated function calls. This enables detailed analysis of timing deltas and control flow paths.",
      "description_length": 475,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Set",
      "library": "core_profiler",
      "description": "This module manages sets of globally unique probe identifiers with operations for creation, transformation, and comparison, including union, intersection, and mapping. It supports efficient set abstractions, serialization to S-expressions and binary formats, and property-based testing, making it suitable for tracking and aggregating profiling data across systems. Child modules handle parsing from S-expressions, binary serialization, set differencing, and hashing, enabling workflows such as persisting probe sets, synchronizing profiling state, and comparing identifier collections. Specific uses include deserializing configuration files, transmitting profiling data over networks, and capturing changes in active probes between runs.",
      "description_length": 739,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Online.Delta_timer",
      "library": "core_profiler",
      "description": "This module tracks time deltas between paired start and stop calls using optimized probe groups, with support for synchronous function wrapping to measure execution duration. It operates on timing states represented by `Core.Time_ns.t` and provides both stateful and stateless interfaces for starting and stopping measurements. Concrete use cases include profiling synchronous function calls, measuring latency of critical code sections, and tracking time intervals in performance-sensitive applications.",
      "description_length": 504,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Protocol.Short_header",
      "library": "core_profiler",
      "description": "This module encodes a `Probe_id.t` and a `Time_ns.t` into a single 63-bit integer, using 9 bits for the probe ID and 54 bits for time relative to a profiler epoch. It provides functions to pack and unpack these values, along with constants defining bit allocations and limits. It is used to efficiently serialize timer records into a compact, aligned format for writing to disk or memory.",
      "description_length": 388,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Hash_set",
      "library": "core_profiler",
      "description": "This module manages sets of profiler probe IDs with efficient insertion, membership checks, and conversion to and from lists and S-expressions. It supports direct manipulation of hash sets and integrates serialization through child modules for S-expression and binary encoding. The S-expression module converts structured data into hash sets for loading stored probe information, while the binary module enables compact serialization for storage or network transmission. Example uses include tracking active probes during profiling and persisting their state for later analysis.",
      "description_length": 578,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.R",
      "library": "core_profiler",
      "description": "This module defines a polymorphic type `t` for representing versioned messages with a header and payload. It includes a function to convert values of this type to S-expressions using a provided conversion function for the payload. This supports serialization of structured messages with versioning information for logging or communication protocols.",
      "description_length": 349,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.End_of_header",
      "library": "core_profiler",
      "description": "This module provides tools to serialize, deserialize, and manipulate end-of-header messages in a binary protocol, using `Iobuf` and `Sexp` for efficient buffer and structured data handling. It centers around the `t` type, representing a message with length and type, and supports reading and writing fixed-format header signals during network communication. The child module defines the message structure, conversion to and from S-expressions, size computation, and buffer writing, enabling concrete use cases like constructing and parsing end-of-header signals. Together, they facilitate seamless conversion between structured data and packed binary representations for header termination handling.",
      "description_length": 699,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Offline.Timer",
      "library": "core_profiler",
      "description": "This module manages time-stamped events for offline profiling, using integer-based timers and probes to record execution times and measure durations of code sections. It organizes timers into groups, enabling analysis of time differences and execution paths between key stages in a pipeline. You can define source relationships between probes to track transitions and isolate performance bottlenecks. The generated data supports detailed performance analysis using the profiler.dat file.",
      "description_length": 487,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_group",
      "library": "core_profiler",
      "description": "This module provides precise manipulation of structured binary messages with probe identifiers, specifications, and fixed-length strings using Iobuf for memory control. It supports serialization, deserialization, null-terminated string encoding, sub-buffer management, and S-expression conversion, enabling efficient field-level access and deterministic serialization for profiling or network protocols. The child module defines a fixed-size group header with functions to serialize to I/O buffers, compute size, and convert to S-expressions, including metadata like message length, probe ID, and type. Together, they allow constructing, modifying, and transmitting binary protocol messages with structured headers and embedded string data.",
      "description_length": 740,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Offline.Delta_probe",
      "library": "core_profiler",
      "description": "Tracks changes in counter values using start/stop pairs to record deltas, optimized for performance. Works with integers and a state type to manage measurement intervals. Useful for profiling code sections where precise counter differences are needed, such as measuring memory usage or event counts in async workflows.",
      "description_length": 318,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Replace_polymorphic_compare",
      "library": "core_profiler",
      "description": "This module replaces polymorphic comparison operators for `Core_profiler.Probe_id.t` with efficient, type-specific comparisons. It ensures correct ordering and equality checks for probe IDs, which are globally unique identifiers used in profiling. This enables reliable sorting, min/max calculations, and comparisons in performance-critical contexts.",
      "description_length": 350,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Offline.Delta_timer",
      "library": "core_profiler",
      "description": "Tracks time differences between paired start and stop events using high-resolution timestamps, optimized for low overhead. It works with functions of various arities, allowing timing of synchronous operations without manual start/stop calls. Use to measure execution duration of specific code sections or functions for performance analysis in offline profiling scenarios.",
      "description_length": 371,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.New_single",
      "library": "core_profiler",
      "description": "This module handles the serialization and manipulation of profiler message headers, offering direct access to fields like IDs, names, and metadata through structured I/O operations. It supports conversion between binary and S-expression formats, with efficient packing and unpacking of header components for performance analysis and data transmission. Child modules define the header protocol structure, including message length, type, and probe details, while providing utilities for size calculation and Iobuf writing. Example uses include parsing binary profiler headers, constructing structured messages for transmission, and converting header data between packed and unpacked forms for efficient memory use.",
      "description_length": 712,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Protocol.Writer",
      "library": "core_profiler",
      "description": "This module writes profiling data into global buffers by invoking header and short message protocols, using profiler epochs, timestamps, and probe identifiers to record events such as timers, probes, and group resets. Its child module provides low-level buffer manipulation functions to inject markers like epoch and end-of-header signals, enabling controlled testing of header parsing logic. Main data types include buffer references, epochs, and event metadata, with operations for logging, buffer injection, and header simulation. Example uses include capturing performance metrics during execution and simulating header parsing scenarios for testing.",
      "description_length": 654,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Protocol.Buffer",
      "library": "core_profiler",
      "description": "This module manages buffer allocation and space management for Iobuf.t, ensuring sufficient capacity during writes while providing operations to retrieve header chunks, check buffer status, and collect written chunks. It includes functionality to reset the buffer's internal state, making it empty and ready for new data, which is useful for reinitializing buffers before new I/O operations or test scenarios. Key data types include Iobuf.t, and core operations involve dynamic buffer growth, chunk assembly, and status verification. Example uses include efficiently handling network packet assembly or streaming file writes where buffer capacity must adapt to varying data sizes.",
      "description_length": 680,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Map",
      "library": "core_profiler",
      "description": "This module organizes maps keyed by globally unique identifiers for profiling entities like timers and probes, combining core operations for creation, transformation, and comparison with specialized submodules for serialization, parsing, hashing, and differencing. Main data types include maps binding unique keys to arbitrary values, along with key representations, hash states, and map diffs. You can create maps from lists or sequences, remap keys with conflict resolution, fold over hash states, compute and apply map differences, and serialize or deserialize maps to binary or S-expression formats. These capabilities support profiling systems that require structured, persistent, and efficient handling of dynamic performance data.",
      "description_length": 737,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id.Table",
      "library": "core_profiler",
      "description": "This module manages hash tables mapping globally unique identifiers to arbitrary data, with operations to construct tables from key-value lists, handle duplicates, and group entries using combination functions. It supports serialization through binary protocols and S-expressions, enabling efficient persistence and transmission of profiling metadata such as timer configurations and probe states. The binary module provides functions to serialize and deserialize tables, compute binary size, and define bin_io representations, facilitating compact data storage and network transfer. The S-expression module enables parsing tables from structured text, using a conversion function for values, useful for loading profiling data from files or streams.",
      "description_length": 749,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol.Epoch",
      "library": "core_profiler",
      "description": "This module manages profiler epoch data in both binary and structured formats, offering direct access to serialization, deserialization, and manipulation through Iobuf. It centers around the `t` record, which holds message length, type, and epoch data, and supports operations like reading and writing to buffers, converting to S-expressions, and calculating byte sizes. Submodule functionality extends this by handling packing and unpacking logic, essential for processing binary protocol headers in profiling streams. Use cases include saving profiler state to disk, sending profiling data over the network, and inspecting metadata programmatically.",
      "description_length": 651,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Online.Delta_probe",
      "library": "core_profiler",
      "description": "This module tracks changes in integer counters using start/stop pairs, computing and recording the delta between calls. It supports both synchronous and asynchronous usage through stateless start/stop operations, allowing integration with async workflows without direct dependency on Async. Concrete use cases include measuring throughput, latency, or resource usage (e.g., memory allocation) over intervals in real-time systems.",
      "description_length": 429,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Online.Profiler",
      "library": "core_profiler",
      "description": "This module tracks performance metrics in real time and prints them to stdout at configurable intervals. It provides functions to record time deltas, manage metric groups, and control when metrics are output, including the ability to trigger manual dumps. It works directly with timers, probes, and performance counters, making it suitable for monitoring latency, throughput, and other runtime characteristics in production services.",
      "description_length": 433,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Header_protocol.Unpacked",
      "library": "core_profiler",
      "description": "This module defines a variant type for unpacked profiler header messages, including single entries, groups, group points, end-of-header markers, and epochs. It provides functions to serialize and deserialize these messages, determine their byte size, identify their message type, and write them to a buffer. It is used to process and emit structured profiler data during runtime.",
      "description_length": 379,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Online.Probe",
      "library": "core_profiler",
      "description": "A probe records integer values with timestamps, enabling real-time tracking of metrics like counters or gauges. It supports creating individual probes and organizing them into groups to analyze relationships, such as time deltas or metric changes across related events. Operations include `create` for instantiating probes and `record` for logging samples, with group-level analysis enabling structured performance tracing between stages in a pipeline. This allows monitoring system load, request rates, or queue sizes while correlating changes across multiple probes.",
      "description_length": 568,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Offline.Profiler",
      "library": "core_profiler",
      "description": "This module controls offline profiling behavior, enabling programmatic configuration of output files, timing intervals, and performance optimizations. It works with time stamps, profiling metrics, and system resource counters. Use it to fine-tune profiling accuracy, pre-allocate resources during idle periods, and manually control when profiling data is output.",
      "description_length": 362,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_id",
      "library": "core_profiler",
      "description": "Globally unique integer identifiers for profiler probes are generated, compared, hashed, and serialized, with support for maps, sets, hash tables, and queues to organize and track probe instances efficiently. The module enables operations like creating identifier sets from lists, serializing them to S-expressions or binary formats, and computing differences between map states for persistent profiling workflows. Hash queues maintain ordered event streams with unique keys, while specialized comparison functions ensure efficient sorting and equality checks critical for performance analysis. Use cases include tracking active probes, persisting profiling state, and synchronizing identifier collections across distributed systems.",
      "description_length": 733,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Profiler_epoch",
      "library": "core_profiler",
      "description": "This module defines a custom time epoch representation for storing timestamps relative to an arbitrary point in time, primarily used for efficient serialization and deserialization of time data in performance metrics. It supports conversion to and from `Time_ns`, integer, and S-expressions, as well as arithmetic operations for adding and computing time offsets. Concrete use cases include compressing time data in binary protocols and profiling logs where space efficiency is critical.",
      "description_length": 487,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Std_offline",
      "library": "core_profiler",
      "description": "This module enables the definition and management of performance probes in applications, allowing developers to collect timing and execution data without requiring runtime dependencies on profiling libraries. It works with probe configurations and sampled data, supporting operations to start, stop, and report on profiling sessions. Concrete use cases include instrumenting critical code paths for performance analysis and generating profiling reports for offline review.",
      "description_length": 472,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Probe_type",
      "library": "core_profiler",
      "description": "This module defines a type `t` that represents different kinds of profiling measurements, including timers and value probes with associated units. It provides functions to convert between the type and S-expressions, compare values, and convert to strings or characters, along with helpers to check if a value is a probe and to extract its units. It is used to classify and handle profiling data in a structured way during performance analysis.",
      "description_length": 443,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Protocol",
      "library": "core_profiler",
      "description": "This module configures and serializes profiling data, managing output paths, file naming, and structured data writing to capture performance metrics during execution. It coordinates with submodules that encode time and probe identifiers into compact integers, write events into global buffers with epoch and timestamp tracking, and manage dynamic buffer allocation for efficient data serialization. Key data types include `Probe_id.t`, `Time_ns.t`, Iobuf.t, and buffer references, with operations for packing timestamps, logging events, buffer injection, and dynamic resizing. Example uses include capturing timer events, simulating header parsing, and streaming profiling data to disk or network with adaptive buffer handling.",
      "description_length": 727,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Check_environment",
      "library": "core_profiler",
      "description": "This module checks the environment for specific variables and ensures safe execution contexts. It provides `get_var` to retrieve environment variable values and `check_safety_exn` to validate the environment setup, raising an exception if unsafe. Useful for verifying deployment configurations or enforcing runtime constraints in production systems.",
      "description_length": 349,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Fstats",
      "library": "core_profiler",
      "description": "This module tracks statistical metrics such as mean, variance, and standard deviation over a sequence of floating-point values. It supports operations to update values in place, retrieve aggregate statistics, and create copies of the current state. Concrete use cases include performance profiling and real-time data analysis where incremental statistical computation is required.",
      "description_length": 380,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler.Std_online",
      "library": "core_profiler",
      "description": "This module supports real-time profiling with operations to start, stop, and collect performance metrics from running applications. It works with timing data and event streams to capture and analyze execution behavior. Concrete use cases include monitoring function call latencies and throughput in production services.",
      "description_length": 319,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Header_protocol",
      "library": "core_profiler",
      "description": "This module enables parsing and construction of profiler header messages from Iobufs, handling message types like `New_single`, `New_group`, and `Epoch` with type-safe validation. It operates on data types such as `t` and `t_no_exn`, supporting serialization, deserialization, and S-expression conversion for structured binary data used in profiling. Child modules handle specific message formats, including group metadata, probe IDs, versioned payloads, and end-of-header signals, with direct Iobuf manipulation for efficiency. Examples include extracting message types, validating header structure, converting between packed and unpacked forms, and managing hierarchical timing data in performance-critical systems.",
      "description_length": 717,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Offline",
      "library": "core_profiler",
      "description": "This module enables offline profiling by capturing timestamped metrics such as counters, durations, and event transitions, which are written to a data file for post-execution analysis. It provides probes for tracking integer values over time, timers for measuring code section durations, and control functions for managing profiling output and resource allocation. You can use it to analyze performance trends like memory usage between function calls, timing bottlenecks in pipelines, or counter deltas in asynchronous workflows. High-resolution timing and low-overhead measurement ensure accurate performance insights without disrupting program execution.",
      "description_length": 656,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Online",
      "library": "core_profiler",
      "description": "This module enables real-time performance tracking by capturing time deltas, counter changes, and timestamped metric samples. It provides timers, probes, and delta tracking structures that can be organized into groups for structured analysis of execution intervals, throughput, and latency. Operations include synchronous and asynchronous measurement, function wrapping for duration tracking, and manual or interval-based metric output to stdout. Example use cases include profiling pipeline stages, measuring function call latency, and monitoring system load or resource usage in production services.",
      "description_length": 601,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler.Common",
      "library": "core_profiler",
      "description": "This module manages time measurements and periodic tasks for profiling, supporting both online and offline profilers. It provides functions to retrieve timestamps with `now`, add slow background tasks with `add_slow_task`, and conditionally execute those tasks with `maybe_do_slow_tasks`. Use cases include tracking performance metrics in real-time and scheduling low-frequency maintenance operations during profiling sessions.",
      "description_length": 427,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler",
      "library": "core_profiler",
      "description": "This module assigns globally unique integer identifiers to profiler probes, enabling efficient tracking, comparison, and serialization of probe instances using maps, sets, and hash tables. It supports operations such as creating identifier sets from lists, serializing them to S-expressions or binary formats, and computing differences between map states for persistent profiling workflows. Hash queues maintain ordered event streams with unique keys, and specialized comparison functions ensure efficient sorting and equality checks for performance analysis. Use cases include tracking active probes, persisting profiling state, and synchronizing identifier collections across distributed systems.",
      "description_length": 698,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Timer.Group",
      "library": "core_profiler.disabled",
      "description": "This module organizes multiple timers into groups to track and measure time or metric changes between specific points (probes) within the group. It allows defining relationships between probes, enabling the calculation of intervals or deltas along specified paths in the timeline. Use this when analyzing performance across distinct stages in a workflow, such as request handling phases in a server or steps in a batch process.",
      "description_length": 427,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Probe.Group",
      "library": "core_profiler.disabled",
      "description": "This module organizes multiple probes into a group to measure time or metric differences between them, enabling path-based analysis in profiling data. It works with probes and arrays of probes to define relationships and track transitions. Use it when analyzing execution paths across related events, such as tracking latency between stages in a pipeline or metric changes across function calls.",
      "description_length": 395,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Probe-Group",
      "library": "core_profiler.disabled",
      "description": "This module organizes multiple probes or timers into groups to measure statistics between them, such as the time or metric change between probes. It supports defining relationships between probes using source lists, enabling path-based analysis of performance data. Use it when tracking transitions between events, like request start and end points, or changes in system state over time.",
      "description_length": 387,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Timer",
      "library": "core_profiler.disabled",
      "description": "This module manages time-stamped events with a lightweight `t` type representing a timer or probe, enabling timestamp recording and basic timing operations with minimal overhead. It supports use cases such as stubbing timing logic in production or measuring code performance during development without requiring full profiling. Its child module organizes multiple timers into groups, allowing definition of probe relationships and calculation of time deltas along specified paths, useful for analyzing performance across distinct workflow stages like server request phases or batch processing steps. Together, they provide both low-level timestamping and structured timing analysis within non-profiling contexts.",
      "description_length": 712,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Profiler",
      "library": "core_profiler.disabled",
      "description": "This module provides functions to manage and interact with a performance profiler, including enabling/disabling profiling, configuring output settings, precomputing expensive operations, and manually dumping statistics. It works with time intervals, counters, and profiling metadata to track and report performance metrics. Concrete use cases include optimizing critical code sections by analyzing time deltas, monitoring resource usage in long-running applications, and integrating profiling into test suites for performance regression detection.",
      "description_length": 547,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Probe",
      "library": "core_profiler.disabled",
      "description": "A Probe tracks integer values with timestamps, primarily for profiling performance metrics like latency or throughput. It supports grouping probes through its Group submodule, which organizes multiple probes to measure time or metric differences between events. The `t` type represents individual probes, while arrays of probes enable path-based analysis, such as tracking transitions between stages in a pipeline. Use Probe to record metrics in specific code sections and Group to analyze relationships and sequences across those metrics.",
      "description_length": 539,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf",
      "library": "core_profiler.disabled",
      "description": "This module defines the interface for profiling operations including starting and stopping timers, creating probes to collect metrics, and managing in-process or offline data aggregation. It works with timestamps, integer-based metrics, and internal buffers for statistical calculations like mean and standard deviation. Concrete use cases include measuring execution intervals with `Timer`, tracking application-specific quantities like heap size with `Probe`, and analyzing performance trends either in real-time via stdout or post-mortem from disk.",
      "description_length": 551,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Timer-Group",
      "library": "core_profiler.disabled",
      "description": "This module organizes multiple timers into groups, enabling the measurement of time intervals and metric changes between probes within the group. It supports defining relationships between probes using source lists to track transitions, and allows resetting group state to manage cycles or isolate specific instrumentation scopes. Use this when analyzing timing paths or dependencies between events, such as tracking request phases in a server or stages in a pipeline.",
      "description_length": 468,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Delta_timer",
      "library": "core_profiler.disabled",
      "description": "This module provides high-performance timing operations to measure time differences between explicit start and stop calls, as well as pausing and resuming measurements. It works with a minimal `t` type representing a timer instance and a `state` type for stateless timing control. Concrete use cases include profiling specific code sections, measuring execution duration of functions with wrap utilities, and tracking performance metrics in low-overhead scenarios.",
      "description_length": 464,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Probe-Group",
      "library": "core_profiler.disabled",
      "description": "This module organizes multiple probes or timers into groups to measure statistics between their occurrences, such as time intervals or metric changes. It allows defining relationships between probes using source arrays to track specific transitions, and supports resetting the group to manage state in complex, cyclic scenarios. Use it to analyze performance paths within functions, like tracking request phases or resource usage changes over time.",
      "description_length": 448,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled.Delta_probe",
      "library": "core_profiler.disabled",
      "description": "This module provides lightweight start, stop, and pause operations to track changes in integer counters, optimized for minimal overhead. It works with a private unit type and a state type to manage delta measurements. Use cases include profiling performance metrics in low-level code where precise timing or resource usage deltas are needed, such as tracking memory consumption or execution time between two points in a computation.",
      "description_length": 432,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Timer",
      "library": "core_profiler.disabled",
      "description": "This module provides operations to create and record timestamped events with no associated metric, optimized for efficiency over general probes. It works with timer objects that capture the current time when a sample is recorded, storing the data in-memory for later analysis. Concrete use cases include tracking the timing of specific code execution points, such as function entry/exit or event triggers, especially when detailed statistical analysis is deferred to post-processing.",
      "description_length": 483,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Profiler",
      "library": "core_profiler.disabled",
      "description": "This module defines an interface for profiling with support for probes and timers to collect metrics and timestamps during program execution. It works with integer-based metrics and time-stamped events, enabling detailed performance analysis either in-process or from offline data files. Concrete use cases include tracking heap allocations, measuring event intervals, and generating periodic or on-demand performance reports without modifying core logic.",
      "description_length": 455,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Delta_probe",
      "library": "core_profiler.disabled",
      "description": "This module provides operations to track changes in integer counters using pairs of probes for start and stop events, optimized for efficiency. It works with integer values and state tokens to manage asynchronous profiling without side effects. Use it to measure deltas in metrics like queue lengths or memory usage across async operations in non-blocking applications.",
      "description_length": 369,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Delta_timer",
      "library": "core_profiler.disabled",
      "description": "This module provides functions to measure time intervals using start and stop actions, optimized for tracking deltas between timestamps. It works with internal state representations to manage timing operations efficiently. Use cases include profiling function execution times, measuring latency in critical sections, and capturing timing metrics for performance analysis without associating numeric values.",
      "description_length": 406,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Probe",
      "library": "core_profiler.disabled",
      "description": "This module defines probes for collecting time-stamped integer metrics or timestamps during program execution. It supports creating standalone probes and recording data samples, with optional grouping via the `Group` submodule. Concrete use cases include tracking application-specific quantities like list lengths or heap allocations, or measuring event timings using lightweight timers.",
      "description_length": 387,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf.Profiler_intf-Probe",
      "library": "core_profiler.disabled",
      "description": "This module defines probes for recording integer metrics along with timestamps, supporting both standalone and grouped usage. It provides functions to create probes, record data samples, and organize probes into groups for structured metric collection. Concrete use cases include tracking application-specific quantities like list lengths or memory allocations at specific points in program execution.",
      "description_length": 401,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Profiler_units",
      "library": "core_profiler.disabled",
      "description": "This module defines types and operations for handling measurement units used in profiling output formatting. It supports conversions between unit types, string representations, and formatting integers according to specific units. Concrete use cases include displaying profiler results in seconds, nanoseconds, words, or integers with appropriate formatting.",
      "description_length": 357,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Intf",
      "library": "core_profiler.disabled",
      "description": "This module defines an interface for performance profiling using time-stamped integer metrics (probes) and timestamp-only events (timers), with implementations that either discard data, maintain statistics in-process, or buffer for offline analysis. It organizes probes and timers into groups to measure transitions, track intervals, and analyze metric changes between events, supporting structured instrumentation of code paths and resource usage. You can use it to measure execution frequency, track heap allocations, capture request phases in servers, or analyze timing and metric deltas across async operations. Specific operations include creating and recording probes, starting and stopping timers, defining probe relationships, and managing group state for scoped or cyclic instrumentation.",
      "description_length": 797,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled.Disabled",
      "library": "core_profiler.disabled",
      "description": "This module enables efficient performance measurement and profiling through lightweight timers, counters, and probes that introduce minimal runtime overhead. It supports timestamped event tracking, time delta calculation, and structured analysis of performance metrics across different stages of execution. Use it to measure function durations, track counter changes, or analyze timing relationships in code paths, with options to group and organize metrics for deeper insight. Examples include profiling server request phases, monitoring resource usage, or detecting performance regressions in test suites.",
      "description_length": 607,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_disabled",
      "library": "core_profiler.disabled",
      "description": "This module provides performance profiling capabilities through time-stamped metrics and events, enabling structured instrumentation of code for analysis of execution timing, resource usage, and metric changes. It supports key data types such as probes for tracking integer metrics, timers for measuring intervals, and groups for organizing related measurements, with operations to record values, start/stop intervals, and manage scoped instrumentation. You can use it to measure function execution times, track heap allocations, analyze async operation phases, or monitor performance regressions in test runs. The module includes implementations for discarding, aggregating, or buffering data, allowing flexible integration based on profiling needs.",
      "description_length": 750,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set.Diff",
      "library": "core_profiler.offline_tool",
      "description": "Works with set differences of raw interest elements, supporting operations to compute, apply, and serialize diffs between sets of `Interest.Raw.I.Set.Elt.t`. Provides functions to derive diffs between two sets, apply a diff to a set to produce a new set, and serialize/deserialize diffs. Useful for tracking incremental changes between versions of raw interest sets in event generation workflows.",
      "description_length": 396,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "Converts S-expressions into sets of raw interests, specifically interpreting the input as a list of elements and constructing a set from them. Works directly with `Sexplib0.Sexp.t` inputs and produces values of type `Core_profiler_offline_tool.Interest.Raw.I.Set.t`. Useful when loading raw interest configurations from files or other serialized sources during profiler setup.",
      "description_length": 376,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for maps with keys of type `Key` and values of type `Core_profiler_offline_tool.Interest.Raw.I.Map.t`. It provides functions to compute binary shape, size, and to read and write values in binary format, enabling efficient storage and transmission of map data. Concrete use cases include persisting profiling data to disk or transferring it across networked systems.",
      "description_length": 429,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map.Key",
      "library": "core_profiler.offline_tool",
      "description": "This module defines a key type for maps keyed by raw profiler interests, providing serialization to and from S-expressions and a comparator for ordering. It works with `Core_profiler_offline_tool.Interest.Raw.I.t` values, enabling structured storage and retrieval of profiler event data. Concrete use cases include organizing event data by raw interest keys during offline profiling analysis.",
      "description_length": 392,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set.Elt",
      "library": "core_profiler.offline_tool",
      "description": "This module represents individual elements within a set of raw profiler interests, providing serialization and deserialization via S-expressions. It supports comparison operations using a comparator derived from the underlying raw interest type. It is used to process and manage distinct raw event-generating interests in profiling workflows, such as filtering and event matching.",
      "description_length": 380,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `hash_fold_t` that computes a hash for a map of raw interest data, combining the hash state with each value in the map. It operates on maps where values have a generic type `'a` and keys are determined by the `Key` module parameter. A concrete use case is generating consistent hash signatures for raw interest maps to detect changes or enable equality checks based on content rather than identity.",
      "description_length": 430,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Hash_set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module parses S-expressions into hash sets of raw interests, specifically converting input data into a collection of `Core_profiler_offline_tool.Interest.Raw.I.Hash_set.t` values. It operates directly on S-expressions and is used when loading pre-defined sets of raw interests from serialized configurations or input files. A typical use case involves initializing event generation with predefined interest sets for profiling analysis.",
      "description_length": 440,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module provides binary serialization and deserialization functions for sets of raw profiler interests. It works with the `Core_profiler_offline_tool.Interest.Raw.I.Set.t` type, enabling efficient storage and retrieval of interest set data. Concrete use cases include persisting interest sets to disk or transmitting them across a network for offline profiling analysis.",
      "description_length": 374,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map.Diff",
      "library": "core_profiler.offline_tool",
      "description": "This module represents differences between maps of raw profiler interests, supporting operations to serialize and deserialize these differences, retrieve specific changes, apply diffs to base values, and construct diffs from lists. It works with structured data types involving keys (`'a`) and their associated diff types (`'a_diff`), typically representing profiler event intervals or metadata. Concrete use cases include analyzing changes in profiler interest maps across different runs or states, enabling efficient storage and comparison of incremental updates.",
      "description_length": 565,
      "index": 114,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Table.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that constructs a table from S-expression data, using a provided function to parse values. It operates on tables indexed by a `Key` type and supports deserializing structured profiling data stored in S-expressions. This is useful for loading raw interest mappings from disk or configuration in a format compatible with offline profiling tools.",
      "description_length": 387,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Hash_set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module provides binary serialization and deserialization functions for hash sets of raw interest values. It supports operations like computing binary size, reading and writing values in binary format, and defining type-specific readers and writers. These functions enable efficient storage and transmission of hash sets containing raw interest data structures.",
      "description_length": 365,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into maps with keys of type `Key.t` and values of a specified type, using a provided deserialization function for the value type. It operates on data structures involving `Core_profiler_offline_tool.Interest.Raw.I.Map.t`, which associate keys with raw profiler interests. A concrete use case is parsing configuration or persisted state data that maps identifiers to raw profiler interest specifications for analysis tools.",
      "description_length": 498,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module implements hash-related operations for sets of raw interests, specifically providing `hash_fold_t` and `hash` functions to compute hash values for set structures. It works directly with `Core_profiler_offline_tool.Interest.Raw.I.Set.t`, using the element type defined in the `Elt` submodule. These functions enable efficient hashing of raw interest sets, useful in scenarios like caching or fast equality checks when processing event data.",
      "description_length": 451,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Table.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module provides binary serialization and deserialization operations for tables mapping keys to values, specifically working with the `Core_profiler_offline_tool.Interest.Raw.I.Table.t` data structure. It supports efficient reading, writing, and size calculation of table data in binary format, enabling persistent storage or transmission of structured profiling data. Concrete use cases include saving and loading profiling results to/from disk or sending them over a network.",
      "description_length": 481,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map.Diff",
      "library": "core_profiler.offline_tool",
      "description": "This module computes and manipulates differences between paths, where each path consists of a start point, an optional sequence of intermediate points stored in reverse order, and an end point. It supports operations to extract, apply, and combine path diffs, ensuring correctness when merging or comparing paths that may share intermediate points. Concrete use cases include analyzing execution traces to detect deviations from expected control flow paths and merging partial path segments from profiler data.",
      "description_length": 510,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "Converts S-expressions into sets of keyed interests, where each interest is associated with a probe identifier. It supports parsing serialized data into structured sets, ensuring elements are comparable and hashable. This is used to reconstruct interest sets from stored or transmitted S-expression representations.",
      "description_length": 315,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `hash_fold_t` that computes a hash for a path map structure, combining the hash state of its elements with the map's contents. It operates on path maps where keys are constrained by the `Key` module and values follow the path structure defined in the parent module. A concrete use case is enabling efficient and deterministic hashing of structured paths for comparison or storage in profiling tools.",
      "description_length": 431,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into maps keyed by `Probe_id.t`, where values are of a type determined by the input deserializer. It works with `Sexplib0.Sexp.t` and map structures specialized over the `Probe_id.t` key type. A concrete use case is parsing profiler interest data from S-expression formatted input, such as configuration files or serialized data dumps.",
      "description_length": 411,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set.Elt",
      "library": "core_profiler.offline_tool",
      "description": "This module represents individual elements within a set of paths, where each path consists of a sequence of points with specific constraints on direct or indirect transitions. It supports serialization to and from S-expressions and provides a comparator for ordering elements based on path structure. It is used to define and compare path segments in profiling data analysis, ensuring correct matching of execution paths with start, intermediate, and end points.",
      "description_length": 462,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `hash_fold_t` for computing hash values of map structures where keys are of type `Probe_id.t` and values are of a generic type `'a`. It enables efficient hashing of maps by folding over their elements with a user-supplied hash state transformer. A concrete use case is generating consistent hash digests of interest maps for serialization or comparison in profiling tools.",
      "description_length": 404,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Hash_set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages collections of raw interest elements with operations for creation from lists, equality checks, S-expression conversion, and deserialization. It includes a submodule for parsing S-expressions into hash sets, used for initializing interest sets from configuration files, and another submodule for binary serialization, enabling efficient storage and transmission of these sets. You can use it to track and compare raw interests during profiling workflows, load predefined interest sets, or serialize them for persistence. Key operations include `of_list`, `t_of_sexp`, `bin_size_t`, and `bin_read_t`.",
      "description_length": 618,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that deserializes S-expressions into map structures, using a provided function to convert the values. It works with `Sexplib0.Sexp.t` as input and produces maps parameterized by a key type. A concrete use case is parsing configuration or event data stored in S-expression format into typed maps for further processing.",
      "description_length": 362,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Map",
      "library": "core_profiler.offline_tool",
      "description": "This module processes polymorphic maps keyed by raw profiler interests, supporting transformations, error-resilient construction from sequences or hashtables, and aggregation over ordered keys. It includes utilities for enforcing uniqueness, handling partial operations, and generating hashes or diffs for change detection and incremental updates. Submodules handle binary and S-expression serialization, comparison, and structured diffing of maps, enabling efficient storage, transmission, and analysis of profiler event data. Examples include persisting profiling data to disk, comparing map states across runs, and parsing configuration files into structured maps for analysis.",
      "description_length": 680,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module hashes sets of paths where each path consists of a sequence of points, with the first and last points explicitly marked to indicate direct or indirect transitions. It provides `hash_fold_t` and `hash` functions to compute hash values for these path sets, using a hash state from the Base module. This supports efficient comparison and storage of path sets in hash tables or other data structures requiring hash values.",
      "description_length": 430,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Table.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for a table structure that maps keys to path segments, where each path includes explicitly stored start and end points with intermediate points stored in reverse order. It supports efficient disk or network transmission of path data used for profiling, ensuring paths with indirect and direct transitions are preserved accurately. Use cases include saving and loading path-based profiler data for offline analysis.",
      "description_length": 478,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set.Provide_hash",
      "library": "core_profiler.offline_tool",
      "description": "This module provides hash folding and hashing operations for sets of interest data, enabling efficient hash-based comparisons and storage. It works with `Core_profiler_offline_tool.Interest.I.Set.t`, a set type where elements are keyed by `Probe_id.t`. Use this module when persisting or comparing interest sets in a hash table or serialization context.",
      "description_length": 353,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Replace_polymorphic_compare",
      "library": "core_profiler.offline_tool",
      "description": "This module replaces polymorphic comparison operators for raw interest values with type-specific comparisons. It provides standard comparison functions like `(=)`, `(<)`, `(>)`, `compare`, `min`, and `max` that operate directly on `Core_profiler_offline_tool.Interest.Raw.I.t` values. These functions enable precise ordering and equality checks between raw interest instances, which are used to uniquely key events in event generation.",
      "description_length": 435,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set.Diff",
      "library": "core_profiler.offline_tool",
      "description": "This module computes and applies differences between sets of paths, where each path is represented with explicit start and end points and intermediate points stored in reverse order. It supports operations to serialize and deserialize diffs, retrieve optional diffs between two path sets, apply diffs to transform path sets, and construct diffs from lists of changes. Concrete use cases include tracking modifications to path structures across different versions of profiler data or analyzing incremental changes in path traversals.",
      "description_length": 532,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "Converts S-expressions into path sets, ensuring proper structure and constraints for path representation. It operates on `Sexplib0.Sexp.t` inputs and produces `Path.I.Set.t` values, which capture sequences of points with explicit start and end conditions. This conversion supports parsing stored paths that distinguish between direct transitions and indirect routes through intermediate points.",
      "description_length": 394,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for map-like structures indexed by a `Key` type, specifically tailored for path representations where the first and last points have special meaning. It supports reading and writing these structures to and from binary formats, with precise control over size and shape during serialization. Concrete use cases include persisting path data to disk or transmitting it over a network in a compact, efficient format.",
      "description_length": 475,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set.Elt",
      "library": "core_profiler.offline_tool",
      "description": "This module represents individual elements within a set of interests, where each element is comparable and hashable by `Probe_id.t`. It provides functions for converting elements to and from S-expressions and defines a comparator for ordering. Concrete use cases include managing unique interest entries in a set structure for efficient lookup and comparison during profiling analysis.",
      "description_length": 385,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Hash_queue",
      "library": "core_profiler.offline_tool",
      "description": "This module provides operations to manipulate a hash queue structure that maintains ordered key-value pairs with unique keys, supporting efficient insertion, removal, and lookup by key. It emphasizes functional traversal (e.g., folding, iteration with early termination), ordered modifications (e.g., moving elements, enqueuing/dequeuing), and conversions to structured formats like association lists. The structure is particularly suited for scenarios requiring strict insertion-order preservation alongside key-based filtering, such as processing event streams where each event is associated with a unique raw interest and must be aggregated or validated in sequence.",
      "description_length": 669,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Table.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that constructs a table from an S-expression, using a provided function to parse the values. It works with tables where keys are of a type specified by the `Key` submodule and values are of a generic type `'a`. A concrete use case is deserializing structured profiler path data from S-expressions for analysis or processing.",
      "description_length": 368,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for a set of path structures that track sequences of points with explicit first and last elements, and a middle list stored in reverse. It supports reading and writing these path sets using Bin_prot, including low-level size calculation and variant handling. Concrete use cases include persisting and transmitting path data for offline profiling analysis, where paths represent execution traces with direct or indirect transitions between points.",
      "description_length": 510,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for sets of `Core_profiler_offline_tool.Interest.I.t` values. It provides functions to compute binary size, read and write set values, and expose bin-io type classes for use in persistent storage or inter-process communication. The module assumes the element type is already bin-io compatible and leverages the comparable and hashable properties of interests keyed by `Probe_id.t`.",
      "description_length": 445,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Table",
      "library": "core_profiler.offline_tool",
      "description": "This module organizes data into hash tables keyed by raw profiler interests, allowing construction from lists, grouping by keys, and handling duplicates or errors during creation. It supports serialization through S-expressions and binary formats, enabling data to be saved, loaded, and transmitted efficiently. The module works with key-value pairs where keys are of type `Interest.Raw.I.t` and values can be arbitrary, providing operations to map, compare, and analyze grouped profiler events. Submodules extend functionality by offering structured deserialization from S-expressions and binary I/O for persistent or networked profiling data workflows.",
      "description_length": 654,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Hash_set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for a hash set of paths, where each path consists of a sequence of points with specific direct or indirect transition constraints. It operates on the `Core_profiler_offline_tool.Path.I.Hash_set.t` type, enabling efficient storage and retrieval of path data. Concrete use cases include persisting path analysis results to disk or transmitting them across a network.",
      "description_length": 428,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Hash_set.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for hash sets of keyed interests, where each interest is associated with a `Probe_id.t`. It provides functions to compute binary size, read and write hash set values in binary format, and define the binary shape and type class instances. Concrete use cases include persisting or transmitting collections of interest data efficiently in binary format, and reconstructing them without loss of structural integrity.",
      "description_length": 476,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I.Set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages sets of raw interest elements with operations for union, mapping, and conversion from sequences, while abstracting comparator logic and supporting S-expression and binary serialization. It includes submodules for computing and applying set differences, converting S-expressions to sets, representing individual elements with comparison and serialization, hashing sets for fast equality checks, and binary storage and transmission of interest sets. You can load raw interest sets from files, compute differences between them, apply those differences incrementally, hash sets for caching, and serialize them to disk or over a network. These capabilities support efficient filtering, analysis, and version tracking of raw interests in event generation and profiling workflows.",
      "description_length": 793,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Table.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "Converts S-expressions into tables keyed by `Probe_id.t`, using a provided function to parse values. Works with `Sexplib0.Sexp.t` and `Core_profiler_offline_tool.Interest.I.Table.t` structures. Useful for deserializing profiler interest data from S-expression representations.",
      "description_length": 276,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set.Diff",
      "library": "core_profiler.offline_tool",
      "description": "This module represents differences between sets of interest elements keyed by `Probe_id.t`, supporting operations to compute, apply, and serialize set diffs. It works with set-like structures derived from `Core_profiler_offline_tool.Interest.I.Set.Elt.t` and uses a comparator witness for ordering. Concrete use cases include tracking incremental changes between two versions of an interest set and applying those changes to reconstruct updated sets.",
      "description_length": 450,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module provides binary serialization and deserialization operations for maps where keys are of type `Key` and values are of type `Core_profiler_offline_tool.Interest.I.Map.t`. It supports concrete operations such as computing the size of serialized data, writing data to a binary buffer, and reading data from a binary buffer. Use cases include persisting or transmitting structured map data efficiently in a binary format.",
      "description_length": 428,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Hash_set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module provides a function `t_of_sexp` that parses an S-expression into a hash set used to represent a path structure with points and direct transitions. It operates on the data type `Core_profiler_offline_tool.Path.I.Hash_set.t`, which encodes sequences of points where the first and last points are explicit, and intermediate points are stored in reverse order. A concrete use case is deserializing path specifications from configuration or log files into a structured format for analysis in profiling workflows.",
      "description_length": 519,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Table.Provide_bin_io",
      "library": "core_profiler.offline_tool",
      "description": "This module implements binary serialization and deserialization for tables mapping `Key`-typed keys to values of arbitrary type `'a`. It provides functions to compute binary size, read and write table data in binary format, and define bin_io type representations for tables. Concrete use cases include persisting profiling data structures to disk or transmitting them over a network in a compact, efficient format.",
      "description_length": 414,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map.Diff",
      "library": "core_profiler.offline_tool",
      "description": "This module computes and manipulates differences between maps keyed by `Probe_id.t`, where each map value has a base type `'a` and a diff type `'b`. It supports operations to extract, apply, and combine diffs, enabling precise tracking of changes between derived map states. Concrete use cases include analyzing incremental changes in profiling data across different execution phases.",
      "description_length": 384,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map.Key",
      "library": "core_profiler.offline_tool",
      "description": "This module uses path values as keys in maps, enabling efficient comparison and serialization to and from S-expressions. It works with the `t` type representing paths that track start and end points, with optional intermediate points stored in reverse order. Concrete use cases include mapping and comparing paths that represent execution traces with explicit direct or indirect transitions between points.",
      "description_length": 406,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Hash_set.Provide_of_sexp",
      "library": "core_profiler.offline_tool",
      "description": "This module parses S-expressions into hash sets of interests, where each interest is identified by a `Probe_id.t`. It directly supports deserializing structured data stored in S-expression format into a hash set representation for efficient lookups and membership checks. A concrete use case is loading predefined sets of probe interests from configuration files during application initialization.",
      "description_length": 397,
      "index": 152,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map.Key",
      "library": "core_profiler.offline_tool",
      "description": "This module uses `Probe_id.t` as a key type for maps, enabling efficient association of values with profiler interest points. It supports map operations like lookup, insertion, and iteration using `Probe_id` keys. Concrete use cases include tracking per-probe metadata or aggregating profiler data across multiple runs.",
      "description_length": 319,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Reader.Header.Item",
      "library": "core_profiler.offline_tool",
      "description": "This module defines three types\u2014`single`, `group`, and `group_point`\u2014representing different kinds of header items in a profiling data structure. Each type includes a `name` field and other fields specific to its role, such as `spec` for `single`, `points_spec` and `children` for `group`, and `parent` and `sources` for `group_point`. These types are used to organize and identify profiling probes by name and relationship, enabling structured analysis of profiling data.",
      "description_length": 471,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages ordered sets of path elements, constructed from lists, arrays, or hash sets, ensuring uniqueness and comparator-based ordering. It operates on `Elt.t` values representing structured path segments, supporting serialization, property-based testing, and conversion from maps, with use cases in analyzing profiler-generated paths under transition constraints. Submodules handle path element comparison and serialization, hash computation for efficient storage, diff calculation and application for versioned path data, S-expression parsing into path sets, and binary serialization for persistence and transmission. Specific operations include building valid path sequences, computing differences between path sets, hashing structured paths, and converting between path representations for analysis and transformation.",
      "description_length": 833,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Table",
      "library": "core_profiler.offline_tool",
      "description": "This module manages hash tables keyed by `Probe_id.t` values, offering operations to create, group, and validate structured profiling data with support for custom key and data extractors. It includes functions for equality checks, S-expression serialization, and invariant enforcement, enabling tasks like aggregating and querying profiler results. The first child module extends this functionality by parsing S-expressions into tables using a custom value parser, facilitating the deserialization of profiler interest data. The second child module adds binary serialization capabilities, allowing tables to be efficiently stored or transmitted, with support for computing binary size and defining bin_io representations.",
      "description_length": 721,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw.I",
      "library": "core_profiler.offline_tool",
      "description": "This module ensures correct ordering, comparison, and validation of raw interest identifiers, forming the foundation for structured event processing in profiling systems. It directly supports maps, sets, and hash tables keyed by these identifiers, enabling efficient storage, transformation, and analysis of event data with operations like `compare`, `min`, and `max`, while submodules handle serialization, structured diffing, and set manipulation. You can load interest sets from configuration files, serialize them for transmission, or track changes between profiling runs using set differences and hashes. Functional data structures like hash queues and polymorphic maps allow ordered traversal, aggregation, and error-resilient construction, supporting real-time event filtering and sequence-based validation.",
      "description_length": 814,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Hash_queue",
      "library": "core_profiler.offline_tool",
      "description": "This module provides operations for a hash queue combining a hash table with a queue, using path points (`Path.I.t`) as keys and arbitrary data as values. It supports path analysis workflows through ordered insertion, removal, and reordering of elements with key-based access, alongside traversal, filtering, and serialization to structures like lists or S-expressions. These capabilities enable validating traversal paths with strict direct/indirect transition rules and ensuring non-repeating points, except for the final endpoint in a sequence.",
      "description_length": 547,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Hash_queue",
      "library": "core_profiler.offline_tool",
      "description": "This module provides operations for managing a hybrid data structure combining a hash table with a queue, enabling efficient key-based lookups (via `Probe_id.t`) and ordered element traversal. It supports insertion/removal at both ends, in-queue element movement, aggregation (summing, extremum detection), and controlled folding with early termination, alongside dual variants for safe and unsafe access patterns. Such a structure is useful for scenarios requiring both associative storage and deterministic processing order, such as prioritized job queues with keyed elements or trace analysis tools maintaining temporal relationships.",
      "description_length": 637,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Replace_polymorphic_compare",
      "library": "core_profiler.offline_tool",
      "description": "This module replaces polymorphic comparison operations with specialized comparisons for `Interest.I.t` values. It provides standard comparison operators (`<`, `>`, `=`, etc.) and functions like `min`, `max`, and `compare` that operate directly on `Interest.I.t` values. These operations enable sorting, filtering, and ordering of interest records based on their keyed comparison logic.",
      "description_length": 385,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Map",
      "library": "core_profiler.offline_tool",
      "description": "This module manages key-value associations with `Probe_id.t` keys, offering construction from lists, arrays, and sequences, value transformations with error handling, and comparison utilities. It supports S-expression serialization, hashing, and binary encoding for structured workflows like profiler data analysis and hierarchical dataset merging. Submodules enable diffing map states for change tracking, hash digest generation, and parsing from S-expressions, while also supporting efficient binary serialization and deserialization. Specific operations include mapping values across probe IDs, computing structured diffs of interest maps, and persisting map data in compact binary form for transmission or storage.",
      "description_length": 718,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Reader.Short_message.Header",
      "library": "core_profiler.offline_tool",
      "description": "This module encodes and decodes a compact integer representation combining a probe identifier and a timestamp. It operates on `Probe_id.t`, `Time_ns.t`, and `Profiler_epoch.t` to pack and unpack values within a constrained bit width. It is used to efficiently store and retrieve profiling events with associated timestamps in a fixed-size format.",
      "description_length": 346,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Hash_set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages collections of paths, where each path is a sequence of points with constraints on transitions between them. It supports operations for creating, comparing, and serializing hash sets that enforce rules such as no repeated points except at the end. The `Core_profiler_offline_tool.Path.I.Hash_set.t` type represents these path sets, with the main module handling set operations and path validation. Submodules provide binary and S-expression serialization, enabling storage, transmission, and configuration-based loading of path data for profiling and analysis workflows.",
      "description_length": 589,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Hash_set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages collections of `Interest.I.t` elements using hash tables keyed by `Probe_id.t`, supporting efficient membership tests, insertion, and traversal. It includes operations for creating, comparing, and serializing hash sets, enabling use cases such as tracking unique interest identifiers during profiling or persisting interest sets to disk. The binary serialization submodule handles size computation, reading, and writing of hash sets in binary format, ideal for efficient storage or transmission. The S-expression parsing submodule converts structured configuration data into hash sets, facilitating the loading of predefined interest sets at startup.",
      "description_length": 670,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Replace_polymorphic_compare",
      "library": "core_profiler.offline_tool",
      "description": "This module overrides polymorphic comparison operators to define equality and ordering for path objects based on their structure and content. It works directly with `Core_profiler_offline_tool.Path.I.t` values, comparing paths by their first and last points, and the sequence of intermediate points stored in reverse. These operations are used to determine path equivalence, sort paths, or select the minimum or maximum path in a consistent and predictable manner.",
      "description_length": 464,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Table",
      "library": "core_profiler.offline_tool",
      "description": "This module manages hash tables keyed by path segments that track direct and indirect transitions between points, supporting operations like creation from association lists, grouping, and duplicate key detection. It works with `Path.I.t` as keys and arbitrary values, enforcing path traversal invariants, and is used for mapping paths to metadata, aggregating statistics, and validating transitions in profiler data. The binary serialization submodule enables efficient disk or network transmission of path data, preserving transition accuracy for offline analysis, while the S-expression submodule provides `t_of_sexp` for parsing structured profiler data into tables using a custom value parser. Together, these components allow robust construction, transformation, and persistence of path-based data structures.",
      "description_length": 814,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I.Set",
      "library": "core_profiler.offline_tool",
      "description": "This module manages sets of values keyed by `Probe_id.t`, supporting construction from lists, arrays, sequences, and maps, along with transformation, comparison, hashing, and serialization. It includes operations for property-based testing, S-expression conversion, binary serialization, and tracking set differences, enabling structured analysis of interest data across profiling and persistence contexts. Child modules handle S-expression parsing, hash operations, element-level conversions, binary I/O, and diff computation, allowing tasks like reconstructing sets from stored data, comparing interest structures, and applying incremental updates efficiently. Examples include serializing hierarchical profiling data, generating test cases for validation, and persisting or transmitting interest sets through bin-io compatible formats.",
      "description_length": 838,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I.Map",
      "library": "core_profiler.offline_tool",
      "description": "This module manages key-value maps where keys encode structured paths with explicit start and end points and reversed intermediate segments. It supports creation, transformation, comparison, and serialization of these maps, with operations to handle duplicates, apply reductions, and integrate with sequences, arrays, and trees. The module enables analysis and aggregation of data tied to traversal paths, such as profiling execution traces or validating graph paths, and includes submodules for computing path differences, hashing, S-expression and binary serialization, and using paths as keys in other maps. For example, it can detect deviations in control flow by comparing path diffs, persist path data using binary serialization, or merge profiler data from partial paths.",
      "description_length": 778,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Interval_subject",
      "library": "core_profiler.offline_tool",
      "description": "This module defines a type `t` with three variants (`Value`, `Delta`, `Time_delta`) representing different kinds of interval subjects in profiling data. It provides functions to convert between strings, integers, and S-expressions, as well as a comparison function for ordering values. These operations are used to categorize and process interval-based metrics in performance profiling tools.",
      "description_length": 392,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Reader.Short_message",
      "library": "core_profiler.offline_tool",
      "description": "This module represents profiling events such as timers, probes, and group resets, each tagged with a probe ID and timestamp, enabling detailed performance analysis in time-sensitive applications. It includes functionality to encode and decode these events into compact integer representations, using `Probe_id.t`, `Time_ns.t`, and `Profiler_epoch.t` for efficient storage and retrieval. Operations include extracting metadata, reconstructing events from encoded values, and managing event groups. For example, it can decode a binary trace file into timestamped events for performance visualization or analysis.",
      "description_length": 610,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Reader.Header",
      "library": "core_profiler.offline_tool",
      "description": "This module processes header data from an offline profiler, organizing probe IDs into structured metadata for efficient querying. It defines core types\u2014`single`, `group`, and `group_point`\u2014each capturing distinct header item roles, such as individual probes, hierarchical groups, and derived points with parent-source relationships. Operations include lookups by name or ID, traversal of hierarchical relationships, and extraction of attributes like type and units. For example, a `group` can be queried to list its `group_point` children, or a `single` can be retrieved by its name to access its specification and metadata.",
      "description_length": 624,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Path.I",
      "library": "core_profiler.offline_tool",
      "description": "This module handles comparison, validation, and serialization of paths that model sequences of profiler probe IDs with constraints on transitions. It works with path values that track start and end points, intermediate points in reverse order, and variants for direct connections, ensuring no duplicate points except possibly at the terminal node. The module provides ordered and hashable path abstractions for efficient management in maps, sets, and tables, supporting offline analysis workflows. Path sets are managed through ordered collections of structured segments, enabling construction, diffing, hashing, and conversion between representations. A hash queue submodule uses path points as keys for ordered insertion and traversal, enforcing non-repeating points except at the end. Hash sets enforce path uniqueness and support serialization, while comparison overrides ensure structural equality and ordering. Path-based maps and hash tables allow grouping, aggregation, and validation of profiler data, with support for binary and S-expression formats. These structures enable tasks like detecting control flow deviations, merging partial traces, and persisting path data for offline analysis. Operations include path validation, diff application, hash computation, and structured parsing for integration with configuration and transmission pipelines.",
      "description_length": 1359,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.I",
      "library": "core_profiler.offline_tool",
      "description": "This module organizes and enhances operations around `Interest.I.t` identifiers keyed by `Probe_id.t`, combining direct utilities for comparison, ordering, and hashing with structured data management through submodules. It supports sorting, interval checks, and hash-based collections like `Map`, `Set`, and `Hash_queue`, while child modules enable S-expression and binary serialization, hybrid associative-ordered structures, and efficient key-based aggregation. You can validate interest ranges, serialize interest maps for storage, or manage prioritized job queues with keyed elements. Submodules further allow structured diffing, hash digest generation, and direct parsing or encoding of interest data in multiple formats.",
      "description_length": 726,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest.Raw",
      "library": "core_profiler.offline_tool",
      "description": "This module manages raw interest identifiers for event generation, providing comparison, validation, and structured manipulation through data structures like maps, sets, and hash tables. It supports operations such as `compare`, `min`, and `max` for ordering, along with submodules for serialization, diffing, and set operations, enabling tasks like loading interest sets from files, computing differences between profiling runs, and tracking event matches. Functional constructs like hash queues and polymorphic maps allow ordered traversal and aggregation, while hash-based validation ensures correctness during event matching and filtering. Examples include serializing interest configurations, detecting changes across profiling sessions, and enforcing sequence constraints in event streams.",
      "description_length": 795,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Util.Name_map",
      "library": "core_profiler.offline_tool",
      "description": "Maps string names to probe IDs, organizing them into single and group entries based on provided headers. It uses string maps to associate names with `Probe_id.t` values, and structures groups with an ID and child name-to-ID mappings. Useful for resolving named probes in profiling data, enabling efficient lookups and hierarchical organization of probe identifiers during offline analysis.",
      "description_length": 389,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Reader",
      "library": "core_profiler.offline_tool",
      "description": "This module reads and processes profiler data from binary files, parsing headers and iterating over compact messages that represent profiling events. It decodes event streams into structured data, such as timers and probes, tagged with timestamps and probe IDs for performance analysis. The header submodule organizes probe metadata into hierarchical structures, enabling efficient lookups and traversal of relationships between probes and groups. For example, you can load a binary trace, extract timestamped events by probe ID, and query group hierarchies to analyze performance characteristics of specific components.",
      "description_length": 620,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Reservoir_sampling",
      "library": "core_profiler.offline_tool",
      "description": "This module implements reservoir sampling for efficient statistical analysis of large datasets. It maintains a fixed-size sample of observed integers, allowing computation of percentiles and overall distribution statistics. Typical use cases include profiling system metrics like latency or memory usage, where storing all data points is impractical.",
      "description_length": 350,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Std",
      "library": "core_profiler.offline_tool",
      "description": "This module handles unit conversion and string formatting for time and profiler units, providing functions to parse and format time spans, convert between units, and create command-line argument parsers for choice-based options. It works with integers, time spans, and profiler units to support tasks like displaying profiling data in human-readable formats or parsing user input for time-based configurations. Concrete use cases include converting nanoseconds to milliseconds for logging, formatting timestamps for reports, and parsing unit choices in command-line interfaces.",
      "description_length": 577,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Util",
      "library": "core_profiler.offline_tool",
      "description": "This module handles time span conversions, formatting, and command-line argument parsing, working with timestamps, profiler units, and their string representations. It includes operations for converting between time units, formatting profiling data, and defining command-line options with predefined choices. A child module maps string names to probe IDs, organizing them into single and grouped entries for efficient hierarchical lookups during profiling analysis. Together, they support tasks like parsing user input, converting timing data, and resolving named probes in performance traces.",
      "description_length": 593,
      "index": 179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Event_generator",
      "library": "core_profiler.offline_tool",
      "description": "This module processes and generates structured timing and probe events from raw profiling data. It defines types for timer and probe paths, including timestamps and deltas, and supports event creation and iteration based on specified raw interests. It is used to extract and analyze specific profiling events from a buffer, such as tracking time intervals or counter changes associated with profiler IDs.",
      "description_length": 404,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool.Id_table",
      "library": "core_profiler.offline_tool",
      "description": "This module implements a specialized table structure optimized for fast lookups using `Probe_id.t` keys, which are assumed to be consecutive integers. It supports operations like creation from a list of keys, initialization with a function, setting and retrieving values by key, iteration, folding, and conversion to an association list. Concrete use cases include efficiently managing per-probe data in profiling tools where probe IDs are dense and known upfront.",
      "description_length": 464,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Path",
      "library": "core_profiler.offline_tool",
      "description": "This module represents sequences of points where each can be direct or indirect, tracking start and end points with intermediates stored in reverse. It provides construction, comparison, serialization, and point lookup operations, supporting tasks like parsing profiler paths, matching execution traces, and preparing path data for visualization. Submodules manage path sets with ordering and hashing, enforce uniqueness constraints, and implement maps and hash tables for grouping and validating profiler data. Examples include detecting control flow deviations, merging traces, and converting paths to string or binary representations.",
      "description_length": 637,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Filter",
      "library": "core_profiler.offline_tool",
      "description": "This module manages event filtering based on defined interests, allowing creation of filters from headers, adding specific probe interests, and testing or iterating over events that match those interests. It operates on event generators and filters, producing lists of matching interests for each event. Concrete use cases include selectively processing profiler events based on probe IDs, such as filtering trace data for specific performance metrics or components.",
      "description_length": 466,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core_profiler_offline_tool.Interest",
      "library": "core_profiler.offline_tool",
      "description": "This module processes structured profiler data interests through typed representations of interval-based metrics, identifier mappings, and header metadata, enabling selection, transformation, and analysis of profiling events. It centers on `Interest.t`, `Probe_id.t`, and `Header.t`, with operations for parsing, filtering, and converting between string, integer, and S-expression forms, while supporting interval categorization, identifier validation, and heuristic-driven configuration. Child modules refine these capabilities through specialized types like `Value`, `Delta`, and `Time_delta`, structured collections for keyed interests, and utilities for serialization, diffing, and set operations. You can select probes by metadata, validate interval ranges, serialize interest maps, detect differences between profiling runs, or manage keyed job queues with ordered traversal and aggregation.",
      "description_length": 897,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core_profiler_offline_tool",
      "library": "core_profiler.offline_tool",
      "description": "This module processes binary profiler data, extracts structured events like timers and probes, and supports analysis through sampling, filtering, and hierarchical metadata lookups. Key data types include probe IDs, timestamps, time spans, and interest specifications, with operations for decoding event streams, converting units, mapping probe hierarchies, and maintaining efficient sample distributions. You can load and filter trace files by probe ID, convert timing data for display, compute latency percentiles, and analyze performance intervals using structured interest mappings and path sequences. Submodules enable command-line parsing, path validation, keyed data management, and statistical summarization for comprehensive profiling workflows.",
      "description_length": 753,
      "index": 185,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 188,
    "meaningful_modules": 186,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9893617021276596
  },
  "statistics": {
    "max_description_length": 1359,
    "min_description_length": 248,
    "avg_description_length": 496.35483870967744,
    "embedding_file_size_mb": 0.6761474609375
  }
}