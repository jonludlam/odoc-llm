{
  "package": "um-abt",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 8,
  "creation_timestamp": "2025-08-14T23:18:40.697201",
  "modules": [
    {
      "module_path": "Abt.Make.Unification.Subst",
      "library": "um-abt",
      "description": "This module implements substitutions for unification variables in an abstract binding tree. It supports operations to look up variable bindings, list all bindings, and convert substitutions to string representations. It works with variables and terms from the enclosing ABT module to represent partial assignments during unification.",
      "description_length": 333,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Abt.Var.Binding",
      "library": "um-abt",
      "description": "This module implements immutable variable bindings identified by string names. It provides operations to create bindings with `v`, retrieve their names with `name`, and compare or check equality between bindings. Concrete use cases include managing variable scopes and tracking bound variables in abstract syntax trees.",
      "description_length": 319,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abt.Make.Unification",
      "library": "um-abt",
      "description": "This module provides algorithms for unifying terms in an abstract binding tree, producing a most general unifier when possible. It operates on terms and variables from the enclosing ABT structure, using substitutions to resolve variable assignments during unification. Concrete use cases include type inference, logic programming, and symbolic manipulation where term equivalence under variable substitution is required.",
      "description_length": 420,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abt.Var.Set",
      "library": "um-abt",
      "description": "The module implements ordered set operations for managing collections of variables, supporting union, intersection, difference, and membership checks while maintaining elements via a comparison-based ordering. It provides ordered traversal, sequence conversion, and transformation capabilities\u2014such as mapping, filtering, and folding\u2014specifically for handling variable sets in abstract binding tree manipulations. These tools are particularly useful for tasks like tracking free variables, analyzing binding structures, or performing ordered iteration during term traversal.",
      "description_length": 574,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abt.Var.Map",
      "library": "um-abt",
      "description": "This module implements a key-ordered finite map structure using variables as keys, supporting efficient insertion, deletion, and lookup operations alongside functional transformations like mapping, filtering, and folding over variable-value pairs. It works with variable bindings that maintain physical equality and order, enabling applications such as managing lexical scopes in compilers or interpreters where variable names must be uniquely resolved and traversed in a consistent order. Use cases include symbol table management, environment tracking in evaluators, and bulk operations over variable mappings via sequence conversions.",
      "description_length": 637,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abt.Var",
      "library": "um-abt",
      "description": "This module represents variables that are either free (named by strings) or bound to a variable binding, with operations to create, compare, bind, and inspect variables. It supports concrete tasks like binding a free variable to a specific binding, checking if a variable is bound to a particular identifier, and converting variables to strings or sexps. The associated `Set` and `Map` modules enable ordered collections and key-based mappings of variables, useful for managing free variable sets and lexical environments in language processing tasks.",
      "description_length": 551,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Abt.Make",
      "library": "um-abt",
      "description": "This module implements an abstract binding tree (ABT) structure for representing and manipulating formal language syntax with support for variables, scoped bindings, and custom operators. It provides operations for binding variables, substituting terms, checking alpha equivalence, and analyzing free variables, enabling precise handling of name binding and scope. Concrete use cases include formal language implementation, type system modeling, and symbolic computation where variable capture and substitution must be carefully managed.",
      "description_length": 537,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abt",
      "library": "um-abt",
      "description": "This module implements abstract binding trees with support for variable binding, substitution, and alpha equivalence checks, working with variables and custom syntax operators. It provides operations to construct and manipulate formal language syntax, including binding variables, substituting terms, and analyzing free variables. Concrete use cases include implementing formal languages, modeling type systems, and performing symbolic computations where precise handling of variable scope and capture is required.",
      "description_length": 514,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 637,
    "min_description_length": 319,
    "avg_description_length": 485.625,
    "embedding_file_size_mb": 0.11641120910644531
  }
}