{
  "package": "sexp_decode",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-07-15T23:05:37.956748",
  "modules": [
    {
      "module_path": "Sexp_decode.SEXP",
      "library": "sexp_decode",
      "description": "This module defines the structure of S-expressions, supporting operations to construct and deconstruct them. It works with two primary data types: atoms (represented as strings) and lists of S-expressions. Concrete use cases include parsing and serializing data in a format suitable for configuration files, domain-specific languages, or communication protocols.",
      "description_length": 362,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_decode.S",
      "library": "sexp_decode",
      "description": "This module supports decoding S-expressions into structured data through a set of monadic parsing combinators that enable mapping, sequencing, and alternative compositions. It operates on S-expressions and streams, handling primitive value extraction (integers, strings) alongside structured types like tuples, lists, records, and variants, with support for optional fields, repeated elements, and default values. Typical use cases include deserializing configuration files, parsing domain-specific languages, or transforming nested S-expression data into OCaml's algebraic data types using recursive and iterative decoding patterns.",
      "description_length": 633,
      "index": 1,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Sexp_decode.Make",
      "library": "sexp_decode",
      "description": "This module provides monadic combinators for decoding S-expressions (atoms and lists) into structured OCaml data types like records, tuples, options, and lists, with support for recursive and conditional parsing. It operates on an abstract S-expression type parameterized via a functor, enabling compatibility across libraries with differing S-expression implementations. Typical use cases include deserializing configuration files, parsing tagged data formats, and bridging incompatible S-expression representations in different OCaml libraries.",
      "description_length": 546,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_decode",
      "library": "sexp_decode",
      "description": "This module offers a monadic framework for decoding S-expressions into structured OCaml data, centered around parsing combinators that transform `Csexp.t` values into typed values with support for atoms, lists, records, and variants. It provides core operations for extracting primitive values (strings, integers, booleans), composing decoders for complex structures (tuples, optional fields, tagged unions), and handling recursive or nested data through combinators like map, bind, and choice. Submodules define the S-expression data model, support stream-based decoding, and enable compatibility across different S-expression implementations via functors. Example uses include parsing configuration files with nested sections, interpreting DSLs with typed expressions, and decoding protocol messages with variable tags or repeated elements.",
      "description_length": 842,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 842,
    "min_description_length": 362,
    "avg_description_length": 595.75,
    "embedding_file_size_mb": 0.014948844909667969
  }
}