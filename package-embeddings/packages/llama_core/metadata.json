{
  "package": "llama_core",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 14,
  "creation_timestamp": "2025-08-14T23:16:30.961833",
  "modules": [
    {
      "module_path": "Llama_core.Music.Note_name",
      "library": "llama_core",
      "description": "This module defines a polymorphic variant type representing musical note names, including sharps. It provides a function to convert these note names to their string representations. Use this module when working with individual musical notes in a scale or chord, such as parsing or displaying note values in a music theory application.",
      "description_length": 334,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Music.Note",
      "library": "llama_core",
      "description": "This module represents musical notes as pairs of note names and octaves. It provides functions to convert notes to frequencies in hertz, to MIDI indices, and from MIDI indices back to note representations. These operations support tasks like audio synthesis, MIDI processing, and music theory calculations.",
      "description_length": 306,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Llama_core.Signal.Ctx",
      "library": "llama_core",
      "description": "Handles audio signal processing contexts with sample indexing and rate information. Works with floating-point sample rates and integer sample indices. Used for managing timing and positioning in audio buffer operations.",
      "description_length": 219,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Signal.Raw",
      "library": "llama_core",
      "description": "This module implements signal transformations using stateful computations, allowing the creation of signals that evolve based on internal state updates. It provides operations to map over signal values, chain signals through monadic binding, and manage state transitions within a signal network. These functions are used to model dynamic behaviors in systems like reactive user interfaces or simulation engines.",
      "description_length": 411,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Midi.Controller_table",
      "library": "llama_core",
      "description": "This module maps MIDI controller values to signals, providing direct access to raw controller data and specialized signals for modulation and volume. It works with a table structure that associates MIDI controller numbers with their corresponding signal representations. Use this module to retrieve specific controller values by index or access common controllers like modulation wheel or channel volume as signals.",
      "description_length": 415,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Midi.Midi_sequencer",
      "library": "llama_core",
      "description": "Handles MIDI event streams by extracting gate signals and synthesizing voice data on a specified channel. It processes note and control events into structured outputs like frequency, gate, and velocity signals, supporting polyphonic voice allocation. Useful for building MIDI-driven audio synthesizers with dynamic pitch and controller handling.",
      "description_length": 345,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Midi.Gate_table",
      "library": "llama_core",
      "description": "This module implements a lookup table for MIDI gate signals, mapping integer keys to gate values. It provides direct access to individual gates using the `get` function. Useful for retrieving precomputed gate states based on MIDI note numbers or other integer indices.",
      "description_length": 268,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Signal.Gate",
      "library": "llama_core",
      "description": "This module provides functions to convert between gate signals and boolean values, sample gate states within a context, and transform gates into triggers. It works with gate signals that represent time-varying boolean conditions, typically used to control the flow of other signals. Concrete use cases include enabling or disabling signal processing based on temporal conditions, and debugging signal flow by tracing gate activations.",
      "description_length": 434,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Llama_core.Signal.Trigger",
      "library": "llama_core",
      "description": "This module converts and manipulates boolean signals into trigger signals that activate only on the first sample of a rising edge. It supports operations like detecting transitions from false to true, converting existing signals into triggers, and sampling trigger states within a context. Use cases include edge detection in digital circuits, event triggering in reactive systems, and debugging by logging trigger occurrences.",
      "description_length": 427,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Music",
      "library": "llama_core",
      "description": "This module handles musical note representations and conversions, working with polymorphic variants for note names and structured note-octave pairs. It provides precise operations for converting notes to frequencies, MIDI indices, and semitone intervals. Use it for audio synthesis, music theory computations, or MIDI file processing where exact pitch and frequency calculations are required.",
      "description_length": 392,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Midi",
      "library": "llama_core",
      "description": "This module processes MIDI input into audio signals, mapping controller values and gate states to structured outputs. It handles MIDI event streams, extracting frequency, gate, and velocity signals for polyphonic synthesis and real-time controller mapping. Use it to build synthesizers that respond to MIDI notes and control changes with dynamic voice allocation and signal routing.",
      "description_length": 382,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Dsl",
      "library": "llama_core",
      "description": "This DSL enables constructing and transforming audio signals through operations like waveform generation (e.g., oscillators, noise), arithmetic manipulations (addition, scaling), and effects processing (filtering, delay, amplification). It works with abstract signal types (`float t`, `bool t`), triggers, and sequencers to model time-varying values and control flow. Designed for audio synthesis and procedural sound design, it supports tasks like creating dynamic envelopes, implementing feedback loops, or building modular synthesis graphs with functional reactive programming principles.",
      "description_length": 591,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core.Signal",
      "library": "llama_core",
      "description": "This module enables dynamic value computation and state management over time through mapping operations, arithmetic transformations, and stateful combinators, supporting audio-rate signal processing and reactive programming. It operates on float and boolean signals, leveraging time/sample-indexed contexts to handle tasks like normalization, edge detection, and conditional signal gating. Key applications include audio synthesis, control flow in signal networks, and converting between numeric/boolean signal representations for interactive systems.",
      "description_length": 551,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Llama_core",
      "library": "llama_core",
      "description": "This module provides core components for audio signal processing and synthesis, featuring a domain-specific language for constructing signal graphs with operations like waveform generation, filtering, and sequencing. It supports typed signals (`float t`, `bool t`) for representing time-varying audio and control data, enabling precise manipulation of sound through arithmetic, stateful transformations, and reactive behaviors. Concrete applications include building synthesizers from MIDI input, generating procedural audio, and implementing dynamic envelopes or feedback loops in a functional style.",
      "description_length": 601,
      "index": 13,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 15,
    "meaningful_modules": 14,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9333333333333333
  },
  "statistics": {
    "max_description_length": 601,
    "min_description_length": 219,
    "avg_description_length": 405.42857142857144,
    "embedding_file_size_mb": 0.2034168243408203
  }
}