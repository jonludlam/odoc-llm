{
  "package": "angstrom",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 9,
  "creation_timestamp": "2025-08-14T23:05:47.664348",
  "modules": [
    {
      "module_path": "Angstrom.Let_syntax.Let_syntax",
      "library": "angstrom",
      "description": "This module provides syntactic support for writing parsers using `let`-binding syntax via the `ppx_let` pre-processor. It includes operations like `return`, `map`, `bind`, and combinators such as `both` and `map2` through `map4` to sequence and transform parser results. These functions enable concise composition of complex parsers that operate on byte streams, such as parsing binary formats or structured text like JSON or HTTP headers.",
      "description_length": 439,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom.LE",
      "library": "angstrom",
      "description": "This module implements parsers for reading and validating little-endian binary values from input streams. It supports exact matches for 16-bit, 32-bit, and 64-bit integers, as well as reading arbitrary little-endian signed and unsigned integers and floating-point numbers. These parsers are useful for decoding binary protocols or file formats that encode numeric data in little-endian byte order, such as certain network protocols or binary serialization formats.",
      "description_length": 464,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Angstrom.Buffered",
      "library": "angstrom",
      "description": "This module provides functions for running and feeding buffered parsers that internally manage input storage, minimizing memory copying while supporting incremental input consumption. It works with parsers defined in the base module, handling input as bigstrings or strings, and returns unconsumed data in a structured buffer format. Concrete use cases include parsing streaming data from files or network sockets where input arrives in chunks and efficient buffer management is critical.",
      "description_length": 488,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom.Consume",
      "library": "angstrom",
      "description": "This module provides functions to control how much of the input is consumed during parsing, specifically by determining whether to consume only a prefix of the input or the entire input. It works with the `t` variant type, which represents consumption modes, and integrates with parser combinators to influence parsing behavior. Concrete use cases include selectively consuming input when parsing structured data formats like JSON or binary protocols, where partial consumption is needed to process headers or variable-length fields.",
      "description_length": 533,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Angstrom.Unsafe",
      "library": "angstrom",
      "description": "This module provides low-level, zero-copy parsing operations that directly manipulate the internal buffer during parsing. It works with `bigstring` buffers and exposes functions like `take`, `take_while`, and `peek` to process input without intermediate allocations. These operations are ideal for performance-critical parsers, such as binary protocol decoders or high-throughput log parsers, where avoiding memory allocation is essential.",
      "description_length": 439,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom.Unbuffered",
      "library": "angstrom",
      "description": "This module provides low-level parsing operations that require manual buffer management, enabling zero-copy input handling by avoiding internal buffering. It works directly with user-managed byte buffers and tracks parser progress through explicit state transitions, using `more` to signal input availability. Concrete use cases include high-performance network protocol parsers and custom streaming data processors where precise memory control is critical.",
      "description_length": 457,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom.BE",
      "library": "angstrom",
      "description": "This module provides big-endian binary parsers for fixed-size integers and floating-point numbers. It operates on byte streams, consuming exact byte counts to decode values like 16-bit, 32-bit, and 64-bit integers (signed and unsigned) and 32-bit/64-bit floats. Use it to parse binary protocols or file formats that encode numeric data in big-endian format, such as network packets or structured binary logs.",
      "description_length": 408,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom.Let_syntax",
      "library": "angstrom",
      "description": "This module enables concise parser composition using `let`-binding syntax via `ppx_let`, providing `return`, `map`, and `bind` operations for sequencing and transforming parser results. It works directly with `Angstrom.t` parsers that consume byte streams, supporting operations like `both` and `map2` to `map4` for combining multiple parsers. Concrete use cases include writing structured parsers for binary protocols or text formats like JSON and HTTP, where readable composition of complex parsing logic is required.",
      "description_length": 519,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Angstrom",
      "library": "angstrom",
      "description": "This module provides low-level parsing primitives and combinator-based parser construction for incremental, memory-efficient data processing. It operates on character streams and binary data using `bigstring`-backed buffers, supporting zero-copy input manipulation through unbuffered interfaces and endianness-aware binary parsing via specialized combinators. Typical applications include protocol implementation, file format parsing, and high-throughput stream processing where precise control over input consumption and minimal allocation overhead are critical.",
      "description_length": 563,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 9,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 563,
    "min_description_length": 408,
    "avg_description_length": 478.8888888888889,
    "embedding_file_size_mb": 0.13085460662841797
  }
}