{
  "package": "lambdapi",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 128,
  "creation_timestamp": "2025-08-18T18:47:53.093978",
  "modules": [
    {
      "module_path": "Handle.Proof.Goal",
      "library": "lambdapi.handle",
      "description": "Handles operations on proof goals, including context extraction, simplification, and formatting. Works with proof goals, typing contexts, and environments. Used to manipulate and inspect individual proof states during tactic development.",
      "description_length": 237,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Compile.PureUpToSign",
      "library": "lambdapi.handle",
      "description": "This module provides `compile` and `compile_file` functions that perform compilation while restoring the console state and library mappings after execution. It operates on file paths and console states, producing a signature result. These functions are used to compile code with controlled environment settings, ensuring consistent behavior across compilations.",
      "description_length": 361,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Inductive",
      "library": "lambdapi.handle",
      "description": "This module generates induction principles for first-order dependent inductive types, supporting mutually defined types and polymorphic encodings via type codes. It constructs induction predicates, recursor types, and associated proof terms, working with symbolic representations of types and terms from the Core module. Concrete use cases include automatically deriving induction principles for inductive data types like lists, trees, and their mutual counterparts, enabling proof automation and type-driven development.",
      "description_length": 521,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Query",
      "library": "lambdapi.handle",
      "description": "This module implements type inference and type checking for terms in a given context, refining terms and determining their types or sorts under constraint problems. It operates on terms, contexts, and constraint problems from the Core module, producing refined terms and type information. It is used to process queries during proof checking, where concrete terms must be validated against expected types or generalized to infer their most precise type.",
      "description_length": 452,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Fol",
      "library": "lambdapi.handle",
      "description": "This module defines a configuration structure for first-order logic tactics, mapping logical symbols like conjunction, disjunction, quantifiers, and propositional constants to their corresponding term symbols. It works with the `Core.Term.sym` type to represent logical constructs and uses `Core.Sig_state.t` to build configurations based on a given signature state. Concrete use cases include setting up logical environments for automated theorem proving and tactic execution in a first-order logic framework.",
      "description_length": 510,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Command",
      "library": "lambdapi.handle",
      "description": "This module processes commands in a proof assistant, handling both top-level directives and proof mode entry. It works with signature states, proof states, and syntax trees for commands and proofs. Concrete operations include parsing and executing commands, managing proof data with positions and finalizers, and triggering warnings for long-running commands.",
      "description_length": 359,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Why3_tactic",
      "library": "lambdapi.handle",
      "description": "This module runs a Why3 prover on a given goal type, using either a specified or default prover name, and fails if no proof is found. It works with goal types from the `Handle.Proof` module and accepts configuration parameters such as prover name and timeout. Concrete use cases include invoking SMT solvers like Z3 or CVC4 to discharge proof obligations during interactive theorem proving.",
      "description_length": 390,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Handle.Rewrite",
      "library": "lambdapi.handle",
      "description": "This module implements the rewrite tactic, providing operations for pattern matching, substitution, and equality manipulation in terms of theorem proving. It works with terms and binders from the Core.Term module, handling tasks like matching, finding subterms, and generating substitutions based on patterns. Concrete use cases include rewriting goal types using equational lemmas, swapping equality sides, and binding patterns in proof terms.",
      "description_length": 444,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Proof",
      "library": "lambdapi.handle",
      "description": "Handles proof goals and proof states for interactive theorem proving. It supports operations like checking goal types, extracting constraints, adding goals from problems, and managing proof states with functionalities for goal removal and environment extraction. Used to manipulate and inspect proof states during tactic development, particularly for processing typing and unification goals.",
      "description_length": 391,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Handle.Tactic",
      "library": "lambdapi.handle",
      "description": "This module implements core proof manipulation operations including tactic application, goal refinement, and axiom handling. It works with proof states, metavariables, inductive data structures, and term contexts to manage logical reasoning steps. Concrete use cases include refining proof goals with terms, applying induction, solving unification constraints, and admitting axioms to discharge unsolved goals.",
      "description_length": 410,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle.Compile",
      "library": "lambdapi.handle",
      "description": "This module compiles source files into signatures, using file paths and module paths as inputs. It controls object file generation via `gen_obj` and supports forced recompilation. Used primarily during package building to ensure correct and repeatable compilation of individual files or module hierarchies.",
      "description_length": 306,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Handle",
      "library": "lambdapi.handle",
      "description": "This module provides operations for parsing and executing proof assistant commands, compiling source files into signatures, defining first-order logic configurations, generating induction principles, managing proof states, performing type inference, implementing rewrite tactics, applying proof tactics, and invoking external provers. It works with data types such as signature states, proof states, terms, contexts, constraint problems, and inductive type definitions. Concrete use cases include processing proof scripts, building logical environments for theorem proving, automating induction, refining terms during type checking, and discharging proof obligations with SMT solvers.",
      "description_length": 684,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lsp.Lp_doc",
      "library": "lambdapi.lsp",
      "description": "This module manages document state and proof processing for a logical editor. It provides functions to create and update document structures, process proof steps and commands, and extract goals or errors, working with types like `doc_node`, `Pure.state`, and `Pure.proof_state`. Concrete use cases include parsing and evaluating logical scripts, tracking proof progress, and generating error responses for an LSP server.",
      "description_length": 420,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lsp.Lp_lsp",
      "library": "lambdapi.lsp",
      "description": "This module implements the main entry point for launching an LSP server, handling command-line arguments and server initialization. It works with string values to configure logging and control server behavior. A concrete use case is starting an LSP server with a specified log file and debug mode.",
      "description_length": 297,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lsp.Lsp_base",
      "library": "lambdapi.lsp",
      "description": "This module handles core LSP protocol operations, converting internal data structures to JSON for communication. It provides functions to create LSP responses, diagnostics, and goal representations, working with positions, goals, and JSON objects. Concrete use cases include formatting errors and proof state information for display in editors supporting the LSP protocol.",
      "description_length": 372,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lsp.Lsp_io",
      "library": "lambdapi.lsp",
      "description": "Handles input/output operations for JSON-RPC communication, including reading requests from channels and sending formatted JSON responses. Works with JSON values (`J.t`), channels (`in_channel`), and formatters (`F.formatter`). Used to implement logging, debugging, and message serialization in language server protocols.",
      "description_length": 321,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lsp",
      "library": "lambdapi.lsp",
      "description": "This module implements a language server for logical proof editing, providing document state management, proof processing, and LSP protocol communication. It works with document nodes, proof states, JSON-RPC messages, and input/output channels to handle tasks like parsing logical scripts, tracking proof progress, and reporting errors. Concrete use cases include launching an LSP server with logging support, converting proof goals to JSON for editor display, and processing proof commands through JSON-RPC.",
      "description_length": 508,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.RangeMap.Make.Range",
      "library": "lambdapi.lplib",
      "description": "This module represents and manipulates source code positions and intervals, using line and column numbers. It provides operations to create and compare intervals, check if a point lies within an interval, and translate interval boundaries. Concrete use cases include tracking token positions in a parser or managing source code spans for error reporting.",
      "description_length": 354,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Extra.IntSet",
      "library": "lambdapi.lplib",
      "description": "This module implements a comprehensive set of integer set operations, including membership checks, union, intersection, difference, and transformations like mapping and filtering. It works with integer sets represented as `Lplib.Extra.IntSet.t`, supporting conversions to and from lists and sequences via `Stdlib.Seq.t`. Typical use cases involve managing sparse integer ranges, performing set algebra, or processing integer collections with functional transformations while maintaining immutability.",
      "description_length": 500,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.RangeMap.Make",
      "library": "lambdapi.lplib",
      "description": "This module maps source code intervals to values, supporting insertion of ranges with associated data and lookup of data covering specific points. It works with line-column positions and intervals represented by the `Range` module, ensuring efficient and precise spatial queries. Concrete use cases include tracking token spans in a parser or associating metadata with source code regions for diagnostics.",
      "description_length": 405,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Option.Monad",
      "library": "lambdapi.lplib",
      "description": "This module provides monadic operations for working with `option` values, specifically enabling sequential composition of functions that return optional results using `let*`. It supports chaining operations where each step depends on the successful outcome of the previous one, simplifying error handling in computations that may fail. Use cases include parsing, configuration loading, and any workflow requiring optional values with clean error propagation.",
      "description_length": 458,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Extra.IntMap",
      "library": "lambdapi.lplib",
      "description": "This module provides operations for constructing, transforming, and querying maps with integer keys, including insertion, deletion, and value updates via functions like `add`, `remove`, and `update`, as well as ordered traversal and aggregation through `fold`, `map`,",
      "description_length": 267,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Extra.StrSet",
      "library": "lambdapi.lplib",
      "description": "This module implements functional string set operations including union, intersection, difference, and element queries with optional variants for safe access, alongside transformations like mapping and filtering. It operates on an immutable set type for string elements, supporting conversions to and from lists and sequences, as well as ordered iteration. Typical use cases include managing unique string identifiers, processing text data with set algebra, or interfacing with sequence-based workflows.",
      "description_length": 503,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Option.Applicative",
      "library": "lambdapi.lplib",
      "description": "Implements applicative operations for the option type, enabling function application within optional contexts. It provides `pure` to wrap values in an option and `<*>` to apply an optional function to an optional argument, propagating absence. Useful for composing computations that may fail, such as parsing or lookup operations where intermediate results might be missing.",
      "description_length": 374,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Base.Int",
      "library": "lambdapi.lplib",
      "description": "This module provides arithmetic operations, bitwise manipulations, and integer comparisons. It works directly with the built-in `int` type, enhancing standard integer handling with functions like addition, subtraction, multiplication, division, and bitwise AND, OR, and XOR. Concrete use cases include numerical computations, flag management, and low-level arithmetic logic.",
      "description_length": 374,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Extra.StrMap",
      "library": "lambdapi.lplib",
      "description": "This module provides operations for constructing and manipulating polymorphic maps with string keys, including insertion, deletion, merging, and ordered key traversal via functions like `find_first`, `min_binding`, and `max_binding`. It supports transformations (e.g., `map`, `filter`), membership checks, and bidirectional conversion between maps and sequences or lists of key-value pairs. These capabilities are particularly useful for managing hierarchical configurations, processing associative data from external sources, or aggregating key-value pairs with ordered traversal requirements.",
      "description_length": 594,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Color",
      "library": "lambdapi.lplib",
      "description": "This module defines operations for managing terminal color output using ANSI escape codes. It provides functions to convert between color values and strings, apply color formatting to output streams, and conditionally colorize text based on boolean flags. Concrete use cases include highlighting errors in red, success messages in green, and dynamically switching output color based on user preferences or terminal capabilities.",
      "description_length": 428,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Extra",
      "library": "lambdapi.lplib",
      "description": "This module implements efficient, immutable data structures for integer and string-based maps and sets, supporting operations like insertion, deletion, union, intersection, and ordered traversal. It provides utilities for working with file system operations, process execution, and time measurement, including functions to read input lines, run shell commands, check file modification times, and time function executions with optional timeouts. Concrete use cases include managing configuration data with string maps, performing set algebra on integer or string sets, and automating file-based workflows with dependency tracking based on file timestamps.",
      "description_length": 654,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Base",
      "library": "lambdapi.lplib",
      "description": "This module extends the standard library with formatting combinators and comparison utilities. It provides functions for building and manipulating pretty-printing values (`pp`), including concatenation, conditional inclusion, and prefix/suffix application, working with basic types like `int`, `char`, `string`, and `float`. It also includes comparison combinators for constructing lexicographic and mapped comparisons, and derives equality from comparison functions, enabling structured data formatting and comparison logic in specific contexts like AST rendering or log output.",
      "description_length": 579,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Range",
      "library": "lambdapi.lplib",
      "description": "This module represents and manipulates source code positions and intervals. It provides functions to create and query points (line and column positions) and intervals (start and end points), including operations like comparison, translation, and checking whether a point lies within an interval. It is used to track and manage source code locations, such as in parsers or linters, where precise positioning is required.",
      "description_length": 419,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Option",
      "library": "lambdapi.lplib",
      "description": "This module offers utilities for constructing, transforming, and composing computations over OCaml's `option` type, with support for monadic chaining (`let*`), applicative function application, and safe extraction. It integrates with data structures like results, lists, and sequences through conversion functions, while enabling idiomatic error handling in workflows such as parsing, configuration loading, and any context requiring robust management of potentially absent values.",
      "description_length": 481,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.List",
      "library": "lambdapi.lplib",
      "description": "The functions enable list traversal, transformation (mapping, folding, filtering), and structural manipulation (reversal",
      "description_length": 120,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Uchar",
      "library": "lambdapi.lplib",
      "description": "This module provides operations for validation, conversion, and low-level manipulation of Unicode scalar values represented as integers, including safe and unsafe transitions between integers and characters, bounds checking, and handling UTF-8/UTF-16 decoding states. It works with integers encoding UCS-4 codepoints, character values, and byte sequences for encoding/decoding, while offering constants for Unicode limits and special codepoints. Use cases include text processing pipelines requiring precise Unicode validation, encoding-aware byte stream parsing, and implementing custom character set transformations with error resilience.",
      "description_length": 640,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.RangeMap_intf",
      "library": "lambdapi.lplib",
      "description": "This module defines an interface for a range map data structure that supports efficient insertion, deletion, and lookup of key-value pairs where keys are represented as intervals. It works with ordered types and interval ranges, enabling associative operations over continuous key spans. Concrete use cases include managing memory regions, handling time intervals, and implementing sparse arrays.",
      "description_length": 396,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.RangeMap",
      "library": "lambdapi.lplib",
      "description": "This module implements a map from source code intervals to values, supporting insertion of ranges with associated data and efficient lookup of data covering specific points. It works with line-column positions and intervals from the `Range` module. Use it to track token spans in a parser or associate metadata with source code regions for diagnostics.",
      "description_length": 352,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Filename",
      "library": "lambdapi.lplib",
      "description": "This module offers operations for constructing, analyzing, and transforming file paths, including joining components, splitting directories and filenames, handling extensions, and securely generating temporary files or directories with controlled access settings. It provides utilities for command-line argument formatting, resolving canonical paths, and normalizing path representations, working with string-based paths and arguments while adhering to platform-specific rules for slashes, separators, and process execution. Key use cases include cross-platform path handling, temporary file management, and preparing paths for system operations like process spawning.",
      "description_length": 668,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib.Bytes",
      "library": "lambdapi.lplib",
      "description": "This module offers low-level byte sequence manipulation, including slicing, transformation, and in-place modification, alongside binary data handling for integer serialization/deserialization with configurable endianness. It operates on mutable `bytes` values and supports text encoding operations for UTF-8 and UTF-16, with utilities for Unicode character access, validation, and case conversion. Key use cases include binary protocol parsing, memory-efficient data serialization, and encoded text processing where direct byte-level control is required.",
      "description_length": 554,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Range_intf",
      "library": "lambdapi.lplib",
      "description": "This module defines operations for representing and manipulating integer ranges, including creating, expanding, and checking membership within ranges. It works with abstract data types that model continuous sequences of integers. Concrete use cases include managing index ranges for arrays, tracking spans in text buffers, and validating numeric intervals.",
      "description_length": 356,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lplib.Array",
      "library": "lambdapi.lplib",
      "description": "The module offers operations for creating, transforming, and iterating over one-dimensional and two-dimensional arrays, supporting in-place modifications, functional updates, and index-aware computations. It includes tools for folding, mapping with side effects, pairwise array comparisons, predicate checks, and sorting with customizable logic, alongside utilities for slicing, shuffling, and converting arrays to lists or sequences. These capabilities suit tasks like matrix operations, data processing pipelines, and algorithms requiring efficient bulk element manipulation or indexed traversal patterns.",
      "description_length": 607,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lplib",
      "library": "lambdapi.lplib",
      "description": "The module provides a comprehensive set of functionalities for working with arrays, offering operations for transformation, iteration, and in-place modification across one-dimensional and two-dimensional structures. It supports advanced array manipulations such as folding, mapping with side effects, pairwise comparisons, and custom sorting, making it well-suited for tasks like matrix computations and data processing pipelines. Additionally, it includes utilities for slicing, shuffling, and converting arrays to other data forms, enabling efficient bulk element handling and indexed traversal patterns.",
      "description_length": 606,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool.Tree_graphviz",
      "library": "lambdapi.tool",
      "description": "This module converts decision trees represented as `Core.Term.dtree` into Graphviz's DOT language for visualization. It defines a variant type `dot_term` to model node kinds and provides the `to_dot` function to print a symbolic representation of a tree, including node labels and edge terms derived from pattern matrices. It is used to generate visual depictions of decision trees for debugging or documentation purposes.",
      "description_length": 422,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool.Lcr",
      "library": "lambdapi.tool",
      "description": "This module provides operations for generating and analyzing critical pairs in term rewriting systems, focusing on incremental verification of local confluence. It manipulates terms and rewrite rules using unification, substitution, and subterm traversal, while tracking rule dependencies to avoid redundant checks when new rules are added. Key use cases include optimizing confluence proofs by isolating critical pairs from rule interactions and managing pattern variable renaming to prevent clashes during unification.",
      "description_length": 520,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tool.Sr",
      "library": "lambdapi.tool",
      "description": "This module ensures that a rule preserves typing by validating its well-formedness in a given signature state. It operates on parsed rules and constructs typed rules, raising an error if type preservation fails. It is used when processing formal rules to guarantee correctness during type-checking.",
      "description_length": 298,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool.Websearch",
      "library": "lambdapi.tool",
      "description": "Starts an HTTP server on the specified port to handle incoming web search requests. It processes queries and returns relevant search results from configured sources. This function is typically used to deploy a standalone search API service.",
      "description_length": 240,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool.External",
      "library": "lambdapi.tool",
      "description": "This module runs external checkers via Unix commands to validate properties on signatures. It processes a signature using a provided formatter, sends it to the checker's standard input, and parses the first line of output as \"YES\", \"NO\", or \"MAYBE\". It returns `Some true`, `Some false`, or `None` accordingly, and raises `Fatal` on unexpected checker behavior.",
      "description_length": 361,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool.Indexing",
      "library": "lambdapi.tool",
      "description": "This module manages an indexing system for signs using a list of rules. It provides operations to initialize an empty index, index a sign based on rules, and dump the index contents. Search functionality is available through `search_cmd_txt` and `search_cmd_html`, which return formatted results for a given query string in plain text or HTML.",
      "description_length": 343,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tool",
      "library": "lambdapi.tool",
      "description": "This module organizes a suite of specialized components for formal verification, indexing, and external analysis of term rewriting systems. It handles operations on signatures, rewrite rules, and decision trees, supporting tasks like confluence checking, type preservation validation, and external property verification through command-line tools. Concrete use cases include proving local confluence incrementally, generating DOT visualizations of decision trees, and running a web search API for indexed content.",
      "description_length": 513,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Export.Hrs.V",
      "library": "lambdapi.export",
      "description": "This module defines a data type `t` as a pair of integers and a comparison function for it. It is used to represent and compare pattern variables with their arities in the context of translating signatures to the HRS format. The module supports operations like lambda, let, and Pi abstraction by encoding pattern variables as functions based on their arity.",
      "description_length": 357,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Hrs.VMap",
      "library": "lambdapi.export",
      "description": "This module implements a map structure for managing variable bindings during the HRS translation process, where keys correspond to HRS variable representations (`Export.Hrs.V.t`) and values hold arbitrary associated data. It supports functional and imperative-style operations for binding manipulation, including associative updates, bulk transformations (mapping, filtering, folding), and conversions to sequences or lists, alongside specialized utilities for handling lists of values and optional bindings. Designed for the HRS format conversion workflow, it enables efficient querying, modification, and structural analysis of variable mappings, particularly in scenarios requiring iterative refinement or traversal of bound variables and their translated forms.",
      "description_length": 765,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Coq.Qid",
      "library": "lambdapi.export",
      "description": "Translates qualified identifiers from the parser-level AST into Coq, applying renamings specified via a map or a lambdapi file. It directly handles values of type `Core.Term.qident`, using `compare` to order identifiers when needed. This module is used during AST conversion to ensure identifiers match Coq's naming conventions or user-defined mappings.",
      "description_length": 353,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Coq.QidMap",
      "library": "lambdapi.export",
      "description": "This module provides a map data structure for managing key-value associations where keys are qualified identifiers (`Qid.t`), supporting operations like insertion, deletion, ordered traversal, and customizable merging of overlapping entries. It includes functions for bidirectional conversion between maps and ordered sequences, bulk updates, and predicate-driven transformations, with a focus on maintaining key ordering during iteration. The structure is particularly used in translating abstract syntax trees to Coq, enabling identifier renaming workflows through preconfigured mapping files.",
      "description_length": 595,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Dk",
      "library": "lambdapi.export",
      "description": "This module translates Lambdapi terms and declarations into Dedukti syntax, handling identifier escaping, path manipulation, and term formatting. It operates on identifiers, paths, terms, and signatures to generate valid Dedukti output, with a focus on managing symbol declarations and preserving source order during signature conversion. The functionality supports interoperability scenarios where Lambdapi code must be transformed into Dedukti-compatible declarations while avoiding syntax conflicts.",
      "description_length": 502,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Coq",
      "library": "lambdapi.export",
      "description": "This module provides operations for converting parser-level abstract syntax trees into Coq syntax, with support for identifier renaming through external maps or files, handling of Coq-specific primitives (`Set`, `Prop`, `Eq`), and management of qualified identifiers (`Qid`) via ordered maps (`QidMap`). It processes terms, types, commands, and parameters using stream-based output formatting, with capabilities for erasing declarations, encoding symbols, and resolving dependencies like module requirements. Key use cases include formalizing source code in Coq, translating domain-specific languages to Coq's logic, and managing notation or implicit arguments during AST conversion.",
      "description_length": 683,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Export.Rawdk",
      "library": "lambdapi.export",
      "description": "This module translates and formats abstract syntax trees into Dedukti representations through operations like removing term wrappers, partitioning modifiers, and printing commands. It processes parser-level constructs such as terms, assertions, and AC types from the `Parsing.Syntax` module. Specific use cases include transforming and serializing formalized logic or proof terms into Dedukti's syntax for interoperability or code generation.",
      "description_length": 442,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Xtc",
      "library": "lambdapi.export",
      "description": "This component translates simply-typed lambda calculus terms and signatures into structured XML elements like `<TLlhs>` and `<TLrhs>` for the termination competition's XTC format. It processes `Core.Sign.t` signatures and LambdaPi terms, mapping bound variables, symbols, and rewrite rules into XML-compatible representations. The output is designed for termination analysis tools that consume XTC-compliant inputs, particularly for formal verification competitions.",
      "description_length": 466,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Export.Hrs",
      "library": "lambdapi.export",
      "description": "This module translates Lambdapi signatures into the HRS format by encoding lambda, let, and \u03a0 abstractions using specific combinators. It operates on terms and signatures, converting symbols, variables, and rewrite rules into HRS-compatible representations. Concrete use cases include exporting term rewrite systems for confluence checking in the CoCo competition.",
      "description_length": 364,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Export",
      "library": "lambdapi.export",
      "description": "This module translates formal language constructs into various target formats, handling syntax conversion, identifier management, and output formatting. It operates on abstract syntax trees, terms, declarations, and signatures, supporting concrete use cases such as formalizing code in Coq, exporting to HRS for confluence checking, generating Dedukti output, and producing XTC-compliant XML for termination analysis. Each submodule specializes in a specific translation task, ensuring accurate representation and compatibility with external tools.",
      "description_length": 548,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Pratt.Pratt",
      "library": "lambdapi.parsing",
      "description": "This module implements Pratt parsing for resolving infix and prefix operators in terms, using a signature state and environment to identify operators and construct parsed terms. It processes terms without recursing into abstractions or implications, relying on a provided symbol lookup function to resolve operator precedences and associativities. Use it to un-sugar operator applications in a structured term language based on operator definitions in the environment.",
      "description_length": 468,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Syntax.P",
      "library": "lambdapi.parsing",
      "description": "This module constructs `p_term` values representing syntactic elements without positional information. It provides functions to build identifiers, patterns, applications, abstractions, and rules, with support for variable binding and term manipulation. Use cases include creating terms for lambda calculus, pattern matching constructs, and higher-order abstract syntax trees during parsing.",
      "description_length": 390,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsing.DkBasic.WS",
      "library": "lambdapi.parsing",
      "description": "This module implements a data structure for managing a collection of `Parsing.DkBasic.ident` values with operations for adding, removing, and querying elements. It supports efficient lookups, membership checks, and aggregation through functions like `find`, `mem`, `fold`, and `count`. Concrete use cases include tracking identifiers during parsing and maintaining symbol tables with fast access and manipulation.",
      "description_length": 413,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Parser.Dk",
      "library": "lambdapi.parsing",
      "description": "This module provides functions to parse Dedukti syntax from various sources. It supports parsing from an input channel, a file, or a string, producing a stream of commands as an abstract syntax tree. Use cases include reading Dedukti code from files or strings for further processing, such as type checking or evaluation.",
      "description_length": 321,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Parser.Lp",
      "library": "lambdapi.parsing",
      "description": "This module provides functions to parse streams of commands and terms from files, strings, or input channels, specifically for the Lambdapi syntax. It operates on data types such as `Parsing.Syntax.ast`, `Parsing.Syntax.p_term`, and `Parsing.SearchQuerySyntax.query`, producing lazily evaluated streams. Concrete use cases include loading and processing Lambdapi source files, evaluating input strings for interactive tools, and parsing search queries for term indexing systems.",
      "description_length": 478,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsing.DkBasic",
      "library": "lambdapi.parsing",
      "description": "This module defines basic identifier types `ident` and `mident`, along with hashing and creation utilities for managing symbol tables during parsing. It includes operations for equality checking, identifier manipulation, and predefined constants like `underscore`. It is used to track and manage identifiers and module identifiers in Dedukti source files with efficient lookups and set operations.",
      "description_length": 397,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.DkTokens",
      "library": "lambdapi.parsing",
      "description": "This module defines token types and location tracking for parsing Dedukti source files. It includes specific tokens for keywords, identifiers, operators, and structural symbols, along with their source positions. It is used directly by the lexer and parser to represent and process the concrete syntax of Dedukti.",
      "description_length": 313,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsing.LpLexer",
      "library": "lambdapi.parsing",
      "description": "This module provides lexical analysis capabilities for processing LP input files, using SEDLEX-generated character classification tables and partition functions to identify token categories such as identifiers, operators, and literals. It operates on UTF-8 encoded input streams, leveraging lookup tables and integer-range mappings to efficiently categorize characters and manage state transitions during tokenization.",
      "description_length": 418,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.DkLexer",
      "library": "lambdapi.parsing",
      "description": "This module implements a lexer for Dedukti source files, providing functions to tokenize input streams into structured tokens defined in `DkTokens`. It handles low-level parsing tasks like identifying identifiers, strings, and comments, and tracks source code positions for error reporting. Concrete use cases include reading Dedukti syntax elements during compilation or analysis of Dedukti programs.",
      "description_length": 401,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Pretty",
      "library": "lambdapi.parsing",
      "description": "The module provides functions to pretty-print parser-level abstract syntax trees, handling elements like identifiers, paths, terms, rules, and inductive definitions through types such as `p_ident`, `p_term`, and `p_inductive`. It supports converting Dedukti syntax ASTs into Lambdapi syntax representations and formats complex structures including proofs, tactics, commands, and nested constructs like equivalences and proof steps using recursive formatting. This enables readable output generation for formal verification artifacts and structured syntax transformations.",
      "description_length": 571,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Parser",
      "library": "lambdapi.parsing",
      "description": "This module provides functions to parse Lambdapi and Dedukti syntax from input channels, files, or strings, producing lazily evaluated streams of commands or terms. It operates on data types such as `Parsing.Syntax.ast`, `Parsing.Syntax.p_term`, and `Parsing.SearchQuerySyntax.query`, with specific entry points for parsing full files, strings, or individual terms. Concrete use cases include loading and processing source files, evaluating input strings for interactive tools, and parsing search queries for term indexing systems.",
      "description_length": 531,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Package",
      "library": "lambdapi.parsing",
      "description": "This module handles locating and parsing package configuration files (`lambdapi.pkg`) to determine package metadata such as name and root path. It provides functions to read configuration data from a file, search upward for a configuration file starting from a given path, and apply the found configuration. Use cases include package initialization, module path resolution, and installation setup based on the configuration data.",
      "description_length": 429,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Scope",
      "library": "lambdapi.parsing",
      "description": "This module processes parsed terms and patterns by resolving identifiers into scoped core terms, determining bound variables, and validating symbol usage based on the current signature state and environment. It handles parser-level rewrite rules and patterns, converting them into internal representations like `pre_rule` and scoped terms, ensuring correct arity, visibility, and metavariable constraints. Concrete use cases include transforming user-written rewrite rules into executable core rules and validating search patterns during type checking or term manipulation.",
      "description_length": 573,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.DkRule",
      "library": "lambdapi.parsing",
      "description": "This module processes parser-level terms to extract or construct function applications, working with terms and their positional metadata. It decomposes terms into heads and arguments using `get_args`, or builds applications with `add_args`, preserving source positions. It also converts dk-style rules to the lp representation, handling structured term transformations specific to parsing logic.",
      "description_length": 395,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.Pratt",
      "library": "lambdapi.parsing",
      "description": "This module implements Pratt parsing to resolve infix and prefix operators in structured terms, using a signature state and environment to determine operator precedence and associativity. It works with parsed terms and relies on a symbol lookup function to un-sugar operator applications without recursing into abstractions or implications. Concrete use cases include parsing mathematical expressions and custom operator-based syntax in domain-specific languages.",
      "description_length": 463,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.SearchQuerySyntax",
      "library": "lambdapi.parsing",
      "description": "This module defines a structured syntax for building and combining search queries with support for exact or partial matches, intersection and union operations, and path-based filtering. It works with strings, parsed terms, and custom types representing query constraints, sides, and logical operators. Concrete use cases include constructing complex search expressions for code analysis tools or structured data queries where precise term matching and logical composition are required.",
      "description_length": 485,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parsing.LpParser",
      "library": "lambdapi.parsing",
      "description": "This module parses logic programming terms, identifiers, and commands from lexed input. It includes functions to parse standalone terms, search queries, qualified identifiers, and commands, producing structured syntax trees. It is used to translate input streams into program structures for further processing or execution.",
      "description_length": 323,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing.DkParser",
      "library": "lambdapi.parsing",
      "description": "Parses lexical tokens into structured commands using a defined grammar. It processes input through a lexing buffer to generate abstract syntax trees representing commands. This module is used to interpret domain-specific language inputs into executable structures.",
      "description_length": 264,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing",
      "library": "lambdapi.parsing",
      "description": "This module provides parsing and lexical analysis capabilities for Dedukti and LP source files, handling identifier management, tokenization, grammar-based parsing, and structured term transformations. It works with identifiers, tokens, abstract syntax trees, and search queries, supporting concrete use cases such as compiling Dedukti programs, analyzing logic programming code, and managing package configurations. Key operations include lexing input streams, parsing terms and commands, resolving operator precedence, and converting syntax between representations.",
      "description_length": 567,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Common.Path.Set",
      "library": "lambdapi.common",
      "description": "This module implements standard set operations for path collections, including membership testing, union, intersection, and conversion to and from lists and sequences. It operates on sets of path-like elements, enabling functional transformations such as mapping, filtering, and folding. These capabilities are useful for tasks like managing unique module paths, resolving path dependencies, or processing hierarchical path structures in functional workflows.",
      "description_length": 459,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Path.Path",
      "library": "lambdapi.common",
      "description": "This module manipulates paths represented as lists of strings, providing operations for constructing, comparing, and printing paths. It supports concrete use cases such as building and traversing module hierarchies and generating human-readable path representations for debugging. The `pp` function prints paths to a formatter without escaping identifiers, while `compare` enables ordering paths lexicographically.",
      "description_length": 414,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Debug.D",
      "library": "lambdapi.common",
      "description": "This module provides functions for printing and formatting various data types, including primitives like integers and strings, as well as structured types like lists, arrays, pairs, and maps. It supports logging values and exceptions, tracking indentation depth, and custom formatting with separators and surrounding delimiters. Concrete use cases include inspecting intermediate values during execution, formatting complex data structures for logs, and debugging by printing structured output with consistent layout.",
      "description_length": 517,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Path.Map",
      "library": "lambdapi.common",
      "description": "The module provides ordered map operations for key-value associations where keys represent hierarchical module paths and values are polymorphic. It supports key-based transformations, filtering, and ordered traversal, along with conversions to and from sequences of key-value pairs. This structure is particularly useful for managing hierarchical data mappings, such as tracking module-specific metadata or incrementally constructing maps from sequential bindings.",
      "description_length": 464,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Library.LibMap",
      "library": "lambdapi.common",
      "description": "This module manages mappings between module paths and file paths, supporting operations to add, retrieve, and iterate over bindings. It works with a custom type `t` representing the mapping, module paths of type `Common.Path.t`, and string file paths. Concrete use cases include resolving module paths to their corresponding source files during compilation or debugging library structures.",
      "description_length": 389,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Common.Console.State",
      "library": "lambdapi.common",
      "description": "This module manages the imperative state of the typechecker, including verbosity levels, enabled loggers, and boolean flags. It provides operations to save, restore, and apply specific states, supporting context-sensitive configuration changes. Concrete use cases include temporarily adjusting logging settings during typechecking phases or rolling back state after experimental type inference steps.",
      "description_length": 400,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Common.Path",
      "library": "lambdapi.common",
      "description": "This module works with paths represented as lists of strings, offering operations to construct, compare, and print them. It includes dedicated set and map structures for managing collections of paths, supporting tasks like dependency resolution, hierarchical data mapping, and module path tracking. Specific functions enable path printing without identifier escaping, lexicographic comparison, and creation of restricted \"ghost\" paths.",
      "description_length": 435,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Logger",
      "library": "lambdapi.common",
      "description": "This module creates and manages loggers with typed output formatting, enabling fine-grained control over logging output. It supports operations to enable/disable loggers by key, set default logging states, and retrieve active loggers or summary information. Concrete use cases include selectively logging debug information for different components of a program using character keys and formatting log output consistently across those components.",
      "description_length": 445,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Escape",
      "library": "lambdapi.common",
      "description": "This module handles string manipulation for identifiers that may be escaped using the `\"{|...|}\"` syntax. It provides operations to escape a string, check if it is already escaped, and remove escapes, along with functions to safely prepend or append to identifiers while preserving their escaped status. These functions are useful when generating or transforming code that requires identifier mangling, such as in compilers or macro systems.",
      "description_length": 441,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Error",
      "library": "lambdapi.common",
      "description": "This module handles warning and error reporting with formatted output, including position information. It supports operations to print warnings, build fatal error messages, and raise exceptions with structured formatting. Use it to report parse-time errors, suppress warnings during specific computations, or terminate with diagnostic messages tied to source positions.",
      "description_length": 369,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Pos",
      "library": "lambdapi.common",
      "description": "This module handles source code position tracking and manipulation, offering operations to manage UTF-8 line/column numbers, convert Lexing positions, and adjust ranges via shifting or concatenation. It works with structured position data that supports optional locations, located values, and comparisons, while enabling string formatting with custom delimiters and escapes. Key use cases include error reporting workflows that extract and format file content based on positions, and integrating lexing/parsing tools with positional context.",
      "description_length": 541,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Debug",
      "library": "lambdapi.common",
      "description": "This module provides functions for logging values, measuring execution time, and formatting structured data like lists, pairs, and maps for debugging. It includes utilities to track and print timing information per task category such as parsing or typing, and to inspect streams while iterating. Concrete use cases include debugging intermediate computation results, profiling performance-critical sections, and formatting complex data structures for readable log output.",
      "description_length": 471,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Common.Console",
      "library": "lambdapi.common",
      "description": "Manages verbosity levels, logging output, and boolean flags for controlling program behavior. It supports conditional output based on verbosity, flag registration for runtime configuration, and resetting to default settings. Useful for controlling debug output during typechecking or managing experimental features via flags.",
      "description_length": 325,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Library",
      "library": "lambdapi.common",
      "description": "This module manages library path mappings and file conversions for a compilation system. It provides operations to bind module paths to source files, resolve module paths to file paths, validate file extensions, and track library roots and binary output paths. Concrete use cases include mapping module names to source files during compilation and converting between module and file paths with proper extensions.",
      "description_length": 412,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common",
      "library": "lambdapi.common",
      "description": "This module organizes core utilities for program configuration, debugging, error reporting, string escaping, path management, and source position handling. It includes concrete tools for logging with verbosity control, tracking execution time, formatting structured data, managing library paths, escaping identifiers, and reporting errors with positional context. Use it to implement typecheckers, compilers, or interpreters that require precise diagnostics, configurable output, and robust path and string manipulation.",
      "description_length": 520,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Tree.CP.PSet",
      "library": "lambdapi.core",
      "description": "This module provides immutable set operations for managing collections of integer pairs, including membership checks, union, intersection, difference, and transformations like mapping and filtering. It supports efficient traversal and construction through conversions to ordered sequences and lists, facilitating ordered processing of elements. These capabilities are optimized for compiling pattern-matching conditions into decision trees, where precise tracking and manipulation of integer-pair constraints are critical for rule prioritization and conflict resolution.",
      "description_length": 570,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Tree_type.TC",
      "library": "lambdapi.core",
      "description": "This module represents atomic pattern constructors for decision trees, with support for symbols, bound variables, and type placeholders. It provides operations for printing and comparing constructors, used in pattern matching and term manipulation. Concrete use cases include tracking variable bindings and symbol arities during decision tree construction and analysis.",
      "description_length": 369,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Tree.CP",
      "library": "lambdapi.core",
      "description": "This module manages condition pools for tracking and resolving constraints during pattern-matching compilation. It supports operations to register and query non-linearity and free variable constraints on integer slots, and to remove or select conditions from a pool. It is used to enforce term convertibility and variable scoping requirements when compiling pattern-matching rules into decision trees.",
      "description_length": 401,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.SymSet",
      "library": "lambdapi.core",
      "description": "This module implements an ordered, immutable set structure for symbolic identifiers, supporting operations like union, intersection, and difference alongside transformations such as mapping and filtering. It works with sets of `Core.Term.sym` elements, leveraging structural equality and ordering for comparisons, and provides utilities to convert sets to ordered sequences or lists. It is particularly useful for analyzing or manipulating collections of variables in term representations, such as tracking free variables or normalizing binder contexts.",
      "description_length": 553,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Term.Raw",
      "library": "lambdapi.core",
      "description": "This module provides a basic pretty-printing function for debugging terms represented using the internal structure defined in `Core.Term`. It works directly with the `term` type, leveraging the `Bindlib` library's abstractions for handling binders. A concrete use case is inspecting the structure of terms during development or logging errors.",
      "description_length": 343,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.Sym",
      "library": "lambdapi.core",
      "description": "This module implements sets and maps keyed by term symbols, providing operations like membership testing, insertion, and lookup. It works directly with the `Core.Term.sym` type, which represents symbols in the term language. Concrete use cases include tracking variable bindings and managing symbol-based metadata during term manipulation or analysis.",
      "description_length": 351,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Term.Meta",
      "library": "lambdapi.core",
      "description": "This module implements sets and maps keyed by metavariables, using the unique identifiers of `Core.Term.meta` values. It provides standard collection operations like insertion, lookup, and iteration, specifically tailored for managing metavariable environments. Concrete use cases include tracking unification variables or managing scoped bindings during term traversal and transformation.",
      "description_length": 389,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Tree.CM",
      "library": "lambdapi.core",
      "description": "This module provides operations to construct and manipulate clause matrices for compiling pattern matching problems into decision trees. It handles matrix transformations, column scoring, and clause specialization over terms, patterns, substitutions, and binder structures, enabling efficient term analysis and rewriting rule compilation. Key applications include wildcard pattern handling, default case generation, and propagating term conditions during matching.",
      "description_length": 464,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.VarSet",
      "library": "lambdapi.core",
      "description": "This module provides efficient, immutable set operations for managing collections of term variables (`Core.Term.tvar`), supporting standard manipulations like union, intersection, and filtering alongside ordered traversal via sequence conversions. It enables use cases such as tracking free variables in term transformations, optimizing binder-related operations with `Bindlib`, and bulk updates through sequence-driven construction. Key features include performance-focused immutability, physical equality checks, and seamless transitions between sets and ordered sequences for structured analysis.",
      "description_length": 599,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.VarMap",
      "library": "lambdapi.core",
      "description": "This module implements a specialized ordered map structure for term variables, supporting efficient key-based operations like insertion, lookup, and modification, along with derived transformations such as merging, filtering, and ordered traversal. It works with maps that bind `Core.Term.tvar` keys to arbitrary values, maintaining key ordering to enable range queries and deterministic iteration. Typical use cases include managing variable environments during term rewriting, accumulating variable-value associations in analysis passes, or processing ordered collections of term bindings.",
      "description_length": 591,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.Var",
      "library": "lambdapi.core",
      "description": "This module implements sets and maps for term variables, using the `tvar` type from `Core.Term`. It provides operations like insertion, lookup, and comparison for managing collections of variables in term representations. These structures are used to track and manipulate variable bindings in higher-level term transformations.",
      "description_length": 327,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Term.MetaMap",
      "library": "lambdapi.core",
      "description": "This module provides operations for managing polymorphic maps where keys are metadata identifiers, supporting insertion, deletion, ordered traversal, and value transformations via functions like `add`, `merge`, and `map`. It handles associations with list-valued entries, enabling efficient merging, predicate-based filtering, and ordered key inspections, with utilities to convert between maps, sequences, and lists. These capabilities are particularly useful for processing structured term metadata with ordered relationships, such as tracking variable bindings or aggregating annotations during term transformations.",
      "description_length": 619,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Tree_type.TCMap",
      "library": "lambdapi.core",
      "description": "This module implements a polymorphic map structure specialized for atomic pattern constructors as keys, enabling efficient associative operations like insertion, deletion, and lookup alongside ordered traversals and transformations. It supports value manipulation through list-accumulating updates, filtering, and sequence-based construction while maintaining compatibility with decision tree workflows involving rule-based pattern matching. Key applications include managing symbolic decision rules, compiling pattern-matching logic, and handling hierarchical data transformations where atomic keys represent structural or semantic primitives.",
      "description_length": 644,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Ctxt",
      "library": "lambdapi.core",
      "description": "This module manages typing contexts, providing operations to query variable types, retrieve definitions, and manipulate terms with respect to those contexts. It supports abstraction, product construction, and term unfolding using context-bound variables, working with contexts, terms, and boxed terms. Use cases include type checking, term normalization, and context-based term transformation in a logical or programming language framework.",
      "description_length": 440,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Inverse",
      "library": "lambdapi.core",
      "description": "This module computes the inverse image of a term with respect to an injective function, using cached graph representations of symbol relationships. It provides operations to retrieve inverse mappings for constant and product terms, leveraging cached versions of symbol graphs to efficiently determine function inverses. Use cases include term rewriting and symbolic manipulation where injective function inverses are required, such as in formal verification or automated reasoning tasks.",
      "description_length": 487,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Eval",
      "library": "lambdapi.core",
      "description": "This module evaluates and converts terms to various normal forms, including weak head-normal, head-normal, and strong normal forms, using customizable reduction strategies and context-aware simplification. It supports operations like equality checking modulo reductions, unfolding symbol definitions, and controlled normalization with tags to disable specific reduction steps. Concrete use cases include normalizing lambda terms, checking term convertibility in type-checking processes, and simplifying expressions during proof normalization or program optimization.",
      "description_length": 566,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Ghost",
      "library": "lambdapi.core",
      "description": "This module defines a ghost signature used by the kernel, exposing operations to check membership and iterate over ghost symbols. It works with symbol and path data types to manage undefined user symbols. Concrete use cases include tracking and processing symbols that are referenced but not defined in the current context.",
      "description_length": 323,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Builtin",
      "library": "lambdapi.core",
      "description": "This module manages built-in symbols by providing operations to register and retrieve them, along with associated type-checking functions. It works with symbol states, string-named builtins, and term types, using a hash table to map symbols to checking functions. It is used to enforce correct typing and usage of built-in symbols during signature checking, raising fatal errors when mismatches occur.",
      "description_length": 401,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Sign",
      "library": "lambdapi.core",
      "description": "This module provides operations for managing symbol signatures in formal logic systems, focusing on symbol resolution, dependency tracking, and serialization. It works with inductive type definitions (`ind_data`), symbol tables (`t`) with metadata, and supports use cases like modular development, safe cross-file symbol referencing, and handling complex dependencies between logical constructs.",
      "description_length": 395,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Env",
      "library": "lambdapi.core",
      "description": "This module manages variable scoping environments as associative lists mapping variable names to typed terms and optional definitions. It supports operations to construct and deconstruct dependent product types, bind variables, and apply terms to environments. Concrete use cases include building lambda abstractions from environments, unbinding products into variables, and converting environments into contexts or arrays of typed terms.",
      "description_length": 438,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Unif",
      "library": "lambdapi.core",
      "description": "Simplifies unification constraints in a given problem, returning `false` if any constraint is unsatisfiable. Works directly with `Core.Term.problem` to resolve metavariables, optionally enforcing type-checking during instantiation. Useful for implementing type inference systems where constraint solving must be attempted without raising exceptions.",
      "description_length": 349,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Print",
      "library": "lambdapi.core",
      "description": "This module provides operations to format and display Core AST terms, contexts, constraints, rules, and related entities such as symbols, variables, and notations. It includes configurable options to control verbosity in output and utilities for handling qualified names, paths, and numeric conversions. These functions are primarily used for logging and generating diagnostic feedback during type-checking and conversion testing processes.",
      "description_length": 440,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Unif_rule",
      "library": "lambdapi.core",
      "description": "This module defines symbols and operations for handling unification rules in a ghost signature. It provides the equivalence symbol `\u2261`, a cons operator `;` for combining constraints, and functions to unpack and check membership of terms in the signature. It is used to represent and manipulate sequences of equivalence constraints during unification.",
      "description_length": 350,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.LibMeta",
      "library": "lambdapi.core",
      "description": "This module provides operations to create, manage, and manipulate metavariables within a term problem. It includes functions to generate fresh metavariables with specified types and contexts, set their values, and check their occurrences in terms. These operations work with data types such as `Core.Term.problem`, `Core.Term.meta`, `Core.Term.ctxt`, and boxed variants like `Core.Term.tbox` and `Bindlib.box`. Concrete use cases include generating unique metavariables during type inference, binding metavariables in rewriting rules, and checking metavariable dependencies in term structures.",
      "description_length": 593,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Infer",
      "library": "lambdapi.core",
      "description": "This module performs type inference and checking for terms in a given context, refining terms and determining their types or checking against expected types. It operates on terms and contexts from the Core.Term module, handling metavariables and constraints during the inference process. Use cases include validating term correctness in a typed language, supporting interactive proof assistants, or enabling type-directed term transformations.",
      "description_length": 443,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Sig_state",
      "library": "lambdapi.core",
      "description": "This module manages the state of a signature during term processing, providing operations to manipulate symbols, notations, and open modules within that state. It works with the `sig_state` record, which tracks the current signature, symbols in scope, path aliases, builtins, and open paths, along with functions like `add_symbol`, `add_notation`, `open_sign`, and `find_sym` to modify and query the state. Concrete use cases include resolving qualified identifiers to symbols during type checking and maintaining scoping information when importing or opening modules.",
      "description_length": 568,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Term",
      "library": "lambdapi.core",
      "description": "This module provides operations for constructing, analyzing, and transforming terms in a binding-aware formal system, including abstraction, application, pattern matching, and unification. It works with terms represented using the Bindlib library to manage binders, alongside variables, symbols, metavariables, and structured types like products and abstractions, supported by set/map modules for efficient manipulation. These tools are used in scenarios like formal verification, compiler intermediate representations, or symbolic computation where precise term handling and binder management are critical.",
      "description_length": 607,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Coercion",
      "library": "lambdapi.core",
      "description": "This module implements term coercion logic using a designated symbol to manage coercion rules. It provides operations to define coercion relationships between types and to construct coercion terms that convert values from one type to another. Direct use cases include building type conversion mechanisms and managing subtyping relationships in term-level computations.",
      "description_length": 368,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Tree_type",
      "library": "lambdapi.core",
      "description": "This module defines data structures and operations for decision trees used in pattern matching and term rewriting. It includes types for representing decision tree nodes with conditions on term convertibility and variable binding, along with utilities for tracking storage requirements during tree evaluation. The module supports concrete tasks such as analyzing term structure, enforcing matching constraints, and optimizing rule application in rewriting systems.",
      "description_length": 464,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.LibTerm",
      "library": "lambdapi.core",
      "description": "This module implements term analysis and transformation operations such as checking term kinds, extracting variables, and manipulating binders. It works with terms, binders, and contexts to support tasks like variable validation, implicit argument removal, and name generation. Specific use cases include processing lambda terms during type checking and preparing terms for substitution or normalization.",
      "description_length": 404,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core.Tree",
      "library": "lambdapi.core",
      "description": "This module compiles pattern-matching rules into decision trees using Maranget's method, handling transformations through condition pools and clause matrices. It operates on terms, patterns, and substitutions, organizing them into decision trees that guide efficient rule application during evaluation. Concrete uses include optimizing pattern matching for term rewriting systems by generating condition-based decision paths and managing variable constraints.",
      "description_length": 459,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Core.Version",
      "library": "lambdapi.core",
      "description": "This module provides a single value `version` that returns a string containing version information. It works with string data to expose details about the current software version. Use this to retrieve and display version metadata in applications or during debugging.",
      "description_length": 266,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Core",
      "library": "lambdapi.core",
      "description": "This module provides core functionalities for managing built-in symbols, type coercions, typing contexts, evaluation strategies, and term inference. It operates on symbols, terms, contexts, environments, and metavariables, supporting concrete tasks such as type checking, term normalization, lambda abstraction binding, and constraint solving. Use cases include formal verification, interactive proof assistance, and language implementation where precise term manipulation and type management are essential.",
      "description_length": 507,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pure.Tactic",
      "library": "lambdapi.pure",
      "description": "This module defines an abstract representation of a tactic, primarily used for handling proof items in the context of the LSP interface. It provides operations to compare tactics for equality, retrieve their source positions, and format them as strings. These capabilities support precise manipulation and reporting of proof steps in interactive theorem proving environments.",
      "description_length": 375,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pure.ProofTree",
      "library": "lambdapi.pure",
      "description": "This module represents proof trees with a focus on structural comparison and traversal. It supports operations to check equality of proof trees and to fold over their nodes, accumulating values based on tactics and their positions. It is used to analyze and manipulate structured proofs in the context of theorem proving and LSP-based proof assistants.",
      "description_length": 352,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pure.Command",
      "library": "lambdapi.pure",
      "description": "Represents top-level commands in a document, enabling comparison, position retrieval, and formatted output. Works with command structures and positional data. Used for managing and displaying individual commands in a language server protocol context.",
      "description_length": 250,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pure",
      "library": "lambdapi.pure",
      "description": "This module processes and manages commands, tactics, and proof states for a language server protocol interface. It parses text into commands, tracks proof goals, and evaluates tactics within a proof context. It supports concrete operations like command execution, proof tree traversal, and symbol lookup, used for interactive theorem proving and error reporting.",
      "description_length": 362,
      "index": 127,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 132,
    "meaningful_modules": 128,
    "filtered_empty_modules": 4,
    "retention_rate": 0.9696969696969697
  },
  "statistics": {
    "max_description_length": 765,
    "min_description_length": 120,
    "avg_description_length": 442.7578125,
    "embedding_file_size_mb": 1.8556890487670898
  }
}