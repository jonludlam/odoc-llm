{
  "package": "biotk",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 155,
  "creation_timestamp": "2025-07-15T23:33:59.199887",
  "modules": [
    {
      "module_path": "Biotk_croquis.Croquis.Font",
      "library": "biotk.croquis",
      "description": "This module defines font metrics and provides access to predefined font styles. It supports operations to retrieve bounding box dimensions and baseline metrics for fonts, including ascender, descender, and min/max coordinates. Concrete use cases include rendering text with precise alignment and layout in graphical applications using specific fonts like DejaVu Sans Mono or Liberation Sans in various styles.",
      "description_length": 409,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk_croquis.Croquis.Colormap",
      "library": "biotk.croquis",
      "description": "This module defines colormaps as arrays of colors and provides functions to generate specific color gradients. It includes operations to create grayscale colormaps of a given length and HSL-based colormaps with fixed saturation and lightness. These colormaps are used to map numerical data to colors in visualizations such as heatmaps or plots.",
      "description_length": 344,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_croquis.Croquis.Viewport",
      "library": "biotk.croquis",
      "description": "This module defines a coordinate mapping and rendering context for 2D plots. It provides functions to create a viewport with specified axis ranges and labels, draw axes, and transform coordinates from data space to screen space. It is used to visualize data points and annotations within a bounded area, such as plotting experimental results or geometric shapes.",
      "description_length": 362,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk_croquis.Croquis.Axis",
      "library": "biotk.croquis",
      "description": "This module defines operations for creating and rendering axes with specified ranges and labels. It provides functions to draw horizontal and vertical axes, including tick marks, using a projection function to map data coordinates to screen coordinates. The module works with axis objects that store minimum and maximum values, and is used for visualizing plots in a 2D space.",
      "description_length": 376,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_croquis.Croquis.Plot",
      "library": "biotk.croquis",
      "description": "This module creates visual elements for plots, including points, lines, horizontal and vertical references, and function graphs. It supports geometric shapes defined by coordinates and styling parameters like color, thickness, and markers. Use it to build custom 2D visualizations from numerical data or mathematical functions.",
      "description_length": 327,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk_croquis.Croquis",
      "library": "biotk.croquis",
      "description": "This library provides tools for creating 2D visualizations with support for text rendering, color mapping, and coordinate transformations. It includes data types for fonts, colormaps, axes, and graphical elements, enabling precise control over layout and styling. Users can define viewports with labeled axes, map data to screen coordinates, generate color gradients, and render points, lines, and shapes with custom styles. Specific applications include scientific plotting, heatmap generation, and interactive graphical interfaces using predefined fonts and scalable visual elements.",
      "description_length": 585,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_croquis",
      "library": "biotk.croquis",
      "description": "This library enables the creation of detailed 2D visualizations with support for text rendering, color mapping, and coordinate transformations. It provides data types for graphical elements, fonts, colormaps, and axes, along with operations to define viewports, map data to screen space, and render styled points, lines, and shapes. Users can generate heatmaps, scientific plots, and interactive interfaces with labeled axes and scalable graphics. Specific capabilities include custom color gradient generation and precise layout control using defined styling options.",
      "description_length": 568,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes.Pipe.Make.Monad_infix",
      "library": "biotk.pipes",
      "description": "Implements monadic bind for pipeline transformations, enabling sequential composition of pipe-based computations. Works with pipe values parameterized by input, output, and result types. Useful for chaining data processing stages where each step consumes output from the previous and produces new values incrementally.",
      "description_length": 318,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes.Pipe.Make",
      "library": "biotk.pipes",
      "description": "This module combines stream processing with monadic composition to build and manipulate pipelines that handle data incrementally. It defines polymorphic pipe types representing streams with distinct input, output, and return types, and supports operations like mapping, filtering, folding, and resource-aware processing. The child module enables sequential pipeline assembly through monadic bind, letting developers chain transformations that propagate state and data across stages. Example uses include parsing structured input, transforming I/O streams, and routing data through conditional logic with precise resource control.",
      "description_length": 629,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk_pipes.Pipe.S-Monad_infix",
      "library": "biotk.pipes",
      "description": "Implements monadic composition for pipeline transformations, allowing sequential chaining of pipeline stages where each stage consumes input of type `'i` and `'a`, producing output of type `'o` and `'b`. Works with pipeline values parameterized over input, output, and result types. Enables building complex data processing chains from simpler components, such as parsing, transforming, and serializing data streams.",
      "description_length": 416,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes.Pipe.S",
      "library": "biotk.pipes",
      "description": "This module implements a composable pipeline system for streaming data, supporting operations like `await` to consume values, `yield` to produce values, and `compose` to chain pipelines. It works with input and output data streams, handling values of arbitrary types, and supports transformations like `map`, `filter`, and `fold`, along with resource management via `bracket`. Concrete use cases include processing bioinformatics data streams, parsing file inputs incrementally, and implementing custom data transformation chains.",
      "description_length": 530,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes.Pipe.Monad",
      "library": "biotk.pipes",
      "description": "Implements monadic composition for pipeline stages, enabling sequential data processing workflows. Works with values wrapped in a pipeline type `'a t`, allowing chaining of operations while handling side effects. Useful for building data transformation chains where each step depends on the result of the previous.",
      "description_length": 314,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes.Pipe",
      "library": "biotk.pipes",
      "description": "This module provides a monadic framework for constructing streaming data pipelines, combining direct support for I/O channels and byte/line-based processing with a rich set of transformation operations. It defines polymorphic pipe types that model streams with distinct input, output, and result types, and supports core operations like `map`, `filter`, `fold`, `await`, and `yield`, enabling both simple and complex data transformations. Submodules extend this foundation with enhanced composition capabilities, resource management via `bracket`, and monadic chaining of pipeline stages that propagate state and handle side effects. Example uses include parsing structured input incrementally, routing and transforming I/O streams, and implementing custom processing chains for applications like bioinformatics or log analysis.",
      "description_length": 828,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk_pipes",
      "library": "biotk.pipes",
      "description": "This module implements a streaming pipeline system with polymorphic pipe types that model streams with distinct input, output, and result types. It supports transformation operations like `map`, `filter`, `fold`, `await`, and `yield`, enabling incremental parsing, I/O stream routing, and custom processing chains. Submodules enhance composition, resource management, and state propagation for applications such as bioinformatics and log analysis. Specific examples include transforming structured input line-by-line and chaining pipeline stages with side-effect handling.",
      "description_length": 572,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.FeatureCounts.Tsv.Fields.Direct",
      "library": "biotk",
      "description": "This module processes TSV data representing genomic features with fields like ID, chromosome, start/end positions, strand, length, and count. It provides iteration, folding, filtering, mapping, and validation operations over these fields, enabling transformations and analysis of feature attributes. Concrete use cases include parsing and manipulating feature count data for genomic intervals, applying filters to regions, or aggregating counts across datasets.",
      "description_length": 461,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Ucsc_genome_browser.Chrom_size.Fields.Direct",
      "library": "biotk",
      "description": "This module provides operations to iterate over, fold, map, and query chromosome size records by their `chrom` (string) and `size` (integer) fields. It supports concrete use cases like validating chromosome names, transforming size values, or collecting field-specific data into lists. Functions like `map` and `to_list` enable direct manipulation and extraction of genomic dataset components.",
      "description_length": 393,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.FeatureCounts.Tsv.Fields",
      "library": "biotk",
      "description": "This module provides accessors and operations for working with TSV records representing genomic features, exposing individual fields like `id`, `chr`, `lo`, `hi`, `strand`, `length`, and `count` as first-class values. It supports structured creation, transformation, and inspection of these records through functions like `create`, `map`, `iter`, and `fold`, enabling precise manipulation of genomic feature count data. Child modules extend this functionality with operations for parsing, filtering, mapping, and validating collections of these records, supporting tasks like processing feature count output files, applying region-based filters, or aggregating counts across samples. Together, the module and its submodules enable a structured and type-safe approach to handling genomic interval data with associated metadata and numerical counts.",
      "description_length": 847,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Set.Elt",
      "library": "biotk",
      "description": "This module defines serialization and deserialization functions for converting between S-expressions and genomic location (`Biotk.GLoc.t`) values. It also provides a comparator for ordering genomic locations, enabling their use in set and map data structures. These functions are essential for persisting and comparing genomic intervals in bioinformatics workflows.",
      "description_length": 365,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Set.Diff",
      "library": "biotk",
      "description": "This module represents differences between sets of genomic locations, supporting operations to create, apply, and serialize diffs. It works with sets of `Biotk.GLoc.t` values, using a specific comparator for ordering. Concrete use cases include computing and applying incremental changes between genomic location sets, such as tracking additions or removals across dataset versions.",
      "description_length": 382,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Map.Key",
      "library": "biotk",
      "description": "This module defines the key operations for using genomic locations (`Biotk.GLoc.t`) as keys in maps. It includes functions for converting keys to and from S-expressions and provides a comparator for ordering keys. It is used to create and manipulate maps where keys are genomic intervals or locations.",
      "description_length": 301,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Bed.Bed5.Item",
      "library": "biotk",
      "description": "This module handles BED5 format items, which represent genomic features with five specific fields. It provides functions to convert between BED5 items and lines in the file format, extract genomic locations, and convert to the simpler BED4 format. Use this module when parsing or generating BED5 files for genomic analysis tasks like annotating regions of interest.",
      "description_length": 365,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Bed.Bed4.Item",
      "library": "biotk",
      "description": "This module represents genomic features in the BED4 format, which includes four fields: chromosome, start, end, and name. It provides functions to extract a genomic location, convert a line from a BED4 file into a structured item, and serialize the item back into a string. It is used for parsing and generating BED4 files to analyze or manipulate genomic intervals with associated names.",
      "description_length": 388,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.Bed3.Item",
      "library": "biotk",
      "description": "This module represents genomic features in the BED3 format, which consists of three fields: chromosome, start, and end positions. It provides functions to convert between this format and genomic location (`GLoc.t`) and to parse or serialize lines from BED files. It is used for reading, manipulating, and writing basic genomic intervals in BED3 format.",
      "description_length": 352,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.GLoc.Map.Provide_hash",
      "library": "biotk",
      "description": "Implements hash folding for GLoc.Map.t structures by leveraging a key-specific hashing function. Accepts a key module with hash support and extends it to handle map values. Useful for enabling efficient hashing of genomic location maps where keys are biological regions or coordinates.",
      "description_length": 285,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Map.Provide_bin_io",
      "library": "biotk",
      "description": "This module implements binary serialization and deserialization for maps with keys of type `Key` and arbitrary values. It provides functions to compute the binary shape, size, and to read/write map values in binary format, supporting version-controlled deserialization through `__bin_read_t__`. Concrete use cases include persisting genome location maps to disk or transmitting them over a network in a compact, efficient binary representation.",
      "description_length": 444,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Idr.Broad_output.Row",
      "library": "biotk",
      "description": "This module defines a data structure for representing rows in Broad Institute's output format used by the IDR (Irreproducible Discovery Rate) program. It includes fields for genomic coordinates, statistical scores, and strand information, enabling precise annotation of genomic regions with associated significance metrics. The module supports operations for accessing and manipulating these structured records, which are commonly used in genomic data analysis workflows.",
      "description_length": 471,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ucsc_genome_browser.Chrom_size.Fields",
      "library": "biotk",
      "description": "This module organizes chromosome size records into structured data with explicit `chrom` and `size` fields, enabling creation, transformation, and analysis through functions like `map`, `fold`, and `filter`. It supports direct manipulation of genomic datasets, such as parsing input files, normalizing size values, or extracting chromosome names into lists. Submodule operations allow field-specific iteration and aggregation, for example validating chromosome names or summing total genome size. Together, the module and its submodules provide a streamlined interface for processing genome-scale data with precise field access and transformation capabilities.",
      "description_length": 660,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Idr.Narrow_output.Row",
      "library": "biotk",
      "description": "This module defines a data type `t` representing a row in a narrowPeak file, with fields for genomic coordinates, peak scores, strand, signal values, and IDR statistics. It provides functions to access and manipulate these fields, including extracting genomic locations as `Biotk.GLoc.t` values. Use cases include parsing and processing narrowPeak data from the IDR program for downstream analysis like peak annotation or visualization.",
      "description_length": 436,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.GLoc.Set.Provide_bin_io",
      "library": "biotk",
      "description": "Implements binary serialization and deserialization for sets of genomic locations. Works directly with `Biotk.GLoc.Set.t` values, enabling efficient disk storage and network transmission. Useful for persisting large collections of genomic intervals or exchanging them between processes.",
      "description_length": 286,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.GLoc.Set.Provide_of_sexp",
      "library": "biotk",
      "description": "Converts S-expressions into sets of genomic locations, parsing each element according to the `Elt` module's sexp conversion. Works directly with `Sexplib0.Sexp.t` input and produces `Biotk.GLoc.Set.t` values. Useful for deserializing stored or transmitted genomic location sets from textual S-expression representations.",
      "description_length": 320,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Set.Provide_hash",
      "library": "biotk",
      "description": "This module implements hash-related operations for sets of genomic locations. It provides `hash_fold_t` and `hash` functions to compute hash values for set structures. The module is used when genomic location sets need to be stored in hash tables or compared via hashing.",
      "description_length": 271,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.GLoc.Map.Diff",
      "library": "biotk",
      "description": "This module handles differential updates for genomic location maps by serializing and deserializing differences between map states. It supports operations to retrieve, apply, and construct diffs using sexp representations, specifically working with `Biotk.GLoc.Map` structures and their derived types. Concrete use cases include tracking changes in genomic interval mappings and merging incremental updates in a version-controlled bioinformatics workflow.",
      "description_length": 455,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.GFF2.Item",
      "library": "biotk",
      "description": "Handles parsing and unparsing of individual GFF2 (GTF) feature records, including attributes. Works with `Biotk.Gff.item` and `Biotk.Line.t`, supporting direct conversion between in-memory representations and GFF2-formatted strings. Useful for reading and writing transcript annotations such as exons, genes, and transcripts in GTF format.",
      "description_length": 339,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Map.Provide_of_sexp",
      "library": "biotk",
      "description": "Converts S-expressions into maps with globally located keys, using a specified key conversion function. It operates on `Sexplib0.Sexp.t` inputs and produces maps where keys are validated and associated with their source locations. This is useful for parsing configuration or data files where each key must be uniquely identified and tracked in the input source.",
      "description_length": 361,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Gff.GFF3.Item",
      "library": "biotk",
      "description": "Handles parsing and unparsing of individual GFF3 records and comments from lines of text. Works with `item` type representing either a GFF3 record or a comment string. Used to convert between textual GFF3 entries and their structured representation for processing annotation data.",
      "description_length": 280,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.Bed6.Item",
      "library": "biotk",
      "description": "This module provides functions to parse and manipulate BED6 format lines into structured items and extract genomic location data. It operates on `t` values representing BED6 records, with access to chromosome, start, end, name, score, and strand fields. Use it to convert between BED6 lines and typed records or to access specific genomic coordinates from BED6 data.",
      "description_length": 366,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Alphabet.S",
      "library": "biotk",
      "description": "This module defines an alphabet as a collection of characters with operations to convert between characters and alphabet elements. It supports checking membership via `of_char`, converting elements to their character representation with `to_char`, and enumerating all elements in the alphabet. Concrete use cases include representing DNA nucleotides, amino acids, or other fixed character-based biological sequences with safe conversions and cardinality tracking.",
      "description_length": 463,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.S",
      "library": "biotk",
      "description": "This module defines operations for working with BED format genomic data, providing types to represent BED records and functions to load and save them. It supports loading from and saving to files, with options to parse into lists or indexed maps. Concrete use cases include processing genome annotations, handling intervals for sequencing data, and integrating with genome browsers.",
      "description_length": 382,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.Item",
      "library": "biotk",
      "description": "This module processes individual lines of BED-formatted data, converting them to and from a structured representation. It handles genomic location information paired with raw string fields, enabling precise manipulation of BED records. Use it to parse BED lines into typed genomic intervals or serialize intervals back to BED lines.",
      "description_length": 332,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GAnnot.Selection",
      "library": "biotk",
      "description": "This module manages collections of non-overlapping genomic regions, supporting operations such as union, intersection, difference, and membership testing. It works with genomic locations represented as ranges paired with sequence identifiers, and tracks the size of region sets. Use it to efficiently compute overlaps between regions, filter genomic features, or merge interval data from sequencing experiments.",
      "description_length": 411,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Profile",
      "library": "biotk",
      "description": "This module represents a scoring profile for sequence alignment, where each position in the profile assigns a score to a specific symbol. It provides operations to retrieve the score for a given symbol at a position and to obtain the score for a missing symbol. The module works with symbolic data types, such as nucleotides or amino acids, and is used in alignment algorithms that require position-specific scoring matrices.",
      "description_length": 425,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bam.Header",
      "library": "biotk",
      "description": "This module converts between BAM and SAM header formats, providing direct transformations to and from the respective header types. It operates specifically on BAM header data structures and their SAM equivalents. Use this module when parsing or generating BAM files that require header translation to comply with SAM specifications.",
      "description_length": 332,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.Bed6",
      "library": "biotk",
      "description": "This module handles BED6 format parsing and serialization for genomic features, supporting operations like loading from and saving to files, mapping by genomic location, and extracting structured data. It works with typed records containing chromosome, start, end, name, score, and strand fields, enabling tasks like annotation analysis and feature filtering. The child module provides utilities to convert between BED6 lines and structured items, and to extract genomic coordinates from BED6 records. Together, they allow efficient manipulation of genomic intervals while preserving format-specific metadata.",
      "description_length": 609,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Cisbp.Motif",
      "library": "biotk",
      "description": "This module parses position weight matrices from the CisBP database, converting them into a standard matrix format. It processes motif files into float arrays and constructs PWMs for sequence analysis. Use cases include loading and transforming motif data from CisBP for downstream bioinformatics workflows.",
      "description_length": 307,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Dna_sequence.Parser",
      "library": "biotk",
      "description": "Implements parsing and statistical analysis of DNA sequences with support for GC content-based scoring. Computes cumulative distribution functions, average CDFs, and score bounds for given false positive rates and GC levels. Used to analyze sequence quality metrics and filter DNA segments based on statistical thresholds.",
      "description_length": 322,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.Annotation",
      "library": "biotk",
      "description": "Processes GFF2 and GFF3 annotation data into structured gene and transcript representations. It converts raw GFF items into an annotation structure and extracts gene records with associated transcripts, handling attribute labels for gene and transcript IDs. Useful for parsing transcriptome annotations from Ensembl or similar genomic databases into manipulatable gene models.",
      "description_length": 376,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Encode.Experiment_list",
      "library": "biotk",
      "description": "Handles parsing of ENCODE experiment lists from string input, providing structured access to experiment items. Works directly with string-encoded data and converts it into a list of experiment entries. Used to extract and process experiment metadata from ENCODE database responses.",
      "description_length": 281,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.S",
      "library": "biotk",
      "description": "This module provides operations to construct and evaluate weighted finite automata for sequence analysis. It supports building expressions from profiles, sequences, and gaps, and computes scores and automata for pattern matching. It is used for tasks like motif scanning in bioinformatics, where patterns are matched against strings with weighted scores.",
      "description_length": 354,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Score",
      "library": "biotk",
      "description": "This module defines a score type `t` with arithmetic and comparison operations, including addition, comparison, equality checks, and min/max selection. It supports working with numerical scores in contexts like sequence alignment where scores need to be combined and compared. Concrete use cases include accumulating alignment scores and comparing path costs in dynamic programming algorithms.",
      "description_length": 393,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Nucleotide_frequency",
      "library": "biotk",
      "description": "This module represents nucleotide frequency distributions as tuples of four floats, corresponding to the four DNA bases. It provides operations to compute a score for a given nucleotide symbol, handle missing symbols, and compute the reverse-complement distribution. These functions support tasks like sequence alignment and motif analysis where position-specific nucleotide probabilities are used.",
      "description_length": 398,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.NarrowPeak.Item",
      "library": "biotk",
      "description": "This module provides a `parse` function that converts a `Biotk.Line.t` into a `Biotk.NarrowPeak.item`, representing a single entry from a NarrowPeak file. It operates on structured genomic data, specifically lines from bioinformatics files in the NarrowPeak format. Use this module when processing ChIP-seq or similar genomic signal data stored in NarrowPeak format.",
      "description_length": 366,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bamstats.Fragment_length_histogram",
      "library": "biotk",
      "description": "Tracks fragment length distributions from aligned sequencing data by collecting lengths into a binned counter. It filters alignments based on minimum mapping quality and updates the histogram incrementally. Useful for quality control in genomic analyses where fragment size distribution is critical, such as in paired-end sequencing experiments.",
      "description_length": 345,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.FeatureCounts.Summary",
      "library": "biotk",
      "description": "This module parses and represents feature count summaries from RNA-seq data, providing a `load` function to read summary statistics from a file. It tracks counts across various categories such as assigned reads and multiple types of unassigned reads. Use this module to analyze alignment results and assess mapping quality or feature coverage in transcriptomic studies.",
      "description_length": 369,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Line_oriented.S",
      "library": "biotk",
      "description": "Processes line-oriented file formats with functions to load, fold, and save items. Works with a list of items where each item corresponds to a line in the file. Use this module to parse and serialize line-based data files, such as CSV or custom log formats.",
      "description_length": 257,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Dna_sequence.Parser_of_char",
      "library": "biotk",
      "description": "Handles parsing and statistical analysis of DNA sequences from character input. It computes GC content distributions and generates cumulative distribution functions for sequence analysis. Useful for calculating false positive rates and normalization bounds in DNA sequence processing tasks.",
      "description_length": 290,
      "index": 54,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Biotk.Wfa.Nucleotide",
      "library": "biotk",
      "description": "This module defines a type `t` representing nucleotide bases and provides constants for the four standard DNA nucleotides: A, C, G, and T. It includes a function `to_string` to convert a nucleotide to its string representation and a list `all` containing all valid nucleotide values. This module is useful for handling and iterating over nucleotide sequences in bioinformatics applications, such as DNA alignment or sequence analysis.",
      "description_length": 434,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Meme.Motif_format",
      "library": "biotk",
      "description": "This module handles parsing and writing motif data in MEME format, supporting operations to serialize motif information to output channels. It works with structured data types including probability matrices, background frequencies, and motif metadata like name and alphabet type. Concrete use cases include saving computed motifs to files or streams for downstream analysis in bioinformatics pipelines.",
      "description_length": 402,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Dataframe.Ez",
      "library": "biotk",
      "description": "This module simplifies working with tabular data by providing direct access to columns as typed arrays, including integers, floats, and strings, with optional values. It supports reading data from files with flexible header handling and retrieving column data either by index or by name. Concrete use cases include parsing CSV files, extracting specific columns for analysis, and handling missing data in bioinformatics datasets.",
      "description_length": 429,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Fastq.Stats",
      "library": "biotk",
      "description": "This module calculates basic statistics from FASTQ files, specifically counting the number of reads. It processes raw FASTQ data and returns structured results as a record with an integer field for the total read count. A primary use case is determining the size of sequencing datasets without full parsing, useful for quick quality checks or preprocessing steps.",
      "description_length": 363,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Nucleotide_IUPAC",
      "library": "biotk",
      "description": "This module defines types and scoring functions for nucleotide sequences using IUPAC ambiguity codes. It provides a `score` function that calculates the match score between a sequence profile and a nucleotide symbol, along with a `missing_score` for handling undefined positions. It operates on custom `symbol`, `t`, and `score` types representing nucleotide variants, sequence profiles, and scoring values, respectively. Use this module to implement alignment or sequence comparison algorithms that account for IUPAC-encoded nucleotide ambiguity.",
      "description_length": 547,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Gff.GFF2",
      "library": "biotk",
      "description": "This module parses and writes GFF2 (GTF) files, loading annotations into memory as lists of structured genomic features like genes and exons. It supports processing annotations through fold operations, enabling tasks like filtering transcripts or extracting feature metadata. The child module handles parsing and unparsing of individual GFF2 records, converting between in-memory representations (`Biotk.Gff.item`) and GFF2-formatted strings, useful for manipulating transcript annotations such as exons and transcripts directly. Together, they support end-to-end workflows including converting between GFF versions and preparing annotation data for downstream analysis.",
      "description_length": 670,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Macs.Xls",
      "library": "biotk",
      "description": "This module parses and unparses MACS output files into structured entries, handling comments, headers, and data records. It works with strings and the `item` type, which includes entries containing sequence IDs, positions, scores, and metadata. Use it to read or write peak data from ChIP-seq experiments, such as processing MACS-generated narrowPeak files or integrating peak calling results into analysis pipelines.",
      "description_length": 417,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Macs2.Xls",
      "library": "biotk",
      "description": "This module parses XLS output from MACS2, converting lines into structured items like records or comments. It processes strings into lists of typed items and extracts genomic locations from records. Use it to analyze MACS2 results by accessing peak data as structured values or filtering by location.",
      "description_length": 300,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Alphabet.Make",
      "library": "biotk",
      "description": "This module generates alphabet implementations with a fixed set of valid characters. It provides operations to convert between characters and alphabet values, list all valid symbols, and determine the size of the alphabet. Use it to define DNA, RNA, or protein sequence alphabets with strict validation.",
      "description_length": 303,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.FeatureCounts.Tsv",
      "library": "biotk",
      "description": "This module provides tools for parsing, manipulating, and serializing genomic feature count data, centered on a record type with fields for identifiers, chromosome locations, intervals, strand, length, and counts. It supports direct access to individual fields and structured transformations via functions like `create`, `map`, `iter`, and `fold`, enabling precise handling of genomic intervals and associated numerical data. Customizable CSV/TSV readers and writers allow seamless conversion to and from tabular formats, while submodules extend functionality with parsing, filtering, validation, and aggregation operations. Specific use cases include processing feature count outputs, applying region-based filters, and integrating with alignment or coverage analysis workflows.",
      "description_length": 779,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Gene.Transcript",
      "library": "biotk",
      "description": "This module represents gene transcripts with operations to construct and query their genomic structure, including exons, introns, and flanking regions. It works with transcripts composed of a chromosome identifier, strand direction, and exon intervals. Concrete use cases include calculating transcript ranges, extracting exon or intron locations, and determining upstream or downstream regions for regulatory analysis.",
      "description_length": 419,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ucsc_genome_browser.Chrom_size",
      "library": "biotk",
      "description": "This module represents chromosome names and sizes as records with explicit fields, supporting operations like mapping, folding, and filtering for data transformation and analysis. It includes functions to load and save data from CSV files or channels, with customizable separators, enabling seamless conversion between in-memory and file-based representations. Submodules extend functionality for structured iteration and aggregation, such as validating chromosome names or computing total genome size. Example uses include parsing UCSC chromosome size files, normalizing size values, and extracting chromosome lists for downstream genomic processing.",
      "description_length": 651,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.PSSM",
      "library": "biotk",
      "description": "This module represents position-specific scoring models (PSSMs) as weighted finite automata for sequence analysis. It provides operations to construct expressions from nucleotide frequencies, combine them with disjunction and sequence, model gaps with length constraints, and compute score ranges and automata for scanning sequences. Concrete use cases include motif detection, sequence alignment scoring, and scanning genomic regions for binding sites using probabilistic models derived from count matrices.",
      "description_length": 508,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Profile_matrix.Make",
      "library": "biotk",
      "description": "This module implements profile matrices with operations for creation, analysis, and visualization. It works with matrices of floating-point values, representing positional character distributions, such as those found in sequence motifs. Functions include converting arrays to validated matrices, computing base composition and entropy per position, and drawing visual representations using a specified color palette.",
      "description_length": 416,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.Record",
      "library": "biotk",
      "description": "This module defines a record type representing a single line of a GFF file, with fields for genomic coordinates, feature metadata, and attributes. It provides functions to convert records to and from S-expressions, extract genomic locations, compute feature lengths, and retrieve attribute values. Concrete use cases include parsing and manipulating transcript annotations, such as extracting gene boundaries or filtering features by source.",
      "description_length": 441,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.GFF3",
      "library": "biotk",
      "description": "This module processes GFF3 files by parsing, manipulating, and writing genomic annotations, supporting structured access to features like genes, transcripts, and exons with their attributes. It provides operations to load annotated features from sources like Ensembl or NCBI, fold over entries to compute summaries, and save modified annotations back to disk. The core `item` type represents either a parsed GFF3 record or a comment, enabling precise round-trip processing of both data and metadata. Submodules handle line-level parsing and formatting, making it possible to integrate transcriptome data or prepare annotations for genome browsers and analysis pipelines.",
      "description_length": 670,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Macs2.Broad_peaks",
      "library": "biotk",
      "description": "Reads and processes MACS2 broad peak output into structured data. Provides parsing of broad peak files into item records containing genomic coordinates, scores, and statistical values. Useful for analyzing ChIP-seq data to identify enriched regions with varying signal strength.",
      "description_length": 278,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Map",
      "library": "biotk",
      "description": "This module provides tools for building and manipulating maps with genomic location keys, supporting safe construction from lists, arrays, and hash tables while handling duplicates through error reporting or merging. It includes operations for efficient key transformation, property-based testing, and serialization in both S-expression and binary formats, enabling robust processing of genomic data. Submodules extend this functionality with key-specific comparison and hashing, binary shape computation, diff-based updates, and S-expression parsing that tracks source locations. These features allow tasks such as persisting genomic interval maps to disk, transmitting them efficiently, and tracking incremental changes in bioinformatics workflows.",
      "description_length": 750,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Idr.Narrow_output",
      "library": "biotk",
      "description": "This module reads IDR narrowPeak files from file paths or string data, parsing each line into structured rows with typed fields for genomic coordinates, peak scores, strand, signal values, and IDR statistics. It produces result values that capture parsing errors, ensuring robust handling of input data. The module supports direct access to fields via accessor functions and can convert rows into genomic locations for use with other genomic analysis tools. Example uses include loading and validating narrowPeak files for downstream processing such as peak annotation or visualization.",
      "description_length": 586,
      "index": 73,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Biotk.Profile_matrix.DNA",
      "library": "biotk",
      "description": "This module represents DNA profile matrices as 2D float arrays, where rows correspond to positions and columns to nucleotide frequencies. It provides operations to create, manipulate, and visualize these matrices, including computing sequence composition, entropy, and reverse complement. Concrete use cases include analyzing transcription factor binding site models and generating sequence logos.",
      "description_length": 397,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GAnnot.LSet",
      "library": "biotk",
      "description": "This module represents sets of genomic regions, each defined by a range and a chromosome identifier, supporting operations like union, intersection, and membership testing. It provides functions to find intersecting regions, test for overlap with a given region, and identify the closest region along with the distance. These capabilities are useful for genomic analyses such as identifying overlapping gene loci or determining proximity between features on the same chromosome.",
      "description_length": 478,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bed.Bed3",
      "library": "biotk",
      "description": "This module processes genomic intervals in BED3 format, offering functions to load and save BED files as lists or interval maps. It supports direct manipulation of genomic features through data types representing chromosome names, start, and end positions, with operations for parsing, converting, and serializing interval data. The child module handles low-level representation and conversion to and from `GLoc.t`, enabling precise handling of genomic locations. Use cases include parsing BED3 files for genomic analysis, transforming interval data for visualization, and preparing datasets for downstream processing.",
      "description_length": 618,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Line_oriented.Item",
      "library": "biotk",
      "description": "This module defines a data type `t` representing items in line-oriented file formats, where each item corresponds to a single line. It provides `parse` to convert a line into an item and `unparse` to serialize an item back into a string. These functions enable reading from and writing to formats like BED or GFF, where each line encodes one record.",
      "description_length": 349,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.S",
      "library": "biotk",
      "description": "This module processes General Feature Format (GFF) files, supporting both GFF2 (GTF) and GFF3 variants. It provides functions to load annotations from a file into a list of structured items, fold over annotations while reading a file, and save a list of annotations to a file. The module works directly with `Biotk.Gff.item` structures, which represent genomic features with attributes such as sequence name, source, feature type, and coordinates. Use this module to parse and write transcript annotations for downstream analysis like gene model comparisons or feature extraction.",
      "description_length": 580,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Symbol",
      "library": "biotk",
      "description": "This module defines a symbolic representation for biological sequence characters, such as nucleotides or amino acids. It includes operations to convert symbols to string representations and provides a list of all valid symbols. It is used to standardize and manipulate sequence data in alignment and analysis workflows.",
      "description_length": 319,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GLoc.Set",
      "library": "biotk",
      "description": "This module provides core operations for working with sets of genomic locations, including creation, manipulation, and comparison. It supports ordered sets through a comparator, enables hashing for use in hash tables, and offers operations to compute and apply diffs between sets. Serialization and deserialization are handled through S-expressions and binary formats, allowing for efficient storage, transmission, and versioning of genomic interval data. For example, you can compute the difference between two sets of genomic locations, serialize that diff, and later apply it to reconstruct updated datasets.",
      "description_length": 611,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Line_oriented.Parser",
      "library": "biotk",
      "description": "Handles incremental parsing of line-oriented data from byte chunks, maintaining state across reads. Works with `string option` inputs and produces a list of parsed lines along with updated state. Useful for streaming line-based formats like FASTA or BED where input arrives in arbitrary chunks.",
      "description_length": 294,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GAnnot.LMap",
      "library": "biotk",
      "description": "This module implements maps from genomic locations to values, supporting operations like adding intervals with associated data, querying intersections, finding closest intervals, and converting to or from sequences of location-value pairs. It works with `Biotk.GLoc.t` intervals and abstract chromosome identifiers, allowing annotations of arbitrary type. Concrete use cases include managing overlapping gene annotations, identifying nearby genomic features, and extracting subsets of regions that intersect a query interval.",
      "description_length": 525,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Profile_matrix.S",
      "library": "biotk",
      "description": "This module implements profile matrices as arrays of floats, providing operations to create, query, and visualize them. It supports tasks like calculating sequence composition, entropy, and rendering profiles as graphical motifs using a specified color palette. Concrete use cases include motif visualization in bioinformatics and information-theoretic analysis of sequence alignments.",
      "description_length": 385,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Idr.Broad_output",
      "library": "biotk",
      "description": "This module processes output files from the IDR program, parsing them into structured rows that capture genomic regions with associated statistical scores and coordinates. Each row includes fields like chromosome, start, end, and significance values, supporting analysis of ChIP-seq or ATAC-seq data. The module provides utilities to read, filter, and manipulate these records, enabling tasks such as thresholding by score or extracting regions of interest. Submodules define the core data structures and accessors, ensuring precise representation and efficient handling of IDR results.",
      "description_length": 586,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Line_oriented.Make",
      "library": "biotk",
      "description": "This module processes line-oriented file formats by converting each line into an `item` type. It provides functions to load items from a file, fold over items while reading, and save items to a file. Use it when parsing or generating text files where each line represents a distinct data record.",
      "description_length": 295,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff.S-Item",
      "library": "biotk",
      "description": "Handles parsing and unparsing of GFF/GTF format lines into structured items, supporting both comment and record types. Operates on `Biotk.Line.t` inputs and outputs either raw comment strings or `Biotk.Gff.Record.t` values. Used to process individual lines of transcript annotation files into manipulable data structures and serialize them back to text.",
      "description_length": 353,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Let_syntax.Result",
      "library": "biotk",
      "description": "This module provides monadic and applicative operators for composing computations that return `result` values. It supports chaining operations that may fail, allowing for concise error handling and value extraction. These functions are useful when implementing workflows where each step depends on the successful outcome of the previous one, such as parsing or system interaction tasks.",
      "description_length": 386,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa.Make",
      "library": "biotk",
      "description": "This module builds and evaluates weighted finite automata for sequence analysis using customizable scoring and symbol representations. It supports constructing expressions from profiles, combining them with disjunction and sequence operators, and defining gap penalties with specified length bounds. The automata can scan strings to find matches with start/end positions, lengths, and scores, enabling applications like motif finding or alignment scoring in bioinformatics.",
      "description_length": 473,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Bed.Bed5",
      "library": "biotk",
      "description": "This module processes genomic intervals in BED5 format, handling reading and writing of records with chromosome, start, end, name, and score fields. It supports operations like parsing file lines into item records, converting to BED4 format, and extracting genomic locations for analysis or visualization. The child module focuses on BED5 item manipulation, offering utilities to serialize and deserialize lines, while the parent module manages file-level operations and list-based data processing. Example uses include annotating genomic regions and preparing interval data for downstream tools.",
      "description_length": 596,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Pwm_stats.TFM_pvalue",
      "library": "biotk",
      "description": "TFM_pvalue calculates statistical significance for position weight matrix (PWM) scores using dynamic programming. It provides functions to compute score distributions, p-values, and score thresholds for DNA sequence analysis. This module works directly with PWMs and background nucleotide distributions to assess motif binding probabilities in genomic data.",
      "description_length": 357,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bamstats.Chr_histogram",
      "library": "biotk",
      "description": "Tracks alignment coverage across chromosomes using a binned counter structure. It works with BAM headers and unpaired alignment records, incrementing counts based on reference sequence positions. This module is used to generate per-chromosome coverage statistics from BAM files, filtering alignments by minimum mapping quality.",
      "description_length": 327,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Bed.Bed4",
      "library": "biotk",
      "description": "This module processes genomic intervals in the BED4 format, handling loading and saving of records with chromosome, start, end, and name fields. It supports operations on lists of records and labeled maps, enabling efficient querying and transformation of annotated genomic data. The child module models individual BED4 items, providing parsing, serialization, and location extraction functions. Together, they allow tasks like filtering intervals by position, grouping by chromosome, or converting BED4 data to other genomic formats.",
      "description_length": 534,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Cisbp.TF_information",
      "library": "biotk",
      "description": "Processes and provides access to transcription factor (TF) data from the CisBP database, including TF identifiers, species, binding domains, and associated metadata. Parses and structures TF information from files into a list of detailed records. Enables querying specific TF attributes like family, source, and motif details for analysis or integration into bioinformatics workflows.",
      "description_length": 384,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ncbi_genome.Assembly_summary",
      "library": "biotk",
      "description": "This module provides functions to parse and generate CSV data for NCBI genome assembly summary records. It works with a structured type representing assembly metadata, including fields like accession, tax ID, organism name, and FTP paths. Concrete use cases include loading assembly data from CSV files, converting rows to structured records, and saving processed records back to CSV format.",
      "description_length": 391,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bam.Alignment0",
      "library": "biotk",
      "description": "This module represents partially parsed BAM alignment records, enabling efficient traversal by accessing only required fields. It works with BAM headers and alignment data structures, providing functions to extract specific fields like query name, flags, reference ID, position, mapping quality, and more. Use cases include processing large BAM files where full parsing is unnecessary, such as calculating coverage or filtering alignments based on specific criteria.",
      "description_length": 466,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Igv.Statement",
      "library": "biotk",
      "description": "This module builds IGV script statements for genomic data visualization. It provides functions to set the genome reference and load data files with optional format, index, and track name parameters. Each function appends a corresponding command to the script, enabling programmatic generation of IGV batch scripts for specific genomic datasets.",
      "description_length": 344,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GAnnot.LAssoc",
      "library": "biotk",
      "description": "This module handles sets of annotated genomic regions, supporting operations like filtering by region attributes, converting between list and set representations, and matching regions based on spatial relationships. It works with region data where each region is paired with an arbitrary annotation type, and enables analysis tasks such as identifying overlapping regions, finding neighboring annotations, or mapping annotations across related datasets. Concrete use cases include genomic interval analysis, annotation transfer between datasets, and filtering genomic features based on positional or attribute criteria.",
      "description_length": 619,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Dataframe.Parser",
      "library": "biotk",
      "description": "This module parses tabular data into typed arrays, handling conversions from strings to integers, floats, and optional variants. It validates column counts and labels, returning structured errors for mismatches or conversion failures. Use it to load and validate CSV or TSV files into strict, typed dataframes with precise schema expectations.",
      "description_length": 343,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Profile_matrix.Protein",
      "library": "biotk",
      "description": "This module represents protein profile matrices as 2D float arrays, providing operations to create, analyze, and visualize them. It supports computing residue composition and entropy per position, and includes functions for graphical rendering using a specified color palette. Concrete use cases include visualizing sequence conservation in multiple sequence alignments and generating profile heatmaps for bioinformatics analysis.",
      "description_length": 430,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Sam.Flags",
      "library": "biotk",
      "description": "This module decodes and queries SAM alignment flags, providing boolean checks for specific flag bits. It works with a private integer type representing SAM flag values, typically extracted from SAM file records. Use it to determine alignment properties like unmapped segments, reverse complementation, PCR duplicates, and whether an alignment is supplementary or fails quality control.",
      "description_length": 385,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Fastq",
      "library": "biotk",
      "description": "This module provides robust parsing and processing of FASTQ files, supporting operations like folding over records and converting between S-expressions and structured data types. It handles FASTQ records with descriptions, sequences, comments, and quality scores, along with detailed error reporting for malformed input. A child module efficiently counts reads in raw FASTQ data, returning the total as an integer, enabling quick dataset sizing for bioinformatics pipelines. Together, they support both full parsing and lightweight analysis for reliable sequencing data transformation.",
      "description_length": 585,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.ISet",
      "library": "biotk",
      "description": "This module provides range-centric set operations for integers, supporting efficient manipulation through additions, deletions, unions, intersections, and range-aware traversals. It employs Discrete Interval Encoding Trees (DIET) to represent contiguous integer intervals compactly, excelling in scenarios with dense ranges but less suited for sparse, scattered elements. Applications include genomic interval analysis, temporal range processing, or any domain where contiguous blocks dominate, such as resource allocation or interval-based scheduling.",
      "description_length": 552,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Bed",
      "library": "biotk",
      "description": "This module processes genomic intervals in BED format variants, offering structured representations and utilities for parsing, serializing, and manipulating records with varying field counts. It supports reading and writing BED3 to BED6 files, converting lines into typed genomic features with fields like chromosome, start, end, name, score, and strand, and mapping intervals for efficient querying. You can load BED6 annotations for feature filtering, parse BED3 intervals for visualization, or convert BED5 data to other genomic formats. Submodules handle low-level line parsing, structured item representation, and format-specific conversions while preserving metadata and genomic location accuracy.",
      "description_length": 703,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Dataframe",
      "library": "biotk",
      "description": "This module enables parsing and manipulating structured tables with typed columns, supporting integers, floats, strings, and optional variants. It allows constructing dataframes from column lists, reading files with customizable header handling, and rendering tables to HTML using custom formatters. The module provides direct access to columns as typed arrays, supports parsing and validation of CSV/TSV files with strict schema enforcement, and handles missing data and conversion errors gracefully. Examples include loading CSV data with explicit schemas, extracting and analyzing specific columns, and generating HTML reports from structured biological datasets.",
      "description_length": 666,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Amino_acid",
      "library": "biotk",
      "description": "This module defines an enumerated type representing standard amino acids, along with conversions to and from characters and integers. It provides a list of all amino acid values, the total count, and safe and unsafe character conversion functions. It is used for parsing and encoding protein sequences in bioinformatics applications.",
      "description_length": 333,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Pwm_stats",
      "library": "biotk",
      "description": "This module implements statistical methods for analyzing position weight matrices by combining naive distribution approaches with dynamic programming techniques. It provides data types for representing PWMs, background nucleotide distributions, and score thresholds, along with operations to compute score probabilities, p-values, and significance thresholds. The core functionality enables precise motif analysis by assessing the likelihood of sequence matches to transcription factor binding profiles. For example, it can calculate the p-value of a given PWM score or determine the score threshold corresponding to a specific significance level.",
      "description_length": 647,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.RanT",
      "library": "biotk",
      "description": "This module traverses integer ranges and applies functions to each value. It supports operations like finding elements, counting matches, folding over ranges, and iterating with side effects. Use it to process sequences of integers, such as summing values, checking conditions across ranges, or mapping with optional results.",
      "description_length": 325,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bamstats",
      "library": "biotk",
      "description": "This module processes BAM records to track and aggregate alignment statistics, including total reads, QC-passing reads, single and paired alignments, and mapped reads. It maintains histograms for fragment lengths and chromosome coverage, built from binned counters that filter alignments by mapping quality. The fragment length tracker specializes in collecting size distributions for quality control in paired-end sequencing, while the chromosome coverage module tallies alignment positions across reference sequences. Together, they enable detailed analysis of sequencing data quality and mapping patterns directly from BAM files.",
      "description_length": 632,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Macs",
      "library": "biotk",
      "description": "This module processes MACS output files by parsing and unparsing structured entries, including comments, headers, and data records. It operates on strings and the `item` type, which captures sequence IDs, positions, scores, and metadata. Use it to read or write narrowPeak files from ChIP-seq experiments, enabling integration of peak calling results into analysis workflows. For example, it can extract peak regions or filter results based on score thresholds.",
      "description_length": 461,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Macs2",
      "library": "biotk",
      "description": "This module processes MACS2 output files into structured data, converting XLS and broad peak formats into typed records with genomic coordinates, scores, and statistics. It enables parsing, filtering, and analysis of peak data from ChIP-seq experiments. You can extract specific peaks by location, analyze signal strength across regions, or integrate results into downstream genomic workflows. For example, you can load an XLS file to find all peaks on chromosome 1 or compute summary statistics from broad peak data.",
      "description_length": 517,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ncbi_genome",
      "library": "biotk",
      "description": "This module provides tools to retrieve and process NCBI RefSeq assembly summary data, including direct access to the latest assembly metadata URL and functions to extract key genomic annotations such as assembly level, organism name, and sequence accessions. It supports parsing and generating structured assembly records from CSV files, enabling workflows that load, transform, and store genome metadata. Key data types include structured representations of assembly entries with fields like accession, tax ID, organism name, and FTP paths, while operations allow CSV serialization, record filtering, and metadata extraction. Example uses include querying the latest assembly data, converting summaries to structured format, and exporting custom genome datasets to CSV.",
      "description_length": 770,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Let_syntax",
      "library": "biotk",
      "description": "This module enables fluent composition of computations that produce `result` values, using monadic and applicative operators to sequence operations and propagate errors. It defines core types like `'a t` (representing result-bearing values) and provides operations such as `bind`, `map`, and `both` for chaining and combining computations. With it, developers can write compact, readable code for tasks like parsing structured data or handling I/O operations, where each step depends on the success of the prior. For example, one might use `let%bind` to extract values from a sequence of file reads or network requests, automatically short-circuiting on any failure.",
      "description_length": 666,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gene",
      "library": "biotk",
      "description": "This module represents gene structures and their transcript variants, enabling construction of genes from exon locations, retrieval of genomic ranges, and extraction of exons and introns. It operates on gene and transcript data types that encode strand-specific locations, supporting tasks like analyzing gene architecture and preparing input for genome annotation tools. The transcripts submodule extends this functionality by modeling individual transcript isoforms with exons, introns, and flanking regions, allowing precise queries such as calculating transcript spans or identifying regulatory regions upstream or downstream of exons. Together, they provide a structured way to model, traverse, and analyze eukaryotic gene and transcript features in genomic data.",
      "description_length": 768,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Utils",
      "library": "biotk",
      "description": "This module ensures uniqueness of values extracted from lists using custom equality checks or string conversion. It operates on any list type, applying a function to map elements to a comparable form, then returns results indicating uniqueness or errors if duplicates exist. Useful for validating distinctness of identifiers, keys, or transformed data in list-based workflows.",
      "description_length": 376,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Cisbp",
      "library": "biotk",
      "description": "This module integrates tools for downloading, parsing, and processing data from the CisBP database, combining direct access to TF metadata with motif analysis through child modules. It supports retrieval of transcription factor information such as species, family, and binding domains, while enabling the extraction and transformation of position weight matrices into standard numerical formats. Operations include querying TF records for specific attributes, loading PWMs for motif analysis, and integrating both data types into regulatory genomics workflows. Example use cases involve comparing DNA binding specificities across TFs or incorporating motif data into gene expression studies.",
      "description_length": 691,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Sam",
      "library": "biotk",
      "description": "This module processes SAM file data, focusing on alignment flags and their interpretation. It provides a private integer type for representing SAM flag values, along with operations to decode and query individual flag bits. Users can check properties such as whether a segment is unmapped, reverse-complemented, a PCR duplicate, or fails quality control. It is designed to work with SAM records, enabling direct analysis of alignment metadata through boolean checks and flag manipulation.",
      "description_length": 488,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Meme",
      "library": "biotk",
      "description": "This module processes motif data in MEME format, enabling serialization and deserialization of structured information such as probability matrices, background frequencies, and motif metadata. It supports reading from and writing to channels, facilitating integration with file-based or stream-based bioinformatics workflows. You can use it to save computed motifs for downstream analysis or to parse existing MEME files into usable data structures. For example, it allows writing a motif with a specified name and alphabet type to a file or extracting motif probabilities from a stream for further processing.",
      "description_length": 609,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Phred_score",
      "library": "biotk",
      "description": "This module implements conversions between PHRED quality scores and related data types, including ASCII characters, integers, probability values, and Solexa scores. It supports two ASCII encodings using offsets of 33 or 64, commonly found in FASTQ files, and provides functions to safely encode and decode PHRED scores while handling potential errors. Concrete use cases include parsing and generating FASTQ files, recalibrating quality scores, and converting between score representations for downstream analysis.",
      "description_length": 514,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ibed",
      "library": "biotk",
      "description": "This module represents and processes chromosomal interaction data from CHiCAGO's ibed files, where each record contains bait and target genomic locations along with metadata like read count and score. It provides operations to sort interactions by genomic coordinates, group contacts by bait region or chromosome, and read/write data from/to ibed files. Concrete use cases include analyzing Hi-C interaction data to study chromatin structure and identifying significant chromosomal contacts.",
      "description_length": 491,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.FeatureCounts",
      "library": "biotk",
      "description": "This module processes and analyzes genomic feature count data from RNA-seq experiments, offering structured representations of features with attributes such as identifiers, genomic locations, strand, length, and associated counts. It provides operations to load, transform, and serialize data through functions like `load`, `create`, `map`, `iter`, and `fold`, supporting precise manipulation of genomic intervals and numerical values. Built-in support for CSV/TSV formats enables easy integration with common bioinformatics tools, while submodules allow filtering, validation, and aggregation of feature counts based on regions or alignment quality. Example uses include assessing mapping accuracy, applying interval-based filters, and aggregating count data across samples for downstream analysis.",
      "description_length": 799,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Line",
      "library": "biotk",
      "description": "This module represents and manipulates individual lines of text, handling operations like splitting, stripping, and parsing lines from strings. It provides functions to convert lines to and from S-expressions, append or concatenate lines, and split lines on specific characters. Use cases include parsing text files line-by-line, processing FASTA or GFF formats, and handling line-based data in bioinformatics workflows.",
      "description_length": 420,
      "index": 121,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Biotk.Profile_matrix",
      "library": "biotk",
      "description": "This module provides profile matrices for probabilistic sequence analysis, supporting operations like sampling, entropy calculation, and visualization across multiple sequence types. It works with position-specific distributions represented as 2D float arrays, where rows encode positions and columns encode character frequencies from `Biotk.Alphabet.S`-compatible alphabets such as DNA and proteins. Functions include converting arrays into validated matrices, computing base or residue composition and positional entropy, and rendering profiles using customizable color palettes. Specific capabilities include motif discovery, sequence logo generation, reverse complement analysis for DNA, and conservation visualization in protein alignments.",
      "description_length": 745,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Nucleotide",
      "library": "biotk",
      "description": "This module defines a type for nucleotide bases in DNA sequences, including constants for each nucleotide (A, C, G, T) and operations to convert between nucleotides, characters, and integers. It supports lookup by character or integer index, with safe and unsafe conversion functions, and provides the complement of a nucleotide. Use cases include parsing and manipulating DNA sequences, validating nucleotide inputs, and implementing bioinformatics algorithms requiring nucleotide complementarity.",
      "description_length": 498,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Igv",
      "library": "biotk",
      "description": "This module constructs IGV script files from structured commands, converting genomic region specifications, track configurations, and session settings into a formatted script string. It supports operations like setting the genome reference, loading BAM files with optional format and index parameters, and defining visible regions. Child modules extend this functionality by providing specific commands for data visualization, such as track naming and session export. Together, they enable automation of complex IGV visualizations, including loading datasets, adjusting display settings, and generating snapshots programmatically.",
      "description_length": 630,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Encode",
      "library": "biotk",
      "description": "This module provides structured access to ENCODE experiment data by parsing string-encoded input into a list of experiment entries. It supports operations for extracting and processing metadata from ENCODE database responses. For example, it can convert raw JSON or tabular data into a list of experiment records, enabling programmatic access to experiment identifiers, assay types, and associated files. Key data types include experiment entries containing metadata fields such as accession IDs, biosample types, and file formats.",
      "description_length": 531,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Range",
      "library": "biotk",
      "description": "This module provides functionality for constructing and manipulating contiguous integer intervals, supporting operations such as membership checks, union, intersection, convex hull computation, and subset/superset analysis. It operates on ranges defined by lower and upper bounds, enabling precise spatial reasoning for applications like genomics, interval arithmetic, or interval-based data processing where relationships between ranges must be determined.",
      "description_length": 457,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Pwm",
      "library": "biotk",
      "description": "This module implements position-weight matrices (PWMs) for DNA motif analysis, providing functions to construct PWMs from count matrices and background distributions, generate random or composite motifs, and scan DNA sequences for motif occurrences above a specified score threshold. It supports operations like reverse complement transformation and tandem motif assembly with configurable spacing, working with data types such as count matrices, background frequency arrays, and PWMs. Concrete use cases include motif discovery, sequence scanning for transcription factor binding sites, and generating synthetic motifs for simulation studies.",
      "description_length": 643,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bai",
      "library": "biotk",
      "description": "This module implements the BAI index format for BAM files, providing functions to read and process BAI data structures. It works with indexed genomic regions using chunk, bin, and interval types to map positions to file offsets. Use this module to efficiently query BAM file indices for specific genomic ranges, such as retrieving alignment data for a given chromosome region.",
      "description_length": 376,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.GLoc",
      "library": "biotk",
      "description": "This module provides tools for constructing and manipulating maps and sets of genomic locations, with robust handling of duplicates, efficient key transformations, and property-based testing. It supports serialization in S-expression and binary formats, enabling data persistence and transmission, while submodules offer key-specific comparisons, hashing, and diff-based updates. You can build a map from a list of genomic intervals, merge overlapping regions, compute differences between sets, and serialize those changes for later application. Operations like tracking source locations during parsing and applying incremental updates enhance its utility in bioinformatics workflows.",
      "description_length": 684,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bgzf",
      "library": "biotk",
      "description": "This module offers low-level I/O operations for BGZF-compressed files, including opening, reading, writing, seeking, and managing virtual offsets as specified in the BAM format, with support for raw bytes and integer types (8-bit, 16-bit, 32-bit). It operates on channels and BGZF blocks, providing resource management functions like safe file closure and scoped handling for writing. These capabilities are essential for processing genomic datasets such as BAM files, where efficient streaming compression and random access to large, indexed data are required.",
      "description_length": 561,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Phylo_tree_draw",
      "library": "biotk",
      "description": "This module constructs and renders phylogenetic trees with styled leaves and colored branches. It supports operations to create leaves with text and styling, define tree nodes with optional tags, and draw branches with specified lengths and colors. The `draw_tree` and `draw_branch` functions generate visual representations using the Croquis rendering system.",
      "description_length": 360,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Ucsc_genome_browser",
      "library": "biotk",
      "description": "This module constructs and manipulates track definitions and URLs for visualizing genomic data in the UCSC Genome Browser. It supports operations to generate track lines from attributes like name, visibility, and color, and to create custom track URLs with parameters such as assembly, genomic position, and display settings. The module works with genomic assemblies (e.g., hg19, mm10), track attributes, and chromosome size definitions to integrate custom data visualizations directly into the browser. A child module represents chromosome names and sizes as records, supporting data transformation through mapping, filtering, and folding, and provides functions to load and save this data from CSV files or channels with customizable separators. Example uses include parsing UCSC chromosome size files, normalizing size values, and generating custom track URLs for specific genomic regions with tailored display settings.",
      "description_length": 923,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.List1",
      "library": "biotk",
      "description": "This module implements a list-like structure that guarantees non-empty contents, providing operations such as creation via singleton, cons, and init, transformations with map, filtering with filter_map, and folds for accumulation. It works with a polymorphic type `'a Biotk.List1.t`, internally ensuring the list is never empty, and supports conversion to and from standard OCaml lists. Concrete use cases include handling sequences that must have at least one element, such as parsing results, biological sequences, or configurations where emptiness is invalid.",
      "description_length": 562,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gff",
      "library": "biotk",
      "description": "This module processes transcriptome annotations in both GFF2 (GTF) and GFF3 formats, parsing and constructing structured genomic features such as genes and exons. It provides core data types like `Record.t` and `item`, which capture genomic coordinates, feature metadata, and attributes, along with operations to convert, filter, and serialize annotations. Submodules handle line-level parsing, in-memory manipulation, and format conversion, supporting tasks like extracting gene models, modifying feature attributes, and converting between GFF versions. It enables end-to-end workflows such as loading annotations from Ensembl, processing them via folds, and writing structured data back to GFF3 or GTF files for analysis or visualization.",
      "description_length": 740,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.GAnnot",
      "library": "biotk",
      "description": "This module manages genomic regions paired with sequence identifiers, supporting set operations like union, intersection, and difference, along with membership and proximity queries. It provides data structures for both overlapping and non-overlapping regions, with optional annotations of arbitrary types, enabling efficient analysis of interval data. You can compute overlaps between gene loci, find the closest genomic feature, annotate intervals with metadata, or filter regions based on spatial or attribute criteria. Applying the functor on the String module gives ready-to-use implementations for common genomic data tasks.",
      "description_length": 630,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bam_iterator",
      "library": "biotk",
      "description": "This module provides functions to iterate over BAM file alignments within specified genomic regions, using a fold-like approach. It works with BAM files and their corresponding index files, processing alignments as `Biotk.Bam.Alignment0.t` values and maintaining a state across iterations. Concrete use cases include aggregating alignment statistics, filtering reads based on genomic location, or transforming alignment data into other formats.",
      "description_length": 444,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Solexa_score",
      "library": "biotk",
      "description": "This module implements conversions between Solexa quality scores and other representations. It provides functions to convert scores to and from ASCII characters and probabilities, using the formula -10*log(p/(1-p)) for score calculation. These operations are used when processing FASTQ files from Solexa/Illumina sequencing platforms.",
      "description_length": 334,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Fasta",
      "library": "biotk",
      "description": "This module parses and writes FASTA files, handling headers and sequence records. It provides types for headers as string lists and items containing descriptions and sequences, with serialization and deserialization functions. Use cases include reading FASTA files into structured data, extracting sequences, and writing items back to disk.",
      "description_length": 340,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Alphabet",
      "library": "biotk",
      "description": "This module creates types representing fixed alphabets, such as DNA or amino acid sequences, using characters while ensuring only valid characters from a specified set are used. It provides operations like `of_char`, `to_char`, and enumeration of all elements, enforcing correctness in sequence data handling. Submodules generate alphabet implementations with strict validation, supporting conversion between characters and alphabet values, symbol listing, and size determination. Use it to define DNA, RNA, or protein alphabets with safe, fixed character sets and trackable cardinality.",
      "description_length": 587,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Gcf",
      "library": "biotk",
      "description": "This module parses and transforms genomic coordinate data in GCF format. It processes rows containing a genomic location and associated fields, supporting conversion to BED format. Use it to handle genome annotation data, such as converting intervals for downstream analysis tools.",
      "description_length": 281,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Wfa",
      "library": "biotk",
      "description": "This module implements alignment algorithms and scoring systems for biological sequences, supporting operations like sequence comparison, scoring matrix generation, and profile construction using nucleotides, frequency distributions, and position-specific scoring matrices. It provides core data types such as nucleotide bases, scoring profiles, and weighted finite automata, along with operations to compute match scores, handle missing symbols, and model gaps with length constraints. Submodules enable motif discovery, sequence alignment against profiles, and scoring matches using PSSMs, with support for IUPAC ambiguity codes and reverse-complement distributions. Examples include scanning genomic regions for binding sites, aligning DNA sequences with weighted scores, and constructing probabilistic models from count matrices for dynamic programming algorithms.",
      "description_length": 868,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Line_oriented",
      "library": "biotk",
      "description": "This module processes line-oriented file formats by folding over lines with indexed access, supporting both standard and error-aware accumulation. It operates on strings and structured line data via the `Line` type, enabling parsing and validation workflows. Concrete use cases include reading and transforming TSV or CSV files where each line represents a record. The module provides core operations for loading, folding, and saving line-based data, while its submodules define item types, support streaming input with stateful parsing, and enable serialization of structured records to formats like BED or GFF.",
      "description_length": 612,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Bam",
      "library": "biotk",
      "description": "This module reads and writes BAM files, handling both full and partial alignment records while ensuring compliance with the official specification. It processes data using types like `Header.t`, `alignment`, and `Alignment0.t`, with functions for reading from and writing to channels or files directly. The header conversion submodule translates between BAM and SAM headers, enabling interoperability with tools expecting SAM-formatted metadata. The partial alignment submodule enables efficient traversal of large BAM files by accessing only required fields, such as query name, flags, reference ID, and mapping quality, supporting use cases like coverage calculation and alignment filtering.",
      "description_length": 693,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Dna_sequence",
      "library": "biotk",
      "description": "This module provides tools for DNA sequence analysis, supporting operations like GC content calculation and sliding window analysis directly on string sequences. It includes submodules for statistical evaluation, enabling computation of cumulative distribution functions, score bounds, and false positive rate estimation based on GC levels. These capabilities allow filtering DNA segments using statistical thresholds and characterizing sequence quality metrics. For example, users can analyze local GC variation across a genome or determine normalization bounds for sequence comparison.",
      "description_length": 587,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Misc",
      "library": "biotk",
      "description": "Iterates over integer ranges with customizable accumulation, computes sums and products of functions applied to integers. Works with integers and floating-point values. Useful for mathematical computations over discrete intervals.",
      "description_length": 230,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Interval_tree",
      "library": "biotk",
      "description": "This module implements an interval tree for storing and querying intervals bounded by integers, each associated with a value. It supports efficient operations such as adding intervals, checking for intersections, finding overlapping intervals, and locating the closest interval to a given range. Use cases include genomic interval analysis, scheduling, and spatial range queries where fast interval lookups are required.",
      "description_length": 420,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.NarrowPeak",
      "library": "biotk",
      "description": "This module handles genomic narrowPeak data, offering tools to read, process, and write peak records with coordinates, scores, and statistical values like p-values. It includes a `parse` function that converts a line of input into a structured peak item, enabling detailed analysis of ChIP-seq or similar datasets. You can use it to filter peaks by score, adjust genomic intervals, or extract regions of interest from large-scale experiments. The combined functionality supports both direct manipulation of peak data and line-by-line parsing through its submodules.",
      "description_length": 565,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Jaspar",
      "library": "biotk",
      "description": "This module parses JASPAR position weight matrices from files into structured data. It reads matrices containing transcription factor binding site counts and metadata like TF name and ID. Use it to load and analyze JASPAR motif data for bioinformatics workflows.",
      "description_length": 262,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk.Idr",
      "library": "biotk",
      "description": "This module provides tools for reading and processing IDR narrowPeak files, converting raw genomic data into structured rows with typed fields for coordinates, scores, and statistics. It supports robust parsing, error handling, and conversion to genomic locations for integration with analysis pipelines. Users can load, filter, and manipulate peak data based on thresholds or genomic regions, enabling applications like peak annotation, visualization, and downstream statistical analysis. Example workflows include validating IDR output files and extracting high-confidence regions from ChIP-seq or ATAC-seq experiments.",
      "description_length": 621,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk.Interval_union",
      "library": "biotk",
      "description": "This module manages a collection of non-overlapping intervals, supporting operations to add a range, remove parts of a range, and represent the union as a list of ranges. It works with `Biotk.Range.t` values, maintaining them in a normalized form. Concrete use cases include tracking genomic regions, managing file offsets, or handling time intervals where overlaps must be resolved.",
      "description_length": 383,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biotk",
      "library": "biotk",
      "description": "The Biotk library provides a comprehensive toolkit for bioinformatics data processing, integrating modules for sequence analysis, genomic interval manipulation, and structured data transformation. Core data types include FASTQ records, BED intervals, PWM motifs, and BAM alignments, with operations spanning parsing, validation, statistical analysis, and visualization. Users can count sequencing reads, analyze transcription factor binding sites, process gene annotations, or generate UCSC track URLs, all within a type-safe, modular framework designed for efficient, pipeline-oriented workflows.",
      "description_length": 597,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes_unix.Pipe.Monad_infix",
      "library": "biotk_pipes_unix",
      "description": "Implements monadic bind for composing pipeline stages, enabling sequential processing of input/output streams. Works with generic pipeline values parameterized by input, output, and result types. Useful for chaining transformations and effectful computations over data streams like file handles or network sockets.",
      "description_length": 314,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes_unix.Pipe",
      "library": "biotk_pipes_unix",
      "description": "This module provides composable stream processing with first-class pipelines that support transformation, filtering, and folding over asynchronous data flows. It centers on the `Pipe.t` type, representing streams that can be manipulated using operations like `map`, `filter`, `fold`, `await`, and `yield`, while integrating file I/O through `from_file` and `to_file` for buffered reading and writing of string streams. Monadic composition via `bind` and `return` enables chaining effectful pipeline stages, such as processing lines from a file, applying transformations, and writing results incrementally. Utilities like `bracket` ensure safe resource handling during streaming operations, and `run` executes completed pipelines to produce results or side effects.",
      "description_length": 764,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biotk_pipes_unix",
      "library": "biotk_pipes_unix",
      "description": "This module enables composable, asynchronous stream processing with first-class pipelines that support transformation, filtering, and folding over data flows. The core `Pipe.t` type represents streams that can be manipulated using operations like `map`, `filter`, `fold`, `await`, and `yield`, with support for effectful chaining via `bind` and `return`. It integrates file I/O through `from_file` and `to_file`, allowing buffered reading and writing of string streams, and includes utilities like `bracket` for safe resource handling. Example usage includes reading lines from a file, incrementally transforming them, and writing results to another file within a single, composed pipeline executed with `run`.",
      "description_length": 710,
      "index": 154,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 156,
    "meaningful_modules": 155,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9935897435897436
  },
  "statistics": {
    "max_description_length": 923,
    "min_description_length": 230,
    "avg_description_length": 474.6516129032258,
    "embedding_file_size_mb": 0.5634441375732422
  }
}