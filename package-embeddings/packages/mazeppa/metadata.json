{
  "package": "mazeppa",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 7,
  "creation_timestamp": "2025-06-18T16:31:30.578327",
  "modules": [
    {
      "module_path": "Mazeppa.Symbol",
      "description": "Provides operations to compare, serialize, and convert symbols between string representations and internal forms. Works with the `t` type, representing symbolic identifiers and operations. Enables parsing of operation kinds, checking operator arity, and generating comma-separated string outputs for symbol lists.",
      "description_length": 313,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mazeppa.Const",
      "description": "Provides operations to compare, format, and convert values of type `t` to strings, including specialized functions for translating signedness, bitness, and integer type representations into human-readable forms. Works with custom types such as `Checked_oint.signedness`, `Checked_oint.bitness`, and `Checked_oint.int_ty` alongside generic integer representations. Used to generate readable output for debugging or logging, and to safely escape string literals in generated code.",
      "description_length": 478,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mazeppa.Raw_term",
      "description": "This module provides operations for equality checks, pretty-printing, and string conversion of symbolic expressions, including variables, integers, strings, and function calls, along with pattern matching structures. It works with term types, symbolic patterns represented as symbol-list tuples, and associated data structures to enable tasks like parser validation or symbolic computation. Use cases include generating human-readable outputs for debugging or logging and facilitating pattern-based matching in rule systems.",
      "description_length": 524,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mazeppa.Raw_program",
      "description": "Compares program rules and attribute lists for equality, and generates human-readable representations of them. It processes a program structure composed of rules, each containing attributes, symbols, and terms. Used for debugging and serialization of parsed program data.",
      "description_length": 271,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mazeppa.Gensym",
      "description": "Generates unique symbols with a prefix and sequential numeric suffix, using a counter stored in a stateful object. It supports creating symbols, retrieving the latest, cloning states, and generating lists of symbols. Used to track unique identifiers in code generation or symbolic computation contexts.",
      "description_length": 302,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "mazeppa",
      "description": "Performs symbolic evaluation of programs using unknown run-time values to identify and extract execution patterns into optimized functions. Operates on abstract syntax trees and intermediate representations of functional programs. Enables the transformation of recursive structures into efficient, direct code, suitable for optimizing compilers and program analysis tools.",
      "description_length": 372,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mazeppa",
      "description": "provides operations for handling symbolic identifiers, expressions, and program structures, enabling parsing, comparison, formatting, and generation of unique symbols. It works with types like `t`, `Checked_oint.signedness`, `Checked_oint.bitness`, and term-based structures, supporting tasks such as converting symbols to strings, generating debug output, and creating unique identifiers. Functions include parsing operation kinds, pretty-printing expressions, and serializing program rules. Examples include generating human-readable representations of symbolic computations, escaping string literals in code, and tracking unique variable names during code generation.",
      "description_length": 670,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 7,
    "filtered_empty_modules": 1,
    "retention_rate": 0.875
  },
  "statistics": {
    "max_description_length": 670,
    "min_description_length": 271,
    "avg_description_length": 418.57142857142856,
    "embedding_file_size_mb": 0.025849342346191406
  }
}