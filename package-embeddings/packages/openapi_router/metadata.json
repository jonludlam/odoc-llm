{
  "package": "openapi_router",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 5,
  "creation_timestamp": "2025-07-15T23:06:02.876178",
  "modules": [
    {
      "module_path": "Openapi_router.Json_Schema.Helpers",
      "library": "openapi_router",
      "description": "This module enables the construction and manipulation of JSON Schema objects for OpenAPI specifications through functions that define types (e.g., null, boolean, object), apply constraints (e.g., enum, const, any_of), and attach metadata (title, description). It operates on schema and reference types to facilitate reusable, structured definitions, particularly useful for modeling API request/response formats and validation rules. Predefined primitives like number, string, and format-specific schemas (datetime, email) streamline the creation of common data representations in API components.",
      "description_length": 596,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Openapi_router.Make",
      "library": "openapi_router",
      "description": "This module constructs and manipulates OpenAPI specifications through fluent interface patterns, enabling programmatic assembly of API metadata (e.g., titles, versions) and reusable components like schemas, parameters, and response definitions. It operates on a core specification type (`t`) and JSON-reference-wrapped objects (`Json_schema.or_ref`) to support modular route definitions with rich HTTP operation metadata (tags, descriptions, request/response bodies). Typical use cases include generating OpenAPI-compliant API documentation, defining typed HTTP endpoints with structured validation, and composing reusable API components across distributed services.",
      "description_length": 666,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Openapi_router.Spec",
      "library": "openapi_router",
      "description": "This module models OpenAPI specification components through OCaml types and conversion utilities, enabling structured manipulation of API metadata, routing configurations, and documentation. It provides bidirectional JSON serialization (via Yojson), pretty-printing, and construction helpers for types representing HTTP parameters, response schemas, security schemes, server variables, and API paths. These capabilities support use cases like programmatic OpenAPI document generation, API validation, and integration of OpenAPI definitions into OCaml-based routing or documentation systems.",
      "description_length": 590,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Openapi_router.Json_Schema",
      "library": "openapi_router",
      "description": "This module provides a comprehensive system for defining, serializing, and validating JSON schemas, particularly for API development. It supports structured schema construction with types like `schema`, `map`, and `or_ref`, and includes operations for applying constraints (e.g., `enum`, `const`), defining primitives (e.g., `string`, `number`), and handling references. Built-in support for metadata (title, description) and format-specific schemas (datetime, email) enables rich, reusable definitions. Combined with its submodules, it allows both programmatic schema assembly and bidirectional conversion with JSON for dynamic validation and API modeling workflows.",
      "description_length": 667,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Openapi_router",
      "library": "openapi_router",
      "description": "This module enables programmatic construction and manipulation of OpenAPI specifications using OCaml types, supporting modular assembly of API metadata, routes, and reusable components. It centers around the `t` type for OpenAPI documents and uses `Json_schema.or_ref` for structured schema references, offering operations to define HTTP endpoints with rich metadata including parameters, responses, and security schemes. The module supports bidirectional JSON serialization, validation, and pretty-printing, facilitating use cases like generating API documentation, defining typed routes with validation, and integrating OpenAPI specs into routing systems. Example workflows include composing API components across services, validating request/response payloads, and dynamically generating OpenAPI JSON from OCaml code.",
      "description_length": 820,
      "index": 4,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 5,
    "meaningful_modules": 5,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 820,
    "min_description_length": 590,
    "avg_description_length": 667.8,
    "embedding_file_size_mb": 0.01859283447265625
  }
}