{
  "package": "vscoq-language-server",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 71,
  "creation_timestamp": "2025-07-15T23:18:13.860356",
  "modules": [
    {
      "module_path": "Dm.DocumentManager.Internal",
      "library": "vscoq-language-server.dm",
      "description": "Handles document state transitions and event transformations within a Coq IDE environment. It provides functions to access document components, inject document events into the event stream, and validate document changes based on parsing feedback. Works directly with document states, raw documents, execution states, and sentence identifiers to support text editing, feedback handling, and document navigation workflows.",
      "description_length": 420,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.DelegationManager.MakeWorker",
      "library": "vscoq-language-server.dm",
      "description": "Handles job delegation and event processing in a worker pool, managing job execution and feedback. It works with job handles, event queues, and cancellation mechanisms to coordinate task distribution and result handling. Concrete use cases include scaling the worker pool dynamically, logging job events, and setting up job execution pipelines with feedback channels.",
      "description_length": 367,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.DelegationManager.Job",
      "library": "vscoq-language-server.dm",
      "description": "This module defines job configurations for managing worker processes, including command-line options and binary names when forking is unavailable. It supports feedback handling through `appendFeedback`, which processes worker-generated feedback with route IDs and sentence data. It works with types like `Feedback.route_id`, `Dm.Types.sentence_id`, `Feedback.level`, `Loc.t`, and `Quickfix.t`.",
      "description_length": 393,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.Types.RangeList",
      "library": "vscoq-language-server.dm",
      "description": "This module manages lists of LSP ranges with operations to insert, merge, remove, truncate, and cut ranges within a list. It ensures that ranges remain non-overlapping and properly ordered after each operation. It is used to maintain accurate text document regions in response to edits or selections.",
      "description_length": 300,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.DelegationManager.Worker",
      "library": "vscoq-language-server.dm",
      "description": "Handles event-driven job delegation and worker management with dynamic pool resizing. It processes events to update job states, manages worker availability, and routes feedback through cancellation handles and forked job execution. Concrete use cases include coordinating distributed task execution and managing dynamic worker pools in response to runtime events.",
      "description_length": 363,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dm.Document.Internal",
      "library": "vscoq-language-server.dm",
      "description": "Handles low-level manipulation and transformation of document content elements, including text normalization, sentence parsing, and code line formatting. Works directly with sentence and code_line types, converting structured document components to string representations. Used during document rendering and content processing to ensure consistent textual output.",
      "description_length": 363,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dm.ExecutionManager.ProofWorkerProcess",
      "library": "vscoq-language-server.dm",
      "description": "Handles proof processing in a delegated Coq toplevel environment without forking. It parses command-line options for proof execution, initializes the proof state, and runs the main processing loop. This module is used to execute proof scripts in isolated worker processes, ensuring safe and controlled evaluation of Coq commands.",
      "description_length": 329,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dm.ParTactic.TacticWorkerProcess",
      "library": "vscoq-language-server.dm",
      "description": "Handles command-line options and initializes a tactic worker process for parallel tactic execution. It parses arguments into structured options and starts the main processing loop with a given Coq state. The log function writes messages to a file, with optional forcing, supporting debugging and progress tracking in distributed tactic evaluation scenarios.",
      "description_length": 357,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.PriorityManager",
      "library": "vscoq-language-server.dm",
      "description": "This module defines integer constants representing priority levels for various operations in a development environment, such as parsing, execution, and user feedback. These priorities are used to control the order in which tasks are processed, ensuring critical actions like cursor movement or parsing are handled promptly. Concrete use cases include scheduling LSP (Language Server Protocol) messages and managing UI responsiveness during code execution.",
      "description_length": 455,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.ParTactic",
      "library": "vscoq-language-server.dm",
      "description": "This module manages tactic execution in separate processes, coordinating feedback through identifiers to align results with proof steps. It provides data types for options, identifiers, and routes, with operations to spawn workers, log messages, and correlate tactic outcomes. The child module handles argument parsing, worker initialization, and logging, enabling distributed tactic evaluation with structured debugging. Example usage includes launching a tactic worker with parsed options, tracking proof step results via sentence IDs, and writing execution logs for auditing distributed proof searches.",
      "description_length": 605,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.ExecutionManager",
      "library": "vscoq-language-server.dm",
      "description": "This module coordinates task execution for document processing, managing state transitions, delegating work to workers, and handling errors. It maintains document consistency during iterative proof checking and supports dynamic invalidation of outdated events using document states, execution contexts, and vernacular data structures. The proof processing submodule executes Coq scripts in isolated worker environments, initializing proof states and running processing loops without forking. Together, they enable context-sensitive task execution and diagnostic propagation across state changes.",
      "description_length": 595,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.CompletionSuggester",
      "library": "vscoq-language-server.dm",
      "description": "Handles completion requests by generating a list of possible completions based on the current editor state and user settings. It processes the input context using parsing and analysis utilities to suggest relevant code snippets or identifiers. This module is used during interactive editing to provide context-aware auto-completion in the IDE.",
      "description_length": 343,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.Document",
      "library": "vscoq-language-server.dm",
      "description": "This module organizes document content into hierarchical structures of sentences, code lines, and comments, supporting parsing, validation, and transformation with precise positional metadata and error tracking. It enables structured navigation, LSP-compliant range generation, and scheduling of proof elements like theorems for incremental processing. The child module handles low-level text normalization, sentence parsing, and code line formatting, converting structured elements to consistent textual representations during rendering and processing. Together, they support tasks such as document editing, proof script analysis, and integration with interactive proof assistants.",
      "description_length": 682,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.DocumentManager",
      "library": "vscoq-language-server.dm",
      "description": "This module organizes document states, execution contexts, and event streams to support text editing, feedback handling, and navigation in a Coq IDE. It provides data types like document states, raw documents, execution states, and sentence identifiers, with operations to inject events, validate changes, and access document components. You can use it to manage transitions between document versions, process user edits, and integrate parsing feedback without requiring IDEs to parse vernacular sentences directly. Submodules extend these capabilities to handle specific workflows like event transformation and state validation.",
      "description_length": 629,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.CompletionItems",
      "library": "vscoq-language-server.dm",
      "description": "This module defines a data structure for completion items used in interactive theorem proving, including references, types, environments, and completion status. It provides functions to create and pretty-print these items, with a helper to generate symbolic prefixes based on completion level. Concrete use cases include displaying auto-completion suggestions in proof assistants and debugging term reconstruction.",
      "description_length": 414,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dm.SearchQuery",
      "library": "vscoq-language-server.dm",
      "description": "Handles search queries and feedback notifications for a language server protocol. It interprets search requests within a given environment and evar map, returning qualified identifier lists based on specified restrictions. Useful for implementing code navigation and symbol search features in an IDE.",
      "description_length": 300,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.DelegationManager",
      "library": "vscoq-language-server.dm",
      "description": "This module coordinates job delegation and cancellation for tasks linked to specific sentences and routes, using `job_handle` values to track and manage execution, report errors, and enable cancellation. It integrates worker pool management, job configuration, and event-driven job handling to support dynamic task distribution, feedback processing, and runtime worker pool adjustments. You can use it to assign jobs to workers, append feedback for specific route and sentence IDs, and scale worker resources in response to incoming events. Concrete workflows include managing asynchronous validation pipelines, handling forked and non-forked job execution, and routing worker feedback with location and severity metadata.",
      "description_length": 722,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dm.RawDocument",
      "library": "vscoq-language-server.dm",
      "description": "This module manages raw text documents with precise location tracking, supporting operations to convert between character offsets and LSP positions, extract substrings, and apply text edits. It works with strings and LSP range/position types, maintaining internal state for efficient document manipulation. Concrete use cases include handling user input in an editor, applying LSP-compliant text changes, and retrieving words or ranges for code analysis.",
      "description_length": 454,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.Types",
      "library": "vscoq-language-server.dm",
      "description": "This module defines core data types for document state, execution ranges, and inter-process communication, enabling structured tracking of sentence IDs, text edits, and error responses. It includes an overview type for execution state tracking using range lists, which are managed by a child module that supports insertion, merging, removal, truncation, and cutting of non-overlapping, ordered LSP ranges. These capabilities facilitate document processing pipelines, coordination of LSP-based text edits, and handling of inter-process communication via file descriptors. Example uses include maintaining text document regions during edits and synchronizing state changes across processes.",
      "description_length": 688,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.Scheduler",
      "library": "vscoq-language-server.dm",
      "description": "This module manages the planning and execution of document sentences, handling dependencies and task delegation. It works with sentences parsed into structured tasks like execution blocks, queries, or opaque proofs, and tracks their relationships in a schedule. Concrete use cases include incremental document processing, error recovery during interpretation, and determining invalidated sentences after changes.",
      "description_length": 412,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm.Log",
      "library": "vscoq-language-server.dm",
      "description": "This module manages logging and event handling during initialization processes, capturing log messages and events for debugging and feedback. It provides functions to create and retrieve logs, track initialization events, and handle messages with locational and quickfix data. Concrete use cases include logging worker initialization steps, capturing LSP initialization events, and feeding back type-checking results with precise source locations.",
      "description_length": 447,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dm",
      "library": "vscoq-language-server.dm",
      "description": "This module orchestrates document processing and interactive editing in a proof assistant environment, managing priorities, task execution, and structured communication between components. It centers around document states, sentence identifiers, execution contexts, and LSP-compliant ranges, with operations for parsing, scheduling, validating, and providing feedback on proof scripts and user edits. You can use it to manage proof step execution with isolated workers, generate context-aware completions, track errors across state changes, and handle fine-grained text edits with positional accuracy. Specific workflows include coordinating tactic evaluation, processing Coq scripts incrementally, and supporting auto-completion and symbol search in an IDE.",
      "description_length": 758,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Language.Hover",
      "library": "vscoq-language-server.language",
      "description": "Computes hover information for qualified identifiers in a given environment and evar map, returning formatted markup content. It processes identifiers that may be represented by notation, resolving their documentation or type information. This function is used to support IDE hover features, providing contextual details during code editing.",
      "description_length": 341,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Language",
      "library": "vscoq-language-server.language",
      "description": "This module computes hover information for identifiers in a programming environment, resolving their documentation or type details even when represented by notation. It processes identifiers within a given environment and evar map to generate formatted markup content. Main data types include environments, evar maps, and identifiers, with operations that support resolving and formatting documentation. For example, it enables IDEs to display type signatures or doc comments when hovering over a variable or function in the editor.",
      "description_length": 532,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.ResetParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling reset parameters in a language server protocol, specifically containing a text document identifier. It provides functions to convert this structure to and from JSON format using the Yojson library. This module is used when a client requests to reset the state of a specific text document in an editor or IDE integration.",
      "description_length": 370,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.DocumentStateParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` representing parameters for a document state request, specifically containing a `textDocument` field of type `Lsp.Types.TextDocumentIdentifier.t`. It provides functions `t_of_yojson` and `yojson_of_t` for converting between JSON and the `t` type. This module is used to serialize and deserialize document state request parameters in LSP (Language Server Protocol) communication.",
      "description_length": 409,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Client.InterpretToPointParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling notification parameters that include a versioned text document identifier and a position. It provides serialization and deserialization functions to and from JSON using the Yojson library. This module is used to interpret client notifications that point to specific locations within a text document.",
      "description_length": 349,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Client.StepForwardParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure representing parameters for a step-forward notification in a language server protocol. It includes serialization and deserialization functions for converting between JSON and the structured type, specifically handling a versioned text document identifier. It is used to convey document context during debugging or execution stepping operations.",
      "description_length": 381,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Client.InterpretToEndParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure representing parameters for a notification related to interpreting a versioned text document. It includes functions to convert the structure to and from JSON format using Yojson. A concrete use case is handling notifications in a language server protocol extension where a client requests interpretation of a specific document version.",
      "description_length": 372,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.DocumentProofsResult",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` that represents a list of proof blocks, specifically used to encapsulate document proofs results. It includes functions to convert this type to and from Yojson format, enabling serialization and deserialization for data exchange. This module is typically used in client-side operations to handle responses containing cryptographic proofs associated with documents.",
      "description_length": 395,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.DocumentStateResult",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for representing a document state result with a single string field. It provides functions to serialize and deserialize this structure to and from JSON format using the Yojson library. This is useful when handling document state responses in a client-server communication protocol where JSON is the exchange format.",
      "description_length": 352,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.DocumentProofsParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for specifying a text document identifier in requests related to document proofs. It includes functions to convert the structure to and from JSON format using Yojson. A concrete use case is handling document identification in proof-related operations within a language server protocol.",
      "description_length": 322,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Server.MoveCursorParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for representing cursor movement parameters in a document, including the document URI and a range. It provides serialization and deserialization functions to and from JSON format. This is used to handle notifications related to cursor positioning in a language server protocol implementation.",
      "description_length": 329,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Server.CoqLogMessageParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling log message notifications in a server protocol. It includes functions to convert the structure to and from JSON format using Yojson. A concrete use case is transmitting log messages between a Coq server and client during interactive proof development.",
      "description_length": 301,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.SearchParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for capturing search parameters in a language server protocol request, including the document identifier, position, search pattern, and unique request ID. It provides serialization and deserialization functions to and from JSON using the Yojson library. This module is used to handle client-initiated search requests within an extended LSP implementation.",
      "description_length": 392,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.PrintParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for capturing request parameters used in client-side print operations, including a versioned text document identifier, a position within the document, and a pattern string. It provides serialization and deserialization functions to and from JSON format, enabling easy integration with JSON-based communication protocols. This module is typically used to transmit print parameter data between a language server and a client in an LSP (Language Server Protocol) extension.",
      "description_length": 507,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Server.ProofViewParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure `t` that holds optional proof state information and a list of diagnostic messages with associated severities. It provides serialization and deserialization functions to and from Yojson for use in JSON-based communication, particularly in server notifications. It is used to convey proof view parameters and related diagnostics in an LSP (Language Server Protocol) context.",
      "description_length": 409,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Client.StepBackwardParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling step-backward notifications in a language server protocol, specifically containing a versioned text document identifier. It includes functions to convert instances of this structure to and from JSON format. This module is used to notify the client to step backward within a specific version of a text document during debugging or interactive editing sessions.",
      "description_length": 409,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.Settings.Goals.Diff.Mode",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` representing the display mode for goal differences, with variants `On`, `Off`, and `Removed`. It includes functions to convert between this type and JSON format, using string representations. This type is used to control and serialize the visibility of goal differences in a settings configuration.",
      "description_length": 329,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.CheckParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling check parameters in a language server protocol, specifically capturing a versioned text document identifier, a position, and a search pattern. It includes functions to serialize and deserialize the structure to and from JSON, enabling seamless communication between client and server. This is used to support features like on-demand code analysis or validation triggered at specific positions within a document.",
      "description_length": 461,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.AboutParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure `t` representing parameters for a client request, including a versioned text document identifier, a position, and a search pattern. It provides serialization and deserialization functions to and from Yojson for use in JSON-RPC communication. This module is used to pass parameters when querying for information related to a specific document position and pattern in a language server protocol context.",
      "description_length": 438,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Server.BlockOnErrorParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling block-on-error notifications in a language server protocol. It includes serialization and deserialization functions for converting between JSON and the record type containing a document URI and a range. It is used to specify the location of errors that should block further processing in the server.",
      "description_length": 349,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client.LocateParams",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for handling locate requests in a language server protocol, specifically capturing the document identifier, position, and search pattern. It provides serialization and deserialization functions to and from JSON, enabling communication between client and server. Concrete use cases include processing user requests to locate specific code elements within a document based on a given pattern.",
      "description_length": 427,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Server",
      "library": "vscoq-language-server.lsp",
      "description": "This module coordinates editor interactions and system events in a proof assistant environment, enabling structured updates for syntax highlighting, cursor movement, proof state display, logging, and error handling. It leverages child modules to define key data structures such as cursor movement parameters, log messages, proof state diagnostics, and block-on-error locations, each with JSON serialization for LSP compatibility. Operations allow the server to send precise client notifications, like updating the proof view with current state and diagnostics or logging messages during theorem proving sessions. Together, the module and its submodules support seamless, structured communication between Coq server and client during interactive development.",
      "description_length": 757,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Goals.Diff",
      "library": "vscoq-language-server.lsp",
      "description": "This module represents differences in goal settings, providing a data structure to capture and serialize these differences to and from JSON. It includes a core type `t` that encodes the nature of the differences, along with operations to convert it to JSON for storage or transmission. The nested `Mode` module defines display modes like `On`, `Off`, and `Removed`, which control how differences are presented and are also serializable to JSON strings. Together, these components allow configurations to persist, transmit, and reconstruct goal setting changes with precise control over their visibility and format.",
      "description_length": 614,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request.Client",
      "library": "vscoq-language-server.lsp",
      "description": "This module orchestrates client-side request processing for a protocol, transforming JSON-RPC inputs into typed values and serializing results to Yojson. It centers around data types like document identifiers, versioned documents, positions, and search patterns, with operations for parsing and generating structured requests and responses. Submodules refine this structure with specific use cases: handling document state requests, proof blocks, search, check, and locate parameters, each equipped with JSON conversion functions. Examples include parsing a client's document state query, serializing a proof response, or transmitting search parameters with document context and a unique request ID.",
      "description_length": 699,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Goals.Messages",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for representing goal-related settings messages with a single boolean field indicating completeness. It provides functions to convert this structure to and from JSON format using the Yojson library. This is used to serialize and deserialize goal configuration data for transmission or storage.",
      "description_length": 330,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification.Client",
      "library": "vscoq-language-server.lsp",
      "description": "This module handles client-to-server notifications for controlling execution and interpretation in a language server protocol, defining structured types like `InterpretToEnd` and `StepForward` that carry contextual parameters. Its submodules provide data structures tied to versioned text documents, supporting operations such as stepping forward or backward and interpreting to specific points, with JSON serialization via Yojson. Functions like `of_jsonrpc` convert raw JSON-RPC messages into typed notifications, enabling precise session control based on structured document positions and versions. Examples include stepping through a document version during debugging or triggering interpretation at a specific cursor location.",
      "description_length": 731,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.Settings.Completion.RankingAlgoritm",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` with two variants representing distinct ranking algorithms used in code completion. It provides serialization and deserialization functions to and from Yojson integer representations. The module is used to configure and persist ranking strategy preferences in code completion settings.",
      "description_length": 316,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Request",
      "library": "vscoq-language-server.lsp",
      "description": "This module handles client-side request processing for a protocol, converting JSON-RPC inputs into typed values and serializing results to Yojson. It defines key data types such as document identifiers, versioned documents, positions, and search patterns, along with operations for parsing and generating structured requests and responses. Submodules support specific operations like document state queries, proof blocks, and search parameters, each with JSON conversion utilities. Example uses include parsing a document state request, serializing a proof response, or sending search parameters with document context and a unique request ID.",
      "description_length": 642,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.LspWrapper.CoqFeedback",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for representing Coq feedback messages with a range, message text, and feedback channel. It includes serialization and deserialization functions for converting between S-expressions and JSON formats. It is used to transmit structured feedback from Coq to an LSP client, such as error messages or proof state updates tied to specific source code locations.",
      "description_length": 392,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.LspWrapper.Range",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines and manipulates text range structures composed of start and end positions. It supports creating ranges, comparing them, checking inclusion and ordering relationships, and converting to and from JSON and S-expressions. Typical use cases include tracking regions in source files, validating overlapping or nested ranges, and serializing range data for communication in language server protocols.",
      "description_length": 413,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.LspWrapper.Position",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a position in a text document using line and character offsets, adhering to the LSP specification. It provides functions to construct positions, convert them to and from JSON and S-expressions, and compare or display them. Use cases include tracking cursor locations, file edits, and diagnostic reporting in language server implementations.",
      "description_length": 360,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Mode",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` representing two operational modes: `Continuous` and `Manual`. It provides functions `yojson_of_t` and `t_of_yojson` for converting between these mode values and their integer-based Yojson representations. This module is used to serialize and deserialize mode settings in JSON format, particularly when communicating with external systems or storing configuration data.",
      "description_length": 400,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.LspWrapper.DiagnosticSeverity",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` representing diagnostic severity levels in the LSP protocol, with constructors for Error, Warning, Information, and Hint. It provides functions to convert between this type and sexp, Yojson, and a feedback level, enabling integration with serialization and user feedback systems. Use cases include mapping internal diagnostic levels to LSP-compatible values and serializing diagnostics for transmission or storage.",
      "description_length": 445,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ExtProtocol.Notification",
      "library": "vscoq-language-server.lsp",
      "description": "This module manages bidirectional communication between client and server in a proof assistant environment, coordinating structured updates for syntax highlighting, cursor movement, proof state display, and execution control. Key data types include versioned document positions, log messages, diagnostics, and commands like `InterpretToEnd` and `StepForward`, all supporting JSON serialization for LSP compatibility. Operations enable precise notifications such as updating the proof view, logging during theorem proving, and converting JSON-RPC messages into typed commands. Examples include stepping through a document version during debugging or triggering interpretation at a specific cursor location.",
      "description_length": 705,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.DelegationMode",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` representing delegation modes with variants `None`, `Skip`, and `Delegate`. It provides serialization and deserialization functions to and from Yojson for this type. This module is used to handle configuration settings for delegation behavior in protocol operations.",
      "description_length": 297,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.PointInterpretationMode",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines an enumeration with two variants, `Cursor` and `NextCommand`, representing different modes for interpreting points in a command sequence. It provides functions `yojson_of_t` and `t_of_yojson` for converting between the enumeration and JSON integer representations. This module is used to serialize and deserialize point interpretation modes when communicating with external systems or storing configuration settings.",
      "description_length": 436,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Completion",
      "library": "vscoq-language-server.lsp",
      "description": "This module configures code completion behavior through settings that control ranking algorithms and type prioritization. It centers around a record type with boolean flags, algorithm selections, and numeric parameters, supporting serialization via YoJSON. The included ranking algorithms, represented as a type with two variants, determine how completion items are ordered based on type and size. Example uses include adjusting ranking strategies in an IDE to favor specific types or smaller completions during development.",
      "description_length": 524,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Diagnostics",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a configuration structure for controlling diagnostic behavior, specifically whether diagnostics are enabled and whether full diagnostics are provided. It includes functions to convert the structure to and from JSON format using Yojson. This module is used to manage diagnostic settings in a language server, enabling or disabling error reporting and highlighting based on client configuration.",
      "description_length": 413,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.LspWrapper.QuickFixData",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for representing quick fix information in a text editor, including the text to apply and the range it affects. It provides serialization and deserialization functions to and from JSON, enabling integration with JSON-based communication protocols. It is used to transmit code fix suggestions between a language server and a client.",
      "description_length": 367,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Memory",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a data structure for managing memory settings with a single integer limit. It provides functions to convert this structure to and from JSON format, enabling easy serialization and deserialization. Concrete use cases include configuring and persisting memory constraints in a system that requires strict memory management.",
      "description_length": 341,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.LspWrapper.FeedbackChannel",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a type `t` with three variants (`Debug`, `Info`, `Notice`) representing feedback levels. It provides functions to convert between `t` and S-expressions, Yojson, and a `Feedback.level` type. Use cases include serializing feedback levels for logging or configuration and mapping external feedback representations to internal types.",
      "description_length": 349,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings.Proof",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines a record type for proof settings, including delegation mode, worker count, execution mode, block handling, and point interpretation mode. It provides serialization and deserialization functions to and from Yojson for this type. Use this module to configure and persist proof-related parameters in a structured format during protocol execution.",
      "description_length": 363,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.Settings.Goals",
      "library": "vscoq-language-server.lsp",
      "description": "This module manages goal settings by converting structured data to and from JSON, centering on a record type `t` that pairs a `Diff` module-defined difference with a `Messages` module-defined message set. The `Diff` module captures changes in goal settings, using a `t` type alongside a `Mode` submodule with `On`, `Off`, and `Removed` display states, all serializable to JSON. The `Messages` module complements this with a boolean-gated message structure for completeness tracking, also supporting JSON conversion via Yojson. Together, these components enable precise persistence, transmission, and reconstruction of goal configuration changes with controlled visibility and formatting.",
      "description_length": 687,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.LspWrapper",
      "library": "vscoq-language-server.lsp",
      "description": "This module organizes data structures and serialization routines for LSP interactions in a Coq environment, bridging the Coq server and editor frontend. It defines core types like `query_result` and `overview` for managing code queries and document state, while submodules handle feedback messages, text ranges, positions, diagnostic severities, quick fixes, and feedback levels with conversions to JSON and S-expressions. You can represent and serialize diagnostic messages with positional information, track code regions with range operations, or send proof state updates to an editor. Functions support constructing, comparing, and converting these types, enabling precise error reporting, code navigation, and structured feedback transmission.",
      "description_length": 747,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Settings",
      "library": "vscoq-language-server.lsp",
      "description": "This module orchestrates protocol configuration through a suite of composite settings governing proof mechanics, goal handling, diagnostics, completion strategies, and memory constraints. Core data structures include records for proof and goal settings, enumeration types for operational modes, and integer-backed JSON serializable values for delegation, display states, and interpretation rules. Operations span runtime configuration updates, cross-system settings synchronization, and structured persistence of protocol behaviors. For example, proof settings integrate delegation modes and worker counts to control verification workflows, while completion settings tune ranking algorithms to prioritize specific types during IDE interactions.",
      "description_length": 744,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol.ExtProtocol",
      "library": "vscoq-language-server.lsp",
      "description": "This module implements a protocol for structured communication in a proof assistant environment, handling client-server interactions with typed data representations of documents, positions, and commands. It supports parsing and serializing JSON-RPC messages for operations like document state queries, proof navigation, and search, using data types such as versioned documents, positions, and log messages. Key operations include converting requests to typed values, generating responses with unique identifiers, and sending structured updates for proof state and execution control. Example uses include interpreting a document from a given cursor position, serializing a proof response with metadata, or stepping through a proof with versioned document tracking.",
      "description_length": 763,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.Printing",
      "library": "vscoq-language-server.lsp",
      "description": "This module provides functions to convert between a custom pretty-printing type and Yojson representations, enabling serialization and deserialization of pretty-printed Coq terms. It works with the `pp` type and Coq's `Pp.t` type, facilitating interoperability with Coq's internal pretty-printing system. Concrete use cases include transmitting formatted Coq output over JSON-based protocols or storing formatted terms in a structured data format.",
      "description_length": 447,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol.ProofState",
      "library": "vscoq-language-server.lsp",
      "description": "This module defines data structures for representing proof states, including proof statements, steps, and blocks, along with JSON serialization and deserialization functions for each. It provides constructors to create proof elements with associated source ranges and supports extracting proof state information from Coq's Vernacstate. Concrete use cases include tracking proof progress in an IDE and synchronizing proof data over LSP.",
      "description_length": 435,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol",
      "library": "vscoq-language-server.lsp",
      "description": "This module suite enables structured communication and data management in a Coq-based proof assistant environment, integrating LSP interactions, protocol configuration, and proof state tracking. It centers around core data types such as `query_result`, versioned documents, proof elements, configuration records, and custom pretty-printing representations, with operations for serialization to JSON and S-expressions. Functionality includes handling document state queries, proof navigation, diagnostic reporting with positional data, runtime configuration updates, and conversion of Coq terms to structured formats. Examples include transmitting formatted proof output over LSP, synchronizing goal states with an editor, configuring proof delegation modes, and serializing document updates with positional metadata.",
      "description_length": 816,
      "index": 70,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 71,
    "meaningful_modules": 71,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 816,
    "min_description_length": 297,
    "avg_description_length": 466.23943661971833,
    "embedding_file_size_mb": 0.2583599090576172
  }
}