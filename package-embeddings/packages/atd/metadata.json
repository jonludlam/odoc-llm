{
  "package": "atd",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 26,
  "creation_timestamp": "2025-08-15T12:17:51.385304",
  "modules": [
    {
      "module_path": "Atd.Import.Option.O",
      "library": "atd",
      "description": "This module provides a monadic bind operator for composing sequences of computations that may fail, where each step returns an `option` type. It works with values of type `'a option`, enabling chaining operations that depend on the success of prior steps. A concrete use case is processing nested optional data, such as traversing a structure where each field may be missing, and only proceeding if all required fields are present.",
      "description_length": 431,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Import.List",
      "library": "atd",
      "description": "This module provides functions for element access, structural manipulation (cons, append, reverse), traversal (folds, iterators), transformation (map, filter), sorting, and associative lookups. It operates on generic `'a list` types, pairs of lists, and sequences, supporting use cases like accumulation with left/right folds, partitioning lists based on predicates, merging sorted sequences, and managing key-value associations with efficient lookup and update operations.",
      "description_length": 473,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Ast.Map",
      "library": "atd",
      "description": "Transforms nodes in an ATD abstract syntax tree by applying user-defined functions to each node and recursively processing their children. It operates on AST components like type expressions, variants, fields, type definitions, and module elements. Use this module to modify specific parts of an ATD AST while preserving its overall structure, such as rewriting type annotations or adjusting field attributes during code generation or analysis.",
      "description_length": 444,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Sort.Make",
      "library": "atd",
      "description": "Implements a topological sort that handles cycles by grouping nodes into acyclic singletons or cyclic groups marked with a boolean. It operates on directed graphs represented as lists of nodes paired with their dependencies, producing a partitioned list where each group is either a non-cyclic single element or a cycle. This is particularly useful for sorting type definitions into dependency order while minimizing recursive groups, improving performance and code clarity in code generation tasks.",
      "description_length": 499,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Atd.Import.Option",
      "library": "atd",
      "description": "This module provides functions for working with `'a option` values, including mapping over options, extracting values with or without a default, and checking presence. It supports operations like `map`, `value_exn`, `value`, and `is_some`, which facilitate handling optional data safely. A concrete use case is processing JSON fields that may be missing, where each function allows structured and safe unwrapping or transformation of optional values.",
      "description_length": 450,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Parser",
      "library": "atd",
      "description": "Parses ATD files into abstract syntax trees using a token stream generated from lexing buffers. It handles the full structure of ATD modules, including type definitions and inheritance. Useful for processing ATD specifications to generate code or analyze type declarations.",
      "description_length": 273,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Jsonschema",
      "library": "atd",
      "description": "Translates ATD type definitions into JSON Schema, supporting Draft 2019-09 and Draft 2020-12 versions. It processes an ATD AST module, applies schema transformations based on `<json ...>` annotations, and outputs the resulting JSON Schema to a channel. Useful for generating validation schemas from ATD type declarations for external JSON validation tools.",
      "description_length": 356,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Version",
      "library": "atd",
      "description": "Contains a single value representing the version of the ATD library as a string. It is used to check or display the current version of the library at runtime. Useful for debugging, logging, or ensuring compatibility in systems that depend on specific ATD versions.",
      "description_length": 264,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Lexer",
      "library": "atd",
      "description": "This module implements a lexer for parsing ATD files, handling tasks like reading tokens, processing string literals, and managing comments. It operates on lex buffers and uses mutable accumulators to track parsing state, such as depth in nested comments and buffered string content. Concrete use cases include converting hexadecimal and decimal character sequences into bytes, lexing quoted strings with escape handling, and recognizing ATD-specific syntax elements like type definitions and annotations.",
      "description_length": 505,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Doc",
      "library": "atd",
      "description": "This module processes documentation annotations embedded in ATD type definitions, providing functions to parse, print, and convert documentation blocks into HTML. It handles structured documentation elements like paragraphs, inline code, and preformatted text blocks. Use it to extract and render documentation from ATD source files into formatted output such as HTML or custom documentation generators.",
      "description_length": 403,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Sort",
      "library": "atd",
      "description": "Performs topological sorting on directed graphs, handling cycles by grouping nodes into acyclic singletons or cyclic groups marked with a boolean. Works with lists of nodes paired with their dependencies, producing a partitioned list that orders dependencies while isolating cycles. Used to sort type definitions by dependency for code generation, reducing unnecessary recursive groups and improving compiler performance and output clarity.",
      "description_length": 440,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Util",
      "library": "atd",
      "description": "This module parses ATD files from various input sources like strings, channels, or lex buffers, producing abstract syntax trees and expanded type definitions. It supports configurable parsing through optional parameters for schema annotations, type expansion, and position tracking. The `tsort` function organizes type definitions into topologically sorted groups for dependency resolution.",
      "description_length": 390,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Print",
      "library": "atd",
      "description": "This module provides functions for pretty-printing ATD abstract syntax trees into formatted strings using the `Easy_format` library. It supports converting type expressions, type names with arguments, and full modules into human-readable representations. Concrete use cases include generating readable output for ATD definitions and debugging ATD AST structures during parsing or transformation tasks.",
      "description_length": 401,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Atd.Ast",
      "library": "atd",
      "description": "This module enables manipulation of abstract syntax trees through operations like transforming type expressions, handling source locations, and traversing nodes. It operates on ATD data structures such as type definitions, annotations, and module-level constructs, supporting tasks like code analysis, type representation optimization, and structural simplification of AST elements. Specific transformations include variant specialization, wrapper removal, and type expression normalization for improved AST processing.",
      "description_length": 519,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Doc_types",
      "library": "atd",
      "description": "This module defines basic document structures for representing formatted text, with `inline` handling text and code fragments and `block` organizing them into paragraphs or preformatted blocks. It is used to model lightweight markup documents, such as comments or documentation extracts, in a structured way. Concrete use cases include parsing and rendering simple documentation formats where inline styling and code snippets are needed.",
      "description_length": 437,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Expand",
      "library": "atd",
      "description": "Monomorphizes type expressions in AST module bodies by replacing repeated type structures with references to generated type definitions. Works with abstract syntax trees and hash tables mapping original types to their monomorphized counterparts. Useful for optimizing type representations in code generation pipelines by eliminating redundant type expressions.",
      "description_length": 360,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Predef",
      "library": "atd",
      "description": "This module defines a list of predefined types used by ATD, including their names, identifiers, and optional type definitions. It provides a function to create a hash table mapping type names to their associated identifiers and type definitions. These are used during type processing and resolution in ATD-based code generation and parsing workflows.",
      "description_length": 350,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Json",
      "library": "atd",
      "description": "This module defines data types and functions for specifying how ATD types map to JSON representations, including handling of integers, floats, lists, records, and variants. It supports custom adapters for normalization and restoration, and controls JSON formatting aspects like null handling and enum representation. Concrete use cases include configuring JSON serialization for ATD-defined types, mapping field names to JSON keys, and defining custom parsing logic for specific JSON structures.",
      "description_length": 495,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Import",
      "library": "atd",
      "description": "This module includes submodules for list and option types, offering operations like mapping, filtering, folding, and safe value extraction. It provides functions for string formatting and output, including `sprintf`, `printf`, and `bprintf`, which handle formatted text generation and logging. Use cases include parsing and transforming structured data, managing optional values safely, and generating formatted output for debugging or file logging.",
      "description_length": 449,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Doc_lexer",
      "library": "atd",
      "description": "This module handles lexing and parsing of structured documentation text, converting raw strings into typed block and inline document structures. It provides functions for processing paragraphs, verbatim text, and inline elements, managing lexing state through lexbuf. Concrete use cases include parsing documentation comments into structured formats for pretty-printing or further processing.",
      "description_length": 392,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Loc",
      "library": "atd",
      "description": "This module represents and compares source code locations using pairs of Lexing.position values. It provides a `compare` function to determine the order of locations based on their positions in the source file. Useful for tracking and comparing the positions of tokens or expressions in parsed files.",
      "description_length": 300,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Atd.Check",
      "library": "atd",
      "description": "Validates the semantic correctness of ATD files by checking for unique type definitions and other structural constraints. Operates directly on the abstract syntax tree (`Atd.Ast.module_body`) to enforce validity rules. Ensures that no duplicate type names exist and that all type references are well-formed.",
      "description_length": 307,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Atd.Reflect",
      "library": "atd",
      "description": "This module converts an ATD AST value into OCaml source code that reconstructs the value. It operates on data structures defined in the Atd.Ast module, particularly `full_module`. A concrete use case is generating OCaml code from an in-memory ATD tree representation for serialization or debugging purposes.",
      "description_length": 307,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Unique_name",
      "library": "atd",
      "description": "This module manages the translation of identifiers between source and destination spaces, ensuring uniqueness by adding suffixes or prefixes compatible with Python syntax. It provides functions to initialize translation tables, create and reserve identifiers, and perform bidirectional translations. Concrete use cases include generating unique variable names during code generation or avoiding naming conflicts when mapping identifiers between different programming language contexts.",
      "description_length": 485,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Annot",
      "library": "atd",
      "description": "This module provides functions to query and manipulate structured annotations, including checking for the existence of sections and fields, extracting and parsing field values with type-specific logic, and setting or merging annotation fields. It works with annotation data structures that contain nested sections, fields, and associated values, along with location information for error reporting. Concrete use cases include validating and interpreting configuration directives embedded in annotations, such as flags or parameters controlling code generation or schema constraints.",
      "description_length": 582,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Atd.Inherit",
      "library": "atd",
      "description": "Expands `inherit` statements within sum and product types in ATD module bodies. Accepts flags to control inheritance of fields and variants, transforming the structure by merging inherited definitions. Useful for processing ATD specifications that use inheritance to share type definitions across modules.",
      "description_length": 305,
      "index": 25,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 27,
    "meaningful_modules": 26,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9629629629629629
  },
  "statistics": {
    "max_description_length": 582,
    "min_description_length": 264,
    "avg_description_length": 408.34615384615387,
    "embedding_file_size_mb": 0.3771839141845703
  }
}