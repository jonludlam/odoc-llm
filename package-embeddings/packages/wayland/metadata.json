{
  "package": "wayland",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 270,
  "creation_timestamp": "2025-08-18T19:32:15.632146",
  "modules": [
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1.Layer",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type representing distinct screen layers for rendering surfaces in a Wayland compositor. It provides conversions between these layer values and 32-bit integers, enabling their use in protocol messages. Concrete use cases include specifying the stacking order of fullscreen or overlay windows relative to regular shell surfaces.",
      "description_length": 361,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_surface.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for XDG surface operations in the Wayland protocol. It includes specific errors like `Not_constructed`, `Already_constructed`, and `Invalid_serial`, and provides functions to convert between error values and 32-bit integers. These conversions are used to interface with low-level protocol messages and handle surface state transitions correctly.",
      "description_length": 377,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1.Flags",
      "library": "wayland.protocols",
      "description": "This module defines flags for buffer parameters in the Linux DMABUF protocol, including `y_invert`, `interlaced`, and `bottom_first`. It provides direct mappings to and from `int32` values for efficient flag manipulation. These flags are used to specify buffer properties when working with display buffers in Wayland compositors.",
      "description_length": 329,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_popup.Error",
      "library": "wayland.protocols",
      "description": "This module defines an error type for handling invalid grab events in popup surfaces, specifically used during user interaction with UI elements like menus or tooltips. It provides conversions between the error type and 32-bit integers, enabling proper error signaling in Wayland protocol implementations. A concrete use case is detecting and handling incorrect pointer grabs that violate compositor rules.",
      "description_length": 406,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_feedback_v1.Tranche_flags",
      "library": "wayland.protocols",
      "description": "This module defines a set of flags used to indicate properties of DMA buffer tranches, specifically whether a tranche supports scanout. It operates on 32-bit integers, providing direct conversion functions between integer values and the flag type. These flags are used when handling feedback from DMA buffer allocation to determine compatibility with display scanout requirements.",
      "description_length": 380,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for invalid operations on XDG toplevel surfaces, such as incorrect resize edges, parent assignments, or size values. It provides conversions between these error codes and 32-bit integers, enabling proper handling and transmission over Wayland protocol connections. These errors are used to enforce constraints during window management in Wayland compositors.",
      "description_length": 390,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for validating Linux DMA-BUF buffer parameters in Wayland. It includes specific errors for invalid buffer configurations, such as incorrect plane indices, unsupported formats, and out-of-bounds dimensions. The module provides conversions between error values and 32-bit integers for use in protocol communication.",
      "description_length": 345,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Constraint_adjustment",
      "library": "wayland.protocols",
      "description": "This module defines bitflags for adjusting the position and size of surfaces in response to layout constraints, such as when a surface would otherwise be partially outside a valid display area. It provides constants like `slide_x`, `flip_y`, and `resize_x` to specify how a compositor should adjust a surface, with a defined precedence for applying these adjustments. These flags are used when positioning child surfaces to ensure they remain fully visible and properly aligned within the parent's layout.",
      "description_length": 505,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Capability",
      "library": "wayland.protocols",
      "description": "This module defines a bitmask type for representing DRM capabilities in the Wayland protocol. It includes operations to convert capability values to and from 32-bit integers. It is used to specify and handle features like PRIME buffer sharing in DRM-based display compositing.",
      "description_length": 276,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Error",
      "library": "wayland.protocols",
      "description": "This module defines an error type for the XDG positioner protocol, specifically handling invalid input scenarios. It provides conversions between the error type and 32-bit integers, enabling proper serialization and error signaling in Wayland protocol messages. This is used to communicate invalid positioning requests from clients to the compositor.",
      "description_length": 350,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for invalid operations on layer surfaces in the unstable layer shell protocol. It includes specific errors like `Invalid_surface_state`, `Invalid_size`, and others, corresponding to invalid configurations of layer surfaces. These errors are used to indicate failure reasons when applying layer surface settings, such as incorrect anchor values or unsupported sizes.",
      "description_length": 397,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Gravity",
      "library": "wayland.protocols",
      "description": "This module defines a set of cardinal and diagonal directions used to specify anchor points for positioning surfaces in a windowing system. It includes functions to convert these direction values to and from 32-bit integers, enabling efficient serialization and transmission. Concrete use cases include aligning pop-up windows relative to parent surfaces, such as positioning a context menu at the bottom-right of a clicked element.",
      "description_length": 432,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Keyboard_interactivity",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type `t` with three values\u2014`None`, `Exclusive`, and `On_demand`\u2014representing distinct keyboard interaction policies for layer shell surfaces in a Wayland compositor. It provides `to_int32` and `of_int32` functions for converting between the enumerated values and their integer representations, enabling serialization or protocol-level handling. These types are used to control how keyboard focus is assigned to layer surfaces, such as panels, lock screens, or widgets, affecting user interaction and focus behavior in desktop environments.",
      "description_length": 573,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1.Mode",
      "library": "wayland.protocols",
      "description": "This module defines two window decoration modes, `Client_side` and `Server_side`, representing how window decorations are handled in a Wayland compositor. It provides conversion functions `to_int32` and `of_int32` to map between these modes and 32-bit integers for protocol serialization. It is used to negotiate and set the decoration mode for top-level windows in the XDG decoration protocol.",
      "description_length": 394,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling invalid operations in layer shell protocol interactions, specifically for cases like incorrect roles, invalid layer values, and duplicate construction attempts. It provides conversions between error values and 32-bit integers for serialization or transmission purposes. These errors are used to enforce correct usage of layer shell surfaces in display compositors.",
      "description_length": 409,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Anchor",
      "library": "wayland.protocols",
      "description": "This module defines a set of positional anchor points used to specify the alignment of surfaces in a windowing system. It includes functions to convert between anchor values and 32-bit integers, enabling efficient serialization and communication with display servers. Concrete use cases include positioning pop-up windows, tooltips, and menus relative to other surfaces.",
      "description_length": 370,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_wm_base.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes used in the XDG WM base protocol for handling window management operations. It includes specific errors like invalid surface roles, defunct surfaces, and positioner issues, along with conversion functions to and from 32-bit integers. These errors are used to report failure conditions during client-server communication in desktop environment protocols.",
      "description_length": 385,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1.Flags",
      "library": "wayland.protocols",
      "description": "This module defines bit flags for screen copy operations, specifically supporting transformations like vertical inversion. It works directly with 32-bit integers to represent flag states. These flags are used to configure frame capture behavior, such as flipping content during screen recording or compositing.",
      "description_length": 310,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1.Lifetime",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type `t` with two values, `Oneshot` and `Persistent`, representing distinct lifetime behaviors for pointer constraints in the Wayland protocol. It provides conversion functions `to_int32` and `of_int32` to map between these lifetime values and their corresponding 32-bit integer representations. These values are used when creating pointer constraints to specify whether a constraint should be deactivated permanently or allowed to reactivate after release.",
      "description_length": 491,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Wm_capabilities",
      "library": "wayland.protocols",
      "description": "This module defines a set of window management capabilities as enumerated values, including actions like maximizing, fullscreening, minimizing, and opening window menus. It provides conversion functions to and from 32-bit integers, enabling efficient serialization and deserialization of capability flags. These capabilities are used to communicate supported window operations between a Wayland compositor and clients.",
      "description_length": 418,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Resize_edge",
      "library": "wayland.protocols",
      "description": "This module defines a variant type `t` representing edges of a surface used during resize operations in a Wayland compositor. It includes functions `to_int32` and `of_int32` to convert between edge values and their integer representations. Concrete use cases include handling user-initiated window resizing in graphical applications by identifying which edge or corner is being dragged.",
      "description_length": 386,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling screen copy operations, specifically indicating when a buffer is already used or invalid. It provides conversions between error values and 32-bit integers for communication with Wayland compositors. These errors are used during screen capture to signal invalid states when attempting to use buffers for frame copying.",
      "description_length": 362,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for the DRM protocol, including authentication failure, invalid pixel format, and invalid name errors. It provides conversions between these error codes and 32-bit integers. These values are used to report specific failure conditions during buffer authentication and configuration in display server implementations.",
      "description_length": 347,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error values for handling pointer constraint operations in Wayland protocols. It includes a single error variant `Already_constrained` and functions to convert between the error type and 32-bit integers. It is used to report errors when attempting to apply pointer constraints to an already constrained pointer.",
      "description_length": 331,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Anchor",
      "library": "wayland.protocols",
      "description": "This module defines constants and conversion functions for positioning layer surfaces in a Wayland compositor. It provides specific flags for anchoring surfaces to screen edges (top, bottom, left, right) as 32-bit integers. Use this module when configuring layer surfaces to control their alignment relative to the display boundaries.",
      "description_length": 334,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling invalid states in the management of top-level window decorations. It includes operations to convert between error values and 32-bit integers, enabling protocol-level communication. Concrete use cases include signaling errors when a buffer is unconfigured, a decoration is already constructed, or a decoration becomes orphaned.",
      "description_length": 371,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration_manager.Mode",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type with three values (`None`, `Client`, `Server`) representing decoration modes in a Wayland server. It provides functions to convert between these mode values and 32-bit integers. This is used to handle decoration mode requests and events in window management protocols.",
      "description_length": 307,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration.Mode",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type with values `None`, `Client`, and `Server`, representing decoration modes in a Wayland server. It provides `to_int32` and `of_int32` functions for converting between the enum and 32-bit integer representations. These conversions are used when handling protocol requests and events that specify how window decorations should be managed.",
      "description_length": 374,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.State",
      "library": "wayland.protocols",
      "description": "This module defines a set of state flags representing the visual and layout conditions of a surface, such as maximized, fullscreen, and tiled edges. It provides bidirectional conversion between these states and 32-bit integers, enabling serialization and deserialization for communication between client and compositor. These states are used to synchronize surface behavior during configuration changes, ensuring correct rendering and layout enforcement.",
      "description_length": 454,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Format",
      "library": "wayland.protocols",
      "description": "This module defines a variant type representing pixel formats used in DRM (Direct Rendering Manager) protocols, such as RGB, BGR, YUV, and formats with alpha channels. It provides functions to convert these format values to and from 32-bit integers, enabling efficient serialization and deserialization during communication with display drivers or compositor interfaces. These operations are essential when negotiating buffer formats between clients and the display server in a Wayland environment.",
      "description_length": 498,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module implements protocol operations for layer shell surfaces in a Wayland compositor, handling requests and events tied to surface configuration. It works with enumerated types for keyboard interaction policies, error codes, and positional anchors to define surface behavior and constraints. Concrete use cases include setting keyboard focus rules, validating surface dimensions, and anchoring panels or overlays to screen edges.",
      "description_length": 436,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module handles pointer constraint operations in the Wayland protocol, specifically defining how pointers can be restricted in movement or behavior. It works with Wayland protocol types such as `t`, `versions`, and submodules `Error` and `Lifetime` to manage constraint states and errors. Concrete use cases include enforcing pointer confinement or locking cursor movement within a specific region during graphical interface interactions.",
      "description_length": 442,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to destroy a primary selection offer and receive data transfers by specifying a MIME type and file descriptor. It works with the `Zwp_primary_selection_offer_v1.t` type representing a selection offer. Concrete use cases include handling user-initiated text selection transfers, such as pasting content from a clipboard manager or text editor.",
      "description_length": 374,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module manages pointer confinement within a Wayland compositor by allowing clients to set a specific region where the pointer is restricted. It provides operations to update the confinement region and destroy the confined pointer object, triggering events when confinement starts or ends. Concrete use cases include restricting pointer movement to a specific window or area during interactive operations like drag-and-drop or modal dialogs.",
      "description_length": 445,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for a primary selection source in version 1 of the unstable primary selection protocol. It provides operations to handle requests and events related to setting and offering selection data, working with types such as file descriptors and strings. Concrete use cases include implementing clipboard-like functionality where a client offers data for selection and responds to selection requests from other clients.",
      "description_length": 453,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module defines the interface and behavior for handling primary selection offers in a Wayland compositor. It provides functions to retrieve requests and events associated with selection data, supporting operations like reading data from a client. The module works with Wayland protocol types, specifically handling versioned messages for primary selection interactions.",
      "description_length": 373,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module implements the XDG WM base protocol for window management in Wayland compositors. It defines protocol constants, message layouts, and versioned request/event structures for operations like creating surfaces, positioning windows, and handling errors during desktop environment setup. Concrete use cases include negotiating protocol versions, dispatching window creation requests, and mapping error codes to client-side failures in surface management.",
      "description_length": 461,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module defines the interface and message handling for a primary selection device in the GTK Wayland protocol. It specifies the requests and events exchanged between client and server, including selection updates and device capability queries. It is used to implement clipboard-like functionality for primary selections in graphical applications.",
      "description_length": 350,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module handles the relative pointer events in the Wayland protocol, specifically capturing and relaying relative motion data. It works with Wayland's event system and input device interfaces. Concrete use cases include implementing cursor movement in graphical applications based on relative pointer input.",
      "description_length": 311,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module defines the `Zxdg_output_v1` protocol interface for handling output management in Wayland compositors. It provides operations to query output descriptions, positions, and modes through requests and events, specifically working with Wayland's metadata and versioned protocol structures. Concrete use cases include retrieving output geometry and handling output addition or removal events in desktop environments.",
      "description_length": 423,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol handling for managing relative pointer motion in Wayland compositing. It provides operations to create and handle relative pointer objects, specifically supporting version 1 of the protocol. Concrete use cases include capturing relative mouse movements for applications like games or virtual reality interfaces.",
      "description_length": 358,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for handling primary selection offers in a Wayland compositor. It provides access to the interface name, version, and metadata, along with functions to retrieve request and event details by index. The module works specifically with Wayland protocol types, including file descriptors and strings, and is used to implement clipboard-like functionality for text or data transfer between clients.",
      "description_length": 435,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module handles pointer lock state management by suppressing standard pointer motion events and providing `locked` and `unlocked` events to indicate activation or deactivation of the lock. It works with `Zwp_locked_pointer_v1.t` objects tied to a Wayland seat's pointer, ensuring focus and position constraints during lock. Concrete use cases include implementing precise pointer capture for games or VR applications where relative motion matters more than absolute position updates.",
      "description_length": 487,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in the X primary selection emulation. It provides operations to create and retrieve primary selection sources and per-seat devices using a singleton global manager. Concrete use cases include handling clipboard operations and inter-client communication for GUI applications in a Wayland environment.",
      "description_length": 357,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol for managing client-side window decorations in a Wayland compositor using the unstable XDG decoration protocol. It provides functions to handle requests and events related to creating and managing decoration objects, specifically for version 1 of the protocol. Concrete use cases include enabling clients to negotiate decoration modes and create decorated surfaces for windows.",
      "description_length": 424,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module implements the XDG positioner protocol for defining surface positioning constraints in a windowing system. It provides enumerations and bitflags for specifying anchors, gravity directions, and constraint adjustments, along with functions to serialize these values into 32-bit integers for protocol transmission. It is used to configure how pop-up surfaces, such as menus and tooltips, are positioned relative to parent surfaces while respecting display boundaries.",
      "description_length": 476,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module handles server-side decoration requests for Wayland surfaces, specifically supporting KDE KWin compositors. It provides `request_mode` to set a decoration mode and `release` to free the associated decoration object. Concrete use cases include managing window borders and visual styles in desktop environments like KDE Plasma.",
      "description_length": 337,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection and data offer operations in a Wayland server. It provides `selection` to advertise a new primary selection offer and `data_offer` to create and manage data offers for primary selection. These functions work with proxy objects representing Wayland clients and selection offers, enabling clipboard-like data transfer between clients.",
      "description_length": 370,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module implements the KDE KWin server-side window decoration protocol, handling requests and events for configuring decoration modes. It works with the `Mode` enumerated type to represent decoration states (`None`, `Client`, `Server`) and provides conversion functions for protocol communication. Concrete use cases include negotiating decoration capabilities during client connection and responding to decoration mode changes in a Wayland compositor.",
      "description_length": 456,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module creates layer surfaces for desktop compositing, allowing clients to assign `wl_surface` objects to specific layers with defined rendering order, anchoring, and input behavior. It operates on `wl_surface` and `wl_output` proxies, providing `get_layer_surface` to configure surfaces with a layer, namespace, and output. Use this to implement desktop shells, overlays, or UI components that require precise screen positioning and layering.",
      "description_length": 448,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module manages the transfer of primary selection clipboard contents by offering available MIME types and handling data transfer requests. It works with primary selection offers, allowing clients to request data in a specific format via a file descriptor. Concrete use cases include implementing clipboard pasting in graphical applications where data is received from a Wayland compositor.",
      "description_length": 393,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module manages pointer locking behavior by suppressing standard pointer motion events and providing a `locked` event when the lock activates. It works with Wayland pointer constraints, specifically handling lock regions and cursor position hints during locked states. Concrete use cases include implementing precise pointer capture for games or VR applications where relative motion matters more than absolute position.",
      "description_length": 424,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module provides functions to create dmabuf-based `wl_buffer` objects using versioned protocol interactions, supporting buffer parameter configuration and implicit synchronization via DMA-BUF fences. It works with Wayland proxies for `zwp_linux_dmabuf_v1`, `zwp_linux_buffer_params_v1`, and `zwp_linux_dmabuf_feedback_v1` to enable buffer creation and feedback retrieval. Concrete use cases include importing DMA-BUF file descriptors for GPU rendering, querying format support per surface, and handling buffer creation with explicit or immediate submission.",
      "description_length": 561,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module manages confined pointer interactions in a Wayland compositor. It provides `confined` and `unconfined` functions to signal when a pointer is restricted to or released from a specific surface region. The functions operate on `Zwp_confined_pointer_v1.t` objects, which represent the confined pointer state. Concrete use cases include implementing pointer confinement for drag-and-drop operations or restricting pointer movement within a window boundary.",
      "description_length": 463,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module provides the `offer` function to advertise MIME types for primary selection data transfer. It works with `Zwp_primary_selection_offer_v1.t` objects, representing offers to transfer primary selection contents. Concrete use cases include enabling clients to receive clipboard data in specific formats, such as text or images, during drag-and-drop or clipboard operations.",
      "description_length": 381,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module implements the core window management protocol for desktop surfaces, handling operations like window creation, resizing, and positioning. It works with `wl_surface` objects, extending them with desktop window behaviors through the `xdg_wm_base` interface. Concrete use cases include managing top-level windows, handling client pings for liveness checks, and supporting transient windows like popups or menus in a compositor.",
      "description_length": 436,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_client.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module handles direct rendering management in a Wayland client, providing functions to create and manage DRM buffers for display. It supports buffer creation with specific pixel formats, dimensions, and memory layouts, including planar and PRIME buffer types. Concrete use cases include integrating GPU-rendered content with the Wayland compositor by importing DRM buffer handles and authenticating access to DRM resources.",
      "description_length": 428,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, allowing the server to send data in a specified MIME type over a file descriptor and handle cancellation requests. It works with `Gtk_primary_selection_source.t` to define how data is transferred when a client requests the primary selection contents. Concrete use cases include implementing custom clipboard data sources and responding to client requests for text or other data types during drag-and-drop operations.",
      "description_length": 482,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module provides functions to constrain pointer movement in a Wayland client. It allows locking the pointer to a specific position with `lock_pointer` or confining it to a region with `confine_pointer`, both requiring a surface, pointer, optional region, and lifetime specification. These operations are used in applications like games or screen lockers where precise pointer control is required.",
      "description_length": 400,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module handles feedback from DMA buffer allocation in the Linux DMABUF protocol, specifically managing flags and metadata for buffer tranches. It works with 32-bit integers and custom flag types to represent tranche properties like scanout support. Concrete use cases include interpreting and responding to DMA buffer feedback events in display compositors.",
      "description_length": 362,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module provides a `create` function to instantiate server-side decoration objects for Wayland surfaces, specifically for clients requesting server-side window decorations. It works with Wayland proxy handlers and surface objects, targeting the `org_kde_kwin_server_decoration` protocol interface. Concrete use cases include managing window borders and title bars rendered by the compositor for client windows that opt into server-side decorations.",
      "description_length": 452,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module manages desktop-style user interface surfaces in a Wayland client, enabling the creation and configuration of top-level windows and popups. It operates on `wl_surface` objects, assigning them roles like `xdg_toplevel` or `xdg_popup`, and handles events such as configuration acknowledgments and window geometry updates. Concrete use cases include setting up and displaying application windows or context menus in a desktop environment.",
      "description_length": 447,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation of dmabuf-based Wayland buffers by collecting dmabuf file descriptors and associated parameters. It supports both single and multi-planar pixel formats, requiring one `add` call per plane with unique indices. Use cases include importing GPU memory buffers for rendering or display in Wayland clients using the Linux DMA-BUF protocol.",
      "description_length": 366,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, allowing the addition of MIME types to describe offered data and handling requests to transfer the selection contents. It works with the `Gtk_primary_selection_source.t` type to define and destroy data sources for clipboard operations. Concrete use cases include implementing custom clipboard data sources and responding to client requests for specific MIME type transfers.",
      "description_length": 439,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module implements the unstable XDG decoration protocol for top-level windows, providing operations to negotiate decoration modes and handle errors during window configuration. It works with Wayland's protocol types, including 32-bit integers for mode and error serialization, and integrates with Wayland's event and request handling. Concrete use cases include setting client or server-side decoration modes, reporting invalid decoration states, and managing unconfigured or orphaned window decorations.",
      "description_length": 508,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and version metadata for the Linux DMABUF protocol, specifying operations to create buffer objects and handle format events. It works with Wayland's protocol types, including versioned requests and events tied to DMABUF buffer management. Concrete use cases include importing DMA buffers for GPU rendering and handling buffer format negotiations in display compositors.",
      "description_length": 403,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides a way to manage and initiate screen capture operations by offering requests to start capturing from a source. It works with Wayland client connections and screen capture sources, enabling concrete use cases like capturing the contents of a display output or a specific window. The module handles version 1 of the protocol, ensuring compatibility with servers requiring this functionality.",
      "description_length": 409,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module implements the layer shell protocol for Wayland, handling requests to create and manage layered surfaces with specific roles and stacking orders. It works with surface objects and layer enums to control visual stacking in display compositors. Concrete operations include creating layer surfaces, setting their dimensions, and specifying their positioning relative to other surfaces.",
      "description_length": 394,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `configure` function to notify clients of changes to window decoration modes, specifically enabling or disabling server-side decorations. It works with the `Zxdg_toplevel_decoration_v1` type, which represents a decoration object tied to a toplevel surface. A concrete use case is allowing a Wayland compositor to dynamically switch between client-side and server-side window decorations based on user or system settings.",
      "description_length": 443,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection in a Wayland client, providing operations to set and clear the selection with a given source and serial. It works with Wayland proxies, specifically for primary selection sources and devices. Concrete use cases include handling user-initiated selections, such as text or file selections, and synchronizing them across different clients.",
      "description_length": 374,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module manages short-lived popup surfaces for UI elements like menus and tooltips. It provides operations to explicitly grab input focus, reposition the popup using a positioner, and destroy the popup to dismiss it. The module works with `xdg_popup` objects and associated Wayland surfaces and seats.",
      "description_length": 305,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the screencopy manager protocol for capturing screen content in Wayland compositors. It provides versioned requests and events for initiating and handling screen capture operations, working with types like `t`, `versions`, and metadata. Concrete use cases include implementing screen recording, screenshot tools, or remote desktop features that require direct access to framebuffers.",
      "description_length": 403,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in the Wayland protocol. It provides functions to create and retrieve primary selection devices per seat and to create primary selection sources. These operations are used for handling clipboard-like data sharing between applications in a Wayland compositor environment.",
      "description_length": 328,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module manages short-lived popup surfaces for user interface elements like menus and tooltips. It provides functions to configure popup geometry, handle dismissal via `popup_done`, and signal repositioning completion. The module works with `xdg_popup` objects tied to Wayland surfaces, requiring explicit destruction or client interaction to unmap surfaces.",
      "description_length": 362,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module handles server-side decoration modes for Wayland clients, specifically supporting the `v1` protocol version. It provides a `mode` function to set the decoration mode on a server decoration object, which influences how window borders and title bars are rendered. Concrete use cases include enabling or disabling server-side decorations for KDE Plasma windows in a Wayland compositor.",
      "description_length": 394,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to manage server-side window decorations in a Wayland compositor. It allows clients to request decorations by creating a toplevel decoration object for a given surface, and to release resources by destroying the decoration manager. The module works with Wayland proxy objects representing decoration managers and toplevel surfaces, specifically targeting use cases where a compositor controls window decorations instead of the client.",
      "description_length": 466,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module manages the advertisement of MIME types for primary selection data transfer offers. It provides the `offer` function to specify which MIME types are available for transfer. Use this module when implementing a Wayland server that needs to communicate supported data formats during clipboard operations.",
      "description_length": 313,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation of relative pointer objects for a given pointer, allowing clients to receive relative motion events. It operates on pointer devices and works with Wayland surfaces to track and report movement deltas. Concrete use cases include implementing precise cursor control in applications like games or graphic design tools where relative motion is critical.",
      "description_length": 382,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in a Wayland compositor. It provides functions to create selection sources and retrieve per-seat selection devices, enabling clipboard-like data sharing between clients. Concrete use cases include handling text selection and paste operations across applications.",
      "description_length": 320,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for managing primary selection devices in Wayland. It specifies the requests and events for creating and handling selection device objects, targeting version 1 of the protocol. Concrete use cases include implementing clipboard-like functionality for text or data selection across Wayland clients.",
      "description_length": 339,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module defines positioning rules for child surfaces relative to parent surfaces, including constraints, gravity, and anchor points. It operates on `xdg_positioner` objects, configuring properties like size, offset, and adjustment behavior to ensure proper placement within visible areas. Concrete use cases include positioning pop-up menus, tooltips, or dialog boxes so they remain visible and properly aligned with their parent surfaces.",
      "description_length": 443,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol handling for managing primary selection devices in a Wayland compositor. It provides functions to create and manage device instances, handle selection requests, and process events related to clipboard operations. The module works specifically with Wayland protocol types, including device managers and selection devices, targeting version 1 of the protocol. It is used to implement clipboard support in graphical applications using the GTK toolkit over Wayland.",
      "description_length": 508,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to constrain pointer movement by locking or confining it to a specific region. It works with Wayland surfaces and pointer objects associated with a seat, enforcing constraints through the `lock_pointer` and `confine_pointer` requests. Concrete use cases include restricting pointer movement to a window during drag operations or locking the pointer during interactive resizing.",
      "description_length": 409,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module handles screen capture operations by defining protocols for frame copying, including error codes and bit flags to manage buffer states and transformation options. It works with Wayland protocol types such as `t`, `versions`, and metadata types to control screen capture behavior like flipping and buffer validation. Concrete use cases include managing screen recording sessions and handling invalid buffer usage during frame capture in compositors.",
      "description_length": 460,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module handles Linux DMA-BUF buffer parameter validation and configuration in Wayland. It defines error codes and flags for specifying buffer properties such as format, orientation, and dimension constraints. Concrete use cases include validating buffer imports, signaling format mismatches, and setting display flags like y-inversion during buffer creation.",
      "description_length": 363,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module handles the creation and management of `xdg_output` objects, which represent outputs (such as monitors) in a Wayland compositor. It provides functions to bind and instantiate `xdg_output` resources, allowing servers to advertise available outputs and their properties to clients. Concrete use cases include setting up display configurations and notifying clients about output geometry and scaling.",
      "description_length": 409,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module manages top-level surfaces in a Wayland compositor, handling operations like resizing, moving, and setting window properties such as title and state. It works with `xdg_toplevel` objects across multiple protocol versions, supporting features like close requests, size configuration, and capability negotiation. Concrete use cases include implementing window management in desktop environments, handling user interactions like dragging and resizing windows, and synchronizing surface state with the compositor.",
      "description_length": 521,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol behavior for confined pointer interactions in Wayland compositors. It provides operations to handle pointer confinement requests and events, specifically working with Wayland protocol message structures and versioned interfaces. Concrete use cases include implementing pointer lock functionality in applications like games or virtual desktops where cursor movement needs to be restricted.",
      "description_length": 435,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module manages desktop-style window creation and interaction. It provides functions to create and manage shell surfaces from Wayland surfaces, handle window positioning, and respond to compositor pings. Concrete use cases include building draggable, resizable, and maximizable windows, as well as handling popup menus and transient windows in a desktop environment.",
      "description_length": 370,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for a locked pointer in the Wayland display server protocol. It provides operations to request pointer locking and handle associated events, working with Wayland's protocol metadata and versioning structures. Concrete use cases include implementing pointer confinement in graphical applications, such as games or screen-sharing tools, where precise input control is required.",
      "description_length": 418,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations for constructing dmabuf-based Wayland buffers by collecting per-plane parameters. It works with dmabuf file descriptors, DRM format codes, and plane indices to describe buffer layouts. Concrete use cases include importing Vulkan or GPU memory buffers for display, handling multi-planar video formats like NV12, and ensuring correct buffer creation before finalizing with `create`.",
      "description_length": 411,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources for X-based clipboard emulation. It provides functions to create primary selection sources and retrieve per-seat device objects. It is used to handle clipboard operations like cut, copy, and paste in Wayland compositors that emulate X selection behavior.",
      "description_length": 312,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to manage layered surfaces on a Wayland desktop, enabling clients to assign surfaces to specific layers, anchor them to screen edges or corners, and define input handling behavior. It works with Wayland surfaces (`wl_surface`) and layer-related enums, such as layer identifiers and anchor points. Concrete use cases include implementing desktop shells, panels, docks, and popups that require precise control over rendering order and screen positioning.",
      "description_length": 484,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module manages screen capture frames by allowing clients to copy frame contents into buffers, supporting both full and damage-based updates. It works with `Zwlr_screencopy_frame_v1` objects and `Wl_buffer` proxies, handling buffer enumeration, copy requests, and failure notifications. Concrete use cases include capturing screen content for remote display, recording, or real-time rendering updates.",
      "description_length": 405,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module manages server-side window decorations for Wayland surfaces, coordinating whether the server should create decorations around shell surfaces. It provides a handler for setting the default decoration mode, allowing the server to specify how surfaces should be decorated. Concrete use cases include enabling or disabling server-side borders and title bars for client windows.",
      "description_length": 385,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module implements protocol operations for managing top-level surfaces in a Wayland compositor, handling requests like configuration, resizing, and state changes. It works with surface state flags, resize edges, and window capabilities, converting them to and from integer representations for protocol transmission. Concrete use cases include synchronizing window states during resizing, enforcing valid surface operations, and communicating supported window management features between client and compositor.",
      "description_length": 513,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module manages the lifecycle and configuration of desktop-style user interface surfaces in a Wayland compositor. It handles assigning roles like toplevel windows or popups to surfaces, enforcing correct state transitions, and coordinating initial surface mapping through commit and configure events. Key operations include setting up role-specific objects, handling configuration acknowledgments, and ensuring proper buffer attachment timing.",
      "description_length": 447,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_server.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module handles Wayland DRM protocol events for version 1 and 2, providing direct operations to set capabilities, authentication status, pixel formats, and device names. It works with Wayland DRM objects and string/int32 parameters, specifically targeting display server implementations needing direct rendering manager integration. Concrete use cases include authenticating DRM clients, advertising supported formats, and binding device nodes for GPU access.",
      "description_length": 463,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages screen capture operations by providing functions to initiate output and region-based screen captures. It works with Wayland proxy objects representing outputs and screencopy frames, allowing clients to specify regions and overlay cursor settings. Concrete use cases include capturing specific display areas for screen recording or remote desktop applications.",
      "description_length": 379,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module defines the interface and communication protocol for a primary selection source in a Wayland compositor. It specifies the requests and events for handling clipboard operations, including sending and receiving data via file descriptors and strings. Concrete use cases include implementing copy-paste functionality between applications in a desktop environment.",
      "description_length": 371,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides a protocol for negotiating server-side window decorations between a compositor and a client. It defines a decoration manager interface that allows clients to request decorations and enables the compositor to manage decoration states, such as active or inactive. The interface works with Wayland surfaces and decoration objects, specifically handling events like mode requests and state changes to control how windows are visually decorated.",
      "description_length": 461,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation and destruction of primary selection sources, allowing the addition of MIME types to represent offered data formats. It works with primary selection source objects to enable clients to advertise supported data types for clipboard operations. Concrete use cases include implementing custom clipboard content sources in graphical applications, such as text editors or image viewers, where specific data formats need to be exposed for selection and transfer.",
      "description_length": 488,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module manages layer surface state for Wayland compositors, handling operations like surface configuration and closure. It works with `Zwlr_layer_surface_v1` objects, tracking properties such as size, anchor, and visibility. Concrete use cases include rendering UI layers (e.g., panels, popups) that require stacking and visibility control based on compositor rules.",
      "description_length": 371,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module defines rules for positioning child surfaces relative to parent surfaces, ensuring visibility and adjacency constraints. It supports operations like setting size, anchor rectangles, and positioning rules such as sliding or flipping. Concrete use cases include aligning pop-up windows, tooltips, or menus within a Wayland compositor's visible area while maintaining parent-child surface relationships.",
      "description_length": 412,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `relative_motion` function to emit relative pointer events with precise motion deltas and timestamps. It works with Wayland's `wl_pointer` interface and seat focus management to deliver unaccelerated and accelerated pointer movement data. Concrete use cases include implementing custom input handling for games or drawing applications requiring fine-grained relative motion tracking.",
      "description_length": 406,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and communication logic for a primary selection device in the Wayland protocol. It provides functions to encode and decode requests and events, such as offering a selection source or handling selection data. It works directly with Wayland protocol messages and object identifiers, used in implementing clipboard-like functionality in Wayland compositors.",
      "description_length": 388,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module creates and manages xdg_output objects from wl_output proxies, providing versioned access to output configuration interfaces. It supports creating outputs with version-specific handlers and destroying the manager when no longer needed. Concrete use cases include setting up per-output configuration in desktop environments or display managers using Wayland's unstable xdg_output protocol.",
      "description_length": 400,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module manages the primary selection device in a Wayland client, providing operations to destroy the device and set the primary selection with a given source and serial. It works with Wayland protocol objects, specifically proxies for primary selection sources and device handles. Concrete use cases include handling clipboard-like selections in graphical applications, such as text or image data selected by the user for copy-paste operations.",
      "description_length": 449,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module handles server-side decoration management for Wayland compositors, specifically supporting protocol requests and events related to window decoration modes. It works with enumeration types for decoration modes (`None`, `Client`, `Server`) and maps them to integers for protocol serialization. Concrete use cases include negotiating decoration modes between the compositor and clients, and handling decoration state changes during window management.",
      "description_length": 459,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation and destruction of relative pointer objects for a given Wayland pointer. It provides `get_relative_pointer` to obtain a relative pointer interface for a specific pointer and `destroy` to release the manager. Use this when implementing client-side pointer input handling that requires relative motion tracking.",
      "description_length": 342,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module handles DMA buffer feedback parameters, including events for preferred devices, supported formats, and modifiers. It works with Wayland protocol objects to communicate buffer allocation preferences and changes. Concrete use cases include optimizing buffer allocation by clients based on compositor feedback and handling device-specific format support for rendering.",
      "description_length": 377,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module represents a logical output region in a Wayland compositor, typically corresponding to a display monitor. It provides a `destroy` function to tear down the output object and supports handling output property updates, which are signaled atomically via `wl_output.done` events starting from version 3. It is used to manage and track the compositor's output geometry for display configuration and rendering purposes.",
      "description_length": 425,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module manages layer surfaces in a Wayland compositor, providing functions to configure their visual properties and interaction behavior. It supports operations like setting the layer level, size, anchor point, margins, and exclusive zones, as well as handling keyboard interactivity and popup assignments. Concrete use cases include implementing UI overlays, docks, and system panels that need precise placement and visibility control relative to the desktop environment.",
      "description_length": 477,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module manages window decoration modes for a toplevel surface in a Wayland compositor. It provides functions to set, unset, and destroy the decoration mode, working with a decoration object tied to a specific version. Concrete use cases include enabling or disabling server-side decorations dynamically during window management.",
      "description_length": 333,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module manages top-level surfaces in a Wayland compositor, providing functions to control window states such as maximize, minimize, and fullscreen, along with interactive operations like resize and move. It works with `xdg_toplevel` objects and related Wayland proxies for seats and outputs, allowing clients to define window geometry, set application metadata, and manage surface relationships. Concrete use cases include implementing window management in desktop environments, handling user interactions for resizing or moving windows, and setting application-specific identifiers for proper window handling.",
      "description_length": 615,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module handles the creation of dmabuf-based `wl_buffer` objects using the `create_params`, `add`, and `create`/`create_immed` requests, supporting format and modifier negotiation for buffer planes. It works with `zwp_linux_dmabuf_params_v1` objects and dmabuf file descriptors, requiring clients to specify buffer formats and optional modifiers for multi-plane buffers. Concrete use cases include importing DMA-BUFs for GPU rendering, handling implicit synchronization via reservation fences, and providing surface-specific or default dmabuf feedback for clients.",
      "description_length": 568,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations for managing logical output regions in a Wayland compositor, including setting size, position, and metadata such as name and description. It works with `Zxdg_output_v1.t` objects to represent outputs, handling versions 1 through 3. Concrete use cases include configuring monitor layouts and notifying clients when output properties are fully updated using the `done_` event.",
      "description_length": 405,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module implements the DRM protocol for Wayland, handling buffer authentication, pixel format negotiation, and capability exchange between clients and display servers. It defines operations for converting error codes, pixel formats, and capabilities to and from 32-bit integers, used in direct communication with DRM drivers. Concrete use cases include validating client-provided buffer names, selecting supported pixel formats, and managing PRIME buffer sharing during display composition.",
      "description_length": 494,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol details for managing output devices in a Wayland compositor using the unstable XDG output protocol version 1. It provides operations to create and handle output objects, supporting protocol versions 1 through 3. Concrete use cases include configuring monitor layouts and handling display changes in desktop environments.",
      "description_length": 367,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module defines the interface and versioning for XDG popup surfaces in the Wayland protocol, including functions to encode and decode protocol requests and events. It works with tagged types representing protocol messages and supports error handling for invalid popup interactions. Concrete use cases include managing popup surface creation and handling user input events like pointer grabs in desktop environments.",
      "description_length": 419,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations to handle screen capture frames, including signaling capture failure, readiness with timestamp, frame flags, and buffer details for `wl_shm` and `linux-dmabuf`. It works with frame objects and supports event signaling for screen copy operations. Concrete use cases include notifying clients when a screen capture is ready, reporting buffer capabilities, and indicating capture failure.",
      "description_length": 416,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, allowing servers to send data via a file descriptor and handle cancellation requests. It works with MIME types and Unix file descriptors to transfer content, such as text or images, during clipboard operations. Concrete use cases include implementing copy-paste functionality where a client offers data to be selected and responds when the selection is canceled or successfully transferred.",
      "description_length": 456,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module implements the XDG surface protocol for Wayland, handling surface creation, configuration, and state management across multiple versions. It defines requests like `get_toplevel`, `set_window_geometry`, and `ack_configure`, and emits events such as `configure` and `close`, working with surface objects and versioned protocol messages. It is used to manage desktop window surfaces in Wayland compositors and clients, ensuring correct interaction with the compositor's lifecycle and rendering pipeline.",
      "description_length": 512,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module sends dmabuf feedback parameters to clients, including preferred devices and supported buffer formats with modifiers. It uses events like `main_device`, `tranche_target_device`, `tranche_formats`, and `done_` to communicate changes in buffer allocation preferences, grouped into ordered tranches. Concrete use cases include informing clients when to reallocate buffers for optimal performance based on device capabilities and compositor needs.",
      "description_length": 455,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `destroy` function to release a relative pointer object that extends `wl_pointer` with focus-aware relative motion events. It works with pointer events tied to a seat, ensuring input is only processed when the pointer has focus. Concrete use cases include handling precise relative mouse movements in compositors or input-sensitive UI components.",
      "description_length": 369,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module manages primary selection and data offer operations in a Wayland server. It provides `selection` to advertise a new primary selection and `data_offer` to create and manage a new primary selection offer. These functions work with Wayland proxy types representing primary selection devices and offers, specifically handling version 1 protocols. Concrete use cases include implementing clipboard-like functionality where a client offers data for primary selection and the server manages the selection state.",
      "description_length": 516,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables clients to create and manage layer surfaces for desktop compositing in Wayland, defining their rendering order, positioning, and input handling. It operates on `wl_surface` and `wl_output` proxies, offering functions to assign surfaces to specific layers, set anchors and margins, and control visibility and keyboard interaction. Use it to build UI components like docks, system panels, and overlays that require precise screen placement and layering behavior.",
      "description_length": 480,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client",
      "library": "wayland.protocols",
      "description": "This module implements desktop shell protocols for Wayland clients, handling window creation, positioning, and interaction. It works with Wayland surfaces and shell objects to support features like draggable and resizable windows, popups, and window state management. Concrete use cases include building desktop applications with fully functional windows, context menus, and transient UI elements that integrate with a Wayland compositor.",
      "description_length": 438,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto",
      "library": "wayland.protocols",
      "description": "This module implements server-side window decoration protocols for Wayland compositors, handling negotiation and state management of decoration modes (`None`, `Client`, `Server`). It provides functions to process protocol requests, manage decoration mode transitions, and serialize mode states for communication. Concrete use cases include setting up decoration preferences during client initialization and updating window decoration behavior in response to compositor events.",
      "description_length": 476,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the unstable XDG decoration protocol for Wayland, providing precise operations to manage client-side window decorations. It includes functions for negotiating decoration modes and handling configuration errors for top-level windows, using Wayland protocol types such as 32-bit integers for mode and error codes. Concrete use cases involve setting decoration states, creating decorated surfaces, and managing invalid or unconfigured window states.",
      "description_length": 469,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables the creation and management of dmabuf-based Wayland buffers with explicit format and modifier support. It handles buffer parameter construction, format negotiation, and feedback for optimal buffer allocation. Concrete use cases include GPU rendering with Vulkan or OpenGL, video display with multi-planar formats, and implicit synchronization via DMA-BUF fences.",
      "description_length": 382,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables precise control over layered surfaces in a Wayland compositor, allowing clients to assign surfaces to specific layers, anchor them to screen edges or corners, and manage input handling behavior. It operates on `wl_surface` objects and uses enums for layer identifiers and anchor points. Use cases include implementing panels, docks, and popups that require strict control over screen positioning and rendering order.",
      "description_length": 436,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland screencopy protocol for capturing screen content in compositors. It includes the screencopy manager and frame protocols, which handle buffer allocation, frame capture, and transformation options such as flipping. Use cases include screen recording, screenshot capture, and remote desktop implementations requiring direct framebuffer access.",
      "description_length": 375,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server",
      "library": "wayland.protocols",
      "description": "This module implements the XDG Shell protocol for Wayland, providing interfaces to manage desktop surfaces with specific roles. It includes components for window management, surface positioning, and lifecycle handling, working with Wayland surfaces and their associated state. Concrete use cases include building windowed user interfaces, positioning popups and menus, and managing top-level window interactions in a Wayland compositor.",
      "description_length": 436,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the unstable XDG output protocol version 1 for Wayland compositors, providing precise control over output devices. It includes functions to manage output creation, query output properties like position and modes, and handle dynamic display changes. Concrete use cases include configuring multi-monitor setups and responding to hotplug events in desktop environments.",
      "description_length": 389,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables Wayland clients to create and manage DMA-BUF-backed buffers through three submodules. `Zwp_linux_dmabuf_v1` handles buffer creation and synchronization, `Zwp_linux_buffer_params_v1` collects buffer parameters and file descriptors, and `Zwp_linux_dmabuf_feedback_v1` communicates allocation preferences and format support. Use cases include importing GPU-rendered buffers for display, querying format compatibility per surface, and optimizing buffer allocation based on compositor feedback.",
      "description_length": 509,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto",
      "library": "wayland.protocols",
      "description": "This module implements the GTK primary selection protocol for Wayland, providing precise operations for clipboard-like data exchange between applications. It defines interfaces for device management, selection offers, and data transfer, working directly with Wayland protocol types to handle versioned messages and events. Concrete use cases include enabling copy-paste functionality in GTK-based desktop applications over a Wayland display server.",
      "description_length": 448,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables precise pointer control in Wayland clients through three submodules. `Zwp_pointer_constraints_v1` allows locking or confining the pointer to a surface or region, `Zwp_locked_pointer_v1` suppresses normal pointer motion for exclusive capture, and `Zwp_confined_pointer_v1` restricts pointer movement to a defined area. It is used in applications such as games, VR, and screen lockers where accurate pointer handling is critical.",
      "description_length": 447,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module provides screen capture functionality through two submodules. `Zwlr_screencopy_manager_v1` initiates screen capture operations on outputs or regions, while `Zwlr_screencopy_frame_v1` handles copying frame data into buffers for transmission or rendering. It works directly with Wayland proxy objects for outputs, frames, and buffers, enabling use cases such as screen recording, remote desktop streaming, and real-time display capture with support for partial updates and cursor overlays.",
      "description_length": 499,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module handles relative pointer input in Wayland compositing, providing interfaces to manage and receive relative motion events. It works with Wayland's input device interfaces and event system to capture precise pointer movement data. Concrete use cases include implementing mouse-based controls in games or VR applications where relative motion is critical.",
      "description_length": 364,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto",
      "library": "wayland.protocols",
      "description": "This module implements the DRM protocol for Wayland, providing functions to handle buffer authentication, pixel format negotiation, and capability exchange between clients and display servers. It works with 32-bit integers to represent error codes, pixel formats, and capabilities, converting these values to and from string representations for communication with DRM drivers. Use cases include validating buffer names, selecting supported pixel formats, and managing PRIME buffer sharing during display composition.",
      "description_length": 516,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto",
      "library": "wayland.protocols",
      "description": "This module implements the XDG Shell protocol for Wayland, providing precise handling of window management operations across multiple protocol versions. It includes components for surface creation, positioning constraints, popup management, and top-level window state synchronization, working with protocol message structures, bitflags, and versioned enumerations. Concrete use cases include negotiating window configuration during desktop environment setup, enforcing layout constraints for pop-up surfaces, and managing surface lifecycle events in Wayland compositors.",
      "description_length": 570,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the Linux DMABUF protocol for Wayland, providing operations to create and manage DMA buffer objects, validate buffer parameters, and handle feedback events for buffer allocation. It works with Wayland protocol types, including versioned requests, buffer parameters, and feedback metadata with custom flags and 32-bit integers. Concrete use cases include importing DMA buffers for GPU rendering, negotiating buffer formats, and handling display flags and tranche metadata in compositors.",
      "description_length": 509,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_server",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland DRM protocol server-side logic, handling events for versions 1 and 2. It provides direct operations to set device capabilities, authentication status, pixel formats, and device names, working with DRM objects and basic types like strings and int32s. Use cases include authenticating clients, advertising rendering capabilities, and binding DRM device nodes for GPU resource access in display servers.",
      "description_length": 435,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client",
      "library": "wayland.protocols",
      "description": "This module implements server-side window decoration management for Wayland clients, specifically supporting KDE KWin compositors. It includes a manager module for creating decoration objects and a decoration module for setting visual modes and releasing resources. Concrete use cases involve rendering window borders and title bars in KDE Plasma desktop environments.",
      "description_length": 368,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland primary selection protocol for handling clipboard-like data selection and transfer between clients. It provides precise operations for creating and managing selection device managers, sources, and offers, enabling clients to negotiate data transfer through file descriptors and mime types. Specific use cases include implementing copy-paste functionality in Wayland compositors and handling inter-client text or data selection.",
      "description_length": 462,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module handles relative pointer motion events in Wayland clients, providing interfaces to create and manage focus-aware relative pointers. It works with Wayland pointer objects tied to a seat, enabling precise input tracking only when the pointer has focus. Use it to implement features like smooth mouse scrolling or input-sensitive UI interactions in compositors.",
      "description_length": 370,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module handles window decoration management in a Wayland compositor. It allows clients to request server-side decorations for surfaces and set decoration modes dynamically. The module works with Wayland proxy objects for decoration managers and toplevel surfaces, specifically enabling compositors to control window borders and visual styles instead of client applications.",
      "description_length": 378,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module implements client-side handling of primary selection in Wayland, enabling clipboard-like data sharing between applications. It includes functions to manage selection devices, create and advertise data sources with MIME types, and handle data transfer offers via file descriptors. Specific use cases include text selection in editors, inter-client data exchange, and clipboard managers synchronizing content across seats.",
      "description_length": 432,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module manages the creation and configuration of logical outputs in a Wayland compositor, handling output properties such as size, position, and metadata. It works with `zxdg_output_v1` resources to represent and update display outputs, supporting versions 1 through 3. Concrete use cases include setting up multi-monitor layouts, advertising output scaling factors, and signaling clients when output configurations are finalized.",
      "description_length": 435,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client",
      "library": "wayland.protocols",
      "description": "This module provides operations for managing primary selection devices, sources, and data transfer in a Wayland client. It works with Wayland protocol objects such as device proxies and selection sources to enable clipboard-like functionality, including setting and retrieving selected content. Concrete use cases include handling text or image copy-paste operations between GUI applications in a Wayland compositor environment.",
      "description_length": 428,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the layer shell protocol for Wayland, providing operations to create and manage layered surfaces with specific roles and stacking orders. It works with surface objects and layer enums to control visual stacking, including setting dimensions and positioning relative to other surfaces. Concrete use cases include anchoring panels or overlays to screen edges and defining keyboard focus rules for layer surfaces.",
      "description_length": 433,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables screen capture management and frame handling for Wayland servers. It allows initiating screen captures via `Zwlr_screencopy_manager_v1` and managing capture results, timestamps, and buffer details through `Zwlr_screencopy_frame_v1`. Use cases include capturing display outputs, handling DMA-BUF or SHM buffers, and signaling frame readiness or failure to clients.",
      "description_length": 383,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables precise control over pointer behavior in Wayland compositors by offering operations to lock or confine pointer movement. It works with Wayland surfaces, seats, and dedicated pointer constraint objects (`Zwp_locked_pointer_v1.t`, `Zwp_confined_pointer_v1.t`) to enforce restrictions. Use cases include restricting pointer movement during window resizing, drag-and-drop interactions, and capturing relative pointer motion for immersive applications like games or VR.",
      "description_length": 484,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements pointer constraint protocols in Wayland, providing interfaces to lock or confine pointer movement. It works with Wayland protocol types including versioned interfaces, error codes, and event structures to manage pointer behavior. Concrete use cases include restricting cursor movement in fullscreen applications, games, or remote desktop clients where precise pointer control is required.",
      "description_length": 411,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server",
      "library": "wayland.protocols",
      "description": "This module implements server-side window decoration management for Wayland clients, handling the `v1` protocol version. It includes functionality to set and manage decoration modes, directly controlling the appearance of window borders and title bars for surfaces. Concrete use cases involve configuring decoration policies for KDE Plasma windows within a Wayland compositor.",
      "description_length": 376,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_client",
      "library": "wayland.protocols",
      "description": "This module handles direct rendering management in a Wayland client, providing functions to create and manage DRM buffers for display. It supports buffer creation with specific pixel formats, dimensions, and memory layouts, including planar and PRIME buffer types. Concrete use cases include integrating GPU-rendered content with the Wayland compositor by importing DRM buffer handles and authenticating access to DRM resources.",
      "description_length": 428,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module implements primary selection and clipboard-like data sharing in a Wayland compositor. It includes device managers for creating selection sources and per-seat devices, selection devices for managing data offers and selection state, and offer and source modules for MIME type negotiation and data transfer over file descriptors. Concrete use cases include handling text selection across terminals, drag-and-drop between applications, and clipboard operations with rich content like images.",
      "description_length": 499,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module implements the unstable XDG decoration protocol for Wayland, enabling negotiation of server-side window decorations between a compositor and clients. It defines two interfaces: one for managing decoration requests and states across surfaces, and another for configuring individual toplevel decorations, supporting dynamic switching between client and server-side decoration modes. Concrete use cases include allowing a compositor to control visual decoration policies and notify clients of active decoration states.",
      "description_length": 527,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables precise relative pointer motion tracking by creating and managing pointer objects that report unaccelerated movement deltas. It works with Wayland pointers and surfaces to deliver motion events with timestamps, specifically for applications like games or graphic design tools that require accurate input handling. The `relative_motion` function provides the core functionality for capturing and emitting these motion events.",
      "description_length": 444,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server",
      "library": "wayland.protocols",
      "description": "This module implements primary selection handling for Wayland servers, providing direct support for clipboard emulation through X selection behavior. It includes functions to manage selection devices, create and advertise data offers with MIME types, and handle data transfer from sources over file descriptors. Specific use cases include enabling cut, copy, and paste operations in Wayland compositors and managing drag-and-drop data transfer with client applications.",
      "description_length": 469,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module implements the client-side interface for the Wayland unstable xdg_output protocol, enabling management of logical display outputs. It provides functions to create and destroy xdg_output objects, handle output property updates, and track output geometry and configuration. Concrete use cases include desktop environments and display managers that need to configure displays or render content aligned with specific monitor layouts.",
      "description_length": 441,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat.Error",
      "library": "wayland",
      "description": "This module defines error values specific to `wl_seat` requests in the Wayland protocol, including a single error case `Missing_capability`. It provides functions `to_int32` and `of_int32` to convert between error values and their integer representations. These conversions are used to handle and communicate protocol-level errors during seat-related operations in Wayland clients or servers.",
      "description_length": 392,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis",
      "library": "wayland",
      "description": "This module defines the axis types for scroll events in the Wayland protocol, specifically vertical and horizontal scroll directions. It provides conversion functions `to_int32` and `of_int32` to map between the axis type and 32-bit integer representations. These values are used to indicate the direction of scroll input events in windowing system interactions.",
      "description_length": 362,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard.Keymap_format",
      "library": "wayland",
      "description": "This module defines the format types for keyboard mappings in the Wayland protocol, specifically supporting `No_keymap` and `Xkb_v1` formats. It provides conversion functions `to_int32` and `of_int32` to serialize and deserialize keymap format values. This is used to handle keymap events sent by the compositor to clients, ensuring correct interpretation of keyboard input data.",
      "description_length": 379,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Button_state",
      "library": "wayland",
      "description": "Represents the physical state of a button in Wayland pointer events, with values for pressed and released states. Converts between button state values and 32-bit integers for serialization or transmission. Used to interpret or construct button event data in Wayland protocol messages.",
      "description_length": 284,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Resize",
      "library": "wayland",
      "description": "This module defines integer constants representing edges of a surface for resize operations, such as `top`, `bottom`, and `top_left`. It provides direct mappings to 32-bit integers for use in Wayland protocol messages. These values are used by clients and servers to communicate which edge is being resized, enabling context-aware behavior like cursor changes during interactive resizing.",
      "description_length": 388,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_source.Error",
      "library": "wayland",
      "description": "This module defines error codes for invalid operations related to data source handling, specifically `Invalid_action_mask` and `Invalid_source`. It provides conversions to and from 32-bit integers for use in protocol communication. These errors are used to indicate malformed drag-and-drop actions or invalid data sources in Wayland client-server interactions.",
      "description_length": 360,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis_source",
      "library": "wayland",
      "description": "This module defines enumerated values representing the physical sources of axis input events, such as `Wheel`, `Finger`, `Continuous`, and `Wheel_tilt`. It provides conversions between these source types and 32-bit integers using `to_int32` and `of_int32`. These values are used to distinguish how scroll or axis input events were generated, enabling clients to adjust interaction behaviors based on input device characteristics.",
      "description_length": 429,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm.Error",
      "library": "wayland",
      "description": "This module defines error codes for the Wl_shm interface, including `Invalid_format`, `Invalid_stride`, and `Invalid_fd`. It provides conversions between these error values and 32-bit integers using `to_int32` and `of_int32`. These errors are used to report invalid client requests related to shared memory buffer configuration.",
      "description_length": 328,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell.Error",
      "library": "wayland",
      "description": "This module defines error codes for the Wl_shell protocol, providing conversions between error values and 32-bit integers. It works with the `t` type representing shell-specific error conditions. Concrete use cases include handling invalid surface roles or protocol violations in Wayland shell implementations.",
      "description_length": 310,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard.Key_state",
      "library": "wayland",
      "description": "This module defines the physical state of a key as either `Released` or `Pressed` and provides conversion functions to and from 32-bit integers. It works directly with the `t` variant type representing key states. This is used to interpret or generate key events in Wayland clients or servers based on the actual hardware state.",
      "description_length": 328,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Transform",
      "library": "wayland",
      "description": "This module defines a set of transformations representing the orientation of an output device, including rotations and flips. It provides conversions between these transformations and 32-bit integers for serialization or transmission. These values are used to communicate how a surface should be transformed for correct display on rotated or mirrored outputs.",
      "description_length": 359,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_display.Error",
      "library": "wayland",
      "description": "This module defines global error codes that can occur in response to Wayland protocol requests. It includes specific errors such as `Invalid_object`, `Invalid_method`, `No_memory`, and `Implementation`, and provides conversions to and from 32-bit integers. These errors are used to indicate failure conditions in Wayland client-server communication.",
      "description_length": 349,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis_relative_direction",
      "library": "wayland",
      "description": "This module defines two possible directions for pointer axis events: `Identical` and `Inverted`. It provides conversion functions `to_int32` and `of_int32` to map between these direction values and 32-bit integers. These values are used to indicate whether pointer axis motion is in the same or opposite direction of the axis orientation.",
      "description_length": 338,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Error",
      "library": "wayland",
      "description": "This module defines error codes specific to pointer operations in the Wayland protocol. It provides conversions between error values and 32-bit integers for serialization and communication. Use this module to handle or inspect errors related to pointer device interactions, such as invalid pointer states or unsupported actions.",
      "description_length": 328,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subcompositor.Error",
      "library": "wayland",
      "description": "This module defines error codes for the subcompositor protocol, specifically `Bad_surface` and `Bad_parent`. It provides conversions between these error values and 32-bit integers using `to_int32` and `of_int32`. These functions are used to handle and communicate protocol-level errors when managing sub-surfaces in a Wayland compositor.",
      "description_length": 337,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm.Format",
      "library": "wayland",
      "description": "This module defines pixel format constants and conversions for shared memory buffers in a Wayland compositor. It supports operations to convert between pixel format variants and their 32-bit integer representations. Use cases include specifying buffer layouts for rendering and handling pixel format negotiation between clients and the compositor.",
      "description_length": 347,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_surface.Error",
      "library": "wayland",
      "description": "This module defines error codes returned by `wl_surface` requests in the Wayland protocol. It includes specific errors like `Invalid_scale`, `Invalid_transform`, and `Invalid_size`, which indicate invalid parameter values. The module provides conversion functions to and from `int32` for use in protocol communication.",
      "description_length": 318,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device.Error",
      "library": "wayland",
      "description": "This module defines error codes for the data device interface, including `Role` and `Used_source`. It provides conversions between these error codes and `int32` values. Use these functions to handle protocol errors during data transfer operations in Wayland clients or compositors.",
      "description_length": 281,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Fullscreen_method",
      "library": "wayland",
      "description": "This module defines an enumerated type representing different methods for setting a surface to fullscreen in a Wayland compositor. It includes variants such as `Scale`, `Driver`, and `Fill`, each indicating how a surface should adjust when conflicting with the output dimensions. The module provides conversion functions `to_int32` and `of_int32` to map between the enumerated values and their integer representations, facilitating interaction with low-level Wayland protocols.",
      "description_length": 477,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_offer.Error",
      "library": "wayland",
      "description": "This module defines error codes for invalid operations during drag-and-drop interactions, such as incorrect action masks or invalid finish calls. It works with the `t` sum type representing specific error conditions and provides conversions to and from `int32` for protocol handling. Concrete use cases include signaling protocol violations when a client misuses data offer operations in Wayland compositors.",
      "description_length": 408,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Transient",
      "library": "wayland",
      "description": "This module defines transient surface behavior flags for use in the `set_transient` request, primarily handling `int32` values. It includes the `inactive` flag and provides direct conversions to and from `int32`. These values dictate how transient surfaces interact with their parent surfaces in window management contexts.",
      "description_length": 323,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device_manager.Dnd_action",
      "library": "wayland",
      "description": "This module defines a bitmask type representing drag-and-drop actions available during Wayland drag-and-drop operations. It includes specific values for `none`, `copy`, `move`, and `ask`, allowing compositors and clients to negotiate the action taken based on user input and modifier keys. The type `t` is an alias for `int32`, with conversion functions to and from `int32` for handling protocol messages.",
      "description_length": 405,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat.Capability",
      "library": "wayland",
      "description": "This module defines a bitmask type `t` representing the capabilities of a Wayland seat, such as pointer, keyboard, and touch input support. It provides constants for each capability and functions to convert between the bitmask and `int32` values. It is used to determine which input device types are available on a given seat in Wayland compositors.",
      "description_length": 349,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Mode",
      "library": "wayland",
      "description": "This module defines bitflags for output mode properties, used to interpret the `flags` field in mode events. It provides constants `current` and `preferred` to check or set specific mode attributes. The `to_int32` and `of_int32` functions convert between flag values and their integer representation, enabling direct interaction with Wayland protocol events.",
      "description_length": 358,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Subpixel",
      "library": "wayland",
      "description": "This module defines an enumeration representing subpixel geometry layouts of display outputs, including horizontal and vertical RGB/BGR arrangements. It provides conversion functions to and from 32-bit integers for interoperability with low-level display protocols. Concrete use cases include configuring display rendering pipelines and handling output device characteristics in graphical applications.",
      "description_length": 402,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subsurface.Error",
      "library": "wayland",
      "description": "This module defines error codes specific to the `Wl_subsurface` protocol, including conversion to and from 32-bit integers. It works with the enumerated type `t` representing protocol-specific errors, such as `Bad_surface`. Concrete use cases include handling invalid surface operations during subsurface management in Wayland compositors.",
      "description_length": 339,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat",
      "library": "wayland",
      "description": "This module defines the Wayland protocol metadata for the `wl_seat` interface, including its supported versions, capability bitmask handling, and error definitions. It provides concrete data structures and conversion functions for managing input device capabilities and protocol errors specific to Wayland seats. Use cases include determining available input devices on a seat and handling capability-related errors in Wayland compositors or clients.",
      "description_length": 450,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shm",
      "library": "wayland",
      "description": "The module defines a singleton global object for shared memory support, allowing clients to create shared memory pools and advertise supported pixel formats via format events. It works with Wayland server-side objects like `wl_shm` and `wl_shm_pool`, handling versioned protocol requests and events. Concrete use cases include enabling clients to allocate and share memory buffers for rendering surfaces using known pixel formats.",
      "description_length": 430,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell",
      "library": "wayland",
      "description": "This module defines protocol metadata and operations for the Wl_shell interface, including versioning, interface name, and serialization of requests and events. It works with Wayland protocol types such as `t`, `versions`, and structured messages involving objects and integers. Concrete use cases include implementing shell extensions, managing surface roles, and handling protocol negotiation in Wayland compositors.",
      "description_length": 418,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_keyboard",
      "library": "wayland",
      "description": "This module handles keyboard input events for Wayland servers, including key presses, modifier state changes, and keyboard focus transitions. It works with `Wl_keyboard` objects and associated types like key state, serial numbers, and file descriptors for keymaps. Concrete use cases include sending key events to clients, updating modifier states, and managing keyboard focus on surfaces.",
      "description_length": 389,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_callback",
      "library": "wayland",
      "description": "This module provides a mechanism for clients to receive notifications when specific Wayland requests have completed, by handling the `done` event. It works with the `wl_callback` interface, which is created by various factory interfaces in the client bindings. Concrete use cases include synchronizing client-side state with server-side operations, such as waiting for a surface to be configured before rendering.",
      "description_length": 413,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_touch",
      "library": "wayland",
      "description": "This module handles touchscreen input events for Wayland clients, supporting operations like touch down, motion, and up. It works with touch point IDs and event sequences to track individual contacts on a touchscreen. Concrete use cases include gesture recognition, touch-based UI interactions, and multi-touch event handling in graphical applications.",
      "description_length": 352,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device",
      "library": "wayland",
      "description": "Handles data transfer operations in Wayland by defining the data device interface, including requests like starting a drag-and-drop operation or setting the selection, and events like data availability or source destruction. Works with data types such as `t`, `versions`, and structured messages containing objects and unsigned integers. Used to implement clipboard and drag-and-drop functionality in Wayland clients and compositors.",
      "description_length": 433,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_callback",
      "library": "wayland",
      "description": "This module defines the protocol interface for the `Wl_callback` type, specifying its versioned requests and events. It provides operations to retrieve method names and parameters for handling callbacks in the Wayland protocol. Concrete use cases include dispatching and handling completion events for asynchronous operations in Wayland compositors or clients.",
      "description_length": 360,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_compositor",
      "library": "wayland",
      "description": "This module manages the compositor singleton responsible for combining surface contents into a single display output. It provides functions to handle surface creation, buffer management, and rendering coordination for Wayland servers. Concrete use cases include setting up display outputs, managing client surfaces, and handling frame rendering for compositors.",
      "description_length": 361,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_region",
      "library": "wayland",
      "description": "This module defines metadata and operations for the `Wl_region` type, including versioned interface details, request and event handling. It works with Wayland protocol types, specifically `Wl_region`, and provides concrete access to its protocol messages by index. Use cases include implementing region-related protocol interactions in Wayland compositors or clients.",
      "description_length": 367,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_compositor",
      "library": "wayland",
      "description": "This module defines the protocol interface for a compositor in the Wayland display server protocol. It provides access to the interface name, supported version, and operations to retrieve requests and events by opcode, specifically handling compositor creation and client interactions. The module works with protocol opcodes, string identifiers, and version enums to manage surface and client lifecycle operations.",
      "description_length": 414,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_device",
      "library": "wayland",
      "description": "Handles inter-client data transfer operations like copy-paste and drag-and-drop. It manages selection updates and drag initiation with associated data sources and surfaces. Used by clients to interact with the compositor's data device manager for input-driven data exchange.",
      "description_length": 274,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_surface",
      "library": "wayland",
      "description": "This module defines the `wl_surface` interface in the Wayland protocol, including its supported versions and associated error codes. It provides functions to retrieve request and event details for specific versions, such as `requests` and `events`, which return tuples containing message names and their parameter types. Concrete use cases include handling surface configuration, buffer attachments, and damage tracking in Wayland compositors and clients.",
      "description_length": 455,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_surface",
      "library": "wayland",
      "description": "This module manages onscreen surfaces for Wayland clients, handling operations like attaching buffers, marking damage regions, setting input and opaque areas, and configuring transformations and scaling. It works with surface-local coordinates and buffer content, supporting versioned interactions up to version 6. Concrete use cases include rendering graphical content, handling display transformations for high-DPI screens, and managing user interaction regions for input handling.",
      "description_length": 483,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm",
      "library": "wayland",
      "description": "This module handles shared memory management for Wayland clients, providing functions to create and manage shared memory buffers via the `wl_shm` interface. It works with file descriptors, integers, and pixel formats to support buffer creation, format specification, and error handling during memory allocation. Concrete use cases include setting up pixel storage for rendering surfaces and validating client-provided buffer parameters like stride and format.",
      "description_length": 459,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_subsurface",
      "library": "wayland",
      "description": "This module manages sub-surface behavior for Wayland clients, providing operations to control synchronization modes, positioning, and stacking relative to parent surfaces. It works with `wl_subsurface` objects and interacts with `wl_surface` for buffer attachment and mapping state. Concrete use cases include positioning UI elements like popups or layered graphics independently of their parent while coordinating state updates through synchronized or desynchronized modes.",
      "description_length": 474,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_display",
      "library": "wayland",
      "description": "This module manages core global state and protocol-level operations for Wayland servers, specifically handling object ID lifecycle and error signaling. It operates on the `Wl_display` type, which represents the Wayland display server instance. Concrete use cases include acknowledging the deletion of protocol object IDs and sending fatal error events to clients with specific error codes and messages.",
      "description_length": 402,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_registry",
      "library": "wayland",
      "description": "This module provides a `bind` function to create client-side handles for global objects advertised by the Wayland compositor, allowing clients to interact with services like input devices or extensions. It works with registry objects, global names, and service handlers to establish connections to available interfaces. Concrete use cases include binding to interfaces such as `wl_compositor` or `wl_seat` to create surfaces or handle input events.",
      "description_length": 448,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_pointer",
      "library": "wayland",
      "description": "This module handles pointer input device operations in a Wayland client, specifically managing cursor appearance, pointer motion, and input events like button presses and scrolling. It works with `Wl_pointer.t` objects and interacts with `Wl_surface` proxies to control cursor position, set surfaces, and handle input focus. Concrete use cases include updating the cursor image during interaction, tracking pointer movement across surfaces, and processing mouse button or scroll wheel input for UI elements.",
      "description_length": 507,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_region",
      "library": "wayland",
      "description": "This module provides operations to manipulate rectangular regions, including union, intersection, and subtraction. It works with pixel-based coordinates and dimensions to define areas. Concrete use cases include defining visible and interactive areas of surfaces in a Wayland server.",
      "description_length": 283,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_touch",
      "library": "wayland",
      "description": "This module handles touchscreen input events for Wayland servers, including touch down, motion, up, and frame completion. It works with touch points identified by unique IDs, providing precise coordinate updates, shape, orientation, and session cancellation. Concrete use cases include managing multi-touch gestures, tracking finger movements on a touchscreen, and synchronizing touch input with rendering pipelines.",
      "description_length": 416,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer",
      "library": "wayland",
      "description": "Handles pointer device interactions in the Wayland protocol with functions to serialize and interpret button states, axis directions, and error codes. Works with 32-bit integers and enumerated types to represent pointer events such as button presses, scrolling, and axis motion. Used to construct and decode pointer input events for windowing system clients.",
      "description_length": 358,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_region",
      "library": "wayland",
      "description": "This module manages 2D regions by providing operations to add or subtract rectangular areas. It works with region objects to define areas for surfaces, such as opaque or input regions. Concrete use cases include setting input boundaries for windows or defining visible surface areas in a Wayland client.",
      "description_length": 303,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shm_pool",
      "library": "wayland",
      "description": "This module manages shared memory pools for Wayland servers, allowing clients to allocate shared memory buffers (`wl_buffer`) from a common memory region. It supports efficient memory reuse, ideal for dynamic surface resizing or handling numerous small buffers. The module works directly with shared memory file descriptors and buffer objects, enabling low-latency updates without repeated memory allocation overhead.",
      "description_length": 417,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_registry",
      "library": "wayland",
      "description": "This module defines the protocol metadata for the Wayland registry interface, including its version, interface name, and the list of requests and events with their respective arguments. It specifies how to encode and decode protocol messages for registry operations, such as binding new global objects. Concrete use cases include generating binding code for clients to interact with Wayland compositors and handling registry events like global object announcements.",
      "description_length": 465,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_device",
      "library": "wayland",
      "description": "Handles drag-and-drop and selection data transfer operations for Wayland servers. It manages events like initiating and ending drag sessions, motion during drags, and advertising data offers for clipboard or DnD actions. Works with Wayland surfaces, data offers, and input events to enable direct client-to-client data exchange.",
      "description_length": 328,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_offer",
      "library": "wayland",
      "description": "This module manages data transfer offers between Wayland clients, supporting copy-paste and drag-and-drop. It allows clients to accept specific MIME types, receive data over a file descriptor, and manage drag-and-drop actions and lifecycle. Use cases include handling user-initiated data transfers and negotiating formats during drag operations.",
      "description_length": 345,
      "index": 214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_seat",
      "library": "wayland",
      "description": "This module manages input device groups, providing functions to retrieve touch, keyboard, and pointer objects associated with a seat. It works with versioned seat objects and proxy handlers to interface with input devices. Concrete use cases include handling user input events such as touch gestures, keystrokes, and pointer movements in a Wayland client.",
      "description_length": 355,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output",
      "library": "wayland",
      "description": "This module defines protocol-level constants and serialization functions for display output management, including operations to encode/decode subpixel layouts, transformations, and mode flags. It works with enumeration types for subpixel geometry, output transforms, and mode properties, converting them to and from 32-bit integers for protocol transmission. Concrete use cases include configuring display output orientation, handling monitor mode changes, and setting up rendering pipelines based on physical display characteristics.",
      "description_length": 534,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_buffer",
      "library": "wayland",
      "description": "This module manages buffer resources for Wayland surfaces, providing a `release` operation to signal when the compositor is done using a buffer. It works with `wl_buffer` objects tied to surface content, such as pixel data from shared memory or DMA buffers. Concrete use cases include attaching rendered frames to surfaces and handling buffer lifecycle in compositors.",
      "description_length": 368,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shell",
      "library": "wayland",
      "description": "This module creates desktop-style surfaces for Wayland servers, enabling clients to associate a `wl_shell_surface` with a basic surface. It works with surface and shell surface types to implement window-like behaviors for desktop environments. Use this to build simple window management interfaces, though it is deprecated in favor of `xdg_shell` for modern applications.",
      "description_length": 371,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_buffer",
      "library": "wayland",
      "description": "This module manages buffer objects that provide pixel content for surfaces in a Wayland client. It supports operations to destroy buffers and works with buffer types created via factory interfaces like `wl_shm` or `wp_linux_buffer_params`. Concrete use cases include attaching buffers to surfaces for rendering and managing buffer lifecycle during graphical updates.",
      "description_length": 366,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_offer",
      "library": "wayland",
      "description": "Handles data transfer during drag-and-drop operations in Wayland compositors. It defines protocol messages for offering and receiving data, including actions like accept, receive, and finish, and works with types such as `t`, `versions`, and metadata. Used to implement clipboard and drag-and-drop functionality between clients and the compositor.",
      "description_length": 347,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_source",
      "library": "wayland",
      "description": "Handles Wayland drag-and-drop data sources with versioned operations for sending data offers and managing MIME types. Works with file descriptors, strings, and unsigned integers to transfer data between clients and the compositor. Used to implement clipboard and drag-and-drop functionality in Wayland-based applications.",
      "description_length": 321,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Proxy.Service_handler",
      "library": "wayland",
      "description": "This module manages service object handlers for Wayland protocol interactions, providing functions to attach handlers to proxies and access interface metadata. It works with proxy objects representing Wayland service instances, supporting versioned message handling and dynamic object registration. Concrete use cases include routing incoming protocol messages to the correct service implementation and managing version compatibility for registered objects.",
      "description_length": 457,
      "index": 222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_seat",
      "library": "wayland",
      "description": "This module manages input device groups, handling seat capabilities and unique identifiers. It works with seat objects to track keyboards, pointers, and touch devices, allowing servers to respond to capability changes and assign names. Concrete use cases include updating input device availability and labeling seats for client identification during runtime.",
      "description_length": 358,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shm_pool",
      "library": "wayland",
      "description": "This module manages shared memory pools for Wayland clients, allowing allocation of shared memory buffers that can be resized or reused efficiently. It operates on `wl_shm_pool` objects, enabling operations like resizing the memory mapping, creating buffers with specific dimensions and pixel formats, and releasing resources. Concrete use cases include interactive surface resizing, managing multiple small buffers for UI elements, and minimizing memory setup overhead during dynamic content rendering.",
      "description_length": 503,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_device_manager",
      "library": "wayland",
      "description": "This module manages client-side data transfer operations like copy-paste and drag-and-drop by creating and linking `wl_data_device` and `wl_data_source` objects to a `wl_seat`. It provides `get_data_device` to associate a data device with a seat and `create_data_source` to initiate a data source for offering content. These functions enable clients to handle version-specific data transfer interactions directly through Wayland proxies.",
      "description_length": 437,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subsurface",
      "library": "wayland",
      "description": "This module defines protocol-specific error codes and message handling for managing subsurface objects in the Wayland display server protocol. It works with enumerated error types and structured message formats to enforce correct surface hierarchy operations, such as positioning and synchronization during rendering. Concrete use cases include validating subsurface placement and handling protocol errors when a client misuses surface relationships.",
      "description_length": 450,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm_pool",
      "library": "wayland",
      "description": "This module defines the protocol interface for shared memory pools in the Wayland protocol. It provides operations to create and manage shared memory resources, including requests for creating buffers and handling memory mapping. The module works with shared memory file descriptors and buffer objects, enabling efficient pixel data transfer for surfaces in graphical applications.",
      "description_length": 381,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_registry",
      "library": "wayland",
      "description": "This module manages the global registry in a Wayland server, providing functions to announce the availability and removal of global objects to clients. It operates on global objects identified by name, interface, and version, enabling clients to bind to and interact with these objects. Concrete use cases include notifying clients of input devices becoming available or removed during runtime.",
      "description_length": 394,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_compositor",
      "library": "wayland",
      "description": "This module creates and manages Wayland surfaces and regions for client applications. It provides functions to instantiate surfaces and regions, which clients use to define and manipulate graphical content. Concrete use cases include setting up rendering targets for windows or UI elements in a Wayland-based application.",
      "description_length": 321,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shell_surface",
      "library": "wayland",
      "description": "This module handles desktop-style surface interactions, providing operations to configure window geometry, signal popup completion, and ping clients for responsiveness. It works with `wl_shell_surface` objects tied to Wayland surfaces, enabling server-side management of toplevel, fullscreen, and popup windows. Concrete use cases include adjusting window size and position, finalizing popup interactions, and monitoring client activity through ping requests.",
      "description_length": 459,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_subcompositor",
      "library": "wayland",
      "description": "This module handles the creation and management of sub-surfaces in a Wayland server, enabling hierarchical compositing of surfaces into a single logical window. It works with `wl_surface` objects, allowing them to be organized into parent-child relationships, where sub-surfaces are positioned relative to their parent. Concrete use cases include offloading compositing tasks such as rendering video overlays or window decorations by grouping related surfaces into a compound window structure.",
      "description_length": 493,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_device_manager",
      "library": "wayland",
      "description": "Manages inter-client data transfer mechanisms like copy-and-paste and drag-and-drop by associating them with `wl_seat` objects. It allows clients to retrieve a `wl_data_device` for a specific seat, enabling coordination of data sources and offers. This module is used to handle version-specific behavior of data transfer operations, particularly in response to seat events.",
      "description_length": 373,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_subcompositor",
      "library": "wayland",
      "description": "This module manages sub-surface compositing by providing a function to create sub-surface relationships between Wayland surfaces and to destroy those relationships. It works with `Wl_subcompositor` and `Wl_surface` objects, enabling clients to structure complex window content hierarchically. A concrete use case is a video player that separates video content and window decorations into different surfaces, allowing the compositor to optimize rendering using hardware overlays.",
      "description_length": 478,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shell_surface",
      "library": "wayland",
      "description": "This module defines operations to manage desktop-style surfaces, enabling clients to set titles, classes, and window states like fullscreen, maximized, or popup. It works with Wayland surface proxies and input seats to control window behavior in response to user actions such as resizing, moving, or pinging. Concrete use cases include implementing window decorations, handling user-initiated window state changes, and managing transient or popup windows in a desktop environment.",
      "description_length": 480,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Proxy.Handler",
      "library": "wayland",
      "description": "This module manages message handling for Wayland protocol objects, allowing handlers to be attached to proxies and providing version casting to adjust protocol compatibility. It works with proxy objects tied to specific roles (`Client` or `Server`) and interface types, enabling precise dispatch of incoming events. Concrete use cases include registering event handlers for Wayland objects and managing object creation in generated protocol code.",
      "description_length": 446,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_surface",
      "library": "wayland",
      "description": "This module manages onscreen surfaces for Wayland servers, handling operations like associating surfaces with outputs, setting preferred buffer transformations, and defining surface behavior through roles. It works with surface objects, output proxies, and transformation enums to control how surfaces are displayed and interacted with. Concrete use cases include assigning a surface to a display output, adjusting its scaling for high-DPI screens, or setting its rotation to match display orientation.",
      "description_length": 502,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shell",
      "library": "wayland",
      "description": "This module creates shell surfaces for desktop-style user interfaces by associating them with basic surfaces. It provides the `get_shell_surface` function to generate a shell surface from a given surface. Designed for Wayland clients, it is used primarily in legacy desktop environments before the adoption of xdg_shell.",
      "description_length": 320,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard",
      "library": "wayland",
      "description": "Handles keyboard input in the Wayland protocol with support for keymap formats and key state transitions. It defines physical key states (`Pressed`, `Released`) and serializes keymap formats like `Xkb_v1` for client-server communication. Used to process key events and keymap updates in Wayland compositors and clients.",
      "description_length": 319,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_source",
      "library": "wayland",
      "description": "This module manages data transfer operations for Wayland servers, handling events like cancellation, data sending, and target negotiation during drag-and-drop or clipboard operations. It works with `wl_data_source` objects across versions 1 to 3, using MIME types and file descriptors to transfer data. Concrete use cases include responding to client requests to send clipboard content, signaling cancellation of a drag operation, or confirming the completion of a drop action.",
      "description_length": 477,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_output",
      "library": "wayland",
      "description": "This module manages Wayland output objects representing visible regions of the compositor coordinate system, typically corresponding to physical monitors. It provides operations to release output resources, handling versions 3 and 4 of the protocol. Concrete use cases include managing display hotplug events and releasing output objects when they are no longer needed by the client.",
      "description_length": 383,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_display",
      "library": "wayland",
      "description": "This module defines the protocol interface for the Wayland display object, specifying its version and global error handling. It provides functions to retrieve request and event signatures, mapping protocol messages to typed fields like object IDs, strings, and unsigned integers. Concrete use cases include handling display initialization, error reporting during client-server communication, and managing global object registration.",
      "description_length": 432,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_subsurface",
      "library": "wayland",
      "description": "This module manages sub-surfaces in a Wayland server, providing functions to control their position, stacking order, and synchronization mode relative to parent surfaces. It operates on `wl_subsurface` objects, handling state changes such as setting position, placing above or below siblings, and switching between synchronized and desynchronized modes. Concrete use cases include arranging UI components like popups or layered windows, ensuring correct rendering order, and coordinating state updates with parent surfaces.",
      "description_length": 523,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_output",
      "library": "wayland",
      "description": "This module manages output regions for a Wayland compositor, handling properties such as geometry, scaling, and display modes. It works with `Wl_output.t` types across multiple versions, allowing servers to define visible areas, their physical attributes, and transformations. Concrete use cases include setting monitor resolutions, advertising supported display modes, and providing output metadata like names and descriptions during startup or hotplug events.",
      "description_length": 461,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_display",
      "library": "wayland",
      "description": "This module manages the core global object in a Wayland client, providing direct access to protocol-level functionality. It supports operations to retrieve the global registry and perform asynchronous roundtrips (sync). These functions interact with Wayland display and proxy objects, specifically handling versions and client-side protocol interactions. Use cases include initializing access to Wayland globals and synchronizing client-server state.",
      "description_length": 450,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_buffer",
      "library": "wayland",
      "description": "This module defines metadata and operations for the `Wl_buffer` type, including versioned interface details, method for querying requests and events by version, and type representations. It works with symbolic types like `[ `Wl_buffer ]` and version tags such as `[ `V1 ]`. Concrete use cases include generating bindings for Wayland buffer objects and handling protocol-specific type information.",
      "description_length": 396,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_source",
      "library": "wayland",
      "description": "Handles data transfer operations for Wayland clients by allowing a data source to offer specific MIME types and respond to transfer requests. Works with `wl_data_source` objects across versions 1 to 3, supporting destruction of sources, adding MIME types, and setting drag-and-drop actions in version 3. Used in implementing drag-and-drop and clipboard functionality where a client needs to provide data to another client.",
      "description_length": 422,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_pointer",
      "library": "wayland",
      "description": "This module handles pointer input events for Wayland servers, including motion, button presses, and scrolling. It works with Wayland surfaces and fixed-point coordinates to track pointer position and interaction. Concrete use cases include sending cursor movement updates, handling mouse clicks, and relaying scroll events with high precision and axis metadata.",
      "description_length": 361,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_keyboard",
      "library": "wayland",
      "description": "This module manages keyboard input devices in a Wayland client, providing functions to handle key events and release keyboard resources. It operates on the `Wl_keyboard.t` type, supporting versioned interactions up to version 9. A concrete use case is handling keyboard input in a graphical application by capturing key presses and releasing the keyboard when it is no longer needed.",
      "description_length": 383,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device_manager",
      "library": "wayland",
      "description": "Handles Wayland drag-and-drop and clipboard operations through protocol requests and events. Works with `Wl_data_device_manager` type and versioned interfaces up to `V3`. Concrete use cases include creating data offers, managing drag-and-drop actions like `copy` and `move`, and handling selection data transfers between clients and the compositor.",
      "description_length": 348,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_touch",
      "library": "wayland",
      "description": "This module defines the protocol metadata for the touch interface, including versioned requests and events. It specifies the data types for touch points, such as coordinates, surface identifiers, and touch point states. Concrete use cases include handling multi-touch input events and mapping touch gestures to application actions in Wayland compositors.",
      "description_length": 354,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_callback",
      "library": "wayland",
      "description": "This module provides a single function, `done_`, which sends a completion notification to a client once a related request has finished processing. It operates on a `Wl_callback` object constrained to version 1, along with an `int32` callback data value. A typical use case involves notifying a client when a frame buffer has been successfully rendered and committed.",
      "description_length": 366,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_offer",
      "library": "wayland",
      "description": "This module manages data transfer offers in Wayland servers, specifically handling MIME type advertisement and drag-and-drop actions. It works with `wl_data_offer` objects to specify available data formats and communicate transfer actions between clients. Concrete use cases include implementing copy-paste and drag-and-drop functionality where a server needs to negotiate data format and transfer method with a client.",
      "description_length": 419,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shm",
      "library": "wayland",
      "description": "This module manages shared memory for Wayland clients, allowing creation of shared memory pools via `create_pool` using a file descriptor and size. It supports version 1 and 2 of the protocol, with version 2 adding a `release` function to free resources. Concrete use cases include allocating buffers for pixel data in client applications, such as rendering surfaces or image transfers, where direct memory access is required.",
      "description_length": 426,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subcompositor",
      "library": "wayland",
      "description": "This module defines the protocol interface and version metadata for the subcompositor extension in Wayland. It includes functions to map request and event indices to their corresponding names and argument types, supporting precise interaction with sub-surface management operations. It is used specifically for handling sub-surface creation and error reporting through the `Error` submodule.",
      "description_length": 391,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface",
      "library": "wayland",
      "description": "This module defines protocol operations and data types for managing shell surfaces in a Wayland compositor. It includes requests like `move`, `resize`, `set_transient`, and `set_fullscreen`, which manipulate surface state using input parameters such as edges, transient flags, and fullscreen methods. The module handles communication between clients and the compositor for window management tasks like interactive resizing, transient window placement, and display mode switching.",
      "description_length": 479,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Registry",
      "library": "wayland",
      "description": "This module provides operations to interact with the Wayland registry, including retrieving interface entries by name and binding to proxies for specific interfaces. It works with the `t` type representing the registry and `entry` type for interface information. Concrete use cases include discovering available Wayland interfaces and creating proxies to interact with them, such as binding to `wl_compositor` or `wl_shell` interfaces for rendering and window management.",
      "description_length": 471,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.S",
      "library": "wayland",
      "description": "This module handles the sending and receiving of bytes and file descriptors using transport mechanisms like `sendmsg` and `recvmsg`. It defines user data tagging for proxies, allowing extensions with additional data types. Concrete use cases include managing communication channels in Wayland clients and servers.",
      "description_length": 313,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server",
      "library": "wayland",
      "description": "This module provides operations for creating and managing global state (e.g., displays, registries), rendering surfaces, handling input devices (pointers, keyboards), and facilitating inter-client data transfer. It works with Wayland resources like surfaces, buffers, input devices, and data offers, while supporting hierarchical composition through subcompositor and subsurface relationships. These features enable implementing windowing systems with structured UI rendering, drag-and-drop interactions, and synchronized multi-surface layouts for overlays or popups.",
      "description_length": 567,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Client",
      "library": "wayland",
      "description": "This module establishes and manages a client connection to a Wayland server over a given transport. It provides functions to send sync messages, retrieve the initial display object, shut down the connection, and format connection state for debugging. It works with the `t` type representing the client connection, and interacts with Wayland protocol objects such as `Wl_display`. Concrete use cases include initializing a Wayland client session, synchronizing with the server, and cleanly terminating the connection.",
      "description_length": 516,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto",
      "library": "wayland",
      "description": "This module provides protocol metadata and type definitions for Wayland interfaces, enabling client-server communication in compositor-based display systems. It supports operations for handling versioned requests, events, and structured data across interface types such as display management, shared memory pools, surfaces, and input devices. Specific use cases include enforcing surface hierarchy constraints via subcompositor extensions, managing data transfer through drag-and-drop offers, and generating language bindings for protocol interaction.",
      "description_length": 551,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Metadata",
      "library": "wayland",
      "description": "This module defines data types and structures for describing Wayland interface parameters and messages. It includes types for parameter kinds (`param`), argument tuples (`arg`), and interface metadata (`info`). Concrete use cases include parsing and representing Wayland protocol descriptions, enabling correct serialization and deserialization of interface calls and events.",
      "description_length": 375,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client",
      "library": "wayland",
      "description": "This module supports protocol interactions for display management, input handling, and graphical resource allocation using Wayland proxy objects like surfaces, buffers, and shared memory pools. It enables structured rendering of complex UI elements through hierarchical surface relationships and synchronized sub-surface positioning, while facilitating inter-client data exchange via drag-and-drop or clipboard operations. Key use cases include building windowing systems, compositors, and applications requiring low-level control over rendering and input events.",
      "description_length": 563,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Server",
      "library": "wayland",
      "description": "This module implements Wayland server-side protocol handling, enabling communication with clients over a transport. It manages connection state, dispatches requests to a service handler, and provides control over the display object and shutdown process. Use it to build custom Wayland compositors by defining behavior for client interactions and resource management.",
      "description_length": 366,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Iface_reg",
      "library": "wayland",
      "description": "This module maintains a registry of Wayland interface metadata, enabling runtime association of interface names with their corresponding structured representations. It provides operations to register interface metadata and to look up previously registered interfaces by name. Concrete use cases include mapping Wayland protocol interface strings to typed representations during client or server initialization.",
      "description_length": 410,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Unix_transport",
      "library": "wayland",
      "description": "Implements message transmission over Unix-domain sockets for Wayland clients. Provides functions to connect to a Wayland server socket, retrieve the socket path, and manage communication using an Eio-based transport interface. Works directly with Eio_unix network resources and Wayland's transport protocol.",
      "description_length": 307,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Msg",
      "library": "wayland",
      "description": "This module handles the low-level construction and deconstruction of Wayland protocol messages. It operates on `Wayland.Msg.t` values, which represent messages in the process of being read or written, and uses auxiliary types like `Cstruct.t` for buffer manipulation and `Unix.file_descr` for file descriptors. It is used to extract individual fields and arguments from incoming messages, and to build outgoing messages by appending arguments such as integers, strings, arrays, and file descriptors.",
      "description_length": 499,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Proxy",
      "library": "wayland",
      "description": "The module provides operations for managing Wayland proxy objects, including querying metadata (version, interface, ID), controlling lifecycle (deletion, shutdown), constructing and sending messages, and dynamically creating objects through spawning or binding. It operates on proxy objects associated with protocol interfaces and roles, facilitating client-server communication with version-aware protocol compatibility. Additional utilities support error diagnostics and logging via string generation for unknown events and `Fmt.t` formatters for proxy state and transport visualization.",
      "description_length": 589,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Fixed",
      "library": "wayland",
      "description": "This module implements arithmetic operations for a 24.8 fixed-point numeric type, represented as a private `int32`. It provides conversion functions between integers, raw bits, and the fixed-point format, along with pretty-printing support. It is used for precise fractional calculations in graphics and windowing operations where floating-point is undesirable.",
      "description_length": 361,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland",
      "library": "wayland",
      "description": "This module implements core components for Wayland client and server communication, handling protocol messaging, proxy management, and transport over Unix-domain sockets. It supports precise fixed-point arithmetic for graphics, interface metadata registration, and low-level message serialization. Concrete use cases include building Wayland compositors, managing client-server interactions with protocol objects like surfaces and input devices, and handling versioned message exchange with proper serialization.",
      "description_length": 512,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 600,
    "meaningful_modules": 270,
    "filtered_empty_modules": 330,
    "retention_rate": 0.45
  },
  "statistics": {
    "max_description_length": 615,
    "min_description_length": 274,
    "avg_description_length": 412.1222222222222,
    "embedding_file_size_mb": 3.9126663208007812
  }
}