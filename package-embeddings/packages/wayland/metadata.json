{
  "package": "wayland",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 275,
  "creation_timestamp": "2025-07-16T00:30:41.002621",
  "modules": [
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_feedback_v1.Tranche_flags",
      "library": "wayland.protocols",
      "description": "This module defines a bitmask type for Linux DMA-BUF buffer feedback flags, used to indicate properties of buffer tranches. It provides constants like `scanout` and utilities `to_int32` and `of_int32` for converting between flag values and their integer representations. These flags are used in Wayland compositor feedback to describe buffer usage constraints for rendering.",
      "description_length": 374,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1.Layer",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type representing distinct display layers for surfaces in a Wayland compositor, including background, bottom, top, and overlay. It provides conversions between the enumerated values and 32-bit integers, enabling serialization and deserialization for inter-process communication. Concrete use cases include managing z-ordering of fullscreen and shell surfaces in compositors implementing the layer shell protocol.",
      "description_length": 446,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for the Xdg positioner interface, specifically handling invalid input scenarios. It provides conversions between error values and 32-bit integers, enabling proper serialization and communication with Wayland clients. A concrete use case is reporting invalid positioning constraints back to clients in a structured and standardized way.",
      "description_length": 367,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Constraint_adjustment",
      "library": "wayland.protocols",
      "description": "This module defines bitflags for adjusting surface positioning in a Wayland compositor when constraints are violated. It provides constants representing adjustment strategies\u2014such as sliding, flipping, and resizing\u2014along with utilities to convert values to and from 32-bit integers. These flags are used to specify how a surface should be repositioned or resized to fit within the compositor's work area.",
      "description_length": 404,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Anchor",
      "library": "wayland.protocols",
      "description": "This module defines constants and conversion functions for anchoring layer surfaces in a compositor. It provides specific flags for positioning surfaces relative to the top, bottom, left, or right edges of an output. These values are used when configuring layer surfaces to control their alignment and docking behavior within a Wayland session.",
      "description_length": 344,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Format",
      "library": "wayland.protocols",
      "description": "This module defines a variant type representing pixel formats used in DRM (Direct Rendering Manager) protocols, including RGB, BGR, ARGB, YUV, and other specialized formats. It provides functions to convert these format values to and from 32-bit integers, enabling efficient serialization and deserialization during communication with display drivers or hardware. These operations are essential for configuring framebuffers and handling display output in low-level graphics applications.",
      "description_length": 487,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1.Flags",
      "library": "wayland.protocols",
      "description": "This module defines flags for buffer parameters in the Linux DMA-BUF protocol, including `y_invert`, `interlaced`, and `bottom_first`. It works with `int32` values to represent and manipulate buffer attributes. These flags are used to specify pixel layout and buffer handling in display compositing scenarios.",
      "description_length": 309,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error values for handling pointer constraint operations in Wayland protocol interactions. It includes a single error variant `Already_constrained` and functions to convert between error values and 32-bit integers. It is used to report and handle errors when applying pointer constraints in graphical applications.",
      "description_length": 333,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration.Mode",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type with values `None`, `Client`, and `Server`, representing decoration modes in a Wayland server protocol. It provides `to_int32` and `of_int32` functions for converting between the enum and 32-bit integers, enabling serialization and deserialization for inter-process communication. These values are used specifically in handling server decoration requests and events within a compositor implementation.",
      "description_length": 440,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_wm_base.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes used in the XDG WM base protocol for handling window management operations. It includes specific errors like invalid surface roles, defunct surfaces, and issues with popups or positioners. These errors are converted to and from 32-bit integers for use in protocol communication.",
      "description_length": 310,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_surface.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for XDG surface operations in the Wayland protocol. It includes specific errors like `Not_constructed`, `Already_constructed`, and `Invalid_size`, which indicate failure reasons during surface configuration and usage. The module provides conversions between error values and 32-bit integers for serialization and protocol handling.",
      "description_length": 363,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for DRM authentication and format validation failures. It provides conversions between error values and 32-bit integers. Use this module to handle protocol-specific errors in DRM-related operations, such as validating client authentication or checking pixel format compatibility.",
      "description_length": 311,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for validating Linux DMA-BUF buffer parameters, including checks for usage, plane indices, format validity, and dimension constraints. It provides conversions between error values and 32-bit integers for serialization or transmission. These errors are used to report specific parameter validation failures when constructing or modifying DMA-BUF-based buffers in Wayland compositors.",
      "description_length": 414,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1.Flags",
      "library": "wayland.protocols",
      "description": "This module defines bit flags for screen copy operations, specifically supporting the inversion of pixel data along the y-axis. It provides constants and conversion functions for working with raw buffer metadata. Use cases include handling screen capture buffers where vertical flipping is required, such as in screen recording or remote desktop applications.",
      "description_length": 359,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.State",
      "library": "wayland.protocols",
      "description": "This module defines a set of state flags used to communicate window state changes between a Wayland compositor and a client, including states like maximized, fullscreen, resizing, and tiled edges. It provides bidirectional conversion between these states and 32-bit integers, enabling efficient serialization and transmission over Wayland protocol events. Concrete use cases include synchronizing window decorations, enforcing geometry constraints, and managing visual presentation during resizing or tiling operations.",
      "description_length": 519,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Wm_capabilities",
      "library": "wayland.protocols",
      "description": "This module defines a set of window management capabilities including window menu, maximize, fullscreen, and minimize options. It provides functions to convert these capabilities to and from 32-bit integers. This module is used to communicate supported window operations between a Wayland compositor and clients.",
      "description_length": 312,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1.Mode",
      "library": "wayland.protocols",
      "description": "This module defines two window decoration modes, `Client_side` and `Server_side`, representing how window decorations are handled in a Wayland compositor. It provides conversion functions `to_int32` and `of_int32` to map between these modes and 32-bit integers. These values are used to negotiate or set decoration rendering responsibility between the client and the server in desktop environments.",
      "description_length": 398,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling invalid operations in layer shell protocol interactions, including cases like incorrect role assignment, invalid layer values, and multiple constructions of the same object. It provides conversions between error values and 32-bit integers for serialization or transmission purposes. These errors are used to enforce correct usage of layer shell surfaces in display compositors.",
      "description_length": 422,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration_manager.Mode",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type with three values (`None`, `Client`, `Server`) representing decoration modes in a Wayland server. It provides conversions to and from 32-bit integers for use in protocol messages. These values are used to specify or respond to decoration mode requests in window management contexts.",
      "description_length": 321,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling screen copy operations, specifically indicating when a buffer is already used or invalid. It provides conversions between error values and 32-bit integers for use in low-level communication. These errors are used to report failure conditions in screen capture requests within the Wayland protocol.",
      "description_length": 342,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for invalid operations on XDG toplevel surfaces, such as incorrect resize edges, parent assignments, or size values. It provides conversions between these error codes and 32-bit integers, enabling proper handling and transmission over Wayland protocol connections. These errors are used to enforce constraints during window management operations in Wayland compositors.",
      "description_length": 401,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Gravity",
      "library": "wayland.protocols",
      "description": "This module defines a set of cardinal and diagonal directions used to specify anchor points for positioning surfaces in a windowing system. It includes functions to convert these direction values to and from 32-bit integers, enabling efficient transmission and storage. Concrete use cases include aligning pop-up windows relative to parent surfaces, such as positioning a context menu below a clicked element or anchoring a tooltip to the top-left of a widget.",
      "description_length": 460,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm.Capability",
      "library": "wayland.protocols",
      "description": "This module defines a bitmask type for representing DRM capabilities in the Wayland protocol. It includes operations to convert capability values to and from 32-bit integers, enabling efficient storage and transmission. Concrete use cases include querying and setting DRM device capabilities such as PRIME support during display server initialization.",
      "description_length": 351,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel.Resize_edge",
      "library": "wayland.protocols",
      "description": "This module defines a set of constants representing edges and corners of a surface for resize operations in a Wayland compositor. It includes functions to convert these edge values to and from 32-bit integers, enabling efficient transmission and handling of resize events. Concrete use cases include determining which part of a window is being dragged during interactive resizing and applying the appropriate resizing logic based on the edge or corner.",
      "description_length": 452,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Keyboard_interactivity",
      "library": "wayland.protocols",
      "description": "This module defines an enumerated type `t` with three variants\u2014`None`, `Exclusive`, and `On_demand`\u2014that specify how a layer shell surface interacts with keyboard focus in a Wayland compositor. It includes conversion functions `to_int32` and `of_int32` for mapping between the type and 32-bit integers, primarily used for protocol serialization. Concrete use cases include setting keyboard focus behavior for lock screens (`Exclusive`), desktop widgets (`None`), and panels (`On_demand`) in a compositor.",
      "description_length": 504,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1.Lifetime",
      "library": "wayland.protocols",
      "description": "This module defines two lifetime semantics for pointer constraints: `Oneshot`, which becomes defunct after deactivation, and `Persistent`, which can reactivate. It provides conversions between these values and 32-bit integers. These values are used when creating pointer constraints to specify how they should behave upon deactivation events.",
      "description_length": 342,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for handling invalid states in the management of XDG toplevel decorations, such as unconfigured buffers, already constructed objects, or orphaned resources. It provides conversions between these error codes and 32-bit integers, enabling proper serialization and communication over Wayland. These operations are used to enforce correct protocol behavior when managing window decorations in a compositor.",
      "description_length": 434,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_popup.Error",
      "library": "wayland.protocols",
      "description": "This module defines an error type for handling invalid grab events in popup surfaces, specifically used in the XDG shell protocol. It provides conversions between the error type and 32-bit integers, enabling proper serialization and error handling in Wayland client-server communication. A concrete use case is detecting and responding to invalid pointer grabs when managing popup window interactions.",
      "description_length": 401,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner.Anchor",
      "library": "wayland.protocols",
      "description": "This module defines a set of anchor points for positioning elements in a windowing system, such as top-left or bottom-right. It includes functions to convert between anchor values and 32-bit integers, enabling efficient storage and transmission. These anchors are used to specify how surfaces should be aligned relative to other elements in a Wayland compositor.",
      "description_length": 362,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1.Error",
      "library": "wayland.protocols",
      "description": "This module defines error codes for invalid operations on layer surfaces in the unstable layer shell protocol. It includes specific errors like `Invalid_surface_state`, `Invalid_size`, and others, each corresponding to different invalid client requests. These errors are used to signal incorrect configuration values sent by clients when managing layer surfaces.",
      "description_length": 362,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module manages the transfer of primary selection clipboard contents by offering mechanisms to receive data in specified MIME types. It provides operations to destroy an offer and request data transfer through a file descriptor. Concrete use cases include handling clipboard data pasted from external sources in graphical applications.",
      "description_length": 339,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation and retrieval of relative pointer objects associated with a pointer device. It provides a function to bind a relative pointer interface to a specific pointer, allowing clients to receive relative motion events. Use this module when implementing pointer input handling that requires tracking relative movement, such as cursor control or gesture recognition.",
      "description_length": 389,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in a Wayland client, enabling interaction with the X primary selection clipboard. It provides operations to create and retrieve primary selection sources and device objects, specifically tied to seats. Concrete use cases include handling clipboard operations like copy and paste in graphical applications using Wayland.",
      "description_length": 377,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation of dmabuf-based Wayland buffers by collecting dmabuf file descriptors and associated parameters. It provides functions to add dmabufs for each plane of a pixel format, specify buffer dimensions and format, and create or destroy the buffer. Concrete use cases include importing GPU memory buffers for display in a compositor or sharing memory between processes for rendering.",
      "description_length": 407,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection in a Wayland client, providing operations to destroy a selection device and set the selection source with a specific serial number. It works with Wayland proxies representing primary selection sources and devices. Concrete use cases include handling user-initiated text selection and clipboard operations in graphical applications.",
      "description_length": 369,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module manages primary selection in a Wayland client, providing operations to set and clear the selection source with a given serial number. It works with Wayland proxies representing primary selection sources and device objects. Concrete use cases include handling user-initiated selections, such as text or image data, and coordinating clipboard operations between applications.",
      "description_length": 385,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `configure` function to notify clients about changes to window decoration modes, specifically enabling or disabling server-side decorations. It works with the `Zxdg_toplevel_decoration_v1` type and mode values from the `Mode` module, representing decoration states like server-side or client-side. Concrete use cases include adjusting visual borders and title bars dynamically in a Wayland compositor based on user or system preferences.",
      "description_length": 460,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol behavior for confined pointer constraints in Wayland, specifically handling pointer motion restrictions within a defined region. It works with Wayland protocol types such as `t`, `versions`, and metadata types to manage requests and events tied to pointer confinement. Concrete use cases include implementing pointer barriers or restricted movement areas in graphical applications.",
      "description_length": 428,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module defines the primary selection source interface for Wayland, handling clipboard-like data transfer. It provides operations to send data to and receive data from a Wayland compositor using file descriptors and strings. Concrete use cases include implementing copy-paste functionality where applications offer or retrieve textual content via the primary selection mechanism.",
      "description_length": 383,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module defines layer surface behavior for Wayland compositors, handling operations like surface configuration and closure. It works with `Zwlr_layer_surface_v1.t` objects, tracking state changes such as size, anchor, and visibility. Concrete use cases include managing UI layers in a desktop environment, where surfaces must be explicitly mapped or unmapped after buffer detachment.",
      "description_length": 387,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module manages pointer confinement within a Wayland compositor by allowing clients to set a specific region where the pointer is restricted. It provides operations to update the confinement region and destroy the confined pointer object, triggering events when confinement starts or ends. Concrete use cases include restricting pointer movement to a specific window or area during interactive operations like drag-and-drop or modal dialogs.",
      "description_length": 445,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module sends detailed DMA buffer feedback to clients, including preferred devices and supported format modifiers. It works with Wayland protocol objects to convey feedback through structured events like `main_device`, `tranche_target_device`, and `tranche_formats`. Concrete use cases include informing clients of optimal buffer allocation settings and signaling when configuration updates are needed.",
      "description_length": 406,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module handles server-side decoration requests for Wayland surfaces, specifically supporting KDE KWin compositors. It provides `request_mode` to set a decoration mode and `release` to free the decoration object. Concrete use cases include managing window borders and visual styles in desktop environments like KDE Plasma.",
      "description_length": 326,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, allowing servers to describe available data and respond to transfer requests. It provides operations to send data via a file descriptor using a specified MIME type and handle cancellation of selection requests. Concrete use cases include implementing clipboard functionality in graphical applications where data needs to be transferred between clients.",
      "description_length": 418,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_client.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module handles direct rendering management in a Wayland client. It provides functions to create DRM buffers for display, including planar and PRIME buffer creation, and supports buffer authentication. The module works with DRM protocol objects, file descriptors, and display parameters like width, height, and pixel format. It is used to interface with GPU memory for rendering surfaces in graphics applications.",
      "description_length": 417,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module manages short-lived popup surfaces for user interface elements like menus and tooltips. It provides functions to configure popup geometry, signal dismissal, and handle repositioning, working with `xdg_popup` objects tied to Wayland surfaces. Concrete use cases include displaying context menus, handling user interactions, and managing transient UI overlays.",
      "description_length": 370,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module defines rules for positioning child surfaces relative to parent surfaces, including constraints for visibility and adjacency. It supports operations like setting anchor points, gravity, size, and offset, with additional controls for reactive updates and parent configuration in later versions. Concrete use cases include positioning pop-up menus, tooltips, or dialog boxes in a windowing system while ensuring they remain within screen boundaries and respond to layout changes.",
      "description_length": 489,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer in the Wayland protocol, allowing the addition of MIME types to describe offered data and handling requests to transfer the selection's contents. It works with the `Zwp_primary_selection_source_v1.t` type representing a primary selection source. Concrete use cases include offering text or file data for clipboard-like primary selection transfers in graphical applications.",
      "description_length": 438,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module manages desktop-style user interface surfaces in a Wayland client, providing operations to assign roles such as toplevel windows or popups, set window geometry, acknowledge configuration events, and destroy surfaces. It works with Wayland surface objects and role-specific proxies like xdg_toplevel and xdg_popup. Concrete use cases include creating and managing application windows, context menus, and handling surface resizing and mapping in a desktop environment.",
      "description_length": 478,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_confined_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module manages pointer confinement within a Wayland compositor. It provides functions to activate confinement, ensuring the pointer is within a specified region of a surface, and to handle unconfined events when the compositor ends the confinement. It works with pointer and surface objects to enforce spatial constraints during user interactions like dragging or selecting.",
      "description_length": 379,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module handles server-side decoration modes for Wayland compositors, specifically supporting the `v1` protocol version. It provides a `mode` function to set the decoration mode, which determines how window decorations are rendered by the server. Concrete use cases include enabling or disabling server-side shadows, borders, or other visual elements for client windows in a Wayland desktop environment.",
      "description_length": 407,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for handling primary selection offers in a Wayland compositor. It provides operations to retrieve the interface name, version, and metadata, along with functions to process requests and events specific to version 1 of the protocol. It works with types such as `t`, `versions`, and structured lists of request and event data, primarily used in implementing clipboard-like functionality for text selection in Wayland clients.",
      "description_length": 466,
      "index": 51,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for a locked pointer in the Wayland display server protocol. It provides operations to request pointer locking and handle associated events, working with Wayland's protocol metadata and versioning structures. Concrete use cases include implementing pointer confinement in compositor clients.",
      "description_length": 334,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module represents a logical output region in a Wayland compositor, typically corresponding to a display monitor. It provides a `destroy` function to tear down the output object and supports handling output property updates, with version 3 enabling atomic updates via `wl_output.done`. It works with Wayland display and output objects, primarily used by compositors to manage and track monitor configurations.",
      "description_length": 413,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland XDG popup protocol, encoding and decoding requests and events for popup surfaces across versions 1 to 6. It handles actions like positioning, input grabs, and dismissal, essential for desktop environments and window managers. The module includes an error-handling submodule that converts invalid grab conditions into 32-bit integers, ensuring robust communication during popup interactions. For example, it allows a compositor to detect invalid pointer grabs or correctly position a popup relative to its parent surface.",
      "description_length": 555,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module manages DMA-BUF buffer allocation feedback in Wayland compositing, handling versioned requests and events to communicate device capabilities and memory constraints. It works with buffer tranches, device identifiers, and memory formats to optimize GPU memory usage and buffer sharing. The `flags` submodule defines a bitmask type for buffer feedback properties, such as `scanout`, with conversion utilities for integrating these flags into feedback messages. You can use this module to query device-specific memory formats, signal buffer usage constraints, and manage DMA-BUF tranches across different protocol versions.",
      "description_length": 631,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module handles the creation and management of layered surfaces on a Wayland desktop, allowing clients to define surfaces with specific z-depth, anchoring, and input behavior. It works with Wayland surfaces (`wl_surface`) and layer-related enums to control rendering order and positioning relative to the desktop. Concrete use cases include implementing desktop shells, panels, docks, and popups that require precise layering and screen attachment.",
      "description_length": 452,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations for managing logical output regions in a Wayland compositor, including setting their size, position, name, and description. It works with `Zxdg_output_v1.t` objects representing output regions and sends events like `done_` to signal property updates. Concrete use cases include configuring monitor layouts and notifying clients of display geometry changes.",
      "description_length": 387,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module manages primary selection in a Wayland server, providing `selection` to advertise a new selection and `data_offer` to create a new primary selection offer. It operates on `Gtk_primary_selection_device` and related proxy types, handling data transfer between clients. Concrete use cases include implementing clipboard functionality where a client sets the primary selection and offers data for retrieval.",
      "description_length": 415,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module manages top-level surfaces in a Wayland compositor, providing functions to control window state (maximize, minimize, fullscreen), set metadata (title, app ID), and initiate user-driven actions (resize, move, window menu). It operates on `xdg_toplevel` objects, with support for multiple protocol versions, and handles interactions like setting size constraints, attaching outputs, and managing parent-child surface relationships. Concrete use cases include implementing window management in desktop environments, handling user input for window resizing or moving, and setting application-specific identifiers for taskbars or compositors.",
      "description_length": 649,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module manages pointer constraints in Wayland, enabling precise control over pointer input through locking and confinement. It defines core types like `t` and `versions`, and supports operations for setting constraint behavior using lifetime semantics such as `Oneshot` and `Persistent`. The module handles errors like `Already_constrained` and integrates with compositors to enforce constraints during input events. For example, it allows restricting pointer movement to a specific region or locking the pointer to a device until explicitly released.",
      "description_length": 556,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages screen capture operations by providing functions to initiate output and region-based screen captures. It works with Wayland proxy objects representing outputs and frame handlers to capture specific regions or entire outputs with optional cursor overlay control. Concrete use cases include capturing screenshots of displays or specific areas for remote desktop, screen recording, or UI automation tasks.",
      "description_length": 422,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module manages layer surfaces in a Wayland compositor, handling configuration, positioning, and keyboard interaction through concrete request and event handlers. It defines core types like `t` for surface state, `versions` for protocol compatibility, and integrates anchoring flags, keyboard interaction modes, and error codes for precise control over UI elements such as panels and popups. The anchoring submodule provides flags to dock surfaces to screen edges, the keyboard_interactive module controls focus behavior with variants like `Exclusive` and `On_demand`, and the error module defines failure conditions like `Invalid_size` for client validation. Together, these components enable fine-grained layout and interaction policies for compositor-managed UI layers.",
      "description_length": 776,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module handles locking a pointer to prevent motion events and provides precise control over the pointer's behavior during the lock. It works with Wayland pointer objects and regions to define constraints, allowing clients to set a lock region and specify a cursor position hint. Concrete use cases include implementing pointer lock for applications like games or VR environments where relative motion is needed without cursor movement, and ensuring the pointer returns to a specific position when unlocked.",
      "description_length": 511,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module manages versioned protocol operations for a Wayland layer shell interface, handling request and event serialization while coordinating structured interaction with layer-specific functionality through its submodules. It provides core operations for negotiating protocol versions and processing layer surface configuration requests, using enumerated types for display layers and error codes for invalid operations. The layer submodule defines z-ordering levels like background and overlay with integer conversions for IPC, while the error submodule handles protocol violations such as invalid layer assignments or duplicate object creation. Use cases include enforcing correct layer shell surface behavior in compositors and managing surface stacking order during display configuration.",
      "description_length": 796,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol handling for managing relative pointer motion in Wayland compositing environments. It provides operations to create relative pointer objects and handle motion events with precise delta tracking. Concrete use cases include implementing cursor movement in desktop environments and handling input device deltas for games or graphics applications.",
      "description_length": 390,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to manage server-side window decorations in a Wayland compositor. It allows clients to request decorations by creating and destroying toplevel decoration objects tied to specific windows. The module works with Wayland proxy objects representing decoration managers and toplevel windows, enabling use cases like custom window borders and control elements managed by the compositor.",
      "description_length": 412,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module implements the XDG toplevel surface protocol for Wayland, managing window operations like resizing, state updates, and capability negotiation. It provides the `Xdg_toplevel` type along with core operations to handle surface configuration, user interactions, and protocol versioning, such as setting window titles, handling resize requests via `Resize_edge`, and managing surface relationships. The associated state module tracks window conditions like maximized or fullscreen using integer conversions, while the capability module communicates supported window actions like minimize or fullscreen. Error and edge modules define constants and conversions for validating operations and handling resize interactions, ensuring robust and precise window management across Wayland compositors.",
      "description_length": 799,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations to construct dmabuf-based wl_buffers by collecting per-plane dmabuf parameters. It provides `add` to supply dmabuf file descriptors for each plane index and `create` to finalize buffer creation, supporting both single and multi-planar DRM formats. Concrete use cases include importing hardware-accelerated video frames or GPU textures into Wayland clients using Linux DMA-BUF.",
      "description_length": 407,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_proto.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module handles protocol operations for interacting with DRM in Wayland, including version negotiation, error reporting, and capability exchange. It defines requests and events for GPU authentication, display capability queries, and buffer format management, enabling tasks like initializing DRM-based displays and processing authentication responses. The pixel format module provides a variant type and conversion functions for DRM formats such as RGB and YUV, supporting framebuffer configuration. Error codes and capability flags modules handle protocol-specific error reporting and feature negotiation, such as validating formats or enabling PRIME support during initialization.",
      "description_length": 686,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module provides functions to create and manage dmabuf-based Wayland buffers using the `zwp_linux_dmabuf_v1` interface. It works with DMA buffer file descriptors and supports operations like creating buffer parameter objects, attaching planes, and creating buffers with explicit or immediate import. Concrete use cases include importing hardware-accelerated video frames or GPU-rendered content into a Wayland compositor for display.",
      "description_length": 437,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client.Zwlr_layer_surface_v1",
      "library": "wayland.protocols",
      "description": "This module manages layer surfaces in a Wayland compositor, providing functions to configure their position, size, layer level, margins, and interactivity. It works with `Zwlr_layer_surface_v1` objects, which represent surfaces intended for stacked desktop environments. Concrete use cases include setting a surface's anchor point and exclusive zone to control its placement and input behavior, and adjusting its layer to determine stacking order relative to other surfaces.",
      "description_length": 474,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module implements the protocol for client-side window decorations in a Wayland compositor, enabling negotiation of decoration modes and handling of related errors. It defines core types such as `Mode`, with variants `Client_side` and `Server_side`, used to determine decoration rendering responsibility, and `Error` for signaling invalid states like unconfigured buffers or orphaned resources. Operations include converting modes and errors to and from 32-bit integers, facilitating serialization over the Wayland wire format. These capabilities allow clients to dynamically adjust decoration strategies and handle misconfigurations during window management.",
      "description_length": 663,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_popup",
      "library": "wayland.protocols",
      "description": "This module manages short-lived popup surfaces for UI elements like menus and tooltips. It provides operations to explicitly grab input focus, reposition the popup using a positioner, and destroy the popup to dismiss it. The module works with Wayland surfaces and seats, requiring clients to commit surface state changes for updates to take effect.",
      "description_length": 348,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client.Zxdg_toplevel_decoration_v1",
      "library": "wayland.protocols",
      "description": "This module manages window decoration modes for a toplevel surface in a Wayland compositor. It provides functions to set, unset, and destroy the decoration mode, working with a decoration object and a mode enumeration. Concrete use cases include enabling or disabling server-side decorations dynamically during window management.",
      "description_length": 329,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module provides functions to constrain pointer movement in a Wayland client. It allows locking the pointer to a specific position with `lock_pointer` or confining it to a region with `confine_pointer`, both requiring a surface, pointer, optional region, and lifetime specification. These operations are useful for implementing features like screen locking or restricted input areas in graphical applications.",
      "description_length": 413,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "Manages server-side window decorations by allowing a compositor to advertise support and negotiate decoration with clients. It works with display servers and client windows, enabling clients to request compositor-provided decorations instead of rendering their own. Concrete use cases include integrating custom window borders, title bars, and control buttons managed by the compositor for a consistent desktop environment experience.",
      "description_length": 434,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module provides a `create` function to instantiate server-side decoration objects for Wayland surfaces, specifically for clients that support the KDE KWin server decoration protocol. It works with Wayland proxies representing surfaces and decoration manager interfaces, enabling the server to control whether decorations are rendered for specific windows. Concrete use cases include managing window borders and title bars in a compositor that supports server-side decorations.",
      "description_length": 481,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module provides a function `offer` to advertise MIME types for transferring primary selection contents to a client. It works with the `Zwp_primary_selection_offer_v1.t` type representing a selection offer. Concrete use cases include implementing clipboard data transfer in Wayland compositors, where a client requests the selected data in a specific format.",
      "description_length": 362,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides a way to manage screen capture operations by offering requests to start capturing from a source. It works with Wayland protocol objects to enable screen copying, specifically handling version 1 of the protocol. A concrete use case is allowing a client to initiate screen capture sessions in a compositor environment.",
      "description_length": 337,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and version metadata for the Linux DMABUF protocol, specifying operations to request and event handling for buffer management. It works with Wayland protocol types, particularly `t` and `versions`, to manage buffer imports and synchronization. Concrete use cases include integrating DMA buffer allocation with Wayland compositors for efficient GPU resource sharing.",
      "description_length": 399,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module defines the interface and communication logic for a primary selection source in the GTK Wayland protocol. It specifies the requests and events for handling data transfer operations like sending and offering content, using types such as strings and file descriptors. Concrete use cases include implementing clipboard-like functionality where a client provides data to be shared with other clients.",
      "description_length": 408,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in a Wayland server, enabling clipboard-like data sharing between clients. It provides functions to create selection sources and retrieve per-seat selection devices, supporting operations such as setting and reading selected content. Concrete use cases include implementing copy-paste functionality and handling user selections across different applications.",
      "description_length": 416,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_offer_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to destroy a primary selection offer and receive data transfers by specifying a MIME type and file descriptor. It works with the `Zwp_primary_selection_offer_v1.t` type representing a selection content offer. Concrete use cases include handling user-initiated text or data selection transfers in graphical applications, such as pasting clipboard content directly into a text editor or input field.",
      "description_length": 429,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation and handling of `xdg_output` objects, which provide logical output information for shell surfaces in Wayland compositors. It defines the `zxdg_output_manager_v1` interface, allowing servers to associate outputs with positions and dimensions in a logical coordinate space. Concrete use cases include configuring multi-monitor layouts and tracking output geometry changes in desktop environments.",
      "description_length": 427,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module orchestrates surface positioning in a Wayland compositor by defining core operations and configuration options such as anchor points, gravity, and constraint adjustments. It includes enumerations for positioner versions, error handling for invalid input, and bitflags that dictate adjustment strategies like sliding or flipping when layout constraints are violated. Users can specify surface alignment using cardinal directions and anchor points, with support for dynamic layout adjustments and structured error reporting to clients. Concrete applications include positioning pop-up windows relative to parent surfaces and ensuring UI elements fit within available screen space.",
      "description_length": 690,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client.Zwp_relative_pointer_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages the creation and destruction of relative pointer objects for a given pointer. It provides `get_relative_pointer` to obtain a relative pointer interface for a Wayland pointer and `destroy` to clean up the manager. It is used in Wayland clients to handle relative pointer input events, such as those from mice or touchpads, by associating them with a specific pointer device.",
      "description_length": 393,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and communication logic for handling primary selection devices in the Wayland protocol. It provides functions to encode and decode requests and events, such as setting the selected content or handling new selection events, using the specific data types like `t` and `versions`. It is used to implement clipboard-like functionality where a client can manage the primary selection buffer.",
      "description_length": 420,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module manages the lifecycle and configuration of desktop-style user interface surfaces in a Wayland compositor. It handles assigning roles like toplevel windows or popups to surfaces, enforcing correct state transitions and synchronization between client and compositor. Key operations include setting up role-specific objects, handling initial commits, and responding to configuration events to ensure surfaces are properly mapped and displayed.",
      "description_length": 452,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the screencopy manager protocol for capturing screen content, providing requests to create frame and buffer objects for screen capture. It works with Wayland protocol types, specifically handling screencopy operations through versioned interfaces (V1 to V3). Concrete use cases include implementing screen recording, screenshot capture, and remote desktop streaming by coordinating buffer allocation and frame capture events.",
      "description_length": 445,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol handling for managing primary selection devices in a Wayland compositor. It provides functions to create and manage device instances, handling requests and events specific to primary selection version 1. Concrete use cases include implementing clipboard-like functionality where clients can offer or request selected content.",
      "description_length": 372,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto.Zxdg_output_v1",
      "library": "wayland.protocols",
      "description": "This module defines the unstable XDG output protocol for Wayland, specifically handling output management features such as describing monitor geometry and positioning. It works with Wayland metadata types and protocol versions, supporting requests and events for output configuration. Concrete use cases include retrieving output descriptions, handling monitor layout changes, and integrating with desktop environments for multi-monitor setups.",
      "description_length": 444,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module handles the relative pointer events in the Wayland protocol, specifically capturing motion and axis updates relative to the pointer's previous position. It defines the interface, version, and message structures for encoding and decoding relative pointer events. Concrete use cases include implementing pointer input handling in Wayland compositors or clients that require precise relative movement tracking.",
      "description_length": 419,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module manages the advertisement of MIME types for primary selection data transfer offers. It provides the `offer` function to specify which MIME types are available for transfer. The module works with `wp_primary_selection_offer` objects, enabling clients to negotiate data formats during clipboard operations. A concrete use case is handling text or image data transfer requests in a Wayland compositor.",
      "description_length": 410,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client.Gtk_primary_selection_source",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, allowing the addition of MIME types and destruction of the source. It works with `Gtk_primary_selection_source.t` to handle data transfer requests for the primary selection clipboard. Concrete use cases include offering text or custom data formats for clipboard operations in Wayland clients.",
      "description_length": 358,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `destroy` function to release a relative pointer object that extends `wl_pointer` for handling relative motion events. It works with the `Zwp_relative_pointer_v1.t` type, which tracks pointer focus and emits events only when active. Concrete use cases include implementing precise cursor movement tracking in compositors or applications requiring fine-grained relative input data.",
      "description_length": 403,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto.Zxdg_decoration_manager_v1",
      "library": "wayland.protocols",
      "description": "Manages client-side window decorations for surfaces in a Wayland compositor using the unstable XDG decoration protocol. It provides requests to create decorated surfaces and handle decoration events, working with surface and decoration objects. Concrete use cases include implementing custom window borders and shadows in desktop environments.",
      "description_length": 343,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_positioner",
      "library": "wayland.protocols",
      "description": "This module defines rules for positioning child surfaces relative to parent surfaces, ensuring visibility and adjacency constraints. It supports operations like setting size, anchor rectangles, and positioning constraints such as sliding and flipping. Concrete use cases include aligning pop-up windows, tooltips, or menus within a Wayland compositor's layout.",
      "description_length": 360,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server.Zwp_linux_dmabuf_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to advertise supported buffer formats and modifiers for dmabuf-based buffer creation. It works with Wayland protocol versions 1 through 5, handling format and modifier negotiation between client and compositor. Concrete use cases include enabling clients to determine compatible pixel formats and modifiers for creating dmabuf-backed wl_buffers, ensuring successful buffer import by the compositor.",
      "description_length": 430,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_toplevel",
      "library": "wayland.protocols",
      "description": "This module manages top-level surfaces in a Wayland compositor, enabling operations like setting window states (maximize, fullscreen), configuring size and position, and handling user interactions such as resize and move. It works with `xdg_toplevel` objects across multiple protocol versions, handling events like close requests and configuration changes. Concrete use cases include managing window lifecycle, applying visual properties, and synchronizing client and compositor state during surface mapping and unmapping.",
      "description_length": 522,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client.Zwp_linux_dmabuf_feedback_v1",
      "library": "wayland.protocols",
      "description": "This module handles DMA buffer feedback parameters, including events for preferred devices, supported formats, and modifiers. It works with Wayland protocol objects to communicate buffer allocation preferences and changes. Concrete use cases include optimizing buffer allocation based on device capabilities and format support in graphics compositors.",
      "description_length": 351,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to create and destroy xdg output objects from Wayland outputs. It works with `zxdg_output_manager_v1` and `wl_output` proxies to manage unstable xdg output protocols. Concrete use cases include integrating high-level output management with low-level display servers in Wayland compositors.",
      "description_length": 321,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_source_v1",
      "library": "wayland.protocols",
      "description": "This module manages the source side of a primary selection offer, enabling the cancellation of selection requests and the transmission of selection content via a file descriptor. It operates on the `Zwp_primary_selection_source_v1.t` type, representing a selection source, and interacts with file descriptors and MIME types. Concrete use cases include handling user cancellation of clipboard operations and sending clipboard data in response to client requests.",
      "description_length": 461,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_offer",
      "library": "wayland.protocols",
      "description": "This module defines the interface and behavior for handling primary selection offers in a Wayland compositor. It provides functions to retrieve requests and events associated with the selection offer, including handling file descriptors and string data. It is used to implement clipboard-like functionality for primary selections in graphical applications.",
      "description_length": 356,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module defines operations to handle screen capture frames, including signaling capture failure, readiness with timestamp, buffer details, and damage regions. It works with Wayland protocol objects to send events like `ready`, `flags`, `buffer`, and `damage` to clients. Concrete use cases include notifying a client when a screen capture buffer is ready for reading or indicating regions of the screen that have changed.",
      "description_length": 425,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module implements the server-side protocol for managing desktop-style windows in a Wayland compositor. It provides operations to create and manage window surfaces with capabilities like dragging, resizing, and maximizing, along with handling transient windows such as popups. The primary data structure is the `Xdg_wm_base` object, used to interface with client window management requests.",
      "description_length": 394,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto.Zxdg_output_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the interface and protocol details for managing output devices in the XDG Output extension, specifically handling versions 1 through 3. It includes operations to create new output objects and manage their lifecycle through requests and events. Concrete use cases include configuring monitor layouts and handling display changes in a Wayland compositor.",
      "description_length": 372,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_surface",
      "library": "wayland.protocols",
      "description": "This module implements the Xdg surface interface for Wayland compositing, enabling configuration and management of top-level surfaces with support for versioned protocols. It defines core types like `t` for surface handles and `versions` for protocol version tracking, along with operations to handle events and requests tied to desktop shell interactions. The child module enhances error handling by exposing specific failure codes such as `Not_constructed` and `Invalid_size`, which are essential for robust surface configuration. Together, they allow developers to create and manage window-like surfaces with precise control over features like maximization, fullscreen, and geometry updates.",
      "description_length": 694,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto.Gtk_primary_selection_device",
      "library": "wayland.protocols",
      "description": "This module defines the interface and message handling for a primary selection device in the GTK Wayland protocol. It specifies the requests and events exchanged between client and server, including data types like objects and unsigned integers. Concrete use cases include implementing clipboard-like functionality for primary selections in graphical applications.",
      "description_length": 364,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module manages screen capture frames by allowing clients to copy frame contents into Wayland buffers. It supports operations to destroy frames, copy frames with or without damage tracking, and handles buffer enumeration and event signaling. Concrete use cases include capturing screen content for remote desktop applications or video streaming clients.",
      "description_length": 357,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration",
      "library": "wayland.protocols",
      "description": "This module implements the server-side Wayland protocol for managing window decorations in KDE KWin, handling versioning, message structures, and negotiation of decoration modes between server and client. It defines the main interface for sending and receiving decoration-related events and requests, including setting and responding to decoration mode changes. The included enumerated type represents possible decoration modes\u2014`None`, `Client`, and `Server`\u2014and supports conversion to and from 32-bit integers for protocol serialization. Developers can use this module to implement a compositor that dynamically selects decoration strategies or to build clients that respond to server-driven decoration changes.",
      "description_length": 712,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client.Zwlr_layer_shell_v1",
      "library": "wayland.protocols",
      "description": "This module creates and manages layer surfaces for desktop compositing, allowing clients to assign `wl_surface` objects to specific layers with defined rendering order, anchoring, and input behavior. It operates on `Zwlr_layer_shell_v1` and interacts with `wl_surface`, `wl_output`, and layer enums to configure visual stacking and screen positioning. Concrete use cases include implementing desktop shells, docks, panels, and overlay applications that require precise control over surface layering and display placement.",
      "description_length": 521,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_pointer_constraints_v1",
      "library": "wayland.protocols",
      "description": "This module provides operations to constrain pointer movement by locking or confining it to a specific region. It works with Wayland surfaces and pointer objects associated with a seat, enforcing mutual exclusivity for active constraints. Concrete use cases include implementing screen locking or restricting pointer movement within a defined area of a display.",
      "description_length": 361,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server.Zwp_relative_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module provides a `relative_motion` function to emit relative pointer events with precise motion deltas and timestamps. It works with Wayland's `wl_pointer` interface and handles input events tied to seat focus. Concrete use cases include implementing cursor movement in compositors that require unaccelerated pointer input, such as games or drawing applications.",
      "description_length": 368,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources in a Wayland client. It provides functions to create and retrieve primary selection devices per seat, and to create primary selection sources. It works with Wayland proxy objects for seats and selection devices/sources, enabling clipboard-like data sharing between applications.",
      "description_length": 336,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_server.Wl_drm",
      "library": "wayland.protocols",
      "description": "This module handles Wayland DRM protocol events for version 1 and version 2, providing functions to manage authentication, device information, pixel formats, and capabilities. It works with the `Wl_drm.t` type, which represents a DRM interface instance, and operates on data such as device names, pixel formats, and capability flags. Concrete use cases include responding to client authentication requests, advertising supported formats, and sending device paths to clients for direct rendering setup.",
      "description_length": 501,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module manages server-side window decorations for KDE KWin in Wayland compositors, handling protocol operations for decoration mode negotiation and application. It works with Wayland types like `new_id` and `object` to manage decoration states across clients, using an enumerated mode type (`None`, `Client`, `Server`) converted to and from 32-bit integers for protocol communication. You can use it to set a surface's decoration mode, respond to client decoration requests, or query the current decoration state of a window. Submodule enums directly support these operations by encoding and decoding mode values during protocol exchanges.",
      "description_length": 644,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server.Zwp_locked_pointer_v1",
      "library": "wayland.protocols",
      "description": "This module handles pointer lock state management by suppressing standard pointer motion events and providing `locked` and `unlocked` events to signal activation or deactivation of the lock. It works with `Zwp_locked_pointer_v1.t` objects tied to a Wayland seat's pointer, ensuring focus and position constraints during lock. Concrete use cases include implementing pointer lock features in compositors where precise control over pointer input is required, such as in VR environments or fullscreen applications.",
      "description_length": 511,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server.Org_kde_kwin_server_decoration_manager",
      "library": "wayland.protocols",
      "description": "This module manages server-side window decorations for Wayland surfaces, providing a `default_mode` function to set the decoration mode. It works with `wl_surface` objects representing shell surfaces, coordinating whether the server should apply decorations. Concrete use cases include enabling or disabling server-side borders and shadows for client windows.",
      "description_length": 359,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module manages desktop-style window creation and interaction. It provides functions to create and manage shell surfaces from Wayland surfaces, handle window positioning, and respond to ping events for protocol version compatibility. Concrete use cases include building draggable, resizable windows and transient popups like menus in a desktop environment.",
      "description_length": 360,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto.Zwp_linux_buffer_params_v1",
      "library": "wayland.protocols",
      "description": "This module manages buffer parameter configuration for DMA-BUF-based Linux surfaces, handling operations like adding file descriptors, setting layout flags, and creating buffers compatible with Wayland protocols. It works with `int32`-based flags for pixel layout and buffer handling, and includes validation logic to check plane indices, format validity, and dimension constraints. You can use it to configure hardware-accelerated buffer imports, manage display compositing attributes, and handle protocol-specific buffer creation across different versions. Error reporting integrates directly with parameter setup, enabling precise diagnostics for invalid configurations during buffer initialization.",
      "description_length": 702,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server.Gtk_primary_selection_device_manager",
      "library": "wayland.protocols",
      "description": "This module manages primary selection devices and sources for X11-style clipboard emulation in Wayland compositors. It provides functions to create primary selection sources and retrieve per-seat selection devices, enabling applications to handle text and data selection across multiple seats. Concrete use cases include implementing clipboard support in text editors and handling drag-and-drop operations within a compositor.",
      "description_length": 426,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto.Xdg_wm_base",
      "library": "wayland.protocols",
      "description": "This module establishes the core interface and versioning for the XDG WM base protocol, handling requests and events with structured type encodings over Wayland metadata. It supports protocol version negotiation, surface creation requests, and global event handling like ping responses. The error submodule defines and encodes specific failure conditions such as invalid surface roles or defunct surfaces, converting them to 32-bit integers for transmission. Together, they enable precise control and communication in a Wayland compositor, ensuring robust window management operations.",
      "description_length": 585,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto.Zwlr_screencopy_frame_v1",
      "library": "wayland.protocols",
      "description": "This module manages screen capture operations in the Wayland protocol, coordinating frame events, buffer attachments, and damage tracking for applications like remote desktops and screen recorders. It uses numeric types and Wayland objects to initiate frame captures and track changes, while its child modules define bit flags for buffer transformations\u2014such as vertical flipping\u2014and error codes for handling invalid or reused buffers. The API supports direct control over screen content copying, with utilities for interpreting buffer metadata and handling failure conditions during capture requests. Specific operations include attaching buffers, inverting pixel data, and handling errors like invalid buffer states during frame capture.",
      "description_length": 739,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto.Zwp_primary_selection_device_manager_v1",
      "library": "wayland.protocols",
      "description": "This module defines the protocol interface for managing primary selection devices in Wayland. It specifies the requests and events for creating and handling selection device objects, targeting version 1 of the protocol. Concrete use cases include implementing clipboard functionality and handling user-initiated text selection across applications.",
      "description_length": 347,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server.Zwp_primary_selection_device_v1",
      "library": "wayland.protocols",
      "description": "This module manages primary selection data in a Wayland server, providing `selection` to advertise a new selection and `data_offer` to create and manage selection offers. It operates on `Zwp_primary_selection_device_v1` instances and proxy handlers for `Zwp_primary_selection_offer_v1`. Concrete use cases include handling clipboard-like data transfers and managing data offers during user selection in graphical applications.",
      "description_length": 426,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables the creation and management of dmabuf-based Wayland buffers for efficient GPU and hardware-accelerated rendering. It supports importing memory buffers by collecting file descriptors, specifying pixel formats and dimensions, and handling buffer feedback for format and device preferences. Key operations include attaching buffer planes, creating buffer objects with explicit parameters, and managing format support feedback. Examples include importing GPU-rendered frames or video buffers for display in a Wayland compositor and optimizing buffer allocation based on device capabilities.",
      "description_length": 606,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module handles relative pointer input in Wayland clients by associating pointer devices with relative motion tracking. It provides `get_relative_pointer` to obtain a relative pointer interface for a `wl_pointer`, and `destroy` to clean up both the relative pointer and its parent manager. The core type `Zwp_relative_pointer_v1.t` emits relative motion events only when active, enabling precise cursor control. Example uses include implementing smooth scrolling or accurate drag operations in graphical applications.",
      "description_length": 521,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_server",
      "library": "wayland.protocols",
      "description": "This module orchestrates the management of desktop and transient user interface elements in a Wayland compositor, handling surface roles, lifecycle events, and layout constraints. It centers around `xdg_toplevel`, `xdg_popup`, and `Xdg_wm_base` objects, offering operations for window state transitions, popup configuration, and constrained positioning. Developers can use it to display and manage windows, menus, and tooltips, ensuring correct placement, visibility, and interaction with the compositor. Specific tasks include aligning popups relative to parent surfaces, handling window resizing, and responding to user-initiated events like close or maximize.",
      "description_length": 662,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland screencopy protocol for capturing and managing screen content, enabling applications like screen recorders and remote desktops to copy frame data into buffers. It provides types for frame and buffer objects, operations for attaching buffers to outputs, tracking damage regions, and handling errors such as invalid buffer reuse. Specific functionality includes flipping pixel data vertically, interpreting buffer metadata, and initiating frame capture requests with version-specific interfaces. Example uses include capturing screenshots, streaming desktop content, and implementing custom screen recording pipelines.",
      "description_length": 651,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables precise control over pointer behavior in a Wayland client by allowing the pointer to be locked to a specific position or confined to a defined region. The main data types include surfaces, pointers, and regions, with key operations such as `lock_pointer`, `confine_pointer`, and region updates that dictate how the pointer interacts with the display. It supports use cases like restricting pointer movement to a window during drag-and-drop, implementing screen locking, or enabling relative motion in games by locking the pointer to a central position. Events signal when confinement or locking starts or ends, allowing the client to respond to changes in pointer state.",
      "description_length": 690,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables precise control over layer surfaces in a Wayland compositor, allowing clients to create and manage layered desktop elements such as panels, docks, and overlays. It provides operations to assign surfaces to specific layers, set anchoring and positioning constraints, and define input behavior through `Zwlr_layer_shell_v1` and `Zwlr_layer_surface_v1` objects. Key data types include `wl_surface`, `wl_output`, and layer enums, with functions to configure size, margins, exclusivity, and stacking order. For example, a client can anchor a panel to the top of a specific output, assign it a high layer to remain visible, and set input pass-through to allow interaction with underlying surfaces.",
      "description_length": 711,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements Wayland pointer constraints for controlling pointer input behavior through confinement and locking mechanisms. It defines core types like `t` and `versions` to manage protocol interactions, supporting operations to restrict pointer movement within regions or lock the pointer to a specific device. The module handles constraint lifetime semantics and errors, enabling use cases such as pointer barriers and exclusive pointer capture in graphical applications.",
      "description_length": 482,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module manages logical output regions and their configuration in a Wayland compositor, enabling the definition and update of output properties such as size, position, name, and description. It centers around two main types: `Zxdg_output_v1.t` for individual output regions and `zxdg_output_manager_v1` for managing their creation and association within a logical coordinate space. Operations include setting output geometry and sending update events like `done_` to notify clients. Example uses include configuring multi-monitor setups and dynamically adjusting display layouts in desktop environments.",
      "description_length": 607,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_client",
      "library": "wayland.protocols",
      "description": "This module enables handling of primary selection clipboard operations in Wayland clients, supporting both source and device management. It provides data types such as primary selection sources, devices, and offers, with operations to set, clear, and transfer selection data using MIME types and file descriptors. Specific functionality includes offering custom data formats, handling user-initiated selections, and coordinating copy-paste operations between applications. Examples include receiving pasted text from external sources and managing clipboard state during user interactions.",
      "description_length": 588,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_proto",
      "library": "wayland.protocols",
      "description": "This module implements primary selection functionality in the GTK Wayland protocol, enabling clipboard-like data exchange between clients through source, device, and offer interfaces. It supports operations for offering and retrieving selection content using data types such as strings, file descriptors, and objects, with version-specific protocol handling. Specific use cases include transferring text or files via primary selection in graphical applications, and managing selection devices and offers on the compositor side. Key operations include sending data offers, handling selection requests, and managing device instances for version 1 of the protocol.",
      "description_length": 661,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables clients to manage server-side window decorations in a Wayland compositor by creating and destroying decoration objects tied to windows, and by setting and unsetting decoration modes dynamically. It operates on proxy objects representing decoration managers, toplevel windows, and decoration modes, allowing fine-grained control over visual elements like borders and control widgets. Specific operations include requesting custom decorations for a window and switching between decorated and borderless states at runtime. For example, a client can enable server-side decorations on window creation and disable them when entering fullscreen mode.",
      "description_length": 663,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Drm_proto",
      "library": "wayland.protocols",
      "description": "This module provides protocol-level support for DRM in Wayland, enabling version negotiation, error handling, and capability exchange. It includes data types for pixel formats (like RGB and YUV), error codes, and capability flags, along with operations for GPU authentication, display capability queries, and buffer format configuration. You can use it to initialize DRM-based displays, validate supported formats, and manage authentication responses during session setup.",
      "description_length": 472,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module manages logical output regions for Wayland compositors, aligning display monitors with xdg output protocols. It supports creating and destroying xdg output objects using `zxdg_output_manager_v1` and `wl_output`, enabling atomic property updates with version 3. Main data types include xdg output handles and Wayland proxies, with operations like `destroy` and property synchronization. Example usage includes tracking monitor configurations and relaying display changes in a compositor.",
      "description_length": 498,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_proto",
      "library": "wayland.protocols",
      "description": "This module implements the server-side Wayland protocol for managing window decorations in KDE KWin, enabling negotiation and application of decoration modes between server and client. It defines an enumeration for decoration modes\u2014`None`, `Client`, and `Server`\u2014with support for conversion to and from 32-bit integers for protocol serialization. Developers can use it to set or query a surface's decoration state, respond to client requests, or dynamically select decoration strategies in a compositor. Key operations include sending and receiving decoration-related events, managing mode changes, and handling protocol versioning and state negotiation.",
      "description_length": 654,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables Wayland compositors to manage window decorations by negotiating server-side decoration support with clients and dynamically updating decoration modes. It centers around the `Zxdg_toplevel_decoration_v1` type and `Mode` values, allowing compositors to enable or disable server-side decorations. Operations include sending `configure` events to clients and handling decoration state changes. For example, a compositor can apply custom borders or title bars system-wide or switch between client and server decorations based on user preferences.",
      "description_length": 561,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_proto",
      "library": "wayland.protocols",
      "description": "This module implements the Wayland XDG shell protocol suite, enabling structured window and popup management in desktop environments. It defines core data types such as `Xdg_toplevel`, `Xdg_popup`, and `Xdg_surface`, along with operations for surface configuration, positioning, resizing, and state updates across multiple protocol versions. Key capabilities include setting window titles, handling resize edges, positioning popups relative to parent surfaces, and negotiating supported capabilities like fullscreen or minimize. The module ensures robust communication through detailed error handling, including invalid grab detection, version mismatches, and constraint violations, with concrete use cases in window managers and compositors requiring precise layout and interaction control.",
      "description_length": 791,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module manages relative pointer motion in Wayland environments, enabling precise tracking of pointer deltas through dedicated event handling. It defines interfaces and message structures for encoding and decoding relative motion and axis updates, supporting versioned protocol interactions. Key operations include creating relative pointer objects and processing motion events, allowing applications like desktop environments or games to accurately handle cursor movement and input device deltas. Example uses include implementing smooth pointer input in compositors or capturing fine-grained movement data for interactive applications.",
      "description_length": 641,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_client",
      "library": "wayland.protocols",
      "description": "This module enables direct rendering management for Wayland clients by handling GPU memory allocation and buffer authentication. It supports creating planar and PRIME DRM buffers, working with display parameters such as width, height, and pixel format. Key operations include buffer creation, file descriptor management, and interfacing with DRM protocol objects. Example use cases include setting up rendering surfaces for graphics applications and managing display output with custom pixel formats.",
      "description_length": 500,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Drm_server",
      "library": "wayland.protocols",
      "description": "This module implements Wayland DRM protocol versions 1 and 2, managing authentication, device information, pixel formats, and capabilities through the `Wl_drm.t` interface. It enables responding to client authentication, advertising supported pixel formats, and transmitting device paths for direct rendering. Operations include handling protocol events, querying DRM capabilities, and exchanging format and device metadata with clients. Example uses include initializing DRM authentication flows and configuring rendering pipelines based on advertised capabilities.",
      "description_length": 566,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the unstable v1 protocol for Wayland layer shells, enabling compositors to manage layered UI surfaces with precise control over layout, stacking, and input. It defines core types such as `t` for surface state, `versions` for protocol negotiation, and enumerated layer values for z-ordering, alongside operations to configure surface anchoring, set keyboard interaction modes, and handle errors like invalid sizes or duplicate surfaces. Submodules structure functionality for screen edge docking, focus policies (`Exclusive`, `On_demand`), and protocol error handling, supporting use cases such as panel placement, popup management, and layer-specific display configuration.",
      "description_length": 696,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables primary selection functionality in Wayland clients, allowing applications to manage selection devices, sources, and data transfers. It supports creating and handling primary selection sources with MIME type negotiation, setting selection with a serial number, and receiving data via file descriptors. Key data types include `Zwp_primary_selection_source_v1.t` and `Zwp_primary_selection_offer_v1.t`, with operations tied to Wayland proxies for seats and devices. Examples include implementing copy-paste of text or files in graphical applications using primary selection offers and device management.",
      "description_length": 620,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Pointer_constraints_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enforces spatial and state-based restrictions on pointer movement within a Wayland compositor by confining or locking the pointer to specific regions or surfaces. It provides data types representing constrained and locked pointer states, along with operations to activate, deactivate, and monitor these constraints. Functions allow clients to define confinement regions, suppress standard motion events during lock, and receive notifications when the pointer is locked or unlocked. Examples include restricting pointer movement during drag operations, implementing screen locking, or enabling precise input control in VR or fullscreen applications.",
      "description_length": 660,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables clipboard-like data sharing in a Wayland server by managing primary selection offers, sources, and devices. It supports advertising MIME types, creating and canceling selection sources, and transferring data via file descriptors. Main data types include `Zwp_primary_selection_offer_v1.t` and `Zwp_primary_selection_source_v1.t`, with operations for setting, retrieving, and responding to selection requests. Examples include implementing copy-paste between applications and handling user-initiated data transfers in graphical interfaces.",
      "description_length": 558,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_client",
      "library": "wayland.protocols",
      "description": "This module enables server-side control of window decorations for Wayland surfaces in KDE KWin compositors. It supports creating decoration objects with `create`, setting decoration modes with `request_mode`, and releasing resources with `release`, all operating on Wayland surfaces and decoration manager interfaces. These operations allow the server to manage visual elements like borders and title bars for individual windows. For example, a compositor can use these functions to dynamically enable or disable decorations based on window properties or user preferences.",
      "description_length": 572,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_layer_shell_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module manages layered surfaces in a Wayland compositor, enabling clients to create and control surfaces with specific z-order, anchoring, and input properties. It operates on `Zwlr_layer_surface_v1.t` and `wl_surface` objects, supporting state changes like size, visibility, and buffer detachment. Key functionality includes mapping and unmapping surfaces for display, and setting layer attributes to control rendering order. Examples include implementing panels, docks, and popups that must appear above or below other desktop elements.",
      "description_length": 543,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Server_decoration_server",
      "library": "wayland.protocols",
      "description": "This module configures server-side window decorations for Wayland surfaces, determining how visual elements like borders and shadows are applied. It supports the `v1` protocol and provides functions `mode` and `default_mode` to set decoration behavior globally or per-surface. The `mode` function controls decoration rendering for specific surfaces, while `default_mode` sets the fallback policy for shell surfaces. For example, it can disable server-side borders for a specific window or enforce a consistent shadow policy across all client surfaces.",
      "description_length": 551,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Relative_pointer_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables handling relative pointer input by binding interfaces to pointer devices and emitting precise motion events. It centers around the `wl_pointer` interface, using functions like `relative_motion` to send unaccelerated pointer deltas with timestamps. Developers can implement low-level pointer control for applications like games or drawing tools, where accurate and direct input tracking is essential. Example usage includes updating cursor position based on raw pointer movement or capturing fine-grained gestures.",
      "description_length": 533,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_decoration_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module enables client-side window decorations in a Wayland compositor by defining decoration modes and error handling for dynamic window management. It introduces key types like `Mode` (`Client_side`, `Server_side`) and `Error`, along with operations to serialize these values for protocol communication. It supports creating decorated surfaces and handling events, allowing clients to implement custom borders, shadows, and negotiate decoration responsibilities with the server. Example use cases include desktop environments adjusting window appearance based on user preferences or compositor capabilities.",
      "description_length": 613,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables efficient DMA buffer management in Wayland compositors by coordinating buffer feedback, format negotiation, and buffer creation. It centers around Wayland protocol objects that communicate device preferences, supported formats, and modifier flags through structured events and requests. Key operations include advertising optimal buffer configurations, importing dmabuf file descriptors per plane, and finalizing buffer creation for single or multi-planar formats. For example, a compositor can signal preferred pixel formats and devices to clients, or a client can construct a GPU-backed buffer using imported dmabuf file descriptors.",
      "description_length": 655,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_client",
      "library": "wayland.protocols",
      "description": "This module enables screen capture by managing frame operations and output handling through Wayland proxies. It provides data types for outputs, frame handlers, and buffers, with operations to capture entire outputs or specific regions, copy frame contents, track damage, and handle events. You can use it to take screenshots, stream screen content, or implement remote desktop functionality. For example, a client can capture a display region with cursor overlay enabled, copy the frame into a buffer, and send it over a network for real-time sharing.",
      "description_length": 552,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland_protocols.Wlr_screencopy_unstable_v1_server",
      "library": "wayland.protocols",
      "description": "This module enables screen capture management by initiating capture sessions and handling frame updates through Wayland protocol events. It provides types for capture sources, frames, and buffers, along with operations to start capture, report readiness with timestamps, and signal damage regions or failures. You can use it to notify clients when a frame is ready for reading, specify updated screen regions, or handle capture errors during screen copying operations.",
      "description_length": 468,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_shell_client",
      "library": "wayland.protocols",
      "description": "This module orchestrates the creation and management of desktop-style UI surfaces in a Wayland client, handling window roles, positioning, state changes, and short-lived popups. It provides core data types like `xdg_toplevel`, `xdg_popup`, and positioner objects, with operations to set window geometry, manage state (maximize, move, resize), and position UI elements relative to parents while respecting screen boundaries. You can create draggable and resizable application windows, display context menus that reposition dynamically, and manage popup surfaces with input grabs for tooltips or menus. Specific examples include implementing a window with a title bar and resize handles, or a tooltip that follows the cursor and stays within view.",
      "description_length": 745,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Linux_dmabuf_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module provides a comprehensive interface for managing DMA-BUF buffers in Wayland compositing environments, enabling efficient GPU memory sharing and buffer allocation feedback. It defines core data types such as buffer tranches, device identifiers, memory formats, and versioned protocol interfaces, along with operations for buffer configuration, layout specification, and synchronization. Key functionalities include querying device capabilities, signaling buffer usage constraints, importing DMA buffers with hardware acceleration, and handling protocol-specific buffer creation with validation. Specific examples include configuring pixel layout flags for display compositing, managing memory format compatibility across protocol versions, and signaling scanout support via buffer feedback messages.",
      "description_length": 809,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Gtk_primary_selection_server",
      "library": "wayland.protocols",
      "description": "This module enables servers to manage primary selection clipboard functionality by handling data offers, MIME type negotiation, and device management across Wayland and X11-style selections. It provides data types such as `selection`, `data_offer`, and `wp_primary_selection_offer`, along with operations to advertise MIME types, transfer data via file descriptors, and manage per-seat selection devices. You can use it to implement clipboard support in graphical applications, handle text or image transfers between clients, and enable drag-and-drop operations within a compositor.",
      "description_length": 582,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Wp_primary_selection_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements Wayland primary selection functionality for clipboard-like data transfer between applications. It provides interfaces to manage selection sources, process protocol requests and events, and handle device interactions using types like `t` and `versions`. Operations include sending and receiving text data via file descriptors, negotiating protocol versions, and encoding selection events. Example uses include implementing copy-paste for text content and synchronizing user-initiated selections across Wayland clients.",
      "description_length": 540,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols.Xdg_output_unstable_v1_proto",
      "library": "wayland.protocols",
      "description": "This module implements the XDG Output extension for Wayland, providing protocols to manage and describe output devices such as monitors. It supports operations for creating and configuring output objects, retrieving geometry and positioning data, and handling dynamic display changes across multiple monitors. Key data types include output descriptions, protocol versions, and event handlers for layout updates. Example uses include synchronizing multi-monitor setups and adapting to resolution or orientation changes in a desktop environment.",
      "description_length": 543,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland_protocols",
      "library": "wayland.protocols",
      "description": "This module provides a comprehensive suite of tools for managing Wayland-based graphical interfaces, enabling efficient buffer handling, input control, and UI composition. It supports key operations such as creating and managing dmabuf-based rendering buffers, handling pointer input with relative motion and constraints, and orchestrating desktop elements like windows, popups, and layer surfaces with precise layout and interaction controls. Developers can use these capabilities to build compositors or clients that support advanced features like screen capture, server-side decorations, multi-monitor configuration, and clipboard-like primary selection data transfer. Example workflows include rendering GPU-accelerated content to display surfaces, implementing smooth scrolling or drag operations, and managing layered UI components such as panels and tooltips with custom input behavior.",
      "description_length": 893,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_source.Error",
      "library": "wayland",
      "description": "This module defines error codes for invalid operations on data sources, specifically `Invalid_action_mask` and `Invalid_source`. It provides conversions to and from 32-bit integers for use in protocol communication. These errors are used to indicate incorrect drag-and-drop action masks or invalid data source handles in Wayland client-server interactions.",
      "description_length": 356,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device.Error",
      "library": "wayland",
      "description": "This module defines error codes for the data device interface, including `Role` and `Used_source`. It provides conversions between these error codes and `int32` values. These are used to report specific error conditions during data transfer operations in Wayland clients and compositors.",
      "description_length": 287,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm.Format",
      "library": "wayland",
      "description": "This module defines pixel format constants and conversions for shared memory buffers in a Wayland compositor. It supports operations to convert between pixel format variants and their 32-bit integer representations. Use cases include specifying buffer layouts for rendering and handling pixel format negotiation between clients and the compositor.",
      "description_length": 347,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat.Error",
      "library": "wayland",
      "description": "This module defines error values specific to `wl_seat` requests in the Wayland protocol, providing a type-safe enumeration of errors such as `Missing_capability`. It supports conversion between error values and `int32` representations for use in low-level communication. Concrete use cases include handling and dispatching protocol-level errors during input device management and seat capability checks.",
      "description_length": 403,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_display.Error",
      "library": "wayland",
      "description": "This module defines globally recognized error codes for Wayland display operations, including invalid object, invalid method, out-of-memory, and implementation errors. It provides conversions between error values and 32-bit integers for serialization and interoperation with C-based Wayland protocols. These errors are used to report failures in server requests across Wayland clients and compositors.",
      "description_length": 401,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard.Keymap_format",
      "library": "wayland",
      "description": "Represents the format of keyboard mappings in the Wayland protocol, specifically handling keymap formats like `No_keymap` and `Xkb_v1`. Converts between keymap format values and 32-bit integers for serialization and deserialization during client communication. Used when processing `wl_keyboard.keymap` events to interpret keyboard layouts correctly.",
      "description_length": 350,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat.Capability",
      "library": "wayland",
      "description": "This module defines a bitmask type `t` representing the capabilities of a Wayland seat, such as pointer, keyboard, and touch support. It provides constants for individual capabilities and functions to convert between the bitmask and `int32` values. It is used to determine which input device types are available on a given seat in Wayland compositors.",
      "description_length": 351,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis_source",
      "library": "wayland",
      "description": "This module defines enumerated values representing the physical sources of axis input events, such as `Wheel`, `Finger`, `Continuous`, and `Wheel_tilt`. It provides conversions between these source types and 32-bit integers using `to_int32` and `of_int32`. These types are used to interpret scroll or axis motion events from input devices in a Wayland client, allowing appropriate UI responses based on the input source.",
      "description_length": 420,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis_relative_direction",
      "library": "wayland",
      "description": "This module defines two values, `Identical` and `Inverted`, representing the direction of motion relative to a pointer axis event. It provides conversion functions `to_int32` and `of_int32` to map between these values and 32-bit integers. This is used to interpret or generate axis motion events in Wayland pointer input handling.",
      "description_length": 330,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm.Error",
      "library": "wayland",
      "description": "This module defines error codes for the Wl_shm interface, including `Invalid_format`, `Invalid_stride`, and `Invalid_fd`. It provides conversions between these error values and 32-bit integers using `to_int32` and `of_int32`. These errors are used to report invalid buffer parameters in shared memory operations during Wayland protocol interactions.",
      "description_length": 349,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Resize",
      "library": "wayland",
      "description": "This module defines integer constants representing edges of a surface for resize operations, such as `top`, `bottom`, and `top_right`. It provides direct mappings to int32 values for use in window management interactions, specifically to indicate which edge is being resized. These values are used by clients and servers to coordinate resizing behavior, such as setting the correct cursor during a drag operation.",
      "description_length": 413,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subsurface.Error",
      "library": "wayland",
      "description": "This module defines error codes specific to the `Wl_subsurface` protocol, including the `Bad_surface` error. It provides conversions between these error codes and `int32` values for use in protocol communication. These operations are used to handle invalid surface errors during subsurface management in Wayland clients or compositors.",
      "description_length": 335,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Transform",
      "library": "wayland",
      "description": "This module defines transformations applied to surfaces to match output device orientation, including rotations and flips. It operates on a custom type `t` representing eight possible transform states. Functions convert between these transforms and `int32` values, enabling clients to correctly render content for compositor display.",
      "description_length": 333,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Fullscreen_method",
      "library": "wayland",
      "description": "This module defines an enumerated type representing different methods for setting a surface to fullscreen in the Wayland protocol. It includes values like `Default`, `Scale`, `Driver`, and `Fill` to specify how a surface should adjust when conflicting with output dimensions. The module provides conversion functions `to_int32` and `of_int32` to map between these methods and their integer representations for use in low-level communication.",
      "description_length": 441,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Subpixel",
      "library": "wayland",
      "description": "This module defines an enumeration representing subpixel geometry layouts of display outputs, including horizontal and vertical arrangements with RGB or BGR ordering. It provides conversion functions to and from 32-bit integers for interoperability with low-level display protocols. Concrete use cases include configuring display rendering pipelines and handling pixel layout information in Wayland output management.",
      "description_length": 417,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Button_state",
      "library": "wayland",
      "description": "Represents the physical state of a button in a Wayland pointer event, with values for pressed and released states. It provides conversions to and from 32-bit integers for serialization or protocol handling. Used when processing input events where exact button transitions need to be tracked or transmitted.",
      "description_length": 306,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_offer.Error",
      "library": "wayland",
      "description": "This module defines error codes for invalid operations on data offers in the Wayland protocol. It includes specific errors like `Invalid_finish`, `Invalid_action_mask`, `Invalid_action`, and `Invalid_offer`, each representing distinct failure scenarios during data transfer handling. These errors are used to report protocol violations or incorrect usage of data offer objects in Wayland clients or compositors.",
      "description_length": 411,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Error",
      "library": "wayland",
      "description": "This module defines error codes specific to pointer operations in the Wayland protocol. It provides conversions between error values and 32-bit integers for efficient transmission and handling. Use this module to interpret or generate error responses related to pointer device interactions in Wayland compositors.",
      "description_length": 313,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subcompositor.Error",
      "library": "wayland",
      "description": "This module defines error codes for the subcompositor protocol, specifically `Bad_surface` and `Bad_parent`. It provides conversions between these error values and 32-bit integers using `to_int32` and `of_int32`. These functions are used to handle and communicate protocol-level errors during subcompositor operations.",
      "description_length": 318,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device_manager.Dnd_action",
      "library": "wayland",
      "description": "This module defines a bitmask type representing drag-and-drop actions available during Wayland drag-and-drop operations. It includes specific values for `none`, `copy`, `move`, and `ask`, allowing compositors and clients to negotiate the action taken based on user input and modifier keys. The module works directly with `int32` values to represent these actions, enabling bitwise operations for combining and selecting actions.",
      "description_length": 428,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer.Axis",
      "library": "wayland",
      "description": "This module defines the axis types for scroll events, specifically vertical and horizontal scroll directions. It provides conversion functions to and from 32-bit integers, enabling precise handling of scroll input in Wayland clients. Concrete use cases include processing mouse wheel events and mapping them to the appropriate scroll direction in a user interface.",
      "description_length": 364,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface.Transient",
      "library": "wayland",
      "description": "This module defines transient surface behavior flags for use in the `set_transient` request. It provides an integer type `t` and constants like `inactive` to specify transient surface states. These values are used directly when configuring surface relationships in Wayland compositors.",
      "description_length": 285,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_surface.Error",
      "library": "wayland",
      "description": "This module defines error codes returned by `wl_surface` operations, including invalid scale, transform, size, offset, and defunct role object errors. It provides conversions to and from 32-bit integers for use in protocol communication. These values are used to handle and propagate specific error conditions during surface configuration and rendering in Wayland clients.",
      "description_length": 372,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output.Mode",
      "library": "wayland",
      "description": "This module defines bitflags for output mode properties, used to describe display modes in Wayland. It provides constants `current` and `preferred` to indicate active and preferred display modes, along with conversion functions `to_int32` and `of_int32`. These flags are used in the mode event to communicate display configuration details to clients.",
      "description_length": 350,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell.Error",
      "library": "wayland",
      "description": "This module defines error codes for the `Wl_shell` protocol, providing conversions between error values and 32-bit integers. It works with the `t` type representing shell-specific error conditions. Concrete use cases include handling invalid surface roles or protocol violations during window management operations.",
      "description_length": 315,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard.Key_state",
      "library": "wayland",
      "description": "This module defines an enumerated type representing the physical state of a keyboard key, with values for released and pressed states. It includes functions to convert between the key state and a 32-bit integer representation. This is used to interpret or generate key events in Wayland protocol bindings, where key state must be serialized or deserialized as part of input handling.",
      "description_length": 383,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_subsurface",
      "library": "wayland",
      "description": "This module manages sub-surface behavior for Wayland client surfaces, providing direct control over positioning, stacking, and synchronization modes. It operates on `Wl_subsurface` objects and interacts with `Wl_surface` proxies to define relationships between parent and child surfaces. Concrete use cases include layering UI components like popups or tooltips independently of their parent's size, synchronizing state updates with parent surfaces, and dynamically reordering surface stacks in a window manager.",
      "description_length": 512,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_registry",
      "library": "wayland",
      "description": "This module provides a singleton registry object that tracks global objects available on the Wayland server, emitting events when globals are added or removed. It allows clients to bind to these global objects, creating client-side handles to interact with server objects such as input devices or extension interfaces. The bind function takes a registry, global name, and service handler to establish a connection to a specific type of global object.",
      "description_length": 450,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_seat",
      "library": "wayland",
      "description": "This module manages input device groups, providing functions to retrieve touch, keyboard, and pointer objects associated with a seat. It works with versioned seat proxies and handler interfaces to interact with input devices in a client context. Concrete use cases include handling user input events such as touch gestures, keyboard presses, and pointer movements within a Wayland client application.",
      "description_length": 400,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_source",
      "library": "wayland",
      "description": "This module manages data transfer operations for clipboard and drag-and-drop actions over the Wayland protocol, handling requests like offering MIME types and setting actions, and responding to events such as data sent or cancellation. It works with file descriptors, strings, and integers to facilitate data exchange between clients. The child module defines specific error codes\u2014`Invalid_action_mask` and `Invalid_source`\u2014and provides integer conversions for use in protocol messaging. These errors signal invalid drag-and-drop actions or source handles during client-server interactions.",
      "description_length": 590,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_surface",
      "library": "wayland",
      "description": "This module manages onscreen surfaces for Wayland servers, handling operations like associating surfaces with outputs, setting preferred buffer transformations, and defining scaling factors. It works with surface objects and output proxies to control how and where content is displayed. Concrete use cases include assigning a surface to a display output, adjusting its orientation, and ensuring proper scaling for high-resolution displays.",
      "description_length": 439,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_source",
      "library": "wayland",
      "description": "This module manages data transfer operations in Wayland clients by allowing the creation and manipulation of data sources. It supports offering data with specific MIME types and setting available drag-and-drop actions for version 3. Concrete use cases include implementing clipboard functionality and handling drag-and-drop events in graphical applications.",
      "description_length": 357,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shell_surface",
      "library": "wayland",
      "description": "This module manages desktop-style surface interactions, handling operations like resizing, moving, and maximizing windows. It works with `wl_shell_surface` objects to provide metadata such as titles and classes, and supports concrete actions like sending ping requests to clients or signaling when popup interactions are complete. Use cases include implementing window management features and handling user interface behaviors for desktop environments.",
      "description_length": 452,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shm",
      "library": "wayland",
      "description": "This module manages shared memory for Wayland clients, allowing creation of shared memory pools via `create_pool` using a file descriptor and size. It supports version 1 and 2 of the protocol, with version 2 including a `release` function to free resources. Concrete use cases include sharing pixel buffers between a client and compositor for rendering surfaces or transferring image data efficiently.",
      "description_length": 401,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_region",
      "library": "wayland",
      "description": "The module implements operations for managing rectangular regions, including union, intersection, and subtraction of areas. It works with coordinates and dimensions to define and manipulate regions, which are essential for specifying surface properties like opacity and input handling. Concrete use cases include defining which parts of a window are clickable or visible in a Wayland compositor.",
      "description_length": 395,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_buffer",
      "library": "wayland",
      "description": "This module manages buffer objects that provide pixel content for surfaces in a Wayland client. It supports operations to destroy buffers and works with types such as `wl_buffer` and related protocol-specific buffer factories. Concrete use cases include attaching pixel data to surfaces for rendering, handling buffer release events, and managing buffer destruction after use.",
      "description_length": 376,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_buffer",
      "library": "wayland",
      "description": "This module defines metadata and operations for handling buffer objects in the Wayland protocol. It specifies the interface name, supported versions, and provides functions to retrieve request and event descriptions for buffer operations. Concrete use cases include managing buffer creation, destruction, and event handling within Wayland clients or servers.",
      "description_length": 358,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_source",
      "library": "wayland",
      "description": "This module manages data transfer operations for Wayland servers, specifically handling events related to drag-and-drop and clipboard interactions. It works with `wl_data_source` objects to notify when transfers are canceled, send data over file descriptors, and respond to mime type negotiations. Concrete use cases include implementing clipboard copy-paste and drag-and-drop functionality in Wayland compositors.",
      "description_length": 414,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell",
      "library": "wayland",
      "description": "This module implements the shell protocol interface for a Wayland display server, mapping versioned requests and events to function signatures and data structures. It coordinates with its child module to handle shell-specific errors, such as invalid surface roles, by converting them to 32-bit integers for communication across the protocol. The interface supports operations like creating client surfaces and managing interactions with the desktop environment. Specific extensions allow customizing shell behavior for different compositor requirements.",
      "description_length": 553,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_output",
      "library": "wayland",
      "description": "This module manages Wayland output objects representing physical display areas in the compositor coordinate system. It provides operations to release output resources, targeting clients that interact with display outputs such as monitors. Concrete use cases include handling monitor hotplugging and releasing output references when they are no longer needed.",
      "description_length": 358,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_device",
      "library": "wayland",
      "description": "Handles drag-and-drop and selection data transfer operations for Wayland servers. It works with Wayland surfaces and data offers to manage events like entering a drop zone, motion during a drag, and finalizing a drop. Concrete use cases include implementing clipboard functionality and drag-and-drop interactions between client applications.",
      "description_length": 341,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_offer",
      "library": "wayland",
      "description": "This module manages data transfer offers in the Wayland protocol, enabling negotiation of MIME types and retrieval of data via file descriptors during clipboard or drag-and-drop operations. It provides operations to advertise supported formats, accept offers, and read data streams, while its error module defines precise failure conditions such as invalid action masks, unsupported operations, and malformed offers. You can use it to handle drag-and-drop payloads with specific MIME types like `text/plain` or `image/png`, or to manage clipboard data exchange between clients and the compositor. The integration of error codes ensures robust handling of protocol violations during data transfer negotiations.",
      "description_length": 709,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_device",
      "library": "wayland",
      "description": "This module manages data transfer operations for a Wayland client, specifically handling copy-paste and drag-and-drop interactions. It works with `Wl_data_device` objects tied to a seat, using proxies for data sources and surfaces to perform actions like `set_selection` and `start_drag`. Concrete use cases include implementing clipboard functionality or initiating drag-and-drop operations with a specified origin and optional icon surface.",
      "description_length": 442,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_callback",
      "library": "wayland",
      "description": "This module provides a callback mechanism for clients to receive notifications when specific Wayland requests are completed. It works with the `wl_callback` interface, allowing clients to attach a handler to the `done` event, which is triggered once the associated request finishes. Concrete use cases include synchronizing client-side state with server-side operations, such as waiting for a surface to be properly configured before rendering.",
      "description_length": 444,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_keyboard",
      "library": "wayland",
      "description": "This module manages keyboard input events and keymap configurations in the Wayland protocol, handling key presses, releases, and keymap updates using types like `key_state` and `keymap_format`. It supports serialization and interpretation of keyboard layouts through keymap format conversions and tracks physical key states using enumerated values for pressed and released conditions. You can use it to process `wl_keyboard.keymap` events, generate input events based on key transitions, or serialize key states for client-server communication. Submodules provide low-level representations for keymap formats and key states, enabling precise control over keyboard interaction in Wayland clients and compositors.",
      "description_length": 711,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_display",
      "library": "wayland",
      "description": "This module manages core global state and object lifecycle operations for Wayland servers. It provides functions to acknowledge object ID deletions and emit fatal error events tied to specific protocol objects. These operations directly handle protocol-level resource management and error signaling for server implementations.",
      "description_length": 326,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_seat",
      "library": "wayland",
      "description": "This module manages input devices and routes events in Wayland compositors, supporting capabilities like pointer, keyboard, and touch through a bitmask type. It allows negotiation of seat versions, creation of input devices, and dispatching events to clients, while handling errors such as missing capabilities during these operations. The `Capability` submodule defines available input types as bitmask values, enabling checks on device support, and the `Error` submodule enumerates protocol-specific issues like `Missing_capability` for robust error handling. Examples include checking for pointer support before creating a pointer device, or handling version mismatches when initializing a seat.",
      "description_length": 698,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_touch",
      "library": "wayland",
      "description": "This module handles touchscreen input events for Wayland servers, including touch down, motion, up, and frame events. It works with touch points identified by unique IDs, and supports additional properties like orientation and shape for newer protocol versions. Concrete use cases include tracking finger movements on a touchscreen, managing touch session state, and relaying touch coordinates to client surfaces.",
      "description_length": 413,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_touch",
      "library": "wayland",
      "description": "This module defines the protocol metadata for the touch interface, including versioned requests and events. It specifies the data types for touch events such as coordinates, touch point IDs, and surface targets. Concrete use cases include handling multi-touch input in compositors and clients, such as tracking touch down/motion/up events across different interface versions.",
      "description_length": 375,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_output",
      "library": "wayland",
      "description": "This module manages output regions for a Wayland compositor, handling properties like geometry, scaling, and display modes. It works with `Wl_output.t` instances across multiple versions, allowing servers to define visible areas, resolution, refresh rates, and physical attributes of displays. Concrete use cases include announcing monitor capabilities during initialization, updating output scaling for high-DPI displays, and providing human-readable names and descriptions for output devices.",
      "description_length": 494,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_region",
      "library": "wayland",
      "description": "This module manages 2D regions by providing operations to add or subtract rectangular areas. It works with region objects to define complex shapes for surface properties like opacity and input handling. Concrete use cases include setting non-opaque areas of a window or defining interactive zones in a graphical interface.",
      "description_length": 322,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shell_surface",
      "library": "wayland",
      "description": "This module defines operations to manage desktop-style surfaces, enabling clients to set titles, classes, and window states like fullscreen, maximized, or popup. It works with Wayland proxies for seats, outputs, and surfaces to control window behavior and metadata. Concrete use cases include implementing window management in desktop environments, handling user interactions like resize and move gestures, and responding to server pings for liveness checks.",
      "description_length": 458,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_buffer",
      "library": "wayland",
      "description": "This module manages buffer objects that provide pixel content for surfaces in a Wayland server. It supports operations to release buffers once they are no longer needed, working with data types representing buffer resources versioned at v1. Concrete use cases include attaching buffer content to a surface for display, and handling buffer lifecycle management after rendering or client submission.",
      "description_length": 397,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm",
      "library": "wayland",
      "description": "This module manages shared memory in Wayland, enabling clients and the compositor to allocate and share memory regions efficiently using file descriptors and memory formats. It supports creating and managing shared memory pools and buffers, while its child modules define pixel format constants and error codes for handling buffer layouts and invalid parameters during protocol interactions. The pixel format module converts between variants and 32-bit integers, and the error module maps error values like `Invalid_stride` to and from 32-bit integers. You can use this module to set up shared memory for rendering, negotiate pixel formats, and handle errors in buffer creation during Wayland communication.",
      "description_length": 707,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_output",
      "library": "wayland",
      "description": "This module manages protocol metadata for the Wayland output interface, handling versioned requests and events related to display configuration. It defines key data types for output properties, including transforms for surface orientation, subpixel layouts for pixel geometry, and bitflags for display modes. Operations allow conversion between these types and integer representations, facilitating serialization and interoperability with low-level display protocols. For example, clients can use the transform module to rotate surfaces for correct rendering, query subpixel arrangements to optimize text rendering, or select preferred display modes for resolution changes.",
      "description_length": 673,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Server.TRACE",
      "library": "wayland",
      "description": "This module traces Wayland protocol messages sent to and from clients in a server context. It provides functions to log inbound and outbound messages, including details like message opcodes, arguments, and associated proxies. Use it to debug client-server communication or audit protocol usage during server development.",
      "description_length": 320,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_compositor",
      "library": "wayland",
      "description": "This module manages the compositor singleton responsible for combining surface contents into a unified display output. It provides operations to handle surface creation, rendering, and destruction across multiple versions (v1\u2013v6), ensuring compatibility with different client protocols. Concrete use cases include managing window stacking, rendering client buffers, and coordinating display updates in a Wayland server environment.",
      "description_length": 431,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_callback",
      "library": "wayland",
      "description": "This module defines the protocol interface for the `Wl_callback` type, specifying its version, requests, and events. It works with Wayland protocol metadata, handling operations like dispatching requests and processing events for version 1. A concrete use case is enabling client-side handling of Wayland callback events tied to specific protocol objects.",
      "description_length": 355,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_touch",
      "library": "wayland",
      "description": "This module handles touchscreen input events for Wayland clients, supporting operations like touch down, motion, and up. It works with touch point IDs and event sequences to track individual contacts on a touchscreen. Concrete use cases include gesture recognition, touch-based UI interactions, and multi-touch event handling in graphical applications.",
      "description_length": 352,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subcompositor",
      "library": "wayland",
      "description": "This module handles protocol requests and events for the subcompositor interface, supporting version 1 of the Wayland protocol. It works with message encoders and decoders to manage sub-surface objects, allowing surfaces to be positioned relative to parent surfaces. The child module defines error codes like `Bad_surface` and `Bad_parent`, with conversions to and from 32-bit integers for handling protocol errors. These errors can be used to validate surface creation and parent-child relationships during subcompositor operations.",
      "description_length": 533,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_device_manager",
      "library": "wayland",
      "description": "Manages inter-client data transfer mechanisms like copy-and-paste and drag-and-drop by associating them with `wl_seat` objects. It allows clients to retrieve a `wl_data_device` for a specific seat, enabling data source and offer interactions. This interface is essential for handling user-initiated data transfers in Wayland compositors.",
      "description_length": 337,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_registry",
      "library": "wayland",
      "description": "This module defines the protocol metadata for the Wayland registry interface, including its version, interface name, and the list of requests and events with their respective parameters. It specifies how to encode and decode protocol messages for registry operations, such as binding global objects. The module works with protocol message indices, string identifiers, and Wayland-specific types like `new_id` and `uint`, facilitating the dynamic discovery and binding of global interfaces in a Wayland client.",
      "description_length": 509,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_surface",
      "library": "wayland",
      "description": "This module manages onscreen surfaces for Wayland clients, handling operations like attaching buffers, marking damage regions, setting input and opaque areas, and configuring transformations and scaling. It works with surface-local coordinates and buffer content, supporting versioned interactions up to version 6. Concrete use cases include rendering graphical content, handling display transformations, and managing user input regions for interactive elements like windows or cursors.",
      "description_length": 486,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_keyboard",
      "library": "wayland",
      "description": "This module handles keyboard input devices in Wayland clients, providing operations to manage key events and keyboard focus. It works with `Wl_keyboard.t` objects, allowing clients to release keyboard resources explicitly. Concrete use cases include handling key presses, managing keyboard grabs, and cleaning up input resources when they are no longer needed.",
      "description_length": 360,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_region",
      "library": "wayland",
      "description": "This module defines the protocol interface for a region object in the Wayland protocol, specifically handling shape and clipping operations for surfaces. It provides functions to construct and manipulate region objects, including adding or subtracting rectangles, and integrates directly with Wayland's event and request system. Concrete use cases include defining non-rectangular window shapes and managing input clipping regions for graphical elements.",
      "description_length": 454,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_keyboard",
      "library": "wayland",
      "description": "This module handles keyboard input events for Wayland servers, including key presses, modifier state changes, and keyboard focus transitions. It works with `Wl_keyboard` objects and associated types like key state, keymap format, and file descriptors for keymaps. Concrete use cases include sending key events to clients, updating modifier states, and configuring keyboard repeat behavior.",
      "description_length": 389,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_display",
      "library": "wayland",
      "description": "This module manages protocol-level interactions for the Wayland display interface, handling request and event marshaling with support for version-specific behavior. It works with core Wayland data types like object IDs, strings, and unsigned integers, enabling setup of display connections, error reporting, and event dispatching. The error submodule defines standard failure codes such as invalid object and out-of-memory, converting them to and from 32-bit integers for use in cross-language protocol communication. Together, they allow clients and compositors to manage display connections and handle protocol errors consistently.",
      "description_length": 633,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_pointer",
      "library": "wayland",
      "description": "This module handles pointer input devices, providing operations to set cursor appearance with `set_cursor` and release resources with `release`. It works with Wayland pointer objects and proxies to surfaces, tracking pointer position and focus across client surfaces. Concrete use cases include updating the cursor image during interaction and cleaning up pointer resources when no longer needed.",
      "description_length": 396,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device_manager",
      "library": "wayland",
      "description": "This module manages data transfer operations in Wayland, including clipboard and drag-and-drop interactions across different protocol versions. It coordinates data device creation and handles selections and drag-and-drop actions between clients. A key component is a bitmask type representing available drag-and-drop actions\u2014such as `copy`, `move`, and `ask`\u2014which uses `int32` values to enable bitwise operations for action negotiation based on user input and modifiers. For example, a compositor can use these actions to determine the result of a drag-and-drop interaction dynamically.",
      "description_length": 587,
      "index": 231,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_subcompositor",
      "library": "wayland",
      "description": "This module handles the creation and management of sub-surfaces in a Wayland server, enabling hierarchical compositing of surfaces. It works with `wl_surface` objects, allowing them to be organized into parent-child relationships, where a main surface acts as the root of a window and sub-surfaces represent nested components. Concrete use cases include offloading compositing tasks such as rendering video overlays or window decorations by grouping related surfaces into a single logical window.",
      "description_length": 496,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_registry",
      "library": "wayland",
      "description": "This module manages the global registry in a Wayland server, handling announcements of available global objects and their removal. It works with global objects represented by names, interfaces, and versions, sending events to clients when globals are added or removed. Concrete use cases include notifying clients about input devices becoming available or removed during runtime.",
      "description_length": 379,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_compositor",
      "library": "wayland",
      "description": "This module provides functions to create and manage Wayland regions and surfaces, which are essential for rendering graphical content. It operates on the compositor object to produce displayable outputs by combining multiple surfaces. Concrete use cases include setting up windows or UI elements in a Wayland-based graphical application.",
      "description_length": 337,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shell_surface",
      "library": "wayland",
      "description": "This module manages shell surface interactions by defining core types like `t`, `versions`, and metadata structures to handle events such as resizing, fullscreen transitions, and transience. It includes operations to configure surface states and coordinate user interface behaviors in a Wayland compositor. Submodules provide specific constants for resize edges, fullscreen methods, and transient flags, enabling precise control over window management, such as setting resize cursors, choosing fullscreen modes, or marking surfaces as inactive. Direct use cases include implementing custom window behaviors and handling surface relationships during user interactions.",
      "description_length": 667,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shm_pool",
      "library": "wayland",
      "description": "This module manages shared memory pools for Wayland clients, allowing allocation of shared memory buffers for graphics operations. It provides functions to resize the memory mapping, create buffers with specific dimensions and pixel formats, and destroy the pool when no longer needed. Concrete use cases include efficiently handling dynamic surface resizing and managing multiple small buffers for interactive UI elements.",
      "description_length": 423,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_offer",
      "library": "wayland",
      "description": "This module manages data transfer offers between Wayland clients, supporting copy-paste and drag-and-drop. It allows clients to accept a transfer, receive data in a specified MIME type, and destroy or finalize offers. Specific use cases include handling user-initiated data transfers during drag-and-drop operations or clipboard pastes.",
      "description_length": 336,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_shell",
      "library": "wayland",
      "description": "This module creates shell surfaces for desktop-style user interfaces by associating them with basic Wayland surfaces. It provides the `get_shell_surface` function to generate a shell surface from an existing surface proxy. Designed for clients building traditional desktop environments, though it has been superseded by xdg_shell for modern use.",
      "description_length": 345,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_seat",
      "library": "wayland",
      "description": "Manages input device groups, tracking keyboards, pointers, and touch devices with capabilities and name events. Works with Wayland server seat objects, handling versioned capability updates and unique identifier assignments. Used to coordinate input device hotplugging and focus management in display servers.",
      "description_length": 309,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Proxy.Handler",
      "library": "wayland",
      "description": "This module manages handlers for Wayland protocol objects, allowing proxies to dispatch events and requests to the correct handler implementations. It works with proxy objects tied to specific roles (`Client` or `Server`) and interface metadata. Concrete use cases include attaching a handler to a proxy to receive events, downcasting handler versions for compatibility, and creating new proxies for peer-allocated objects.",
      "description_length": 423,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Proxy.Service_handler",
      "library": "wayland",
      "description": "This module manages service handlers for Wayland proxy objects, allowing proxies to be attached to handler implementations. It supports attaching handlers with or without retaining the resulting proxy, querying interface metadata and version constraints, and safely downcasting versions when necessary. These operations are used to register and manage objects that respond to Wayland protocol events, such as handling requests or events from a compositor or client.",
      "description_length": 465,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shm",
      "library": "wayland",
      "description": "This module manages shared memory support for Wayland servers, allowing clients to create shared memory pools and advertise supported pixel formats for buffer creation. It works with `wl_shm` objects and `wl_shm_pool` instances, handling versioned format events and pool creation requests. Concrete use cases include enabling client-side buffer allocation with specific pixel formats like ARGB8888 or XRGB8888 for rendering surfaces.",
      "description_length": 433,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shm_pool",
      "library": "wayland",
      "description": "This module manages shared memory pools for Wayland servers, allowing clients to allocate shared memory buffers (`wl_buffer`) from a common memory region. It supports efficient memory reuse, ideal for scenarios like interactive surface resizing or handling many small buffers. The module works directly with shared memory file descriptors and buffer objects, version 1 being preferred for server implementations.",
      "description_length": 412,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Proxy.TRACE",
      "library": "wayland",
      "description": "This module traces protocol messages sent to and received from a Wayland connection. It provides `outbound` and `inbound` functions to log messages associated with a proxy, where `outbound` handles write-direction messages and `inbound` handles read-direction messages. Use this when debugging communication between a client and compositor by inspecting message flow at the proxy level.",
      "description_length": 386,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_callback",
      "library": "wayland",
      "description": "This module provides a single operation, `done_`, which sends a completion notification to a client with a specific timestamp. It works with the `Wl_callback.t` type, representing a callback object created by various server-side interfaces. A concrete use case is signaling the completion of a surface state update or input event handling to the client, ensuring synchronization with the compositor's internal state.",
      "description_length": 416,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Metadata.S",
      "library": "wayland",
      "description": "This module defines metadata for a Wayland interface, including its name, version, and structured descriptions of its requests and events. It works with the `Wayland.Metadata.ty` type, specifically handling interface definitions with associated data types and method signatures. Concrete use cases include parsing and representing Wayland protocol specifications for code generation or runtime reflection.",
      "description_length": 405,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Client.TRACE",
      "library": "wayland",
      "description": "This module traces Wayland protocol messages sent to and from a client. It provides functions to intercept and log outbound and inbound messages, including their associated proxies and events. Use it to debug communication between a Wayland client and server by inspecting raw message flow.",
      "description_length": 290,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_shm_pool",
      "library": "wayland",
      "description": "This module defines the protocol interface for shared memory pools, including operations to create and manage memory buffers. It works with shared memory file descriptors and buffer allocation parameters. Concrete use cases include setting up pixel buffers for surfaces or sharing memory between client and server for efficient data transfer.",
      "description_length": 342,
      "index": 248,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_surface",
      "library": "wayland",
      "description": "This module defines the protocol metadata for the `Wl_surface` interface, including supported versions and message details, and provides utilities to retrieve request and event information such as method names and argument types. It includes a child module that defines error codes for surface operations, like invalid scale or transform, with conversions to and from 32-bit integers for protocol use. The combined functionality supports implementing and handling surface communication between clients and the compositor, including error handling during configuration and rendering. For example, it allows retrieving event details for input handling or returning specific errors when surface state is invalid.",
      "description_length": 709,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_display",
      "library": "wayland",
      "description": "This module manages core global operations for Wayland clients, specifically providing access to the global registry and synchronization mechanisms. It works with the `Wl_display` type and constructs proxies for `Wl_registry` and `Wl_callback` to interact with Wayland's protocol. Concrete use cases include retrieving global objects like `Wl_registry` and performing asynchronous roundtrips to synchronize client and server states.",
      "description_length": 432,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_pointer",
      "library": "wayland",
      "description": "This module handles pointer input events for Wayland servers, including motion, button presses, and scrolling. It works with Wayland surfaces and input device states to track pointer position and interactions. Concrete use cases include sending cursor movement updates, handling mouse clicks, and relaying scroll events with high precision and directional information.",
      "description_length": 368,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_pointer",
      "library": "wayland",
      "description": "This module manages pointer input events in the Wayland protocol, handling motion, button presses, axis scrolling, and focus changes. It works with core types like `Button_state.t` for tracking button transitions, `Axis.t` for scroll directions, `Axis_source.t` for identifying input sources like wheels or fingers, and `Axis_relative_direction.t` for motion direction relative to the pointer. Operations include converting these types to and from 32-bit integers for protocol transmission, enabling precise event interpretation and response in compositors or clients\u2014such as mapping a mouse wheel event from a `Wheel` source to a vertical scroll in a UI. Error codes from child modules allow handling and signaling of pointer-related failures during event processing.",
      "description_length": 768,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_data_device_manager",
      "library": "wayland",
      "description": "This module manages data transfer mechanisms like copy-paste and drag-and-drop by providing functions to create data devices and sources tied to a `wl_seat`. It works with `wl_data_device`, `wl_data_source`, and `wl_seat` proxy objects, enabling clients to handle data transfer operations. Concrete use cases include implementing clipboard functionality or drag-and-drop interactions in a Wayland client.",
      "description_length": 404,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_shell",
      "library": "wayland",
      "description": "This module creates desktop-style surfaces for Wayland servers, handling client requests to associate basic surfaces with shell-specific properties. It works with `wl_surface` and `wl_shell_surface` types, enabling window-like behaviors such as resizing, moving, and setting titles. Use this to implement legacy desktop shell interactions, though `xdg_shell` should be preferred for modern applications.",
      "description_length": 403,
      "index": 254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_client.Wl_subcompositor",
      "library": "wayland",
      "description": "This module creates and manages sub-surface relationships between Wayland surfaces, allowing one surface to become a sub-surface of another. It provides `get_subsurface` to assign a sub-surface role to a surface with a specified parent, and `destroy` to unbind the subcompositor interface. It is used in scenarios such as structuring a video player with separate surfaces for video content and window decorations, enabling optimized compositing by the display server.",
      "description_length": 467,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_subsurface",
      "library": "wayland",
      "description": "This module handles the protocol metadata and serialization logic for the `Wl_subsurface` interface, managing versioned requests and events through structured data encoding and decoding. It supports operations on integers and object references, enabling hierarchical surface composition in Wayland display servers. The child module defines error codes like `Bad_surface` and provides conversions to `int32` for error handling during subsurface management. Together, they enable precise client and server logic for compositing, such as validating surfaces and transmitting position data in nested display hierarchies.",
      "description_length": 616,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_data_device",
      "library": "wayland",
      "description": "This module manages data transfer operations in the Wayland compositing protocol, handling clipboard and drag-and-drop interactions through data devices and selection metadata. It defines core operations for managing data device roles and selection sources, along with error codes for reporting interface-specific failures. The child module provides structured error types like `Role` and `Used_source`, convertible to `int32`, enabling precise error handling during data transfer. Together, they allow applications to implement robust clipboard management and drag-and-drop functionality with detailed error reporting.",
      "description_length": 619,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_proto.Wl_compositor",
      "library": "wayland",
      "description": "This module defines the interface and version metadata for the Wayland compositor protocol object. It provides access to the compositor's requests and events, such as creating surfaces or handling display destruction. It works directly with protocol versioning and message definitions for compositor-specific operations.",
      "description_length": 320,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_data_offer",
      "library": "wayland",
      "description": "This module manages data transfer offers in Wayland servers, specifically handling MIME type advertisement and drag-and-drop actions. It works with `wl_data_offer` objects, allowing servers to announce supported MIME types and communicate available or selected data transfer actions. Concrete use cases include implementing clipboard operations and drag-and-drop interactions where a server needs to negotiate data format and transfer method with clients.",
      "description_length": 455,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server.Wl_subsurface",
      "library": "wayland",
      "description": "This module manages sub-surfaces in a Wayland server, providing functions to control their position, stacking order, and synchronization mode relative to parent surfaces. It operates on `wl_subsurface` objects, handling state changes such as mapping, unmapping, and destruction, while enforcing rules about focus and clipping. Concrete use cases include implementing layered UI components like popups, tooltips, or embedded views that need precise positioning and visibility control independent of their parent's buffer state.",
      "description_length": 526,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Server",
      "library": "wayland",
      "description": "This module implements Wayland server-side protocol handling, managing connections over a transport layer and providing functions to establish connections, access the display object, and shut down the server gracefully. It includes tools to create a server instance from a Unix socket and trace protocol messages for debugging. The tracing submodule logs inbound and outbound messages with details like opcodes, arguments, and proxies, enabling inspection of client-server communication. Together, these components support building and auditing a Wayland server with visibility into protocol state and message flow.",
      "description_length": 615,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Unix_transport",
      "library": "wayland",
      "description": "This module implements message transmission over Unix-domain sockets for Wayland clients. It provides functions to connect to a Wayland server socket, retrieve the socket path, and manage communication using a dedicated transport type. Concrete use cases include establishing a connection to a Wayland compositor and sending or receiving Wayland protocol messages over the socket.",
      "description_length": 380,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Proxy",
      "library": "wayland",
      "description": "This module manages Wayland proxy objects, handling their lifecycle, message routing, and event dispatching across client-server boundaries. It operates on `Wayland.Proxy.t` values and transport interfaces, supporting dynamic object interactions, tracing, and error handling for use cases like building clients, servers, and debugging tools. The proxy layer routes events and requests to role-specific handlers, attaches service implementations with version compatibility, and traces message flow in both directions for inspection. For example, a proxy can be configured to dispatch events to a client handler, log outbound requests, or spawn new proxies for objects allocated by a compositor.",
      "description_length": 693,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.S",
      "library": "wayland",
      "description": "This module defines a polymorphic variant type `user_data` with a single constructor `No_data`, representing the absence of user-defined data associated with a Wayland proxy. It is used to handle cases where no additional data is attached to proxies in Wayland client-server communication. Concrete use cases include initializing proxies with default user data or pattern matching to handle proxies that carry no extra information.",
      "description_length": 431,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Metadata",
      "library": "wayland",
      "description": "This module organizes metadata for Wayland interfaces, defining core data types like integers, strings, file descriptors, and objects, along with operations to map interface descriptions into structured data. It supports retrieving arguments and metadata by index, enabling tasks like parsing and generating protocol specifications. The child module extends this by capturing interface-specific details such as name, version, and method signatures, working directly with `Wayland.Metadata.ty` to represent full interface definitions. Together, they facilitate code generation and runtime handling of Wayland protocols through structured, accessible metadata.",
      "description_length": 658,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Client",
      "library": "wayland",
      "description": "This module establishes and manages a client connection to a Wayland server over a given transport, enabling the sending and synchronization of protocol messages, access to the initial display object, and graceful shutdown of the connection. It includes a submodule that traces protocol messages, allowing interception and logging of inbound and outbound communication, including proxies and events, for debugging message flow. Main data types include the client connection and display object, with operations for message dispatch, logging, and connection lifecycle management. You can use it to bootstrap Wayland client applications, coordinate communication with the compositor, and inspect raw client-server interactions for debugging.",
      "description_length": 738,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Msg",
      "library": "wayland",
      "description": "This module handles the construction and parsing of Wayland protocol messages, including reading from and writing to buffers with support for integers, strings, arrays, file descriptors, and fixed-point numbers. It operates on `Wayland.Msg.t` values, which encapsulate message headers and arguments, and uses `Cstruct.t` for buffer manipulation. Concrete use cases include decoding incoming Wayland messages from a socket buffer and assembling outgoing messages with correct binary formatting for protocol compliance.",
      "description_length": 517,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Fixed",
      "library": "wayland",
      "description": "This module implements arithmetic operations for a 24.8 fixed-point numeric type, represented as a private int32. It provides conversions to and from integers and raw bits, along with formatted printing. It is used for precise fractional calculations in graphics and windowing operations where floating-point is undesirable.",
      "description_length": 324,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_proto",
      "library": "wayland",
      "description": "This module provides type metadata and protocol definitions for Wayland interface objects, enabling structured data exchange, error handling, and versioned communication between clients and compositors. It defines core data types such as integers, bitmasks, and enumerated values for input events, buffer operations, surface management, and data transfer, along with conversions to and from 32-bit integers for protocol messaging. Operations include handling keyboard and pointer input, managing shared memory and buffer formats, negotiating drag-and-drop actions, and configuring display outputs and surface properties. Examples include using MIME types for clipboard data transfer, interpreting keymap events for keyboard layouts, or setting up shared memory pools for rendering surfaces.",
      "description_length": 790,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Wayland_client",
      "library": "wayland",
      "description": "This module provides a comprehensive interface for Wayland clients to manage surfaces, input devices, data transfer, and global resources in a display server environment. Key data types include `wl_surface`, `wl_buffer`, `wl_seat`, `wl_registry`, and `wl_data_source`, with operations for rendering, input handling, clipboard and drag-and-drop, and dynamic resource management. Users can implement window compositing with sub-surfaces, handle multi-touch and keyboard input, synchronize state with the display server, and manage shared memory for efficient graphics rendering. Specific applications include building desktop environments, interactive UIs, and graphical applications with custom window management and input handling.",
      "description_length": 731,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland.Registry",
      "library": "wayland",
      "description": "This module provides operations to interact with the Wayland registry, including retrieving interface entries by name and binding to proxies for specific interfaces. It works with the `t` type representing a registry and `entry` records containing interface names and versions. Concrete use cases include discovering available Wayland interfaces and creating proxies to interact with compositor objects.",
      "description_length": 403,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wayland.Wayland_server",
      "library": "wayland",
      "description": "This module provides a comprehensive interface for building Wayland servers by integrating surface management, input handling, buffer composition, and data transfer functionalities. It centers around key data types such as surfaces, outputs, input devices, buffers, and data offers, enabling operations like window management, touch and pointer event handling, shared memory buffer allocation, and clipboard or drag-and-drop interactions. Developers can use it to assign surfaces to displays with custom scaling, manage hierarchical UI components with sub-surfaces, handle keyboard and pointer input, and coordinate data transfers between clients. Specific tasks include synchronizing client rendering with callbacks, defining input regions, and announcing display capabilities for high-DPI support.",
      "description_length": 799,
      "index": 272,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wayland.Iface_reg",
      "library": "wayland",
      "description": "This module maintains a registry of Wayland interface metadata, enabling runtime lookup of interfaces by name. It provides `register` to add interface metadata and `lookup` to retrieve it by string identifier. Used internally by generated code to map between interface names and their corresponding types during protocol handling.",
      "description_length": 330,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wayland",
      "library": "wayland",
      "description": "This module implements the core Wayland protocol, enabling structured message passing, proxy management, and callback handling between clients and servers. It operates on protocol-defined types like `Wl_callback.t`, `Wayland.Proxy.t`, and `Wayland.Msg.t`, supporting versioned interfaces and precise data handling through structured metadata and fixed-point arithmetic. Concrete use cases include managing display connections, dispatching input events, and synchronizing client-server communication over Unix sockets. Submodules provide transport-layer messaging, interface metadata handling, registry interaction, and detailed tracing for debugging protocol interactions.",
      "description_length": 672,
      "index": 274,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 604,
    "meaningful_modules": 275,
    "filtered_empty_modules": 329,
    "retention_rate": 0.4552980132450331
  },
  "statistics": {
    "max_description_length": 893,
    "min_description_length": 285,
    "avg_description_length": 464.6690909090909,
    "embedding_file_size_mb": 0.9995498657226562
  }
}