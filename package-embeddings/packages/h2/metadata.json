{
  "package": "h2",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 16,
  "creation_timestamp": "2025-08-14T23:25:24.298599",
  "modules": [
    {
      "module_path": "H2.Body.Reader",
      "library": "h2",
      "description": "This module manages the reading of HTTP/2 message bodies by providing callbacks for consuming incoming data chunks and handling end-of-stream conditions. It works with `Bigstringaf.t` buffers to efficiently process byte streams without unnecessary copying. Concrete use cases include streaming large request bodies to disk or processing multipart form data incrementally.",
      "description_length": 371,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Body.Writer",
      "library": "h2",
      "description": "This module provides functions to write character data to an HTTP/2 message body, including operations to buffer and schedule writes of strings and bigstrings. It supports efficient transmission by combining writes and allowing direct memory management through `schedule_bigstring`, which avoids unnecessary copies. Concrete use cases include streaming large payloads, sending binary data, and building HTTP/2 responses incrementally without excessive memory overhead.",
      "description_length": 468,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Status",
      "library": "h2",
      "description": "This module defines types and functions for working with HTTP/2 response status codes, including standard symbolic representations like `OK`, `Found`, and `Internal_server_error`, as well as arbitrary numeric status codes via `Code of int`. It provides utilities to convert between status codes and their integer representations, classify status codes (e.g., `is_successful`, `is_error`), and obtain default reason phrases. Concrete use cases include constructing and validating HTTP/2 responses, handling client and server errors programmatically, and logging or debugging HTTP/2 communication flows using human-readable status strings.",
      "description_length": 637,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.IOVec",
      "library": "h2",
      "description": "This module handles vectorized IO operations over HTTP/2 connections by providing functions to manipulate and inspect IOVec.t structures, which represent sequences of memory buffers. It supports operations like calculating the total length of a buffer or a list of buffers, shifting buffers by a given offset, and pretty-printing buffer contents for debugging. Concrete use cases include managing incoming and outgoing data frames in an HTTP/2 connection, where precise buffer control is required for efficient data transmission.",
      "description_length": 529,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Settings",
      "library": "h2",
      "description": "This module defines settings parameters for HTTP/2 connections, including values for header table size, stream concurrency, window size, and frame limits. It provides functions to serialize and deserialize settings to and from base64, as required by the HTTP/2 specification for use in the SETTINGS frame. These operations support configuring and transmitting connection-level parameters during HTTP/2 handshake and negotiation.",
      "description_length": 428,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Method",
      "library": "h2",
      "description": "This module defines types and functions for working with HTTP request methods, including standard methods like `GET`, `POST`, and `PUT`, as well as custom methods. It provides predicates to check properties of standard methods, such as whether they are safe, cacheable, or idempotent, and functions for converting methods to and from strings. It is used to determine request semantics and validate method properties in HTTP/2 clients and servers.",
      "description_length": 446,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Headers",
      "library": "h2",
      "description": "This module provides functions to construct, modify, and query HTTP/2 header collections, supporting ordered transmission, selective addition and replacement (with optional sensitivity flags), bulk operations from lists, and lookups for single or multiple values per header name. It operates on ordered collections of lowercase name-value string pairs, enforcing HTTP/2 compliance such as case-insensitive name equality and proper handling of combined field values. These capabilities are critical for managing headers in HTTP/2 messages during transmission, proxying, or logging, and for serializing headers into string or human-readable formats while preserving semantic integrity.",
      "description_length": 683,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Server_connection",
      "library": "h2",
      "description": "This module manages HTTP/2 server connections by handling request processing, input/output operations, and error handling. It works with HTTP/2 frames, request handlers, and low-level IO buffers using types like `t`, `error`, `request_handler`, and `error_handler`. Concrete use cases include initializing a connection from an HTTP/1.1 upgrade, reading incoming data, writing responses, handling errors during processing, and managing connection lifecycle events like shutdown.",
      "description_length": 477,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Reqd",
      "library": "h2",
      "description": "This module handles HTTP/2 request/response interactions on a per-stream basis, enabling operations like retrieving incoming requests, streaming or immediate response sending, and managing trailers. It works with HTTP/2 requests, responses, and bodies using types like `H2.Request.t`, `H2.Response.t`, and `H2.Body.Reader.t`. Concrete use cases include responding to a client request with a string or streaming body, pushing additional responses to the client before the initial response completes, and handling exceptions tied to specific HTTP/2 streams.",
      "description_length": 555,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Body",
      "library": "h2",
      "description": "This module handles the ingestion and emission of HTTP/2 message payloads through its `Reader` and `Writer` submodules. It operates on `Bigstringaf.t` buffers for efficient data transfer, supporting streaming and memory-conscious operations. Use it to process large request bodies incrementally or construct responses with controlled memory usage.",
      "description_length": 347,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Error_code",
      "library": "h2",
      "description": "This module defines error codes used in HTTP/2 communication, including standard errors like protocol violations, flow control issues, and stream management problems. It provides conversions to human-readable strings and formatting functions for debugging or logging error conditions. These values are used to signal and handle specific failure scenarios during HTTP/2 connection and stream processing.",
      "description_length": 402,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Response",
      "library": "h2",
      "description": "This module defines the structure and operations for handling HTTP/2 server responses, including status codes and headers. It provides functions to create responses, determine the length of response bodies based on the request method, and pretty-print response data. Concrete use cases include constructing valid HTTP/2 responses for server handlers and calculating message body sizes for transmission.",
      "description_length": 402,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Config",
      "library": "h2",
      "description": "This module defines configuration parameters for HTTP/2 connections, including buffer sizes, flow control settings, and protocol features like server push. It provides a `default` value for standard configurations and a `to_settings` function to convert configurations into HTTP/2 settings frames. Use this module to customize connection behavior for performance tuning or protocol compliance in client and server implementations.",
      "description_length": 430,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2.Client_connection",
      "library": "h2",
      "description": "This module manages HTTP/2 client connections, handling request/response cycles, server push, and connection lifecycle events. It works with HTTP/2 requests and responses, including headers, bodies, and trailers, and supports operations like sending requests, handling asynchronous responses, and managing flow control. Concrete use cases include making HTTP/2 requests with streaming request/response bodies, handling server push streams, and managing connection-level events like pings and graceful shutdowns.",
      "description_length": 511,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "H2.Request",
      "library": "h2",
      "description": "This module represents client-initiated HTTP/2 requests, providing functions to construct and inspect request values. It works with HTTP methods, string targets, schemes, and structured headers. Use it to create and manipulate HTTP/2 request metadata, such as setting the request method, URI components, and headers for transmission over a connection.",
      "description_length": 351,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "H2",
      "library": "h2",
      "description": "This module implements HTTP/2 clients and servers with support for request/response handling, streaming bodies, and connection management. It works with structured types for methods, status codes, headers, and messages, along with efficient buffer-based IO operations. Concrete use cases include serving and consuming HTTP/2 APIs with precise control over headers, streaming data, and connection settings like flow control and server push.",
      "description_length": 439,
      "index": 15,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 16,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 683,
    "min_description_length": 347,
    "avg_description_length": 467.25,
    "embedding_file_size_mb": 0.23222923278808594
  }
}