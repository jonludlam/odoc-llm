{
  "package": "colibrilib",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 14,
  "creation_timestamp": "2025-08-14T23:20:33.421841",
  "modules": [
    {
      "module_path": "Colibrilib.Interval.Union.Make.Increasing.Unary",
      "library": "colibrilib",
      "description": "This module implements unary operations on intervals represented by the `t` type, specifically handling increasing functions and constants. It supports operations like negation, multiplication by a constant, and applying increasing scalar functions to intervals. These functions are useful for interval arithmetic in domains like numerical analysis or constraint solving where precise bounds transformations are required.",
      "description_length": 421,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Union.Make.Increasing.Binary",
      "library": "colibrilib",
      "description": "This module implements interval arithmetic operations for rational numbers using a binary representation, supporting addition, multiplication, inversion, and division of intervals. It provides functions to manipulate intervals with custom operations, including handling bounds, constants, and presence states like near or far. Use cases include precise numerical computations, symbolic algebra systems, and constraint solving where exact arithmetic on bounded values is required.",
      "description_length": 479,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Union.Make.NonIncreasing",
      "library": "colibrilib",
      "description": "This module implements interval union operations for non-increasing functions, supporting transformations like ceiling, floor, truncation, and ReLU on interval data. It provides specialized application functions (`op_nsi1_sin`, `op_nsi1_inter`, `op_nsi1_wait`) that handle conditional and stateful interval updates based on input values. These operations are used for precise interval arithmetic in domains like signal processing or constraint solving where monotonicity cannot be assumed.",
      "description_length": 489,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Union.Make.Increasing",
      "library": "colibrilib",
      "description": "This module manages interval arithmetic for increasing functions and rational numbers using unary and binary operations. It works with interval types that track bounds and presence states, supporting transformations like negation, scaling, addition, and division. It is used for precise numerical analysis, constraint solving, and symbolic computation where interval bounds must be accurately maintained and transformed.",
      "description_length": 420,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Colibrilib.Interval.Union.Make.IsComparable",
      "library": "colibrilib",
      "description": "This module implements comparisons between interval bounds, determining precise ordering relationships like less than, greater than, or incomparable. It works with interval types and rational numbers, using directional checks to classify relationships. Concrete use cases include validating interval overlaps and ordering in interval arithmetic.",
      "description_length": 345,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Union.Make",
      "library": "colibrilib",
      "description": "This module manipulates interval sets through union, intersection, and exclusion operations, while supporting comparisons and transformations like convex hull construction, ceiling/floor adjustments, and ReLU applications. It operates on recursive interval structures composed of rational number bounds (`Q.t`) paired with bound presence indicators, handling both discrete points and nested intervals with open/closed endpoints. These capabilities are tailored for numerical analysis tasks requiring precise interval arithmetic, such as static program analysis or geometric computations involving continuous ranges.",
      "description_length": 615,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Convexe.Make",
      "library": "colibrilib",
      "description": "This module provides convex interval arithmetic and set operations over rational numbers, supporting construction of intervals with open or closed bounds, membership tests, and relational comparisons. It handles convex intervals represented by bound types that distinguish open/closed endpoints, along with utilities for union, intersection, and heuristic-based interval splitting. The functionality is suited for numerical analysis, constraint system implementations, or algorithms requiring precise interval partitioning and arithmetic.",
      "description_length": 538,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Colibrilib.Interval.Union",
      "library": "colibrilib",
      "description": "This module performs union, intersection, and exclusion operations on interval sets with rational bounds, supporting transformations like convex hull, ceiling/floor adjustments, and ReLU. It works with recursive interval structures representing continuous or nested ranges with open/closed endpoints. Useful for static analysis and geometric computations requiring precise interval arithmetic.",
      "description_length": 393,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Bound",
      "library": "colibrilib",
      "description": "This module defines two bound types, `Strict` and `Large`, representing open and closed interval boundaries. It provides the `inv_bound` function to invert a bound, converting `Strict` to `Large` and vice versa. Useful for interval arithmetic and range manipulation where boundary inclusion needs to be dynamically adjusted.",
      "description_length": 324,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval.Convexe",
      "library": "colibrilib",
      "description": "This module implements convex interval arithmetic and set operations over rational numbers, allowing creation of intervals with open or closed bounds, membership testing, and relational comparisons. It supports union, intersection, and heuristic-based interval splitting, designed for numerical analysis, constraint systems, and precise interval partitioning algorithms.",
      "description_length": 370,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib.Interval",
      "library": "colibrilib",
      "description": "This module provides operations for defining and manipulating intervals with rational bounds, supporting convex arithmetic, union and intersection operations, and dynamic boundary inversion. It works with interval structures that have open or closed endpoints, enabling precise numerical analysis, constraint solving, and interval partitioning. Concrete use cases include implementing range-based static analysis, geometric range queries, and exact interval arithmetic for safety-critical computations.",
      "description_length": 502,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Colibrilib.QUtils",
      "library": "colibrilib",
      "description": "This module extends rational number operations with functions for computing floors, ceilings, and divisibility-based intervals. It works with `Q.t` rational numbers and `Z.t` integers, providing precise arithmetic for tasks like rounding or checking divisibility. Concrete use cases include financial calculations requiring exact fractional arithmetic and scheduling algorithms needing interval alignment.",
      "description_length": 405,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Colibrilib.Ord",
      "library": "colibrilib",
      "description": "This module defines a comparison result type with three variants: `Eq` for equality, `Lt` for less-than, and `Gt` for greater-than. It is used to represent the outcome of ordered comparisons between values. Concrete use cases include implementing custom ordering logic in sorting functions, comparison-based data structures like binary search trees, and equality checks in polymorphic containers.",
      "description_length": 396,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colibrilib",
      "library": "colibrilib",
      "description": "This module provides precise rational number operations, interval arithmetic with open/closed bounds, and a three-way comparison result type. It works with `Q.t` rational numbers, `Z.t` integers, and interval structures with dynamic boundaries. Concrete use cases include financial calculations, scheduling algorithms, range-based static analysis, and custom ordering logic in data structures.",
      "description_length": 393,
      "index": 13,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 14,
    "meaningful_modules": 14,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 615,
    "min_description_length": 324,
    "avg_description_length": 435.0,
    "embedding_file_size_mb": 0.20345115661621094
  }
}