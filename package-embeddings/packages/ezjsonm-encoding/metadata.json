{
  "package": "ezjsonm-encoding",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 3,
  "creation_timestamp": "2025-07-15T23:04:42.579085",
  "modules": [
    {
      "module_path": "Ezjsonm_encoding.Decoding.Syntax",
      "library": "ezjsonm-encoding",
      "description": "This module provides monadic operators to compose decoders for parsing JSON values into OCaml values. It works with the `'a Ezjsonm_encoding.Decoding.t` type, representing decoders that may fail. Use it to sequentially bind decoding steps, map results, combine parallel decoders, or inject constant values into decoding pipelines.",
      "description_length": 330,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ezjsonm_encoding.Decoding",
      "library": "ezjsonm-encoding",
      "description": "This module enables decoding JSON into OCaml values using composable combinators, supporting primitives like strings, integers, and booleans, as well as structured data like lists, optional fields, and enums. Its core operations allow parsing API responses into typed structures and validating JSON configurations. The child module provides monadic operators to chain, map, and combine decoders, enabling precise and failure-aware decoding pipelines. For example, you can decode a JSON object into a record by sequentially binding field decoders or validate a list of enum values in a configuration file.",
      "description_length": 604,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ezjsonm_encoding",
      "library": "ezjsonm-encoding",
      "description": "This library enables structured JSON serialization and deserialization of OCaml values using type-safe combinator-based encodings, with support for fixed-length arrays, extensible JSON objects, and nested structures. It provides `tupN` and `objN` combinators that tolerate extra object fields during decoding, making it suitable for evolving schemas and resilient API parsing. The core module handles primitives, records, and recursive types, while the child module adds monadic decoding combinators for composing and validating complex data structures. Example uses include parsing JSON API responses into typed records, decoding configuration files with optional fields, and handling enums or nested lists with precise validation.",
      "description_length": 732,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 732,
    "min_description_length": 330,
    "avg_description_length": 555.3333333333334,
    "embedding_file_size_mb": 0.011331558227539062
  }
}