{
  "package": "nanoev-picos",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 10,
  "creation_timestamp": "2025-08-14T23:12:50.901760",
  "modules": [
    {
      "module_path": "Nanoev_picos.Base.Raw",
      "library": "nanoev-picos",
      "description": "This module schedules timed and I/O-driven callbacks with precise control over execution context, using Unix file descriptors and delayed invocation. It handles asynchronous resource management by triggering actions on read, write, or timeout events, while ensuring operations complete despite interruptions. Use it to implement non-blocking I/O loops, delayed execution of system tasks, or event-driven resource cleanup.",
      "description_length": 421,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos.Background_thread",
      "library": "nanoev-picos",
      "description": "Handles execution of event loops in a background thread, providing setup, shutdown, and scoped management of the thread's lifecycle. Works with `Nanoev.t`, a type representing an event loop instance. Useful for running non-blocking event loops concurrently while ensuring proper initialization and cleanup, such as in network servers or asynchronous I/O handlers.",
      "description_length": 363,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos.Net_client",
      "library": "nanoev-picos",
      "description": "This module implements network client operations for connecting to picos over Unix sockets. It provides functions to establish connections and exchange data using `IO_in` and `IO_out` streams. Concrete use cases include sending requests to and receiving responses from a pico service.",
      "description_length": 284,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos.Base",
      "library": "nanoev-picos",
      "description": "This module implements non-blocking I/O operations and asynchronous event handling using Unix file descriptors. It provides direct control over reading, writing, connecting, and closing file descriptors, along with timed suspension of execution. Use it to build low-level network clients, event loops, or resource management systems that require precise control over I/O and timing.",
      "description_length": 382,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos.Net_server",
      "library": "nanoev-picos",
      "description": "This module creates and manages TCP servers that handle client connections using a provided client handler function. It supports starting a server on a specific socket address, limiting concurrent connections, and controlling server lifecycle with start, shutdown, and wait operations. It is used to implement network services that process incoming connections with custom logic, such as handling client requests over Unix sockets or TCP/IP.",
      "description_length": 441,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nanoev_picos.IO_out",
      "library": "nanoev-picos",
      "description": "This module implements output channels for writing data to various destinations, such as buffers, file descriptors, or in-memory structures. It supports operations like character, string, integer, and line-based output, with optional buffering, flushing, and closing behaviors. Concrete use cases include logging to memory buffers, writing binary data to files via file descriptors, and multiplexing output across multiple channels using `tee`.",
      "description_length": 444,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nanoev_picos.Net",
      "library": "nanoev-picos",
      "description": "This module implements low-level network communication primitives for interacting with picos, providing direct access to socket operations. It handles raw data transmission and reception over Unix file descriptors, supporting both connected and connectionless communication through `send`, `recv`, `sendto`, and `recvfrom` functions. Concrete use cases include sending and receiving binary payloads to and from picos over UDP or TCP sockets, with precise control over message flags and memory buffers.",
      "description_length": 501,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos.Global_ev",
      "library": "nanoev-picos",
      "description": "This module manages a global event loop and background thread operations for handling asynchronous events. It provides functions to start, stop, and interact with a background thread, as well as retrieve or lock access to the global Nanoev event loop instance. Concrete use cases include coordinating long-running background tasks, ensuring thread-safe access to shared resources, and managing event-driven I/O operations across the application.",
      "description_length": 445,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nanoev_picos.IO_in",
      "library": "nanoev-picos",
      "description": "This module implements input channel abstractions for handling byte streams, supporting operations like reading into buffers, concatenating input sources, and copying data to output channels. It works with `bytes`, `string`, and file descriptors, providing direct access to low-level I/O through callbacks and Unix file descriptors. Concrete use cases include reading from network sockets, processing binary file data, and streaming input from memory buffers.",
      "description_length": 459,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nanoev_picos",
      "library": "nanoev-picos",
      "description": "This module provides low-level non-blocking I/O and event loop management for handling asynchronous operations with Unix file descriptors and network communication. It includes direct I/O primitives for reading, writing, connecting, and accepting connections, along with modules for building input/output channels, network clients and servers, and event-driven processing. Concrete use cases include implementing network services that handle client requests over TCP or Unix sockets, sending and receiving binary payloads to picos, and managing background event loops for concurrent I/O-bound tasks.",
      "description_length": 599,
      "index": 9,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 12,
    "meaningful_modules": 10,
    "filtered_empty_modules": 2,
    "retention_rate": 0.8333333333333334
  },
  "statistics": {
    "max_description_length": 599,
    "min_description_length": 284,
    "avg_description_length": 433.9,
    "embedding_file_size_mb": 0.14530658721923828
  }
}