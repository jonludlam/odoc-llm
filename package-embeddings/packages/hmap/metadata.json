{
  "package": "hmap",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 7,
  "creation_timestamp": "2025-07-15T23:05:24.300056",
  "modules": [
    {
      "module_path": "Hmap.Make.Key",
      "library": "hmap",
      "description": "This module creates and manipulates keys for heterogeneous maps, where each key carries type-specific information. It supports operations to create keys with associated metadata, retrieve that metadata, and compare keys for equality and ordering. Existential keys enable type-agnostic comparisons, making it possible to implement map operations like filtering across different key types.",
      "description_length": 387,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hmap.Key",
      "library": "hmap",
      "description": "This module creates and manages keys for heterogeneous maps, supporting dynamic key creation and type-safe value storage. It defines operations to generate unique keys, hide their types, and compare them for equality or ordering. These keys enable efficient filtering and manipulation of heterogeneous map contents based on key identity or type.",
      "description_length": 345,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hmap.Make",
      "library": "hmap",
      "description": "This module implements a heterogeneous map where keys carry type-specific information and values can be of arbitrary types. It supports standard operations like adding, removing, and finding bindings, as well as iteration, folding, and filtering over the map's contents. The key module enables creating and manipulating these typed keys, allowing for type-safe access and comparison across different key types. For example, you can store configuration options with different value types under typed keys and later retrieve or transform them based on their key metadata.",
      "description_length": 569,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hmap.S-Key",
      "library": "hmap",
      "description": "This module defines operations for creating and managing keys used in heterogeneous maps, including functions to create keys with associated metadata and to retrieve that metadata. It supports existential keys, which enable type-erased comparisons and ordering, allowing keys of different types to be compared or filtered uniformly. Concrete use cases include implementing key-based filtering and equality checks in heterogeneous map structures.",
      "description_length": 445,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hmap.S",
      "library": "hmap",
      "description": "This module implements a heterogeneous map that associates unique keys with values of arbitrary types. It supports operations like adding, removing, and querying bindings, as well as iterating, folding, and filtering over the map's contents. Concrete use cases include managing dynamic configurations with mixed value types, tracking runtime state with varied metadata, and implementing extensible registries where keys determine value types.",
      "description_length": 442,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hmap.KEY_INFO",
      "library": "hmap",
      "description": "This module defines the type for key information used in heterogeneous value maps. It includes operations to create, compare, and hash keys based on their unique identifiers and value types. Concrete use cases include managing typed keys for storing and retrieving values of varying types within a single map structure.",
      "description_length": 319,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hmap",
      "library": "hmap",
      "description": "This module manages heterogeneous maps where keys enforce type safety while values retain dynamic flexibility. It supports operations like insertion, lookup, iteration, and cardinality tracking over type-erased bindings, enabling use cases such as dynamic configuration stores and extensible registries. Keys carry type-specific metadata and support equality checks, filtering, and ordering, allowing efficient manipulation of map contents based on key identity or type. For example, you can store and retrieve mixed-type configuration values under typed keys, or filter map entries by key metadata during runtime processing.",
      "description_length": 625,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 625,
    "min_description_length": 319,
    "avg_description_length": 447.42857142857144,
    "embedding_file_size_mb": 0.025857925415039062
  }
}