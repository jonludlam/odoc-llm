{
  "package": "hardcaml_xilinx_components",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 11,
  "creation_timestamp": "2025-08-14T23:07:37.102576",
  "modules": [
    {
      "module_path": "Xilinx_vhdl.Vhdl.Range_direction",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a type `t` with two variants, `Up` and `Down`, representing range directions in VHDL. It provides comparison, S-expression conversion, and equality checking for these values. This is used to model and manipulate direction indicators in VHDL range declarations.",
      "description_length": 280,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Expression",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a data type for representing VHDL expressions, including literals like integers, floats, and strings, as well as operators and unary negation. It provides comparison and S-expression conversion functions for these expressions. Concrete use cases include parsing and manipulating VHDL code fragments, such as signal assignments or arithmetic expressions in hardware descriptions.",
      "description_length": 398,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Type",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a variant type for representing VHDL data types, including scalar types like `Bit`, `Boolean`, and `Integer`, as well as vector types like `Bit_vector` and `Std_logic_vector` with optional range specifications. It provides comparison and S-expression conversion functions for these types. Concrete use cases include modeling and manipulating VHDL type declarations in a synthesis or analysis toolchain.",
      "description_length": 422,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Port",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a record type representing a port in a VHDL entity, including its name, direction, type, and optional default value. It provides comparison and S-expression conversion functions for working with port data in a structured and serializable format. This is used to model and manipulate hardware interface definitions during VHDL code generation or analysis.",
      "description_length": 374,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Range",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module represents and compares VHDL range expressions, consisting of lower and upper bounds with a direction. It provides direct comparison and S-expression conversion for range values used in hardware description. Concrete use cases include analyzing and transforming signal or array index ranges in VHDL code.",
      "description_length": 316,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Component",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a component structure with name, generics, and ports, supporting comparison and S-expression serialization. It works with lists of port types to model VHDL components. Used for representing and manipulating VHDL component declarations in a structured form.",
      "description_length": 276,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Port_direction",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a type `t` representing port directions in VHDL, with variants `In`, `Inout`, and `Out`. It provides operations to compare, convert to strings, serialize to S-expressions, and check equality for these port directions. This module is used to handle directional attributes of ports in VHDL entities during synthesis or analysis tasks.",
      "description_length": 352,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module provides a suite of data types and operations for modeling VHDL constructs such as range directions, expressions, types, ports, and components. It supports concrete tasks like parsing and transforming VHDL signal ranges, representing hardware port interfaces, and serializing component declarations for use in synthesis or analysis tools. Each submodule handles specific VHDL elements with direct comparison, S-expression conversion, and structured data modeling.",
      "description_length": 475,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl_to_hardcaml",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "Converts a VHDL component declaration into an equivalent OCaml module, enabling hardware descriptions to be used directly in OCaml code. It operates on VHDL component structures and produces string output representing the OCaml module. This is useful for integrating hardware designs written in VHDL with software written in OCaml, particularly in hardware-software co-design workflows.",
      "description_length": 386,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Parse",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "Parses VHDL component definitions from input channels or strings into structured component lists. Works with VHDL syntax to extract component declarations, ports, and types. Used for analyzing or transforming FPGA design files programmatically.",
      "description_length": 244,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "The module provides tools for parsing VHDL component definitions, modeling VHDL constructs, and converting VHDL components into OCaml modules. It works with VHDL syntax structures, including components, ports, types, and expressions, to enable programmatic analysis, transformation, and integration of FPGA designs. Concrete use cases include automated VHDL parsing for design analysis, structured representation of hardware interfaces, and generating OCaml code from VHDL for hardware-software co-design.",
      "description_length": 505,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 505,
    "min_description_length": 244,
    "avg_description_length": 366.1818181818182,
    "embedding_file_size_mb": 0.15983295440673828
  }
}