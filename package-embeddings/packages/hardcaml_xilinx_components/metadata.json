{
  "package": "hardcaml_xilinx_components",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 11,
  "creation_timestamp": "2025-07-15T23:06:33.231884",
  "modules": [
    {
      "module_path": "Xilinx_vhdl.Vhdl.Range",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module represents and compares VHDL range expressions, which consist of a lower bound, a direction, and an upper bound. It provides concrete operations for comparing ranges and converting them to S-expressions. Typical use cases include analyzing or generating VHDL code where range constraints are required, such as in array declarations or subtypes.",
      "description_length": 356,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Type",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a variant type representing fundamental VHDL data types, including scalar types like `Bit`, `Boolean`, and `Integer`, as well as vector types like `Bit_vector` and `Std_logic_vector` that optionally carry range information. It provides `compare` and `sexp_of_t` functions for ordering and serializing these types, enabling use in maps, sets, and debugging output. Concrete use cases include modeling VHDL type declarations and supporting type-checking or transformation passes in a VHDL toolchain.",
      "description_length": 517,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Range_direction",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a type `t` with two variants, `Up` and `Down`, representing range directions in VHDL. It provides comparison, equality checking, and S-expression conversion for these values. This module is used to specify and manipulate directionality in VHDL range declarations, such as in array or loop bounds.",
      "description_length": 316,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Expression",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a type `t` representing various VHDL expression constructs such as literals, identifiers, unary and binary operations, and special values. It includes functions for comparing expressions and converting them to S-expressions, primarily used for parsing, analyzing, and generating VHDL code. Concrete use cases include building and manipulating VHDL abstract syntax trees during hardware description processing.",
      "description_length": 429,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Port_direction",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a type `t` representing port directions in VHDL, with variants `In`, `Inout`, and `Out`. It provides operations to compare, convert to strings, serialize to S-expressions, and check equality for these port directions. This module is used to handle directional properties of hardware ports in VHDL descriptions, such as determining signal flow in component interfaces.",
      "description_length": 387,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Port",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a record type representing a port in a VHDL entity, including its name, direction, type, and optional default value. It provides comparison and S-expression conversion functions for port values. Used to model and manipulate VHDL port declarations in circuit design workflows.",
      "description_length": 295,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl.Component",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module defines a data structure for representing VHDL components, including their names, generics, and ports. It provides operations for comparing components and converting them to S-expressions. This module is used to model and manipulate VHDL component declarations in a structured way.",
      "description_length": 293,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl_to_hardcaml",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "Converts a VHDL component declaration into an equivalent OCaml module, optionally generating code specialized for VHDL simulation. Works directly with VHDL component structures to enable hardware description translation. Useful for integrating VHDL-based hardware designs into OCaml-based toolchains or simulation environments.",
      "description_length": 327,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Parse",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "Parses VHDL component definitions from input channels or strings into structured component data. Works with VHDL syntax to extract component declarations, ports, and generics. Used to analyze or transform FPGA design files by converting raw VHDL into a manipulable in-memory representation.",
      "description_length": 290,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xilinx_vhdl.Vhdl",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module provides a structured representation of VHDL constructs including types, expressions, ranges, and component declarations. It supports modeling and manipulating VHDL code elements such as scalar and vector types, directional ranges, port definitions, and expressions, with built-in comparison and serialization capabilities. Specific use cases include analyzing array bounds, generating type declarations, checking port directions, and building or transforming VHDL component definitions.",
      "description_length": 499,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Xilinx_vhdl",
      "library": "hardcaml_xilinx_components.xilinx_vhdl",
      "description": "This module translates VHDL components into OCaml representations, enabling manipulation and integration into OCaml toolchains. It parses and structures VHDL declarations, ports, and generics, supporting analysis and transformation of FPGA designs. Key data types model VHDL constructs like types, ranges, and expressions, allowing operations such as array bound analysis, type generation, and port direction checks. Example uses include converting VHDL components to OCaml modules, extracting design metadata, and programmatically modifying hardware descriptions.",
      "description_length": 564,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 564,
    "min_description_length": 290,
    "avg_description_length": 388.45454545454544,
    "embedding_file_size_mb": 0.04040241241455078
  }
}