{
  "package": "dunolint",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 50,
  "creation_timestamp": "2025-08-15T14:45:25.022618",
  "modules": [
    {
      "module_path": "Dunolinter.Sexp_handler.Make_atom",
      "library": "dunolint.dunolinter",
      "description": "This module creates a handler for a dune file field that expects exactly one required argument as an `Sexp.Atom`. It provides functions to read, write, and rewrite the field value as a string, ensuring correct sexp formatting and location handling for errors. It is used for managing simple atomic fields in dune stanzas, such as flags or single-value configuration entries.",
      "description_length": 374,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Sexp_handler.Make_sexpable",
      "library": "dunolint.dunolinter",
      "description": "This module creates a handler for a specific field in a dune stanza, using a sexpable type to parse and rewrite its value. It works with S-expressions representing individual fields and their arguments, ensuring correct serialization and deserialization. It is used to read, write, and refactor dune file fields such as those in existing stanzas or when introducing new ones.",
      "description_length": 375,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Private.Stanza",
      "library": "dunolint.dunolinter",
      "description": "This module defines operations for constructing and transforming stanza values, primarily through the `create` function which builds a finalized stanza from a configuration structure. It works with abstract stanza types and their configuration representations to enforce correct assembly. Concrete use cases include validating and initializing structured configuration blocks used in Dune file processing.",
      "description_length": 405,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Sexp_handler.Make_sexps",
      "library": "dunolint.dunolinter",
      "description": "Handles reading, writing, and rewriting of generic fields in dune stanzas without parsing their arguments. It operates on S-expressions represented as `Base.Sexp.t` lists, preserving their structure while enabling manipulation of fields like `library` or `executable` in dune files. Useful for tools like `dunolint` to introduce or update fields in existing dune files while maintaining correct syntax and location information for errors.",
      "description_length": 438,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolinter.Private",
      "library": "dunolint.dunolinter",
      "description": "This module handles the construction and transformation of stanza values, centered around the `create` function that assembles finalized stanzas from configuration structures. It operates on abstract stanza types and their corresponding configuration data to ensure valid composition. It is used to validate and initialize structured configuration blocks during Dune file processing.",
      "description_length": 383,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Linters",
      "library": "dunolint.dunolinter",
      "description": "This module implements a linter registry that maps field names to linter functions using a sorted list for efficient binary search. It provides operations to create a registry from a list of linters and to look up a linter by field name. The module is used to validate and process configuration fields in a structured and performant way.",
      "description_length": 337,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Linter",
      "library": "dunolint.dunolinter",
      "description": "This module defines a linter interface with operations to evaluate and enforce conditions on code structures. It works with predicates and boolean expressions over those predicates, using custom logic to determine enforcement behavior. Concrete use cases include validating naming conventions, structural constraints, or code patterns during static analysis.",
      "description_length": 358,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Stanza_linter",
      "library": "dunolint.dunolinter",
      "description": "This module defines a linter for processing and validating individual stanzas in configuration files. It provides functions to check stanza structure, validate field values, and report errors or warnings based on predefined rules. It operates on stanza data types representing parsed configuration entries, enabling precise analysis and feedback during configuration parsing.",
      "description_length": 375,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Handler",
      "library": "dunolint.dunolinter",
      "description": "This module evaluates and enforces predicates during linting, handling cases where enforcement is requested but not semantically defined. It works with predicate types defined in the `Dunolinter.Handler.Predicate` module and uses `Loc.t` for source location tracking. Concrete use cases include reporting enforce failures as errors while continuing linting, or raising exceptions to halt execution in test contexts.",
      "description_length": 415,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter.Sexp_handler",
      "library": "dunolint.dunolinter",
      "description": "Handles reading, writing, and rewriting of fields in dune stanzas by processing S-expressions as lists of `Base.Sexp.t`. Works with atomic fields via `Make_atom` for single-value entries and generic Sexp-based fields via `Make_sexps` for structured manipulation. Used to enforce correct field formatting, update values, and insert missing fields in dune files during linting, such as adjusting flags or restructuring stanzas.",
      "description_length": 425,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolinter",
      "library": "dunolint.dunolinter",
      "description": "This module implements a configurable linter for Dune configuration files, providing structured validation and rewriting of stanzas based on semantic predicates. It supports operations such as predicate enforcement, field manipulation via S-expressions, and efficient linter registration and lookup. Concrete use cases include enforcing naming conventions, validating stanza structure, rewriting dune flags, and inserting or correcting missing configuration fields during static analysis.",
      "description_length": 488,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_cli",
      "library": "dunolint.dunolint_cli",
      "description": "Handles command-line interface logic for the Dunolint tool. Defines the `main` command that processes user input and triggers linting operations. Works with abstract syntax trees and configuration files to enforce code style rules in OCaml projects.",
      "description_length": 249,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Library.Private",
      "library": "dunolint.dune_linter",
      "description": "Performs in-place rewriting of Dune library fields using a provided sexp rewriter. It operates on Dune library values and S-expressions, enabling transformations of specific fields within library definitions. Useful for modifying Dune files programmatically during build configuration or linting processes.",
      "description_length": 306,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Executable.Private",
      "library": "dunolint.dune_linter",
      "description": "This module provides a `rewrite` function that modifies executable configurations by integrating existing library dependencies into the in-memory representation before applying a sexp-based transformation. It operates on `Dune_linter.Executable.t` values and uses a `Sexps_rewriter.t` to process individual fields. The function is used internally to adjust dune configuration files during linting or refactoring tasks, specifically to handle library references that must be resolved before rewriting.",
      "description_length": 500,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Pps.Arg",
      "library": "dunolint.dune_linter",
      "description": "This module defines and compares command-line arguments for preprocessors, handling both simple preprocessor names and flag-value pairs. It supports exact equality checks and S-expression serialization for structured data representation. Use cases include validating and transforming preprocessor configurations in Dune files, particularly for linters and build system extensions.",
      "description_length": 380,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Library.Linter",
      "library": "dunolint.dune_linter",
      "description": "This module evaluates and enforces linter rules over Dune configuration files using predicates and rule definitions. It processes `Dunolint.Trilang.t` structures to represent linter conditions and applies them to Dune libraries. Concrete use cases include validating build configurations and enforcing project-specific Dune file conventions during CI checks.",
      "description_length": 358,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Library.Public_name",
      "library": "dunolint.dune_linter",
      "description": "This module handles the creation, parsing, rewriting, and evaluation of public name fields in Dune library stanzas. It works with s-expressions and custom types representing public names and predicates, enabling precise manipulation and validation of Dune file fields. Concrete use cases include reading and validating existing public name fields, rewriting them during linting, and enforcing naming policies based on logical conditions.",
      "description_length": 437,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Executable.Linter",
      "library": "dunolint.dune_linter",
      "description": "This module evaluates and enforces linting rules over Dune executable configurations using predicates and boolean logic. It operates on `t` values representing linters and `predicate` functions that match against Dune expressions. Concrete use cases include validating build configurations and ensuring consistent Dune file structures based on custom rules.",
      "description_length": 357,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Executable.Name",
      "library": "dunolint.dune_linter",
      "description": "This module handles the creation, parsing, and rewriting of executable name fields in Dune files. It works with S-expressions and provides functions to read, write, and refactor name fields within existing stanzas using a sexps rewriter. It supports evaluating and enforcing name-based predicates for linting and transformation workflows.",
      "description_length": 338,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Library.Name",
      "library": "dunolint.dune_linter",
      "description": "This module handles the creation, parsing, and manipulation of library name fields in Dune configuration files. It provides functions to read, write, and rewrite library names as S-expressions, ensuring correct formatting and integration with existing stanzas. It supports evaluating and enforcing predicates against library names to validate or alter their structure during linting or transformation processes.",
      "description_length": 411,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Executable.Public_name",
      "library": "dunolint.dune_linter",
      "description": "This module manages the public name field of an executable stanza in a Dune file. It supports creating, parsing, writing, and rewriting the public name value as an S-expression, ensuring correct structure and location tracking for error reporting. It also allows evaluating and enforcing predicates on the public name, used for linting rules that check or modify existing Dune files.",
      "description_length": 383,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Libraries.Entry",
      "library": "dunolint.dune_linter",
      "description": "This module represents individual entries in a list of library dependencies, typically used in Dune configuration stanzas like `library` or `executable`. It provides operations to construct entries from library names and convert them to S-expressions for serialization. Direct use cases include defining and serializing library dependencies in Dune linting or analysis tools.",
      "description_length": 375,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Lint",
      "library": "dunolint.dune_linter",
      "description": "This module manages the configuration of linters in Dune stanzas by parsing, creating, and rewriting the `\"lint\"` field in s-expressions. It supports operations to read, write, and refactor linter settings, and evaluates or enforces linter rules based on predicates. It works directly with s-expressions and linter configuration data to ensure correct formatting and rule application during Dune file processing.",
      "description_length": 412,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Library",
      "library": "dunolint.dune_linter",
      "description": "This module defines and manipulates Dune library configurations through structured S-expressions. It supports creating, reading, rewriting, and validating library fields such as name, public name, dependencies, and linting rules. Concrete use cases include enforcing naming conventions, modifying library dependencies in existing Dune files, and validating library stanzas during automated linting or project refactoring.",
      "description_length": 421,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Preprocess",
      "library": "dunolint.dune_linter",
      "description": "This module handles preprocessing configurations in Dune stanzas, supporting operations to create, parse, write, and rewrite preprocessor settings. It works with s-expressions and tracks preprocessor flags and their locations for accurate error reporting. It is used to enforce and evaluate preprocessing rules in Dune files during linting.",
      "description_length": 340,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Libraries",
      "library": "dunolint.dune_linter",
      "description": "This module manages library dependencies in Dune configuration stanzas, handling creation, parsing, rewriting, and serialization of library lists. It works with S-expressions and library name lists, providing direct operations for modifying and querying dependencies in linting or configuration tools. Concrete use cases include updating library stanzas in Dune files during automated refactoring or enforcing dependency rules in analysis pipelines.",
      "description_length": 449,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dune_linter.Instrumentation",
      "library": "dunolint.dune_linter",
      "description": "This module handles the instrumentation settings for Dune stanzas, primarily working with S-expressions and custom types for instrumentation backends and predicates. It provides operations to create, parse, evaluate, and rewrite instrumentation fields, ensuring correct integration with Dune files. Concrete use cases include initializing instrumentation when missing, validating existing fields, and refactoring them during linting or automated fixes.",
      "description_length": 452,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Flags",
      "library": "dunolint.dune_linter",
      "description": "This module manages OCaml compiler flags represented as S-expressions. It supports creating, parsing, rewriting, and evaluating flags within Dune configuration stanzas, handling both initial field creation and in-place modifications. Use cases include linting Dune files by enforcing or evaluating compiler flag policies, and refactoring existing Dune configurations while preserving source locations for accurate error reporting.",
      "description_length": 430,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Pps",
      "library": "dunolint.dune_linter",
      "description": "This module handles the configuration and manipulation of preprocessors specified in Dune files, working with a custom type `t` that represents preprocessor settings. It provides operations to create, parse, serialize, and evaluate preprocessor configurations, supporting both new field insertion and in-place rewriting within existing Dune stanzas. Concrete use cases include validating preprocessor arguments, enforcing linter configurations, and refactoring Dune files during automated build system updates.",
      "description_length": 510,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dune_linter.Executable",
      "library": "dunolint.dune_linter",
      "description": "This module defines an executable configuration type with fields for name, public name, flags, libraries, and linting settings. It provides operations to create, parse, rewrite, and evaluate executable stanzas using S-expressions, supporting linting rules through predicate enforcement. It is used to validate and modify Dune files during static analysis or automated refactoring tasks.",
      "description_length": 386,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter.Stanza",
      "library": "dunolint.dune_linter",
      "description": "This module defines a private extensible type `t` for representing Dune stanza syntax trees. It provides functions to parse, manipulate, and analyze individual stanzas in Dune configuration files. Concrete use cases include linting Dune files for correctness and transforming stanza structures during build configuration processing.",
      "description_length": 332,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_linter",
      "library": "dunolint.dune_linter",
      "description": "This module processes Dune configuration files for linting and automated refactoring. It parses Dune stanzas into structured S-expressions, allowing inspection, modification, and rewriting of build configurations while preserving source locations for accurate error reporting. Concrete use cases include enforcing compiler flag policies, updating library dependencies, validating instrumentation settings, and rewriting preprocessor configurations directly within Dune files.",
      "description_length": 475,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint_vendor_git_pager.Git_pager",
      "library": "dunolint.vendor_git_pager",
      "description": "This module manages the execution of Git commands with color output handling and a pager. It provides a way to determine if colors should be forced and writes output to a channel, supporting scenarios like displaying diffs with consistent color formatting. The module is used to replicate Git's behavior when showing colored diffs through a pager programmatically.",
      "description_length": 364,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_vendor_git_pager",
      "library": "dunolint.vendor_git_pager",
      "description": "This module determines whether to force color output for Git commands and writes formatted content to a channel, typically used for displaying diffs through a pager. It handles scenarios where color consistency is required when piping output, such as when showing Git diffs with colors enabled. The module works directly with output channels and environment settings to replicate Git's built-in pager behavior in OCaml programs.",
      "description_length": 428,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Generate_opam_files.Linter",
      "library": "dunolint.dune_project_linter",
      "description": "This module evaluates and enforces conditions on Dune project configurations using predicates. It works with `Dunolint.Trilang.t` and `Dunolint.Std.Blang.t` to express and check constraints on project metadata. Concrete use cases include validating opam file generation rules and ensuring consistency in package definitions across a project.",
      "description_length": 341,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dune_project_linter.Implicit_transitive_deps.Linter",
      "library": "dunolint.dune_project_linter",
      "description": "This module evaluates and enforces rules related to implicit transitive dependencies in Dune projects. It works with predicate and rule types defined in the `Dunolint` ecosystem, specifically `Dunolint.Std.Dune_project.Predicate.t` and `Dune_project_linter.Implicit_transitive_deps.t`. Use it to define and apply constraints on dependency visibility and propagation within Dune project configurations.",
      "description_length": 401,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Name.Linter",
      "library": "dunolint.dune_project_linter",
      "description": "This module evaluates and enforces naming rules for Dune projects using predicates and linters. It operates on Dune project names and predicates, applying checks to ensure naming conventions are met. Concrete use cases include validating that library or executable names follow specific patterns, such as requiring lowercase or prefixing with a project identifier.",
      "description_length": 364,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Name",
      "library": "dunolint.dune_project_linter",
      "description": "This module manages Dune project name fields, providing operations to create, read, write, and rewrite name values within S-expressions. It supports validation through predicates and enforces naming rules by integrating with a linter, ensuring names meet specific criteria such as lowercase formatting or prefix requirements. Use cases include validating and standardizing names for libraries or executables in Dune project files.",
      "description_length": 430,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Generate_opam_files",
      "library": "dunolint.dune_project_linter",
      "description": "This module manages the generation and manipulation of opam file configuration stanzas within Dune projects. It provides operations to create, read, write, and rewrite structured field values, specifically handling S-expressions to maintain and validate project metadata. It is used to enforce consistency in opam generation rules and evaluate constraints against project configuration data.",
      "description_length": 391,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Implicit_transitive_deps",
      "library": "dunolint.dune_project_linter",
      "description": "This module manages implicit transitive dependency rules in Dune project configurations. It supports creating, parsing, evaluating, and rewriting dependency enforcement policies using S-expressions, working directly with `Dunolint.Std.Dune_project.Implicit_transitive_deps.Predicate.t` and related rule types. Use it to define and validate dependency visibility constraints in Dune files, ensuring correct propagation behavior during project analysis or linting workflows.",
      "description_length": 472,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter.Stanza",
      "library": "dunolint.dune_project_linter",
      "description": "This module defines a private extensible type `t` used to represent and process individual stanzas in a Dune project configuration. It provides operations for parsing, validating, and manipulating stanza data, such as checking stanza structure and extracting key-value pairs. Concrete use cases include linting Dune files for syntax correctness and enforcing project configuration rules during build analysis.",
      "description_length": 409,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dune_project_linter",
      "library": "dunolint.dune_project_linter",
      "description": "This module processes Dune project configuration stanzas, enabling structured manipulation of S-expressions for specific project rules. It works directly with Dune project files, handling data types like `Stanza.t`, `Sexps_rewriter.t`, and `File_rewriter.t` to enforce constraints and perform linting operations. Concrete use cases include validating Dune file syntax, enforcing naming conventions, and managing opam file generation and dependency visibility rules during project analysis or linting workflows.",
      "description_length": 510,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_vendor_prompt.Prompt.Choice",
      "library": "dunolint.vendor_prompt",
      "description": "This module represents a single choice in a terminal prompt, consisting of a character input and an associated value. It supports marking a choice as the default option for a prompt. Use it to define selectable options when prompting users for input in command-line interfaces.",
      "description_length": 277,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_vendor_prompt.Prompt.Arg",
      "library": "dunolint.vendor_prompt",
      "description": "Handles command-line argument parsing for user prompts, providing typed access to input values. Works with basic data types like strings, integers, and booleans through Cmdlang's argument definitions. Used to extract and validate user-provided values in interactive terminal sessions.",
      "description_length": 284,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_vendor_prompt.Prompt",
      "library": "dunolint.vendor_prompt",
      "description": "This module provides functions to interactively prompt users for input in terminal applications. It supports asking for free-form answers, yes/no responses, and selecting from predefined choices, with validation and optional default values. The module works with strings, boolean values, and choice-based enumerations, integrating with command-line argument parsing for typed input handling. It is suitable for building interactive CLI tools that require user confirmation, selection, or data entry.",
      "description_length": 499,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_vendor_prompt",
      "library": "dunolint.vendor_prompt",
      "description": "This module enables interactive user input in terminal applications, offering functions to prompt for free-form text, boolean responses, and selections from predefined options. It supports input validation, default values, and typed handling of strings, booleans, and enumerated choices. It is ideal for building command-line tools that require user interaction for configuration, confirmation, or data entry tasks.",
      "description_length": 415,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_engine.Config.Running_mode",
      "library": "dunolint.dunolint_engine",
      "description": "This module defines a variant type `t` representing different running modes for a linter, including `Dry_run`, `Check`, `Force_yes`, and `Interactive`. It provides comparison, equality, and S-expression conversion functions for this type. These operations support configuration handling and mode-based decision making in linter execution workflows.",
      "description_length": 348,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_engine.Visitor_decision",
      "library": "dunolint.dunolint_engine",
      "description": "This module defines a set of decisions made during the traversal of a repository, controlling whether to break, continue, or skip subtrees. It works with directory structures and is used to manage iteration behavior in a visitor pattern. Concrete use cases include selectively skipping directories during code analysis or halting traversal upon finding specific conditions.",
      "description_length": 373,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_engine.Config",
      "library": "dunolint.dunolint_engine",
      "description": "This module defines a configuration type `t` with a default value and command-line argument integration. It includes a submodule `Running_mode` that defines a variant type `t` for linter execution modes such as `Dry_run`, `Check`, `Force_yes`, and `Interactive`. Functions provided include creating a configuration with a specified running mode and retrieving the current mode from a configuration, enabling mode-based control in linter workflows.",
      "description_length": 447,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint_engine",
      "library": "dunolint.dunolint_engine",
      "description": "This module processes and enforces linting rules across Dune project files and directories. It supports traversing directory structures with conditional control over subdirectories, applying linting and formatting operations to individual files, and optionally rewriting or creating files based on linter decisions. Concrete use cases include validating and autoformatting `dune` and `dune-project` files, enforcing project-wide code standards, and selectively skipping or halting traversal based on directory content.",
      "description_length": 518,
      "index": 49,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 52,
    "meaningful_modules": 50,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9615384615384616
  },
  "statistics": {
    "max_description_length": 518,
    "min_description_length": 249,
    "avg_description_length": 398.9,
    "embedding_file_size_mb": 0.7249441146850586
  }
}