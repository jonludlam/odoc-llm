{
  "package": "swipl",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 12,
  "creation_timestamp": "2025-08-14T23:18:43.425293",
  "modules": [
    {
      "module_path": "Bindings.Stubs.Q",
      "library": "bindings",
      "description": "This module defines integer constants used to configure behavior in a runtime or evaluation context, such as exception handling and execution flags. Each value represents a specific option or mode, like enabling exception catching or allowing yielding. These constants are used directly in low-level operations to control evaluation semantics.",
      "description_length": 343,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.Result",
      "library": "bindings",
      "description": "This module defines integer constants representing specific result states, including exception, false, true, and last. These constants are used to indicate outcome statuses in low-level operations or system interfaces. They provide a standardized way to handle and check result codes in bindings or stub implementations.",
      "description_length": 320,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.VersionInfo",
      "library": "bindings",
      "description": "This module defines constant integer values representing version numbers for various system components, including the operating system, file interface, record management, query language, and virtual machine. These constants are used to specify or check compatibility of data formats and APIs in low-level system interactions. Concrete use cases include ensuring correct version matching when loading compiled modules or validating file structures during serialization.",
      "description_length": 468,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.File",
      "library": "bindings",
      "description": "This module defines constants representing file operations such as checking existence, reading, writing, executing, and resolving paths. It works with integer-based constants to specify file access modes and behaviors. These values are used directly in system call bindings to control file handling in low-level operations.",
      "description_length": 323,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.Database",
      "library": "bindings",
      "description": "This module defines constants used to specify database operation modes, such as inserting facts at the end or beginning, and creating thread-local or incremental databases. It works with integer-based constants that correspond to different database behaviors. These values are used directly in database configuration and fact insertion functions to control execution and storage semantics.",
      "description_length": 389,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bindings.Stubs.CVT",
      "library": "bindings",
      "description": "This module defines integer constants representing various type tags and serialization modes used in low-level data conversion and marshaling operations. It works with abstract data types that require explicit tagging for type identification and encoding during binary serialization. These values are used directly in functions that handle custom binary formats, such as writing specific value types to memory buffers or controlling output formatting for canonical or quoted representations.",
      "description_length": 491,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.Action",
      "library": "bindings",
      "description": "This module defines integer constants representing specific runtime actions and configuration options for memory management. It provides direct mappings to system-level operations such as tracing, debugging, halting, and controlling output behavior. These values are used to configure or trigger specific behaviors in low-level execution contexts, such as setting memory allocation functions or controlling console attachment.",
      "description_length": 426,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs.Term",
      "library": "bindings",
      "description": "This module defines constants representing different Prolog term types, such as variables, atoms, integers, floats, lists, and dictionaries. It provides direct mappings to internal Prolog type identifiers for term inspection and manipulation. These constants are used when interacting with Prolog terms at a low level, such as in foreign function interfaces or term traversal logic.",
      "description_length": 382,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings.Stubs",
      "library": "bindings",
      "description": "This module provides constants for low-level system interactions, including term types, type tags, runtime flags, result codes, database modes, file operations, memory actions, and version identifiers. It works directly with integer-based constants and abstract data types to configure behavior in foreign function interfaces, serialization, and execution contexts. Concrete use cases include controlling fact insertion in databases, specifying file access modes, handling result states in bindings, and ensuring version compatibility in compiled module loading.",
      "description_length": 562,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bindings",
      "library": "bindings",
      "description": "This module defines constants for configuring low-level system behavior, such as term types, runtime flags, file operations, and version identifiers. It works with integer constants and abstract types to control database modes, fact insertion, and result handling in foreign interfaces. Use cases include setting file access modes, managing serialization formats, and ensuring compatibility during module loading.",
      "description_length": 413,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Swipl.Syntax",
      "library": "swipl.swipl",
      "description": "This module provides operators to build Prolog terms and queries using OCaml syntax, including creating atoms, function applications, and logical conjunctions or disjunctions. It works with Prolog terms (`Swipl.t`), function names (`Swipl.fn`), and optional module qualifiers. Concrete use cases include writing Prolog expressions directly in OCaml code, such as constructing queries with `&&` for conjunction or `/@` to declare predicates with arity.",
      "description_length": 451,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Swipl",
      "library": "swipl.swipl",
      "description": "This module enables creating and manipulating Prolog terms (atoms, lists, compound terms) and evaluating Prolog queries with support for solution iteration, folding, and context management. It operates on Prolog terms (`Swipl.t`) within a context (`Swipl.ctx`), providing type-safe extraction of values (integers, strings, booleans) and compound structures from Prolog to OCaml. It is particularly useful for embedding logic programming capabilities into OCaml applications, querying Prolog databases, and bidirectionally transforming structured data between the two languages.",
      "description_length": 577,
      "index": 11,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 12,
    "meaningful_modules": 12,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 577,
    "min_description_length": 320,
    "avg_description_length": 428.75,
    "embedding_file_size_mb": 0.17435359954833984
  }
}