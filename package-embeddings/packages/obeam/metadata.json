{
  "package": "obeam",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 10,
  "creation_timestamp": "2025-08-14T23:12:44.504558",
  "modules": [
    {
      "module_path": "Obeam.Parser.Combinator",
      "library": "obeam",
      "description": "This module implements parser combinators for constructing complex parsers from simpler components, using function composition and sequencing. It operates on input represented as tuples of state and remaining data, typically used for parsing binary formats or structured byte streams. Functions like `repeat`, `list`, and the sequencing operators `>>` and `>>=` enable parsing of variable-length structures, transformations, and conditional parsing logic.",
      "description_length": 455,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Aux.Z",
      "library": "obeam",
      "description": "This module implements a comprehensive set of operations for arbitrary-precision integers (`Z.t`), encompassing arithmetic (addition, multiplication, division with various rounding modes), bitwise manipulation (shifting, logical operations), and advanced number-theoretic functions (GCD, primality testing, modular exponentiation). It supports conversions between integers, strings, and fixed-size numeric types (32/64-bit, floats) with precise handling of sign, overflow, and base representations, catering to cryptographic protocols, mathematical research, and system-level numeric validation. The design emphasizes correctness for edge cases (e.g., division by zero, side-channel resistance) and provides utilities for comparison, formatting, and random generation in high-precision contexts.",
      "description_length": 795,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Abstract_format",
      "library": "obeam",
      "description": "This module enables bidirectional conversion between abstract syntax tree (AST) elements\u2014like expressions, patterns, literals, and type specifications\u2014and S-expressions (via `Sf.t`) for serialization, debugging, and structured data interchange. It handles parsing with error tracking and validation, returning result-wrapped values to ensure robust type-safe transformations. Key use cases include deserializing External Term Format (ETF) data into typed AST nodes and generating human-readable or machine-processable representations of code structures.",
      "description_length": 553,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Beam",
      "library": "obeam",
      "description": "This module provides binary parsing operations for BEAM file format chunks, converting byte buffers into structured layouts with metadata. It operates on `Bitstring.t` buffers to extract specific chunk types like atoms, code sections, imports, and debug information, returning typed representations paired with remaining buffer data. These functions enable analysis or transformation of BEAM files by exposing low-level binary structures in a usable format.",
      "description_length": 457,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Simple_term_format",
      "library": "obeam",
      "description": "This module defines a data type for representing Erlang terms in a simplified format, including integers, atoms, tuples, maps, strings, binaries, big integers, lists, and floats. It provides functions to convert these terms to S-expressions and to construct them from an external term format. Use this module when parsing or serializing Erlang terms for communication or storage.",
      "description_length": 379,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Aux",
      "library": "obeam",
      "description": "This module implements precise bit-level layout calculations for binary data serialization, providing alignment and padding computations for memory buffers. It handles low-level operations on byte sequences and bitstrings, with functions to calculate content sizes in bits or bytes and skip padding regions in binary streams. Concrete use cases include parsing and constructing binary file formats, network protocols, and memory-mapped data structures requiring strict alignment constraints.",
      "description_length": 491,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Parser",
      "library": "obeam",
      "description": "This module implements parser combinators for building complex parsers by composing and sequencing simpler functions. It processes input as state and data tuples, ideal for parsing binary or structured byte streams. Use it to handle variable-length data, transform parsed values, or implement conditional parsing logic with operators like `>>`, `>>=`, `repeat`, and `list`.",
      "description_length": 373,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Obeam.Err",
      "library": "obeam",
      "description": "This module defines operations for constructing and manipulating error values with location and backtrace information. It provides functions to create errors, wrap existing errors with additional context, and record source positions for debugging. The module works with error types parameterized over a kind, supporting structured error reporting in compilers or interpreters where precise error locations and causes are critical.",
      "description_length": 430,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.External_term_format",
      "library": "obeam",
      "description": "This module defines a type `t` representing Erlang External Term Format (ETF) values, including integers, floats, atoms, tuples, maps, lists, binaries, and big numbers. It provides functions to parse ETF data from bitstrings, handle compression, and convert terms to S-expressions for debugging or serialization. Concrete use cases include decoding and encoding Erlang terms for network transmission or file storage, and inspecting ETF structures in a readable format.",
      "description_length": 468,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam",
      "library": "obeam",
      "description": "This module provides precise bit-level layout calculations and low-level operations for binary data serialization, handling alignment, padding, and size computations. It works with byte sequences and bitstrings to support parsing and constructing binary formats requiring strict memory layout constraints. Concrete use cases include working with binary file formats, network protocols, and memory-mapped data structures.",
      "description_length": 420,
      "index": 9,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 10,
    "meaningful_modules": 10,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 795,
    "min_description_length": 373,
    "avg_description_length": 482.1,
    "embedding_file_size_mb": 0.14532756805419922
  }
}