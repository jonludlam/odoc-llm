{
  "package": "obeam",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 9,
  "creation_timestamp": "2025-06-18T16:33:38.379724",
  "modules": [
    {
      "module_path": "Obeam.Aux.Z",
      "description": "provides a set of arithmetic operations and conversions for arbitrary-precision integers, with support for 2's complement bit manipulation and overflow handling. It introduces a type t with redefined operators for intuitive expression writing, such as Z.(~$2 + ~$5 * ~$10). Functions enable seamless conversion between t and standard integer types, raising exceptions when values exceed representable ranges. It enhances the toplevel experience with custom syntax and operator overloading.",
      "description_length": 489,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Obeam.Parser.Combinator",
      "description": "Provides operations for sequencing and transforming results that carry a state tuple, including repeating actions, combining functions, and mapping over values within a stateful context. Works with functions that take a state tuple and return a result containing a new state and a value. Used to build complex stateful workflows, such as parsing sequences or processing lists while maintaining context.",
      "description_length": 402,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Aux",
      "description": "provides arithmetic and bit manipulation capabilities for arbitrary-precision integers, with a type t supporting overloaded operators for intuitive expressions. It includes conversions between t and standard integers, with overflow detection and exception raising. Operations like addition, multiplication, and 2's complement bit manipulation are directly supported. Examples include Z.(~$2 + ~$5 * ~$10) and converting t values to and from int.",
      "description_length": 445,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Beam",
      "description": "This module handles parsing and structuring binary data through operations that decode specific chunk formats, such as imports, functions, and debug information, from byte sequences using offset-based processing. It works with byte arrays, integer offsets, and abstract representations of program components, enabling structured analysis of low-level data layouts. Use cases include binary format interpretation, program inspection, and debugging, particularly in contexts like compiler outputs or serialized execution environments.",
      "description_length": 532,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Err",
      "description": "Converts error values and their kinds to S-expressions, constructs errors with location metadata, records backtraces at specific source positions, and wraps errors with additional context. Operates on polymorphic error types and their associated kind types. Used to serialize error diagnostics, track error origins in code, and enhance error messages with contextual information.",
      "description_length": 379,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Parser",
      "description": "Sequences and transforms results within a stateful context, enabling complex workflows by combining functions, repeating actions, and mapping over values while tracking state. Operates on functions that accept a state tuple and return a result with a new state and value. Supports building parsers for sequences, processing lists with context, or managing state transitions. Examples include parsing nested expressions or accumulating results during traversal.",
      "description_length": 460,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam.Simple_term_format",
      "description": "The module provides a foundation for term formatting with basic type definitions and utility functions. It includes a `t` type for representing formatted terms and operations like `empty` for creating blank terms. Functions such as `append` and `render` allow combining and converting terms to strings. It supports simple formatting tasks like adding spaces or newlines to term sequences.",
      "description_length": 388,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "obeam",
      "description": "Parses BEAM format and Erlang External Term Format, extracting structured data such as atoms, integers, and tuples. Processes binary data and nested term structures common in Erlang bytecode. Enables inspection and analysis of compiled Erlang modules for debugging or interoperability tasks.",
      "description_length": 291,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obeam",
      "description": "provides arithmetic and bit manipulation for arbitrary-precision integers, binary data parsing, error handling with context, and term formatting, along with stateful result sequencing. it includes types like t for big integers, abstract program components for binary decoding, polymorphic errors with location tracking, and formatted terms with append and render operations. users can perform expressions like Z.(~$2 + ~$5 * ~$10), parse binary structures, track error origins, and build formatted output. it also supports stateful workflows for complex processing tasks.",
      "description_length": 571,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 18,
    "meaningful_modules": 9,
    "filtered_empty_modules": 9,
    "retention_rate": 0.5
  },
  "statistics": {
    "max_description_length": 571,
    "min_description_length": 291,
    "avg_description_length": 439.6666666666667,
    "embedding_file_size_mb": 0.033135414123535156
  }
}