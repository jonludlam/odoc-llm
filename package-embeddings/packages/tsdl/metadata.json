{
  "package": "tsdl",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 34,
  "creation_timestamp": "2025-07-15T23:12:33.831210",
  "modules": [
    {
      "module_path": "Tsdl.Sdl.Haptic.Direction",
      "library": "tsdl",
      "description": "This module defines operations for creating and inspecting haptic direction values used in force feedback effects. It works with 3D direction vectors represented as three `int32` components, along with a `direction_type` that specifies the direction's coordinate system (e.g., cartesian or polar). These values are used to configure directional effects in haptic devices, such as defining the direction of a rumble or vibration in game controllers.",
      "description_length": 448,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Point",
      "library": "tsdl",
      "description": "This module provides functions to create and manipulate 2D points with integer coordinates. It supports operations to set and retrieve the x and y components of a point. Concrete use cases include representing screen coordinates, handling mouse input positions, and managing 2D game entity locations.",
      "description_length": 300,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Renderer",
      "library": "tsdl",
      "description": "This module manages 2D rendering operations, including creating and configuring renderers, clearing screens, drawing primitives, and presenting rendered frames. It works with textures and surfaces to enable image manipulation and display. Concrete use cases include rendering game graphics, UI elements, and visual effects in applications using SDL.",
      "description_length": 349,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Event",
      "library": "tsdl",
      "description": "This module provides operations for event handling and introspection, including creating and accessing SDL event structures, retrieving event-specific data (e.g., input states, coordinates, device IDs), and distinguishing event categories via typed constants. It operates on `Tsdl.Sdl.Event.t` and related field types to support structured access to input devices (keyboard, mouse, joystick, touch), window lifecycle events, system notifications, and application lifecycle management. Specific use cases include processing game controller input, handling window resizing or focus changes, capturing text input, and responding to sensor or gesture events in multimedia applications.",
      "description_length": 681,
      "index": 3,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Tsdl.Sdl.Color",
      "library": "tsdl",
      "description": "This module directly manages color values used in SDL rendering operations. It provides functions to create, access, and modify individual RGBA components of a color, each represented as an 8-bit unsigned integer. Use this module when setting pixel colors, configuring render draw colors, or manipulating color values for textures and surfaces in SDL-based applications.",
      "description_length": 370,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Kmod",
      "library": "tsdl",
      "description": "This module defines constants representing keyboard modifier keys such as shift, control, alt, and gui (e.g., Windows key), each available as left, right, or combined variants. It works with the `keymod` type to indicate which modifier keys are pressed during input events. These values are used directly in event handling to check for modifier key states, such as detecting if a key combination like Ctrl+S is pressed.",
      "description_length": 419,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Flip",
      "library": "tsdl",
      "description": "This module defines flip operations for SDL rendering, specifically combining and applying horizontal and vertical flips. It works with the `flip` type to represent individual or combined flip states. Use it to control sprite or texture orientation during rendering, such as flipping images for character movement direction or animation effects.",
      "description_length": 345,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Frect",
      "library": "tsdl",
      "description": "This module provides operations to create and manipulate floating-point rectangles with fields for position (x, y) and dimensions (width, height). It supports setting and retrieving individual components of a rectangle, enabling precise geometric definitions for 2D rendering or collision detection. Concrete use cases include defining screen regions for drawing or hitbox areas in games.",
      "description_length": 388,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Haptic",
      "library": "tsdl",
      "description": "This module enables precise control over haptic feedback devices by configuring effects like periodic waveforms, condition-based forces, and custom vibration patterns. It supports operations to define effect parameters including direction, magnitude, duration, and waveform data, allowing applications to simulate physical interactions through vibration or resistance. The module includes submodules for handling directional effects using 3D vectors and coordinate systems, making it possible to specify directional haptic output for devices such as game controllers. For example, you can create a sine wave vibration with a specific direction and envelope, or configure a spring force effect with adjustable resistance parameters.",
      "description_length": 731,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Gl",
      "library": "tsdl",
      "description": "This module provides functions to configure and query OpenGL contexts and framebuffer attributes, using types like context flags, profiles (core, compatibility, ES), and pixel format settings. It operates on attribute descriptors to manage properties such as version, stereo rendering, multisampling, and context sharing. These tools are used to initialize and inspect OpenGL rendering contexts for applications requiring specific visual features or compatibility settings.",
      "description_length": 473,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Button",
      "library": "tsdl",
      "description": "This module defines integer constants representing mouse button identifiers and bitmask values for SDL mouse events. It provides direct mappings to SDL's `SDL_BUTTON_*` constants, such as left, middle, right, x1, and x2 mouse buttons, along with their corresponding bitmask values. These constants are used to detect and handle specific mouse button presses and releases within SDL event loops.",
      "description_length": 394,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Texture",
      "library": "tsdl",
      "description": "This module manages GPU textures for rendering operations, supporting creation, manipulation, and access control. It works with texture objects, access modes (`access_static`, `access_streaming`, `access_target`), and modulation flags (`modulate_color`, `modulate_alpha`). Concrete uses include loading images for display, setting up render targets, and adjusting texture blending during 2D rendering.",
      "description_length": 401,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Pixel",
      "library": "tsdl",
      "description": "This module provides operations for comparing, converting, and defining pixel formats through enumerations that specify color layouts (e.g., RGB, BGR, ARGB, BGRA) with varying bit depths and channel orders. It works directly with low-level pixel data representations, enabling precise control over graphics rendering, image processing, and surface manipulation in multimedia applications. Specific use cases include handling texture formats, converting between color spaces, and managing pixel-level data for software rendering pipelines.",
      "description_length": 538,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Window",
      "library": "tsdl",
      "description": "This module provides constants and bitmask operations for configuring and querying window properties through SDL window",
      "description_length": 119,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Hat",
      "library": "tsdl",
      "description": "This module defines integer constants representing joystick hat positions, such as up, down, left, right, and diagonals. It provides direct mappings to SDL's `SDL_HAT_*` constants for detecting directional input from joystick hats. Use these values to interpret joystick hat events and determine direction input in game controls or custom input handlers.",
      "description_length": 354,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Fpoint",
      "library": "tsdl",
      "description": "This module provides functions to create and manipulate 2D floating-point coordinates. It supports operations to set and retrieve the x and y components of a point structure. Concrete use cases include representing positions or vectors in graphical applications where precise decimal coordinates are required.",
      "description_length": 309,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Joystick_type",
      "library": "tsdl",
      "description": "This module defines constants representing different types of joysticks and game controllers, such as gamecontroller, wheel, flight_stick, and guitar. It provides direct mappings to SDL's joystick type identifiers for use in input handling and device detection. These values are used to classify connected input devices and determine their intended use in games or interactive applications.",
      "description_length": 390,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.K",
      "library": "tsdl",
      "description": "The module provides constants representing physical keyboard keys, including alphanumeric, function, numpad, modifier, and specialized keys, for precise input identification in SDL-based applications. These values of type `Tsdl.Sdl.keycode` map directly to SDL's key representations, enabling developers to detect specific key presses in contexts like game controls, text editing, and multimedia interactions. Use cases span handling standard input (e.g., navigation keys), extended keyboard layouts (e.g., keypad symbols), and hardware-specific keys (e.g., volume controls) in real-time or event-driven systems.",
      "description_length": 612,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Message_box",
      "library": "tsdl",
      "description": "This module displays customizable message boxes with buttons, icons, and color schemes. It supports creating modal dialogs with text, button labels, and return key behaviors, using SDL windows. Use it to prompt users for decisions, display alerts, or collect simple input within SDL-based applications.",
      "description_length": 302,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Vulkan",
      "library": "tsdl",
      "description": "This module provides functions to interface SDL with Vulkan, including loading and unloading the Vulkan library, retrieving required instance extensions, and creating Vulkan surfaces from SDL windows. It operates on Vulkan instance and surface types, using SDL windows and numeric types like nativeint and uint64 for integration. Concrete use cases include setting up Vulkan rendering contexts and managing drawable surfaces for graphics applications.",
      "description_length": 451,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Rect",
      "library": "tsdl",
      "description": "This module provides functions to create and manipulate axis-aligned rectangles using integer coordinates. It supports operations to set and retrieve the position (x, y) and dimensions (width, height) of rectangles. These rectangles are used for defining areas in 2D rendering, such as specifying source or destination regions during texture or surface blitting operations.",
      "description_length": 373,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Blend",
      "library": "tsdl",
      "description": "This module provides low-level operations for configuring pixel blending behavior in 2D rendering pipelines, including blend equation definitions, source/destination color weighting factors, and alpha modulation controls. It works directly with pixel color values and alpha channels to enable effects like transparency layering, additive blending for particle systems, and custom material compositing by manipulating how source and destination color values interact during rendering passes.",
      "description_length": 490,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Joystick_power_level",
      "library": "tsdl",
      "description": "This module defines constants representing joystick power levels as a variant type `t`, including states like `unknown`, `low`, `medium`, `full`, `wired`, and `max`. It provides direct access to these values for comparison or matching against joystick power state readings. Concrete use cases include checking or reacting to the current power level of a connected joystick, such as adjusting input sensitivity or displaying battery status in a game or interactive application.",
      "description_length": 476,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Hint",
      "library": "tsdl",
      "description": "This module provides operations to configure and prioritize internal SDL behaviors through string-based hint keys and explicit priority levels. It works with string constants representing hint categories like `render_driver` or `audio_resampling_mode`, alongside priority values (`normal`, `override`) to control hint precedence. Specific use cases include fine-tuning rendering pipelines, input handling, or system-specific optimizations by setting hints with defined priorities before SDL subsystem initialization.",
      "description_length": 516,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Controller",
      "library": "tsdl",
      "description": "This module defines types and constants for game controller inputs, including bind types (`button`, `axis`, `hat`), axes for left/right sticks and triggers, and buttons like A, B, X, Y. It provides functions to query input bindings, determine their types, and access controller state details. These features support game development tasks such as handling controller input, implementing custom control mappings, and responding to button or axis events in real-time.",
      "description_length": 465,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Audio",
      "library": "tsdl",
      "description": "This module provides operations for managing audio playback states (stopped, paused, playing) and defining sample data formats (e.g., `s16`, `f32` with endianness variants) to describe audio buffer layouts. It works with low-level audio configuration flags (e.g., `allow_format_change`) and device-specific data structures for 32-bit floating-point audio. These features are used to initialize audio devices, convert audio data between formats, and handle dynamic changes during playback setup.",
      "description_length": 494,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Finger",
      "library": "tsdl",
      "description": "This module provides access to touch finger data, including the finger's unique identifier, position coordinates, and pressure level. It operates on the `finger` type, which represents a single touch point in a multi-touch event. Use this module to retrieve detailed touch input information for applications like gesture recognition or interactive displays.",
      "description_length": 357,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl.Sdl.Vertex",
      "library": "tsdl",
      "description": "This module provides functions to create and manipulate vertex objects with position, color, and texture coordinate fields. It works with floating-point points (`fpoint`) and color values (`color`) to define 2D graphics data. Use it to construct and modify vertices for rendering shapes or textured surfaces in SDL-based applications.",
      "description_length": 334,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Scancode",
      "library": "tsdl",
      "description": "This module provides type-safe mappings and constants for keyboard scancodes, enabling precise identification of physical keys regardless of layout. It centers on the `scancode` type, offering predefined values for keys like letters, function keys, navigation controls, and special-purpose keys (e.g., media controls, numpad symbols), alongside utilities for classification. These capabilities are critical for low-level input handling in games, multimedia applications, or systems requiring hardware-specific key detection.",
      "description_length": 524,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Init",
      "library": "tsdl",
      "description": "This module defines bitmask flags for initializing SDL subsystems and provides operations to combine, remove, and test these flags. It works with the abstract type `t` representing sets of subsystems, such as video, audio, and events. Use it to specify which SDL components to initialize when calling `Sdl.init`, for example enabling both video and game controller support with `video + gamecontroller`.",
      "description_length": 403,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.System_cursor",
      "library": "tsdl",
      "description": "This module defines constants representing built-in system cursor types for use in graphical applications. It provides direct access to predefined cursor values such as `arrow`, `ibeam`, `wait`, and directional resize cursors, which correspond to standard UI interactions. These cursors are used to indicate actions like text input, waiting, or resizing windows in SDL-based interfaces.",
      "description_length": 386,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl.Log",
      "library": "tsdl",
      "description": "This module provides functions for logging messages with specific categories and priority levels, directing output to platforms like Android logcat or Windows debug consoles. It supports structured logging through predefined categories such as application, error, system, audio, video, render, and input, along with priority levels from verbose to critical. Concrete use cases include debugging rendering issues by logging video subsystem warnings or tracking input events with high priority errors.",
      "description_length": 499,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tsdl.Sdl",
      "library": "tsdl",
      "description": "This module provides low-level access to SDL's core systems for graphics, input, and audio, enabling direct interaction with hardware for game and multimedia development. It supports operations like initializing subsystems, managing rendering contexts, handling input events, and controlling audio devices, working with data types such as surfaces, textures, rectangles, and event structures. Submodules extend this functionality with precise 2D point and rectangle manipulation, color handling, haptic feedback, OpenGL integration, and input abstractions for keyboards, mice, and game controllers. Examples include rendering textured sprites with flipping and blending, capturing and responding to joystick or touch input, configuring audio playback formats, and displaying message boxes for user interaction.",
      "description_length": 810,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tsdl",
      "library": "tsdl",
      "description": "This module provides low-level access to SDL's core systems for graphics, input, and audio, enabling direct hardware interaction for game and multimedia development. It supports initializing subsystems, managing rendering contexts, handling input events, and controlling audio devices, working with data types like surfaces, textures, rectangles, and event structures. Submodules offer precise 2D manipulation, color handling, haptic feedback, OpenGL integration, and input abstractions for keyboards, mice, and game controllers. Examples include rendering textured sprites with flipping and blending, capturing joystick or touch input, configuring audio playback, and displaying message boxes.",
      "description_length": 694,
      "index": 33,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 34,
    "meaningful_modules": 34,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 810,
    "min_description_length": 119,
    "avg_description_length": 446.9117647058824,
    "embedding_file_size_mb": 0.12398338317871094
  }
}