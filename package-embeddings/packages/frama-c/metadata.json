{
  "package": "frama-c",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 4008,
  "creation_timestamp": "2025-08-19T11:52:28.285678",
  "modules": [
    {
      "module_path": "Variadic.Options.Enabled.Datatype",
      "library": "frama-c-variadic.core",
      "description": "This module defines a custom abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating variadic function-related constructs in the AST. It includes functions for deep copying values, checking membership based on project context, and exposing structural descriptors for integration with the kernel's typing and serialization systems. Concrete use cases include tracking and transforming va_arg expressions and variadic function calls during AST traversal.",
      "description_length": 534,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Variadic.Options.Strict.Datatype",
      "library": "frama-c-variadic.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in strict mode when handling integral type casts in LibC variadic function calls. It includes descriptors and representants for structural manipulation, along with functions for project membership checks and deep copying. It is used to manage and reason about datatype representations in Frama-C's kernel, particularly in contexts requiring strict type safety and precise memory project tracking.",
      "description_length": 530,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options.Enabled",
      "library": "frama-c-variadic.core",
      "description": "This module enables configuration of variadic function translation through boolean state management, offering operations to toggle translation behavior, register state change hooks, and handle command-line interactions. It works with a simple boolean type (`t`) to track enable/disable states, integrates with AST traversal mechanisms, and supports marshaling for persistence across global or project-specific contexts. Its primary use case involves controlling translation of variadic constructs like `va_arg` during static analysis in Frama-C plugins.",
      "description_length": 553,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Variadic.Options.Strict",
      "library": "frama-c-variadic.core",
      "description": "This module enforces strict type safety during variadic function calls by managing a boolean flag that blocks non-portable integral type conversions. It handles state transitions through direct value manipulation (`on`/`off`), alias tracking, and persistent configuration via serialization, while associating metadata with strict mode enforcement. The core operations target LibC variadic function compatibility checks and project-wide option consistency tracking in Frama-C's analysis kernel.",
      "description_length": 493,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options",
      "library": "frama-c-variadic.core",
      "description": "This module manages boolean configuration flags for variadic function translation and type safety enforcement. It provides operations to toggle state, register change hooks, and persist settings across analysis sessions. Designed for use in Frama-C plugins, it controls translation of variadic constructs like `va_arg` and enforces strict type checking during variadic function calls.",
      "description_length": 384,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic",
      "library": "frama-c-variadic.core",
      "description": "This module manages configuration flags for variadic function translation and type safety enforcement. It allows toggling state, registering change hooks, and persisting settings across analysis sessions. Specifically used in Frama-C plugins to control handling of variadic constructs such as `va_arg` and enforce strict type checking during variadic function calls.",
      "description_length": 366,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RteGen.Visit",
      "library": "frama-c-rtegen.core",
      "description": "This module provides functions to generate and retrieve code annotations for CIL elements such as functions, statements, expressions, and l-values, specifically tied to alarm handling. It includes visitor iterators for traversing l-values, expressions, instructions, and statements, along with registration and annotation application operations. Use cases include integrating alarm-based analysis into code generation and extracting annotations for specific CIL constructs during static analysis.",
      "description_length": 496,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RteGen.Flags",
      "library": "frama-c-rtegen.core",
      "description": "This module defines a record type `t` for configuring which categories of alarms to filter during analysis. It includes boolean flags for specific alarm types like memory access, division, overflow, and cast issues, along with a set of kernel functions for tracking initialization. The module supports creating default, fully enabled, or fully disabled flag configurations, used to control alarm generation and filtering in static analysis workflows.",
      "description_length": 450,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RteGen",
      "library": "frama-c-rtegen.core",
      "description": "This module provides operations for configuring alarm filters, generating code annotations, and traversing CIL elements to handle and retrieve alarm-related metadata. It works with record types for alarm flags, CIL constructs like expressions and statements, and supports annotation-based analysis workflows. Concrete use cases include controlling alarm generation during static analysis, annotating code elements with analysis results, and extracting alarm metadata for specific program points.",
      "description_length": 495,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a hash table specialized for values of a given data type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with any data type specified by the `Data` module parameter, ensuring deep copies and project-aware membership checks. Concrete use cases include managing collections of Eva AST expressions with efficient lookups and structural comparisons.",
      "description_length": 415,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a map structure keyed by offsets, with values parameterized by the `Data` module. It provides standard map operations\u2014equality, comparison, hashing, pretty-printing, deep copying\u2014and supports project-aware membership checks. It is used to represent and manipulate offset-indexed data, such as memory layouts or field positions in structured types.",
      "description_length": 370,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for a hash table that stores values based on the structure of constants in the Eva AST. It provides standard operations including equality, comparison, hashing, and pretty printing for these keys, along with functions for deep copying and checking the presence of project-specific data. It is used to manage and manipulate constant-based keys in Eva's analysis context, particularly when tracking or retrieving computed values across different analysis states.",
      "description_length": 491,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps in the Eva AST, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with the `Lhost.Map.key` type, which represents keys in a map structure used for Eva's abstract syntax tree. Concrete use cases include managing unique identifiers for AST nodes, enabling efficient lookups, and supporting serialization and comparison of key values in Eva analyses.",
      "description_length": 433,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map specialized for values of a given `Data` module, with operations including comparison, hashing, pretty printing, and deep copying. It works with maps where keys are of type `Eva.Eva_ast.Lval.t` and values are of type `Data.t`. Concrete use cases include managing and manipulating typed Eva AST lvalue mappings in static analysis tasks, such as tracking variable assignments or analyzing memory states.",
      "description_length": 427,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps based on Eva's abstract syntax tree l-values. It includes standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in map structures where each key represents an l-value in the Eva AST.",
      "description_length": 341,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type `t` for keys used in a hash table that maps to Eva AST offsets. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with functions for deep copying and checking the presence of project-related values. It is used to manage and manipulate keys that uniquely identify AST node offsets within the Eva analysis framework.",
      "description_length": 411,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for use in hash tables, specifically tailored for the Eva abstract syntax tree. It provides standard operations including equality, comparison, hashing, and pretty-printing for the key type, ensuring compatibility with OCaml's `Hashtbl` module. The key type is used to represent and manipulate values in Eva's analysis context, particularly for tracking and comparing abstract syntax tree elements.",
      "description_length": 429,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports maps with keys from `Eva.Eva_ast.Lhost.t` and includes functionality for project membership checks, deep copying, and type descriptor management. Concrete use cases include managing and comparing collections of Eva AST lhost-based data with efficient lookups and serialization.",
      "description_length": 444,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a hash table key type for Eva expressions, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that include type information, descriptors, and project membership checks, enabling efficient key management in hash tables. Concrete use cases include tracking expression keys in analysis passes and ensuring structural uniqueness for Eva AST nodes during abstract interpretation.",
      "description_length": 453,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports structured data management with deep copying, membership testing by project, and type-safe storage of representational values. Concrete use cases include tracking and manipulating collections of typed constants in static analysis contexts.",
      "description_length": 420,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines the key type used in maps with Eva AST constants, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with Frama-C projects by including functions to check project membership and perform deep copies. Use cases include managing and comparing keys in maps that store Eva AST constant data during static analysis.",
      "description_length": 385,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for a hash table that represents values with project membership checks, deep copying, and standard comparison and hashing operations. It works with a specific key type that includes project-aware data, supporting precise equality, ordering, and pretty-printing. Concrete use cases include managing and querying project-specific abstract syntax tree elements in Eva's analysis, such as tracking lvalues across different project contexts.",
      "description_length": 467,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps that uses expressions from the Eva abstract syntax tree. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and project membership checks. It is used when managing maps keyed by Eva expressions, ensuring correct handling of their structure and properties.",
      "description_length": 361,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a map keyed by expressions, with values of a specified data type. It provides standard map operations including comparison, equality, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage expression-indexed collections of values, such as analysis results or annotations, in a way that supports structural operations and project-specific queries.",
      "description_length": 420,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a map keyed by `Eva_ast.Constant.t` with values of a specified `Data` type, providing standard map operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checks over projects, and integrates with Frama-C's type and descriptor system for runtime type information. Concrete use cases include managing constant-specific metadata during Eva analysis passes, such as tracking constant values across different project versions or analysis domains.",
      "description_length": 514,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a concrete key type for maps in the Eva AST Offset system, including operations for equality, comparison, hashing, and pretty-printing. It works with structured data types that represent keys in a map, supporting deep copying and membership checks for project-related values. Use cases include managing and comparing unique keys in map structures for static analysis tasks.",
      "description_length": 393,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data management tasks such as deep copying, membership checking with project filtering, and type representation with descriptors. Concrete use cases include tracking and manipulating collections of Eva AST elements associated with host locations in static analysis plugins.",
      "description_length": 449,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a hash table specialized for values of a given `Data` type, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that require structured handling within Frama-C's Eva plugin, such as abstract values or expressions. Concrete use cases include tracking and managing sets of Eva AST l-values with efficient lookup and comparison, particularly during static analysis phases where precise dataflow tracking is required.",
      "description_length": 491,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a hash table specialized for a given data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with values of type `Data.t` and provides a deep copy function, a list of representative values, and project membership checks. Concrete use cases include managing collections of Eva AST nodes with offset information, ensuring efficient lookups and structural consistency in analysis plugins.",
      "description_length": 457,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map",
      "library": "frama-c-eva.core",
      "description": "This module provides functional map operations for managing associations between Eva AST l-values and arbitrary data, supporting additions, removals, ordered traversals, and structural manipulations like merging and splitting. It includes utilities for transforming, filtering, and converting maps to sequences or lists, with functions to maintain key ordering and perform equality checks. These maps are used in static analysis tasks to track variable properties or intermediate results tied to specific l-value expressions, enabling precise data-flow computations and analysis state management.",
      "description_length": 596,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides hash tables using Eva AST offset values as keys, supporting imperative modifications, bulk sequence conversions, and ordered traversal over entries. These tables facilitate efficient lookups and structural consistency in Frama-C Eva analysis plugins, particularly for memoization and managing offset-based mappings during static analysis.",
      "description_length": 359,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Set",
      "library": "frama-c-eva.core",
      "description": "This module provides a functional set abstraction for manipulating ordered collections of Eva AST offsets, supporting operations like union, intersection, ordered traversal, and membership queries. It works with immutable sets of `Offset.t` elements, enabling efficient transformations, sequence conversions, and structural analyses for tasks such as tracking node positions during AST manipulations or analyzing hierarchical relationships through offset comparisons.",
      "description_length": 467,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map",
      "library": "frama-c-eva.core",
      "description": "This module implements a persistent map structure where keys are abstract syntax tree (AST) expressions, supporting ordered traversal, functional transformations, and structural queries. It provides operations to manipulate key-value associations through insertion, deletion, filtering, and ordered selection, while preserving immutability for use in compiler pipelines like symbol table management or AST annotation. Key applications include tracking expression metadata during type checking and enabling efficient restructuring of AST nodes via ordered key sequences.",
      "description_length": 569,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module implements imperative hash tables specialized for keys of Eva abstract syntax tree expressions, enabling efficient insertion, lookup, iteration, and in-place modification with support for custom key/value ordering and comparison. It facilitates use cases like memoizing evaluation results for AST nodes, tracking expression metadata during analysis, and bulk processing of expression-to-value mappings with ordered traversal or statistical aggregation. The design integrates sequence conversions and type-specific utilities to streamline manipulation of AST-centric data flows in compiler or static analysis contexts.",
      "description_length": 629,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides hash table operations for Eva AST constants, supporting imperative updates (insertion, deletion) and functional transformations (iteration, folding, sequence conversion) over mappings from `Constant.t` keys to arbitrary values. It includes utilities for structural comparison, ordered traversal, and memoization, leveraging the `Key` and `Make` submodules to ensure type-safe storage and efficient processing of AST-related metadata. Typical use cases involve tracking constant values during static analysis, caching computation results, or managing attributes associated with AST nodes in a type-preserving manner.",
      "description_length": 636,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type for keys used in a hash table, including operations for equality, comparison, hashing, and pretty-printing. It supports structured keys with deep copying and project membership checks, enabling efficient key management in hash table implementations. Use cases include tracking unique identifiers with associated projects and ensuring consistent key behavior in hash-based data structures.",
      "description_length": 420,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns.Memory.LOffset",
      "library": "frama-c-eva.core",
      "description": "This module provides lattice operations and interval arithmetic for abstract memory analysis, enabling precise manipulation of offset-value mappings through joins, inclusion checks, and interval-based lookups. It works with interval maps that associate ranges of integers (offsets) to values, supporting transformations like merging overlapping intervals and folding with customizable combination logic. These capabilities are used in static analysis to track memory regions with varying precision, such as merging heap-allocated structures or analyzing buffer accesses with range constraints.",
      "description_length": 593,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Set",
      "library": "frama-c-eva.core",
      "description": "This module implements ordered collections of `Lval` elements with efficient membership checks, ordered traversal, and set algebra operations like union and intersection. It supports transformations through mapping and filtering, maintains elements in a fixed order defined by a comparator, and enables range queries, nearest-neighbor searches, and project-specific analysis workflows. Typical applications include static analysis tasks requiring precise tracking of program variables or expressions in abstract syntax tree contexts.",
      "description_length": 533,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Set",
      "library": "frama-c-eva.core",
      "description": "This module provides a purely functional set abstraction for managing collections of Eva AST expressions (`Eva.Eva_ast.Exp.t`) with a total ordering. It supports standard set operations like union, intersection, and difference, along with traversal, filtering, and conversion to/from lists/sequences, while ensuring efficient membership checks and ordered element access. It is particularly useful in program analysis scenarios requiring precise tracking of expression relationships, such as static analysis of variable dependencies or control flow constructs.",
      "description_length": 560,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map",
      "library": "frama-c-eva.core",
      "description": "This module implements ordered maps with keys of type `Eva.Eva_ast.Offset.t` and polymorphic values, supporting functional updates, transformations, and structural queries. It provides operations for merging, folding, filtering, and ordered iteration, along with utilities for equality checks, range-based traversals, and pretty-printing. These features are particularly useful in static analysis tasks requiring precise tracking of memory layouts or structured data relationships, where offset-based key ordering ensures efficient inspection and manipulation of hierarchical or sequential memory regions.",
      "description_length": 605,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module defines a map structure specialized for callstack values, where keys are callstacks and values are of a specified data type. It provides standard map operations including comparison, equality, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate callstack-indexed data in static analysis contexts, such as tracking function call contexts or propagating analysis results across call paths.",
      "description_length": 468,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type `t` for keys used in a map structure, along with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks via `mem_project` and deep copying with `copy`. Concrete use cases include managing and comparing callstack keys in static analysis contexts where precise key identity and project membership matter.",
      "description_length": 447,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map",
      "library": "frama-c-eva.core",
      "description": "This module provides associative map operations for key-value pairs where keys are constants, supporting insertion, deletion, querying, and merging with immutable semantics. It leverages ordered keys for efficient traversal, transformation via mapping and folding, and set-like operations such as filtering, partitioning, and comparison. Designed for use cases like bulk updates from sequences, ordered iteration, and conversions between maps and lists or sequences, it also includes utilities for pretty-printing and custom key behavior.",
      "description_length": 538,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports introspection and serialization through type descriptors, project membership checks, and deep copying. Concrete use cases include managing per-project data in static analysis plugins with efficient lookups and persistence.",
      "description_length": 398,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module implements hash tables mapping Eva AST l-values to arbitrary values, supporting imperative modifications (insertion, removal, in-place filtering) and bulk transformations (iteration, folding, sequence conversion). It provides ordered traversal over keys using customizable comparison functions and includes utilities for memoization, type-aware lookups, and structural analysis of C code during static analysis. These operations are specifically designed for tracking variable assignments, evaluating expressions, and propagating abstract values in program analysis workflows.",
      "description_length": 588,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Set",
      "library": "frama-c-eva.core",
      "description": "This module implements an ordered set abstraction for managing collections of `Lhost.t` values, with operations optimized for ordered traversal, membership queries, and set algebra. It supports transformations, projections, and comparisons while maintaining element ordering, and includes utilities for pretty-printing, hashing, and project-specific membership checks. Designed for static analysis tasks, it enables efficient tracking and manipulation of AST node sets in Frama-C's Eva plugin.",
      "description_length": 493,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Set",
      "library": "frama-c-eva.core",
      "description": "This module manages ordered sets of `Eva.Eva_ast.Constant.t` values, offering standard set operations (union, intersection, difference), element queries (membership, min/max), ordered iteration, and transformations (map, filter). It supports efficient conversions to lists/sequences, nearest-element searches, and integration with Frama",
      "description_length": 336,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module supports creation, manipulation, and traversal of hash tables mapping project-aware AST elements to arbitrary data, with operations for insertion, deletion, lookup, and ordered iteration over keys, values, or entries. It provides utilities for safe key access, memoization, and integration with structural analysis systems, using hash tables specialized for `Lhost.t` keys derived from Eva's syntax tree. Typical applications include tracking associations between AST nodes and computed analysis metadata, such as variable bindings or intermediate evaluation states in Frama-C's Eva framework.",
      "description_length": 605,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Map",
      "library": "frama-c-eva.core",
      "description": "This module implements a specialized ordered map structure for associating values with `Eva.Callstack.t` keys, supporting efficient insertion, deletion, and lookup operations alongside ordered traversal and transformation. It provides ordered key processing with physical equality optimizations, enabling use cases like static analysis state tracking where callstacks serve as unique, hierarchically ordered identifiers. Operations include ordered folding, filtering, and sequence conversion, tailored for contexts requiring precise callstack-based data flow management.",
      "description_length": 570,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval",
      "library": "frama-c-eva.core",
      "description": "This module defines operations for manipulating l-values in an abstract syntax tree, including equality, comparison, hashing, and pretty-printing. It supports data types that represent program variables and expressions, with functionalities for deep copying, project-specific analysis, and structural comparisons. Concrete use cases include tracking variable references in static analysis, managing expression values during abstract interpretation, and enabling precise data-flow computations tied to specific program points.",
      "description_length": 525,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.MakeDepsOf",
      "library": "frama-c-eva.core",
      "description": "This module computes memory dependencies and zones for expressions and lvalues based on a provided location function. It operates on AST nodes from `Eva_ast_types`, including expressions and lvalues, and produces memory zones and dependency information using `Frama_c_kernel.Locations.Zone.t` and `Eva.Deps.t`. Concrete use cases include determining memory effects of expressions and tracking dependencies for static analysis tasks like value analysis or slicing.",
      "description_length": 463,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Set",
      "library": "frama-c-eva.core",
      "description": "This module implements an ordered, immutable set structure for managing collections of callstack values, supporting standard set-theoretic operations (union, intersection, subset checks), element-wise transformations (map, filter), and ordered traversal (find_first, reverse sequences). It operates on sets containing elements of type `Eva.Callstack.t`, leveraging a comparison function to maintain sorted order for efficient membership queries and ordered iteration. Typical use cases include static analysis tasks requiring precise callstack tracking, such as detecting recursion patterns, analyzing call hierarchies, or aggregating context-sensitive program states with ordered set operations.",
      "description_length": 696,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Call",
      "library": "frama-c-eva.core",
      "description": "This module defines operations for manipulating callstack elements, including equality checks, comparison, hashing, and pretty-printing. It works with the `t` type representing callstack frames, supporting deep copies and membership checks for project-related data. Concrete use cases include tracking function call hierarchies and analyzing control flow in static analysis tasks.",
      "description_length": 380,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module implements hash tables optimized for keys based on structured callstack types, supporting imperative operations like insertion, lookup, and iteration alongside sequence-driven bulk updates. It organizes key-value pairs where keys adhere to a structured format defined in the Key module and values can be arbitrary, enabling ordered traversal and folding through customizable key comparators. Typical applications include caching analysis results tied to callstack contexts, maintaining state mappings with structured identifiers, and processing hierarchical data requiring efficient keyed access and ordered enumeration.",
      "description_length": 632,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns.DepsOrUnassigned",
      "library": "frama-c-eva.core",
      "description": "This module represents the assignment status of a memory location, tracking whether it is unassigned, definitely assigned from a set of dependencies, or possibly assigned. It provides operations to compare statuses, check if a location may be unassigned, and convert the status to a memory zone. It is used in static analysis to model the initialization state of variables and determine dependencies affecting their values.",
      "description_length": 423,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Constant",
      "library": "frama-c-eva.core",
      "description": "This module defines operations for handling constants in the Eva AST, including equality, comparison, hashing, deep copying, and pretty-printing. It works with the `Eva.Eva_ast.Constant.t` type, which represents constants in the abstract syntax tree, and includes utilities for set, map, and hash table manipulations through its submodules. Concrete use cases include managing constant values during static analysis, performing efficient lookups and transformations on AST nodes, and supporting memoization or caching strategies tied to constant keys.",
      "description_length": 551,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Rewrite",
      "library": "frama-c-eva.core",
      "description": "This module implements transformations over expressions, lvalues, variables, and offsets in Eva's abstract syntax tree. It provides functions to apply customizable rewriters to these elements, enabling modifications such as substitution, simplification, or annotation. Use cases include implementing Eva-specific AST transformations for analysis passes or preprocessing expressions and lvalues before evaluation.",
      "description_length": 412,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp",
      "library": "frama-c-eva.core",
      "description": "This module defines operations for manipulating abstract syntax tree (AST) expressions in Eva, including equality, comparison, hashing, deep copying, and pretty-printing. It works with the type `Eva.Eva_ast.Exp.t`, which represents expressions in the Eva AST, and includes utilities for analyzing and transforming these expressions based on their structure and associated projects. Concrete use cases include static analysis of program expressions, transformation passes in compilers, and tracking expression metadata during semantic analysis.",
      "description_length": 543,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset",
      "library": "frama-c-eva.core",
      "description": "This module defines core operations for manipulating Eva AST offset values, including equality checks, comparison, hashing, deep copying, and pretty-printing. It supports data types like `t` with structural descriptors and project membership checks, enabling precise static analysis tasks such as memory layout tracking and hierarchical data inspection. Concrete use cases include analyzing C abstract syntax trees for offset-based relationships and ensuring structural consistency during Frama-C Eva plugin executions.",
      "description_length": 519,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.PreciseDepsOf",
      "library": "frama-c-eva.core",
      "description": "This module computes memory dependencies and zones for expressions and lvalues based on precise locations. It operates on syntax tree nodes, including `exp_node`, `lhost`, and `offset` tagged with location information, and returns memory zones or dependency sets. Concrete use cases include determining which parts of memory affect an expression's value or tracking dependencies for pointer accesses and offset computations.",
      "description_length": 424,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Build",
      "library": "frama-c-eva.core",
      "description": "Constructs and manipulates expression and lvalue nodes for Eva's abstract syntax tree. It supports creating constants (integers, floats, booleans), performing arithmetic and comparison operations (addition, division, equality), and handling memory accesses (variables, fields, indices, casts). This module is used to build Eva expressions and lvalues programmatically, typically during semantic analysis or transformation passes in Eva.",
      "description_length": 436,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type `t` representing project-aware abstract syntax tree (AST) elements in Frama-C's Eva plugin. It provides operations for equality checks, comparison, hashing, deep copying, pretty-printing, and project-specific membership queries. Use cases include tracking and manipulating AST nodes during static analysis, such as variable identifiers or expression hosts, with support for set, map, and hash table structures optimized for analysis tasks.",
      "description_length": 471,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_perf.StatByCallstack",
      "library": "frama-c-eva.core",
      "description": "Tracks analysis performance statistics for each unique callstack during program analysis. It allows retrieving per-callstack statistics, iterating over all analyzed callstacks, and registering hooks to react to changes in statistics. This is useful for monitoring and optimizing the performance of static analysis on different execution paths in the code.",
      "description_length": 355,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns.Memory",
      "library": "frama-c-eva.core",
      "description": "This module provides lattice operations for abstract memory analysis, including join, inclusion checks, and interval-based mappings, while managing a memory state represented as a map from bases to values with offset information. It supports static analysis tasks like tracking heap structures and buffer accesses through precise dependency tracking, merging intervals, and handling bindings with varying precision levels (imprecise to precise locations). Key data structures include memory assignments, intervals, and dependencies, with utilities for filtering, folding, and cache management to optimize analysis workflows.",
      "description_length": 624,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Fold",
      "library": "frama-c-eva.core",
      "description": "Traverses syntax tree nodes, applying a folder to expressions and lvalues. It processes tagged AST nodes, combining results from sub-expressions using a user-defined function. Use it to analyze or transform Eva programs by aggregating values across the tree structure.",
      "description_length": 268,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Analysis",
      "library": "frama-c-eva.core",
      "description": "This module tracks the computation state of the Eva analysis, providing functions to check whether analysis has been completed, register hooks for state changes, and query the status of individual functions. It works with internal Eva states and Cil kernel functions, exposing whether functions are unreachable, analyzed, or handled via specs or builtins. Concrete use cases include coordinating analysis steps, monitoring progress, and determining availability of analysis results for specific functions.",
      "description_length": 505,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Statistics",
      "library": "frama-c-eva.core",
      "description": "This module tracks and manages numerical statistics associated with program elements such as statements, functions, or global units. It supports operations to register, retrieve, update, increment, and grow statistics based on specific elements. For example, it can count iterations per statement, cache hits and misses per function, or track maximum widening and unrolling values during analysis.",
      "description_length": 397,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Cvalue_callbacks",
      "library": "frama-c-eva.core",
      "description": "This module allows registering hooks to be executed during the analysis of function calls, providing access to cvalue domain states before and after each statement. It works with analysis states, call stacks, and function call results, enabling inspection of values and memory states at various stages of function processing. Concrete use cases include tracking value propagation, monitoring memory effects, or logging intermediate states during static analysis.",
      "description_length": 462,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Results",
      "library": "frama-c-eva.core",
      "description": "This module enables constructing and transforming analysis result queries by specifying program points (e.g., before/after statements, function entry/exit) and callstack contexts, with support for evaluating expressions and lvalues into abstract domains like integers, floats, or memory locations. It operates on abstract request and value types, integrating with kernel structures such as variables, statements, and functions to enable tasks like taint tracking, dependency analysis, and coverage inspection. Specific applications include extracting evaluated values with fallback defaults, checking value properties (e.g., initialization, reachability), and analyzing call graphs via callers/callees relationships.",
      "description_length": 716,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Logic_inout",
      "library": "frama-c-eva.core",
      "description": "This module evaluates logic dependencies and memory zones for predicates and assigns clauses in Cvalue states, supporting plugins like Inout and From. It handles operations such as computing valid function behaviors, determining input/output zones for assigns, and verifying assigns correctness against computed dependencies. Use cases include static analysis of function contracts, tracking memory effects, and validating specification clauses during abstract interpretation.",
      "description_length": 476,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eval",
      "library": "frama-c-eva.core",
      "description": "Handles expression evaluation and caching behavior for analysis functions. It defines how values are computed and cached during static analysis, determining whether results can be reused or must be recalculated. Used to control caching granularity in scenarios like function calls with side effects or expensive computations.",
      "description_length": 325,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast",
      "library": "frama-c-eva.core",
      "description": "This module provides operations for constructing, manipulating, and analyzing abstract syntax trees used in static analysis, focusing on expressions, l-values, and type structures derived from CIL-based representations. It supports tasks like memory dependency tracking, expression simplification, and semantic transformations through utilities for normalization, constant folding, and offset handling. Key data structures include tagged AST nodes, offsets, and bitfields, with specialized functions for traversal, rewriting, and comparison conversion.",
      "description_length": 552,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Unit_tests",
      "library": "frama-c-eva.core",
      "description": "Contains test cases that validate the behavior of Eva's core functionalities. Operates on the Eva module's public API, including its main data types and operations. Ensures correctness of programmatic tests by verifying expected outcomes against actual results.",
      "description_length": 261,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Builtins",
      "library": "frama-c-eva.core",
      "description": "This module defines and registers built-in functions for the Eva value analysis, enabling more efficient handling of specific C functions. It works with types representing Eva's abstract values, memory states, and function call results, including `cvalue`, `model`, and `full_result`. Use cases include replacing standard C functions like `memcpy` or `strlen` with optimized Eva-specific implementations to improve analysis precision and performance.",
      "description_length": 450,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_perf",
      "library": "frama-c-eva.core",
      "description": "Tracks and analyzes performance statistics for functions and callstacks during static analysis. It provides detailed metrics such as number of calls, self and total analysis durations, and called functions, enabling optimization of analysis time by identifying performance bottlenecks. Useful for profiling the cost of analyzing specific functions or execution paths.",
      "description_length": 367,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Parameters",
      "library": "frama-c-eva.core",
      "description": "This module configures analysis settings by enabling abstract domains, specifying built-in interpretations for functions, and applying value partitioning to global variables. It operates on kernel functions and variable information from the Frama-C CIL types. Use it to customize how specific functions and globals are analyzed during static analysis.",
      "description_length": 351,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Deps",
      "library": "frama-c-eva.core",
      "description": "This module provides operations to construct, transform, and compare memory dependency representations, focusing on tracking memory zones accessed during expression evaluation. It works with a custom type modeling sets of memory locations, supporting set-like operations such as inclusion checks, joins, and narrowing to refine dependencies. These capabilities are particularly useful for static analysis tasks requiring precise memory access tracking, such as optimizing code analysis or integrating with Frama-C's project system for context-sensitive evaluations.",
      "description_length": 565,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Export",
      "library": "frama-c-eva.core",
      "description": "This module generates logical predicates that characterize the domains of l-values at specific program points, using the results from static analysis. It provides functions to export these predicates for individual values or statements, focusing on reads and branching conditions. Use cases include automatically generating assertions for runtime checks or formal verification, and managing these assertions through annotation and cleanup passes.",
      "description_length": 446,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Assigns",
      "library": "frama-c-eva.core",
      "description": "This module tracks variable assignment states and memory dependencies during static analysis. It provides operations to compare assignment statuses, check unassigned locations, and merge states using lattice join. The module works with memory zones and dependency sets to model initialization and modification of variables in analyzed code.",
      "description_length": 340,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack",
      "library": "frama-c-eva.core",
      "description": "This module provides operations to manipulate hierarchical call contexts during static analysis, including stack-like modifications (pushing/popping function calls), structural comparisons, and conversion to ordered representations. It works with callstacks as first-class values, organizing them through ordered sets, maps, and hash tables for efficient querying and project-specific membership checks. These capabilities support abstract interpretation tasks like tracking control flow dependencies and analyzing function call propagation in program analysis pipelines.",
      "description_length": 571,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_annotations",
      "library": "frama-c-eva.core",
      "description": "This module defines and manages annotations that control Eva's abstract interpretation behavior, such as slevel limits, loop unrolling, state splitting, and memory allocation strategies. It operates on CIL statements and expressions, allowing precise tuning of analysis precision and performance at specific code locations. Use cases include enforcing state merging, setting per-statement unroll counts, and controlling array segmentation or domain scopes during analysis.",
      "description_length": 472,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva",
      "library": "frama-c-eva.core",
      "description": "This module provides core components for static analysis in Eva, including tracking analysis states, managing callstacks, handling memory dependencies, and querying analysis results. It works with data types such as function states, call contexts, memory zones, and abstract values to support tasks like taint tracking, dependency analysis, and control flow inspection. Concrete use cases include coordinating analysis steps, optimizing code analysis through built-ins, profiling performance bottlenecks, and enforcing analysis precision via annotations and parameter settings.",
      "description_length": 577,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Api.Marks.F_Proj",
      "library": "frama-c-pdg.core",
      "description": "This module manages the association between functions and their marks in a program dependence graph. It provides operations to retrieve function-specific marks and to propagate marks across the graph based on a selection strategy. It works with types such as `varinfo`, `mark`, and `Pdg.t`, and is used to track and apply semantic marks during analysis of function calls and dependencies.",
      "description_length": 388,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Marks.F_Proj",
      "library": "frama-c-pdg.core",
      "description": "This module manages the association between functions and their marks in a program dependence graph. It provides operations to retrieve function-specific marks and propagate marks across the graph based on a selection strategy. It works with types such as `varinfo`, `mark`, `call_info`, and `fct`, and is used to track and apply marks during analysis of function calls and dependencies.",
      "description_length": 387,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Api.Marks",
      "library": "frama-c-pdg.core",
      "description": "This module translates and propagates semantic marks across program dependence graph nodes during interprocedural analysis. It provides functions to convert input and output marks between caller and called functions, using mappings derived from the graph structure. Key operations include refining mark selections based on call relationships and projecting marks onto specific functions for precise dependency tracking.",
      "description_length": 419,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg.Marks",
      "library": "frama-c-pdg.core",
      "description": "This module translates and propagates marks between caller and called functions in a program dependence graph. It handles input and output mark transformations using mappings tied to function calls, working with types like `stmt`, `varinfo`, `mark`, and `call_info`. Concrete use cases include updating caller function nodes with propagated marks after analyzing changes in called functions during static analysis.",
      "description_length": 414,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg.Api",
      "library": "frama-c-pdg.core",
      "description": "This module enables querying and navigating program dependence graphs to analyze dataflow, control, and address dependencies, including direct and transitive relationships between nodes for variables, statements, call sites, and annotations like preconditions or postconditions. It operates on graph representations (`Pdg.Api.t`), CIL statements, and nodes (`PdgTypes.Node.t`), supporting custom traversal strategies and propagation of node markings to track dependencies across program elements. These capabilities are used for static analysis tasks such as program slicing, impact analysis, and verification of correctness properties through dependency chains.",
      "description_length": 662,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg",
      "library": "frama-c-pdg.core",
      "description": "The module provides program dependence graph analysis capabilities, enabling queries and traversals to track dataflow, control, and address dependencies between variables, statements, and annotations. It supports custom traversal strategies and mark propagation across nodes, with operations for analyzing dependency chains, performing program slicing, and verifying correctness properties. Concrete use cases include static analysis tasks like impact analysis and interprocedural mark propagation through function calls.",
      "description_length": 521,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inout",
      "library": "frama-c-inout.core",
      "description": "This module computes memory access zones for expressions, statements, and functions in CIL code, providing precise read and write sets for analysis. It operates on CIL statements, expressions, and kernel functions, returning memory zones that capture data dependencies and side effects. These results support static analysis tasks like impact analysis, slicing, and dependency tracking by identifying which memory locations are accessed or modified in specific code contexts.",
      "description_length": 475,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.As_string.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and operations for handling author information as strings in a command-line parameter context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to manage and manipulate author values in a structured and consistent way, particularly for integration with command-line parsing and project analysis systems.",
      "description_length": 426,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.As_string.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in a structured and type-safe manner. It supports operations like equality checking, comparison, hashing, and pretty-printing, ensuring values can be uniquely identified, compared, and displayed. It is used to represent and manipulate string parameters passed via the `-mdr-stubs` command-line option, enabling robust parsing and validation within the analysis framework.",
      "description_length": 452,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.Category",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manages categories for command-line parameters related to a collection of elements. It provides operations to create, enable, and configure categories such as `@none`, `@default`, and `@all`, using names, accessors, and dependency lists. These categories control how parameters are interpreted and grouped when processing command-line inputs in tools relying on the `Markdown_report` configuration system.",
      "description_length": 429,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating structured values used in command-line parameter handling. It supports concrete data operations such as deep copying, equality checking, hashing, and pretty printing, along with project membership testing. Typical use cases include managing and querying structured command-line arguments in a type-safe manner.",
      "description_length": 404,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.As_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module manipulates string-based command-line parameters for analysis configuration, focusing on validating input values against predefined options and resolving function aliases. It operates on parameter definitions that specify allowed string values and associated validation logic, supporting controlled access through typed retrieval and mutation operations. Typical use cases include enforcing valid stub behavior in static analysis tools and bridging user-provided command-line arguments with internal state management systems.",
      "description_length": 537,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Verbose.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin development. It includes functions to check membership within projects, create deep copies, and manage type descriptors for structured data handling. The type supports integration with Frama-C's project system and structural descriptions, enabling robust analysis and reporting workflows.",
      "description_length": 442,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.FlameGraph.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type for representing structured values used in flame graph generation, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a custom type `t` that encapsulates complex data structures, including project-specific information. Concrete use cases include storing and manipulating hierarchical profiling data, enabling deep copying, and checking project membership via predicates.",
      "description_length": 444,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Remarks.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete data type for representing remark values associated with the `-mdr-remarks` parameter. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for project membership testing. The type is used to store and manipulate structured remark data during analysis, enabling features like filtering and display in reports.",
      "description_length": 414,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.As_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages string-based author information as a command-line parameter, offering operations to set and validate allowed values, register change hooks, and handle aliases. It works with string collections and parameter state, supporting use cases like project-specific author configuration and extensible marshaling for serialization. Key functionality includes conditional value retrieval, function name validation, and maintaining synchronized state across parameter changes.",
      "description_length": 485,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type for representing author information with support for equality checks, comparison, hashing, and pretty printing. It includes operations for deep copying values, checking membership based on project criteria, and providing type descriptors for integration with command-line parameters. It is used to manage and manipulate author data passed via the `-mdr-authors` command-line option in a structured and type-safe manner.",
      "description_length": 451,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Title.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete datatype for representing and manipulating values associated with a title parameter in a markdown report. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checks. The datatype is used to store and manage structured values that can include project-specific data, enabling precise handling of report titles within analysis workflows.",
      "description_length": 454,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponent.Contents",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete type for representing content categories in SARIF tool components, specifically distinguishing between localized and non-localized data. It provides direct conversions to and from JSON using `Yojson.Safe.t`, ensuring compatibility with SARIF schema requirements. Use this module when handling internationalized tool output or static analysis results that require language-specific content.",
      "description_length": 420,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Generate.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a polymorphic type `t` with operations for type representation, comparison, hashing, and pretty printing. It supports working with structured data through descriptors, packed representations, and deep copying, ensuring values can be uniquely identified and manipulated. Concrete uses include managing and comparing complex data structures during analysis, such as tracking and printing changes across different project states.",
      "description_length": 446,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.PrintLibc.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use with the `-mdr-print-libc` option in the Markdown report generation. It supports structured data representation with descriptors, packed representations, and deep copying, ensuring values can be uniquely identified and manipulated independently. Use cases include managing and comparing complex data structures during static analysis to generate detailed reports.",
      "description_length": 497,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.Category",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manages categories for author-related command-line parameters, such as `@none`, `@default`, and `@all`. It supports operations to create, modify, and enable categories with custom accessors and dependencies. Use cases include configuring how author data is interpreted and filtered in command-line interfaces.",
      "description_length": 333,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Output.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and associated operations for representing and manipulating structured output values tied to a specific descriptor. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, along with membership testing for project values. The type is used to handle representable values in a structured, project-aware context, ensuring safe traversal and transformation.",
      "description_length": 414,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.SarifDeterministic.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type with operations for representing and manipulating structured values used in deterministic SARIF reporting. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle representational and structural aspects of SARIF output data in a deterministic manner.",
      "description_length": 366,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Date.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a custom data type for representing date values in the context of a Markdown report configuration. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, all tailored to handle date values specifically. The type is integrated with Frama-C's kernel structures, enabling it to be used in project-aware contexts, such as filtering or serializing date-based parameters within analysis sessions.",
      "description_length": 461,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Debug.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type `t` with operations for type representation, comparison, hashing, and pretty printing. It supports working with structured descriptors, project membership checks, and deep copying of values. Concrete use cases include managing and comparing complex data structures in static analysis tools, particularly for tracking and debugging project-specific data.",
      "description_length": 385,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Run",
      "library": "frama-c-markdown-report.core",
      "description": "This module constructs and manipulates SARIF run objects that capture the execution context of a static analysis tool. It supports creating, serializing, and deserializing run records with detailed metadata such as tool configuration, source control provenance, artifact references, and analysis results. Use cases include generating SARIF output for code analysis tools, integrating with CI systems for structured reporting, and processing tool runs for aggregation or transformation.",
      "description_length": 485,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Graph_dictionary",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of dictionaries mapping string keys to SARIF graph objects. Works with `Markdown_report.Sarif.Graph.t` values and string keys, using Yojson for JSON encoding and decoding. Useful for persisting or transmitting SARIF graph data structures in JSON format according to the SARIF 2.1 specification.",
      "description_length": 336,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactLocationDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents a dictionary mapping artifact locations in the SARIF 2.1 schema, using `Markdown_report.Sarif.ArtifactLocation.t` as the value type. It provides serialization and deserialization to and from JSON using `Yojson.Safe.t`, ensuring compatibility with SARIF format requirements. It is used to manage file paths and artifact references in static analysis reporting workflows.",
      "description_length": 392,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Md_gen.Eva_info",
      "library": "frama-c-markdown-report.core",
      "description": "This module tracks Eva's loading state and provides functions to generate Markdown content for coverage and domain information. It works with boolean values and functions that produce Markdown elements or text pairs. It is used to dynamically generate documentation sections about Eva's analysis coverage and domain configurations when Eva is loaded.",
      "description_length": 350,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptor",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete SARIF 2.1 reporting descriptor with fields for identifiers, descriptions, message strings, configuration defaults, and relationships. It supports serialization to and from JSON using `to_yojson` and `of_yojson`, and provides a `create` function for constructing instances with optional fields. It is used to represent and manipulate rule or result descriptors in static analysis reports conforming to the SARIF format.",
      "description_length": 449,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Location",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a location in the SARIF 2.1 schema, combining a physical location, optional logical name, message, annotations, and properties. It provides functions to construct, convert to/from JSON, and create default or CIL-based locations. It is used to represent and report specific source code positions with contextual details in static analysis outputs.",
      "description_length": 366,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Node",
      "library": "frama-c-markdown-report.core",
      "description": "Handles the structure and serialization of SARIF node data, including identifiers, labels, locations, child nodes, and properties. Works with recursive node trees and converts them to and from JSON using `Yojson`. Used to build and manipulate hierarchical analysis results in SARIF format, such as representing code analysis paths or error traces.",
      "description_length": 347,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Session",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a session directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring they exist based on the `create_path` flag. Use cases include storing and accessing plugin-specific user data during analysis sessions.",
      "description_length": 342,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Remarks",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides operations to manage a file path option for structured remark data, including setting, retrieving, modifying, and serializing the value, along with handling change hooks and project-specific state tracking. It works with file path options as the core data structure, supporting default values and boolean checks for emptiness. These capabilities enable use cases like persisting and analyzing remark data during project workflows.",
      "description_length": 451,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Notification_kind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete type `t` representing the `notificationKind` field in the SARIF 2.1 specification, restricted to the values `\"note\"`, `\"warning\"`, and `\"error\"`. It provides direct constructors for each valid value and functions to convert to and from JSON using `Yojson.Safe.t`. This module is used to ensure correct and consistent representation of notification severities when generating or parsing SARIF output.",
      "description_length": 430,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Attachment",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF attachment data to and from JSON. Works with SARIF message, artifact location, region, and rectangle types. Used for embedding supplementary files or code snippets in SARIF-formatted analysis reports.",
      "description_length": 251,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactContent",
      "library": "frama-c-markdown-report.core",
      "description": "Handles content representation for artifacts in SARIF reports, supporting text, binary, and formatted message content. It provides functions to construct and decode artifact content with optional properties. Useful for embedding source code snippets or encoded data in analysis reports.",
      "description_length": 286,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptorRelationship",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines relationships between reporting descriptors in the SARIF 2.1 schema. It includes operations to construct, serialize, and deserialize these relationships using `Yojson`. The primary data type is a record with a target reference, optional kinds list, description, and properties. Use this module when linking analysis rules or results to their related descriptors in SARIF-formatted reports.",
      "description_length": 409,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Tool",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a tool record with a driver field, providing functions to create, serialize, and deserialize tool instances. It works with the `Markdown_report.Sarif.Driver.t` type and uses Yojson for JSON encoding and decoding. Concrete use cases include constructing and manipulating SARIF tool data structures for static analysis reporting.",
      "description_length": 347,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.FlameGraph",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides functionality for managing command-line parameters related to flame graph configuration, including setting and retrieving string values, handling update hooks, and defining aliases with default behaviors. It operates on string lists and structured data types that support marshaling, equality checks, and project-specific state management. These capabilities enable use cases such as validating function names against C-style naming conventions and ensuring correct parameter inputs for generating visualization outputs.",
      "description_length": 541,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Replacement",
      "library": "frama-c-markdown-report.core",
      "description": "Handles replacements in SARIF output by specifying deleted regions and inserted content. Works with `Region.t` and `ArtifactContent.t` to represent code changes. Used to generate precise code fix-its in SARIF reports.",
      "description_length": 217,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Json_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a string type for representing SARIF JSON content and provides serialization and deserialization functions using Yojson. It supports converting between a string-based SARIF representation and Yojson's abstract syntax tree. Use this module when generating or parsing SARIF output in JSON format, such as when integrating with static analysis tools or report generators.",
      "description_length": 388,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.FileChange",
      "library": "frama-c-markdown-report.core",
      "description": "Handles file change data in SARIF 2.1 reports, specifically tracking artifact locations and a list of code replacements. It provides serialization to and from JSON using `to_yojson` and `of_yojson`. Useful for tools that need to represent and manipulate source code modifications within SARIF-compliant analysis outputs.",
      "description_length": 320,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Edge_traversal",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for converting `Edge_traversal` values to and from JSON format using `Yojson`. It works with the `Edge_traversal` type, which includes fields such as `edgeId`, `message`, `finalState`, `stepOverEdgeCount`, and `properties`. Use this module when serializing or deserializing edge traversal data for SARIF output in analysis tools.",
      "description_length": 360,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.LogicalLocation",
      "library": "frama-c-markdown-report.core",
      "description": "Handles conversion of logical location data to and from JSON format, specifically supporting the SARIF 2.1 schema's logical location structure. Works with the `t` type, which includes fields like `name`, `fullyQualifiedName`, and `kind`. Used to serialize and deserialize logical location information for SARIF output in static analysis tools.",
      "description_length": 343,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Graph",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF graph data to and from JSON. It works with graph structures containing nodes, edges, descriptions, and properties. Used for converting SARIF-formatted analysis results to JSON for storage or transmission.",
      "description_length": 255,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ExternalPropertyFileReferences",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and creation of external property file references in SARIF format. Works with artifact locations, GUIDs, integers, and property objects. Used to generate SARIF-compliant JSON output for analysis tools.",
      "description_length": 223,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.StackFrame",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF stack frame data, conforming to the SARIF 2.1 schema. Works with structured data including location, thread identifiers, memory addresses, and parameter lists. Used to convert stack frame information to and from JSON for analysis tools and error reporting systems.",
      "description_length": 315,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Output",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages file path configurations for output generation, offering operations to set, retrieve, and modify paths with support for change hooks, default values, and command-line integration. It operates on a file path type (`Frama_c_kernel.Filepath.t`), including validation checks to determine if the path is empty. Designed for static analysis plugins, it facilitates persistent configuration tracking and marshaling in reporting workflows.",
      "description_length": 451,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Hash",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data structure for representing hash values and their algorithms in the SARIF 2.1 format. It includes functions to convert the structure to and from JSON, ensuring compatibility with SARIF standards. Use this module when generating or parsing SARIF reports that require artifact hashing for content identification.",
      "description_length": 336,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Notification",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a notification type aligned with the SARIF 2.1 schema, including structured fields for reporting issues such as rule ID, physical location, message, severity level, thread ID, timestamp, and associated exception. It provides serialization to and from JSON using `Yojson.Safe.t`, ensuring compatibility with SARIF output standards. Concrete use cases include generating structured diagnostic reports for static analysis tools.",
      "description_length": 445,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.PrintLibc",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a boolean flag that controls the inclusion of libc-related information in Markdown reports. It operates on a boolean value, providing functions to set, retrieve, and monitor state changes, with integration into Frama-C's state management and command-line interface for dynamic configuration during report generation.",
      "description_length": 336,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Invocation",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and construction of SARIF invocation records, including command-line arguments, execution metadata, and artifact references. Operates on structured data types like strings, lists, optional fields, and nested artifact location objects. Used to log tool execution details such as process start time, exit code, standard input/output paths, and environment variables in SARIF-compliant reports.",
      "description_length": 413,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Additional_properties",
      "library": "frama-c-markdown-report.core",
      "description": "Handles conversion and representation of additional properties in SARIF 2.1 format, specifically mapping string dictionaries to and from Yojson.Safe.t structures. Provides concrete functions `of_yojson`, `to_yojson`, and `default` for parsing, serializing, and initializing default property sets. Used when working with SARIF log data that includes arbitrary key-value metadata extensions.",
      "description_length": 389,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Region",
      "library": "frama-c-markdown-report.core",
      "description": "Handles region definitions in SARIF output, including creation, serialization, and conversion from CIL locations. Works with SARIF region records containing positional data like line and column ranges, byte offsets, and associated messages. Used to represent source code spans in static analysis reports, such as highlighting specific lines in a file where an issue was detected.",
      "description_length": 379,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Result_suppressionState",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete type for representing SARIF result suppression states, specifically `suppressedInSource` and `suppressedExternally`. It provides functions to convert these states to and from JSON format using Yojson. This type is used to indicate whether a result was suppressed directly in source code or through an external configuration in SARIF output.",
      "description_length": 371,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Rectangle",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for working with rectangular regions in SARIF output, specifically handling coordinates and associated messages. It supports serialization to and from JSON using `Yojson.Safe.t`, ensuring compatibility with SARIF schema requirements. Use cases include generating structured error reports with positional information in static analysis tools.",
      "description_length": 372,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.VersionControlDetails",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of version control metadata in the SARIF 2.1 schema. Works with `t` records containing URI, revision ID, branch, tag, timestamp, and properties. Used to convert version control details to and from JSON format for SARIF output generation.",
      "description_length": 279,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ThreadFlowLocation",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a thread flow location in a SARIF report, capturing execution steps with location, stack, and state details. It includes serialization and deserialization functions for JSON representation. Used to model and exchange precise code analysis paths in static analysis tools.",
      "description_length": 290,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.CodeFlow",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF code flow data structures to and from JSON. Works with `t` records containing message descriptions, thread flows, and custom properties. Used to convert SARIF code flow instances to JSON format for storage or transmission, and to parse JSON input into typed OCaml values for analysis tools.",
      "description_length": 341,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Result_kind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of string-based constants representing result kinds in the SARIF 2.1 schema, such as `pass`, `fail`, and `review`. It provides functions to convert these result kinds to and from Yojson for serialization and deserialization. These values are used to categorize the outcome of analysis rules in SARIF-formatted reports.",
      "description_length": 344,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponent",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete type `t` representing SARIF tool components with fields for metadata, descriptions, versioning, and internationalization. It provides functions to serialize and deserialize instances to and from JSON using `Yojson.Safe.t`, and a `create` function to construct instances with optional fields. Use this module to model static analysis tools in SARIF format, particularly when handling multilingual output or structured tool metadata.",
      "description_length": 462,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Sarif_result",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete SARIF result record with fields for error metadata, locations, and analysis context, supporting structured reporting of code analysis findings. It includes functions to serialize and deserialize results to and from JSON, and a `create` function to construct result instances with optional fields. Use cases include generating standardized error reports for static analysis tools and integrating with systems that consume SARIF output for dashboarding or triage.",
      "description_length": 492,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ThreadFlow",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF thread flow data to and from JSON. Works with SARIF thread flow records containing identifiers, messages, location sequences, and property bags. Used to convert thread flow data to JSON format for storage or transmission, and to parse JSON into structured thread flow objects for analysis tools.",
      "description_length": 346,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Verbose",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides integer-based verbosity control with operations to increment, set, and validate values within a configurable range. It manages an internal state integer, supporting dynamic adjustments through command-line interfaces and change monitoring via hooks. The design facilitates integration with state management systems for persistence and project-wide configuration in analysis workflows.",
      "description_length": 405,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.WebRequest",
      "library": "frama-c-markdown-report.core",
      "description": "Handles HTTP request data in SARIF 2.1 format, providing functions to create, serialize, and parse web request objects. Works with structured types like JSON string dictionaries, artifact content, and properties. Used to represent and manipulate HTTP requests within SARIF-compliant analysis reports.",
      "description_length": 300,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactLocation",
      "library": "frama-c-markdown-report.core",
      "description": "This module constructs and manipulates artifact location data conforming to the SARIF 2.1 schema. It handles conversions from JSON, creates locations from URIs and optional base paths, and derives locations from source code positions. It is used to map analysis results to specific source files and positions in a SARIF-compatible format.",
      "description_length": 338,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.TranslationMetadata",
      "library": "frama-c-markdown-report.core",
      "description": "Handles translation metadata for SARIF reports, including tool name, descriptions, and URIs. It supports serialization to and from JSON using `to_yojson` and `of_yojson`. Use it to define and persist metadata about analysis tools in SARIF output.",
      "description_length": 246,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Version",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a single valid value representing the SARIF 2.1.0 version string. It provides conversion functions to and from Yojson for serialization and deserialization. The module ensures correct handling of the version field in SARIF reports, specifically enforcing the use of the \"2.1.0\" version.",
      "description_length": 306,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Sarif_exception",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for handling SARIF exception data, including parsing from and converting to JSON, and provides a default exception structure. It works with the `t` type representing SARIF exceptions, which includes message, stack trace, and nested exceptions. Concrete use cases include serializing exceptions for logging, error reporting, and integration with SARIF-compliant tools.",
      "description_length": 398,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Date",
      "library": "frama-c-markdown-report.core",
      "description": "This module supports configuration and validation of date parameters using a custom string-based `Date.t` type integrated with Frama-C's analysis kernel. It provides operations for setting, retrieving, and validating date values through whitelisting and conditional parsing, alongside managing aliases and serialization. These features are designed for use in analysis sessions to ensure consistent date handling across reports and project-specific states.",
      "description_length": 456,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.MultiformatMessageStringDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents a dictionary mapping string keys to `MultiformatMessageString` values, adhering to the SARIF 2.1 schema. It provides functions to convert between JSON and the OCaml dictionary type, ensuring proper serialization and deserialization. It is used to handle internationalized diagnostic messages in SARIF output, where each key typically represents a message identifier.",
      "description_length": 389,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Debug",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages integer parameters for debugging static analysis tools, supporting bounded value increments, range validation, and project-specific state tracking. It uses an integer type `t` with associated metadata to handle update hooks, aliases, and custom serialization, enabling dynamic adjustments during analysis. Key use cases include enforcing iteration limits, tracking analysis progress, and generating diagnostics with structured parameter constraints.",
      "description_length": 469,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Share",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages paths related to a shared directory for a plugin, providing functions to set, retrieve, and check the directory location. It supports operations to locate specific subdirectories or files within the shared directory, ensuring they exist and are of the correct type. Use cases include loading plugin-specific resources like templates or configuration files from a predefined directory structure.",
      "description_length": 414,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Custom_properties",
      "library": "frama-c-markdown-report.core",
      "description": "This module handles custom properties in SARIF 2.1 reports, specifically encoding and decoding JSON objects with arbitrary key-value pairs. It operates on `Yojson.Safe.t` values and uses dictionary-like structures to represent custom metadata. Use this module to extend SARIF output with additional analysis data such as tool-specific annotations or diagnostic attributes.",
      "description_length": 372,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ExternalFiles",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF external file references to and from JSON. Works with `ArtifactLocation.t` records nested within the `ExternalFiles.t` type. Used to manage file paths and artifact locations in SARIF reports when converting between OCaml and JSON formats.",
      "description_length": 289,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.RunAutomationDetails",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for constructing and serializing SARIF run automation details, including creating instances with optional fields like description, ID, GUID, and properties. It works with structured data types such as `Message.t`, `Properties.t`, and string identifiers. Concrete use cases include generating automation metadata for SARIF reports and converting between OCaml and JSON representations using `to_yojson` and `of_yojson`.",
      "description_length": 449,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.MultiformatMessageString",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents a SARIF multiformat message string with `text`, `markdown`, and `properties` fields. It provides functions to construct instances using `create`, parse from JSON with `of_yojson`, and access a default value. It is used to handle diagnostic messages that include both plain text and formatted content in SARIF reports.",
      "description_length": 340,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages string-based command-line parameters and collections, enabling operations like value assignment, retrieval, state validation, and lifecycle hooks for dynamic updates. It operates on string lists, categorized parameter groups, and alias mappings, with applications in static analysis tool configurations requiring parameter grouping, validation, and integration with project state management.",
      "description_length": 411,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Artifact",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines an artifact in the SARIF 2.1 schema, representing a source code file or other content analyzed during a static analysis run. It includes fields for metadata like file location, encoding, and content, along with functions to serialize to JSON (`to_yojson`) and construct instances (`create`). It is used to describe input files in static analysis reports, including their content, offsets, and associated properties.",
      "description_length": 435,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ColumnKind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a single type `t` representing the possible column kinds in the SARIF 2.1 schema, specifically for indicating how column positions are measured in source code. It includes two predefined values: `utf16CodeUnits` and `unicodeCodePoints`, which correspond to the two valid column kind literals in the SARIF specification. This type is used when generating or parsing SARIF output to ensure correct interpretation of column positions in source files.",
      "description_length": 467,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Address",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data structure representing an address in a SARIF (Static Analysis Results Interchange Format) report, specifically tailored for the 2.1 schema. It includes fields such as absolute and relative addresses, length, kind, name, and references to parent elements, enabling precise location tracking in code analysis outputs. The module supports serialization to and from JSON using `Yojson`, and provides a `create` function for constructing instances with optional fields, along with a predefined `default` value for convenience.",
      "description_length": 548,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Properties",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a type `t` that represents properties in the SARIF 2.1 schema, including a list of tags and a collection of custom key-value pairs. It provides functions to construct a property value, parse it from JSON, and access a default instance. Use this module when building or validating SARIF output that requires structured metadata and custom extensions.",
      "description_length": 369,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Role",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of string-based constants representing roles for artifacts in the SARIF 2.1 schema. It includes specific roles such as `analysisTarget`, `attachment`, `responseFile`, and others for categorizing files and streams in static analysis reports. These values are used to specify the purpose or context of files and streams when generating or parsing SARIF output.",
      "description_length": 384,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Uri",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a type for URIs used in SARIF reports, ensuring valid string representations. It provides conversion functions to and from Yojson for serialization and deserialization. A predefined URI for GitHub integration is included for direct use in SARIF output.",
      "description_length": 272,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Stl_importance",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines string-based values representing importance levels in a SARIF report, with specific constants for `important`, `essential`, and `unimportant`. It provides serialization and deserialization to and from JSON using Yojson, ensuring compatibility with the SARIF 2.1 schema. These values are used to categorize the severity or relevance of analysis results in static code analysis tools.",
      "description_length": 402,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Fix",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the `Fix` type for representing SARIF 2.1 fix data, including a description and a list of file changes. It provides JSON serialization and deserialization functions using `Yojson.Safe`. It is used to encode and decode fix information in SARIF output for tools that support automated code fixes.",
      "description_length": 314,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.JsonStringDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module implements a dictionary mapping strings to strings, specifically for handling JSON key-value pairs in the SARIF 2.1 schema. It provides serialization to and from Yojson.Safe.t for structured JSON output and input parsing. This dictionary is used to represent metadata or annotations in SARIF reports, such as rule properties or tool extensions.",
      "description_length": 356,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Config_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a plugin-specific configuration directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the user directory. Concrete use cases include initializing plugin state from a configuration directory, storing generated files, or ensuring consistent access to user-specific settings.",
      "description_length": 441,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Cache_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a cache directory path for a plugin, providing functions to retrieve, set, and check the existence of the directory. It works with file paths represented as `Frama_c_kernel.Filepath.t`, handling both directories and files within the cache. Concrete use cases include storing and accessing cached analysis results or temporary files during static code analysis.",
      "description_length": 380,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.SarifDeterministic",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides operations to manage a boolean flag that enforces deterministic behavior in SARIF output generation, including functions to set its state (`on`/`off`), register callbacks for value changes, and handle serialization for persistence. The flag interacts with a shared internal state variable and supports project-specific configuration management within Frama-C's parameter system. It is used to ensure reproducibility of analysis results across runs, such as in automated testing or collaborative environments where consistent SARIF outputs are required.",
      "description_length": 573,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.GraphTraversal",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF graph traversal data structures to and from JSON. Operates on the `t` type, which includes graph identifiers, descriptions, initial states, edge traversals, and properties. Used to convert SARIF graph traversal information to JSON format for storage or transmission, and to parse such data from JSON input.",
      "description_length": 357,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Stack",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF stack data to and from JSON. Works with SARIF messages, stack frames, and properties. Used to convert SARIF error stacks to JSON format for output or analysis tools.",
      "description_length": 216,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponentReference",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a reference to a tool component within a SARIF report, capturing metadata such as name, index, GUID, and custom properties. It provides functions to serialize and deserialize these references to and from JSON, and to create instances with optional fields. It is used to identify and configure specific tool components when generating or processing SARIF output from static analysis tools.",
      "description_length": 408,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors",
      "library": "frama-c-markdown-report.core",
      "description": "This component handles command-line author lists through a structured, type-safe collection of strings, supporting operations like addition, iteration, folding, and emptiness checks. It integrates validation, change hooks, and category-based classifications (e.g., `@none`, `@default`) while enabling customizable serialization and alias management for author metadata. Designed for tools requiring dynamic author tracking with flexible input handling and type consistency.",
      "description_length": 473,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Message",
      "library": "frama-c-markdown-report.core",
      "description": "This module constructs and manipulates SARIF message objects, supporting both plain text and Markdown-formatted content. It handles messages with optional identifiers, argument substitutions, and associated properties. Use it to generate diagnostic or log messages in SARIF output, such as reporting analysis results with structured formatting and localization support.",
      "description_length": 369,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Title",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides operations for managing a title parameter in markdown reports, including value setting/retrieval, change hooks, alias handling, and serialization, while enforcing validation rules for allowed values or predefined string lists. It works with string-based types and structured datatypes to support use cases like configuration management, project state tracking, and enforcing naming conventions for report titles across sessions.",
      "description_length": 449,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_level",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of string-based constants representing result levels in the SARIF 2.1 schema, including `none`, `note`, `warning`, and `error`. It provides functions to convert these levels to and from Yojson for serialization and deserialization. These values are used to categorize the severity of analysis results in SARIF-formatted reports.",
      "description_length": 354,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptorReference",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a reference to a reporting descriptor in the SARIF 2.1 schema. It includes fields for identifier, index, GUID, tool component reference, and custom properties, supporting serialization to and from JSON. It is used to uniquely identify and describe analysis rules or findings within a SARIF log.",
      "description_length": 314,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Generate",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides operations for managing string command-line options with state tracking through hooks, enabling value configuration, alias handling, and serialization. It works with enriched string types and lists to enforce validation rules, sanitize inputs, and validate parameter names, primarily used in configuring analysis parameters and handling command-line interactions where dynamic value changes and consistent state management are required.",
      "description_length": 457,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Conversion",
      "library": "frama-c-markdown-report.core",
      "description": "Converts OCaml representations of SARIF 2.1 schema components to and from JSON using Yojson. It handles structured data including tool, invocation, and artifact location information. Enables serialization and deserialization of SARIF log data for storage or transmission.",
      "description_length": 271,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Driver",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides functions to construct and manipulate SARIF driver objects with specific metadata fields like name, version, and URIs. It supports serialization to and from Yojson for integration with JSON-based workflows. A concrete use case is generating standardized SARIF output for static analysis tools, ensuring compliance with the SARIF 2.1 schema.",
      "description_length": 361,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.RuleConfigLevel",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines string-based constants representing SARIF rule configuration levels such as `none`, `note`, `warning`, and `error`. It provides direct values for these levels and supports conversion to and from JSON using Yojson. These values are used to specify the severity or reporting level of rules in SARIF-formatted output.",
      "description_length": 334,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.SpecialLocations",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manipulates special location data within a SARIF report, specifically handling artifact locations and associated properties. It supports creating, serializing, and deserializing special location records to and from JSON. This is used when generating SARIF output that references specific files or locations in source code artifacts.",
      "description_length": 356,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.State_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a user-defined directory path for storing state information, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations conditioned on directory existence. Concrete use cases include storing plugin-specific state files, ensuring paths exist before writing analysis results, and managing user-configured directories without runtime creation.",
      "description_length": 468,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.WebResponse",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and construction of SARIF web response objects. It supports creating structured web response data with fields like status code, headers, and body content, using types such as `JsonStringDictionary` and `ArtifactContent`. This module is used to generate SARIF-compliant web response entries for analysis tools that need to report HTTP interaction results.",
      "description_length": 376,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Edge",
      "library": "frama-c-markdown-report.core",
      "description": "Handles conversion of SARIF edge data structures to and from JSON format. Works with SARIF edge records containing node identifiers, labels, and properties. Used to serialize and deserialize SARIF edges for analysis tools and reporting systems.",
      "description_length": 244,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingConfiguration",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the configuration for reporting rules in a SARIF (Static Analysis Results Interchange Format) output. It includes fields to control whether a rule is enabled, its default severity level, priority rank, and customizable parameters and properties. It is used to configure how analysis results are reported, influencing rule behavior and output metadata during static analysis tool execution.",
      "description_length": 409,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Json_dictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module converts between a dictionary structure and Yojson representations, specifically handling the SARIF 2.1 schema. It provides `of_yojson` to parse a Yojson object into a typed dictionary and `to_yojson` to serialize the dictionary back into a Yojson object. Use this when working with SARIF-formatted JSON data, such as generating or parsing static analysis results in a toolchain.",
      "description_length": 391,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_baselineState",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a string-based enumerated type representing the baseline state of a SARIF result, with specific values for new, existing, and absent states. It provides functions to convert between JSON and these states, ensuring compatibility with SARIF schema 2.1. This module is used to track whether a result is newly introduced, already present in the baseline, or no longer present.",
      "description_length": 392,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Schema",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the structure and serialization logic for SARIF 2.1 schema reports. It supports converting SARIF data to and from JSON using `to_yojson` and `of_yojson`, and constructing SARIF objects with `create` using optional schema and version fields along with a list of runs. It is used to generate and manipulate static analysis results in a format compatible with tools expecting SARIF output.",
      "description_length": 406,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.PhysicalLocation",
      "library": "frama-c-markdown-report.core",
      "description": "Handles physical location data in SARIF 2.1 reports, including artifact references, source regions, and contextual regions. It supports serialization to and from JSON, creation with optional fields, and conversion from Frama-C location data. Used to represent and manipulate source code positions in static analysis results.",
      "description_length": 324,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif",
      "library": "frama-c-markdown-report.core",
      "description": "This component provides structured data handling for SARIF 2.1 schema elements, focusing on JSON serialization/deserialization of static analysis artifacts like diagnostic messages, source locations, stack traces, and tool metadata. It operates on typed OCaml representations of SARIF entities\u2014including graphs, logical locations, and rule configurations\u2014using `Yojson.Safe.t` for precise round-trip encoding. Designed for static analysis workflows, it supports error reporting, result exchange, and integration with SARIF-compliant tools through artifact management, code fix suggestions, and version-controlled metadata.",
      "description_length": 622,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Parse_remarks",
      "library": "frama-c-markdown-report.core",
      "description": "Reads Markdown skeleton files to extract manually written comments associated with report sections. Maps each section anchor to its corresponding list of Markdown elements. Enables embedding custom textual content into specific parts of a generated analysis report.",
      "description_length": 265,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_register",
      "library": "frama-c-markdown-report.core",
      "description": "Registers the main entry point for a plugin, handling initialization and setup. Works with plugin-specific data structures to configure and launch the plugin's core functionality. Used when integrating a new plugin into the system to ensure proper loading and execution.",
      "description_length": 270,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params",
      "library": "frama-c-markdown-report.core",
      "description": "This module supports structured logging, parameter validation, and state persistence for static analysis workflows, operating on categorized events, key-value configuration pairs (strings, integers, paths), and source-position metadata. It enables use cases like tailoring diagnostic verbosity, filtering debug output via active keys, and maintaining project-specific analysis settings across sessions through validated command-line aliases and output path management. Core operations include emitting severity-tiered messages, registering warning categories with continuation handlers, and persisting structured report metadata (authors, remarks) with kernel integration.",
      "description_length": 672,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif_gen",
      "library": "frama-c-markdown-report.core",
      "description": "Generates a SARIF JSON object representing analysis results. Works with internal data structures modeling code analysis findings and their metadata. Useful for exporting static analysis output in a standardized format for integration with tools like GitHub Code Scanning.",
      "description_length": 271,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Md_gen",
      "library": "frama-c-markdown-report.core",
      "description": "Generates Markdown reports for Eva's analysis, supporting draft or final output based on a flag. Works with boolean state and functions that build Markdown content. Used to produce documentation sections detailing Eva's coverage and domain configurations during report generation.",
      "description_length": 280,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report",
      "library": "frama-c-markdown-report.core",
      "description": "This module assembles Markdown and SARIF report generation capabilities for static analysis results. It provides functions to create structured Markdown documentation from analysis data, generate SARIF-compliant JSON output, register plugins for report generation, parse and integrate manual remarks into reports, and manage analysis parameters with structured metadata. It is used to produce detailed, standardized analysis reports with customizable formatting and integrated diagnostic data.",
      "description_length": 493,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for handling sets of strings with operations for comparison, hashing, and pretty-printing. It provides functionality for checking membership in projects, deep copying values, and managing representants for type descriptors. Concrete use cases include tracking string-based identifiers in static analysis plugins and managing project-specific data within Frama-C.",
      "description_length": 394,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling file paths as strings, supporting operations like equality, comparison, hashing, and pretty printing. It works with file path strings and project skeletons, enabling checks on project membership and deep copying of values. Concrete use cases include managing and comparing file paths in static analysis contexts, such as tracking source file origins or filtering based on project structure.",
      "description_length": 434,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for handling sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering through a `mem_project` function. The type is used to represent and manipulate string sets in a way that ensures structural integrity and efficient lookup.",
      "description_length": 365,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a data type with standard operations for representing and manipulating string-based values in a Frama-C plugin analysis. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to handle string data within abstract interpretation or analysis plugins that require persistent, comparable, and storable values.",
      "description_length": 414,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality checking, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type to represent file paths and includes functions for deep copying values and checking membership based on project criteria. Concrete use cases include managing and comparing collections of file paths within static analysis tools.",
      "description_length": 437,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values as strings within a multi-map structure. It includes standard utilities such as equality, comparison, hashing, pretty printing, and deep copying, tailored for string-based data handling. Concrete use cases include managing and querying string-represented identifiers or labels in static analysis contexts, ensuring value integrity and project membership checks.",
      "description_length": 462,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for handling string-based representations in a static analysis context. It includes standard functionalities such as equality checks, comparison, hashing, and pretty printing, specifically tailored for string values used in analysis scripts. The type supports deep copying and project membership checks, enabling precise manipulation and querying of string data across different analysis phases.",
      "description_length": 443,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type and associated operations for handling multiple string mappings in a structured, typed manner. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, all tailored to values that represent collections of strings. It is used in contexts requiring precise manipulation and analysis of string-based data structures, such as static analysis passes or transformation pipelines.",
      "description_length": 447,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for representing and manipulating string-based values in a functional analysis context. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, ensuring value integrity and usability in analysis workflows. The type is used to handle string parameters within kernel function maps, particularly for static analysis tasks involving function declarations and prototypes.",
      "description_length": 443,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations. It supports checking membership within projects and provides deep copying to ensure no shared references. Use cases include managing and manipulating string identifiers in static analysis contexts, such as tracking variable names or function signatures across different analysis phases.",
      "description_length": 437,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It supports persistent storage and project-aware membership checks, making it suitable for analysis scripts that need to track string lists across different project contexts. The type `t` represents the encapsulated string list, while functions like `mem_project` and `copy` enable project-specific filtering and deep cloning.",
      "description_length": 479,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically for representing and manipulating strings in a static analysis context. It includes functions for checking membership based on project filters and performing deep copies, ensuring no shared references. It is used to handle string-based identifiers or representations within Frama-C's analysis framework, supporting tasks like function declaration tracking or string-based state management.",
      "description_length": 510,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for handling string-based values in a structured, typed collection. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to represent and manipulate string data within Frama-C's kernel, supporting analysis scripts that require typed string handling with full type metadata and structural operations.",
      "description_length": 434,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing string-based values. It supports set operations and project membership checks, enabling efficient representation and manipulation of string collections in static analysis contexts. Use cases include tracking string identifiers or values during program analysis, ensuring unique naming, and managing string-based state representations.",
      "description_length": 437,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of strings with operations for comparison, hashing, and pretty-printing. It supports concrete use cases like tracking string-based identifiers or annotations in static analysis, ensuring deep copying and project membership checks. The data structure is integrated with Frama-C's kernel for analysis plugins requiring string list manipulations.",
      "description_length": 393,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling file paths. It includes functions for deep copying values and checking membership based on project properties, ensuring no shared state between copies. The type supports integration with Frama-C's internal mechanisms through a named descriptor and a packed representation, facilitating use in analysis plugins that require precise path tracking and value comparison.",
      "description_length": 512,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C kernel plugins. It includes functions for deep copying values, checking membership of project-specific data, and managing type descriptors for structural representation. It is used to handle and manipulate complex data structures within Frama-C's analysis frameworks, such as abstract domains or custom value representations.",
      "description_length": 461,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in static analysis contexts. It supports working with a structured descriptor and provides deep copying, membership testing based on project properties, and representant values. Concrete use cases include managing and comparing abstract values in Frama-C plugins, particularly for analyses requiring precise type handling and value representation.",
      "description_length": 488,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Empty_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project-related values, and includes type descriptors for integration with Frama-C's plugin system. The data type is designed to represent and manipulate values within static analysis plugins, particularly handling empty strings in list-based analyses.",
      "description_length": 432,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Action.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in static analysis contexts. It includes support for deep copying values and checking membership based on project-related predicates. The type is integrated with Frama-C's kernel structures, making it suitable for representing and manipulating analysis-specific data during program verification tasks.",
      "description_length": 442,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This component offers operations to manage string parameters with validation, change tracking, and command-line integration for Frama-C plugins. It works with string values constrained by allowed options or validation rules, supporting use cases like configurable settings with defaults, alias resolution, and persistent value management across project sessions. Key patterns include restricting input to predefined values, customizing serialization, and linking parameter changes to plugin behavior through hooks.",
      "description_length": 514,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for handling lists of strings with operations for equality, comparison, hashing, and pretty printing. It supports integration with Frama-C's type system through descriptors and provides deep copying and project membership checks. Use cases include representing and manipulating string-based data structures in static analysis plugins.",
      "description_length": 366,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing string parameters with dynamic configuration, validation against predefined allowed values, and integration with Frama-C's plugin system. It works with a string-based parameter type (`As_string.t`) to support command-line argument parsing, serialization, and state tracking through update hooks. Specific use cases include configuring analysis scripts with validated string inputs, enforcing function name validation rules, and exposing plugin parameters to Frama-C's command-line interface.",
      "description_length": 536,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Bool.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a boolean list data structure with standard operations including equality, comparison, hashing, and pretty printing. It supports list manipulations specific to Frama-C's analysis framework, such as checking membership based on project properties and performing deep copies. Concrete use cases include tracking and analyzing boolean expressions in static code analysis, particularly in value and dependency tracking across program states.",
      "description_length": 457,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of string-based elements, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It supports setting accessors and dependencies for categories and controls how the `@all` category behaves in different contexts. Concrete use cases include organizing and selecting subsets of string-based parameters in static analysis configurations.",
      "description_length": 439,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers utilities for managing string-based configuration parameters with state tracking, including operations to set and validate values against allowed options, handle aliases, and register update hooks. It works with strings and string lists, supporting use cases in static analysis tools where parameter validation, dynamic configuration updates, and serialization are required\u2014for example, handling command-line arguments or runtime tunables.",
      "description_length": 458,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for parameter grouping, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.Parameter_category.t` and supports setting accessors, dependencies, and interpretations for these categories. Concrete use cases include configuring analysis parameters, enabling global settings, and defining default or fallback behaviors for category-based selections.",
      "description_length": 465,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a parameter system, providing operations to define, retrieve, and configure named categories with dependencies and access rules. It works with category types represented as `t` and `elt`, and interacts with state lists to control parameter behavior. Concrete use cases include setting up default categories, enabling global category behavior with specific interpretations, and defining category inheritance or equivalence.",
      "description_length": 457,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories used to group and control analysis parameters in a configuration system. It supports operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each influencing how parameters are interpreted and enabled. Use cases include setting up analysis profiles, enabling groups of parameters collectively, and defining fallback behaviors for unspecified settings.",
      "description_length": 430,
      "index": 230,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` and associated operations for handling values that represent multiple string maps, including equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project skeletons, and integrates with Frama-C's type and descriptor system for analysis purposes. Concrete use cases include tracking and comparing string map states across different analysis contexts and projects.",
      "description_length": 452,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a string set data structure with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks, deep copying, and project-based filtering through the `mem_project` function. Concrete use cases include tracking sets of string identifiers across program analyses and managing project-specific string data in Frama-C plugins.",
      "description_length": 387,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports structured data representation with a descriptor and a list of representatives, enabling type inspection and memory management. Concrete use cases include tracking and comparing abstract values during program analysis, such as representing sets of possible runtime states or type information for variables.",
      "description_length": 468,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Float.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing floating-point numbers with optional decimal points, supporting operations such as equality, comparison, hashing, and pretty printing. It includes functions for deep copying values, checking membership based on project conditions, and providing type descriptors for integration with analysis frameworks. Use cases include precise numeric analysis and transformation of floating-point data in program analysis tasks.",
      "description_length": 464,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports managing string-based file path parameters with operations for setting, validation against allowed values, handling aliases and function name resolution, and serialization, integrating with Frama-C's state system. It operates on string values and lists, enabling use cases such as static analysis workflows where file paths must be validated, aliased, or persisted across sessions.",
      "description_length": 402,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-based parameters for static analysis configurations, offering validation against predefined value sets, function name resolution, and CLI integration. It operates on string values and lists of strings to enforce constraints, track mutable state across projects, and handle aliases or marshaled representations. Typical use cases include restricting analysis options to valid function names or controlled vocabularies while supporting dynamic updates and cross-context persistence.",
      "description_length": 507,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use within Frama-C's kernel. It includes support for checking membership based on project properties and deep copying to prevent shared state. The type is used to represent and manipulate structured values in static analysis scripts, particularly for tracking and comparing data across different analysis states.",
      "description_length": 436,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter collections, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with `Category.t` values, which represent named categories, and interacts with `Frama_c_kernel.State.t` lists and accessors. Concrete use cases include setting up configurable analysis categories, enabling global category behaviors, and defining default or special-purpose categories like `@none`, `@default`, and `@all`.",
      "description_length": 505,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a concrete data type for handling string-based values with support for equality checks, comparison, hashing, and pretty-printing. It provides operations to create, compare, and manipulate string instances, along with deep copying and project membership testing. Use cases include representing and analyzing string constants or identifiers within Frama-C plugins, particularly for static analysis tasks requiring precise string value tracking.",
      "description_length": 465,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories used to group and control the behavior of analysis parameters. It provides operations to create, modify, and retrieve categories such as `@none`, `@default`, and `@all`, each influencing how analysis states are interpreted and combined. These categories are used to structure the activation and interaction of different analysis components in a precise and configurable way.",
      "description_length": 417,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements operations for defining and managing string-based analysis parameters with validation, default handling, and value change notifications. It operates on string parameters associated with allowed value lists and serialization logic, using maps to store parameter metadata such as validation rules and default values. The module is designed for static analysis tools like Frama-C, where parameters must be validated against predefined options or integrated into project state management systems.",
      "description_length": 515,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis scripts. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. The type is used to represent and manipulate analysis-specific data structures in a way that integrates with Frama-C's kernel infrastructure.",
      "description_length": 407,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing configurable string parameters with validation against allowed value lists, change tracking via hooks, and command-line integration. It operates on strings and string lists, supporting use cases like dynamic configuration management where parameters require validation, default handling, or persistent state tracking across tool invocations. Key capabilities include value restriction to predefined options, callback execution on changes, and seamless CLI argument synchronization.",
      "description_length": 526,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module enables managing string-based parameters within a multi-map structure, supporting operations like setting values, defining allowed options, validating inputs against predefined rules or function names, and integrating with command-line interfaces via parameter marshaling and alias handling. It is particularly suited for configuration management and state tracking scenarios where string values require validation, dynamic updates, or project-specific contextualization.",
      "description_length": 483,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a string set collection, providing operations to define and manipulate category behaviors such as `none`, `default`, and `all`. It works with category types tied to `Frama_c_kernel.Parameter_category`, supporting dynamic category creation, dependency assignment, and global category overrides. Concrete use cases include configuring analysis parameters with named categories, enabling bulk category activation, and defining fallback behaviors for unspecified categories.",
      "description_length": 505,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Zero.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugin development. It supports structural analysis through descriptors and representants, enabling deep copying and membership checks within project contexts. Concrete use cases include managing and comparing abstract values in static analysis passes, such as tracking variable states or constraint sets across program points.",
      "description_length": 458,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types that represent parameter groups, including special categories like `@none`, `@default`, and `@all`. Concrete use cases include configuring analysis parameters, enabling global category behavior, and mapping category names to specific states and accessors in static analysis scripts.",
      "description_length": 487,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for parameter configurations, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and uses accessors to link categories to states. Concrete use cases include setting up configurable analysis modes, enabling global behavior via `@all`, and redirecting category behavior using `enable_all_as`.",
      "description_length": 456,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in a map structure that disallows multibindings. It includes support for deep copying values and checking membership based on project properties. Typical use cases include managing unique, structured keys in analysis scripts where precise value identity and ordering are required.",
      "description_length": 401,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports structured data representation with capabilities for project membership checks and deep copying, ensuring no shared references. Concrete use cases include managing and comparing analysis states or configurations in Frama-C plugins.",
      "description_length": 393,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Debug.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis scripts. It includes functions for deep copying values, checking membership of project-specific data, and integrates with Frama-C's type and descriptor system for structural representation. The type supports serialization through a packed descriptor and is used to manage and analyze program representations in debugging and analysis workflows.",
      "description_length": 495,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage string-typed configuration parameters in static analysis workflows, including setting and validating values, registering change hooks, and handling aliases. It operates on strings and string lists for value constraints, with specialized logic to check function names against valid prototypes or declarations. Typical use cases involve tracking analysis script parameters, enforcing project-specific state consistency, and validating dynamic inputs during kernel function customization.",
      "description_length": 527,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.False.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structured data representation with deep copying, membership testing within projects, and type descriptors for integration with Frama-C's kernel. Concrete use cases include managing analysis states, tracking value representations, and enabling project-specific queries in plugin extensions.",
      "description_length": 458,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Enum.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a finite enumerated type `t` with operations for structural comparison, hashing, and pretty-printing. It provides a list of all possible values (`all_values`), a string representation function (`to_string`), and a type descriptor for integration with Frama-C's kernel. The type supports deep copying, membership testing within projects, and is intended for use in contexts requiring closed sets of values, such as analysis options or fixed configuration parameters.",
      "description_length": 485,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage mutable string parameters with validation against predefined allowed values, supporting both plain string retrieval and function name resolution. It operates on global parameter states using lists of valid strings for validation, while offering metadata handling through aliases, help messages, and serialization hooks. The functionality is particularly useful for configuration validation in analysis scripts and distinguishing between symbolic function names and literal string inputs during static analysis workflows.",
      "description_length": 562,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string parameters with change hooks, serialization, and validation against predefined string lists, supporting configuration-driven static analysis workflows. It operates on strings and string lists to enforce allowed values, validate identifiers like function names, and maintain global parameter state, primarily for Frama-C's analysis tools requiring precise string-based configuration. Use cases include command-line argument parsing, analysis parameter constraints, and dynamic configuration updates with side-effect tracking.",
      "description_length": 551,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-valued command-line parameters with metadata, supporting operations to define allowed values via string lists, validate inputs against these constraints, and register hooks for updates or serialization. It is designed for scenarios requiring strict parameter validation, dynamic behavior through function aliases, and structured state management in project configurations.",
      "description_length": 399,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing string-valued analysis parameters with validation, including setting/retrieving values, defining allowed options, and enforcing rules for function names. It works with `As_string.t` for string data and uses lists of strings to specify valid values, integrating with Frama-C's plugin system for command-line parsing and project state management. Specific use cases include restricting parameters to predefined string options and validating identifiers against external naming conventions during analysis configuration.",
      "description_length": 562,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling file paths in a static analysis context. It includes functions for deep copying values, checking membership based on project properties, and integrates with Frama-C's type and descriptor system. Concrete use cases include representing and manipulating file paths during the analysis of C codebases, ensuring accurate tracking and comparison of file-based data across different analysis phases.",
      "description_length": 539,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for a parameter map, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with `Category.t` values, which represent named categories, and interacts with Frama-C's state and parameter systems. Use cases include setting up configurable analysis categories, defining default and special '@all' behaviors, and enabling category-based parameter resolution in static analysis scripts.",
      "description_length": 482,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Verbose.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating analysis data in Frama-C. It includes functions for checking membership based on project properties, deep copying values, and exposing type information through a descriptor. Concrete use cases include tracking and analyzing function lists in C code, where each value represents a function with associated metadata.",
      "description_length": 481,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter states and accessors, allowing dependencies and interpretations to be specified. Concrete use cases include configuring analysis parameters with custom categories, enabling global behavior via `@all`, and redirecting category behavior using `enable_all_as`.",
      "description_length": 477,
      "index": 262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. The type is typically used to represent and manipulate analysis-specific data structures with strict identity and structural constraints.",
      "description_length": 404,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing file path string parameters with change hooks and default handling, alongside utilities to restrict and validate sets of allowed string values. It works with individual strings and string lists, supporting use cases like command-line option parsing, project state persistence, and controlled function name resolution in analysis workflows.",
      "description_length": 384,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype with operations for managing a map structure that allows multiple bindings per key. It provides functionalities for equality checks, comparison, hashing, pretty-printing, and deep copying of map entries, as well as checking membership based on project properties. The data type is designed for use in static analysis contexts where key-value relationships must be tracked across multiple analysis passes.",
      "description_length": 435,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering using `Project_skeleton.t`. Concrete use cases include tracking and analyzing collections of string identifiers in static analysis contexts.",
      "description_length": 341,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of file paths, providing operations to define, modify, and enable categories with specific behaviors. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include setting up configurable groups like `@none`, `@default`, and `@all`, enabling unified handling of file path selections based on analysis needs.",
      "description_length": 436,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for a parameter map with multibindings, supporting operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and uses accessors and state lists to define category behavior. Use cases include setting up configurable analysis categories in static analysis tools, where categories control parameter propagation and interpretation.",
      "description_length": 466,
      "index": 268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of elements, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types that encapsulate element types and state dependencies, supporting dynamic category creation and access control. Concrete use cases include configuring analysis parameters with custom categories, enabling global behavior through `@all`, and setting default interpretations for unspecified cases.",
      "description_length": 495,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.WithOutput.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` and a set of operations for managing and manipulating values of that type. It includes functions for equality checking, comparison, hashing, pretty printing, deep copying, and project membership testing, all tailored to the specific structure of `t`. The type `t` is integrated with Frama-C's datatype system, supporting use cases such as static analysis state representation, value tracking across program transformations, and structured data persistence in analysis plugins.",
      "description_length": 512,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Int.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling integer lists with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project skeletons, ensuring no shared references. Use cases include analyzing and manipulating integer lists in Frama-C plugins, particularly for static analysis tasks requiring precise data representation and comparison.",
      "description_length": 402,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` representing file paths, along with standard operations including equality, comparison, hashing, and pretty printing. It provides a unique name, type descriptor, and support for deep copying and project membership checks. Concrete use cases include managing and comparing file paths within Frama-C's analysis framework, particularly when tracking or analyzing project-specific data.",
      "description_length": 425,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Custom.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports complex data manipulation and project membership checks, enabling precise data representation and transformation in Frama-C plugins. The type is designed for deep copying and structural inspection, making it suitable for analyses requiring persistent or modified data states.",
      "description_length": 444,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.True.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a concrete data type `t` with associated operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project skeletons, and includes type descriptors for integration with Frama-C's kernel. The type supports structural comparisons and is intended for representing and manipulating values within static analysis plugins.",
      "description_length": 401,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter collections, supporting operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and uses accessors and state lists to define category behavior. Concrete use cases include setting up default parameter interpretations, enabling global category behavior, and defining dependencies for specific parameter groups.",
      "description_length": 476,
      "index": 275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintDeclarations.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a concrete data type `t` representing a structured data descriptor, along with operations for equality, comparison, hashing, and pretty printing. It provides access to the type's name, descriptor, packed descriptor, and representative values, enabling introspection and serialization. Use cases include analyzing and printing datatype declarations in a static analysis tool, where deep copying and project membership checks are required for accurate representation and transformation.",
      "description_length": 504,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.State_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a specific state directory for a plugin, providing functions to retrieve or create directories and files within that state directory. It works with file paths represented by `Frama_c_kernel.Filepath.t`, allowing clients to set, get, and check the existence of the state directory. Concrete use cases include storing and accessing plugin-specific configuration or output files in a structured way.",
      "description_length": 416,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_user_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module constructs a user directory within an existing parent directory. It provides `get_dir` and `get_file` functions to retrieve or create directories and files under the new user directory, with optional path creation. Use cases include setting up isolated working directories for user-specific data storage or temporary file management.",
      "description_length": 345,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing sets of kernel functions and collections of kernel_function elements, including membership checks, iteration, state management, and command-line configuration. It works with Frama_c_kernel.Cil_datatype.Kf.Set.t for set operations and leverages modules like Datatype for serialization and As_string for string parameter handling. These tools are used in Frama-C plugin development to implement static analysis features that require tracking kernel function states or categorizing elements with validated configurations.",
      "description_length": 563,
      "index": 279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides stateful management of file path mappings with operations for setting, retrieving, and tracking changes to values associated with file paths, alongside serialization and equality checks. It works with validated string parameters, categorized configurations, and aliased file path collections, supporting analysis plugins that require precise project-specific data tracking integrated with Frama-C's kernel. Use cases include static analysis tools needing hierarchical parameter organization, stateful hooks for file path events, and cross-project data consistency enforcement through customizable categories.",
      "description_length": 629,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage string sets with capabilities for membership checks, iteration, aggregation, and set comparisons, alongside change tracking and custom serialization. It organizes elements into named categories like `@default` and integrates with command-line interfaces through validated string parameters, serving static analysis workflows that require project-specific state tracking and categorized identifier grouping.",
      "description_length": 448,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage lists of file paths (`Frama_c_kernel.Filepath.t list`) as configurable options, supporting modification, iteration, folding, and emptiness checks. It integrates with Frama-C's state management system through hooks for default values, project-specific state tracking, and custom serialization, while enabling command-line interaction via aliases and help messages. Use cases include configuring analysis targets, handling dynamic file path updates during analysis, and persisting file path collections across sessions with type-safe marshalling.",
      "description_length": 586,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Action",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing boolean command-line options with associated state, including setting values, registering update hooks, handling aliases, and defining serialization behavior. It operates on boolean values and a custom `Datatype.t` integrated with Frama-C's kernel, enabling use cases like static analysis parameter configuration and project-specific value tracking. Specific functions allow toggling state via `on` and `off` actions while maintaining compatibility with Frama-C's option parsing and analysis workflows.",
      "description_length": 547,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Float",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages floating-point parameters with optional decimal points, supporting operations to define value ranges, set and retrieve values with default handling, and register change hooks for dynamic updates. It operates on float data, including string representations with optional decimal points, and provides custom serialization for integration with state management systems. These features are particularly useful in command-line interfaces requiring numerical option parsing and analysis frameworks needing validated, range-constrained parameters with reactive behavior.",
      "description_length": 583,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Enum",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing stateful enumerated types with support for command-line option parsing, value serialization, and project-specific persistence. It works with variant types that have structural equality, using them to track configuration states and register change handlers. The functionality is particularly useful in contexts requiring integration with Frama-C's parameter system and kernel extensions, such as implementing analysis settings that need dynamic value updates and cross-project consistency.",
      "description_length": 533,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports associating kernel functions (including optionally pure prototypes) with values through a customizable map structure, enabling operations like setting, retrieving, and observing changes with hooks for update notifications and project-specific state management. It works with structured data types such as `Datatype.t`, strings, and `Category.t`, supporting advanced use cases like Frama-C analysis plugins that require tracking function-specific metadata, handling aliased keys, or organizing entries into hierarchical categories with controlled serialization and equality semantics.",
      "description_length": 604,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Cache_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a plugin-specific cache directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the cache structure. Concrete use cases include storing temporary analysis results or persistent plugin data in a dedicated location.",
      "description_length": 379,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Empty_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage string-based state with lifecycle hooks, command-line integration, and serialization, alongside utilities for validating and parameterizing string inputs. It works with string values and typed parameters (`Typed_parameter.t`), enabling use cases like Frama-C plugin development where parameters must accept predefined values, distinguish function names from literals, or maintain persistent state across sessions. Key patterns include stateful option handling, value validation, and project-specific configuration management.",
      "description_length": 567,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Custom",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers state management for customizable data types with comparison, hashing, and serialization capabilities, alongside utilities to configure command-line parameters using string lists for validation and aliasing. It operates on a custom type `t` (derived from `V.t`) and string-based value constraints, enabling use cases like integrating stateful options into Frama-C's project system and enforcing controlled command-line interfaces with deprecated or aliased flags.",
      "description_length": 482,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.False",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean flags with lifecycle hooks and persistent state integration for static analysis plugins. It operates on kernel parameters (`Typed_parameter.t`) and project-specific state containers, enabling use cases like toggling analysis features (e.g., enabling/disabling checks) via command-line interfaces or programmatic updates while tracking changes in Frama-C's kernel.",
      "description_length": 391,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_user_dir_opt",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides functions to manage a user directory path, including setting, retrieving, and checking the existence of the directory. It supports operations to obtain file and directory paths, with an option to create the path if it does not exist. These functions are used to handle user-specific directory configurations in static analysis tools.",
      "description_length": 354,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage string-based configuration parameters for Frama-C plugins, including setting, retrieving, and tracking value changes with support for notifications, serialization, and alias management. It works with strings and string lists, integrating with Frama-C's project/state system and kernel-specific typed parameters to enable use cases like analysis customization, command-line interface configuration, and persistent state handling across projects.",
      "description_length": 486,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Config_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages the plugin's configuration directory by providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring they exist based on the `create_path` flag. It is used to set, get, and check the status of a specific user directory without automatically creating it.",
      "description_length": 366,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.WithOutput",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages state and output behavior for a boolean flag, offering operations to enable/disable the flag, define output dependencies, and conditionally trigger output based on state changes. It operates on boolean values and structured data through the `Datatype` module, integrating with Frama-C's project state and plugin system. It is particularly useful for controlling dynamic output in analysis plugins, where results must be emitted or suppressed according to evolving dependencies or inter-plugin interactions.",
      "description_length": 526,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Value_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a value type for strings with support for equality, comparison, hashing, and pretty-printing. It provides conversions to and from standard strings, with deep copy semantics and membership checks for project-related data. It is used to represent and manipulate string values in a structured analysis context, such as storing and querying string-based identifiers or annotations.",
      "description_length": 400,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Share",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages paths within a specific directory used by a plugin, providing functions to set, retrieve, and check the directory location. It handles operations to locate and validate subdirectories and files within this directory, ensuring they exist and are of the correct type. Concrete use cases include resolving paths to configuration files or resource directories during plugin execution.",
      "description_length": 400,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_site_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module constructs a `Site_dir` by extending an existing parent directory with a new subdirectory. It provides `get_dir` and `get_file` functions to retrieve validated directory or file paths within the site structure. These operations are used to safely access known directories and files within a predefined site hierarchy, ensuring correct structure during analysis tasks.",
      "description_length": 379,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Debug",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages mutable integer state with change tracking, supporting operations to constrain values within specified ranges, increment counters, and register callbacks for updates. It works with a custom integer type enhanced with serialization, comparison, and integration hooks, enabling use cases like debugging parameter validation and enforcing numerical invariants in static analysis workflows. The design facilitates interactive configuration through command-line interfaces while maintaining consistency in project state management.",
      "description_length": 546,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers operations for manipulating mutable string lists with change tracking, category-based organization, and integration into static analysis workflows. It supports element addition, list transformations, and named category management (e.g., `@default`, `@all`) to group configuration options, while providing serialization, alias resolution, and project-specific state synchronization. Primarily used in static analysis plugins to manage configurable parameters and persist analysis settings across sessions.",
      "description_length": 523,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a mutable key-value structure where each string key maps to a list of values, supporting aliases, category-based configurations, and project-specific state tracking. It provides operations for modifying, querying, and serializing data, along with hooks for change detection and default value handling. Designed for static analysis workflows, it enables persistent configuration management and integration with analysis frameworks through structured state manipulation.",
      "description_length": 488,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing string-keyed maps with advanced state tracking, including value mutation, comparison, and hook registration for change detection. It works with key-value associations that support custom marshaling, categorization, and metadata like deprecation flags, while integrating with Frama-C's analysis framework for plugin configuration and project-specific state management. Use cases include tracking analysis results with immutable markers, handling aliased keys with visibility rules, and orchestrating parameter updates during static code analysis workflows.",
      "description_length": 600,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Value_int",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines operations for handling integer values within a specific analysis framework. It provides functions for equality checks, comparison, hashing, pretty-printing, and project membership testing, along with conversions to and from strings. The module works with the `int` type, offering deep copy capabilities and a list of representative values for the type.",
      "description_length": 373,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Session",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages file paths for a session directory used by a plugin, providing functions to retrieve or create directories and files within it. It works with string names and converts them into typed file paths using `Frama_c_kernel.Filepath.t`. Use this module to handle session-specific storage needs, such as saving temporary files or logs in a structured way.",
      "description_length": 367,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintLibc.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating structured data in the context of Frama-C analysis. It includes functions for deep copying values, checking membership based on project properties, and exposing type-level metadata such as a descriptor and representants. The type is designed to integrate with Frama-C's kernel structures, enabling precise data modeling and inspection during static analysis tasks.",
      "description_length": 522,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.True",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing boolean state with both fine-grained control and simple toggling mechanisms. It works with a `bool` value encapsulated in a `Datatype` module for Frama-C kernel integration, alongside a `Typed_parameter.t` for global state manipulation, supporting features like command-line visibility, serialization, and hook registration. It is particularly suited for static analysis plugins requiring project-specific configuration flags or runtime state tracking during code analysis.",
      "description_length": 518,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing mutable sets with dynamic state tracking, including element insertion, membership checks, iteration, and emptiness validation, all operating on a base type `t` implemented as `E.Set.t`. It integrates change hooks, default values, and serialization capabilities, while supporting use cases like static analysis state management and configuration parameter handling through string alias resolution and categorized grouping of options.",
      "description_length": 477,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Bool",
      "library": "frama-c.analysis-scripts",
      "description": "This module enables state management for boolean values through operations like toggling, update hooks, and command-line integration, while defining serialization behavior. It operates on boolean options and lists alongside typed parameters (`Typed_parameter.t`), facilitating static analysis tasks that require tracking dependencies and value changes across program states.",
      "description_length": 374,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Output.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating analysis output values. It supports deep copying and provides functionality to check membership of project-specific values within the data structure. The type is used to store and process representational instances of analysis results, enabling persistence and traversal across different analysis contexts.",
      "description_length": 473,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Verbose",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports constrained integer state management with change tracking, serialization, and integration into project state systems. It operates on a global integer value bounded by configurable min/max limits, maintaining validity through controlled modification hooks and command-line interface synchronization. The design enables use cases requiring audited value transitions, persistent state snapshots, and validation constraints in analysis tools.",
      "description_length": 459,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports operations on sets of CIL function declarations (`Fundec.Set.t`), including membership checks, iterative traversal, and dynamic modification, primarily for tracking analysis state across Frama-C projects. It integrates with configuration systems to enforce valid parameter settings, group options logically via categories, and persist function set data through serialization. Use cases include static analysis workflows requiring function scope management, project-specific value registration, and command-line interface synchronization.",
      "description_length": 558,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a parameterized map structure for typed key-value pairs, supporting operations like value assignment, retrieval, iteration, and equality checks, while enforcing single bindings per key. It integrates with state management systems to track changes, handle defaults, and validate parameters, leveraging datatype-specific comparisons and hashing for consistency. Designed for configurations in Frama-C, it enables categorized parameter organization, custom marshaling, and reactive hooks to respond to updates within project state systems.",
      "description_length": 556,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations to manage a map associating kernel functions with lists of values, supporting insertion, retrieval, and modification with change notifications. It works with kernel function keys, value lists, and integrates with Frama-C's state management for project-specific analysis tracking. Designed for static analysis workflows, it enables command-line configuration, serialization customization, and category-based organization of key-value pairs.",
      "description_length": 471,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Zero",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports managing integer-based state with hooks and serialization for Frama-C plugins, utilizing an associated `Datatype` for operations like value setting, update hooks, and command-line integration. It also enables configuration of integer parameters constrained to specific ranges, providing functions for incrementing, range validation, and retrieval in plugin development contexts.",
      "description_length": 399,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module supports operations for managing string sets, including addition, membership checks, iteration, and folding, alongside configurable parameter handling through validation and category management. It enables command-line integration with alias resolution and help message generation, while tracking project-specific state via serialization. Key use cases involve dynamic configuration with constraints, change tracking in plugins, and command-line option parsing within Frama-C plugin development.",
      "description_length": 507,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Int",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing integer values with state tracking, including setting and monitoring changes to options with customizable defaults, range constraints, and project-specific hooks. It supports integer lists and scalar integers through a datatype module enabling comparison, serialization, and range validation. Use cases include enforcing numeric input boundaries, persisting configuration parameters with custom marshaling, and tracking value modifications across project states.",
      "description_length": 507,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers utilities for structured diagnostics, configuration management, and state handling in static analysis tools. It operates on typed configuration parameters (integers, strings, enums, etc.), log events with categorized verbosity levels, and session-wide state with change tracking and serialization. These components are designed for integrating command-line interfaces, auditing analysis workflows, and customizing error reporting in Frama-C plugins and similar systems.",
      "description_length": 488,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.SemanticLocs",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers hash table operations specialized for associating CIL source code locations with arbitrary semantic data, supporting key-based insertion, lookup, and traversal while maintaining efficient handling of location-indexed values. It works with a custom map-like structure (`SemanticLocs.t`) that uses `Stdlib.Seq.t` for bulk updates and key-value sequence conversions, optimized for static analysis tasks like tracking semantic properties across program points. Typical applications include analyzing code semantics at specific AST nodes or managing location-scoped metadata in transformation pipelines.",
      "description_length": 617,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintDeclarations",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for managing boolean configuration options with change hooks, serialization, and introspection capabilities, working with a structured data type `t` in a project-aware context. It supports dynamic state tracking for analysis tools through value toggling mechanisms that enable or disable print operations. Specific use cases include runtime configuration updates and conditional output control during static analysis workflows.",
      "description_length": 459,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintLibc",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides a boolean configuration abstraction with state change hooks, serialization, and command-line integration, enabling controlled modification of shared logging/printing behavior through atomic toggle operations. It operates on a custom `t` type representing boolean state, with internal synchronization to ensure consistency across Frama-C's project and kernel systems, making it suitable for runtime logging control, command-line flag configuration, and state-aware plugin extensions.",
      "description_length": 503,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Output",
      "library": "frama-c.analysis-scripts",
      "description": "This module offers configuration management for file path settings and file property analysis. It operates on file paths (`Frama_c_kernel.Filepath.t`) with operations to track state changes, serialize values, and validate emptiness. Use cases include managing persistent project configurations with dynamic hooks and verifying empty file conditions during static analysis workflows.",
      "description_length": 382,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides operations for analyzing and printing structured data about C functions, including tracking their declarations and definitions across source code locations. It works with custom types like `funinfo` and location-annotated sequences, using specialized maps for efficient key-based access and transformations. Concrete use cases include generating JSON or textual reports of function definitions with size metrics, filtering functions based on source locations, and serializing analysis results for external consumption.",
      "description_length": 539,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts",
      "library": "frama-c.analysis-scripts",
      "description": "This module processes structured data about C functions, offering operations to analyze, filter, and serialize function declarations and definitions based on source locations. It works with custom types such as `funinfo` and location-annotated sequences, leveraging specialized maps for efficient lookups and transformations. Use cases include generating detailed JSON or text reports with function size metrics, filtering functions by source file, and exporting analysis results for external tools.",
      "description_length": 499,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing_gui.Register_gui",
      "library": "frama-c-security_slicing.gui",
      "description": "Adds security-specific controls and visualizations to the main GUI interface. Works with GUI components like buttons, panels, and event handlers to integrate security plugin features directly into the user interface. Enables users to interact with security settings through dedicated UI elements without requiring separate tools or manual configuration.",
      "description_length": 353,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing_gui",
      "library": "frama-c-security_slicing.gui",
      "description": "Adds security-specific UI elements like buttons and panels to the main interface, integrating security plugin features directly into the user experience. Works with GUI components and event handlers to enable interactive configuration of security settings. Allows users to manage security features through dedicated interface elements instead of external tools or manual edits.",
      "description_length": 377,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread_gui.Mt_gui",
      "library": "mthread_gui",
      "description": "This module provides a function to register a hook that updates the GUI when a thread is selected, specifically interacting with the main window extension points and thread state data types. It enables dynamic UI updates in response to thread selection events in the Frama-C GUI. A concrete use case is displaying thread-specific information in a custom panel when a user selects a thread from the menu.",
      "description_length": 403,
      "index": 325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread_gui",
      "library": "mthread_gui",
      "description": "This module defines a function to register a GUI update hook that reacts to thread selection events, working with thread state data types and main window extension points. It dynamically updates the Frama-C interface to show thread-specific information, such as in a custom panel. A concrete use case is refreshing a display with current thread details when a user selects a thread from the GUI menu.",
      "description_length": 400,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope_gui.Dpds_gui",
      "library": "frama-c-scope.gui",
      "description": "Implements custom GUI components and event handlers for integrating plugin-specific analysis features into Frama-C's interface. Works with Frama-C's abstract syntax trees, analysis results, and user interaction events. Enables visualizing dataflow dependencies and selecting program points for further analysis directly within the Frama-C environment.",
      "description_length": 351,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope_gui",
      "library": "frama-c-scope.gui",
      "description": "Implements custom GUI components and event handlers for integrating plugin-specific analysis features into Frama-C's interface. Works with Frama-C's abstract syntax trees, analysis results, and user interaction events. Enables visualizing dataflow dependencies and selecting program points for further analysis directly within the Frama-C environment.",
      "description_length": 351,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report_eva_info.Eva_info",
      "library": "markdown_report_eva_info",
      "description": "This module populates the functions required by `Md_gen.Eva_info` to generate Markdown reports based on Eva analysis data. It processes and formats Eva-specific information such as function summaries, call graphs, and analysis results into structured Markdown content. It works directly with Eva's internal data structures to produce human-readable reports.",
      "description_length": 357,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report_eva_info",
      "library": "markdown_report_eva_info",
      "description": "This module implements functions to generate Markdown reports from Eva analysis data, focusing on function summaries, call graphs, and analysis results. It operates on Eva's internal data structures to extract and format relevant information into structured Markdown content. Use cases include producing human-readable reports for static analysis results and documentation generation.",
      "description_length": 384,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics_gui.Metrics_gui_panels",
      "library": "frama-c-metrics.gui",
      "description": "This module manages the graphical interface for displaying and interacting with metrics in a LablGTK-based application. It provides functions to initialize and reset a metrics panel, register metrics with associated display logic, and render data as tables. Key operations include dynamically updating the UI based on selected metrics and embedding custom display components into the main window.",
      "description_length": 396,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics_gui.Register_gui",
      "library": "frama-c-metrics.gui",
      "description": "Implements custom GUI components and event handlers for visualizing and interacting with analysis metrics in Frama-C. Works with Frama-C's GUI framework and plugin data structures. Enables users to configure and view metric displays through dedicated panels and controls.",
      "description_length": 271,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics_gui",
      "library": "frama-c-metrics.gui",
      "description": "This module provides a LablGTK-based interface for managing and visualizing analysis metrics in Frama-C. It supports initializing metrics panels, registering metrics with custom display logic, and embedding interactive components into the GUI. Concrete use cases include dynamically updating metric tables and integrating user-configurable display controls into Frama-C's plugin interface.",
      "description_length": 389,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Constant_Propagation.Api",
      "library": "frama-c-constant_propagation.core",
      "description": "Implements constant propagation analysis by computing and applying constant values across functions. Operates on CIL fundec structures and project states, introducing casts when enabled. Useful for optimizing code by replacing variables with known constants during static analysis.",
      "description_length": 281,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constant_Propagation",
      "library": "frama-c-constant_propagation.core",
      "description": "Performs constant propagation analysis on CIL function definitions and project states, replacing variables with known constants. Applies casts when enabled and optimizes code during static analysis. Useful for eliminating redundant computations and simplifying control flow based on constant conditions.",
      "description_length": 303,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G.V",
      "library": "frama-c-alias.core",
      "description": "This module defines operations for managing vertices in a graph, where each vertex has a unique integer identifier and an associated label. It provides functions to create vertices from labels, retrieve their labels, and compare, hash, or check equality of vertices. These operations support concrete use cases such as building and analyzing graph structures where vertex identity and labeling are essential, for example in control flow graphs or dependency tracking systems.",
      "description_length": 475,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G.E",
      "library": "frama-c-alias.core",
      "description": "This module defines directed edges with source and destination vertices and an associated label. It provides operations to create edges between vertices, retrieve their labels, and compare edges. The module is used to represent and manipulate labeled, directed edges in a graph structure, where edges are ordered and can be compared based on their direction and content.",
      "description_length": 370,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G",
      "library": "frama-c-alias.core",
      "description": "This interface provides operations to query structural properties of directed graphs, such as vertex/edge counts, adjacency relationships, and degree metrics, while supporting traversal and transformation functions that iterate or fold over nodes and edges. It works with labeled vertices and directed edges, enabling structured access to graph relationships through both unfiltered and label-aware processing. These capabilities are useful for tasks like dependency resolution, network analysis, or social graph modeling where directed relationships and efficient graph traversal are critical.",
      "description_length": 594,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.EdgeLabel",
      "library": "frama-c-alias.core",
      "description": "This module defines and manipulates edge labels used to represent pointer and field access relationships in memory graphs. It supports operations to construct, compare, and pretty-print labels, as well as check whether a label represents a pointer or a field access. It is used to track how memory locations are accessed or modified through pointers or struct fields in static analysis.",
      "description_length": 386,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.Function",
      "library": "frama-c-alias.core",
      "description": "This module provides functions to analyze aliasing relationships between variables and lvalues within a function. It computes points-to sets, alias sets, and checks whether two lvalues are aliased at any point in the function. These analyses are used to track memory references and overlaps in pointer usage during static analysis.",
      "description_length": 331,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.Abstract_state",
      "library": "frama-c-alias.core",
      "description": "This module provides operations to analyze and query an abstract aliasing state, including retrieving the points-to graph, finding associated variables and lvals for vertices, and computing alias sets and transitive closures. It works with data types such as abstract state (`t`), vertices (`v`), variable sets (`VarSet.t`), and lval sets (`LSet.t`). Concrete use cases include determining which variables or lvals are aliased to a given lval, inspecting the structure of the alias graph, and comparing abstract states for inclusion.",
      "description_length": 533,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.Statement",
      "library": "frama-c-alias.core",
      "description": "This module provides functions to analyze pointer aliasing and points-to relationships at the level of individual statements. It operates on CIL statements and lvalues, returning variable sets, lvalue sets, or boolean results that describe aliasing behavior. Concrete use cases include determining which variables or lvalues may be aliased by a given lvalue at a specific program point, identifying newly created aliases after a statement, and checking if two lvalues are aliased at a given statement.",
      "description_length": 501,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API",
      "library": "frama-c-alias.core",
      "description": "This module provides functions to analyze and manipulate aliasing relationships in C programs through operations on memory graphs, statements, and functions. It works with data types such as vertices, edge labels, abstract alias states, and CIL statements and lvalues, enabling precise tracking of pointer and field accesses. Concrete use cases include determining aliased variables at specific program points, computing points-to sets across function calls, and analyzing the impact of statements on aliasing relationships.",
      "description_length": 524,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.Analysis",
      "library": "frama-c-alias.core",
      "description": "Performs alias analysis computations and manages analysis state. It works with abstract representations of program variables and their aliasing relationships. Use to determine which variables may reference the same memory locations during program execution.",
      "description_length": 257,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias",
      "library": "frama-c-alias.core",
      "description": "This module provides operations for analyzing and manipulating aliasing relationships in C programs, including determining which variables may reference the same memory locations. It works with data types such as CIL statements, lvalues, vertices, edge labels, and abstract alias states. Concrete use cases include computing points-to sets across function calls, analyzing the impact of statements on aliasing, and querying aliased variables at specific program points.",
      "description_length": 469,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for handling string-based collection parameters in command-line interfaces, including equality checks, comparison, hashing, and pretty printing. It works with a concrete data type `t` representing string collections, supporting deep copying and membership testing for project skeletons. Use cases include parsing and manipulating sets of string options with associated descriptors and type information.",
      "description_length": 433,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for a string-based datatype used in command-line parameter handling, including equality, comparison, hashing, and pretty-printing. It works with string representations of parameters, supporting deep copying and membership checks for project-related values. Concrete use cases include managing and validating string parameters in a slicing context, ensuring they conform to expected descriptors and behaviors.",
      "description_length": 439,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based threat selection parameters in a slicing context. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to represent and manipulate threat criteria as string values within analysis configurations.",
      "description_length": 354,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based collection parameters in command-line interfaces, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with string values representing collections and includes utilities for project membership testing and deep copying. Concrete use cases include parsing and validating string inputs for static analysis tools, where collections of values must be processed and compared efficiently.",
      "description_length": 480,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for handling string-based loop variable selections in command-line parameters, providing standard operations like equality, comparison, hashing, and pretty printing. It supports deep copying and project membership checks, ensuring values can be uniquely identified and manipulated independently. Concrete use cases include parsing and validating loop variable options in static analysis tools where string parameters must be strictly managed and compared.",
      "description_length": 487,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for handling string-based command-line parameters in a slicing context. It supports operations like equality checks, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to represent and manipulate slicing configurations through string values in a structured and type-safe manner.",
      "description_length": 368,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a concrete data type for representing string-based collection parameters in a slicing context. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle command-line parameters that represent sets of string values, ensuring safe manipulation and consistent serialization.",
      "description_length": 398,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for handling string-based command-line parameters in a slicing context. It provides operations for equality checks, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to represent and manipulate string parameters that are part of a larger configuration or analysis setup.",
      "description_length": 361,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for handling string-based collection parameters in command-line options, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a custom type `t` that represents string collections, including functions to manage project membership checks and deep copying. Concrete use cases include parsing and manipulating loop invariant selection parameters in static analysis tools.",
      "description_length": 446,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for handling string-based collection parameters in command-line interfaces, including equality checks, comparison, hashing, and pretty-printing. It works with a concrete data type `t` that represents string collections, supporting deep copying, membership testing with project predicates, and introspection via type descriptors. Use cases include parsing and manipulating sets of string options passed to analysis tools, ensuring consistent handling of command-line arguments with structured and user-friendly representations.",
      "description_length": 557,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl.Make",
      "library": "frama-c-slicing.core",
      "description": "This module implements a hash table with values marked for slicing analysis, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a user-specified `Data` module, providing typed descriptors, structural representation, and project membership checks. Concrete use cases include tracking marked data values during static analysis and managing slice-specific metadata in Frama-C plugins.",
      "description_length": 423,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module offers functions to define and validate string-based command-line parameters with controlled value sets, supporting operations like alias resolution, serialization, and comparison. It operates on globally managed parameter states, allowing constraints such as predefined value lists or function name validation. These features are particularly useful in static analysis configurations where parameters require strict input validation or dynamic value handling through function references.",
      "description_length": 500,
      "index": 357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters with validation and dynamic behavior. It supports operations to define allowed values, distinguish between function names and plain strings, and customize serialization while maintaining state with default values and project tracking. Useful for CLI tools requiring configurable string inputs that enforce specific formats or semantic checks during execution.",
      "description_length": 416,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages parameter categories for a command-line interface, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring how command-line parameters are grouped, interpreted, and activated during program execution.",
      "description_length": 342,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line parameter handling. It supports structured data representation with a list of type representatives and descriptors for integration with the Frama-C kernel. Concrete use cases include managing and manipulating parameter values during static analysis configuration and ensuring consistent data handling across different analysis modules.",
      "description_length": 472,
      "index": 360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring parameter behavior in command-line tools, where categories determine how parameters are interpreted and applied.",
      "description_length": 366,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters for slicing configurations, offering operations to validate allowed values, distinguish function names from literals, and customize serialization formats. It operates on string parameters enriched with type-safe handling via the `Datatype` module, supporting project-specific state and default value management. Typical use cases include parsing user-defined slicing options, enforcing value constraints, and bridging string representations with executable logic through alias resolution and hook registration.",
      "description_length": 567,
      "index": 362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in command-line parameter handling. It supports structured data representation with a descriptor system, including deep copying and membership testing for project-related values. Concrete use cases include managing and manipulating slicing parameters in a static analysis tool, where precise data identity and transformation are critical.",
      "description_length": 472,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to manage string-based configuration parameters for threat selection, including validation against predefined allowed values, function name checks, and alias handling. It works with string values constrained by sets of acceptable options or function identifiers, supporting command-line interface integration and analysis state management where dynamic threat criteria configuration is required. Specific use cases include validating user-provided threat filters and marshaling parameter states across different analysis stages.",
      "description_length": 560,
      "index": 364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module provides utilities for managing string-based command-line parameters related to loop invariant selection, supporting operations like value validation, dynamic state updates, and alias handling. It works with string values and lists to enforce allowed input patterns, validate function names, or restrict entries to predefined options. These features are particularly useful in scenarios requiring robust configuration interfaces for loop analysis tools, where parameters must adapt to project-specific contexts or evolve during execution.",
      "description_length": 550,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.As_string",
      "library": "frama-c-slicing.core",
      "description": "This component manages string-based command-line parameters with operations to set and validate allowed values, handle aliases, and track state changes through hooks. It operates on string values constrained by predefined allowed lists, supporting both literal strings and function names as inputs for dynamic evaluation. Use cases include parameter validation in CLI tools, mapping user-provided strings to executable functions, and maintaining project-specific defaults with customizable serialization.",
      "description_length": 504,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of elements, using string names and state dependencies. It provides operations to create, enable, and modify categories like `@none`, `@default`, and `@all`, with support for accessors and dependency lists. Use cases include configuring command-line parameters with dynamic category behavior and state-based selection logic.",
      "description_length": 384,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map.Key",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for keys used in a map structure, along with standard operations such as equality, comparison, hashing, and pretty printing. It supports working with values of type `Slicing.SlicingTypes.Sl_mark.Map.Key.t`, providing deep copy, membership testing with project functions, and structural representation. Concrete use cases include managing and comparing keys in map-based data structures for slicing analysis, ensuring unique identification and proper handling of slice-related data.",
      "description_length": 513,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in command-line parameter handling. It supports structured data representation with descriptors and provides utilities to check project membership and perform deep copies. Concrete use cases include managing and comparing parameter values in static analysis tools like Frama-C.",
      "description_length": 411,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.SliceUndef.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in slicing parameters. It supports deep copying and membership testing for project skeletons, ensuring structural integrity and uniqueness through its descriptor and representant list. Concrete use cases include managing and comparing slicing configurations in static analysis tools.",
      "description_length": 417,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of elements, where each category is associated with a name, an accessor, and a list of dependent states. It provides operations to create and configure named categories, including special categories like `@none`, `@default`, and `@all`, with support for enabling or aliasing these categories. Concrete use cases include organizing and selecting subsets of function calls during static analysis based on user-defined categories specified via command-line parameters.",
      "description_length": 525,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Calls.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for representing and manipulating slicing parameters related to function calls in a program analysis context. It provides functions for equality checks, comparison, hashing, pretty-printing, deep copying, and membership testing within projects, specifically tailored for use in static analysis tasks such as program slicing. The data type is designed to capture semantic aspects of function calls, supporting precise analysis and transformation of C code.",
      "description_length": 502,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in command-line parameters within a slicing context. It supports structured data handling with functions to check membership in projects, create deep copies, and describe values through type and descriptor information. Concrete use cases include managing and comparing parameter values in static analysis tools where precise data representation and project-specific filtering are required.",
      "description_length": 510,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map.Make",
      "library": "frama-c-slicing.core",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports key-based data management with functions to check membership in projects and create deep copies. Use cases include tracking and manipulating mapped data in slicing contexts, such as maintaining per-function or per-variable slice information during analysis.",
      "description_length": 424,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring how different parameter sets are interpreted and activated in command-line tools.",
      "description_length": 335,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages parameter categories for a command-line interface, using types `elt` and `t` to represent category elements and collections. It provides operations to create, modify, and enable categories such as `none`, `default`, and `all`, with support for accessors and dependencies. Use cases include configuring slicing parameters through named categories, setting default behaviors, and enabling global selection semantics via `@all`.",
      "description_length": 457,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate descriptors for command-line parameters in a static analysis context. It supports deep copying and membership checks over project skeletons, ensuring values can be uniquely identified and safely shared across different parts of the analysis. It is used to manage representational data for parameter parsing and configuration in static analysis tools built on the Frama-C platform.",
      "description_length": 530,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a concrete data type with standard operations including equality, comparison, hashing, and pretty printing. It supports working with a unique named type that can be used to represent and manipulate structured data, particularly in the context of command-line parameters and project-based data filtering. The type is designed for deep copying and membership testing within project skeletons, enabling precise data traversal and transformation.",
      "description_length": 462,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring parameter behavior in static analysis tools, where categories control how options are interpreted and applied.",
      "description_length": 364,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for representing and manipulating values used as command-line parameters in a slicing context. It supports equality checks, comparison, hashing, pretty-printing, project membership testing, and deep copying of values. Concrete use cases include handling user-provided parameters for selecting loop invariants during static analysis and ensuring consistent value manipulation across different analysis phases.",
      "description_length": 455,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring how parameter sets are interpreted and controlled in command-line tools.",
      "description_length": 326,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to manage string-based command-line parameters, including setting allowed values, validating against predefined options, and retrieving values as either function names or raw strings. It works with string parameters that support value constraints, introspection, and comparison, enabling use cases like parsing CLI arguments with restricted input domains or dynamically binding parameter values to project states. The module also supports alias handling and custom serialization, allowing seamless integration with configuration systems and runtime value monitoring.",
      "description_length": 598,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Callers.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for managing slicing parameters related to function callers in a program analysis context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to represent and manipulate caller-specific data during static analysis, particularly in tracking and comparing execution contexts across different program slices.",
      "description_length": 441,
      "index": 383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, used to represent and manipulate structured values in a command-line parameter context. It supports deep copying and membership testing for project-related values, ensuring no shared references between copies. This module is suitable for managing distinct, comparable data instances in analysis tools or parameter handling systems.",
      "description_length": 435,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of threat parameters in slicing configurations. It provides operations to create, modify, and enable categories such as `none`, `default`, and `all`, each controlling how threat parameters are interpreted and applied. Use cases include configuring slicing behavior through named categories with specific accessors and dependencies, and controlling global threat selection via the `@all` category.",
      "description_length": 456,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.KeepAnnotations.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the Frama-C kernel's slicing parameters. It includes functionality to check membership within projects, create deep copies, and manage type descriptors for structural representation. The type is used to represent and manipulate annotated data structures in program slicing tasks, such as tracking and comparing semantic information across different code projections.",
      "description_length": 503,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module provides utilities for managing string-based command-line options that select loop variables in static analysis tools. It operates on strings and string lists to support value validation, alias resolution, and serialization, while enabling customization through hooks and project-specific default values. Typical use cases involve parsing and validating user-specified loop variables from command-line arguments with flexible formatting and alias support.",
      "description_length": 467,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling slicing parameters related to threat selection. It supports working with project-based data through membership checks and deep copying, ensuring no shared references. Concrete use cases include managing and comparing threat-related slicing configurations in static analysis workflows.",
      "description_length": 423,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of loop variables used in slicing parameters. It provides operations to create, modify, and enable categories such as `none`, `default`, and `all`, along with custom named categories that include dependencies and accessors. These categories control how loop variables are interpreted and activated during analysis, particularly in command-line configurations and state management.",
      "description_length": 440,
      "index": 389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl.Key",
      "library": "frama-c-slicing.core",
      "description": "This module defines a key type for a hash table used in a slicing context, where keys must support equality, comparison, hashing, and pretty-printing. It provides operations to check membership based on project conditions, create deep copies, and manage type representations and descriptors. Concrete use cases include tracking and comparing slice marks associated with project elements in static analysis tools.",
      "description_length": 412,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for managing representable values with support for equality, comparison, hashing, and pretty printing. It works with structured data types that include project membership checks and deep copying capabilities. Concrete use cases include handling annotated slice data in command-line parameters and ensuring consistent value representation across different analyses.",
      "description_length": 411,
      "index": 391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Calls",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for managing configurable integer parameters with range constraints, including incrementing values, setting and retrieving allowed min/max bounds, and integrating update hooks for reactive behavior. These parameters are used in program slicing analysis to control aspects like tracking depth or enabling/disabling features related to function calls, with support for CLI integration and serialization to manage configuration persistence.",
      "description_length": 469,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Set",
      "library": "frama-c-slicing.core",
      "description": "This module supports operations for creating, querying, and transforming ordered, immutable sets of `Sl_mark.t` elements, including standard set algebra (union, intersection, difference), membership checks, and ordered traversal. It provides utilities for converting between sets and sequences or lists, finding extremal elements, and performing comparisons or hash-based operations, all leveraging a total ordering on elements. These capabilities are tailored for static analysis tasks in Frama-C, such as tracking code annotations or managing dependencies during program slicing.",
      "description_length": 581,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.KeepAnnotations",
      "library": "frama-c-slicing.core",
      "description": "This module manages a boolean configuration flag that determines whether annotations are preserved during code transformation workflows, offering functions to set, retrieve, and observe changes to this state. It operates on shared configuration objects that integrate with command-line interfaces for dynamic parameter adjustment and support persistent storage across sessions. Typical applications include controlling annotation retention in static analysis tools or optimizing code generation pipelines where metadata preservation is selectively required.",
      "description_length": 557,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to manage command-line parameters representing sets of kernel functions, supporting dynamic configuration through value hooks, alias resolution, and serialization. It works with sets of `kernel_function` elements, offering set-like manipulations (addition, membership checks, iteration) and state management tailored for slicing annotations. These capabilities enable use cases such as validating user-defined parameter sets, persisting configurations, and handling extensible command-line interfaces for static analysis tools.",
      "description_length": 559,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to manage set-based command-line parameters with dynamic evaluation and validation, supporting kernel function collections through `Frama_c_kernel.Cil_datatype.Kf.Set.t`. It enables membership checks, element iteration, and stateful modifications while integrating with string-based aliases and categorized configurations. Typical use cases include handling configurable CLI options that require dynamic parameter updates, validated input constraints, or grouped settings with project-specific behavior.",
      "description_length": 535,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ProjectName.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a structured data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in program slicing contexts. It includes functionality to check membership of project-related values and perform deep copies, ensuring no shared references. The type `t` represents slicing parameters associated with a project, supporting precise data flow analysis and transformation tasks in static code analysis workflows.",
      "description_length": 469,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Verbose.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and associated operations for representing and manipulating slicing parameters in a verbose format. It supports equality checks, comparison, hashing, pretty-printing, and deep copying of values, along with membership testing for project-related data. The type is used to store and process detailed configuration settings for slicing operations, enabling precise control over analysis parameters and output representation.",
      "description_length": 453,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.SliceUndef",
      "library": "frama-c-slicing.core",
      "description": "This module manages a boolean configuration option controlling undefined slicing behavior, offering operations to set, retrieve, and track changes to the value through state-switching functions, pre/post-update hooks, and default handling. It works with boolean state integrated into a project-specific datatype and supports command-line interface interactions (e.g., option aliases, help messages) and serialization for persistent configuration. The functionality is particularly useful for customizing static analysis workflows where undefined behavior handling must be dynamically adjusted and persisted across sessions.",
      "description_length": 623,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map",
      "library": "frama-c-slicing.core",
      "description": "This module implements an ordered associative map for keys of type `Sl_mark.t`, supporting operations like insertion, deletion, merging, and ordered traversal (ascending/descending) with comparisons governed by the `Ord` module. It handles key-value associations in slicing contexts where ordered access to slice marks is critical, such as tracking dependencies or resolving extremal slice points. Use cases include managing hierarchical slice data with bounded key ranges, filtering by custom predicates, and converting structured maps to sequences for analysis or pretty-printing.",
      "description_length": 582,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls",
      "library": "frama-c-slicing.core",
      "description": "This module provides set-like operations for managing collections of function calls and kernel functions, including membership checks, iteration, and predicate-based filtering. It works with structured data types representing command-line parameters and function categories, supporting use cases in static analysis where specific functions must be selected or excluded via aliases and custom serialization. The design emphasizes dynamic configuration through value hooks and category-based organization for scalable slicing workflows.",
      "description_length": 534,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat",
      "library": "frama-c-slicing.core",
      "description": "This module provides set-based operations for managing threat selection parameters in slicing configurations, including adding elements, membership checks, and iteration over kernel function sets. It works with `Frama_c_kernel.Cil_datatype.Kf.Set.t` for efficient set manipulation and integrates with command-line interfaces through string-based serialization and category-based grouping. Use cases include dynamic threat filtering during static analysis, project-specific state persistence, and alias-aware parameter marshaling for distributed analysis workflows.",
      "description_length": 564,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar",
      "library": "frama-c-slicing.core",
      "description": "This module manages a command-line option's state for a set of loop variables, providing operations to add elements, check membership, iterate over collections, and handle project-specific lifecycle tracking. It works with sets of `kernel_function` elements from Frama-C's kernel, incorporating serialization and comparison logic for state management. Use cases include configuring slicing parameters via command-line flags and maintaining loop variable selections across analysis sessions.",
      "description_length": 490,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for managing command-line parameters that store string sets, supporting value assignment, update hooks, alias resolution, and serialization. It operates on `String.Set.t` values and integrates category-based organization via dependency-aware named categories for structured element grouping. These capabilities are particularly useful in static analysis tools for tracking project-specific configurations, handling dynamic parameter updates, and maintaining extensible sets of values with semantic categorization.",
      "description_length": 545,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ExportedProjectPostfix.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate structured data within the Frama-C kernel. It supports deep copying and membership checks for project values, ensuring no shared references between copies. This type is used to manage representational data in static analysis workflows, such as tracking and comparing project states during slicing operations.",
      "description_length": 458,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters represented as sets, offering operations to add elements, check membership, and iterate over collections while supporting validation and state synchronization. It works with `Frama_c_kernel.Datatype.String.Set.t` structures and integrates with project-specific contexts through dependency tracking and category definitions. Use cases include configuring slicing tools with dynamic, validated string options and managing interdependent parameters during analysis.",
      "description_length": 519,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Callers",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to configure and toggle a boolean flag that determines whether function callers are included in static analysis slices. It manages state through direct value manipulation, command-line option parsing with aliases and documentation, and project-specific persistence. The functionality supports use cases like enabling/disabling caller tracking in analysis workflows or adjusting slicing criteria via configuration files and CLI switches.",
      "description_length": 468,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl",
      "library": "frama-c-slicing.core",
      "description": "This module implements hash tables mapping `Sl_mark.t` keys to slicing-aware values, supporting imperative manipulation, ordered traversal, and memoization patterns. It provides deterministic iteration/folding over keys and values, optional/default lookups, and sequence-based updates, with structural descriptors enabling integration into static analysis plugins. These operations are particularly useful for caching intermediate results during slice computation and maintaining consistent dependency graphs in deterministic analysis workflows.",
      "description_length": 545,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for defining and manipulating command-line parameters that represent sets of loop invariants in static analysis tools. It works with collections of `kernel_function` elements, supporting membership checks, iteration, and aggregation while integrating with string-based parameter parsing and categorized option dependencies. Specific use cases include configuring analysis scopes through function sets and managing dynamic parameter updates with serialization hooks in Frama-C-based tools.",
      "description_length": 520,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Debug.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for debugging slicing parameters. It supports deep copying and membership testing for project skeletons, ensuring values can be uniquely identified and manipulated independently. The type is used to represent and manage descriptors for slicing parameters in a structured and type-safe manner.",
      "description_length": 418,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess",
      "library": "frama-c-slicing.core",
      "description": "This module manages command-line parameters for string sets, enabling operations like adding elements, checking membership, and iterating over values, while supporting constraints through aliases and category-based organization. It integrates with state management systems to handle default values, value change hooks, and marshaling, ensuring compatibility with Frama-C's project infrastructure. Use cases include configuring analysis options with restricted string inputs and tracking dynamic parameter updates during tool execution.",
      "description_length": 535,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Cache_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages file paths for a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to handle path manipulations and ensures existence based on user-specified names. Use cases include storing and accessing cached analysis results or temporary files during static code analysis.",
      "description_length": 381,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Slice",
      "library": "frama-c-slicing.core",
      "description": "This module manages function slices in a control flow graph, providing operations to create, remove, and query slices associated with kernel functions. It supports lookups for callers, called functions, and marks derived from statements, labels, variables, and function inputs, enabling precise slicing for analysis tasks. Use cases include program slicing for debugging, impact analysis, and code comprehension tools.",
      "description_length": 418,
      "index": 413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.Api.Project",
      "library": "frama-c-slicing.core",
      "description": "This module manages slicing projects by providing operations to reset slicing state, change slicing levels for functions, generate new projects from slices, and visualize call graphs via DOT files. It works with `Project.t` and `kernel_function` types, enabling precise control over slicing behavior and output. Concrete use cases include extracting sliced projects with custom naming, analyzing call relationships, and debugging with formatted output.",
      "description_length": 452,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Session",
      "library": "frama-c-slicing.core",
      "description": "This module manages file paths for a session directory in a Frama-C plugin, providing functions to retrieve or create directories and files within that session context. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing configuration of a user directory without automatic creation. Concrete use cases include setting up session-specific storage locations for analysis results or temporary files during static code analysis.",
      "description_length": 453,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Share",
      "library": "frama-c-slicing.core",
      "description": "This module manages the configuration and retrieval of the `<dune-site-dir>` directory and its contained files and subdirectories. It provides functions to set, get, and check the directory path, as well as to locate specific files or directories within it. Concrete use cases include resolving plugin-specific resources such as configuration files or shared libraries stored under the `share` directory.",
      "description_length": 404,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Debug",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for managing integer-valued debug settings with constraints, including incrementing values, enforcing min/max bounds, and registering hooks for state changes. It works with integer parameters augmented by metadata like command-line visibility, aliases, and project-specific state tracked via the Datatype module. Use cases include configuring and persisting debug settings for slicing operations, dynamically adjusting parameters during execution, and ensuring valid value ranges in analysis workflows.",
      "description_length": 534,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages the configuration mode for slicing operations, providing functions to set, retrieve, and modify the current mode value. It works with a string-based enumeration type representing distinct slicing modes, each corresponding to a specific analysis behavior. The module supports use cases such as selecting between different slicing strategies (e.g., forward, backward, or hybrid analysis) via command-line options or configuration files, enabling dynamic adjustment of analysis scope and precision.",
      "description_length": 527,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to select and manage sets of function calls, kernel functions, and related entities through command-line parameters, supporting dynamic configuration via aliases, categories, and value hooks. It works with structured data types including `Frama_c_kernel.Cil_datatype.Kf.Set.t` and string-based sets, enabling concrete use cases such as filtering functions during static analysis, configuring slicing scopes, and persisting analysis settings across sessions.",
      "description_length": 489,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Mark",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manipulates mark values that represent the role of elements in slicing results, such as whether they are data, control, or address-related. It provides functions to construct marks, query their properties, and compare or display them. These marks are used to determine visibility and relevance in slicing operations, particularly in relation to function calls and GUI rendering.",
      "description_length": 402,
      "index": 420,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingSelect.Selections",
      "library": "frama-c-slicing.core",
      "description": "This module manages variable selection criteria in a slicing context using map-based structures keyed by variable identifiers. It provides operations to add selection entries, iterate over selections, and fold across selection data. Concrete use cases include tracking and processing user-defined critical variables during program slicing analysis.",
      "description_length": 348,
      "index": 421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.State_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages file and directory paths within a plugin's state directory, providing operations to retrieve or create files and directories. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing configuration of a user directory without automatic creation. Concrete use cases include setting up persistent storage locations for plugin-specific data and safely accessing files within a predefined directory structure.",
      "description_length": 448,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Verbose",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing an integer-based parameter with bounded values, supporting dynamic adjustments, range constraints, and change notifications. It works with internal state tracking mechanisms to enforce value validity, integrates with command-line option parsing, and enables serialization for persistent configuration. Typical use cases include controlling verbosity levels in slicing analysis, synchronizing parameter states across project components, and customizing behavior through runtime hooks.",
      "description_length": 527,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_project",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing and querying slice project data, including equality checks, comparison, hashing, and pretty-printing. It works with the `t` type representing slice projects and interacts with project skeletons for membership testing. Use cases include tracking slice project identities, performing deep copies, and integrating with Frama-C's project system for slicing operations.",
      "description_length": 408,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Config_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages the configuration directory for a plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the user-specified directory. Concrete use cases include initializing plugin-specific storage, reading/writing configuration files, and ensuring required paths exist before performing analysis tasks.",
      "description_length": 453,
      "index": 425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_fct_slice",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing function slices, including equality, comparison, hashing, and pretty-printing. It works with the `t` type representing function slices and supports deep copying and membership checks for project-related data. Concrete use cases include tracking and manipulating slices during static analysis, ensuring unique identification and structural integrity of slice representations.",
      "description_length": 418,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Request",
      "library": "frama-c-slicing.core",
      "description": "This module manages slicing operations for program analysis, providing functions to manipulate and propagate code slices. It works with `Slicing.Api.Slice.t` for representing slices and `Slicing.Api.Select.t` for selections, supporting actions like merging, splitting, copying slices, and adding call relationships between slices or functions. Concrete use cases include applying slicing transformations, propagating user-defined marks, and managing persistent or command-line driven slice selections.",
      "description_length": 501,
      "index": 427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_select",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for comparing, hashing, and pretty-printing values of type `Sl_select.t`, including deep copying and membership checks over project skeletons. It works with list representants of a descriptor and supports precise equality and ordering operations. Concrete use cases include managing and querying slice selection data in a slicing context, such as checking if a project satisfies a condition or generating a user-readable representation of a selection.",
      "description_length": 482,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Fct_user_crit",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing and comparing function user criteria in a slicing context, including equality, comparison, hashing, and pretty-printing. It works with the type `t` representing function user criteria and includes utilities for project membership checks and deep copying. Concrete use cases include tracking and manipulating slicing criteria based on user-defined conditions and ensuring correct handling of project-specific data.",
      "description_length": 457,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ProjectName",
      "library": "frama-c-slicing.core",
      "description": "This module manages stateful string parameters for project name configuration, supporting operations to set and validate values against allowed lists, register change notifications, and handle aliases or marshaled representations. It works with strings, string lists, and metadata-bearing state objects, enabling use cases like project-specific settings with dynamic validation and observable state updates. The design facilitates scenarios requiring persistent configuration, cross-referencing of project aliases, and safe value comparisons in distributed contexts.",
      "description_length": 566,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ExportedProjectPostfix",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based configuration parameters with validation and dynamic value handling, supporting operations like default value assignment, command-line argument parsing, and state change notifications. It operates on strings, lists of allowed values, and structured project state representations to enforce constraints or resolve function identifiers. Typical applications include parameter validation in analysis tools and customizable workflow systems requiring controlled string inputs.",
      "description_length": 505,
      "index": 431,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.Api.Select",
      "library": "frama-c-slicing.core",
      "description": "This module enables the construction and manipulation of selection sets for program slicing by selecting and combining program elements such as statements, lvalues (with read/write sets), zones, predicates, annotations, and control dependencies. It operates on structured data like `Slicing.Api.Select.t`, `kernel_function`, `stmt`, `Zone.t`, and `PdgTypes.Node.t`, facilitating static analysis tasks such as dependency tracking, slice traversal, and execution point-specific value preservation in program analysis workflows.",
      "description_length": 525,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type `t` representing slice marks used in static analysis, along with core operations for equality, comparison, hashing, and pretty-printing. It supports structured manipulation through associated sets, maps, and hash tables, enabling precise tracking and querying of slice annotations within Frama-C. Concrete use cases include managing dependencies between code elements during slicing, resolving slice points based on project context, and caching intermediate slice data for efficient recomputation.",
      "description_length": 529,
      "index": 433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingInternals",
      "library": "frama-c-slicing.core",
      "description": "This module defines internal data structures and operations for managing function slicing, including mark types for dependency tracking, function slice metadata, and dummy values for initialization. It works with types like `mark`, `pdg_mark`, `fct_info`, and related index and slice types to represent and manipulate partial program dependencies. Concrete use cases include tracking call sites with `Cav` marks, managing slice specialization levels, and storing computed slices for functions with associated marks.",
      "description_length": 515,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingMarks",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions to manage hierarchical mark values with semantic roles (data, address, control) through set-like operations like intersection and difference, alongside structures to track input/output dependencies, control flow marks, and visibility flags across program locations and zones. It enables precise analysis of slicing relationships by combining low-level mark manipulations with high-level dependency tracking for tasks like visualizing data flow or determining reachable code segments.",
      "description_length": 514,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingMacros",
      "library": "frama-c-slicing.core",
      "description": "This module provides utilities for converting, retrieving, and modifying slicing data structures like `fct_info`, `fct_slice`, and `level_option`, alongside equality checks and property inspections for function calls. It operates on types such as `stmt` and `fct_info` to support tasks including kernel function extraction, visibility analysis, and integration with Frama-C's PDG components, while managing persistent selection flags and slicing level transformations. Specific use cases involve analyzing call status, folding over function data, and manipulating internal slicing state for static analysis workflows.",
      "description_length": 617,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingProject",
      "library": "frama-c-slicing.core",
      "description": "This module manages program slicing operations for kernel functions, providing functions to create, merge, split, and filter slices based on criteria such as call relationships and user-defined rules. It works with function slices (`fct_slice`) and slicing criteria (`criterion`, `fct_user_crit`), allowing precise control over slice construction and modification. Concrete use cases include refining slices to specific function calls, removing unnecessary slices, and visualizing slicing results through formatted output functions.",
      "description_length": 532,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Fct_slice",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions to analyze and manipulate function slices within a program dependence graph (PDG), including merging slices, applying and filtering marks based on criteria, and retrieving dependencies for nodes, statements, or keys. It operates on data structures like `fct_slice`, `pdg_mark`, and `stmt`, enabling static analysis tasks such as program slicing, dependence tracking, and visibility checks for function calls in tools like Frama-C. Key use cases involve optimizing code analysis by managing PDG marks for parameters, variables, and input locations while supporting slice merging and signature extraction.",
      "description_length": 634,
      "index": 438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingSelect",
      "library": "frama-c-slicing.core",
      "description": "This module supports precise dataflow slicing by enabling the construction and modification of selection contexts that target program elements such as statements, PDG nodes, kernel functions, and memory zones. It facilitates operations like selecting nodes based on execution paths, function boundaries, or memory effects, merging criteria for incremental analysis, and adjusting call sites during slicing transformations. These capabilities are specifically applied in program analysis tasks such as impact analysis, dependency tracking, and refactoring scenarios where integration with a program dependency graph or Frama-C's analysis pipeline is required.",
      "description_length": 658,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingState",
      "library": "frama-c-slicing.core",
      "description": "Manages the internal state of a slicing project, providing access to the current slicing project data and enabling conditional execution based on initialization status. It works with the `sl_project` type from `SlicingTypes` and supports operations that depend on whether the slicing state has been initialized. Useful for ensuring safe access to slicing data after project setup or handling fallback behavior when no project is active.",
      "description_length": 436,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingCmds",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for selecting and manipulating program elements in control flow or data flow graphs, focusing on criteria based on data dependencies, control flow, and syntactic constructs like lvalues and predicates. It works with sets to represent slicing criteria, selection sets for managing marked elements (e.g., statements, functions, PDG nodes), and a global action list for batch processing. These tools enable tasks such as iterative slicing, propagation of selections, and applying transformations across program representations while maintaining state consistency.",
      "description_length": 592,
      "index": 441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTransform",
      "library": "frama-c-slicing.core",
      "description": "Performs program slicing transformations on a CIL AST, extracting a reduced version of the program based on slicing criteria. It applies pending actions in a project and generates a new program representation reflecting the sliced code. Uses a provided function to customize naming of sliced functions, and outputs the transformed CIL AST to a specified file.",
      "description_length": 359,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Register",
      "library": "frama-c-slicing.core",
      "description": "This module handles the registration of a plugin within the Frama-C kernel, ensuring it is properly initialized and available for use. It operates internally without exposing any functions or data types to external code. A typical use case involves invoking its registration routine during the plugin's setup phase to integrate it into the Frama-C analysis framework.",
      "description_length": 367,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations to configure slicing modes, manage slicing projects, define element roles via marks, construct selection sets, and manipulate function slices within a control flow graph. It works with kernel functions, statements, zones, and control flow nodes to support tasks like dependency tracking, call graph analysis, and slice-based debugging. Concrete use cases include extracting and transforming slices for impact analysis, visualizing slicing results, and preserving execution context during static analysis.",
      "description_length": 536,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingActions",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for constructing and modifying slicing criteria in a program dependence graph, focusing on node and dependency selections through mechanisms like data/control/address dependency tracking, function call analysis, and mark propagation. It works with typed representations of marked nodes (`sl_mark`), selection rules (`select`), and composite criteria structures to enable precise slice definition and directional analysis. These capabilities are applied in scenarios like call site refinement, input/output boundary determination, and debug visualization of slicing artifacts.",
      "description_length": 607,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.PrintSlice",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions to print formatted slices of C code elements, such as function slices, marked function slices, global variables, and function statements. It works with data types like `fct_slice`, `Pdg.t`, `global`, and `kernel_function`, primarily from the Frama-C and slicing internals. It is used to generate human-readable representations of code slices and to build dot files for visualization projects.",
      "description_length": 423,
      "index": 446,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes",
      "library": "frama-c-slicing.core",
      "description": "This module defines core data types and operations for managing slicing projects, function slices, selection criteria, and slice marks. It includes structured representations for tracking slice state and dependencies during static analysis. Concrete use cases include identifying function-specific slicing criteria, managing slice project identities, and annotating code elements with slice metadata for precise analysis and transformation.",
      "description_length": 440,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters",
      "library": "frama-c-slicing.core",
      "description": "This module manages diagnostic output, configuration parameters, and warning handling for program slicing analysis. It operates on structured logging categories, verbosity levels, session paths, and command-line option groups, with support for stateful parameter constraints and deprecation notices. Key use cases include controlling debug output granularity, enforcing slicing analysis constraints, and configuring warning categories during static code analysis workflows.",
      "description_length": 473,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions for configuring slicing criteria, manipulating function slices within control flow and program dependence graphs, and managing marks to track dependencies and visibility. It operates on data structures such as `fct_slice`, `pdg_mark`, `stmt`, and `sl_mark`, supporting tasks like slice merging, selection refinement, and call site analysis. Concrete use cases include performing static analysis for impact tracking, generating visualizations of slicing results, and transforming code based on computed slices.",
      "description_length": 540,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating string-based scoped data in static analysis. It supports membership testing within projects, deep copying, and structured pretty-printing, tailored for use in Frama-C's scope analysis framework. The type `t` is used to model string multiple maps with associated descriptors, equality, and hash operations.",
      "description_length": 399,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for a data type used in scope analysis to represent string-based identifiers for kernel functions. It supports equality checks, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate function names within the analysis, particularly when integrating with Frama-C's project and type systems.",
      "description_length": 399,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing function declaration sets as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks based on project context and provides deep copying to ensure value independence. Concrete use cases include managing and comparing function scope data during static analysis, and persisting or displaying scope information in a user-friendly format.",
      "description_length": 441,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating string-based scoped values. It includes functions for equality checks, hashing, pretty-printing, and deep copying, along with descriptors for type and structure. It is used to handle string identifiers within a scope analysis context, supporting operations like membership testing in projects and structural comparison.",
      "description_length": 413,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations in a scope analysis context. It supports managing and querying values that can include project-specific information, using a unique name and a descriptor for type consistency. It is used to handle distinct string identifiers with associated properties in static analysis tasks.",
      "description_length": 427,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It includes functions for checking membership based on project conditions, deep copying values, and integrating with Frama-C's type and descriptor system. It is used to manage string list representations in static analysis contexts where precise data flow and project-specific conditions are required.",
      "description_length": 455,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for a string-based data type used in scope analysis, including equality, comparison, hashing, and pretty-printing. It supports internal management of representants, descriptors, and project membership checks for string values. Concrete use cases include handling string identifiers in static analysis, comparing and storing string-based data, and ensuring deep copies for safe manipulation in different analysis contexts.",
      "description_length": 452,
      "index": 456,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing and manipulating string-based file paths in the context of scope analysis. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to track and analyze file paths during static analysis, enabling precise handling of file-related data across different analysis phases.",
      "description_length": 433,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for handling string-based representations of kernel functions, including equality, comparison, hashing, and pretty-printing. It supports working with lists of these types, provides deep copying, and includes project membership checks for Frama-C project skeletons. It is used to manage and manipulate function sets in the context of static analysis, specifically for scope analysis within the Frama-C framework.",
      "description_length": 459,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for handling sets of strings in the context of scope analysis, providing standard operations like equality, comparison, hashing, and pretty printing. It supports internal representations of string sets with functions for membership testing, deep copying, and project-based filtering. Concrete use cases include managing and comparing string identifiers during static analysis of C code, particularly for tracking scope-related properties.",
      "description_length": 470,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for a string-based data type used in scope analysis, including equality, comparison, hashing, and pretty-printing. It supports working with project-specific values through predicates like `mem_project` and provides deep copying to ensure value independence. Concrete use cases include managing and comparing string identifiers within kernel function scopes during static analysis.",
      "description_length": 411,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with string-based representations of file paths and includes utilities for project membership checks and deep copying. Concrete use cases include managing and comparing sets of file paths in static analysis contexts, such as tracking source files or dependencies in a project.",
      "description_length": 440,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type and operations for handling sets of strings in a way that supports comparison, hashing, and pretty-printing. It provides functions for checking membership in projects, deep copying values, and defining type descriptors for integration with Frama-C's kernel. The module is used to represent and manipulate string-based data within the scope analysis framework, ensuring compatibility with Frama-C's internal mechanisms for data representation and project management.",
      "description_length": 497,
      "index": 462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a data type for handling multiple string bindings in scope analysis, supporting operations like equality, comparison, hashing, and pretty-printing. It works with strings as representational values and includes functionality for project membership checks and deep copying. It is used to manage and analyze string-based identifiers within Frama-C's scope analysis framework.",
      "description_length": 395,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It works with string-based data structures, providing deep copy and membership checks for project-related values. Concrete use cases include managing and comparing string identifiers in static analysis contexts.",
      "description_length": 330,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing string-typed configuration parameters with support for dynamic value validation, default handling, and serialization within Frama-C's scope analysis framework. It works with string values and lists of allowed values, enabling checks against predefined options or function name validity, and is used for command-line configuration, project state persistence, and scoped analysis rule enforcement. Key functionality includes tracking parameter changes, marshaling data across sessions, and ensuring inputs conform to declared constraints.",
      "description_length": 581,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Enum.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a finite enumerated type `t` with operations for comparison, hashing, and pretty-printing. It provides a list of all possible values, equality checks, and a deep copy function. Use cases include representing fixed sets of values in scope analysis where structural equality and enumeration are required, such as tracking specific program analysis states or predefined identifiers.",
      "description_length": 399,
      "index": 466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Action.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling efficient value manipulation and introspection. Use cases include managing and analyzing program scopes with precise type information, such as tracking variable lifetimes and type relationships in a compiler or static analysis tool.",
      "description_length": 502,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Verbose.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It includes functions for checking membership within projects, deep copying values, and exposing structural descriptors for serialization. The type supports representants and is designed for precise manipulation of scoped data structures in static analysis contexts.",
      "description_length": 415,
      "index": 468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides state management and validation for string list parameters, supporting operations to set, retrieve, and validate values against function name constraints or plain string criteria. It works with string lists and individual strings, integrating hooks for serialization, command-line interaction, and Frama-C project state synchronization. Use cases include configuration handling for analysis tools and enforcing input validity in static analysis workflows.",
      "description_length": 476,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.WithOutput.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for a specific datatype used in scope analysis, including equality, comparison, hashing, and pretty-printing functions. It works with `Datatype.t` values, providing deep copying, membership checks over project skeletons, and structural descriptions for representation and serialization. Concrete use cases include managing and comparing abstract values during static analysis, such as tracking variable scopes or analyzing control flow structures.",
      "description_length": 478,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a string map data structure with efficient lookup, insertion, and traversal operations. It works with associative maps from string keys to values of type `Datatype.t`, supporting operations like `equal`, `compare`, and `hash` for key-value integrity. Concrete use cases include tracking variable bindings during scope analysis and managing symbol tables with string-identified entries.",
      "description_length": 408,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a set-like structure for managing collections of `Datatype.t` values with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks, deep copying, and project-aware filtering through the `mem_project` function. Concrete use cases include analyzing and manipulating scoped data representations in static analysis tasks, such as tracking variable occurrences or evaluating type descriptors.",
      "description_length": 457,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage string-based parameters representing file paths, including validation against allowed values, serialization, and dynamic value updates through hooks. It works with string collections and parameterized state structures, supporting both plain string inputs and function name validation for controlled value assignment. The module is designed for static analysis workflows, enabling precise file path handling in project-specific contexts and integration with analysis kernels like Frama-C.",
      "description_length": 529,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides utilities to manage a string-valued configuration parameter representing function declaration sets, including setting, retrieving, and validating values against predefined options. It operates on string lists for parameter constraints and string identifiers for function names, with support for update hooks and custom marshaling. These capabilities enable static code analysis workflows such as scope management, command-line interface integration, and persistent storage of analysis configurations.",
      "description_length": 521,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Float.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing optional decimal parameters as OCaml floats, with operations for equality, comparison, hashing, and pretty printing. It includes standard data structure primitives like deep copy, membership testing over projects, and type descriptors for integration with the Frama-C kernel. Concrete use cases include handling floating-point configuration parameters and analysis values within Frama-C's scope analysis framework.",
      "description_length": 463,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing sets of strings that are filled in a specific scope analysis context. It provides operations for equality checking, comparison, hashing, and pretty-printing these sets, along with deep copying and project membership testing. It is used to track and manipulate string sets within static analysis passes, particularly when handling data representations tied to Frama-C's internal project model.",
      "description_length": 441,
      "index": 476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling multi-mapped values in scope analysis. It supports deep copying and membership checks over project skeletons, ensuring structural integrity and uniqueness through its descriptor and representants. It is used to manage and manipulate complex scoped data structures in Frama-C's analysis framework.",
      "description_length": 422,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type and associated operations for representing and manipulating function mappings in the context of scope analysis. It supports key functionalities such as equality checking, comparison, hashing, pretty printing, and deep copying of function data. The type is used to manage function declarations and prototypes, enabling precise tracking and analysis of function usage within a project.",
      "description_length": 415,
      "index": 478,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.True.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis within Frama-C. It supports deep copying, membership testing within projects, and provides representants and descriptors for structural manipulation. It is used to model and analyze program elements with precise type and project relationships in Frama-C plugins.",
      "description_length": 411,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for parameter customization in scope analysis, specifically handling function declarations and prototypes. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, with support for setting accessors and dependencies. Use cases include configuring how function parameters are interpreted in different analysis contexts, such as enabling or disabling specific function handling globally or by category.",
      "description_length": 490,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for defining and manipulating string-based analysis parameters with constrained value sets and validation rules. It supports setting allowed values, checking if a value is a valid function name, and retrieving raw string representations, while integrating command-line handling and dynamic value update hooks. These capabilities are used in Frama-C's kernel to implement scope analysis options that require restricted input domains, such as function-specific configurations or extensible parameter sets with runtime validation.",
      "description_length": 559,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages category definitions for a collection, supporting operations to create, enable, and configure categories with specific accessors and dependencies. It works with category and state data types from the Frama_c_kernel module, including handling special categories like `@none`, `@default`, and `@all`. Concrete use cases include defining named categories with associated states and accessors, setting default category behavior, and enabling the `@all` category with specific interpretations for state propagation.",
      "description_length": 530,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for a collection with multibinding support, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameterized elements and state lists, allowing the association of accessors and dependencies. Concrete use cases include setting up category behaviors for scope analysis, enabling global category interpretations, and redirecting category references.",
      "description_length": 471,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages category definitions and configurations for a collection, supporting operations to create, enable, and set default or special-purpose categories with custom accessors and dependencies. It works with category types and state lists to define behaviors for positive and negative occurrences. Concrete use cases include setting up analysis scopes with named categories, enabling global behaviors through `@all`, or defining fallback interpretations via `@default`.",
      "description_length": 480,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types derived from `Frama_c_kernel.Parameter_category.t` and state lists from `Frama_c_kernel.State`. It is used to configure how parameters are grouped and interpreted in scope analysis, particularly for setting default behaviors and enabling global categories with specific accessors.",
      "description_length": 474,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for handling string values within a scope analysis framework, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports internal representation and manipulation of string data through a structured descriptor and deep copying. Concrete use cases include managing string identifiers and values during static analysis, ensuring accurate tracking and comparison within the analysis context.",
      "description_length": 463,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Int.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's scope analysis. It includes functions for deep copying values, checking membership based on project properties, and exposing type descriptors for integration with the kernel. Concrete use cases include representing and manipulating analysis-specific data structures during static analysis phases within Frama-C plugins.",
      "description_length": 457,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for parameter grouping, using `Category.t` as the primary data structure. It supports operations to create named categories with accessors and dependencies, configure the default and `@all` category behaviors, and enable global category interpretations. These features are used to control parameter propagation and resolution in scope analysis contexts.",
      "description_length": 396,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.False.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's scope analysis. It includes functions for deep copying values, checking membership of project skeletons, and exposing structural descriptors for integration with the kernel's typing system. The datatype is designed to represent and manipulate analysis-specific data during static analysis phases within Frama-C plugins.",
      "description_length": 452,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It supports values of type `Datatype.t` and ensures deep copying and project membership checks. Concrete use cases include managing and comparing scoped entities like variables or types within a program analysis framework.",
      "description_length": 362,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage string-typed configuration parameters with constraints, including setting allowed values, handling aliases, and validating function names or plain strings. It works with string data and associated metadata like default values, serialization rules, and allowed input lists, while integrating with scope analysis and command-line interface systems. Specific use cases include defining restricted configuration options for project state management, validating user-provided function names, and parsing CLI arguments with predefined string constraints.",
      "description_length": 590,
      "index": 491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports set operations and project membership checks, enabling precise handling of string sets in static analysis contexts. Use cases include tracking sets of identifiers or string-based values during abstract interpretation or program analysis.",
      "description_length": 386,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Debug.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for debugging scope analysis data. It supports structured representation through descriptors, packed descriptions, and a list of representatives for inspection. Use cases include analyzing and comparing scope data structures during debugging, checking project membership, and ensuring deep copies for data integrity.",
      "description_length": 433,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides utilities for managing string-based options with change tracking and validation, specifically handling kernel function sets in Frama-C's analysis framework. It operates on string values and lists of allowed strings, supporting operations to set, retrieve, and validate function names or plain strings against predefined constraints. The module integrates with the system's state management to enable CLI configuration, option aliasing, and serialization for scenarios like project persistence or dynamic analysis parameterization.",
      "description_length": 551,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's kernel analysis framework. It includes descriptors for type representation, a unique name, and functions for deep copying and project membership checks. It is used to manage and manipulate analysis-specific data structures within Frama-C plugins, ensuring consistency and integrity during static analysis.",
      "description_length": 443,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type and associated operations for representing and manipulating function declarations within a scope analysis context. It supports equality checks, comparison, hashing, and pretty-printing for function data, enabling efficient storage and retrieval in analyses. The type is used to track function definitions and prototypes, with capabilities for deep copying and project membership testing.",
      "description_length": 419,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for organizing and manipulating file paths within a scope analysis framework. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, each controlling how file path data is interpreted and aggregated. Use cases include configuring analysis settings, enabling or disabling groups of file paths, and defining dependencies between categories for consistent state management.",
      "description_length": 453,
      "index": 497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for organizing elements in a scope analysis context. It provides operations to create, modify, and enable categories with specific accessors and dependencies, including special categories like `@none`, `@default`, and `@all`. Use cases include configuring analysis parameters and controlling scope propagation behavior in static analysis tools.",
      "description_length": 387,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based file path parameters with validation and state tracking capabilities, focusing on command-line interface integration and persistent configuration. It operates on string values representing file paths, using string lists for constraint validation and distinguishing between plain strings and function name references in project-specific contexts. Typical use cases include static analysis tools requiring robust file path handling, parameter validation workflows, and systems needing to serialize or hook into path value changes across different execution phases.",
      "description_length": 595,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing and manipulating lists of file paths within a scope analysis context. It provides standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage collections of file paths that are part of a project's scope, enabling precise analysis and tracking within Frama-C's kernel.",
      "description_length": 422,
      "index": 500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter customization in scope analysis, allowing the definition and manipulation of named categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent different categories, and supports operations like setting defaults, enabling categories, and defining accessors with dependencies. Concrete use cases include configuring how function parameters are interpreted in the presence of prototypes and controlling the behavior of the `@all` category in both positive and negative contexts.",
      "description_length": 563,
      "index": 501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a map data structure specialized for file paths, supporting efficient lookups, insertions, and deletions. It works with `Datatype.t` values, organizing them based on file path keys. It is used to manage and query collections of data associated with specific source code files in static analysis tasks.",
      "description_length": 324,
      "index": 502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage string parameters with constrained value sets, including validation against allowed options, function name checks, and callback registration for value changes. It works with string data enriched by metadata such as default values, valid function identifiers, and serialization hooks, while integrating with Frama-C's state management system. Typical use cases involve parameter customization in plugins, such as restricting inputs to predefined string options or ensuring valid C function name references during static analysis.",
      "description_length": 570,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter grouping in a kernel function set, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with `Category.t` values, which represent individual categories, and interacts with `Frama_c_kernel.State.t` lists to define category behavior. Concrete use cases include setting up the `@none`, `@default`, and `@all` categories, enabling `@all` with specific interpretations, and dynamically modifying category assignments for plugin parameters.",
      "description_length": 552,
      "index": 504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides utilities for managing mutable configuration parameters that accept multiple string values, supporting operations to set, validate, and track changes to these values. It works with multibinding maps and string-based parameters, incorporating features like alias resolution, function name validation, and serialization. It is particularly useful in static analysis contexts for enforcing parameter constraints and integrating dynamic configuration updates with scope analysis workflows.",
      "description_length": 506,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for handling file paths within a scope analysis context. It provides equality, comparison, hashing, and pretty-printing functions for a custom data type representing file paths. The module supports deep copying and includes functionality to check membership within projects using custom predicates.",
      "description_length": 329,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Empty_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for representing empty strings within a scope analysis framework. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to model and manipulate empty string values in static analysis plugins for Frama-C.",
      "description_length": 340,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for a parameter map, supporting operations to create, modify, and query named categories with associated accessors and dependencies. It works with category types derived from `Frama_c_kernel.Parameter_category.t`, including predefined categories like `@none`, `@default`, and `@all`. Concrete use cases include setting up scoped configuration categories for analysis parameters, enabling global behaviors through `@all`, and redirecting category interpretations via `enable_all_as`.",
      "description_length": 525,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements operations for managing lists of a specific datatype, including equality, comparison, hashing, and pretty-printing functions. It provides deep copying and membership checks for project-specific values within the list structure. Use cases include handling collections of analyzed data elements where structural integrity and value comparison are critical.",
      "description_length": 377,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for string sets in the context of scope analysis, providing operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`. It works with category types derived from `Frama_c_kernel.Parameter_category.t` and supports adding named categories with accessors and dependencies. Concrete use cases include configuring scope analysis behavior through category-based filtering and state management in Frama-C plugins.",
      "description_length": 474,
      "index": 510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Bool.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a boolean data type with standard operations including equality, comparison, hashing, and pretty printing. It provides a deep copy function and supports project membership checks for values within a specified scope. The type is used to represent logical truth values in static analysis contexts, such as tracking variable states or condition outcomes.",
      "description_length": 371,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a set of operations for managing and comparing a specific abstract data type `t`, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership within projects, create deep copies, and describe the type with a unique name and descriptor. These operations support analysis tasks requiring precise type handling, such as tracking and comparing function declarations within Frama-C's scope analysis.",
      "description_length": 461,
      "index": 512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage a string-based parameter for kernel function identifiers in Frama-C's scope analysis, including value setting/retrieval, validation against allowed functions or prototypes, and customization of marshaling behavior. It operates on strings and predefined value sets, integrating with Frama-C's state system to handle tasks like alias resolution, input validation, and dynamic updates during static analysis. Specific use cases include enforcing function name constraints, managing prototype inclusion via parameter hooks, and customizing string representations for analysis contexts.",
      "description_length": 623,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages scoped string parameters through operations like setting and retrieving values, validating inputs against predefined lists, and handling aliases or dynamic value transformations. It operates on parameter configurations that include default values, help documentation, and custom marshaling rules, supporting use cases in command-line interface integration and persistent scoped state management where input validation and structured configuration are critical.",
      "description_length": 480,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a map data structure specialized for keys of type `String_multiple_map.Datatype.t`, supporting efficient lookups, insertions, and deletions. It works with associative collections where keys are strings with multiple occurrences, and values are of an arbitrary type. Concrete use cases include tracking multiple string-indexed values in static analysis contexts, such as mapping variable names to sets of possible values or annotations.",
      "description_length": 458,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a data type for representing and manipulating lists of strings within a scope analysis context. It provides standard operations such as equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to handle string lists as part of dataflow analyses in Frama-C, particularly when tracking and comparing scoped values across program states.",
      "description_length": 428,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for a collection of string lists, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It supports setting accessors and dependencies for categories, enabling fine-grained control over how string list parameters are interpreted and activated. Concrete use cases include configuring analysis options where different categories determine how specific lists of values are processed or applied.",
      "description_length": 479,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter accessors and state lists, allowing dynamic configuration of category behavior. Concrete use cases include setting up default interpretations for analysis parameters and enabling global category overrides in scope analysis.",
      "description_length": 443,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Custom.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It supports deep copying and provides introspection capabilities through a list of representative values and a packed descriptor. Concrete use cases include managing and analyzing abstract values in static analysis plugins, particularly when custom data structures need to be passed as parameters in the Frama-C framework.",
      "description_length": 469,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string parameters with change-tracking capabilities, offering operations to define allowed values, register update hooks, and enforce validation rules for both plain strings and function name constraints. It operates on string data that may represent static values or callable function identifiers, supporting use cases in static analysis configuration where parameter integrity and dynamic behavior (via hooks) are critical. The module also facilitates command-line interface integration through customizable serialization and alias management for parameter values.",
      "description_length": 586,
      "index": 520,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Zero.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It provides a structured representation with a unique name, type information, and descriptor handling, supporting deep copying and membership checks over project skeletons. Concrete use cases include managing and analyzing abstract values in static analysis plugins, such as tracking variable scopes or evaluating data dependencies.",
      "description_length": 471,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module offers operations to manage string parameters with observable state changes, default value handling, and command-line integration. It works with string data and lists of allowed values, supporting validation against predefined options or function names through pre/post hooks and controlled access patterns. Typical use cases include configuring static analysis tools with dynamically validated parameters and tracking runtime-modifiable settings in program analysis frameworks.",
      "description_length": 490,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with the `Category.t` type, which wraps a parameter category from the Frama-C kernel, and supports adding new categories with custom accessors and dependencies. Concrete use cases include configuring analysis scopes by associating parameters with specific categories and controlling default or global behavior through category overrides.",
      "description_length": 518,
      "index": 523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set",
      "library": "frama-c-scope.core",
      "description": "This module provides imperative set operations for managing collections of function declarations (`Fundec.Set.t`), including addition, iteration, folding, and membership checks, alongside state management features like project-specific tracking and default value handling. It integrates with configuration systems through CLI support and persistent storage, enabling use cases such as scope analysis in program verification, dynamic analysis scope control, and serialization of analysis states for incremental processing.",
      "description_length": 521,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Value_string",
      "library": "frama-c-scope.core",
      "description": "This module implements a string-based data type with standard operations including equality, comparison, hashing, and pretty printing. It supports conversions to and from string representations, deep copying, and membership testing over project skeletons. The type is used to represent and manipulate scoped string values in the context of static analysis, particularly for Frama-C plugins.",
      "description_length": 390,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing mutable string sets, including element insertion, membership testing, iteration, and emptiness checks, alongside CLI integration for configuration via command-line arguments, help message generation, and visibility control. It supports change notifications, custom marshaling, and scoped configuration management using Frama-C's parameter and category systems. The module is used in static analysis plugins to track string-based identifiers across program states and maintain extensible sets of scoped analysis directives.",
      "description_length": 567,
      "index": 526,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Verbose",
      "library": "frama-c-scope.core",
      "description": "This module manages a scoped integer parameter for controlling verbosity levels in static analysis, offering operations to set, increment, and enforce range constraints on the value while tracking state changes. It operates on an internal integer state with associated metadata for allowed ranges, aliases, and serialization formats, supporting dynamic configuration through command-line interfaces or runtime adjustments. The design enables diagnostic output control in analysis tools by ensuring valid state transitions and providing hooks for reactive updates or help documentation generation.",
      "description_length": 596,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Bool",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage boolean-typed configuration parameters in static analysis contexts, supporting value mutation, pre/post-update hooks, and command-line interface integration. It operates on `bool` values encapsulated within a shared `Typed_parameter.t` structure, enabling state control via unit functions like `on`/`off`. Use cases include kernel-level state management in Frama-C, where boolean flags drive analysis behaviors and require customizable serialization or dynamic value tracking.",
      "description_length": 518,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Float",
      "library": "frama-c-scope.core",
      "description": "This module manages floating-point configuration parameters with optional values and configurable validity ranges, enabling operations like value setting/retrieval, default initialization, change tracking via hooks, and range enforcement. It works with `float` values encapsulated in a `t` type that carries metadata and project-specific state, while supporting command-line integration, serialization, and alias management. Typical use cases include defining analysis thresholds, numeric tolerances, or resource limits in scope analysis tools where optional parameters must adhere to constrained ranges and interact with external interfaces.",
      "description_length": 642,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Zero",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing scoped integer options and parameters with customizable hooks, serialization, and project-specific state tracking. It supports data structures for integers constrained to value ranges, enabling use cases like tracking variable bounds in static analysis or persisting analysis state across projects through aliased scoped values. Key features include incrementing constrained values, registering update callbacks, and defining persistent state behavior for analysis plugins.",
      "description_length": 518,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage string configuration parameters, including setting, retrieving, and validating values against allowed lists, with support for aliases, serialization, and dynamic value computation. It works with string-typed parameters that may have associated validation functions, allowed value sets, or computed states, enabling use cases like configuring Frama-C's analysis options, enforcing value constraints, and integrating parameter metadata with user-facing help systems or persistent storage.",
      "description_length": 528,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set",
      "library": "frama-c-scope.core",
      "description": "This module manages mutable sets of strings with operations for adding elements, checking membership, iteration, and emptiness checks, while integrating with Frama-C's scope analysis framework. It supports command-line option handling through aliases and help messages, tracks state changes via hooks, and enables custom marshaling for persistence. The module's category subsystem interacts with Frama-C's parameter system to manage scoped string sets as project-specific analysis configurations.",
      "description_length": 496,
      "index": 532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.State_dir",
      "library": "frama-c-scope.core",
      "description": "This module manages file paths for a plugin's state directory, providing operations to retrieve or create directories and files within it. It works with string names and `Frama_c_kernel.Filepath.t` paths, allowing configuration of a user directory and checking its status. Concrete use cases include storing and accessing plugin-specific state files during analysis runs.",
      "description_length": 371,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_site_dir",
      "library": "frama-c-scope.core",
      "description": "This module constructs a `Site_dir` by cloning an existing one, using a parent directory and a target directory name. It provides `get_dir` and `get_file` operations to retrieve validated directory and file paths by name, ensuring correct type and existence. It works directly with `Frama_c_kernel.Filepath.t` and assumes structured directory content, useful for managing site-specific resources like configuration or data files.",
      "description_length": 429,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage file path values, including update hooks, alias handling, serialization, and validation checks like emptiness, along with configuration-driven state management. It works with a custom file path type that supports project-specific context and visibility controls, enabling use cases such as scope analysis path tracking and rule enforcement during static analysis workflows.",
      "description_length": 415,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map",
      "library": "frama-c-scope.core",
      "description": "This module provides a structured way to manage key-value associations with string keys and values of type `V.t`, supporting operations like insertion, lookup, iteration, and state tracking. It incorporates advanced features such as alias management, category grouping, validation rules, and customizable serialization, while enabling hooks for change monitoring and default value handling. Designed for scenarios requiring dynamic configuration management, project state tracking, and command-line interface integration, it facilitates robust handling of hierarchical or scoped data models.",
      "description_length": 591,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for maintaining a mutable map of string keys to lists of values, with functionality to set entries, fetch associated lists, reset state, and monitor modifications via lifecycle hooks. It operates on string-indexed collections of `V.t` elements, supporting advanced use cases like tracking variable annotations, aggregating value sets during scope analysis, and managing hierarchical configuration parameters with category-based classifications. The structure also facilitates serialization, equality comparisons, and scoped state management for analysis workflows requiring persistent, versioned data mappings.",
      "description_length": 642,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Cache_dir",
      "library": "frama-c-scope.core",
      "description": "This module manages file paths for a cache directory used by a plugin, providing operations to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to handle platform-independent paths and ensures the existence of required structures based on a central user-defined directory. Concrete use cases include storing and accessing cached analysis results or temporary files during static code analysis.",
      "description_length": 438,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Config_dir",
      "library": "frama-c-scope.core",
      "description": "This module manages file paths for a plugin's configuration directory, providing operations to retrieve or create directories and files within it. It works with string names and `Frama_c_kernel.Filepath.t` paths, allowing the user to set or check a central user directory. Concrete use cases include initializing plugin-specific storage locations or accessing configuration files during analysis.",
      "description_length": 396,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list",
      "library": "frama-c-scope.core",
      "description": "This module enables managing list-based state variables with operations to set, retrieve, and compare values, register update callbacks, and customize serialization. It works with element collections supporting addition, iteration, folding, and emptiness checks, alongside modules for validated string parameters (`As_string`) and category-based grouping (`Category`). Applied in Frama-C's scope analysis for handling project-specific configurations and dynamic state updates.",
      "description_length": 476,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage a scoped string list parameter in Frama-C's scope analysis, enabling setting and retrieving values, monitoring changes with hooks, handling command-line options with aliases and visibility controls, and supporting dataflow analysis through tracking and serialization. It operates on string lists and individual strings, incorporating parameter state management, validation, and category-based configuration modules to facilitate comparison, iteration, and propagation of string list data across program states. These features are applied in static analysis tools to handle configurable analysis contexts, propagate variable tracking information, and manage hierarchical configurations with customizable visibility and persistence.",
      "description_length": 772,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.True",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing a boolean configuration option, including setting values (`on`/`off`), tracking state changes via hooks, and integrating with command-line interfaces and serialization systems. It works with a boolean type `t` and incorporates project-specific state management to support persistent configuration across Frama-C's analysis sessions. These capabilities are used for kernel-level parameters and plugin settings where dynamic, observable boolean flags control behavior or visibility in static analysis workflows.",
      "description_length": 554,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Session",
      "library": "frama-c-scope.core",
      "description": "This module manages file and directory paths within a session-specific context, providing direct access to session resources. It supports operations to retrieve or create directories and files, and allows setting and querying a user-defined directory path. Concrete use cases include handling plugin-specific storage during analysis sessions, such as caching intermediate results or logging session data to disk.",
      "description_length": 412,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a map associating function declarations (`kernel_function`) with lists of values (`V.t list`), supporting operations to set, retrieve, and modify entries while notifying hooks of changes. It incorporates aliases, serialization customization, and category-based parameter configuration (`Category.t`), enabling use cases like tracking function-specific state during scope analysis or handling project-specific computations in Frama-C. The structure integrates with Frama-C's state system, allowing default values, prototype inclusion via parameter customization, and cross-analysis data consistency.",
      "description_length": 618,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.WithOutput",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage a boolean parameter with state tracking, serialization hooks, and project-specific context, alongside mechanisms to control plugin output behavior through dependency-aware activation and conditional generation. It operates on boolean values and `Datatype.t` structures, supporting use cases like scope analysis in static code analysis and state-driven output management for Frama-C plugins.",
      "description_length": 432,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_user_dir_opt",
      "library": "frama-c-scope.core",
      "description": "This module constructs and manages a `User_dir_opt` from a `User_dir`, providing operations to retrieve or set file paths with optional directory creation. It works with `Frama_c_kernel.Filepath.t` to handle file and directory paths, supporting use cases like initializing analysis directories from existing paths or environment variables. Functions include setting a directory, fetching files or directories by name, and checking if a directory was set.",
      "description_length": 454,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Value_int",
      "library": "frama-c-scope.core",
      "description": "This module implements an integer-based data type with standard operations including equality, comparison, hashing, and pretty printing. It supports internal scope analysis by providing deep copying, project membership checks, and string serialization/deserialization. The type is used to represent and manipulate integer values within Frama-C's scope analysis framework, particularly for tracking and comparing analysis states.",
      "description_length": 428,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map",
      "library": "frama-c-scope.core",
      "description": "This module manages mappings between kernel functions and customizable values, enabling operations to track state changes, enforce default value policies, and associate analysis metadata with function declarations. It organizes data using a specialized map structure with kernel functions as keys and supports advanced parameter handling through alias resolution, custom marshaling directives, and categorical grouping of function properties. These capabilities facilitate scope analysis tasks such as interprocedural dataflow tracking and configurable analysis parameter propagation in Frama-C's analysis pipeline.",
      "description_length": 615,
      "index": 548,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_user_dir",
      "library": "frama-c-scope.core",
      "description": "This module constructs a `User_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` functions to retrieve or create subdirectories and files, with an option to automatically create missing parent paths. It operates directly on `Frama_c_kernel.Filepath.t` values, ensuring correct path resolution relative to the parent directory.",
      "description_length": 364,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Action",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage boolean state through configuration parameters, supporting actions like setting values (via `on`/`off`), retrieving state, and tracking changes with hooks. It integrates with Frama-C kernel parameters for analysis configuration, includes CLI features like help generation and alias handling, and supports serialization and equality comparisons. The core data structures involve boolean values and typed parameters, used in static analysis tools to control scope analysis behavior and persist state across projects.",
      "description_length": 556,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Enum",
      "library": "frama-c-scope.core",
      "description": "This module manages scoped enumerated options with a finite variant type `t` that enforces structural equality, enabling operations like value setting/retrieval, change hooks, and project-specific state tracking. It works with fixed-value lists (`all_values`) and integrates with command-line interfaces and custom marshaling, supporting aliases and defaults. Use cases include configuration systems requiring strict value constraints, such as analysis phase settings or domain-specific mode switches in toolchains like Frama-C.",
      "description_length": 528,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing a multi-map structure where each key maps to a list of values, supporting element manipulation (add, find, iter, fold), state tracking, and dynamic updates with semantic consistency. It works with key-value pairs stored in `K.Map.t` and `V.t list` structures, incorporating features like aliasing, custom marshaling, and category-based organization. It is particularly useful in scope analysis for handling configuration parameters with multiple valid values per key, such as analysis options or semantic rules, while enabling integration with project systems and serialization workflows.",
      "description_length": 633,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for managing and manipulating collections of file paths (`Frama_c_kernel.Filepath.t`), including configuration workflows for setting, updating, and serializing lists, as well as utilities for iteration, comparison, and state management. It supports scope analysis by tracking project-specific file paths and enabling hooks for dynamic updates, with use cases in static analysis contexts where file path aliases, category-based parameters, or marshaling behavior are required.",
      "description_length": 507,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map",
      "library": "frama-c-scope.core",
      "description": "This module provides operations to manage a global state represented as a map from file paths to values of type `V.t`, enabling setting, retrieval, and reset functionality alongside hooks for state change notifications. It works with key-value pairs using file path semantics, supporting aliases, membership checks, and iterative transformations, while incorporating validated and categorized string-based file paths. It is particularly useful in static analysis tasks for tracking file-associated data, managing configurations, and integrating with command-line tools.",
      "description_length": 569,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set",
      "library": "frama-c-scope.core",
      "description": "This module enables set-like state manipulation with change tracking, serialization, and scoped analysis capabilities for `Datatype.t` elements, supporting efficient membership checks and equality comparisons. It also manages parameter aliases with visibility and deprecation metadata, alongside scoped string and category parameters, facilitating configuration validation and state management in static analysis workflows where hierarchical or contextual data organization is required.",
      "description_length": 486,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Custom",
      "library": "frama-c-scope.core",
      "description": "This module enables managing customizable scoped state with pre/post-update hooks and custom serialization, alongside parameter configuration through aliases, visibility controls, and value constraints. It operates on custom data types and string lists, primarily supporting Frama-C's static analysis plugins for cross-project state management and validated parameter handling. Key use cases include analysis state persistence, dynamic parameter validation, and extensible configuration in plugin-driven environments.",
      "description_length": 517,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set",
      "library": "frama-c-scope.core",
      "description": "This module provides operations for manipulating sets of kernel functions (Frama_c_kernel.Cil_datatype.Kf.Set.t) through standard collection primitives like addition, iteration, membership checks, and emptiness verification, while supporting advanced features like state change hooks and project-specific persistence. It integrates with Frama-C's configuration system via command-line option handling with aliases, help documentation, and serialization customization, alongside submodules for validated string options and category-based function grouping. These capabilities enable use cases such as tracking analysis targets during static analysis, organizing functions into configurable analysis groups, and implementing plugin-specific settings that persist across Frama-C sessions.",
      "description_length": 785,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.False",
      "library": "frama-c-scope.core",
      "description": "This module manages boolean parameters in Frama-C's scope analysis, providing functions to set and retrieve values (e.g., `on`/`off`), register hooks for state changes, and integrate command-line visibility and alias handling. It operates on boolean values encapsulated in Frama_c_kernel's typed parameters, with support for marshaling and synchronization with analysis state. Use cases include configuring plugin behavior, toggling analysis features via CLI flags, and tracking transient analysis states during code processing.",
      "description_length": 528,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a scoped, mutable map with typed key-value pairs (`K.t` keys, `V.t` values), offering operations for entry manipulation, alias definitions, serialization, and state change hooks. It supports command-line option semantics with default handling and visibility controls, while integrating with Frama-C's project system, and includes specialized modules for string-typed parameters and category-based configuration. Use cases involve structured state management with customizable serialization and hierarchical parameter organization.",
      "description_length": 550,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Share",
      "library": "frama-c-scope.core",
      "description": "This module manages paths within a plugin's `share` directory, providing functions to set and retrieve a base directory, check its existence, and resolve subdirectories or files within it. It operates on file paths represented by `Frama_c_kernel.Filepath.t`, ensuring correct resolution or aborting on invalid states. Concrete use cases include locating plugin-specific resources like configuration files or templates stored under the `share` directory.",
      "description_length": 453,
      "index": 560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Debug",
      "library": "frama-c-scope.core",
      "description": "This module provides scoped debugging utilities for integer parameters with bounded ranges, offering operations to increment values, enforce min/max constraints, and track modifications through hooks. It works with integer-based configuration types that support custom serialization, command-line parsing, and alias registration for dynamic project state management. Typical use cases include debugging scope analysis workflows, enforcing parameter validity during configuration, and exposing debug settings to end users via interactive interfaces.",
      "description_length": 548,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R",
      "library": "frama-c-scope.core",
      "description": "This module offers logging and diagnostic operations with configurable severity levels, category filters, and output channels, alongside utilities for managing typed configuration parameters (integers, strings, file paths, etc.) with validation, serialization, and scoped state tracking. It operates on structured log events, warning categories, formatter objects, and project-specific settings, supporting use cases like scoped analysis state management, command-line interface integration, and conditional debugging output based on verbosity levels. Key data structures include `warn_category`, `Filepath.t`, and typed parameter modules for integers, enums, and collections, enabling fine-grained control over analysis behavior and diagnostic reporting.",
      "description_length": 755,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Zones",
      "library": "frama-c-scope.core",
      "description": "Manages zones associated with statements in a function's control flow graph. It builds and retrieves mappings from statements to memory zones, tracking where variables are accessed or modified. Useful for analyzing variable lifetimes and memory usage patterns within specific code blocks.",
      "description_length": 288,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Defs",
      "library": "frama-c-scope.core",
      "description": "This module provides functions to analyze variable definitions within a function's scope, specifically retrieving statements that define a given lvalue before a specified point. It works with control flow statements, lvalues, and location zones, returning sets or maps of definition points with direct or indirect modification flags. Concrete use cases include determining where a variable is defined or modified before a specific statement, aiding in static analysis tasks like uninitialized variable detection or dataflow analysis.",
      "description_length": 533,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope",
      "library": "frama-c-scope.core",
      "description": "This module computes data and property scopes for statements in a function, determining sets of statements that influence or are influenced by a given lval or annotation. It works with kernel functions, statements, lvals, and code annotations, returning HPT sets and annotation lists to capture scope relationships. It is used to identify redundant assertions and enable their removal based on scope analysis.",
      "description_length": 409,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope",
      "library": "frama-c-scope.core",
      "description": "Performs scope analysis for variables and data in function control flow, identifying definition points, influence regions, and memory zones. Works with statements, lvalues, annotations, and control flow graphs to support tasks like detecting uninitialized variables, removing redundant assertions, and analyzing memory access patterns. Directly used for static analysis optimizations and code correctness checks based on scope relationships.",
      "description_length": 441,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Obfuscator",
      "library": "frama-c-obfuscator.core",
      "description": "This module implements an obfuscation plug-in that registers transformation functions dynamically through `Dynamic.register`. It operates on abstract syntax trees and string-based identifiers, applying renaming and control flow modifications to hinder reverse engineering. Concrete use cases include code protection in compiled binaries and tamper resistance in security-sensitive applications.",
      "description_length": 394,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From_gui.From_register_gui",
      "library": "frama-c-from.gui",
      "description": "Handles GUI interactions specific to the from analysis, extending the base GUI with event handlers and input validation for register-related operations. Works with GUI components like input fields, buttons, and event streams. Used to capture and validate user input for register definitions during analysis setup.",
      "description_length": 313,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From_gui",
      "library": "frama-c-from.gui",
      "description": "Extends the base GUI with event handlers and input validation for register-related operations. Works with input fields, buttons, and event streams to capture and validate user input for register definitions during analysis setup.",
      "description_length": 229,
      "index": 569,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Aorai",
      "library": "frama-c-aorai.core",
      "description": "This module implements an Aorai plugin that translates LTL formulas into ACSL assertions. It operates on logical formulas and program annotations, enabling runtime verification of temporal properties in C code. Use it to enforce complex behavioral contracts during program execution.",
      "description_length": 283,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map.Key",
      "library": "mthread",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with project-based values through membership testing and deep copying. Use cases include managing and comparing key values within a map that associates data with specific project contexts.",
      "description_length": 351,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map.Make",
      "library": "mthread",
      "description": "This module implements a map structure where keys are pointers and values are of the type provided by the `Data` module. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage collections of pointer-indexed data in a way that supports analysis and transformation within the Frama-C framework.",
      "description_length": 409,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl.Key",
      "library": "mthread",
      "description": "This module defines a key type for use in a thread memory pointer hashtbl, including standard operations like equality, comparison, hashing, and pretty printing. It supports data types that can be stored in a hashtbl, with functions tailored for handling project-specific values and deep copying to avoid shared references. Concrete use cases include managing and comparing keys representing memory pointers in a multi-threaded analysis context.",
      "description_length": 445,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl.Make",
      "library": "mthread",
      "description": "This module creates a hash table type specialized for a given data type, supporting operations like equality, comparison, hashing, and pretty-printing. It works with values of type `Data.t` and provides a deep copy function, a unique type descriptor, and project-aware membership checks. Concrete use cases include managing collections of typed values with structural equality and persistence across analysis projects.",
      "description_length": 418,
      "index": 574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for representing thread-skipping configurations as strings, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with standard string parameters and project-specific values, enabling precise handling of thread exclusion rules in command-line interfaces. Concrete use cases include parsing and validating thread identifiers for static analysis tools.",
      "description_length": 423,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl.Key",
      "library": "mthread",
      "description": "This module defines a key type for a hash table that represents nodes in a multithreaded control flow graph (CFG). It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. The keys are used to uniquely identify CFG nodes in a thread-aware analysis context, enabling efficient storage and retrieval in analyses built on the Frama-C platform.",
      "description_length": 447,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map.Key",
      "library": "mthread",
      "description": "This module defines operations for a key type used in maps representing multithreaded control flow graph nodes. It provides standard map key functionality such as equality, comparison, hashing, and pretty printing, specifically for CfgNode keys. These keys are used to uniquely identify and manipulate nodes within multithreaded CFG structures.",
      "description_length": 344,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Global.ZoneMap.LOffset",
      "library": "mthread",
      "description": "This module provides interval-based mapping operations that associate integer ranges with abstract values, supporting lattice-style joins, inclusion checks, and interval fusion. It works with data structures that track offset zones as contiguous intervals mapped to values, enabling efficient merging, querying, and transformation of range-bound data. These capabilities are particularly useful in static analysis for modeling memory layouts, propagating dataflow information across ranges, and optimizing interval-based abstract domains in program verification.",
      "description_length": 562,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype for handling string-based command-line collections with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks over project skeletons, ensuring values are treated as distinct entities. Concrete use cases include managing sets of strings as command-line arguments and validating project-specific values within analysis configurations.",
      "description_length": 423,
      "index": 579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for representing thread options as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports working with sets of threads as command-line parameters, specifically for the `-mt-only-threads` option. Use cases include parsing and validating thread identifiers, comparing thread configurations, and displaying thread sets in a human-readable format.",
      "description_length": 413,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Verbose.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It integrates with Frama-C's type and descriptor system, providing a named type representation, a list of representative values, and a packed descriptor for structural manipulation. The module supports deep copying, project membership checks, and is used to manage and query structured data within Frama-C's analysis framework.",
      "description_length": 444,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map",
      "library": "mthread",
      "description": "This module implements ordered associative maps with pointer keys and polymorphic values, supporting efficient insertion, deletion, and lookup operations alongside ordered traversal via iterators and folds. It provides specialized functions for key-based queries, bulk transformations, and structural manipulations while leveraging physical equality and ordered key properties for optimized performance. Designed for the Frama-C framework, it is particularly suited for static analysis tasks requiring precise pointer-value associations, ordered enumeration, and customizable serialization of memory state representations.",
      "description_length": 622,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for handling string-based command-line options related to interrupt behaviors, providing standard operations like equality, comparison, hashing, and pretty printing. It works with strings as atomic values, supporting their use in option parsing and project-specific checks. Concrete use cases include representing and manipulating interrupt handler configurations via command-line arguments.",
      "description_length": 423,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Debug.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides access to type descriptors, a list of representants, and utilities for project membership checks and deep copying. The type supports structural inspection and is used to manage and manipulate values with project-specific properties in a thread-debugging context.",
      "description_length": 391,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl",
      "library": "mthread",
      "description": "This module implements hash tables for pointer-based keys with operations including insertion, lookup, deletion, iteration, and in-place transformations, alongside thread-safe utilities for bulk updates, ordered traversal via custom comparisons, and safe key management. It operates on memory pointers within multi-threaded analysis contexts, enabling structural equality checks, deep copying, and project-specific value handling essential for static analysis tasks like memory modeling and concurrent data structure verification.",
      "description_length": 530,
      "index": 585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl.Make",
      "library": "mthread",
      "description": "This module implements a hash table specialized for multithreaded control flow graph nodes, where keys are nodes and values are determined by the parameter module `Data`. It provides standard operations like equality, comparison, hashing, and pretty printing, along with project-aware membership checks and deep copying, enabling precise analysis and transformation of multithreaded CFGs. Use cases include tracking thread-specific state or analyzing inter-thread dependencies in static analysis plugins.",
      "description_length": 504,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map.Make",
      "library": "mthread",
      "description": "This module implements a map keyed by multithread control flow graph nodes, with values parameterized by the `Data` module. It provides standard map operations\u2014lookup, insertion, iteration\u2014and supports equality, comparison, hashing, and pretty-printing for the map type. Concrete use cases include tracking analysis results per CFG node in static analysis plugins, such as value sets or abstract states in dataflow analysis.",
      "description_length": 424,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Set",
      "library": "mthread",
      "description": "This module offers ordered set operations for managing memory pointers, supporting element insertion, deletion, algebraic operations (union, intersection, difference), and ordered traversal. It works with sets of pointer values, enabling efficient membership checks, predicate-based filtering, and transformations while maintaining element ordering. Typical use cases include static analysis of memory accesses, concurrency verification, and program transformation tasks requiring precise tracking of pointer relationships.",
      "description_length": 523,
      "index": 588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating a collection of thread-related command-line options. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle the internal state and behavior of the `-mt-only-threads` option in Frama-C's analysis framework.",
      "description_length": 397,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Precise.ZoneMap",
      "library": "mthread",
      "description": "This module provides lattice operations (join, meet, top, bottom) and map manipulations for tracking memory zones with interval-based offsets, primarily used in static analysis of concurrent programs. It operates on a map structure (`ZoneMap.t`) that associates memory regions (represented by `Base.t` and offset ranges) with abstract values, enabling precise merging of intervals and combination of thread-local states. Key use cases include analyzing thread-shared variables, propagating memory state across concurrent contexts, and resolving conflicts during static analysis in Frama-C.",
      "description_length": 589,
      "index": 590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.KeepProjects.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for managing and inspecting project retention policies. It supports equality checks, comparison, hashing, and pretty printing, along with deep copying and membership testing via a predicate. The type represents structured data used to determine which analysis projects to retain, with functions that facilitate policy evaluation and manipulation in a multi-threaded analysis context.",
      "description_length": 431,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer",
      "library": "mthread",
      "description": "This module defines a pointer type with standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It provides fundamental capabilities for handling memory pointers in static analysis tasks, particularly in tracking and comparing pointer values across program states. The associated Set, Map, and Hashtbl submodules offer efficient data management structures tailored for pointer-based analysis in multi-threaded environments.",
      "description_length": 504,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.MutexPresence.KeySet",
      "library": "mthread",
      "description": "This module provides ordered set operations for managing collections of elements with a total ordering, supporting union, intersection, difference, and transformations like `map` and `filter`. It works with sets of elements ordered via a comparison function, enabling efficient membership checks, ordered iteration, and nearest-element queries. These operations are used in concurrency control scenarios to model access permissions and in static analysis for tracking structured data dependencies.",
      "description_length": 497,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.Category",
      "library": "mthread",
      "description": "This module manages categories for the `-mt-only-threads` command-line option, providing operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to the `Frama_c_kernel.State.t` list and `Parameter_category` structures. Concrete use cases include setting default category behavior, enabling all categories with specific interpretations, and defining dependencies for thread-related command-line parameters.",
      "description_length": 494,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map",
      "library": "mthread",
      "description": "This module manages associative mappings between multithreaded control flow graph (CFG) nodes and arbitrary values, emphasizing ordered key handling and structural preservation. It supports functional transformations (mapping, filtering, folding), ordered traversal (ascending/descending iteration, min/max bindings), and structural operations (union, split, partition) optimized for CFG node keys. Its features cater to static analysis tasks like dataflow computation, where CFG node relationships require precise aggregation, incremental updates, and ordered enumeration for algorithmic correctness.",
      "description_length": 601,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Debug",
      "library": "mthread",
      "description": "This module provides operations for managing integer parameters with dynamic update hooks, bounded value ranges, and project-specific state tracking. It works with integer-based data structures that support marshaling customization, value change notifications, and alias definitions. These features are particularly useful in thread-debugging scenarios where monitoring and constraining integer values (e.g., thread identifiers, debug levels) is critical for maintaining system integrity.",
      "description_length": 488,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Share",
      "library": "mthread",
      "description": "This module manages paths related to a shared directory for a plugin, providing functions to set, retrieve, and check the directory location. It works with `Frama_c_kernel.Filepath.t` to represent file and directory paths, ensuring correct types for system operations. Concrete use cases include locating specific files or subdirectories within the plugin's shared directory, such as configuration or resource files.",
      "description_length": 416,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.DumpSharedVarsValues.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values related to the -mt-shared-values option in a static analysis context. It supports functionalities such as equality checking, comparison, hashing, pretty printing, and deep copying, along with project membership testing. The data type is primarily used to manage and persist analysis configurations and results tied to specific projects.",
      "description_length": 437,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.FullCfg.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating configuration options related to the `-mt-full-cfg` behavior. It supports structured values with descriptors, packed representations, and deep copying, enabling precise handling of configuration states. Use cases include managing and comparing analysis configurations, persisting settings, and inspecting or transforming configuration data during static analysis.",
      "description_length": 523,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating a collection of thread-skipping specifications. It supports standard operations like comparison, hashing, and pretty-printing, along with deep copying and membership checking against project skeletons. The type is used to handle command-line parameters that specify which threads to skip during analysis.",
      "description_length": 386,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.Category",
      "library": "mthread",
      "description": "This module defines and manages categories for the `-mt-skip-threads` command-line option, using string names and associated states. It provides operations to create, modify, and query named categories such as `@none`, `@default`, and `@all`, each tied to a list of states and an accessor. These categories control how thread skipping is interpreted during analysis, allowing precise configuration through command-line parameters.",
      "description_length": 430,
      "index": 601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Set",
      "library": "mthread",
      "description": "This module offers ordered, immutable set operations for managing collections of multithreaded control-flow graph nodes, supporting union, intersection, difference, and element queries like finding min/max or nearest elements. It provides transformations, ordered iteration, and conversions to/from lists and sequences, leveraging a custom comparison function to maintain structure. These capabilities are particularly useful for analyses requiring precise traversal order, merging thread-specific node sets, or tracking hierarchical relationships in CFGs.",
      "description_length": 556,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.AccessesByZoneNode.LOffset",
      "library": "mthread",
      "description": "This module provides lattice-based operations for manipulating interval-bound data structures, focusing on offset intervals and their mappings to values. It supports abstract interpretation tasks like merging intervals (`join`), inclusion checks (`is_included`), and value lookups (`find`) over integer ranges, with applications in static analysis for tracking memory offset validity and program state properties using interval arithmetic and caching optimizations.",
      "description_length": 465,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Config_dir",
      "library": "mthread",
      "description": "This module manages the creation, retrieval, and configuration of plugin-specific directories and files within a Frama-C environment. It operates on file paths using the `Frama_c_kernel.Filepath.t` type, allowing optional directory creation when accessing files or directories. Concrete use cases include setting up persistent storage for plugin data, ensuring necessary directories exist before writing logs or configuration files, and retrieving predefined paths for analysis results.",
      "description_length": 486,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.WriteWriteRaces.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type for representing and manipulating values related to the `-mt-write-races` option in a thread analysis context. It includes standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. The type is used to model and analyze potential write-write race conditions in concurrent programs.",
      "description_length": 400,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values related to the `-mt-extract` command line option. It supports working with project-based data through the `mem_project` function, which checks for the presence of a project satisfying a predicate, and provides deep copying to avoid shared state. Concrete use cases include managing and querying extracted model representations during static analysis configuration.",
      "description_length": 521,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowTime.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing values related to time tracking in a multi-threaded analysis. It supports deep copying and membership checks for project-specific data, ensuring values can be uniquely identified and manipulated independently. Concrete uses include managing and comparing time-based analysis states across different threads.",
      "description_length": 409,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.As_string",
      "library": "mthread",
      "description": "This module provides utilities for defining and enforcing string-based command-line parameters with validation constraints, alias handling, and dynamic value transformation. It operates on string values and lists of allowed options, supporting use cases like parsing project-specific configurations, validating user input against predefined sets, and managing stateful parameter changes with callback hooks. The design emphasizes safe marshaling between string representations and internal data structures while maintaining compatibility with global parameter state tracking.",
      "description_length": 575,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.StopAfter.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type for representing stopping conditions based on analysis depth in the `-mt-stop-after` option. It includes standard operations like comparison, equality, hashing, and pretty-printing, along with functions for project membership checks and deep copying. The type is used to manage and evaluate when a specific stopping criterion should terminate the analysis, particularly in relation to project-specific conditions.",
      "description_length": 454,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDiskPrefix.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values tied to the `-mt-projects-on-disk-prefix` option. It includes standard comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over project skeletons. The type supports serialization via a packed descriptor and is used to manage project prefix configurations during analysis.",
      "description_length": 407,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.As_string",
      "library": "mthread",
      "description": "This module manages string-based command-line configurations for thread exclusion rules, offering operations to define allowed values, validate inputs as either function names or raw strings, and handle value constraints. It operates on global parameter state with string collections representing thread-skipping criteria, supporting use cases like specifying function-derived thread identifiers or static thread name patterns in a static analysis tool's CLI.",
      "description_length": 459,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepWhiteNodes.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to the `-mt-non-shared-accesses` option in a static analysis context. It includes standard operations like equality, comparison, hashing, and pretty-printing, as well as functions for checking project membership and deep copying. The type is used to model analysis configurations where non-shared memory accesses are tracked or controlled.",
      "description_length": 436,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.PrintCallstacks.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to callstack printing behavior. It supports equality, comparison, hashing, pretty-printing, deep copying, and project membership checks. The type is used to configure or query callstack display settings, particularly in the context of Frama-C's analysis options.",
      "description_length": 359,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.State_dir",
      "library": "mthread",
      "description": "This module manages file paths for a plugin's state directory, providing functions to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, handling path resolution and existence checks. Use it to store or access plugin-specific state files in a structured directory hierarchy.",
      "description_length": 347,
      "index": 614,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Verbose",
      "library": "mthread",
      "description": "This module provides operations to manage an integer-valued parameter with constraint enforcement, supporting range validation, incremental adjustments, and lifecycle hooks for state changes. It works with integer values bounded by min-max constraints and integrates with Frama-C's state management and datatype system for structured configuration tracking. These capabilities are used to handle command-line options, serialize project-specific settings, and maintain consistent state across analysis sessions in the MThread plugin.",
      "description_length": 532,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.Category",
      "library": "mthread",
      "description": "This module manages categories for a collection of elements, where each category is associated with an accessor and a list of dependencies. It provides operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`, and control their behavior in command-line interpretations. Use cases include configuring how model elements are grouped and selected through command-line options.",
      "description_length": 416,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ModerateWarnings.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks via `mem_project` and deep copying with `copy`. Use cases include managing and comparing moderate warning configurations in static analysis, where precise data representation and project membership checks are required.",
      "description_length": 432,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl",
      "library": "mthread",
      "description": "This module implements hash tables that map multithreaded control flow graph nodes to arbitrary data, supporting creation, insertion, lookup, and both imperative and functional transformations like folding and iteration. It enables ordered traversal based on keys or values, memoization strategies, and structural analysis of thread-aware CFGs. Such tables are particularly useful for tracking data flow across thread boundaries, aggregating analysis metadata, and integrating with static analysis frameworks requiring precise node-value associations.",
      "description_length": 551,
      "index": 618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.PopTopFunctionForCallbacks.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the context of the `-mt-inline-callbacks` option. It supports structured representation and manipulation of values, including deep copying and membership testing within projects. Use cases include managing and analyzing callback-related data structures during static analysis with Frama-C.",
      "description_length": 426,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.SetStmtIdAccess.O",
      "library": "mthread",
      "description": "This module supports a functional set abstraction for managing collections of statement identifiers tied to shared variable accesses in concurrent program analysis. It provides standard set operations like union, intersection, and filtering alongside utilities for element selection, equality checks, and project-specific membership verification, all operating on immutable data structures. Designed for static analysis in Frama-C's Mthread plugin, it helps track and reason about shared variable access patterns across program statements to ensure algorithmic convergence and concurrency correctness.",
      "description_length": 601,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ConcatDotFilesTo.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type and operations for handling values associated with the `-mt-concat-dot-files-to` option in Frama-C's Mthread plugin. It includes standard comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. The type is used to represent and manipulate configuration values that determine how dot files are concatenated during analysis.",
      "description_length": 414,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.Enabled.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use with the `-mthread` option's enabled state. It supports structured data representation with a descriptor, packed type information, and a list of representative values. The type is designed for deep copying and project membership checks, enabling precise manipulation and analysis of thread-related configurations in Frama-C's kernel.",
      "description_length": 463,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.ThreadPresence.KeySet",
      "library": "mthread",
      "description": "This module offers ordered set operations for managing immutable collections of thread presence keys, supporting insertion, deletion, union, intersection, difference, and membership checks, along with ordered traversal, filtering, and transformations. It works with sorted sets of elements where comparisons and hashing are defined, enabling efficient lookups and nearest-element queries. Typical applications include tracking valid thread states in concurrent systems, analyzing access patterns to shared resources, or validating constraints during static analysis of multi-threaded code.",
      "description_length": 589,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.As_string",
      "library": "mthread",
      "description": "This module provides utilities for handling command-line options that accept string-based thread set specifications, enabling operations like validation against allowed values, function name checks, and conversion between string representations and internal data structures. It works with global parameter states and string collections, supporting use cases such as restricting input to predefined thread identifiers, distinguishing between function names and raw strings, and persisting or transmitting configuration values through marshaling.",
      "description_length": 544,
      "index": 624,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByZone.LOffset",
      "library": "mthread",
      "description": "This module provides operations for managing interval-based mappings of mutexes to memory zones, supporting lattice-aware manipulation and analysis of abstract values. It works with interval-keyed data structures that associate integer ranges with mutex states, enabling efficient queries, joins, and validity checks. These capabilities are specifically used in static analysis to model concurrent memory access constraints, merge overlapping intervals during abstract interpretation, and optimize performance through caching and constraint propagation.",
      "description_length": 553,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.SetNodeIdAccess.O",
      "library": "mthread",
      "description": "This module provides structured set operations for managing collections of node identifiers, supporting creation, modification, algebraic operations (union, intersection, difference), and traversal. It works with immutable sets of `NodeId` values, offering utilities for filtering, cardinality checks, and project-specific membership validation, along with serialization and pretty-printing capabilities. It is particularly useful in scenarios requiring persistent, thread-safe manipulation of node relationships, such as dependency analysis, configuration management, or static analysis tools where safe deep copying and context-aware set comparisons are critical.",
      "description_length": 665,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDisk.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values in the context of disk-based project handling. It supports standard operations including equality, comparison, hashing, and pretty printing, as well as deep copying and membership checking over project skeletons. It is used to manage and persist project data structures to disk, ensuring correct serialization and deserialization behavior.",
      "description_length": 440,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Session",
      "library": "mthread",
      "description": "This module manages a session directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of session-specific storage. Use cases include persisting plugin state, caching analysis results, or storing user-specific configuration files during static analysis sessions.",
      "description_length": 417,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for managing and comparing values used in command-line option handling. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. The type is used to represent and manipulate command-line parameters related to interrupt handling behavior.",
      "description_length": 372,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.IgnoreNull.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to handle the `IgnoreNull` option in the context of Frama-C's analysis projects. It supports deep copying and membership checks for project-specific values, ensuring values are properly compared and formatted. The type is used to represent and manipulate configuration states during static analysis where null pointer checks are ignored.",
      "description_length": 459,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.As_string",
      "library": "mthread",
      "description": "This module manages string-based configurations for interrupt behaviors, offering operations to validate values against allowed options or C-style function names, register dynamic state hooks, and handle command-line parameter parsing. It operates on string parameters representing interrupt handler settings, using lists for value enumeration and validation rules to enforce format constraints. Typical use cases include parsing project-specific interrupt configurations from command-line arguments, tracking runtime state changes, and ensuring safe marshaling of function name references in distributed systems.",
      "description_length": 613,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.Category",
      "library": "mthread",
      "description": "This module manages categories for command-line interrupt handling options, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to `Frama_c_kernel.State.t` lists and accessors, supporting structured configuration of interrupt behaviors. Concrete use cases include setting default interrupt handling strategies, enabling all interrupts with specific interpretations, or defining custom category behaviors for option parsing.",
      "description_length": 516,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowReturnEdges.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to the behavior of the `-mt-return-edges` option. It supports equality, comparison, hashing, pretty-printing, deep copying, and project membership checks, making it suitable for use in analysis configurations and value tracking. The type is used to define and handle specific return edge behaviors in the Mthread plugin's analysis of C programs.",
      "description_length": 442,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Cache_dir",
      "library": "mthread",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and allows setting and querying the cache directory location. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured way.",
      "description_length": 369,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.CheckProtections.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain embedded project data, enabling checks on project membership via predicates. The type is used to represent and manipulate values tied to Frama-C's project system, with deep copying ensuring isolation between instances.",
      "description_length": 384,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepGreenNodes.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for values that may contain embedded project data. It supports checking membership of projects within values and provides deep copying to ensure no shared references. Concrete use cases include managing and manipulating structured analysis data in a thread-safe manner, where project-specific information must be preserved or compared accurately.",
      "description_length": 472,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.AccessesByZone.LOffset",
      "library": "mthread",
      "description": "This module provides lattice operations (join, is_included), interval management (binding, merging), and map transformations for analyzing memory access patterns where values of type `v` are associated with integer intervals. It operates on a custom access type `t` representing structured offset mappings, enabling efficient querying and merging of interval-based dataflow information. The functionality supports static analysis tasks like thread-local memory access tracking and abstract interpretation of variable access ranges.",
      "description_length": 531,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.LatticeMutexes",
      "library": "mthread",
      "description": "This module defines a lattice structure for mutexes, providing operations such as join, inclusion checks, and equality comparisons over mutex states. It works with the `mutexes_by_access` type, representing sets of mutexes with access information in a lattice context. Concrete use cases include static analysis of concurrent programs to track and merge mutex usage across different execution paths.",
      "description_length": 399,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowTime",
      "library": "mthread",
      "description": "This module provides operations to manage a boolean flag controlling time display in multi-threaded analysis output. It works with a boolean option state, supporting toggling, tracking, and serialization. Use cases include enabling or disabling time reporting through the `-mt-time` flag to configure output verbosity in performance analysis scenarios.",
      "description_length": 352,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers",
      "library": "mthread",
      "description": "This module manages command-line configurations for interrupt handling behavior through a set-like collection of kernel functions, supporting operations like membership checks, iteration, and state serialization. It works with string-based parameter representations and categorized option groups to control interrupt policies, enabling use cases such as dynamic adjustment of interrupt handling via runtime hooks or project-specific default value tracking. The design facilitates parsing, comparison, and persistence of interrupt-related settings in the Frama-C kernel.",
      "description_length": 569,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.SetNodeIdAccess",
      "library": "mthread",
      "description": "This module provides set-theoretic operations (union, intersection, inclusion checks) and functional manipulations (filtering, folding, projection) on a private type representing either concrete node ID sets or a symbolic \"top\" element denoting all possible IDs. It works with multithreaded control flow graphs (CFGs) to model node ID access patterns, supporting static analysis tasks like concurrency verification through algebraic combinations (`meet` for intersection approximation) and transformations (`inject_singleton`, `apply1`). The type's design enables abstract interpretation by handling both explicit sets and unbounded representations, with utilities for validation and structured traversal.",
      "description_length": 705,
      "index": 641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cil.StackElt",
      "library": "mthread",
      "description": "This module defines operations for manipulating stack elements in a static analysis context, including equality, comparison, hashing, and pretty-printing. It works with a specific type `t` representing stack elements, which are used to model program states during analysis. The module supports deep copying, membership checks for project-related data, and provides structured representations for serialization and comparison.",
      "description_length": 425,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByZone",
      "library": "mthread",
      "description": "This module provides lattice-based abstract interpretation capabilities to analyze mutexes in relation to memory zones represented as intervals, supporting operations like join, inclusion checks, and framework integration for static analysis. It employs interval maps and customizable combinators to manage bindings between memory regions and mutex states, enabling efficient merging of contiguous ranges and structural queries. These features facilitate concurrent program verification in Frama-C, particularly for detecting race conditions and ensuring thread-safe memory access through precise tracking of protected zones.",
      "description_length": 625,
      "index": 643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ModerateWarnings",
      "library": "mthread",
      "description": "This module provides operations to manage a boolean configuration flag that controls moderate warning behavior, offering capabilities to set or disable the flag, define state update hooks, and register command-line aliases. It operates on a structured datatype encapsulating boolean values with support for comparison, hashing, and project-specific state synchronization, alongside a shared boolean state for direct manipulation. These features enable use cases such as fine-grained warning control during static analysis, integration with Frama-C's analysis pipelines, and customizable configuration persistence through marshaling.",
      "description_length": 632,
      "index": 644,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.AccessesByZone",
      "library": "mthread",
      "description": "This module provides operations to manage and analyze mappings from memory zones to variable access intervals, using lattice semantics to support static analysis of concurrent programs. It works with structured maps that associate zones to access ranges, enabling precise tracking of shared variable usage across threads. Key use cases include detecting race conditions and validating thread-locality through operations like joining access patterns, filtering bindings, and inspecting interval overlaps.",
      "description_length": 503,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.NodeValueState",
      "library": "mthread",
      "description": "This module defines a type `t` representing the possible states of a node's value in a concurrent program analysis. It includes functions to determine the presence status of threads and mutexes within a given program state. These operations are used to track whether threads or mutexes are active, started, or not present during analysis.",
      "description_length": 338,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.RecomputeReason",
      "library": "mthread",
      "description": "This module defines a type `t` representing reasons for recomputation in a multi-threaded analysis context. It includes a comparison function for ordering recomputation reasons and a pretty-printing function for displaying them. These are used to track and diagnose why specific analyses are re-executed in a concurrent setting.",
      "description_length": 328,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByAccess",
      "library": "mthread",
      "description": "This module represents mutexes categorized by access patterns using a specific data structure. It provides operations to compare, hash, and pretty-print these mutex representations, along with a value representing unaccessed mutexes. It is used in static analysis to track and reason about thread synchronization behavior.",
      "description_length": 322,
      "index": 648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Global",
      "library": "mthread",
      "description": "This module tracks and analyzes concurrent memory accesses across threads using lattice-based abstractions over memory zones. It provides functions to collect accessed zones, identify concurrent accesses, and pretty-print access information. Concrete use cases include detecting race conditions and analyzing shared memory interactions in concurrent C programs.",
      "description_length": 361,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cil.Stack",
      "library": "mthread",
      "description": "This module implements a stack data structure with operations for equality checking, comparison, hashing, deep copying, and pretty-printing. It works with stack elements representing CIL statements, particularly tracking accesses to shared variables in a multithreaded context. Concrete use cases include analyzing memory accesses in C programs and managing call stacks during static analysis of concurrent code.",
      "description_length": 412,
      "index": 650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.CheckProtections",
      "library": "mthread",
      "description": "This module provides operations to manage a boolean configuration flag that controls synchronization behavior for shared memory accesses, including enabling, disabling, and monitoring state changes. It operates on a state-aware boolean type, supporting dynamic value updates, serialization, and integration with project-wide state management systems. Specific use cases include enforcing thread safety during runtime by toggling synchronization policies or persisting configuration changes across sessions.",
      "description_length": 506,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.Context",
      "library": "mthread",
      "description": "This module defines a context type used to represent and manipulate contextual information in a multithreaded control flow graph. It includes operations to create an empty context and format it for debugging or logging. The context is used to track thread-specific state during analysis of concurrent programs.",
      "description_length": 310,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.MutexPresence",
      "library": "mthread",
      "description": "This module manages sets of keys associated with presence flags, supporting operations like insertion, lookup, and union. It works with keys and presence flags to track which elements are present in a given context. Used in concurrency control to manage access permissions and in static analysis to track dependencies.",
      "description_length": 318,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepGreenNodes",
      "library": "mthread",
      "description": "This component provides operations to manage a boolean flag that governs non-concurrent memory access behavior in multi-threaded analysis, including functions to toggle its state, register change hooks, define aliases, and customize value marshaling. It operates on boolean flags and thread-safe, project-scoped state structures through the `Datatype` module, enabling precise control over concurrency-related memory access rules. Use cases include configuring analysis sensitivity to non-concurrent accesses and integrating dynamic behavior adjustments via callback hooks.",
      "description_length": 573,
      "index": 654,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_thread.Priority",
      "library": "mthread",
      "description": "This module defines operations for handling thread priority values, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing thread priorities, supporting deep copying and membership checks for project-specific data. Concrete use cases include managing and comparing thread priority levels within a formal verification toolchain.",
      "description_length": 383,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepProjects",
      "library": "mthread",
      "description": "This module manages string-based options for project retention policies in multi-threaded analyses, providing functions to set, validate, and observe values (e.g., \"all\", \"last\", \"none\"), along with state tracking and kernel system integration. It operates on string and list data structures to enforce input validation, handle default values, and support",
      "description_length": 355,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.StmtIdAccess",
      "library": "mthread",
      "description": "This module defines a type for representing full variable access operations, including whether the access is a read or write, the statement where it occurs, and the thread performing the operation. It provides standard comparison, hashing, and pretty-printing functions, along with utilities for deep copying and checking project membership. It is used to track and analyze variable accesses in a multi-threaded context during static analysis.",
      "description_length": 443,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgConcur",
      "library": "mthread",
      "description": "This module defines operations for managing concurrent access information in a control-flow graph. It provides functions to combine access data, add read/write accesses to memory zones, and check for the presence of concurrent or specific types of accesses. The module works with a structured type representing concurrency configurations, used to track and analyze memory accesses in a multi-threaded context.",
      "description_length": 409,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread",
      "library": "mthread",
      "description": "This module offers logging, debugging, and warning management capabilities tailored for multi-threaded environments, with operations to control verbosity, format messages, and filter output based on debug levels, source positions, or terminal contexts. It works with structured types like `warn_category`, `Filepath.t`, and constrained integer parameters, enabling use cases such as plugin configuration, session-specific logging, and command-line option handling in Frama-C. Key functionalities include conditional logging, category registration, and customizable output backends, supporting extensible diagnostics and state management across shared or session-scoped contexts.",
      "description_length": 678,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepWhiteNodes",
      "library": "mthread",
      "description": "This module manages a shared boolean state that governs how static analyzers handle non-shared memory accesses in multi-threaded code. It provides toggling operations (`on`/`off`), change tracking via hooks, and serialization mechanisms, enabling dynamic configuration and project-scoped persistence for analysis workflows. The flag directly influences thread-local data access modeling in static analysis frameworks.",
      "description_length": 417,
      "index": 660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ToDiskPrefix",
      "library": "mthread",
      "description": "This module provides operations to configure and track a disk path prefix for multi-threaded project handling, supporting value setting/retrieval, change hooks, alias resolution, and custom serialization. It works with strings for path prefixes and string lists for allowed value validation, enabling use cases like restricting project paths to specific directories during static analysis or dynamically adjusting paths in multi-threaded environments.",
      "description_length": 451,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDisk",
      "library": "mthread",
      "description": "This component manages a boolean option that determines whether Frama-C projects are stored on disk, supporting configurations like `-mt-projects-on-disk`. It offers functions to enable or disable the flag, track state changes via hooks, and customize serialization. This is particularly useful in multi-threaded scenarios where disk-based storage optimizes memory usage by offloading project data.",
      "description_length": 398,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_outputs.Html",
      "library": "mthread",
      "description": "Generates HTML reports from thread analysis data. It converts analysis results into structured HTML output for visualization. Useful for rendering thread execution traces and state information in a web browser.",
      "description_length": 210,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.IgnoreNull",
      "library": "mthread",
      "description": "This module manages a boolean state that determines whether null values are excluded from analysis in Frama-C's static analysis framework. It provides mechanisms to set, query, and observe changes to this state, with support for command-line configuration and project-specific persistence. The functionality is used to adjust analysis precision when handling memory operations in concurrent contexts, where ignoring null values may simplify or refine results.",
      "description_length": 459,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_outputs.Eva_results",
      "library": "mthread",
      "description": "Handles the display of analysis results by printing or visualizing the evaluated values from the analysis state. Works directly with the `analysis_state` type to output results in a human-readable format. Useful for debugging and presenting the outcome of value analysis in a thread-based analysis project.",
      "description_length": 306,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.OrderedThreads",
      "library": "mthread",
      "description": "This module analyzes thread creation relationships and provides operations to traverse threads based on their creation order. It builds a family tree and creation map to represent parent-child thread dependencies and enables folding or iterating over threads in a partial order that respects thread creation hierarchy. It is used to process multithreaded programs in an order that ensures parent threads are processed before their children, enabling analyses that depend on thread creation lineage.",
      "description_length": 498,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.Event",
      "library": "mthread",
      "description": "Handles event comparison, hashing, and pretty-printing for thread analysis in static code verification. Works with event types representing thread interactions and synchronization points. Used to track and display concurrency-related behavior during program analysis.",
      "description_length": 267,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Precise",
      "library": "mthread",
      "description": "This module manages precise tracking of memory zones and their accesses across threads using interval-based offsets. It provides operations to merge and analyze shared variable states, identify concurrent accesses, and display or filter memory values based on thread interactions. Key functions include computing all accessed zones, joining shared values, and marking or removing memory regions in control flow graphs based on concurrency analysis.",
      "description_length": 448,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_types.Trace",
      "library": "mthread",
      "description": "This module represents execution traces as mappings from program stacks to events and memory states. It supports operations to add events or memory states at specific stack points, query traces at statements or function calls, and combine or filter traces based on events. Use cases include analyzing program executions by tracking events and memory changes at different control points during static analysis.",
      "description_length": 409,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.EventsSet",
      "library": "mthread",
      "description": "This module provides standard set operations (union, intersection, difference) for immutable collections of events, with functions for membership testing, iteration, and transformation. It supports conversions to sequences and lists, along with extracting thread information from events, enabling use cases like tracking event occurrences and analyzing thread interactions in concurrent programs.",
      "description_length": 396,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ConcatDotFilesTo",
      "library": "mthread",
      "description": "This module provides configuration operations for directing dot file output during static analysis, including setting and retrieving file paths, managing change hooks, and handling serialization. It primarily works with file path strings and boolean state checks to control concatenation behavior. Specific use cases involve aggregating intermediate dot files into a target location for visualization or further processing in analysis workflows.",
      "description_length": 445,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.PrintCallstacks",
      "library": "mthread",
      "description": "This component manages a boolean option to control callstack printing behavior, offering functions to set, retrieve, and monitor its state, along with hooks for dynamic adjustments and custom serialization. It operates on an internal boolean flag, enabling or disabling callstack display during analysis, particularly useful for debugging concurrency-related issues or tracking execution paths in complex programs.",
      "description_length": 414,
      "index": 672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels",
      "library": "mthread",
      "description": "This module provides operations for handling command-line parameters that involve sets of strings, including value management, change tracking, and alias resolution. It works with a string set type (`Set.t`) and a state type (`State.t`) for project-specific persistence, serialization, and comparison. It is particularly useful in command-line interfaces requiring structured configuration, such as static analysis tools that track project state or validate parameters against predefined categories.",
      "description_length": 499,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.ThreadState",
      "library": "mthread",
      "description": "This module provides operations to inspect and compare thread state objects, including checking if a thread is the main thread, retrieving its name, and determining creation relationships between threads. It works with the `thread_state` type, representing internal states of threads in a concurrent analysis. Concrete use cases include tracking thread creation hierarchies and formatting thread names for debugging or detailed output in static analysis tools.",
      "description_length": 460,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads",
      "library": "mthread",
      "description": "This module provides operations to manage a string-based set of thread identifiers for filtering concurrent analysis, supporting operations like membership checks, iteration, and state modification. It works with collections of thread names represented as sets and strings, integrating command-line configuration with runtime validation and persistent project settings. Specific use cases include restricting analysis to specified threads, dynamically updating thread selections, and ensuring configuration consistency across Frama-C's kernel and project management systems.",
      "description_length": 574,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.Enabled",
      "library": "mthread",
      "description": "This module provides operations to manage a boolean state controlling thread-related behavior, including setting, querying, and toggling the state, as well as registering change hooks and handling value serialization. It operates on a boolean type (`t`) with dedicated functions to activate (`on`) or deactivate (`off`) the associated feature. The state is used to enable or disable threading capabilities in Frama-C's analysis, such as parallel execution or thread-aware checks.",
      "description_length": 479,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode",
      "library": "mthread",
      "description": "The module provides operations for managing control flow graph nodes in multithreaded environments, including equality checks, comparison, hashing, and deep copying, along with integration into sets, maps, and hash tables. It supports traversal and analysis through functions that inspect node properties like successors, concurrent variable accesses, and inclusion criteria, featuring custom traversal with path tracking and pre/post-processing actions. These utilities are used in static analysis to handle dynamic node generation, track execution paths, and analyze concurrency-related behaviors in multithreaded programs.",
      "description_length": 625,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads",
      "library": "mthread",
      "description": "This module manages a command-line option that specifies thread identifiers to skip during analysis, offering operations to set, retrieve, and modify a string set of excluded threads while tracking configuration changes. It works with string-based collections organized into categories, enabling membership checks, iteration, and validation of exclusion rules. The functionality is used in a static analysis tool's CLI to control thread skipping behavior through customizable, validated parameters with support for aliases and default values.",
      "description_length": 542,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.StopAfter",
      "library": "mthread",
      "description": "This module provides operations for managing an integer-based stopping condition in multi-threaded analysis, including setting and retrieving values, registering update hooks, and handling aliases and marshaling. It works with a bounded integer parameter that enforces valid ranges, typically used to control termination depth during threaded execution.",
      "description_length": 353,
      "index": 679,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_types.ThreadPresence",
      "library": "mthread",
      "description": "This module represents thread presence information using a key-value structure where each thread key maps to a presence flag indicating its active or inactive status. It supports operations to query, add, or combine presence states, and extract sets of present threads. Concrete use cases include tracking which threads are currently executing in a system, merging presence states from different scopes, or filtering threads that are actively present during analysis of concurrent programs.",
      "description_length": 490,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.NodeIdAccess",
      "library": "mthread",
      "description": "This module defines operations for handling node identifiers in a multithreaded control flow graph, including equality, comparison, hashing, and pretty-printing. It works with tuples combining read/write markers, nodes, and threads to represent access points in the graph. These functions support precise analysis and transformation of concurrent programs by enabling accurate tracking and manipulation of node access information.",
      "description_length": 430,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.AccessesByZoneNode",
      "library": "mthread",
      "description": "This module provides lattice operations for analyzing sets of memory access states and map manipulations for tracking zone-to-access bindings, primarily used in static analysis of C programs. It works with structured data combining memory zones (`Zone.t`), node IDs, and access metadata, supporting semantic equivalence checks, interval merging, and lattice-aware transformations. Key applications include abstract interpretation tasks like merging access paths, handling top/bottom elements during analysis, and maintaining precise memory access summaries across program points.",
      "description_length": 579,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types",
      "library": "mthread",
      "description": "This module defines core data types for representing memory states, values, and pointers in static analysis of C programs. It includes operations for managing function-specific memory states, iterating over analysis requests, and merging state mappings in multi-threaded contexts. Key use cases involve tracking pointer values across program points, managing per-function memory models, and supporting interprocedural analysis through state access and combination functions.",
      "description_length": 474,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.DumpSharedVarsValues",
      "library": "mthread",
      "description": "This module manages an integer configuration parameter that governs static analysis behavior, providing operations to set and retrieve its value, define valid ranges, and register hooks for change monitoring. It works with integer values and range constraints, incorporating support for aliased parameters, state persistence across projects, and dynamic value adjustments through increment operations. The functionality is particularly useful in analysis tools requiring fine-grained control over shared variable value tracking levels during program analysis.",
      "description_length": 559,
      "index": 684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ShowReturnEdges",
      "library": "mthread",
      "description": "This module provides functions to manage a boolean option that controls the display of return edges in control flow analysis. It operates on a boolean state with support for persistent settings, aliases, and integration with Frama-C's project system. The option is used to toggle return edge visibility when analyzing multi-threaded program paths, enabling users to refine control flow visualization or focus on specific execution scenarios.",
      "description_length": 441,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.RW",
      "library": "mthread",
      "description": "This module defines operations for handling read and write access types in a multi-threaded analysis context. It provides functions to compare, hash, and pretty-print access type values, along with checking if an operation is a read and retrieving its source location. Concrete use cases include tracking memory accesses during static analysis and distinguishing between read and write operations in concurrency models.",
      "description_length": 419,
      "index": 686,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.WriteWriteRaces",
      "library": "mthread",
      "description": "This module provides operations to toggle, query, and customize a boolean flag controlling write-write race detection in thread analysis. It manipulates a boolean value within a structured datatype, enabling use cases like dynamic analysis configuration and integration with serialization systems. The flag directly influences race condition detection behavior during concurrent execution analysis.",
      "description_length": 398,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_ids",
      "library": "mthread",
      "description": "This module associates thread, mutex, and message queue identifiers with integer values in a state, enabling precise tracking and manipulation of their states. It supports reading, writing, and replacing integer values linked to these identifiers, as well as pretty-printing and enumerating possible values. Concrete use cases include modeling concurrency primitives in static analysis and managing state transitions for multi-threaded program verification.",
      "description_length": 457,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_main",
      "library": "mthread",
      "description": "Registers and applies hooks that execute at the end of thread analysis, allowing custom actions based on the analysis state. Works with thread analysis data structures to enable post-processing tasks. Useful for integrating analysis results with external systems or logging.",
      "description_length": 274,
      "index": 689,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types",
      "library": "mthread",
      "description": "This module implements data structures and operations for tracking variable accesses in concurrent programs. It defines types for representing memory zones, statement-identified accesses, and sets of these accesses, along with mappings from zones to access intervals. These structures support static analysis tasks such as race detection and thread-locality verification through operations like joining access patterns, filtering, and interval overlap checks.",
      "description_length": 459,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars",
      "library": "mthread",
      "description": "This module tracks concurrent memory accesses across threads using lattice-based abstractions over memory zones. It provides functions to collect accessed zones, identify concurrent accesses, and pretty-print access information. Concrete use cases include detecting race conditions and analyzing shared memory interactions in concurrent C programs.",
      "description_length": 348,
      "index": 691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options",
      "library": "mthread",
      "description": "This module offers logging, diagnostic control, and configuration management for multi-threaded static analysis, supporting operations like severity-based message logging, warning category registration, and dynamic adjustment of analysis flags. It interacts with structured types such as `warn_category`, `Filepath.position`, boolean/int flags, and string sets, while enabling use cases like thread filtering, race detection, project state persistence, and command-line-driven analysis customization in Frama-C's kernel and project systems.",
      "description_length": 540,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory",
      "library": "mthread",
      "description": "This module offers operations for merging memory states, handling pointer arithmetic, and converting between abstract and concrete representations in multi-threaded static analysis. It works with memory slices, integers, C strings, and Frama-C-specific variables to support tasks like extracting constant values, reading/writing memory at specific addresses, and formatting debug output. Key use cases include symbolic execution, value propagation, and visualization of memory states during program analysis.",
      "description_length": 508,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cil",
      "library": "mthread",
      "description": "This module provides functions for identifying global variables, detecting synchronization calls, and printing control flow information in CIL-based static analysis. It works with CIL statements, kernel functions, and stacks of program points to track multithreaded behavior. Concrete use cases include analyzing shared variable accesses, managing call stacks during concurrency analysis, and generating diagnostic output for synchronization primitives.",
      "description_length": 453,
      "index": 694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_analysis_hooks",
      "library": "mthread",
      "description": "This module defines hooks for analyzing multi-threaded programs, providing functions to initialize the main thread state, register built-in functions, and intercept function calls and returns during analysis. It operates on thread and memory states, integrating with the value analysis to track execution flow and side effects. Concrete use cases include monitoring thread creation, handling synchronization primitives, and tracking shared memory accesses.",
      "description_length": 456,
      "index": 695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Trie",
      "library": "mthread",
      "description": "Implements a thread-safe trie data structure with operations for inserting, looking up, and deleting key-value pairs. Works with arbitrary key and value types, supporting concurrent access through synchronized mutable state. Useful for applications requiring efficient, concurrent prefix-based searches, such as auto-complete systems or shared dictionary implementations.",
      "description_length": 371,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes",
      "library": "mthread",
      "description": "This module implements pretty-printing and analysis functions for mutex-based protection states in a concurrent analysis context. It handles structured data including mutex sets, thread pairs, and location zones to represent access protections. It is used to detect ill-protected memory accesses and to format protection reports for diagnostic output.",
      "description_length": 351,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types",
      "library": "mthread",
      "description": "This module defines core data types and operations for modeling thread analysis in static verification. It includes types for read/write access modes, thread and synchronization events, event sets, execution traces, and presence flags for threads and mutexes. These are used to track memory accesses, thread interactions, and concurrency primitives like mutexes and message queues during program analysis.",
      "description_length": 405,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types",
      "library": "mthread",
      "description": "This module defines data types and structures for representing mutex access states and their categorization by read/write access. It includes operations to manipulate and analyze these states using lattice theory, enabling precise tracking of mutex usage in concurrent programs. The types `access_or_protection` and `mutexes_by_access` are used to model mutex presence and access patterns, supporting static analysis tasks such as synchronization verification and race condition detection.",
      "description_length": 489,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg",
      "library": "mthread",
      "description": "This module constructs and manipulates control flow graphs (CFGs) for multi-threaded analysis, translating thread states into CFG representations and optimizing them by removing unnecessary nodes based on memory access patterns. It provides operations to generate CFGs from thread states, prune nodes that lack concurrency-relevant content, and visualize CFGs using DOT format with customizable node labels. The module also includes dataflow functions to update analysis contexts and analyze memory accesses across CFG nodes, specifically tracking variable accesses by zone.",
      "description_length": 574,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_interferences",
      "library": "mthread",
      "description": "Tracks and updates the last analysis state for threads in a concurrent program. It works with thread analysis data structures to store and retrieve the most recent state information. This is used to compare current and previous analysis results for detecting changes or stabilizing fixed-point computations during thread interference analysis.",
      "description_length": 343,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_outputs",
      "library": "mthread",
      "description": "This module includes submodules for generating HTML reports and displaying analysis results from multi-threaded program analysis. It operates on analysis state data to produce structured visualizations and human-readable output. Concrete use cases include rendering thread execution traces in HTML and printing evaluated values for debugging and reporting.",
      "description_length": 356,
      "index": 702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_lib",
      "library": "mthread",
      "description": "This module defines types and functions for polymorphic pretty-printing, including customizable formatters and generic tag-based comparisons. It handles strings, file paths, and low-level value representations, with utilities for sanitizing filenames, escaping non-UTF8 characters, and locating the mthread.h header file. Concrete use cases include formatting complex data structures for logging, comparing variant values in type-specific compare functions, and preparing output for analysis tools.",
      "description_length": 498,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_analysis_fixpoint",
      "library": "mthread",
      "description": "This module implements fixed-point analysis for thread states in a concurrent system. It provides operations to mark shared nodes, record thread analysis completion, and determine when a stable state (fixpoint) is reached. These functions operate on `analysis_state` structures to track and synchronize thread interactions during static analysis.",
      "description_length": 346,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types",
      "library": "mthread",
      "description": "This module defines core data structures and operations for analyzing multithreaded programs, focusing on concurrency tracking and control flow. It includes types for threads, contexts tracking active threads and mutexes, and CFG nodes enriched with concurrency metadata such as variable access kinds and memory states. The module supports precise modeling of concurrent memory accesses, thread interactions, and CFG traversal, enabling static analysis tasks like concurrency bug detection and abstract interpretation of multithreaded control flow.",
      "description_length": 548,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread",
      "library": "mthread",
      "description": "This module enables concurrency analysis by providing data structures and operations to model thread states, synchronization primitives, and memory interactions. It supports precise tracking of shared variables, mutex usage, and control flow in multi-threaded programs, facilitating static analysis tasks such as race detection and synchronization verification. Use cases include analyzing thread-locality, detecting ill-protected memory accesses, and modeling concurrent execution traces for C programs.",
      "description_length": 504,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table structure specialized for values of type `Data.t`, where equality and hashing are adapted to the structural or physical identity of elements, as required by the `Pred_or_term` context. It provides standard operations such as `equal`, `hash`, and `mem_project`, along with serialization and pretty-printing support for analysis-specific data. Concrete use cases include tracking and comparing sets of predicates or terms during static analysis, ensuring deep copying and proper project membership checks.",
      "description_length": 539,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines keys for a hash table that can represent either predicates or terms, with structural equality for predicates and physical equality for terms. It provides operations for comparing, hashing, and pretty-printing these keys, as well as checking project membership and performing deep copies. Concrete use cases include managing analysis data indexed by logical expressions or terms in a Frama-C plugin.",
      "description_length": 418,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map data structure parameterized by a `Data` module, where keys are associated with values of type `Data.t`. It provides standard operations including equality, comparison, hashing, pretty printing, and deep copying, along with project membership checks. It is used to represent and manipulate maps in static analysis contexts, such as tracking value associations across program states or analysis domains.",
      "description_length": 431,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for a map that associates logic variables with interval profiles based on function call arguments. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. The key type is used to represent function parameters in a profile map, enabling precise interval tracking across different callsites.",
      "description_length": 411,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a hash table, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports data types that represent keys with a unique name, type descriptor, and structural description, ensuring deep copying and project membership checks. Concrete use cases include managing and comparing analysis keys in a hash table structure for Frama-C plugins.",
      "description_length": 419,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a hash table that maps logic variables to intervals based on function call arguments. It supports operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. The key type captures contextual information about function parameters and their associated logic variables at callsites.",
      "description_length": 396,
      "index": 712,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Functions.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options with operations for comparison, hashing, pretty-printing, and deep copying. It supports values of type `t` representing string parameters, along with standard operations for equality, ordering, and project membership checks. Concrete use cases include parsing and managing E-ACSL configuration options that require string inputs, such as file paths or identifier names.",
      "description_length": 447,
      "index": 713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with hash tables mapping keys to values of type `Data.t`, providing deep copy, membership checks over projects, and type descriptors for integration with Frama-C's kernel. Concrete use cases include managing analysis-specific data indexed by keys during static analysis, such as tracking memory states or value abstractions.",
      "description_length": 512,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for a key type used in map structures, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type, which represents keys in a map, along with project-based membership checks and deep copying. Concrete use cases include managing and comparing logic function or predicate profiles within analysis tools.",
      "description_length": 372,
      "index": 715,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data handling with capabilities for deep copying and membership testing within projects. Use cases include managing and manipulating string-based parameters in a type-safe manner, particularly for configuration or logging systems where unique identification and representation are critical.",
      "description_length": 432,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for representing, comparing, and printing values used in the context of a string-based parameter configuration. It supports equality checks, ordering, hashing, and pretty-printing, making it suitable for use in logging or configuration management. The type is designed to hold values that can be associated with projects, allowing for deep copying and membership checks based on project properties.",
      "description_length": 446,
      "index": 717,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines keys for a map that can represent either predicates or terms, with structural equality for predicates and physical equality for terms. It provides standard operations including comparison, hashing, pretty printing, and deep copying, along with utilities to check membership within projects and describe the key type. Use cases include managing and distinguishing between predicate and term keys in analysis contexts where equality and identity matter.",
      "description_length": 471,
      "index": 718,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map datatype specialized for analysis values, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with a parameterized value type `Data.t` and includes support for project membership checks, deep copying, and structural descriptions. Concrete use cases include managing and manipulating analysis-specific value mappings during static analysis in a type-safe and efficient manner.",
      "description_length": 448,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for logic function profiles, providing operations for equality, comparison, hashing, and pretty-printing. It works with values of type `Data.t` and supports deep copying, membership testing by project, and type descriptors for integration with Frama-C's kernel. Concrete use cases include managing and querying logic function profiles during static analysis, ensuring efficient lookups and structured data handling.",
      "description_length": 463,
      "index": 720,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a hashtbl, providing equality, comparison, hashing, and pretty-printing operations tailored to the `Number_ty` analysis. It includes functions for deep copying keys, checking membership based on project properties, and exposing type descriptors for integration with Frama-C's kernel. It is used to uniquely identify and manipulate numeric type information within analysis-specific hash tables.",
      "description_length": 435,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for values with identity and profiling information, supporting operations like equality, comparison, hashing, and pretty-printing. It works with data types that include terms and their variable profiles, ensuring deep copying and project-aware membership checks. Concrete use cases include managing and querying logic function terms with associated free variable intervals in static analysis plugins.",
      "description_length": 448,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps used in analysis, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports data types that include project-specific information, allowing for deep copying and membership checks based on project projections. Concrete use cases include managing and comparing symbolic analysis keys in static analysis passes.",
      "description_length": 391,
      "index": 723,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table data structure parameterized by the `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing for values stored in the table. It supports concrete data types defined by the `Data` module, enabling efficient lookups, deep copies, and project-aware membership checks. Use cases include managing analysis-specific data indexed by keys during static analysis, such as tracking variable states or function summaries.",
      "description_length": 490,
      "index": 724,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module creates a map structure specialized for values of type `Data.t`, where keys are based on the `Pred_or_term` type. It supports standard map operations such as lookup, insertion, and iteration, while ensuring structural equality for predicates and physical equality for terms. Concrete use cases include managing analysis-specific data indexed by logical predicates or terms in static analysis tools.",
      "description_length": 410,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map structure parameterized by a `Data` module, where keys are tied to a logic function or predicate profile and values are of type `Data.t`. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project membership checks. It is used to manage and manipulate mappings from logic function profiles to associated data, such as analysis results or metadata.",
      "description_length": 448,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a hash table, specifically tailored for terms with profiles that include free variables and their intervals. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate keys representing logical terms in the context of static analysis, enabling efficient lookups and comparisons within Frama-C's analysis framework.",
      "description_length": 480,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map where keys are number types and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate mappings involving number types in static analysis contexts, such as tracking numeric value properties across program states.",
      "description_length": 414,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options in E-ACSL, providing standard operations such as equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project-related values, ensuring proper handling of string parameters during option parsing and manipulation. Concrete use cases include managing and validating string inputs from the command line, such as file paths, identifiers, or configuration strings.",
      "description_length": 486,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table-based data structure where keys are logic variables representing function parameters and values are intervals determined by function call arguments. It provides operations for equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. Concrete use cases include tracking and analyzing variable bounds across function calls in static analysis tools.",
      "description_length": 442,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type for a hash table that uses physical equality and provides standard operations including equality, comparison, hashing, and pretty printing. It supports deep copying and checks for the presence of specific project values within keys. This module is used to manage and manipulate keys in a hash table designed for terms requiring physical identity.",
      "description_length": 379,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map structure that associates logic variables (function parameters) with interval values, based on the callsite arguments of the function. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to represent and manipulate function parameter profiles in static analysis, particularly for tracking value ranges across different call contexts.",
      "description_length": 472,
      "index": 732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps that handle number-type analyses data, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with functions for deep copying, membership testing within projects, and type-safe representations. Use cases include tracking and manipulating numeric analysis keys in static analysis plugins, ensuring unique identification and efficient lookup within map structures.",
      "description_length": 473,
      "index": 733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table data structure specialized for a given `Data` module, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports concrete use cases like tracking and comparing analysis values in a Frama-C plugin context, where each hash table instance holds values of a specific analysis type. The module also enables deep copying, membership testing with project filtering, and maintains type descriptors for integration with Frama-C's kernel functionalities.",
      "description_length": 523,
      "index": 734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a hash table for logic function or predicate profiles, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the `LFProf.Hashtbl.key` type, which represents logic function or predicate keys with associated argument profiles. Concrete use cases include managing and querying logic function profiles in analysis tools, ensuring unique identification and efficient lookup based on structural and semantic equivalence.",
      "description_length": 497,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps used in analysis data structures, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports working with a specific abstract key type that includes project membership checks and deep copying. Concrete use cases include managing and comparing keys in map-based analyses, ensuring correct value association and efficient lookup.",
      "description_length": 410,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for values of a given `Data` module, using physical equality for identity. It provides standard operations like `mem`, `add`, `remove`, and `find`, along with deep copying, equality, comparison, and pretty-printing. It is used to manage collections of terms where identity is based on object physical address, ensuring correct behavior in contexts like Frama-C's kernel where term identity must be preserved across analyses.",
      "description_length": 472,
      "index": 737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options with operations for comparison, hashing, pretty printing, and deep copying. It supports values of type `t` representing string parameters, along with standard utilities for integration with Frama-C's option system. Use cases include parsing and managing E-ACSL instrumentation settings via command-line interfaces.",
      "description_length": 392,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a hashtbl implementation, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports working with values of type `E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl.key`, enabling efficient key-based lookups and storage management. Concrete use cases include managing interned values, tracking analysis-specific identifiers, and facilitating hash-based collections in static analysis contexts.",
      "description_length": 473,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-valued command-line parameters with support for validation, default handling, and dynamic updates. It operates on string values and associated metadata like allowed value lists, enabling use cases such as parsing user-provided options, enforcing parameter constraints, and synchronizing configuration state across a project. Key features include alias resolution, function name validation, and change tracking for parameters requiring string inputs.",
      "description_length": 476,
      "index": 740,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables for polymorphic values indexed by `At_data.t` keys, enabling ordered traversal, bulk updates from sequences, and safe key lookups via custom comparisons. It facilitates analysis-specific data management with memoization, deep copying, and project-aware validations, integrating seamlessly into static analysis workflows. Use cases include structured storage for program analysis states, efficient value transformations, and maintaining ordered key-value associations in Frama-C's kernel.",
      "description_length": 522,
      "index": 741,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a functional map structure with ordered keys supporting static analysis tasks, offering insertion, deletion, merging, and transformation operations that preserve key ordering. It works with polymorphic values paired with keys that enable comparison, hashing, and pretty-printing, providing both exception-raising and option-based accessors for safe key lookups. Designed for analyses requiring precise key-value associations, it facilitates operations like filtered iteration, ordered traversal, and sequence-based construction while maintaining immutability.",
      "description_length": 582,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements set operations (union, intersection, difference, insertion/removal) and transformations (filtering, mapping, partitioning) over collections of parameter interval profiles, which map function parameters to value ranges derived from specific callsites. It supports efficient membership queries, ordered traversal, and conversions to lists/sequences while preserving physical equality for performance. These capabilities enable static analysis tasks like aggregating parameter constraints across function calls, identifying overlapping intervals, or computing bounds for runtime checks.",
      "description_length": 606,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.List",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies RWS monadic functions to lists. It provides `iter`, `map`, and `fold_left` to sequence monadic effects over list elements. Use it to process lists while reading from an environment, writing logs, or modifying state.",
      "description_length": 235,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a functional set abstraction for numerical elements, supporting operations like union, intersection, difference, and transformations via mapping or filtering. It works with immutable sets of `Number_ty.t` values, providing ordered iteration, nearest-element queries, and conversions to sorted lists or sequences. These capabilities are particularly useful for static analysis tasks requiring precise numerical range tracking, disjointness checks, or set-based computations in Frama-C's analysis pipelines.",
      "description_length": 528,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables with keys derived from numeric type analysis data, supporting efficient insertion, deletion, and lookup operations alongside sequence-based bulk updates and ordered iteration. It provides utilities for managing table state, in-place value transformations, and memoization, specifically tailored for handling numeric type hierarchies within Frama-C's analysis framework. The design enables seamless integration with formal verification workflows by associating analysis-specific metadata with hash table entries.",
      "description_length": 546,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements polymorphic maps with keys representing logic function or predicate profiles, supporting insertion, deletion, merging, and ordered traversal operations. It provides ordered key-value pair management with efficient search, filtering, and transformation capabilities, along with utilities for sequence generation and customizable pretty-printing. Such structures are useful for analyzing or manipulating logic function profiles with associated data in formal verification contexts.",
      "description_length": 502,
      "index": 747,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables for key-value storage using physically equal terms as keys, supporting imperative operations like insertion, lookup, and removal alongside bulk transformations over sequences of entries. It enables ordered iteration and folding with customizable key ordering, safe default-returning lookups, and memoization, specifically designed for managing structural descriptions and type definitions in Frama-C's kernel where physical identity ensures term uniqueness. The reliance on physical equality avoids comparison function dependencies, making it suitable for scenarios requiring address-based identity checks in program analysis.",
      "description_length": 661,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Replace_libc_functions.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating abstract values in the context of E-ACSL option handling. It supports deep copying and membership checking over project skeletons, enabling precise tracking and transformation of analysis states. Concrete use cases include managing and comparing configurations during static analysis and logging.",
      "description_length": 450,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating values within the E-ACSL widening output system. It supports structured data handling through a list of representatives, a type descriptor, and project membership checks, ensuring deep copying and project-specific queries. Concrete use cases include managing abstract values during static analysis and facilitating value comparison and output formatting in E-ACSL's logical contexts.",
      "description_length": 537,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for grouping and controlling widening arguments in E-ACSL. It provides operations to create, enable, and modify categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. These categories determine how widening is applied during analysis, enabling fine-grained control over abstract interpretation behavior.",
      "description_length": 383,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This structure provides persistent maps with numeric keys and polymorphic values, supporting ordered operations like range queries, extremum retrieval, and bidirectional traversal alongside standard manipulations such as insertion, merging, and filtering. It includes utilities for static analysis tasks like numeric range tracking and abstract interpretation, offering optimized equality checks and physical sharing for efficiency. The design enables bidirectional iteration, pretty-printing, and conversion to sequences, leveraging key ordering for precise symbolic execution and value-set analysis.",
      "description_length": 601,
      "index": 752,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides ordered map operations for associating logic variables (function parameters) with interval profiles derived from callsite arguments, supporting key-based insertion, merging, filtering, and ordered traversal. It works with maps that use `Profile.t` keys\u2014representing analysis contexts\u2014and values of arbitrary type, enabling structural queries, list-accumulating updates, and sequence-based construction. Use cases include static analysis of function parameter intervals, merging profiles across call paths, and generating formatted representations of analysis results.",
      "description_length": 588,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements an ordered, immutable set structure for precise value tracking in static analysis, supporting operations like union, intersection, and difference alongside element-wise transformations (`map`, `filter`) and ordered traversal. It operates on elements of type `E_ACSL.Analyses_datatype.Ival_datatype.t`, leveraging comparison logic for efficient membership checks, nearest-neighbor queries, and ordered iteration. Designed for symbolic execution and range analysis, it enables use cases such as tracking dynamic value ranges, partitioning state spaces, and generating ordered sequences of analysis results.",
      "description_length": 627,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling abstract data types in command-line parameters. It provides utilities to check membership within project structures, perform deep copies, and expose type descriptors for integration with kernel functionalities. Concrete use cases include managing and validating structured options in static analysis tools built on the Frama-C platform.",
      "description_length": 473,
      "index": 755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for command-line parameter collections, such as `@none`, `@default`, and `@all`. It provides operations to create, enable, and modify categories with accessors and dependencies, controlling how parameters are interpreted in different contexts. Use cases include configuring instrumentation options with dynamic category-based behavior and managing global parameter states in command-line tools.",
      "description_length": 437,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Interlang.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the E-ACSL options system. It supports structured values with associated type and descriptor information, enabling deep copying and membership checks over project skeletons. Concrete use cases include representing and manipulating configuration options with rich structural semantics in a type-safe manner.",
      "description_length": 437,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Temporal_validity.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing temporal validity options in E-ACSL, including operations for equality, comparison, hashing, and pretty printing. It supports structured values with deep copying, membership testing on project skeletons, and integrates with Frama-C's type and descriptor system. Use cases include managing and manipulating temporal validity configurations during static analysis and logging sessions.",
      "description_length": 441,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Valid.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the E-ACSL runtime system. It supports structured values with associated type and descriptor information, enabling deep copying and membership checks over project skeletons. Typical use cases include managing and comparing configuration or state values within E-ACSL's analysis framework.",
      "description_length": 421,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type for representing and manipulating command-line parameter collections, including operations for equality, comparison, hashing, and pretty-printing. It works with structured data types that include project-specific values, supporting deep copying and membership checks within project contexts. Concrete use cases include managing and validating instrumented datatype options during command-line parsing and configuration in E-ACSL.",
      "description_length": 461,
      "index": 760,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Interlang_force.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the E-ACSL instrumentation framework. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling precise type handling and introspection. Concrete use cases include managing and comparing abstract values during static analysis, particularly for tracking and copying project-specific data across analysis states.",
      "description_length": 497,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module supports imperative hash table operations with polymorphic values, emphasizing in-place modifications and ordered traversals over keys of type `Ival_datatype.t`. It provides mechanisms for safe key lookups, bulk updates from sequences, and customizable comparison-based iteration, accommodating both functional and imperative usage patterns. Designed for integration with static analysis frameworks, it enables efficient memoization, ordered aggregation of analysis results, and traversal consistency in Frama-C's kernel-level dataflow computations.",
      "description_length": 561,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Operators",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines monadic operations for building intermediate language expressions during E-ACSL translation. It provides bind and map combinators for sequencing translation steps and transforming results within the `M` monad. These operations are used to construct and manipulate `Interlang` expressions in a structured way during the first compilation stage.",
      "description_length": 363,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Validate_format_strings.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing format string validation options in E-ACSL. It includes standard operations such as equality, comparison, hashing, and pretty printing, along with functions for deep copying and checking project membership. It is used to manage and manipulate format string validation settings during static analysis in Frama-C.",
      "description_length": 369,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements an ordered set data structure for elements representing logic functions or predicates with argument profiles, supporting operations like union, intersection, and difference, as well as ordered transformations (`map`, `filter`), iteration (`fold`, `to_list`), and structural queries (`subset`, `split`). It leverages a comparator-defined ordering to enable efficient element retrieval (`min_elt`, `find_first`) and ordered sequence conversions, with applications in static analysis phases requiring precise management of logic function profiles. The structure integrates with Frama-C's kernel for tasks like membership validation, deep copying, and analysis-specific pretty-printing.",
      "description_length": 705,
      "index": 765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages parameter categories for command-line options, including special categories like `@none`, `@default`, and `@all`. It works with category types built from elements and accessors, supporting operations to create, enable, and modify categories with specific dependencies and interpretations. Concrete use cases include configuring option groups with shared behavior and controlling global defaults or enablement rules for analysis parameters.",
      "description_length": 471,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Bool",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides the `only_if` function, which conditionally executes a monadic action based on a boolean flag. It operates on the unit type within the RWS monad, allowing conditional side-effects or state manipulations. A concrete use case is selectively logging or updating state based on runtime conditions without branching outside the monadic context.",
      "description_length": 360,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing widening arguments in the E-ACSL plugin, including operations for equality, comparison, hashing, and pretty printing. It works with a structured type `t` that includes a name, descriptor, packed descriptor, and representants, supporting deep copying and project membership checks. Concrete use cases include managing and comparing abstract domain parameters during static analysis and formatting them for user output.",
      "description_length": 475,
      "index": 768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for controlling output behavior in a logging system, specifically handling widening operations. It provides functions to create, enable, and configure categories such as `none`, `default`, and `all`, along with custom named categories that include accessors and dependencies. These categories are used to selectively enable or disable logging output based on dynamic conditions during program analysis.",
      "description_length": 445,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Gmp_only.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type and operations for managing a specific kind of value within the E-ACSL options system. It includes standard comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over project skeletons. The type is used to represent and manipulate structured data with support for persistence and project-based queries.",
      "description_length": 388,
      "index": 770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Option",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides monadic operations for handling `option` values within the intermediate language generation monad. It supports iterating over and mapping optional values using functions that produce monadic results. Useful for safely processing optional components during the translation of E-ACSL predicates into intermediate language expressions.",
      "description_length": 353,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based configuration parameters with support for validation, aliases, and dynamic value handling. It operates on string values and lists of allowed options, providing mechanisms to enforce constraints (e.g., valid function names), retrieve sanitized values, and integrate with Frama-C's project state for persistent configuration. Typical use cases include parsing and validating plugin settings, logging contexts, and user-defined string parameters in analysis tools.",
      "description_length": 494,
      "index": 772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Option",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies RWS monadic functions to the option type, enabling effectful computations over optional values. It provides `iter` for performing side-effecting operations on `Some` values and `map` for transforming optional values within the monad. Use cases include handling optional configuration data with logging or state updates, and processing values that may be absent while carrying reader or writer effects.",
      "description_length": 421,
      "index": 773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Assert_print_data.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in logging and option handling within the E-ACSL framework. It supports structured data representation with a descriptor and a list of representatives, enabling introspection and dynamic handling of values. The type is used to manage and manipulate assert/print-related configuration data, including project membership checks and deep copying to avoid shared state.",
      "description_length": 499,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables for managing logical terms enriched with profiling metadata, such as free variables and interval constraints, supporting operations like insertion, lookup, and in-place filtering with customizable comparison logic. It enables ordered traversal of entries and bulk updates from sequences, while integrating Frama-C's structural type system for static analysis tasks like memoizing term evaluations or tracking variable bounds in E-ACSL specifications. Key applications include optimizing logic function analysis and ensuring precise term handling during verification workflows.",
      "description_length": 611,
      "index": 775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements imperative hash tables for managing keys of type `Pred_or_term.t`, where predicates are compared structurally and terms use physical equality via `Id_term`. It supports standard operations like insertion, lookup, iteration, and folding, with utilities for safe access (`find_opt`, `find_def`) and ordered traversal using custom key comparators. The design facilitates use cases such as memoization, analysis state tracking, and efficient mapping of heterogeneous keys requiring distinct equality semantics.",
      "description_length": 529,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output_base.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in logging and option handling within the E-ACSL framework. It supports structured values through a descriptor and provides deep copying, membership testing for project skeletons, and representant enumeration. Concrete use cases include managing and persisting analysis options with precise type handling and project-specific filtering.",
      "description_length": 470,
      "index": 777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module supports creation, insertion, in-place updates, and sorted iteration over polymorphic hash tables using logic function or predicate profiles as keys, enabling efficient profiling and analysis workflows. The tables map these structured keys to arbitrary values, facilitating tasks like memoization, default value handling, and integration with Frama-C's structural type system. Specific applications include analyzing logic function behavior, maintaining keyed metadata during static analysis, and optimizing predicate evaluation through cached results.",
      "description_length": 564,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Run.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with support for deep copying and project membership checks. It works with structured data involving project skeletons and is used to represent and manipulate configuration or state data tied to analysis runs. Concrete use cases include managing run-time options with structured values, ensuring deep copies for isolation, and checking project-specific conditions during analysis.",
      "description_length": 494,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Full_mtracking.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the E-ACSL instrumentation framework. It supports structured data representation with a descriptor, packed descriptor, and list of representatives, enabling precise type handling and introspection. Use cases include tracking memory states and managing project-specific configurations during static analysis.",
      "description_length": 440,
      "index": 780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.List",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides monadic operations for processing lists within the intermediate language generation monad. It supports list iteration, mapping, and left folding, where each function applies a monadic computation to list elements. These operations are used to construct and manipulate lists of intermediate language expressions during E-ACSL to Cil translation.",
      "description_length": 365,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments_base.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a structured data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling widening arguments in E-ACSL. It supports deep copying, membership testing within projects, and provides representants along with type descriptors for introspection and serialization. Concrete use cases include managing and comparing abstract interpreter configuration options that involve complex data structures.",
      "description_length": 451,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements set operations for managing collections of predicate and term values, combining structural equality checks for predicates with physical identity comparisons for terms via `Misc.Id_term`. It supports ordered set manipulations like union, intersection, and filtering, along with sequence conversions and nearest-element queries, while ensuring immutability. The design accommodates static analysis scenarios requiring precise handling of logical expressions where predicate equivalence is structural but term uniqueness relies on physical identity.",
      "description_length": 569,
      "index": 783,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Functions.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based command-line configuration parameters, providing operations to set and retrieve values, validate against allowed options, and handle aliases and defaults. It operates on string values and collections of permitted entries, supporting use cases such as option parsing, function name validation, and state management in project configurations.",
      "description_length": 373,
      "index": 784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements ordered set operations for manipulating collections of `E_ACSL.Analyses_datatype.At_data.t` values, including union, intersection, difference, membership checks, and ordered traversal via iteration, folding, and filtering. It provides utilities for transforming sets to sequences, finding nearest elements relative to a value, and maintaining ordered semantics during analysis workflows, with support for comparison, hashing, and pretty-printing. These capabilities are designed for static analysis tasks in Frama-C, such as managing annotated memory states or processing structured data with strict ordering requirements.",
      "description_length": 645,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for handling command-line parameter representations. It supports structured data manipulation with deep copying, membership testing within projects, and descriptors for type representation. Concrete use cases include managing and comparing complex option values in E-ACSL command-line interfaces and static analysis configurations.",
      "description_length": 444,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Bool",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides monadic operations for handling boolean conditions during intermediate language generation. It includes functions like `only_if`, which conditionally executes monadic actions based on a boolean flag. It works with the `M` monad and is used to generate `Interlang` expressions that depend on runtime boolean checks.",
      "description_length": 335,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based command-line parameters for E-ACSL instrumentation settings, offering operations to define, validate, and manipulate allowed values with support for dynamic updates via hooks. It works with string collections and parameter objects that enforce value constraints, supporting use cases like configuring instrumentation modes or serialization formats through customizable, state-aware options. Key features include alias registration, comparison logic, and project state integration for robust command-line interface design.",
      "description_length": 554,
      "index": 788,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables that map logic variable profiles\u2014representing function parameters at callsites\u2014to interval values, supporting operations like insertion, lookup, and iteration with customizable key ordering. It facilitates static analysis tasks by enabling efficient storage and retrieval of parameter bound information, with utilities for memoization and serialization tailored to logic variable contexts. The structure is particularly suited for analyzing function behavior across varying input intervals during program verification.",
      "description_length": 553,
      "index": 789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides map operations for key-value associations where keys are either predicates (compared structurally) or terms (compared physically via `Misc.Id_term`). It supports standard manipulations like insertion, removal, lookup, and merging, along with ordered traversal, filtering, and transformation, tailored for static analysis scenarios requiring precise handling of mixed predicate-term keys. Use cases include managing analysis data with strict equality semantics, such as tracking term identities or structurally equivalent predicates in program verification.",
      "description_length": 577,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Operators",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides infix operators for sequencing and transforming computations within an RWS monad. It supports chaining effectful actions using bind (`>>-`, `let*`) and non-effectful transformations using map (`>>-:`, `let+`). These operations are used to compose reader, writer, and stateful computations concisely, such as passing configuration data through a pipeline or accumulating logs while maintaining mutable state.",
      "description_length": 428,
      "index": 791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Project_name.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling project-specific values. It includes functions for checking membership within projects, deep copying values, and exposing structural representations via descriptors and a packed format. Concrete use cases include managing and comparing project configurations, validating project inclusions, and serializing values for logging or user output.",
      "description_length": 473,
      "index": 792,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Verbose.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing verbose options in E-ACSL, including operations for equality, comparison, hashing, and pretty printing. It works with structured values that may contain project-specific data, supporting deep copying and membership checks over project skeletons. Use cases include managing and manipulating verbose configuration settings during static analysis with Frama-C.",
      "description_length": 415,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Debug.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the E-ACSL options logging system. It supports structured values with descriptors, representants, and project membership checks, enabling precise type handling and introspection. Concrete use cases include logging and debugging configuration settings with rich type information and structured representations.",
      "description_length": 433,
      "index": 794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with category types that associate names with accessors and dependency lists, controlling how parameters are interpreted and enabled. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a category, and defining special categories that override standard behavior.",
      "description_length": 486,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Concurrency.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing concurrency-related options in E-ACSL, including operations for equality, comparison, hashing, and pretty printing. It works with structured descriptors, project skeletons, and lists of representants to manage and manipulate concurrency configurations. Use cases include tracking and copying concurrency state across different analysis contexts and projects.",
      "description_length": 416,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages stateful configuration of widening parameters through a typed option structure and key-value mappings, supporting dynamic updates via hooks and aliases. It operates on abstract domain parameters during static analysis, enabling customization of abstract interpretation behavior through category-based controls and marshaling strategies. Use cases include tracking computed widening thresholds, defining symbolic aliases for analysis flags, and coordinating domain-specific tuning during program verification.",
      "description_length": 528,
      "index": 797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents function parameter logic variables mapped to interval values derived from callsite arguments, supporting operations like creation, comparison, hashing, and pretty-printing. It works with logic variables and interval types to enable static analysis of function parameter bounds. Concrete use cases include tracking parameter intervals across function calls, merging analysis contexts, and computing value ranges for runtime verification.",
      "description_length": 459,
      "index": 798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing command-line configuration parameters and their runtime state, including value assignment, default retrieval, change hooks, and alias definitions. It works with structured sets of kernel functions and string-based parameter categories, enabling command-line option parsing, validation, and integration with Frama-C's project state system. Specific use cases include configuring analysis options through command-line arguments and tracking state changes in kernel function collections during program analysis.",
      "description_length": 553,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Validate_format_strings",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean flag to control format string validation behavior, offering operations to set (on/off), retrieve, and track changes to the flag's state. It works with a concrete boolean type (`t = bool`) and includes mechanisms for command-line configuration (e.g., help messages, aliases), serialization, and project-specific state monitoring. The flag directly influences runtime validation of format strings in E-ACSL, enabling use cases like dynamically toggling strict validation checks or persisting configuration settings across sessions.",
      "description_length": 559,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Assert_print_data",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to manage a boolean flag that controls the display of assertion data, including functions to toggle its state (`on`/`off`) and track value changes. It works with shared global state and supports advanced features like update hooks for reactive behavior, custom serialization for persistence or communication, and command-line interface integration (e.g., help messages, aliases). It is used to dynamically enable or disable debug/output functionality during analysis, configure logging behavior via external interfaces, and maintain consistent state across distributed or project-specific contexts.",
      "description_length": 630,
      "index": 801,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Env.Context",
      "library": "frama-c-e-acsl.core",
      "description": "Saves the current state of an environment, allowing for later restoration. Works with the environment type `E_ACSL.Env.t`. Useful when temporarily modifying the environment during analysis phases that require backtracking.",
      "description_length": 222,
      "index": 802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Misc.Id_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a term type based on physical equality, providing operations for equality checks, hashing, comparison, and deep copying. It supports structured data analysis in Frama-C by enabling precise identity tracking and memoization through a dedicated hash table implementation. Use cases include managing term representations and structural descriptors in program analysis tasks where identity is determined by physical equality.",
      "description_length": 441,
      "index": 803,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a composite data type representing logic functions or predicates paired with argument profiles, supporting precise static analysis operations. It provides core functionalities for equality checks, comparison, hashing, deep copying, and pretty-printing tailored for logic function profiling in formal verification tasks. The associated Set, Map, and Hashtbl submodules enable structured manipulation of these profiles with ordered sets, keyed mappings, and hash tables, specifically applied in static analysis phases for tasks like predicate evaluation optimization and metadata management.",
      "description_length": 609,
      "index": 804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.State_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages the creation, retrieval, and setting of file paths for a plugin-specific state directory. It provides direct access to directories and files within that state directory, ensuring correct handling of paths using the `Frama_c_kernel.Filepath` type. Concrete use cases include storing and accessing plugin-generated files such as logs, intermediate results, or configuration data in a dedicated directory.",
      "description_length": 422,
      "index": 805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang.Pretty",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements precise pretty-printing functions for various components of the E-ACSL intermediate language, including expressions, variables, binary operations, and memory locations. It operates directly on types such as `exp`, `lval`, `binop`, and `varinfo`, producing human-readable representations suitable for debugging and logging. These functions are used during the intermediate translation phase to inspect and validate the structure of generated code before conversion to Cil.",
      "description_length": 494,
      "index": 806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a polymorphic data type `t` representing analysis-specific values with rich structural properties. It provides core operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Designed for static analysis in Frama-C, it supports precise manipulation of annotated program states and structured data, with use cases including memory model tracking and logic predicate evaluation.",
      "description_length": 459,
      "index": 807,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Debug",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to manage integer-based configuration parameters with capabilities to set, increment, constrain values within bounded ranges, and track state changes. It works with integers augmented by metadata for introspection, serialization, and dynamic value hooks, supporting use cases like structured logging, command-line interface integration, and debugging of E-ACSL plugins where precise control over numeric configuration states is required.",
      "description_length": 469,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Share",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages paths related to a shared directory for the E-ACSL plugin, providing functions to set, retrieve, and check the directory location. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports locating specific files or subdirectories within the shared directory. Concrete use cases include resolving paths to plugin resources or configuration files during analysis.",
      "description_length": 405,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for interval values used in static analysis, including operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and project membership checks, working with `ival` values and integrating with Frama-C's project and type system. It is used for representing and manipulating abstract values in symbolic execution and range analysis.",
      "description_length": 394,
      "index": 810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a polymorphic type `t` representing either a predicate or a term, with structural equality for predicates and physical identity for terms via `Misc.Id_term`. It provides standard operations including equality, comparison, hashing, pretty printing, deep copying, and project membership checks. Use cases include managing logical expressions in static analysis where predicate equivalence and term identity must be handled distinctly.",
      "description_length": 452,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Inductive.Derived_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a hash table mapping inductive predicates to derived logic functions generated during their transformation into executable form. It provides `iter` to traverse these derived functions, applying a function to each predicate-function pair. It directly supports processing logic functions derived from inductive predicate definitions that conform to generalized Horn clauses.",
      "description_length": 392,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp.Z",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements arithmetic and comparison operations over arbitrary-precision integers using the GMP library. It provides functions to create and manipulate `mpz_t` variables, perform binary operations (addition, subtraction, etc.), and comparisons, with support for casting and logical term tracking. Concrete use cases include formal verification tasks requiring precise integer arithmetic, such as loop invariant checks or overflow analysis in C code.",
      "description_length": 461,
      "index": 813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Rtl.Symbols",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to query and manipulate symbol tables that map C identifiers to their corresponding RTL representations. It supports checking existence and retrieving variable information for globals, kernel functions, and named variables. Use cases include resolving C function replacements in RTL and verifying if a given symbol is part of the RTL.",
      "description_length": 366,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp.Q",
      "library": "frama-c-e-acsl.core",
      "description": "Implements rational number creation, arithmetic operations, and type conversions using GMP. Works with CIL expressions and types to handle real numbers as rationals, supporting operations like addition, comparison, and casting to integers. Useful for precise real-number manipulation in static analysis plugins, such as handling ACSL annotations involving rational arithmetic.",
      "description_length": 376,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Cache_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Use cases include storing transient analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 380,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module creates an RWS monad that combines reader, writer, and state effects, enabling computations that read from an environment, write to a log, and update state. It provides operations like `read`, `write`, `get`, `set`, and `modify`, along with monadic combinators for sequencing and transforming effectful computations. Use it to manage configuration-driven processing with logging and mutable state, such as parsing files with contextual settings while accumulating diagnostics.",
      "description_length": 488,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic variable environments and execution profiles in a stack-based manner. It supports operations to add logic variables with associated integer values, retrieve the current logic environment and profile, and push or pop environments to maintain context during analysis. It is used in static analysis to track and manipulate logic variable states across different program points.",
      "description_length": 400,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term.Term",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates logical terms and expressions, including constants like true and false, conditional expressions, let bindings, and labeled terms. It operates on the `term` type, which represents logical terms in the CIL type system, and supports building logic bodies, let expressions, and time-stamped terms using labels. Concrete use cases include generating intermediate logic expressions for static analysis, constructing preconditions or postconditions for function contracts, and embedding terms within other logic constructs.",
      "description_length": 555,
      "index": 819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Temporal_validity",
      "library": "frama-c-e-acsl.core",
      "description": "This implementation provides a boolean option type to manage temporal validity checks, with operations to toggle its state, register change handlers, and handle command-line configuration. It integrates with Frama-C's state management system to support project-specific settings and serialization, enabling runtime control of temporal property enforcement during program analysis. The type works with internal flags and aliases to coordinate pre/post-condition validation modes across different analysis phases.",
      "description_length": 511,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Concurrency",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing a boolean concurrency configuration, including state modification, retrieval, and serialization. It works with a concrete boolean type enhanced with project-specific state tracking, default values, and command-line interface integration. The functionality supports use cases like enabling/disabling concurrency features in E-ACSL and persisting configuration changes across sessions.",
      "description_length": 428,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term.Predicate",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates logical predicates used in formal verification. It provides functions to create boolean constants, conditional expressions, let bindings, and temporal assertions using labels. These operations directly build and transform `predicate` values, which represent logical conditions in program analysis.",
      "description_length": 336,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Gmp_only",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides state manipulation operations for a boolean flag, supporting initialization, toggling via `on`/`off` actions, and lifecycle management with pre/post-update hooks. It operates on a single implicit boolean value, integrating with project-specific state tracking and custom marshaling for persistence. Designed for configuration scenarios in Frama-C's plugin ecosystem, it enables command-line interface exposure, aliasing, and serialization tailored to dynamic analysis toolchains.",
      "description_length": 500,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_ats.Free",
      "library": "frama-c-e-acsl.core",
      "description": "Translates E-ACSL `\\at()` expressions into C code by inserting and managing `free` statements for memory cleanup. Works with `kernel_function` and `stmt` types from Frama-C's CIL framework. Used during E-ACSL instrumentation to generate correct C implementations of logical terms involving memory states.",
      "description_length": 304,
      "index": 824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_build.Lhost",
      "library": "frama-c-e-acsl.core",
      "description": "Converts a CIL variable into an intermediate language host value, using an optional custom name. Works with CIL variable information and intermediate language host structures. Useful for translating C variables into their corresponding symbolic representations during expression construction.",
      "description_length": 292,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Logic_env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a logic environment representing intervals of bound variables, providing operations to add, refine, and retrieve variable bindings. It works with logic variables and intervals, supporting precise interval analysis during static checking. Use cases include tracking variable ranges in function calls and quantified expressions to improve verification accuracy.",
      "description_length": 379,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing command-line options as sets and kernel function collections, including element addition, membership checks, iteration, and emptiness tests. It works with `Frama_c_kernel.Cil_datatype.Kf.Set.t` values and string-based parameters, enabling configuration of instrumentation settings with dynamic updates, value constraints, and context-dependent behavior. These features support integrating with Frama-C's option handling system and managing project-specific state through serialization and update hooks.",
      "description_length": 547,
      "index": 827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Config_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages file paths for a plugin-specific configuration directory, providing operations to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to handle system paths and ensures the existence of required structures when needed. Concrete use cases include setting up storage for plugin-generated files and accessing configuration resources during analysis.",
      "description_length": 408,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Replace_libc_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a boolean configuration option to control libc function replacement during static analysis, offering operations to set, query, and monitor state changes through a dedicated type `t`. It manages a shared internal state variable via unit functions (`on`/`off`), integrates with command-line interfaces for user configuration, and supports project-level state persistence and marshaling. The functionality is specifically used to enable or disable libc function substitution in E-ACSL analysis workflows.",
      "description_length": 524,
      "index": 829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Full_mtracking",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean configuration flag for memory tracking, offering operations to set, retrieve, and monitor changes through callback hooks. It works with boolean state values augmented by metadata for command-line parsing, serialization, and project-specific lifecycle management. The functionality supports use cases like enabling/disabling memory tracking in static analysis workflows, integrating configuration with command-line interfaces, and synchronizing state transitions across analysis phases.",
      "description_length": 515,
      "index": 830,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Bimap.Make",
      "library": "frama-c-e-acsl.core",
      "description": "Implements a bijective hash map using two hash tables, allowing efficient bidirectional lookups. It supports adding key-value pairs, retrieving associated values in either direction, and handling chains of mappings through head and tail operations. Useful for scenarios requiring fast forward and reverse lookups, such as symbol table management or bidirectional data synchronization.",
      "description_length": 384,
      "index": 831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Annotation_kind",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for managing and manipulating annotation kinds, including equality checks, comparison, hashing, and pretty-printing. It works with the `annotation_kind` type, representing different categories of annotations used in static analysis. Concrete use cases include tracking and comparing annotation types during analysis, ensuring deep copies for mutation operations, and supporting project-specific filtering through `mem_project`.",
      "description_length": 458,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Verbose",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages verbosity settings through integer levels with bounded ranges, supporting operations to set, increment, and constrain values while integrating hooks for change tracking and command-line interface handling. It enables dynamic logging control and persistent configuration management across E-ACSL's analysis workflows by serializing project-specific state and comparing verbosity thresholds.",
      "description_length": 409,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_build.Exp",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs expressions in an intermediate language using smart constructors. It provides functions to create expressions from expression nodes, lvalues, integers, and sizeof operations, all tied to a specific type system and term origin. Use it to build complex expressions programmatically during static analysis or transformation passes.",
      "description_length": 351,
      "index": 834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Error.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module generates error-handling utilities for specific phases, offering functions to create and raise exceptions like `Typing_error`, `Not_yet`, and `Not_memoized`, each tied to distinct error scenarios during analysis. It provides helpers to handle these errors, map over results, and format error messages, all while incorporating source location context where applicable. Use cases include enforcing typing constraints, managing unsupported features, and handling incomplete computations in static analysis phases.",
      "description_length": 522,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile",
      "library": "frama-c-e-acsl.core",
      "description": "This module pairs a CIL term with a profile that tracks free variables and their intervals, enabling precise handling of terms within logic functions or predicates. It supports operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and analyze terms with attached profiling metadata, such as during verification tasks where tracking variable bounds and term structure is essential.",
      "description_length": 470,
      "index": 836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions.RTL",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles name manipulation and identification for functions and variables in the E-ACSL runtime library. It provides functions to prefix names with identifiers for the public API and generated instrumentation symbols, and to check or retrieve original names by stripping these prefixes. It is used to manage symbol naming during instrumentation and analysis phases in E-ACSL.",
      "description_length": 386,
      "index": 837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_normalizer.Logic_infos",
      "library": "frama-c-e-acsl.core",
      "description": "Tracks relationships between original and generated logical entities during predicate preprocessing. It provides functions to retrieve the list of auxiliary `logic_info` elements generated from a given one and to identify the original `logic_var` from which a variable originates. This is used to ensure error messages and user feedback reference the original, user-defined logic constructs rather than internal generated ones.",
      "description_length": 427,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions.Libc",
      "library": "frama-c-e-acsl.core",
      "description": "This module identifies and maps C standard library functions to their RTL equivalents, checking for replacements and categorizing functions related to memory operations, variable-length arrays, and formatted output. It operates on function names and CIL expressions, providing precise recognition of functions like `memcpy`, `memset`, `alloca`, and `printf` variants. Use cases include static analysis optimizations, replacing unsafe or platform-specific calls, and handling variadic arguments in logging or serialization functions.",
      "description_length": 532,
      "index": 839,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Interlang.Varinfo",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents variables in an intermediate language used during E-ACSL compilation, distinguishing between freshly generated logic variables and references to existing ones. It provides constructors for creating fresh variables with a given type, name, and origin term, and for wrapping existing logic variables. The module supports pretty-printing for debugging and maintains strict field requirements to ensure correct Cil code generation equivalence with legacy compilation.",
      "description_length": 486,
      "index": 840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types.Z",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manipulates an unbounded integer type for runtime representation, providing functions to obtain the type, its pointer variant, and to check type equivalence. It works directly with `Frama_c_kernel.Cil_types.typ` to integrate with the analysis framework's type system. Concrete use cases include handling arbitrary-precision integers in static analysis plugins and ensuring correct type recognition during program transformation passes.",
      "description_length": 459,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Translate_ats.Malloc",
      "library": "frama-c-e-acsl.core",
      "description": "This module tracks and manages `malloc` statements associated with kernel functions during the translation of E-ACSL `\\at()` terms. It provides operations to retrieve all `malloc` statements for a given kernel function and to remove them from the internal tracking table. It works directly with `kernel_function` and `stmt` data types from the Frama-C CIL framework. Use cases include inserting dynamically allocated memory statements into generated C code and cleaning up temporary allocations after processing.",
      "description_length": 512,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing configuration options with customizable update hooks, alias resolution, and category-based logging controls. It operates on string-indexed integer values, key-value pairs with string parameters, and category settings, enabling dynamic configuration adjustments, project-aware state tracking, and marshaling support. Specific capabilities include parameter validation, iterative queries over configuration data, and maintaining consistent state across project sessions.",
      "description_length": 513,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Valid",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing a mutable boolean state variable, including setting its value, observing changes through hooks, and synchronizing with external systems. It works with shared boolean values and supports advanced features like aliasing, serialization, and integration into Frama-C's project state management. The design enables use cases requiring persistent configuration toggles, such as feature flags or analysis settings that must propagate across tools and projects while maintaining visibility and change tracking.",
      "description_length": 547,
      "index": 844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a numeric type representation with operations for equality checking, comparison, hashing, and pretty-printing. It supports static analysis tasks requiring precise handling of numeric types, including deep copying, membership testing within projects, and standard type descriptor functionalities. The associated Set, Map, and Hashtbl submodules provide efficient data structures for numerical set manipulation, key-based mapping, and hash-based storage, tailored for Frama-C's analysis workflows.",
      "description_length": 515,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Interlang",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for managing boolean configuration options, including state toggling via `on`/`off` functions, value retrieval, alias handling, and customizable marshaling. It operates on an encapsulated `bool` type (`E_ACSL.Options.Interlang.t`) with support for pre/post-change hooks and visibility control. These features enable integration with Frama-C's project system and serialization workflows, particularly for runtime configuration adjustments and state synchronization during analysis.",
      "description_length": 512,
      "index": 846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_tracking.SpecialPointers",
      "library": "frama-c-e-acsl.core",
      "description": "Tracks properties of pointers in memory, such as whether they are freeable, writeable, or initialized. It analyzes CIL terms to determine pointer characteristics, aiding in precise memory modeling. Used during static analysis to ensure correct handling of pointer operations and memory safety.",
      "description_length": 293,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_binding",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic variable bindings within an environment, providing operations to add, retrieve, and remove associations between logic variables and variable information. It works with environments, logic variables, and variable information structures from the Frama-C kernel. Concrete use cases include tracking variable substitutions during logic expression evaluation and maintaining context for symbolic reasoning tasks.",
      "description_length": 433,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions.Concurrency",
      "library": "frama-c-e-acsl.core",
      "description": "This module determines whether a C library function has a corresponding replacement in the RTL and provides the name of that replacement. It operates on function names as strings, returning boolean checks and string mappings. Use cases include identifying available replacements during static analysis and resolving function names in instrumented code.",
      "description_length": 352,
      "index": 849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a monadic framework for generating intermediate language expressions during E-ACSL translation, supporting operations for managing environment, state, and side-channel output. It works with `env`, `state`, and `out` types to handle configuration, mutable state, and logging respectively, while providing structured control flow for expression generation. Concrete use cases include conditionally emitting expressions based on boolean checks, accumulating generated code fragments, and handling optional or list-valued components during translation.",
      "description_length": 571,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output_base",
      "library": "frama-c-e-acsl.core",
      "description": "This module manipulates and tracks bounded integer parameters with dynamic constraints, supporting operations to set, increment, and enforce allowed value ranges. It works with integer-valued state that includes metadata for bounds, change hooks, and marshaling, while integrating with command-line interfaces and project-specific configuration. Typical use cases involve analysis parameters requiring validated ranges, such as setting iteration limits or resource thresholds that trigger side effects when modified.",
      "description_length": 516,
      "index": 851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types.Q",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manipulates the GMP rational type representation at runtime. It provides functions to obtain the type `t` and its pointer variant, check if a given type matches the GMP rational type, and initialize usage with `is_now_referenced`. It works directly with `Frama_c_kernel.Cil_types.typ` to support type handling in static analysis plugins.",
      "description_length": 361,
      "index": 852,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Interlang_force",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to manage a boolean state flag, including toggling its value, registering state change handlers, and integrating with command-line interfaces through serialization and aliasing. It operates on a shared boolean value representing an interlanguage processing option, enabling runtime configuration and persistence across different execution contexts. Specific use cases include enabling/disabling instrumentation features dynamically and propagating state changes to dependent components via registered hooks.",
      "description_length": 539,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Project_name",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides mechanisms to manage string-valued options with features like pre/post-update hooks, alias handling, and custom marshaling, alongside utilities for validating and restricting string parameters to specific function names or patterns. It operates on strings and string lists, supporting use cases such as command-line interface integration, project state tracking across sessions, and enforcing naming conventions for functions through parameter validation. The module also facilitates serialization, comparison, and dynamic customization of project-related settings.",
      "description_length": 586,
      "index": 854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_scope",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic scopes within an environment, providing operations to retrieve, extend, and remove logic variables. It supports environment manipulation by allowing temporary modifications and controlled resets based on a reset flag. Use cases include tracking logic variables during static analysis and managing scope transitions in formal verification tasks.",
      "description_length": 370,
      "index": 855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments_base",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to manage integer values with optional range constraints, supporting bounded increments, value validation, and state synchronization. It works with shared mutable integers paired with min/max bounds, enabling use cases like configuration settings that require validated input or iterative adjustments within defined limits. The module integrates with command-line interfaces for option parsing, persists state changes, and supports introspection and serialization for system-wide consistency.",
      "description_length": 524,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LF_env",
      "library": "frama-c-e-acsl.core",
      "description": "Implements a mutable environment for tracking and updating intervals and profiles during fixpoint analysis of recursive logic functions. It maps logic_info values to profiles, intervals, and argument sets, supporting operations to query, update, and reset analysis state. Used to infer and refine bounds for recursive function calls during static analysis.",
      "description_length": 356,
      "index": 857,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Session",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages session-specific directories and files for the plugin, providing functions to retrieve or create them. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations like setting, getting, and checking the existence of a user directory. Concrete use cases include initializing session storage, accessing session files, and ensuring directory paths exist before writing logs or intermediate data.",
      "description_length": 444,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Dkey",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines categories for command-line options related to dynamic assertion checking in E-ACSL. It groups options that control the behavior of the runtime system, such as memory tracking, interval analysis, and label handling. These categories are used to structure and manage configuration flags during tool initialization and command-line parsing.",
      "description_length": 358,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Run",
      "library": "frama-c-e-acsl.core",
      "description": "The module implements runtime configuration mechanisms for boolean flags and structured state data, supporting operations to set values, register change hooks, and manage defaults with computed states. It integrates command-line aliases and help output, enabling use cases like feature toggles and dynamic behavior adjustments in E-ACSL's execution environment, while custom marshaling ensures state persistence across sessions with project-specific logic.",
      "description_length": 456,
      "index": 860,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Lscope.D",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for a data type representing analysis scopes, including equality, comparison, hashing, and pretty-printing functions. It supports working with project-based data through the `mem_project` function, which checks for the presence of specific project values within a scope. The module also provides deep copying to ensure no shared references between instances.",
      "description_length": 389,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.E_acsl_visitor",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a visitor pattern for traversing and processing different kinds of global declarations and definitions in the CIL abstract syntax tree, particularly tailored for E-ACSL transformations. It provides case-specific handlers for variables, functions, annotations, and built-in symbols, enabling targeted code analysis or instrumentation. Use cases include translating or analyzing E-ACSL annotations, handling variable initializations, and processing function definitions during static analysis.",
      "description_length": 511,
      "index": 862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Rtl",
      "library": "frama-c-e-acsl.core",
      "description": "This module links the RTL's abstract syntax tree (AST) with the current project's AST, ensuring alignment between the intermediate representation and the original source code. It provides the `link` function to integrate the RTL into the project's context. A key use case is enabling accurate translation and verification of C functions by resolving symbol mappings during the linking phase.",
      "description_length": 391,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to check function definitions, code generation requirements, and instrumentation needs for kernel functions. It works with CIL expressions and kernel functions, directly supporting static analysis decisions and instrumentation workflows. Concrete use cases include determining whether to generate code for a function's annotations or whether to apply instrumentation based on function properties.",
      "description_length": 428,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines types and printers used in E-ACSL analyses for representing logical variables, scopes, and annotations. It includes variants for integer and numeric types, predicates, terms, and structured data like `at_data` for tracking analysis context. These types support precise modeling and analysis of C code annotations, particularly for assertions, preconditions, and invariants.",
      "description_length": 393,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Exit_points",
      "library": "frama-c-e-acsl.core",
      "description": "This module identifies variables that must be removed from tracking before early exit statements like `goto`, `break`, or `continue`, and variables that must be re-recorded before labeled statements targeted by `goto`. It processes CIL function definitions and statements to analyze control flow and variable scope transitions. Use this module to manage variable tracking across complex control structures during static analysis.",
      "description_length": 429,
      "index": 866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Labels",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles pre-analysis of labeled terms and predicates in CIL code, determining where translations should occur. It processes statements to extract labeled elements and tracks translation points using CIL statement structures and logic variables. Used during static analysis to prepare labeled assertions and terms for further processing, ensuring correct placement of translations in the code.",
      "description_length": 404,
      "index": 867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interval_utils",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements operations on intervals, including inclusion checks, joins, meets, and construction of intervals from integers or types. It works with the `ival` type representing abstract intervals and interacts with integer values, C types, and logic types. Concrete use cases include determining if an interval is a singleton, lifting arithmetic operations to intervals, and computing bounds for C or logic types.",
      "description_length": 423,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_tracking",
      "library": "frama-c-e-acsl.core",
      "description": "This module determines which variables, expressions, and left-values must be tracked by the memory model library during static analysis. It works with CIL types such as `varinfo`, `lval`, and `exp`, and supports precise memory modeling by analyzing pointer properties through the `SpecialPointers` submodule. It is used to enforce memory safety by identifying values that require runtime monitoring, particularly in the absence of concurrency support.",
      "description_length": 451,
      "index": 869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_translate",
      "library": "frama-c-e-acsl.core",
      "description": "This module translates memory-related operations into expressions, handling function calls that involve memory manipulation, validity checks, and size computations. It operates on types such as terms, predicates, and expressions from the CIL framework, along with assertion data and environment contexts. Concrete use cases include converting memory validity conditions into expressions, translating GMP terms to size_t, and generating expressions from predicates in memory safety analyses.",
      "description_length": 490,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Quantif",
      "library": "frama-c-e-acsl.core",
      "description": "Converts quantified predicates into expressions, working with CIL types for kernel functions, environments, and predicates. It returns a transformed expression along with an updated environment. This is used during static analysis to handle logical quantifiers in annotations, enabling further processing by tools like the value analysis or the weakest precondition plugin.",
      "description_length": 373,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for constructing and manipulating logical predicates and terms in formal verification. It provides functions to create boolean constants, conditionals, let bindings, and labeled expressions for both `predicate` and `term` types, supporting the building of logical conditions and expressions used in static analysis. Concrete use cases include generating preconditions, postconditions, and intermediate logic constructs for function contracts and program analysis.",
      "description_length": 494,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Bound_variables",
      "library": "frama-c-e-acsl.core",
      "description": "This module processes quantified predicates by extracting and refining bound variables along with their guards, and replaces or stores these bounds for further analysis. It works with logic variables, terms, and predicates from the Cil_types module, focusing on quantified expressions in annotations and global predicates. Concrete use cases include refining variable bounds during static analysis and preprocessing annotations to simplify quantified conditions.",
      "description_length": 462,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides structured logging and configuration management for static analysis diagnostics, handling formatted messages, source positions, and logging categories with customizable severity levels. It supports dynamic configuration through boolean, integer, and string options, integrated with command-line interfaces and session-persistent state tracking. Use cases include controlling analysis behaviors like memory tracking, concurrency, and instrumentation, as well as managing diagnostic output, runtime flags, and warning categories with conditional emission.",
      "description_length": 574,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_array",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to generate C code for array equality or inequality comparisons and to translate runtime exception references in the context of array operations. It works with C expressions and environment structures to handle array comparisons and code annotations. Concrete use cases include generating intermediate C code for array equality checks and managing runtime exception handling during array processing.",
      "description_length": 430,
      "index": 875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translation_error",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines exception constructors and handlers for managing translation errors during static analysis. It works with result types and exceptions like `Typing_error`, `Not_yet`, and `Not_memoized`, tied to source locations. Functions support error propagation, handling, and formatting, specifically for translation phases in program analysis workflows.",
      "description_length": 361,
      "index": 876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Contract_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a `contract` type that represents function or statement contracts in C code, capturing their location, specification, and runtime behavior metadata. It includes operations to track named behaviors, associate behavior names with runtime indices, and manage translation status of contract clauses. This structure is used during static analysis to handle ACSL contract annotations, particularly for verifying assume, ensures, and behavior clauses in C functions.",
      "description_length": 479,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Varname",
      "library": "frama-c-e-acsl.core",
      "description": "Handles variable name generation for different scopes, providing functions to retrieve fresh names based on expressions, reset local name counters, and generate names within global, function, or block contexts. Works directly with Frama-C CIL expressions and string identifiers. Useful for generating unique variable names during program transformation or analysis passes.",
      "description_length": 372,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Contract",
      "library": "frama-c-e-acsl.core",
      "description": "This module processes ACSL contracts by translating them into C statements for runtime assertion checking. It operates on `E_ACSL.Contract_types.contract` values, which represent function or statement contracts, and modifies an `E_ACSL.Env.t` environment during translation. It is used to generate precondition and postcondition checks in C code based on ACSL annotations.",
      "description_length": 372,
      "index": 879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Assert",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages assertion contexts for runtime checks, providing operations to create, merge, and register data within these contexts. It supports data registration for expressions, terms, and predicates, and generates cleanup and runtime check statements tied to specific locations and kernel functions. Use cases include instrumenting C code with assertions that capture relevant data for verification, such as tracking expressions or logical constructs at specific program points.",
      "description_length": 487,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses",
      "library": "frama-c-e-acsl.core",
      "description": "Performs preprocessing and result management for E-ACSL translation analyses. It runs necessary analyses before translation and clears analysis results when needed. Works with internal E-ACSL data structures representing program annotations and analysis outcomes. Used during the translation phase of E-ACSL plugins to ensure analyses are correctly initialized and reset between uses.",
      "description_length": 384,
      "index": 881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Error",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines functions to create and raise exceptions for specific error scenarios during static analysis, such as typing errors, unsupported features, and incomplete computations. It works with exceptions, result types, and source code locations to handle and format errors with contextual information. Concrete use cases include enforcing typing rules, signaling unimplemented features, and managing partial results in analysis phases.",
      "description_length": 444,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_utils",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to translate logical properties and expressions into C code, handling type conversions, comparisons, and conditionals. It operates on data types such as `Property.t`, `term`, `exp`, `kernel_function`, and `Env.t`, with support for GMP integers and logic info structures. Concrete use cases include converting GMP values to `size_t` expressions with RTE checks, translating conditional logic into C expressions, and converting logic predicates and terms into C expressions using provided assertion contexts and environments.",
      "description_length": 554,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles GMP multi-precision values, providing initialization and type-checking operations. It works with `Frama_c_kernel.Cil_types.typ` to identify GMP integer and rational types, and includes functions to retrieve bit count types and initialize GMP usage. It is used in static analysis plugins to manage arbitrary-precision arithmetic types during program analysis and transformation.",
      "description_length": 397,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Main",
      "library": "frama-c-e-acsl.core",
      "description": "This module initializes and registers the E_ACSL plugin within the Frama-C kernel, enabling integration of runtime assertion checking features. It operates on Frama-C's internal plugin structures and does not expose any functions or data types for external use. A concrete use case is activating E_ACSL's instrumentation and evaluation capabilities during Frama-C analysis.",
      "description_length": 373,
      "index": 885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_build",
      "library": "frama-c-e-acsl.core",
      "description": "Constructs expressions and host values in an intermediate language using smart constructors. It supports building expression nodes from lvalues, integers, and sizeof operations, and converts CIL variables into symbolic host representations. Used during static analysis to programmatically generate and manipulate intermediate language terms tied to a specific type system.",
      "description_length": 372,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Widening",
      "library": "frama-c-e-acsl.core",
      "description": "Implements widening operations for interval and profile analysis in static program verification. It provides `widen` to compute an over-approximated interval merge and `widen_profile` to merge analysis profiles, both taking logic information and initial or accumulated states as inputs. These functions are used during fixed-point computations to accelerate convergence when analyzing loops or recursive functions.",
      "description_length": 414,
      "index": 887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Logic_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module generates C function implementations for logic functions based on argument types, handling overloading through type-specific prototypes. It translates logic terms and predicates into C expressions, using provided environments and assertion data, and inserts the resulting functions into a C file's global scope. It supports concrete use cases like compiling logic function calls with different integer types into appropriately typed C functions.",
      "description_length": 457,
      "index": 888,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Monad_rws",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements the RWS monad, combining reader, writer, and state effects into a single computational context. It supports operations like `read` for accessing an environment, `write` for logging, and `get`/`set`/`modify` for state manipulation, all while enabling composition of effectful functions. It is useful for tasks like configuration-driven processing where you need to read settings, update state, and accumulate logs\u2014such as parsing input files with context-sensitive rules and diagnostic output.",
      "description_length": 515,
      "index": 889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interval",
      "library": "frama-c-e-acsl.core",
      "description": "This module computes intervals for integer and real number terms in C programs, using type information and registered logic variable ranges. It provides operations to infer intervals for terms, check inclusion within types, and combine intervals from multiple terms. Concrete use cases include analyzing program expressions to determine value ranges for optimization or verification, such as ensuring arithmetic operations stay within bounds or validating annotations.",
      "description_length": 468,
      "index": 890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Literal_observer",
      "library": "frama-c-e-acsl.core",
      "description": "Replaces literal strings in C expressions with observed variables during analysis. Works with CIL expressions and environment mappings. Useful for tracking and substituting string literals in static analysis passes.",
      "description_length": 215,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_normalizer",
      "library": "frama-c-e-acsl.core",
      "description": "This module normalizes logical predicates and terms during preprocessing, handling transformations and mappings between original and generated logical entities. It operates on CIL types such as files, code annotations, predicates, and terms, maintaining bidirectional references to ensure accurate error reporting. Use cases include preparing logical expressions for analysis, resolving generated variables back to their original definitions, and ensuring consistency between source-level and internal representations of logic constructs.",
      "description_length": 538,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_aggr",
      "library": "frama-c-e-acsl.core",
      "description": "Handles aggregate type inspection in CIL types. Provides `get_array_typ_opt` to extract array type components and `get_t` to classify types as arrays, struct/unions, or non-aggregates. Useful for analyzing C array and struct declarations during static analysis.",
      "description_length": 261,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_annots",
      "library": "frama-c-e-acsl.core",
      "description": "This module translates ACSL annotations into C statements for runtime assertion checking, integrating them into the environment. It processes function preconditions, postconditions, and code annotations' preconditions and postconditions, working with kernel functions, statements, and the environment structure. It is used to generate executable checks from formal specifications embedded in C code.",
      "description_length": 399,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Assigns",
      "library": "frama-c-e-acsl.core",
      "description": "This module computes assignments for logic variables in a given environment, generating a list of expressions that represent the assigned values. It operates on logic variables and terms, using location and variable information from the CIL types. A concrete use case is extracting assignment expressions for a set of variables at a specific program point during static analysis.",
      "description_length": 379,
      "index": 895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Rte",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to retrieve runtime error (RTE) annotations for statements and expressions within a CIL-based analysis, specifically working with `kernel_function`, `stmt`, `exp`, and `code_annotation` types. It allows querying RTEs for specific code elements, with an option to enable or suppress warnings, and offers a way to obtain a state selection that includes RTE dependencies. Concrete use cases include analyzing potential runtime errors in C code during static analysis, such as division by zero or out-of-bounds array access, by inspecting the generated annotations for specific program points.",
      "description_length": 620,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Inductive",
      "library": "frama-c-e-acsl.core",
      "description": "Transforms inductive predicates into executable direct predicates, handling generalized Horn clauses. Processes `logic_info` and `term` types, with support for derived logic functions via a hash table. Used during translation to Cil, particularly for validating and converting inductive definitions that may generate fallthrough terms requiring failure assertions.",
      "description_length": 364,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Literal_strings",
      "library": "frama-c-e-acsl.core",
      "description": "This module maps string literals to unique variable identifiers, enabling tracking and retrieval of variables associated with specific string values. It provides operations to add, find, and fold over these associations, ensuring each string is bound to a single variable. Useful for analyses requiring string-based variable indexing, such as constant propagation or string interning.",
      "description_length": 384,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the intermediate language used during E-ACSL compilation, including expressions, binary operations, and variable handling. It supports translation from E-ACSL to Cil by maintaining structural fidelity with both source and target languages, using types like `exp`, `varinfo`, and `binop`. Concrete use cases include expression construction with origin tracking and variable creation for logic and Cil code generation.",
      "description_length": 436,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Temporal",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to enable temporal memory error detection, update environments for tracking referent numbers through function calls and statements, and generate tracking statements for global initializers. It operates on environments, CIL statements, kernel functions, and variable initializers. It is used to detect stale pointer dereferences by inserting tracking logic during analysis.",
      "description_length": 403,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Smart_stmt",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates C statements used in program transformation and analysis, particularly for instrumentation tasks. It supports operations like creating assignments, conditionals, function calls, and memory management statements for variables and structures. Specific use cases include generating code to initialize structs, assign field values, insert memory tracking calls, and build control flow constructs with precise location information.",
      "description_length": 465,
      "index": 901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines core datatypes and operations for static analysis in Frama-C, focusing on annotation kinds, predicates/terms, interval values, logic environments, and profiling structures. It supports precise manipulation of analysis-specific data such as annotated program states, function parameter intervals, and logic function profiles. Use cases include symbolic execution, range analysis, function bound tracking, and formal verification tasks requiring structured handling of logical expressions and abstract values.",
      "description_length": 527,
      "index": 902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Typed_number",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a function `add_cast` that converts number expressions to be compatible with a given typing context by applying appropriate type casts. It operates on expressions, types, and terms within a CIL-based environment, handling both string-represented numbers and native C number types. A concrete use case is ensuring correct type representation when generating or transforming C code during static analysis.",
      "description_length": 424,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_ats",
      "library": "frama-c-e-acsl.core",
      "description": "Translates E-ACSL `\\at()` terms and predicates into C expressions, handling both predicates and terms for statements within a function. Operates on `kernel_function`, `stmt`, `term`, and `predicate` types from Frama-C's CIL framework. Used to generate in-place or pre-translated C expressions for logical constructs, with support for memory management via `malloc` and `free` insertion.",
      "description_length": 386,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to analyze and manipulate CIL expressions and logic terms, particularly for handling \\result variables, checking variable properties, extracting base pointers, and working with logic types and terms. It operates on CIL data types such as kernel_function, varinfo, exp, term, and logic_type, often interacting with low-level constructs like bitfields, pointer arithmetic, and logic expressions. Concrete use cases include extracting lvalues from expressions, determining if a term contains C variables, checking if a type is a set of pointers, and retrieving the base address of a pointer expression.",
      "description_length": 630,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Bimap",
      "library": "frama-c-e-acsl.core",
      "description": "Implements a bijective hash map using two hash tables, enabling efficient bidirectional lookups. Supports operations to add key-value pairs, retrieve values in either direction, and manage chains of mappings via head and tail. Suitable for symbol table management and bidirectional data synchronization scenarios.",
      "description_length": 313,
      "index": 906,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Injector",
      "library": "frama-c-e-acsl.core",
      "description": "Injects monitoring code into a program to enforce and check runtime assertions specified in E-ACSL annotations. Works directly on the program's abstract syntax tree, modifying it to include checks for memory safety, preconditions, postconditions, and loop invariants. Used during the instrumentation phase of E-ACSL-enabled programs to enable runtime verification of formal specifications.",
      "description_length": 389,
      "index": 907,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Libc",
      "library": "frama-c-e-acsl.core",
      "description": "Handles memory modeling for libc functions during code generation. It identifies functions that write to memory and updates the memory model accordingly after their execution. Used to track memory effects of calls like `memcpy` or `memset` in generated code.",
      "description_length": 258,
      "index": 908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_trans",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a function `try_il_compiler` that attempts to compile E-ACSL expressions using a new intermediate language-based approach, falling back to a direct-to-Cil compiler if the new method fails. It operates on E-ACSL expressions and works with compilers that produce Cil output. A concrete use case is compiling E-ACSL predicates into Cil expressions during the translation phase of a verification toolchain.",
      "description_length": 423,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Typing",
      "library": "frama-c-e-acsl.core",
      "description": "This module computes minimal C types and necessary casts for integer expressions and predicates through interval analysis, determining optimal type representations and coercion points to prevent overflow. It operates on Frama-C logic terms and code annotations, mapping C types to internal numeric representations while leveraging interval inference to resolve type joins and GMP requirements. A key use case involves statically optimizing arithmetic operations\u2014like safely downcasting results of expressions such as `1 + (x + 1) / (y - 64)` to narrower types while inserting explicit GMP conversions where overflow risks exist.",
      "description_length": 628,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Smart_exp",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates CIL expressions for low-level memory operations, logical negation, and pointer arithmetic. It operates on expressions and types from the CIL framework, including lvals, pointers, and variables. Concrete use cases include building expressions for array subscripting, pointer dereferencing, logical not operations, and generating NULL pointer constants.",
      "description_length": 390,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Lscope",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic scopes by providing operations to add, remove, and check the presence of scope variables within a scope. It supports data types representing analysis scopes (`t`) and scope variables (`lscope_var`), with functions to manipulate and query their contents. Concrete use cases include tracking variable bindings during static analysis and ensuring correct scope management when processing logical predicates or terms.",
      "description_length": 439,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Loops",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles loop-specific transformations and annotations in CIL code, primarily by modifying loop statements to include checks for loop invariants and variants. It supports the creation of nested loops with associated logic variables and initialization statements, using a provided location and environment. It also provides references to functions that translate logical predicates and terms into C expressions, operating within a given function and environment context.",
      "description_length": 480,
      "index": 913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Prepare_ast",
      "library": "frama-c-e-acsl.core",
      "description": "This module prepares the abstract syntax tree (AST) for E-ACSL translation, ensuring proper setup for instrumentation. It introduces a global variable to track the soundness of E-ACSL verdicts and provides a hook to identify libc variables involved in memory references. It is used during the initial phase of E-ACSL plugin execution to configure the AST before generating instrumentation code.",
      "description_length": 394,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_predicates",
      "library": "frama-c-e-acsl.core",
      "description": "This module converts ACSL predicates into C expressions for runtime checking, translating them into forms valid in specific contexts. It handles untyped predicates and integrates with environment tracking to maintain state during translation. Use cases include generating runtime assertions from formal specifications and embedding predicate checks into C code for verification purposes.",
      "description_length": 387,
      "index": 915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manipulates environments for static analysis and formal verification workflows, focusing on scoped variable introduction, logic binding management, and structured handling of analysis parameters like RTE generation or loop invariants. It operates on environments (`t`), logic variables, CIL types, and annotated statements, supporting error-tolerant execution through context saving and scoped parameter changes. Key use cases include inserting assertions, managing contracts, and pretty-printing environment states during C program analysis with logic annotations.",
      "description_length": 577,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a monadic framework for generating intermediate language expressions during E-ACSL translation, supporting operations for managing environment, state, and side-channel output. It works with `env`, `state`, and `out` types to handle configuration, mutable state, and logging respectively, while providing structured control flow for expression generation. Concrete use cases include conditionally emitting expressions based on boolean checks, accumulating generated code fragments, and handling optional or list-valued components during translation.",
      "description_length": 569,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_terms",
      "library": "frama-c-e-acsl.core",
      "description": "This module converts E-ACSL terms into C expressions or intermediate language expressions, handling typed and untyped terms with support for in-place translation. It operates on ACSL terms, kernel functions, and environments, producing CIL expressions or intermediate language structures. Use cases include generating C implementations of logical assertions and translating terms for analysis or instrumentation.",
      "description_length": 412,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Global_observer",
      "library": "frama-c-e-acsl.core",
      "description": "This module tracks global variables and manages their observation throughout a program's lifecycle. It provides functions to add variables for observation, handle their initializers, and generate C functions for initializing and cleaning up observers. It works directly with CIL types like `varinfo`, `offset`, and `init`, and is used to inject instrumentation code for global variable monitoring in generated C code.",
      "description_length": 417,
      "index": 919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Builtins",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a database of E-ACSL built-in functions, providing operations to check existence (`mem`), retrieve (`find`), and update (`update`) their associated variable information. It works directly with string identifiers and `varinfo` structures from the Frama-C CIL library. It is used during analysis to access and modify metadata for built-in functions recognized by the E-ACSL runtime.",
      "description_length": 400,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp",
      "library": "frama-c-e-acsl.core",
      "description": "This module directly interfaces with GMP to generate initialization, assignment, and cleanup statements for CIL expressions and lvals based on their types. It handles both integer (`mpz_t`) and rational (`mpq_t`) types, selecting appropriate GMP functions such as `mpz_init`, `mpq_set`, or `mpq_clear`. It is used to manipulate arbitrary-precision numbers in C code during static analysis, particularly for formal verification tasks involving precise arithmetic in ACSL annotations.",
      "description_length": 482,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_rtes",
      "library": "frama-c-e-acsl.core",
      "description": "Translates RTE annotations into runtime checks for a given function and environment. Works with CIL types and environments to generate code annotations that enforce runtime assertions during program execution. Useful for integrating runtime verification into C programs by converting high-level annotations into executable checks.",
      "description_length": 330,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_observer",
      "library": "frama-c-e-acsl.core",
      "description": "This module manipulates memory tracking information by inserting calls to memory management functions into the environment. It operates on variables and sets of variables, adding instrumentation for memory allocation and deallocation. It is used to track memory blocks associated with specific variables during analysis.",
      "description_length": 320,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides static analysis, translation, and instrumentation capabilities for handling logical and memory-related constructs in C programs. It operates on CIL-based data structures, intermediate language representations, and ACSL annotations to perform tasks like assertion enforcement, interval analysis, memory safety translation, and program transformation. Key use cases include generating executable code from formal specifications, optimizing type representations, and managing analysis state for fixed-point computations using techniques like interval widening.",
      "description_length": 578,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Users.Users_register",
      "library": "frama-c-users.core",
      "description": "Registers and analyzes user-defined functions related to user behavior tracking. It processes kernel functions to identify and collect entry points associated with user registration flows. Use this module to trace registration logic across complex call graphs in static analysis of authentication systems.",
      "description_length": 305,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Users",
      "library": "frama-c-users.core",
      "description": "Handles analysis of user registration flows by tracing entry points and behavior tracking functions across call graphs. Works with kernel functions and user-defined logic to map registration pathways in authentication systems. Useful for identifying registration-related code in static analysis of security-critical applications.",
      "description_length": 329,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_types.Make",
      "library": "frama-c-eva.gui",
      "description": "This module implements operations for pretty-printing, comparing, and extracting variable information from GUI result and after states, specifically working with types that depend on an abstract value representation. It provides functions to convert between custom abstract values and Frama-C's Cvalue type, along with equality checks and formatting utilities. Concrete use cases include displaying analysis results in a user interface and tracking variable involvement in program states.",
      "description_length": 488,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.Make",
      "library": "frama-c-eva.gui",
      "description": "This module provides functions to evaluate l-values, expressions, terms, and predicates across multiple callstacks, producing results such as offset maps, value bounds, and computation results. It works with abstract domains, CIL types like lval, exp, term, and predicate, and evaluation environments tied to specific locations. Concrete use cases include analyzing program state at different callstack levels, evaluating memory zones for l-values, and computing predicate truth values in a symbolic execution context.",
      "description_length": 518,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_types.GCallstackMap",
      "library": "frama-c-eva.gui",
      "description": "This module implements an ordered associative map structure for managing associations between GUI callstack keys and arbitrary values, supporting insertion, deletion, ordered traversal, and bulk sequence operations. It provides both equality-preserving and physical identity-based key comparisons, with specialized functions for list-valued maps, range queries, and bidirectional sequence conversions. Typical use cases include tracking hierarchical callstack relationships in GUI components, maintaining ordered state mappings during program analysis, and efficiently transforming or filtering large sets of callstack-bound data.",
      "description_length": 630,
      "index": 929,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_callstacks_manager",
      "library": "frama-c-eva.gui",
      "description": "Manages the \"Values\" panel in the GUI's lower notebook, displaying analysis results for selected expressions and lvalues based on callstacks. It provides functions to create, reset, and update the panel's content, returning a display function to show data structured by callstack. Useful for visualizing abstract interpretation results in a tabular format filtered by user-selected callstacks.",
      "description_length": 393,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_types",
      "library": "frama-c-eva.gui",
      "description": "This module defines core data types and operations for representing and manipulating GUI-specific analysis artifacts such as callstacks, selections, offset maps, and locations. It includes variants for structured callstack handling, precise value and location tracking, and semantic comparison and formatting functions. These types directly support use cases like visualizing program analysis states, managing hierarchical callstack data in GUI components, and performing precise value comparisons and transformations during static analysis.",
      "description_length": 541,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_callstacks_filters",
      "library": "frama-c-eva.gui",
      "description": "This module provides functions to filter and match analysis callstacks based on structured criteria. It works with `rcallstack` values built from `Eva.Callstack.t` and supports operations like checking if a callstack or a statement matches a filter, focusing on specific callstacks, and determining reachability or non-termination of statements. Concrete use cases include narrowing down displayed callstacks in a GUI and determining statement visibility based on callstack filters.",
      "description_length": 482,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates l-values, expressions, terms, and predicates across multiple callstacks, producing results such as offset maps, value bounds, and predicate evaluations. It operates on CIL types like `lval`, `exp`, `term`, and `predicate`, using evaluation environments tied to specific program locations. Concrete use cases include analyzing program state at different callstack levels, evaluating memory zones for l-values, and determining predicate truth values during symbolic execution.",
      "description_length": 496,
      "index": 933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Register_gui",
      "library": "frama-c-eva.gui",
      "description": "This module extends the graphical user interface to integrate visualization and interaction capabilities specific to value analysis. It handles data types related to analysis states, variable bindings, and evaluation contexts. Concrete use cases include rendering analysis results in a user-friendly format and enabling step-by-step exploration of program execution states.",
      "description_length": 373,
      "index": 934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_red",
      "library": "frama-c-eva.gui",
      "description": "Implements a GUI extension to display red alarms generated during value analysis. Adds a dedicated tab to the main interface using `make_panel`, which integrates with the Frama-C GUI framework. Useful for visualizing critical runtime errors directly within the analysis environment.",
      "description_length": 282,
      "index": 935,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui",
      "library": "frama-c-eva.gui",
      "description": "This module integrates value analysis visualization and interaction features into the Frama-C GUI. It supports filtering and display of analysis callstacks, evaluation of program expressions across callstacks, and presentation of analysis results in structured panels. Concrete use cases include narrowing callstack views, visualizing abstract interpretation states, and displaying red alarms and evaluated expression values during static analysis.",
      "description_length": 448,
      "index": 936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters in the context of the Why3 flag system. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of these parameters, ensuring proper handling of their values. It is used to manage and manipulate string representations of Why3-related configuration options within the WP plugin.",
      "description_length": 402,
      "index": 937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Var",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical variables in the context of the WP plug-in's low-level logic language. It provides operations to compare, hash, and pretty-print variables, as well as access their base names and associated logic sorts. Concrete use cases include variable management during theorem proving and debugging of logical expressions.",
      "description_length": 357,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a plugin interface, providing operations for equality checks, comparison, hashing, and pretty-printing. It works with a custom type `t` representing string parameter values, along with associated descriptors and project membership checks. Concrete use cases include managing and manipulating string configuration options passed via the command line, ensuring deep copies and proper project-specific filtering.",
      "description_length": 497,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Tau",
      "library": "frama-c-wp.core",
      "description": "This module implements operations for managing and manipulating logical terms in the Qed-based logic language, specifically handling term comparison, hashing, and string representation. It works with the `t` type, representing logical terms, and provides concrete functionality for pretty-printing, debugging, and generating fresh variable names. Useful in contexts like theorem proving, term rewriting, and symbolic reasoning where term identity and structure are critical.",
      "description_length": 474,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a collection, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with `Project.t` values through membership checks and deep copying, ensuring no shared references. Concrete use cases include managing and comparing string parameters in the WP plugin's command-line interface.",
      "description_length": 408,
      "index": 941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.STset",
      "library": "frama-c-wp.core",
      "description": "This structure provides ordered set operations over logical terms, supporting efficient insertion, deletion, and algebraic manipulations like union and intersection. It emphasizes ordered traversal, deterministic element selection, and predicate-based filtering, working with structural sets that maintain element ordering via a dedicated comparator. Use cases include symbolic reasoning tasks requiring ordered enumeration, set transformations with functional predicates, and sequence-based conversions for iterative processing.",
      "description_length": 529,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Vars",
      "library": "frama-c-wp.core",
      "description": "This module offers set-theoretic operations for managing collections of logical variables, including union, intersection, difference, and transformations via mapping or filtering. It operates on variable sets represented as functional data structures with immutable semantics, designed for precise manipulation of symbolic terms in formal verification contexts. Typical applications involve tracking or analyzing variable dependencies in proof obligations, symbolic execution, or logical formula simplification.",
      "description_length": 511,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string parameters in the context of function timeout settings. It supports operations like equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate string-based configuration values within the WP plugin's parameter system.",
      "description_length": 363,
      "index": 944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides standard operations like equality, comparison, hashing, and pretty-printing for this type, along with functions for deep copying and checking membership based on project properties. It is used to represent and manipulate string configuration values that may be tied to specific analysis projects.",
      "description_length": 407,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in a persistent and project-aware manner. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to manage string configuration values that may be associated with different analysis projects.",
      "description_length": 372,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Map.Key",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for keys used in a map structure, providing essential operations including equality, comparison, hashing, and pretty-printing. It supports working with project-specific values through membership testing and deep copying, ensuring no shared references. Concrete use cases include managing and comparing symbolic keys in map-based data structures, particularly for analysis tasks within the WP plug-in.",
      "description_length": 432,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of string parameter values, along with support for project membership testing. The module works directly with string values and integrates with project management logic to support analysis configuration and state tracking.",
      "description_length": 420,
      "index": 948,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a context, providing operations for equality, comparison, hashing, and pretty-printing. It supports structured data management with functions to check project membership, deep copy values, and access type descriptors. Concrete use cases include parsing and managing string configuration options in the WP plugin, ensuring consistent handling of parameter values across different analysis contexts.",
      "description_length": 485,
      "index": 949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.STmap",
      "library": "frama-c-wp.core",
      "description": "This implementation provides ordered map operations for Qed logic terms, including dictionary functions like insertion, lookup, and removal, specialized list-value handling via `add_to_list`, and structural merges with non-linear complexity. It manages maps with Qed terms as keys and arbitrary value types, supporting efficient physical equality checks, ordered traversal, and functional transformations that preserve structural integrity. Designed for scenarios requiring precise structural manipulation of term-based mappings\u2014such as logical context management or proof state tracking in formal verification workflows\u2014where ordered processing and structural consistency outweigh strict merge performance demands.",
      "description_length": 715,
      "index": 950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Term",
      "library": "frama-c-wp.core",
      "description": "Handles equality, comparison, and pretty-printing for low-level logic terms in the Qed-based language. Operates directly on `t` values, which represent logical expressions and predicates. Useful for debugging solvers or analyzing term structures during formal verification tasks.",
      "description_length": 279,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in a WP plugin context. It supports operations like equality checks, comparison, hashing, and pretty-printing for string values, along with deep copying and project membership testing. It is used to represent and manipulate string parameters in a type-safe and structured way, particularly for configuration or input parsing tasks.",
      "description_length": 412,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based configuration parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project-related structures, enabling the management of command-line options that require string values. Concrete use cases include parsing and storing configuration settings such as file paths, identifiers, or user-defined options passed via the command line.",
      "description_length": 472,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, and pretty-printing of parameter values, along with deep copying and project membership testing. It works with a custom type `t` representing string parameters, supporting their manipulation and introspection within the plugin's configuration system.",
      "description_length": 415,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of string parameter values, along with support for project membership testing. The module works with a concrete type `t` representing string parameters, including their descriptors and representants, and is used to manage and manipulate string configuration options within the WP plugin's parameter system.",
      "description_length": 504,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports efficient lookups, deep copying, and project membership checks, making it suitable for managing structured data in analysis plugins. Concrete use cases include tracking variable states or function summaries in static analysis.",
      "description_length": 417,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Map.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements a map data structure indexed by the `Data` module's type, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports map manipulation with functions for membership testing, deep copying, and project-based filtering through `mem_project`. Concrete use cases include managing collections of values with unique keys, performing efficient lookups, and maintaining structured data in analyses requiring key-value associations.",
      "description_length": 484,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl.Key",
      "library": "frama-c-wp.core",
      "description": "This module defines a key type for use in a hashtbl, including operations for equality, comparison, hashing, and pretty printing. It supports data types involving project-specific keys with functions to check membership based on project properties and to create deep copies. Concrete use cases include managing and querying keys tied to specific analysis projects within a hashtable structure.",
      "description_length": 393,
      "index": 958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based tactic parameters in the WP plugin, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with project-specific values through membership checks and deep copying, ensuring proper isolation between instances. Concrete uses include managing configurable string parameters that interact with Frama-C's project system and command-line interface.",
      "description_length": 451,
      "index": 959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing string-based prover parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, and pretty-printing values of this type, along with utilities for project membership testing and deep copying. It is used to handle command-line parameters that represent prover configurations as strings.",
      "description_length": 367,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Tset",
      "library": "frama-c-wp.core",
      "description": "This module offers a high-performance set structure for QED terms, supporting operations like membership testing, union, intersection, difference, and functional transformations such as mapping and filtering. It leverages machine-dependent comparisons for efficiency, making it ideal for symbolic reasoning tasks like automated theorem proving or logical expression manipulation where rapid set operations and term comparisons are critical. The implementation prioritizes speed over structural equality, enabling efficient handling of large-scale term sets in performance-sensitive workflows.",
      "description_length": 592,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters within a plugin interface, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a custom type `t` that represents parameter values, along with project-aware predicates and deep copying. Concrete use cases include managing and querying string parameters during static analysis, such as storing and comparing user-provided options or configuration values.",
      "description_length": 482,
      "index": 962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project-related structures through functions like `mem_project` and `copy`. Concrete use cases include managing and comparing string configuration values, checking project membership, and formatting parameter values for display.",
      "description_length": 440,
      "index": 963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Subst",
      "library": "frama-c-wp.core",
      "description": "Manages term substitutions and variable bindings in a logical context, providing operations to add, find, and filter terms based on a pool of variables. Works directly with logical terms, variables, and substitution environments defined in the underlying logic system. Useful for implementing rewriting rules, term simplification, and variable management in formal verification tasks.",
      "description_length": 384,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Tmap",
      "library": "frama-c-wp.core",
      "description": "This module provides polymorphic map operations using Qed logic terms as keys, supporting associative operations like insertion, lookup, and deletion alongside advanced combinators for merging, filtering, and key-aware transformations. It works with structured maps of typed keys and values, enabling efficient merges with custom strategies, subset checks, and in-place updates. Optimized for performance, it is suited for logic term analysis tasks requiring fast comparisons and non-structural key-driven processing.",
      "description_length": 517,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of parameter values, along with utilities for inspecting and filtering based on project skeletons. It works directly with string representations of parameters and supports concrete use cases like parsing and displaying WP-specific command-line options.",
      "description_length": 450,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Vmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a polymorphic map structure keyed on logical variables, supporting associative operations like union, intersection, and conditional updates with optional values. It enables precise manipulation of variable-indexed data through transformations such as differential merging, subset analysis, and key-specific value combinators. Typical applications include managing logical term environments, propagating constraints across variable bindings, and implementing symbolic reasoning algorithms within verification workflows.",
      "description_length": 541,
      "index": 967,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in command-line parameters within the WP plugin. It supports structured data handling with capabilities for deep copying, membership testing in projects, and includes descriptors for type representation and serialization. Concrete use cases include managing parameter values passed to the WP plugin during analysis, ensuring consistent handling of complex data types across different analysis contexts.",
      "description_length": 536,
      "index": 968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptOnStdout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports integration with Frama-C's project management by providing a `mem_project` function to check for embedded project values. The type is used to represent and manipulate script output configurations within the WP plugin's analysis framework.",
      "description_length": 421,
      "index": 969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheEnv.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in caching environments. It supports structured data representation with a descriptor, a list of representatives, and project membership checks via `mem_project`. The type is used to manage and manipulate cache entries with deep copying and project-specific queries.",
      "description_length": 400,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, along with utilities for project membership checks and deep copying. It works with a concrete type `t` that represents a command-line parameter datatype, including its descriptor, name, and representants. Use cases include managing and manipulating parameter values in a type-safe manner, ensuring deep equality checks, and formatting output for user display.",
      "description_length": 459,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitSwitch.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values within the WP plugin's split switch functionality. It supports structured data handling with a descriptor, packed representation, and a list of representatives for the type. The module enables deep copying, project membership checks, and user-friendly value display, used to manage WP-specific configuration or state data in a type-safe manner.",
      "description_length": 501,
      "index": 972,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ExternArrays.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values in the context of the WP plugin, specifically for handling external arrays. It provides operations for equality checking, comparison, hashing, deep copying, and pretty printing, along with support for querying values based on project membership. The type is used to manage and reason about array data structures within the WP analysis, enabling precise value representation and transformation during verification tasks.",
      "description_length": 501,
      "index": 973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with operations for setting values, validation through whitelisting, and project-specific state tracking via hooks and aliases. It works with string parameters that support custom marshaling, default values, and integration into Frama-C's parameter system. Use cases include configuring analysis plugins, enforcing constrained input options, and persisting project-aware settings across sessions.",
      "description_length": 453,
      "index": 974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitBranch.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in the WP plugin's split branch functionality. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Use cases include managing and comparing complex data structures during program analysis, such as tracking and splitting branches in abstract interpretation.",
      "description_length": 501,
      "index": 975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyType.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's type simplification system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient type analysis and transformation. Concrete use cases include managing and comparing complex type structures during static analysis and ensuring deep copies for project-specific data manipulations.",
      "description_length": 489,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating parameter descriptors in the WP plugin. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to handle command-line parameters with structured data types, enabling robust parsing, storage, and querying of plugin configuration options.",
      "description_length": 402,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcode.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's smoke and deadcode analysis. It supports structured data representation with a descriptor, packed type information, and project membership checks. Concrete use cases include managing analysis states, tracking project-specific values, and ensuring deep copying for correctness during static analysis phases.",
      "description_length": 453,
      "index": 978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ProofTrace.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating proof trace elements within the WP plugin. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to handle structured data in proof traces, enabling precise analysis and transformation of verification results.",
      "description_length": 376,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to plugin parameters, enabling fine-grained control over command-line behavior. Concrete use cases include setting default parameter behavior, enabling all parameters under a specific interpretation, and defining dependencies for category activation.",
      "description_length": 473,
      "index": 980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and integrates accessors and state lists to control parameter behavior. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific access rules, and aliasing the `@all` category to another category.",
      "description_length": 459,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with validation, alias handling, and change tracking, operating on a custom string type `t`. It supports use cases like configuring plugin settings through validated function names or plain strings, while enabling introspection and serialization for parameter state management. Key operations include value registration, hook attachment, and safe retrieval with contextual validation rules.",
      "description_length": 447,
      "index": 982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitMax.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling integration with Frama-C's project management features. Use cases include defining and manipulating parameter types for static analysis configurations, such as splitting strategies or max iteration limits, with deep copying and persistence capabilities.",
      "description_length": 526,
      "index": 983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Interactive.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for interactive parameters in the WP plugin. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise handling of parameter states across different projects. Use cases include managing and comparing plugin-specific configuration values, ensuring deep copies for state isolation, and displaying user-friendly representations of complex types.",
      "description_length": 533,
      "index": 984,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StrategyEngine.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's strategy engine. It supports structured data representation with descriptors, packed descriptors, and a list of representative values, enabling introspection and manipulation of complex types. Concrete use cases include managing and comparing strategy configurations, checking project membership, and ensuring deep copies for safe data transformation.",
      "description_length": 491,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Let.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and project membership checks, enabling precise type manipulation and introspection. Use cases include defining and managing parameterized types within the WP plugin's logic, such as handling abstract values, constraints, or symbolic expressions tied to specific projects.",
      "description_length": 541,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Cache.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manage cached values in the WP plugin. It supports structured data handling with functions to check membership in projects, perform deep copies, and describe values using a type descriptor. Concrete use cases include managing symbolic representations and ensuring consistent value identity during theorem proving tasks.",
      "description_length": 458,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line configuration parameters with support for default values, change hooks, and validation against constraints or naming rules. It operates on string values and project-specific data structures, enabling use cases like persistent configuration storage, dynamic parameter updates, and enforcing input validity during CLI parsing. The module also handles aliases and serialization, ensuring consistent state management across projects.",
      "description_length": 475,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic type `t` and standard operations including equality, comparison, hashing, and pretty-printing. It supports working with command-line parameters by providing descriptors, representations, and project membership checks. Useful for managing typed parameter collections in a plugin context, such as handling user inputs or configuration values with rich structural operations.",
      "description_length": 406,
      "index": 989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Print.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate structured data within the WP plugin. It supports integration with Frama-C's project management features through the `mem_project` function, which checks for embedded project values. The type is used to store and manage parameter representations that are persisted or shared across analyses.",
      "description_length": 441,
      "index": 990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeMargin.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing time margins in the WP plugin, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with a concrete type `t` that encapsulates time margin values, and includes functions for deep copying, membership testing in projects, and handling type descriptors. Use cases include configuring and managing time-based constraints within the WP analysis framework, such as setting timeouts or scheduling proof tasks.",
      "description_length": 498,
      "index": 991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating a specific datatype used in command-line parameter handling, including equality, comparison, hashing, and pretty-printing. It works with a polymorphic type `t` and structures like lists, descriptors, and formatters. Concrete uses include checking membership within projects, deep copying values, and comparing or printing datatype instances for configuration or analysis purposes.",
      "description_length": 441,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to plugin parameters, allowing the association of states and dependencies with named categories. Concrete use cases include setting up default parameter behavior, enabling all parameters under a specific interpretation, and defining how the `@all` category behaves in different contexts.",
      "description_length": 507,
      "index": 993,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.RunAllProvers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports working with project-specific values through membership testing and deep copying. Concrete use cases include managing and comparing prover configurations and ensuring value integrity during analysis passes.",
      "description_length": 337,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WeakIntModel.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling weak integer model parameters in the WP plugin. It supports structured data representation with descriptors, packed descriptions, and project membership checks, ensuring deep copying and project-specific queries. Concrete use cases include managing and comparing parameter configurations during static analysis, particularly for tracking and validating integer model behaviors across different analysis contexts.",
      "description_length": 537,
      "index": 995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AliasInit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copying and ensuring no shared state. Concrete use cases include managing and comparing complex parameter types within the WP plugin's analysis framework.",
      "description_length": 452,
      "index": 996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Heap.Set",
      "library": "frama-c-wp.core",
      "description": "This module provides standard set operations for managing collections of heap-allocated elements, including membership checks, union/intersection/difference operations, and transformations via mapping or filtering. It works with sets built over `Wp.Sigma.Heap.t` values, supporting both unordered and ordered traversal while preserving structural invariants during conversions from lists or element transformations. Typical use cases involve analyzing or manipulating memory states in program verification tasks where heap-allocated chunks require precise set-theoretic reasoning.",
      "description_length": 580,
      "index": 997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and integrates accessors and state lists to control parameter behavior. Concrete use cases include setting default category behavior, enabling all parameters with specific interpretations, and creating named categories with dependencies.",
      "description_length": 446,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadloop.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Use cases include defining and managing parameter types within the WP plugin, particularly for scenarios involving project membership checks and deep copying of parameter values.",
      "description_length": 508,
      "index": 999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and integrates accessors from `Frama_c_kernel.Parameter_category`. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a specific interpretation, and defining dependencies for category activation.",
      "description_length": 448,
      "index": 1000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Init.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type handling and serialization. Concrete use cases include managing and comparing complex parameter values in static analysis tasks, such as tracking project-specific data through transformations and ensuring deep copies for safe manipulation.",
      "description_length": 538,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusFalse.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a specific data type used within the WP plugin for representing and manipulating values related to proof statuses. It includes standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. The type is used to manage and reason about proof outcomes in a structured and efficient manner.",
      "description_length": 388,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based timeout configurations through operations for value assignment, alias resolution, and validation of allowed inputs, while supporting hooks to track changes and ensure consistency. It operates on string parameters and command-line arguments, enabling use cases like runtime configuration updates and persistent state management across project sessions. The design emphasizes extensible data handling for scenarios such as dynamic parameter adjustments and serialization of project-specific settings.",
      "description_length": 531,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for function timeout settings in the WP plugin, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types that encapsulate parameter accessors and dependency lists, allowing configuration of timeout behavior across different analysis states. Concrete use cases include enabling timeout parameters globally via `@all`, setting a default fallback category, or defining custom categories with specific accessors and dependencies.",
      "description_length": 549,
      "index": 1004,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitCNF.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's SplitCNF functionality. It supports structured data representation with descriptors, packed representations, and a list of exemplars for type inspection. The type is used to manage and manipulate logical formula representations during theorem proving tasks within the WP plugin.",
      "description_length": 431,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyLandMask.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for representing and manipulating values used in the simplification of land mask parameters. It supports equality checks, comparison, hashing, pretty-printing, deep copying, and project membership testing through predicate functions. The type is integrated with Frama-C's project and structural descriptor systems, enabling use in contexts requiring type representation, persistence, or user interaction.",
      "description_length": 452,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Detect.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports working with project-specific data through a descriptor, a packed representation, and a list of representatives. The module enables checking membership within projects using custom predicates and provides deep copying to ensure data isolation.",
      "description_length": 363,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CachePrint.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in caching and project management contexts. It supports structured data representation with descriptors, packed types, and project membership checks. Concrete use cases include managing and comparing complex data structures in the WP plugin's analysis pipeline.",
      "description_length": 395,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating a specific datatype used in command-line parameter handling, including equality checks, comparison, hashing, and pretty printing. It works with a custom type `t` that represents parameter data, along with project-related structures through functions like `mem_project`. Concrete use cases include deep copying parameter values, checking membership within projects, and formatting values for user output.",
      "description_length": 464,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameter collections, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to parameter elements, allowing configuration of how parameters are grouped and interpreted. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a specific interpretation, and defining dependencies for category activation.",
      "description_length": 489,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TerminatesVariantHyp.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling termination variant hypotheses in the WP plugin. It supports structured data representation with type-safe descriptors, deep copying, and project membership checks. Concrete use cases include managing and comparing variant hypothesis data during proof generation and verification tasks.",
      "description_length": 424,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line configuration, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with `elt` elements and `t` category types, supporting dynamic category creation with dependencies and accessors. Concrete use cases include enabling all parameters under a category, setting default category behavior, and defining how categories interact with command-line flags.",
      "description_length": 466,
      "index": 1012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Report.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing command-line parameter values in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a polymorphic type `t` and includes descriptors for type representation, along with functions to manage project membership and perform deep copies. Concrete use cases include handling and comparing parameter values during plugin execution and formatting them for user output.",
      "description_length": 472,
      "index": 1013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptMode.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in script mode parameters of the WP plugin. It supports structured data representation with descriptors, packed representations, and deep copying to ensure value integrity. Concrete use cases include managing and manipulating script-specific data types in a type-safe manner during analysis configuration.",
      "description_length": 439,
      "index": 1014,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.CounterExamples.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing counterexamples in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It works with structured data involving project skeletons and supports deep copying and membership checks within projects. Concrete use cases include managing and analyzing counterexample data during program verification tasks.",
      "description_length": 387,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeExtra.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks for project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing complex configuration or state values within the WP plugin.",
      "description_length": 377,
      "index": 1016,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.QED",
      "library": "frama-c-wp.core",
      "description": "This module implements a logical core language with operations for constructing and analyzing terms, managing binders and substitutions, and optimizing symbolic reasoning. It operates on terms, variables, binders, and structured collections like sets and maps, supporting typed first-order logic expressions with arithmetic, boolean operations, and quantifiers. Key use cases include formal verification of programs, theorem proving via logical connectives and term rewriting, and optimizing term manipulation through sharing analysis and substitution management.",
      "description_length": 563,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with validation, default handling, and alias management, supporting operations to set, query, and observe state changes through hooks. It works with a custom string type `t` representing configuration options, alongside data structures for allowed values, validation rules, and project-specific state tracking. Use cases include configuring static analysis plugins via command-line arguments, validating inputs against predefined function names or literals, and serializing parameter states for persistent storage or cross-component communication.",
      "description_length": 604,
      "index": 1018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage string-based command-line parameters, including setting allowed values, validation through whitelisting and function name checks, handling aliases, and registering update hooks. It works with string parameters that support default values, lifecycle tracking, and project-specific state management. Use cases include configuring plugin options, enforcing parameter constraints via validation rules, and dynamically managing parameter values in command-line interfaces.",
      "description_length": 509,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Ground.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed representations, and deep copying, ensuring values can be uniquely identified and manipulated safely. It is used to manage parameter values within the WP plugin, enabling features like project membership checks and serialization.",
      "description_length": 468,
      "index": 1020,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StatusAll.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating status values within the WP plugin. It supports integration with Frama-C's project system through a `mem_project` function that checks for the presence of project-related values. The type is used to manage and track the status of proof obligations across different analysis sessions.",
      "description_length": 443,
      "index": 1021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheDir.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in caching directory-related information within the WP plugin. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient storage and retrieval. Concrete use cases include managing and comparing directory structures during static analysis sessions.",
      "description_length": 448,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusTrue.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured values tied to project analysis, enabling checks for project membership via predicates and providing deep copying to ensure value independence. Use cases include managing and comparing analysis states or configurations within the WP plugin.",
      "description_length": 376,
      "index": 1023,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Literals.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating a specific datatype used within the WP plugin, including equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` and supports operations like deep copying, membership testing in projects, and handling of type descriptors. Concrete use cases include representing and comparing symbolic values in the WP context, such as logical expressions or program states, and ensuring consistent handling across different modules.",
      "description_length": 516,
      "index": 1024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Parasite.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling deep copying and ensuring no shared state. Concrete use cases include managing and comparing complex parameter configurations within the WP plugin's analysis framework.",
      "description_length": 454,
      "index": 1025,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Sigma.Heap.Map",
      "library": "frama-c-wp.core",
      "description": "This module implements a map structure with keys organized as heap chunks and polymorphic values, supporting associative operations like insertion, lookup, and value transformation alongside set-like union, intersection, and difference. It provides both ordered and unordered traversal for heap-structured data, enabling use cases such as symbolic execution state management and static analysis of memory models where precise key-value associations over heap regions are required. Custom merging and filtering functions allow fine-grained control over value updates and domain-specific comparisons.",
      "description_length": 598,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in command-line parameters within a plugin system. It supports structured data representation with descriptors, type information, and project membership checks, enabling deep copying and user-friendly output formatting. Concrete use cases include managing and validating plugin-specific configuration types during command-line parsing and project analysis.",
      "description_length": 490,
      "index": 1027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in the WP plugin, providing operations to define, retrieve, and modify parameter categories such as `@none`, `@default`, and `@all`. It works with parameter collections and state lists, using accessors to bind categories to specific behaviors. Concrete use cases include enabling all parameters under a category, setting default category behavior, and defining custom categories with dependencies.",
      "description_length": 456,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for handling a specific datatype used in command-line parameters of the WP plugin, including equality checks, comparison, hashing, and pretty printing. It works with the abstract type `t` representing parameter values, supporting deep copies and membership checks over project skeletons. Concrete use cases include managing and comparing WP-specific command-line options and configurations.",
      "description_length": 421,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DryFinalizeScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Concrete use cases include managing and comparing script parameters during the dry-run and finalization phases of WP analysis.",
      "description_length": 460,
      "index": 1030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoWidth.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and comparing symbolic execution states and parameter configurations within the WP plugin.",
      "description_length": 455,
      "index": 1031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTests.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured representation through a descriptor, packed descriptor, and a list of representative values. The type is used to model values that can be deeply copied, checked for project membership, and serialized for user-friendly output.",
      "description_length": 365,
      "index": 1032,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Reduce.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's reduction framework. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type manipulation and analysis. Concrete use cases include managing and comparing intermediate representations during program analysis, such as tracking and reducing logical expressions or proof obligations.",
      "description_length": 504,
      "index": 1033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrepareScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling project-specific data structures in the WP plugin. It supports values of type `t` that can be compared, copied deeply, and checked for membership within projects using custom predicates. Concrete use cases include managing and manipulating script preparation data, such as tracking and serializing analysis configurations or intermediate representations tied to specific Frama-C projects.",
      "description_length": 514,
      "index": 1034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusMaybe.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling values that may include project-related state. It supports deep copying and membership checks for project values, ensuring no shared references. Concrete use cases include managing and comparing analysis statuses that depend on project contexts in the WP plugin.",
      "description_length": 401,
      "index": 1035,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Procs.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating procedural datatypes within the WP plugin. It provides operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for inspecting and querying project-related properties. The type `t` works with internal WP structures, particularly for handling descriptors, representations, and project membership checks. Use cases include managing datatype definitions during proof generation and analyzing procedure specifications with respect to project context.",
      "description_length": 566,
      "index": 1036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to plugin parameters, allowing configuration based on named categories and their dependencies. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a category, or aliasing the `@all` category to another category for consistent command-line handling.",
      "description_length": 511,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Timeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling timeout-related values in the WP plugin. It supports structured data representation with a descriptor, a list of representatives, and project membership checks, enabling precise value manipulation and analysis. Concrete use cases include managing timeout configurations, comparing and copying timeout states, and formatting timeout values for user output.",
      "description_length": 494,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Dump.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter dumping system. It supports structured data representation with a descriptor, packed representation, and membership testing for project-related values. The type is used to manage and manipulate parameter data during static analysis, enabling deep copying and project-specific queries.",
      "description_length": 447,
      "index": 1039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Concrete use cases include managing and comparing function timeout parameters within the WP plugin's analysis framework.",
      "description_length": 441,
      "index": 1040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.Vars",
      "library": "frama-c-wp.core",
      "description": "This module provides set-like operations for managing variables within formal logic terms, including membership checks, union/intersection/difference computations, and higher-order transformations like filtering and folding. It operates on a specialized variable set structure (`Wp.Lang.F.Vars.t`) containing elements of type `Wp.Lang.F.var`, supporting operations to partition, map, and query sets while preserving logical consistency. Typical applications involve analyzing or manipulating logical expressions by extracting variable dependencies, applying constraints, or verifying quantifier conditions.",
      "description_length": 606,
      "index": 1041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ExtEqual.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling integration with Frama-C's project management and analysis features. Concrete use cases include defining and manipulating parameterized types in WP's verification process, such as storing and comparing analysis configurations or intermediate values.",
      "description_length": 522,
      "index": 1042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Probes.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and comparing parameter configurations, validating project-specific data, and ensuring consistent serialization within the WP plugin framework.",
      "description_length": 515,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Prenex.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values within the WP plugin, supporting operations such as equality, comparison, hashing, and pretty printing. It works with a structured type `t` that includes a type descriptor, a name, and a packed representation, along with a list of representative values. It is used to manage and query project-specific data in a type-safe manner, enabling deep copying and membership checks over project skeletons.",
      "description_length": 479,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling command-line parameters within the WP plugin. It supports structured data manipulation, including deep copying and membership testing over project skeletons. Typical use cases include managing parameter values with rich structural properties, ensuring unique identification and efficient comparison in configuration contexts.",
      "description_length": 450,
      "index": 1045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data representation with a descriptor, a list of representatives, and project membership checks. Use it to manage typed values with rich structural properties in analysis plugins.",
      "description_length": 321,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Status.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate status values within the WP plugin. It supports integration with Frama-C's project management system through the `mem_project` function, which checks for the presence of project-related values. The type is designed for deep copying and is used to manage representational values in a way that ensures no shared state between copies.",
      "description_length": 481,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportName.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically used to represent and manipulate report names in the WP plugin. It includes functions for checking membership within projects, deep copying values, and exposing structural descriptors for serialization and introspection. Typical use cases include managing named reports with associated project contexts, ensuring unique identification and proper handling during analysis or output generation.",
      "description_length": 509,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for managing string-based command-line parameters in prover configurations, supporting operations like value validation against predefined strings or function names, alias resolution, and default value handling. It works with parameterized string values that enforce constraints through validation functions, while offering marshaling capabilities and integration with project state management. Specific use cases include configuring prover-specific options with strict value requirements and generating help documentation for parameterized command-line interfaces.",
      "description_length": 596,
      "index": 1049,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate command-line parameters in the context of the Why3 flag system. It supports operations to check membership within projects, create deep copies, and provides descriptors for type and structure. Concrete use cases include managing and validating parameter values during command-line parsing and project configuration.",
      "description_length": 465,
      "index": 1050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadassumes.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured values that may contain project-specific data, enabling checks for membership within project contexts and deep copying to avoid shared state. Concrete use cases include managing and comparing symbolic execution parameters or assumption sets in formal verification workflows.",
      "description_length": 462,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Prune.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's pruning functionality. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling efficient data manipulation and introspection. Concrete use cases include managing and comparing intermediate values during program analysis, such as tracking and filtering pruning decisions based on project-specific conditions.",
      "description_length": 525,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.MemoryContext.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing memory contexts in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It supports structured values with descriptors, packed representations, and project membership checks. Use cases include managing and comparing memory state abstractions during program analysis and verification tasks.",
      "description_length": 377,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CheckMemoryContext.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in memory context checks within the WP plugin. It supports structured data representation with descriptors, packed types, and project membership testing via `mem_project`. Use cases include managing and validating memory state representations during static analysis, ensuring deep copies and project-specific queries are handled efficiently.",
      "description_length": 475,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.As_string",
      "library": "frama-c-wp.core",
      "description": "This module enables management of string-based configuration parameters with support for validation, default values, and dynamic state tracking. It operates on string values constrained by whitelists or function name rules, offering operations to set/retrieve values, register update hooks, and handle aliases. Useful for command-line interface configuration where parameters require strict value enforcement and cross-cutting concerns like project state synchronization.",
      "description_length": 471,
      "index": 1055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with validation, alias resolution, and default value handling, while supporting serialization and project-specific state tracking. It operates on a structured datatype with equality, comparison, and marshaling capabilities, enabling controlled access to parameter values and their allowed string constraints. Key applications include validating user inputs against predefined value lists and ensuring consistent parameter behavior across WP plugin workflows.",
      "description_length": 515,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Pmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a polymorphic map structure where keys are logical predicates, enabling operations like conditional insertion, set-theoretic union/intersection, and value transformations based on key relationships. It works with polymorphic maps (`Pmap.t`) that associate logical expressions (`Wp.Lang.F.pred`) to arbitrary values, supporting advanced merging with custom conflict resolution and subset analysis. Such functionality is particularly useful in symbolic reasoning systems where mappings must be dynamically combined or filtered according to logical constraints.",
      "description_length": 581,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitConj.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling values within the WP plugin's splitting and conjunction logic. It supports structured data management using a list of representants, a type descriptor, and a packed descriptor for efficient storage and retrieval. Concrete use cases include managing and comparing complex logical expressions, tracking project-specific values via `mem_project`, and ensuring deep copies for mutation-safe data manipulation.",
      "description_length": 531,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Subst",
      "library": "frama-c-wp.core",
      "description": "Implements substitution operations for logic terms, including copying, adding term replacements, and applying functions or filters during substitution. Works with logic terms and substitution environments (`sigma`). Used to manipulate symbolic expressions during theorem proving or program analysis tasks.",
      "description_length": 305,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoDepth.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and comparing parameter configurations within the WP plugin's analysis framework.",
      "description_length": 460,
      "index": 1060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing command-line parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a concrete type `t` that encapsulates parameter values, along with lists of such values and descriptors for type information. Use cases include managing and manipulating parameterized configurations and options within the WP plugin's analysis workflows.",
      "description_length": 444,
      "index": 1061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Hashtbl",
      "library": "frama-c-wp.core",
      "description": "This module's hash tables are optimized for associating program points with arbitrary data, supporting imperative operations like insertion, lookup, and in-place modification alongside bulk initialization from key-value sequences. They facilitate efficient dataflow analysis and transformation workflows in control flow graph compilation by enabling iterative updates, filtering, and statistical tracking tied to specific nodes. The structure is particularly suited for scenarios requiring dynamic mapping of analysis results to execution paths, such as optimizing compiler passes or static analysis tracking.",
      "description_length": 609,
      "index": 1062,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Set",
      "library": "frama-c-wp.core",
      "description": "This module provides set operations for program points in a control flow graph, including membership testing, insertion, union, intersection, and difference, along with functional transformations like mapping, filtering, and partitioning. It works with immutable collections of nodes, enabling efficient set-based analysis while adhering to functional programming principles through non-destructive operations and iteration. Typical applications include analyzing code paths, tracking reachable nodes, and combining sets of program points during static analysis tasks like data flow or reachability checks.",
      "description_length": 606,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FilterInit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, along with support for project membership checks and deep copying. It works with a concrete type `t` that represents structured data involving projects and descriptors. Use this module when managing structured data values that require comparison, persistence, or user-friendly display, particularly in the context of project filtering and initialization.",
      "description_length": 458,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Debug.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for debugging purposes within the WP plugin. It supports structured data representation with a list of type representatives, a descriptor, and a packed descriptor for type inspection and dynamic typing. The type is used to manage and manipulate debug information, such as checking membership in projects, performing deep copies, and ensuring consistent value comparison and formatting.",
      "description_length": 520,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Generate.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and manipulating parameterized data structures within the WP plugin's analysis framework.",
      "description_length": 448,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Core.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type `t` and associated operations for managing parameter representations in the WP plugin. It includes functions for equality checks, comparison, hashing, pretty printing, and deep copying, along with descriptors and representants for structural handling. It is used to define and manipulate parameter types in a way that supports project-specific logic and serialization.",
      "description_length": 400,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrecondWeakening.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling precondition weakening in the WP plugin. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise manipulation of analysis parameters. Use cases include managing and comparing abstract precondition states during formal verification tasks.",
      "description_length": 429,
      "index": 1068,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Simpl.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type handling and introspection. Concrete use cases include managing and comparing complex parameter types within the WP plugin's analysis framework.",
      "description_length": 443,
      "index": 1069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.UnfoldAssigns.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter handling. It supports structured data representation with a descriptor, a list of representatives, and project membership checks, enabling precise type manipulation and analysis. It is used to manage and reason about parameter configurations during static analysis tasks in the WP plugin.",
      "description_length": 451,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl",
      "library": "frama-c-wp.core",
      "description": "This module implements a hash table with operations for creation, modification, and querying of key-value mappings where keys are of type `Wp.Wpo.S.t`. It supports ordered traversal using custom comparators, value-based lookups, memoization with default values, and sequence-driven initialization, while enabling structural transformations like filtering and folding over entries. These features are particularly useful for static analysis tasks requiring efficient state management, such as memoizing intermediate results or maintaining ordered collections of analysis data during program verification.",
      "description_length": 603,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with `Parameter_category.t` structures, which encapsulate category metadata and behavior. Concrete use cases include setting up default parameter behavior, enabling all parameters under a category, or aliasing the `@all` category to another category.",
      "description_length": 440,
      "index": 1072,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.Tmap",
      "library": "frama-c-wp.core",
      "description": "This module provides associative operations for mapping logic terms to values, supporting precise insertion, lookup, and transformation with custom merging strategies. It works with term-indexed maps where keys are formal logic expressions, enabling structured manipulation through ordered comparisons, differential updates, and value-aware composition. Typical applications include symbolic reasoning tasks that require maintaining and evolving logical state associations or combining term-based data under domain-specific rules.",
      "description_length": 530,
      "index": 1073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with support for value validation, alias resolution, and state persistence. It operates on string values constrained by allowed options, enabling use cases like configurable project settings where parameters must validate against predefined lists or dynamically resolve through function names. Key features include tracking changes across sessions, enforcing value constraints, and handling symbolic aliases for parameter values.",
      "description_length": 486,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Vmap",
      "library": "frama-c-wp.core",
      "description": "This module provides variable-indexed map operations for polymorphic data manipulation, supporting key-based transformations (insertion, deletion, lookup), value transformations (mapping, filtering), and set-theoretic combinations (union, intersection) with customizable merge strategies. It operates on maps where keys are logical variables and values can be arbitrary typed data, enabling precise handling of variable associations in symbolic reasoning tasks. Typical applications include managing variable bindings in formal verification, merging logical environments during proof construction, or tracking variable dependencies in static analysis workflows.",
      "description_length": 661,
      "index": 1075,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.FinalizeScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and comparing script parameters, validating project dependencies, and serializing data for analysis configurations.",
      "description_length": 480,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in the WP plugin, providing operations to define, retrieve, and modify parameter categories such as `@none`, `@default`, and `@all`. It works with parameter categories and state lists, using accessors to bind categories to specific parameter behaviors. Concrete use cases include setting default parameter behavior, enabling all parameters by default with specific interpretations, and defining dependencies between categories and states.",
      "description_length": 497,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyIsCint.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks for membership within projects and deep copying to avoid shared state. Use cases include managing and comparing complex parameter types in the WP plugin's analysis pipeline.",
      "description_length": 378,
      "index": 1078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Filter.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating values within a filtering system, supporting operations such as equality checks, comparison, hashing, and pretty printing. It works with a concrete type `t` and integrates with project-based data through the `mem_project` function, which checks for the presence of specific project values. Use cases include filtering and processing structured data values based on type, representation, or associated projects.",
      "description_length": 476,
      "index": 1079,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wpo.S.Set",
      "library": "frama-c-wp.core",
      "description": "This set structure supports standard operations like union, intersection, ordered traversal, filtering, mapping, and bidirectional conversion with sequences and lists, while maintaining persistent, ordered elements using a comparison function. It enables proximity-based queries via nearest-element functions, deterministic iteration, and project-specific membership validation. Designed for scenarios requiring strict element ordering, interoperability with sequential data, or directional searches, such as symbolic analysis or ordered collection transformations.",
      "description_length": 565,
      "index": 1080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TruncPropIdFileName.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling truncated property identifiers and file names within the WP plugin. It supports structured data management with deep copying, membership testing over projects, and type representation through descriptors. Concrete use cases include tracking and manipulating property identifiers and file paths during static analysis tasks.",
      "description_length": 462,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.Parameter_category.t` and state lists to control parameter behavior based on category membership. Concrete use cases include setting default category behavior, enabling all parameters under a specific interpretation, and defining dependencies for category activation.",
      "description_length": 478,
      "index": 1082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BoundForallUnfolding.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Use cases include managing and comparing complex parameter values in formal verification workflows, such as tracking and querying project-specific data during proof generation.",
      "description_length": 510,
      "index": 1083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating prover-related values with operations for equality, comparison, hashing, and pretty printing. It supports structured data handling through descriptors, project membership checks, and deep copying, enabling precise management of prover configurations and state. Use cases include command-line parameter parsing, project-specific prover selection, and maintaining isolated copies of prover data during analysis.",
      "description_length": 475,
      "index": 1084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportJson.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's JSON reporting system. It includes descriptors for type representation, a list of representants, and utilities for project membership checks and deep copying. Concrete use cases include managing and serializing proof-related data structures in a format suitable for JSON output.",
      "description_length": 422,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Map",
      "library": "frama-c-wp.core",
      "description": "This module supports associative operations like insertion, lookup, and bulk transformations (e.g., mapping or filtering values) on maps where keys are program points within a control flow graph trace. It also provides set-theoretic operations (union, intersection, partition) and advanced combinators for merging or comparing maps with custom logic, enabling precise analysis of program properties across execution paths. Such functionality is particularly useful for static analysis tasks like data flow tracking, code optimization, or verifying safety properties in program traces.",
      "description_length": 584,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.As_string",
      "library": "frama-c-wp.core",
      "description": "This module supports managing string-based command-line parameters for Why3 flags, including setting",
      "description_length": 100,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Pset",
      "library": "frama-c-wp.core",
      "description": "This module supports functional manipulation of sets of logical predicates through operations like union, intersection, filtering, and partitioning, returning new immutable sets rather than modifying existing ones. It works with a polymorphic set type `t` whose elements are logical predicates (`Wp.Lang.F.pred`), enabling transformations such as mapping with optional filtering, size computation, and list extraction. It is particularly useful in formal verification or logical reasoning contexts where immutable, set-based manipulation of predicates is required.",
      "description_length": 564,
      "index": 1088,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Memlimit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling memory limit parameters in the WP plugin. It supports values of type `t` and includes functionality for checking membership within projects, deep copying, and working with type descriptors. Concrete use cases include managing and comparing memory limit configurations during static analysis and ensuring project-specific constraints are respected.",
      "description_length": 486,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in the WP plugin, providing operations to define, retrieve, and modify parameter categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and `Frama_c_kernel.State.t`, and uses accessors to bind categories to parameter interpretations. Concrete use cases include setting default parameter behavior, enabling all parameters under a specific interpretation, and defining dependencies for parameter groups.",
      "description_length": 494,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Steps.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing abstract values used in the WP plugin's parameter system. It supports operations for equality checking, comparison, hashing, pretty-printing, and deep copying, as well as querying membership within project skeletons. The type is used to manage and manipulate parameter values in a way that ensures structural integrity and supports serialization through descriptors.",
      "description_length": 415,
      "index": 1091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InitWithForall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor and provides deep copying and project membership checks. Concrete use cases include managing and comparing symbolic execution parameters and ensuring consistent handling of data across different analysis contexts.",
      "description_length": 432,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating tactic-related values in the WP plugin, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with a concrete type `t` that encapsulates tactic data, including descriptors, names, and project membership information. Use cases include managing command-line parameters for tactics, performing deep copies of tactic values, and checking project membership constraints during analysis configuration.",
      "description_length": 507,
      "index": 1093,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for defining and managing string-based command-line parameters with support for value validation, alias handling, and project-specific state tracking. It operates on string parameters tied to analysis projects, enabling use cases like configuring plugin behavior, tracking analysis settings, and validating user-provided arguments through predefined allowed values. Key operations include setting/getting parameter values, registering change hooks, and customizing serialization for persistence or display.",
      "description_length": 537,
      "index": 1094,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.As_string",
      "library": "frama-c-wp.core",
      "description": "This module offers utilities for handling string-based command-line parameters in a plugin system, supporting operations like value validation, alias management, and serialization. It works with string values, parameter state tracking, and project-specific configurations, enabling features like customizable defaults and runtime value constraints. Typical applications include defining CLI parameters with restricted value sets, associating metadata with plugin options, and synchronizing parameter changes across different system components.",
      "description_length": 543,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CalleePreCond.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter handling. It supports values that may contain project-specific data, allowing checks for the presence of projects satisfying a predicate and enabling deep copies to avoid shared state. Concrete use cases include managing and comparing precondition parameters in the WP plugin's analysis of C functions.",
      "description_length": 465,
      "index": 1096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.OldReportJson.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with capabilities for deep copying and membership testing within projects. Use cases include managing and manipulating parameterized data structures in a way that ensures project-specific constraints and persistence across operations.",
      "description_length": 448,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in a WP plugin, providing operations to define, enable, and manipulate parameter categories. It works with types like `elt` for elements and `t` for category structures, supporting concrete actions such as setting default categories, enabling all categories with specific interpretations, and defining dependencies. Use cases include configuring parameter behavior via command-line flags and managing category-based enable/disable logic in analysis tools.",
      "description_length": 514,
      "index": 1098,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InteractiveTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling interactive timeout parameters in the WP plugin. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. It is used to manage and manipulate timeout configurations during interactive proof sessions.",
      "description_length": 391,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BackTrack.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in backtracking scenarios. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient value manipulation and analysis. Concrete use cases include managing and comparing complex state representations during symbolic execution or constraint solving.",
      "description_length": 447,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for defining and managing string-based command-line parameters with support for value validation, alias resolution, and dynamic state updates. It operates on string values (`t`) and associated metadata like allowed value sets, visibility flags, and project-specific context, while integrating with Frama-C's parameter system for seamless toolchain compatibility. Typical use cases include configuring analysis options via CLI flags, enforcing domain-specific constraints (e.g., valid C function names), and bridging user input with internal plugin state management.",
      "description_length": 596,
      "index": 1101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DynCall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic type `t` with operations for type representation, comparison, hashing, and pretty printing. It supports working with descriptors, packed structures, and lists of representants, enabling dynamic type inspection and manipulation. Use cases include managing dynamic values in the WP plugin, such as storing and comparing typed parameters across different analysis contexts.",
      "description_length": 404,
      "index": 1102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WP.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors and provides deep copying and project membership checks. Concrete use cases include managing and manipulating parameterized data types within the WP plugin's analysis framework.",
      "description_length": 408,
      "index": 1103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for handling command-line parameters within the WP plugin. It supports structured data representation with descriptors, type information, and project membership checks, ensuring deep copying and project-specific queries. Concrete use cases include managing and validating parameter values during plugin execution and facilitating parameter persistence across different project states.",
      "description_length": 497,
      "index": 1104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.Eva.State",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory states during static analysis, providing operations to construct and combine states from program elements like statements and functions. It supports data types such as `t` for abstract states, derived from CIL kernel instructions, statements, and functions. Concrete use cases include computing initial states for analysis, merging states at control flow join points using `join`, and pretty-printing states for debugging or reporting.",
      "description_length": 474,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RTE.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and comparing complex parameter types within the WP plugin's analysis framework.",
      "description_length": 452,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages named categories for organizing tactics within a command-line interface, supporting operations to define, enable, and modify categories with associated states and accessors. It works with tactic elements and state lists to control behavior based on category membership. Concrete use cases include configuring default tactic behavior, enabling all tactics under a category, or aliasing the '@all' category to a custom definition.",
      "description_length": 448,
      "index": 1107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's analysis framework. It supports structured data representation with a descriptor and provides deep copying, membership checks over project skeletons, and standard type functionalities. Concrete use cases include managing and manipulating analysis-specific data structures during static verification tasks.",
      "description_length": 452,
      "index": 1108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Volatile.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation through descriptors, packed descriptions, and a list of representatives for type inspection. The module is used to manage volatile parameters in the WP plugin, enabling deep copies, project membership checks, and consistent serialization for analysis configurations.",
      "description_length": 429,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Tset",
      "library": "frama-c-wp.core",
      "description": "This module implements a functional set interface for logic terms, supporting operations like union, intersection, difference, and predicate-based partitioning, along with size computation and list conversion. It operates on sets of `Wp.Lang.F.term` values, adhering to OCaml's functional set idioms, and is designed for managing collections of logical expressions in symbolic reasoning or formal verification workflows. Specific use cases include filtering term sets during proof obligations, mapping transformations over logic expressions, and comparing term sets for equivalence or subset relationships in automated theorem proving contexts.",
      "description_length": 644,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for managing string-based command-line parameters, including validation against allowed values, alias resolution, and dynamic value updates via hooks. It operates on string values within a parameterized collection structure, supporting integration with project state tracking and kernel-level functionalities. Typical use cases involve enforcing controlled input constraints for configuration options or ensuring safe string manipulation in plugin interfaces.",
      "description_length": 490,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadlocalinit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports working with project-specific values through membership checks and deep copying, ensuring isolation between instances. Typical use cases include managing and comparing configuration or analysis state data within the WP plugin's internal logic.",
      "description_length": 422,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Verbose.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured data manipulation with deep copying, membership testing over project skeletons, and provides type and descriptor information. Use cases include managing and comparing complex data representations within the WP plugin, particularly for static analysis tasks involving project-specific data.",
      "description_length": 425,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating a specific datatype used in command-line parameter handling, including equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` and structured descriptors, supporting deep copying and membership checks within project skeletons. Concrete use cases include handling parameter representations in a plugin interface, ensuring unique identification and structured manipulation of parameter values.",
      "description_length": 491,
      "index": 1114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters related to provers, allowing creation, modification, and retrieval of named categories with associated accessors and dependencies. It operates on types including `t` for categories and `elt` for elements within those categories. Concrete use cases include defining the `@none`, `@default`, and `@all` categories, enabling all provers with a specific interpretation, and setting default or global category behaviors.",
      "description_length": 474,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyForall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for structural manipulation and comparison, including equality, hashing, and pretty-printing. It supports project membership checks and deep copying, working with a list of representants and descriptors for type representation. Concrete use cases include managing and comparing complex data structures in the context of the WP plugin's simplification logic.",
      "description_length": 404,
      "index": 1116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Clean.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed representations, and deep copying to ensure value integrity. It is used to manage and manipulate parameter values in a way that integrates with Frama-C's project model, enabling checks and transformations over parameterized data.",
      "description_length": 468,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Havoc.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling robust type handling. Concrete use cases include managing and comparing complex parameter values during static analysis, such as tracking and modifying analysis configurations across different projects.",
      "description_length": 494,
      "index": 1118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.SCOPE",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates scope identifiers within a model registration context. It provides operations to retrieve a scope's unique identifier, compare scopes for equality and ordering, and compute hash values. These functions are used to manage and distinguish between different scopes during model analysis and verification tasks.",
      "description_length": 346,
      "index": 1119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVar.Static",
      "library": "frama-c-wp.core",
      "description": "This module tracks variable usage based on static CIL information. It provides functions to retrieve parameter representations, iterate over variable declarations, and initialize variable tracking in a memory context. It works directly with CIL variables and kernel functions, enabling precise static analysis of variable dependencies in C code.",
      "description_length": 345,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.GeneratorID",
      "library": "frama-c-wp.core",
      "description": "This module implements a model-specific, projectified storage system with key-value semantics. It supports operations to check existence (`mem`), retrieve (`get`, `find`), assign (`set`), and remove (`remove`, `clear`) data associated with keys. Designed for contextual data management during program analysis where model-dependent state must persist without serialization.",
      "description_length": 373,
      "index": 1121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.E",
      "library": "frama-c-wp.core",
      "description": "This module represents relocatable effects, which are predicates dependent on two program states. It provides operations to create, retrieve, and pretty-print these effects, along with tracking memory domains read from or written to. Use cases include modeling state transitions during program analysis and relocating effects across different memory sequences.",
      "description_length": 360,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Cache_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages a cache directory for the plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of the cache directory. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured and accessible location.",
      "description_length": 420,
      "index": 1123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.RunAllProvers",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter controlling prover execution behavior, including setting values, registering change hooks, and handling command-line options with aliases and help. It works with a boolean type and a Datatype module to support project-specific state management through serialization and comparison. This enables use cases like globally enabling/disabling prover runs, configuring CLI options for parameter activation, and maintaining consistent parameter states across sessions.",
      "description_length": 523,
      "index": 1124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout.Alias",
      "library": "frama-c-wp.core",
      "description": "This module manages layout aliases through operations like `use`, `merge`, and `alias`, enabling the composition and manipulation of layout structures. It works with the `Wp.Layout.alias` type to represent and modify layout relationships. Concrete use cases include defining hierarchical layouts, resolving layout references, and combining layout configurations in static analysis tasks.",
      "description_length": 387,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportJson",
      "library": "frama-c-wp.core",
      "description": "This module implements a parameter management system for configuring JSON reporting paths, centered on a file path type that supports setting, querying, and change monitoring via hooks. It integrates with command-line interfaces through help documentation and alias support, while providing serialization for state persistence. Key operations include checking whether the file path is empty, enabling validation of output destinations for generated reports.",
      "description_length": 457,
      "index": 1126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Prenex",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to configure, toggle, and track boolean states, including setting values through command-line interfaces, persisting defaults, and triggering hooks on changes. It operates on boolean parameters integrated with Frama-C's project-specific state management and serialization systems. Use cases include dynamically enabling/disabling analysis features, maintaining cross-project consistency, and reacting to configuration updates in real time.",
      "description_length": 471,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Make",
      "library": "frama-c-wp.core",
      "description": "This module extends a memory model with a new chunk type, enabling uniform handling of individual chunks within the sigma structure. It provides operations to promote a chunk to a uniform representation, check membership, retrieve variables and values, and construct domains from chunks. Concrete use cases include integrating specific memory regions into a unified analysis framework and querying their properties within a sigma context.",
      "description_length": 438,
      "index": 1128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Havoc",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter, including setting values (`on`/`off`), tracking project-specific state, and handling serialization, while supporting command-line interface integration through option aliases and help documentation. It works with a custom `t` type to represent the parameter's state and allows dynamic behavior toggling via registered hooks for value changes. Specific use cases include configuring analysis modes in the WP plugin and enabling/disabling features like havocing during verification tasks.",
      "description_length": 549,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Ctypes.C_object",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type `t` representing C objects, along with operations for equality, comparison, hashing, and pretty printing. It includes metadata such as the type `ty`, name, and descriptor `descr`, and supports deep copying and project membership checks via `mem_project`. Use cases include managing and manipulating C object representations in static analysis, particularly for tracking and comparing object states across analysis phases.",
      "description_length": 462,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Compound",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manipulate structured layouts by reshaping and obfuscating content. It works with layout data types that represent regions, incorporating offset caches and generic values. Use cases include transforming region hierarchies and applying obfuscation at specific offsets in a layout.",
      "description_length": 314,
      "index": 1131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacHavoc.Havoc",
      "library": "frama-c-wp.core",
      "description": "Implements tacticals for generating and managing logical havoc states in proofs. Works with Wp's tactical and strategy types to inject non-deterministic state transitions. Useful for modeling undefined behavior and enforcing memory safety in C-like language verification.",
      "description_length": 271,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Simpl",
      "library": "frama-c-wp.core",
      "description": "This module provides boolean parameter management with set, get, and clear operations, including default value handling, alias support, and change-tracking hooks. It operates on a shared boolean state variable, enabling command-line configuration, persistent state storage, and project-specific behavior through marshaling and update notifications. Use cases include feature toggling via CLI flags, persisting user preferences across sessions, and synchronizing parameter changes with external systems using reactive callbacks.",
      "description_length": 527,
      "index": 1133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitCNF",
      "library": "frama-c-wp.core",
      "description": "This module manages integer parameters that control CNF transformation behavior in theorem proving workflows, offering operations to set, get, and constrain values within specified bounds while tracking state changes. It works with integer-valued options that integrate with logical formula representations, supporting dynamic range validation, command-line configuration, and custom serialization. Specific applications include tuning thresholds for formula splitting strategies or adjusting proof search parameters in formal verification tasks.",
      "description_length": 546,
      "index": 1134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Parasite",
      "library": "frama-c-wp.core",
      "description": "This component defines a boolean parameter type with state management capabilities, supporting operations to toggle values, register update callbacks, and integrate with command-line interfaces through visibility controls and alias handling. It works with project-specific state tracking mechanisms and Frama-C's kernel for parameter registration, marshaling, and default value management. The type is designed for scenarios requiring persistent flag toggling, such as enabling/disabling analysis features or configuring plugin behavior across different project contexts.",
      "description_length": 571,
      "index": 1135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.WeakIntModel",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter, including setting, retrieving, and tracking changes to its value, with support for hooks on updates, command-line visibility, and serialization. It operates on a boolean type `t` while handling project-specific state management, default value configuration, and integration with Frama-C's parameter system. These capabilities are used to control feature toggles, persist settings across sessions, and synchronize value changes with external systems or UI components.",
      "description_length": 529,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Volatile",
      "library": "frama-c-wp.core",
      "description": "This module supports dynamic configuration and state tracking through volatile boolean flags, offering operations to set, retrieve, and toggle values, along with mechanisms for alias resolution, update hooks, and serialization customization. It manages boolean state within a shared context, enabling runtime adjustments and persistence of transient settings. Typical applications include feature toggles, temporary behavior overrides, and project-specific runtime configuration in the WP plugin environment.",
      "description_length": 508,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Dump",
      "library": "frama-c-wp.core",
      "description": "This module provides a system for managing boolean configuration options with capabilities to set, retrieve, and track value changes, including hooks for state transitions and support for command-line interaction (e.g., help messages, aliases). It operates on a dedicated boolean type `t`, integrates with Frama-C's project state management, and enables custom marshaling for serialization. This infrastructure is used to control runtime features like diagnostic output dumping, allowing dynamic configuration adjustments via programmatic flags or command-line parameters.",
      "description_length": 572,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Chunk",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to inspect and compare chunk values, including hashing, equality checks, and ordering. It works with the `t` type representing memory chunks, offering access to their properties like type, name, and initialization status. Concrete use cases include managing memory representations in program analysis, filtering initialization chunks, and generating variable names during symbol compilation.",
      "description_length": 423,
      "index": 1139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt",
      "library": "frama-c-wp.core",
      "description": "This module offers operations to manage command-line parameters as string sets, supporting value updates, persistence via Frama-C's project state system, and validation through hooks. It works with `Frama_c_kernel.Datatype.String.Set.t` for set operations like membership checks and iteration, alongside structured configuration handling via `Category` and string serialization. Use cases include defining hierarchical command-line options with default values, aliases, and runtime validation in Frama-C plugins.",
      "description_length": 512,
      "index": 1140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Root",
      "library": "frama-c-wp.core",
      "description": "This module manages hierarchical layout structures for organizing and formatting output in the WP plug-in. It provides operations to construct, merge, and inspect layout roots, which represent formatted regions with optional indexing and framing. Use cases include generating structured output for proofs, reports, or user interfaces where nested layouts with consistent formatting are required.",
      "description_length": 395,
      "index": 1141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Ground",
      "library": "frama-c-wp.core",
      "description": "This module manages environments for term and predicate transformations, supporting operations like applying substitutions, branching logical contexts, and propagating constraints forward and backward. It works with environments (`env`) and symbolic expressions (`term`, `pred`) from the `Wp.Lang.F` module. Concrete use cases include simplifying logical formulas, managing conditional branches in proofs, and applying context-specific transformations during verification tasks.",
      "description_length": 478,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Subst",
      "library": "frama-c-wp.core",
      "description": "This module implements substitution operations over logical terms and predicates, centered around a map from variables to terms. It supports applying substitutions to terms and predicates, adding variable-term bindings, and querying the domain and codomain of substitutions. Concrete use cases include managing variable replacements during proof obligations or term transformations in a theorem proving context.",
      "description_length": 411,
      "index": 1143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StatusTrue",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters for status flags controlling analysis behaviors, supporting operations to set, retrieve, and monitor state changes, along with alias management and serialization customization. It operates on boolean values scoped to project analysis states, integrating with command-line interfaces and persistent state storage. Typical use cases include enabling or disabling specific static analysis checks or runtime features based on user configuration or project requirements.",
      "description_length": 504,
      "index": 1144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc.Separated",
      "library": "frama-c-wp.core",
      "description": "This module implements tactical operations for managing memory separation and aliasing in program verification. It provides functions to manipulate and reason about disjoint memory regions using separation logic. Concrete use cases include verifying functions that modify heap-allocated data structures without interfering with other parts of the program state.",
      "description_length": 361,
      "index": 1145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.Static",
      "library": "frama-c-wp.core",
      "description": "This module manages a static, project-specific context for associating keys with data values, supporting operations like definition, retrieval, and iteration with protections against redefinition and circular dependencies. It works with key and data types defined by the parameter module `E`, enabling project-wide state management and memoization. Concrete use cases include caching computed values, registering named entities, and ensuring consistent data access across analysis phases.",
      "description_length": 488,
      "index": 1146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StrategyEngine",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing boolean options with state mutation, change tracking, and serialization capabilities. It operates on boolean values and structured datatypes for marshaling, supporting use cases like toggling strategy engine components and tracking computed states across project lifecycles. Key features include default value handling, alias management, and introspection for synchronized state persistence.",
      "description_length": 436,
      "index": 1147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeExtra",
      "library": "frama-c-wp.core",
      "description": "This component enables configuration and monitoring of time-related integer parameters with range constraints, offering operations to increment, set, and retrieve values while enforcing min-max boundaries. It manages shared mutable state through a parameter system integrated with Frama-C, supporting command-line interfaces, project persistence, and lifecycle hooks for validation or side effects during value changes. Typical use cases include setting timeouts, scheduling intervals, or time-based thresholds in analysis workflows where bounded numerical inputs require validation and cross-component synchronization.",
      "description_length": 619,
      "index": 1148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Cache",
      "library": "frama-c-wp.core",
      "description": "This module implements a parameter caching system for string-valued configuration options, enabling validation against allowed values, registration of update hooks, and serialization of state. It operates on parameters constrained by predefined value sets or validation functions, integrating with project management systems to scope parameter lifecycles and persist settings across sessions. Use cases include command-line interface configuration via aliases and visibility controls, as well as ensuring consistent parameter state during project loading, saving, and reset operations.",
      "description_length": 585,
      "index": 1149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.Eva",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to construct and manipulate abstract memory values during static analysis, including creating null or literal values, accessing fields or array elements, and loading values from memory states. It works with abstract memory states and values derived from CIL program elements like variables, fields, and expressions. Concrete use cases include modeling pointer arithmetic, tracking memory contents during analysis, and generating constraints for value ranges or memory layouts.",
      "description_length": 508,
      "index": 1150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node",
      "library": "frama-c-wp.core",
      "description": "This module represents individual program points within a control flow graph trace, offering operations to create, compare, and format nodes. It works with the `t` type, which models control flow graph nodes, and supports precise static analysis tasks such as tracking execution paths, data flow, and reachability. Concrete use cases include identifying specific program points for analysis, comparing node identities during path exploration, and formatting nodes for debugging or reporting purposes.",
      "description_length": 500,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TruncPropIdFileName",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter representing truncated property identifiers and file names, offering operations to set, retrieve, increment, and constrain values within a valid range. It maintains shared state with bounds tracking, supporting marshaling and alias definitions for configuration during static analysis. Key use cases include generating unique identifiers and enforcing numeric constraints in analysis workflows where scoped or bounded integer values are critical.",
      "description_length": 487,
      "index": 1152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrepareScripts",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with operations to set, retrieve, and monitor its state, alongside mechanisms to customize command-line interactions (e.g., help messages, aliases) and serialize values via a dedicated datatype. It integrates with project-specific state updates and supports use cases like toggling analysis flags or configuring script preparation behavior dynamically through hooks and marshaled data.",
      "description_length": 425,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc.Validity",
      "library": "frama-c-wp.core",
      "description": "This module ensures the validity of havoc operations during tactic application by verifying preconditions and constraints on program states. It works with logical assertions, program variables, and memory states to confirm that havocing a variable does not invalidate existing proof obligations. Concrete use cases include validating variable elimination in proofs and ensuring soundness when modifying program state during verification.",
      "description_length": 437,
      "index": 1154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice.Choice",
      "library": "frama-c-wp.core",
      "description": "Implements tactical choices for proof strategies, providing `tactical` and `strategy` functions to handle logical branching. Works with proof goals and selection tactics to guide automated reasoning. Used to define prioritized decision points in proof search, such as selecting between multiple possible proof paths based on context.",
      "description_length": 333,
      "index": 1155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheEnv",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to control caching behavior through boolean state switches, enabling features like cache activation or invalidation, and tracks changes via observer hooks. It operates on boolean values and structured cache data represented by the Datatype submodule, facilitating state serialization and cross-project consistency. Use cases include command-line configuration of caching policies with aliased flags, real-time monitoring of cache state modifications, and persisting environment settings across sessions.",
      "description_length": 535,
      "index": 1156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice.Contrapose",
      "library": "frama-c-wp.core",
      "description": "This module implements the contraposition tactic for logical reasoning, enabling the transformation of goals by negating both the conclusion and the premises. It operates on logical formulas and supports proof strategies that require reductio ad absurdum or contrapositive reasoning. Concrete use cases include proving implications by assuming the negation of the conclusion and deriving a contradiction.",
      "description_length": 404,
      "index": 1157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheDir",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a cache directory path parameter validated as a string, supporting dynamic configuration updates, value serialization, and command-line interface integration. It works with string-based values enhanced by validation logic to accept either plain paths or function names resolving to paths, while tracking project-specific state and default configurations. The functionality is used to configure cache directories during static analysis workflows, enabling runtime adjustments and monitoring of directory settings through hooks and alias management.",
      "description_length": 589,
      "index": 1158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadloop",
      "library": "frama-c-wp.core",
      "description": "This parameter module introduces a shared boolean state for toggling smoke deadloop functionality, with operations to set, retrieve, and monitor value changes through pre/post hooks. It integrates command-line configuration capabilities like help documentation, aliases, and value validation, while leveraging a datatype module for serialization and persistent state management across projects. The boolean state is specifically used to enable or disable smoke deadloop detection in static analysis workflows, with hooks supporting side effects like cache invalidation or logging when the setting changes.",
      "description_length": 605,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.VC_Annot",
      "library": "frama-c-wp.core",
      "description": "This module handles verification condition annotations by providing operations to check if an annotation is trivial and to resolve property identifiers against its components. It works with structured data including goals, axioms, tags, warnings, dependencies, and source information. Concrete use cases include filtering out redundant verification conditions and linking properties to their defining contexts during static analysis.",
      "description_length": 433,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyLandMask",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter controlling land mask simplification behavior, including state modification via `on`/`off` functions, value monitoring with pre/post-update hooks, and persistence mechanisms through custom marshaling. It operates on scalar boolean values augmented with metadata for default states, command-line interface visibility, and change tracking callbacks. The functionality is specifically used to enable or disable land geometry simplification steps in geospatial data processing workflows within the plugin's analysis pipeline.",
      "description_length": 583,
      "index": 1161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Lvalue",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing and printing lvalue regions in the WP plugin's layout system. It provides equality checking, ordering, and pretty-printing for the `t` type, which represents memory locations in a program's memory model. These functions are used to analyze and verify memory-related properties in C code during static analysis.",
      "description_length": 355,
      "index": 1162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Deref",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing and printing region dereference values. It supports equality checks, ordering, and pretty-printing of `t` type instances. Useful for analyzing memory regions in static analysis tasks.",
      "description_length": 228,
      "index": 1163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportName",
      "library": "frama-c-wp.core",
      "description": "This module defines a string-based parameter type for managing report name configurations, offering operations to validate values against allowed function names or literals, handle command-line input, and synchronize with project state. It supports data structures like string lists for allowed values and integrates with Frama-C's state management system to enforce consistency across sessions. Typical use cases include validating user-defined report identifiers, configuring output naming conventions, and bridging plugin parameters with global analysis settings.",
      "description_length": 566,
      "index": 1164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FilterInit",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage boolean states with project-specific persistence, supporting dynamic configuration through CLI hooks and change notifications. It works with boolean values and custom data types via the Datatype module, enabling use cases like feature toggles for filtering logic or initialization workflows tied to project contexts. Key functionality includes atomic state updates, serialization, and equality checks for robust configuration management.",
      "description_length": 479,
      "index": 1165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyForall",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean flag that enables or disables simplification of universal quantifiers during logical analysis. It works with an internal boolean state, offering functions to set, retrieve, and monitor changes to the flag, along with lifecycle hooks, default value handling, command-line configuration, and serialization. The toggle mechanism is specifically used to control quantifier simplification strategies in workflows involving formal verification or symbolic reasoning.",
      "description_length": 512,
      "index": 1166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Warning.Set",
      "library": "frama-c-wp.core",
      "description": "This module offers standard set operations\u2014union, intersection, difference, and ordered traversal\u2014on immutable, sorted collections of contextual error objects, leveraging a comparison module to enforce uniqueness and ordering. It supports transformations like filtering, mapping, and partitioning, along with efficient queries for subsets, extremal elements, and sequence-based conversions for ordered iteration. Designed for managing hierarchical warning data in static analysis workflows, it enables tasks like merging diagnostic reports, extracting specific error categories, or generating prioritized remediation lists.",
      "description_length": 623,
      "index": 1167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements a memory model interface supporting configuration, manipulation of abstract memory locations (pointers, variables, fields, and array elements), and operations like pointer arithmetic, casting, and memory state transformations. It works with memory segments, logical predicates, and dependency graphs to express constraints, validity, and separation properties, enabling formal verification tasks such as heap state reasoning, scope management, and proof obligation generation for memory-related program properties.",
      "description_length": 537,
      "index": 1168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Auto.Range",
      "library": "frama-c-wp.core",
      "description": "Manages integer range analysis for program variables. Computes value ranges from condition sequences and provides mappings for lower/upper bounds. Used to optimize static analysis by narrowing variable domains in conditional contexts.",
      "description_length": 234,
      "index": 1169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.FinalizeScripts",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to configure and manage a boolean parameter, including setting values via `on`/`off` functions, tracking state changes, and integrating with project-specific persistence mechanisms. It works with boolean primitives and structured data through the `Datatype` module, enabling use cases like toggling finalization script execution during analysis or kernel interactions. The design supports serialization, alias handling, and dependency management for parameter updates within a larger plugin ecosystem.",
      "description_length": 533,
      "index": 1170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTests",
      "library": "frama-c-wp.core",
      "description": "This module controls a boolean state for smoke test configuration, offering operations to toggle flags, persist values with project-specific defaults, and synchronize settings via command-line interfaces. It supports dynamic behavior through change hooks, alias management, and serialization, enabling use cases like conditional test execution and cross-session configuration consistency.",
      "description_length": 388,
      "index": 1171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.DISK",
      "library": "frama-c-wp.core",
      "description": "This module implements operations for managing and querying disk-based proof obligations, including saving, loading, and checking the status of proof files. It works with proof identifiers, model contexts, and prover configurations to persist and retrieve verification results. Concrete use cases include caching intermediate proofs, resuming verification sessions, and storing counterexamples for later analysis.",
      "description_length": 413,
      "index": 1172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InteractiveTimeout",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manipulate integer-based timeout parameters with configurable min/max ranges, including incrementing values, enforcing bounds, and tracking changes through registered hooks. It supports use cases requiring dynamic adjustment of interactive timeouts while maintaining project-specific constraints, such as in interactive theorem proving environments where precise control over execution limits is critical. The design incorporates alias handling, serialization, and comparison capabilities for seamless integration with configuration systems and state management workflows.",
      "description_length": 607,
      "index": 1173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Reduce",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean options for logical expression analysis with operations to set, retrieve, and query flag states, while supporting project-specific state tracking and command-line configuration through aliases and custom marshaling. It operates on a structured type designed for expression reduction tasks, enabling use cases like feature toggling and analysis pipeline customization. The shared boolean state variable allows direct on/off control of specific logical transformation rules during program analysis.",
      "description_length": 524,
      "index": 1174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities to manage command-line parameters stored as string lists, enabling operations like value assignment, default checks, change tracking, and ordered iteration over parameter collections. It supports structured customization through aliases, help messages, and serialization, while integrating with state management systems to persist parameter configurations across sessions. Typical use cases include defining and modifying user-configurable option lists in tools like Frama-C, where parameters must be validated, documented, and synchronized with project states.",
      "description_length": 592,
      "index": 1175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Steps",
      "library": "frama-c-wp.core",
      "description": "This module manages integer configuration parameters with support for incrementing values, enforcing numeric ranges, and tracking state changes through hooks. It works with integer types and leverages a Datatype module for serialization, while providing command-line interface integration with option aliases and help documentation. Typical use cases include configuring analysis settings in the WP plugin, enforcing domain-specific constraints on integer parameters, and maintaining project state across sessions through customizable marshaling.",
      "description_length": 546,
      "index": 1176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusFalse",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing a boolean parameter state, including setting and retrieving values, registering change hooks, handling aliases, and controlling serialization. It operates on a boolean type `t` and supports use cases such as default value handling, project-specific state tracking, and command-line interface integration. Additionally, it offers simple toggling functions (`on`/`off`) to directly manipulate the state without external data dependencies.",
      "description_length": 481,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cvalues.Logic",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for manipulating logic values that represent memory locations and regions, including arithmetic transformations, memory access (e.g., field selection, shifting, loading), and set-theoretic operations like union, intersection, and subset checks. It works with logic terms, memory segments, and regions to construct predicates that model memory states and verify properties such as validity, initialization, and separation. These capabilities are used in formal verification tasks to reason about program memory behavior and enforce correctness constraints in low-level code analysis.",
      "description_length": 614,
      "index": 1178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.CachePrint",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing a boolean parameter that controls cache printing behavior, including setting, retrieving, and monitoring state changes through hooks and custom serialization. It works with cached boolean values tied to project-specific lifecycles, enabling use cases like conditional output logging and persistent configuration across sessions. The interface supports toggling the cache state while tracking modifications for debugging or workflow optimization scenarios.",
      "description_length": 500,
      "index": 1179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Init",
      "library": "frama-c-wp.core",
      "description": "This module enables management of boolean configuration parameters with support for state manipulation, CLI integration, and marshaling. It operates on a shared boolean type `t` tied to the plugin's global project state, facilitating use cases such as initialization flags, option parsing with aliases, and visibility-controlled settings that require persistent storage and cross-session consistency.",
      "description_length": 400,
      "index": 1180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CounterExamples",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean flag controlling counterexample generation during Weakest Precondition analysis, including setting, retrieving, and monitoring state changes via hooks. It integrates with Frama-C's project system for state persistence and marshaling, while supporting command-line configuration through aliases and descriptive help output. The functionality is specifically used to enable or disable counterexample computation in verification workflows and maintain consistent analysis settings across sessions.",
      "description_length": 546,
      "index": 1181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags",
      "library": "frama-c-wp.core",
      "description": "This module manages a mutable, hook-aware collection of Why3 command-line flags, enabling value setting, pre/post-change hooks, default checks, marshaling, and alias definitions while integrating with Frama-C's state and project system. It operates on string-based parameter lists (`elt = string`), supporting iteration, folding, and categorized configuration through submodules, ideal for dynamic flag management in static analysis workflows requiring ordered, categorized command-line arguments.",
      "description_length": 497,
      "index": 1182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties",
      "library": "frama-c-wp.core",
      "description": "This module enables configuration and manipulation of command-line parameters through string list operations, value change tracking, alias resolution, and state persistence mechanisms. It works with string lists and associated metadata, offering validation, category-based organization, and integration with Frama-C's parameter system for tasks like project state management and plugin extensibility. Key applications include parameter validation workflows, hierarchical configuration grouping, and dynamic state marshaling across sessions.",
      "description_length": 540,
      "index": 1183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.Make",
      "library": "frama-c-wp.core",
      "description": "This module enables the construction and manipulation of a memory model within a Hoare logic framework, focusing on memory locations (`loc`) and segments. It provides operations for pointer arithmetic, address casting, memory state transitions (`sigma`), and validation of properties like initialization, separation, and inclusion of memory regions. These capabilities are applied in formal verification to enforce memory safety, resolve variable dependencies, and validate program correctness through logical assertions about heap and stack behavior.",
      "description_length": 551,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemDebug.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling and verification operations for analyzing memory states, including pointer arithmetic, segment manipulation, and memory effect modeling (load/store operations). It works with memory locations (`loc`), segments, memory states (`sigma`), and logical formulas (`pred`) to enforce constraints and validate properties like validity, separation, and initialization. These capabilities are used in formal verification tasks to ensure memory safety and correctness of low-level operations in programs.",
      "description_length": 530,
      "index": 1185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RTE",
      "library": "frama-c-wp.core",
      "description": "This parameter system manages boolean runtime flags through set/get operations and change-monitoring hooks, supporting command-line configuration with aliases, help, and marshaling. It operates on an internal boolean state, integrates with Frama-C's project management for state tracking and versioning, and enables use cases such as runtime feature toggling and CLI-driven analysis configuration in formal verification workflows.",
      "description_length": 430,
      "index": 1186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcall",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean configuration flag, including setting and retrieving values, registering change hooks, handling aliases, and supporting serialization and project-specific state persistence. It operates on boolean values and structured data through a custom `Datatype` module, enabling use cases like toggling smoke testing or dead call detection features with project-aware configuration management.",
      "description_length": 435,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Chunk",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates sets of integer ranges, called chunks, using operations like union, membership test, and disjoint verification. It supports constructing empty or singleton chunk sets, combining them through union, and checking if two sets are disjoint. Use cases include tracking memory regions or line number ranges in a program, where precise aggregation and overlap checks are required.",
      "description_length": 412,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AliasInit",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean state with project-specific persistence, offering operations to toggle values, register update callbacks, and handle command-line aliases. It integrates with Frama-C's parameter system for serialization and visibility control in help messages, leveraging a shared `t = bool` state type. Typical use cases include initializing analysis flags, synchronizing UI toggles, and configuring persistent options across sessions.",
      "description_length": 449,
      "index": 1189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Memlimit",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage an integer parameter constrained by minimum and maximum bounds, supporting value modification, range adjustments, and pre/post-change notifications. It works with integer values and bounded ranges, offering integration with command-line interfaces, persistent state management through the `Datatype` module, and customizable serialization for use cases like configuring memory allocation thresholds or enforcing resource limits in computational workflows.",
      "description_length": 497,
      "index": 1190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.State_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages the state directory for the plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the state directory structure. Use cases include storing transient analysis results or configuration files specific to the plugin's execution.",
      "description_length": 389,
      "index": 1191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Config_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages the configuration directory for the plugin, providing direct access to directory and file paths within it. It supports operations to retrieve or create directories and files, and allows setting or checking a user-specified directory. Concrete use cases include storing and accessing plugin-specific configuration files or persistent data.",
      "description_length": 358,
      "index": 1192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WP",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage boolean options for feature configuration, including setting values, registering change hooks, and handling command-line visibility. It works with boolean states to enable/disable plugin behaviors, supporting use cases like feature toggles and persistent project settings through serialization. The system also accommodates aliased parameters and dynamic state updates for flexible integration with command-line interfaces and runtime environments.",
      "description_length": 490,
      "index": 1193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitConj",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a project-scoped boolean parameter with change tracking, including functions to set and retrieve its value, register hooks for state transitions, and handle custom serialization. It works with a mutable boolean state augmented by metadata for dependency management, aliases, and marshaling logic. Typical use cases involve dynamically configuring plugin behavior with persistent, cross-session state updates or triggering side effects like UI refreshes when the boolean value changes.",
      "description_length": 526,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters with string list values, supporting operations like value modification, alias handling, and serialization, while integrating with Frama-C's project and kernel systems for state management. It works with string lists (`t = string list`) and collections of command-line options, offering utilities for iteration, folding, constraint enforcement, and category-based organization. It is particularly useful for plugins or tools requiring structured handling of command-line arguments with default values, help documentation, or persistent state tracking.",
      "description_length": 594,
      "index": 1195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TerminatesVariantHyp",
      "library": "frama-c-wp.core",
      "description": "This component manages a boolean flag to control termination variant hypothesis behavior in static analysis, offering operations to toggle its state, query current values, and bind changes to side effects. It operates on a parameterized boolean state with associated metadata, supporting command-line configuration through help documentation and alias management. The functionality is specifically applied to enable or disable variant hypothesis checks during program verification, influencing termination proof strategies in the analysis pipeline.",
      "description_length": 548,
      "index": 1196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CalleePreCond",
      "library": "frama-c-wp.core",
      "description": "This module offers operations to manage boolean flags controlling precondition checks in a verification context, with support for setting values, tracking state changes via hooks, and integrating command-line interfaces (e.g., help messages, aliases). It operates on a shared boolean state and project-specific metadata, providing utilities for serialization, comparison, and synchronization with Frama-C's parameter system. Typical use cases include enabling/disabling precondition analysis features dynamically or configuring verification workflows through CLI options and project settings.",
      "description_length": 592,
      "index": 1197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters as string sets, offering operations to add elements, check membership, enforce constraints, and register hooks for value changes, with support for alias resolution and custom serialization. It organizes parameters into dynamic categories for grouped management and configurable validation, enabling structured input handling. It is particularly useful for plugin configurations requiring validated, category-scoped parameters and reactive updates via change listeners.",
      "description_length": 512,
      "index": 1198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Clean",
      "library": "frama-c-wp.core",
      "description": "This module supports managing a boolean option with operations to set and retrieve values, register change hooks, handle command-line aliases, and persist project-specific state using marshaling and equality checks. It works with a `t` type for option values and integrates with Frama-C's project model to track and control visibility of states. Specific use cases include toggling analysis features, configuring CLI options with aliases, and maintaining consistent parameter settings across sessions.",
      "description_length": 501,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Warning.Map",
      "library": "frama-c-wp.core",
      "description": "This module organizes and manipulates key-value associations where keys are contextual error descriptors, supporting functional updates, ordered traversal, and selective transformation. It enables merging, filtering, and comparison of error maps while preserving key ordering, with utilities to safely extract, aggregate, or partition error data. Typical applications include managing hierarchical error states, processing diagnostic reports, or implementing analysis workflows that require structured handling of warnings with precise positional or contextual keys.",
      "description_length": 566,
      "index": 1200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Split",
      "library": "frama-c-wp.core",
      "description": "Tracks occurrence counts of logical predicates to identify frequently used literals for case splitting. It provides operations to create an occurrence counter, add predicates, and select the most common ones. This helps optimize proof strategies by prioritizing splits on prevalent literals.",
      "description_length": 291,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadlocalinit",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter through operations for setting, retrieving, and registering change hooks, enabling dynamic configuration of analysis modes. It operates on a shared boolean state, integrating with command-line interfaces, project-specific storage, and Frama-C's state system for persistence and cross-component communication. Use cases include toggling verification workflows and synchronizing parameter updates with external tools or project settings.",
      "description_length": 475,
      "index": 1202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.MODEL",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for working with model types in the context of the WP plug-in API. It provides functions to retrieve identifiers, descriptions, and hash values for models, as well as comparison and equality checks. These operations are used to manage and distinguish between different models during verification tasks.",
      "description_length": 333,
      "index": 1203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.N",
      "library": "frama-c-wp.core",
      "description": "This module defines overloaded operators and functions for constructing logical terms and predicates using familiar arithmetic and boolean syntax. It works directly with term and predicate types from the `Wp.Lang.F` module, enabling concise expression of logical formulas. Concrete use cases include writing verification conditions, preconditions, and postconditions in a more readable form, such as `x + y > 0` or `p &&: q ==> r`.",
      "description_length": 431,
      "index": 1204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Overlay",
      "library": "frama-c-wp.core",
      "description": "This module manages overlay structures used to combine and display hierarchical layout information. It provides operations to merge overlays using a custom merger function, format overlays for display with optional titles, and check if a value exists in an overlay. These functions are used to construct and manipulate complex UI layouts that combine multiple data sources, such as displaying annotated code views with overlapping regions.",
      "description_length": 439,
      "index": 1205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels.T",
      "library": "frama-c-wp.core",
      "description": "Implements structural comparison and equality for normalized C-labels. Works directly with `Wp.Clabels.c_label` values. Useful for ensuring consistent label handling in logic operations and comparisons.",
      "description_length": 202,
      "index": 1206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.UnfoldAssigns",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter constrained by configurable bounds, offering operations to set and retrieve values, enforce range validity, and trigger actions on updates via pre/post hooks. It integrates with a state management system to persist values across sessions, supporting marshaling, default initialization, and visibility-controlled command-line aliases. It is used to enforce bounded integer configurations in analysis workflows and enable dynamic parameter adjustments with session-persistent state.",
      "description_length": 521,
      "index": 1207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.StaticGenerator",
      "library": "frama-c-wp.core",
      "description": "This module provides a key-value store interface with operations to check existence (`mem`), retrieve (`get`, `find`), insert (`set`), and remove (`remove`, `clear`) data associated with keys. It works with abstract key and data types defined by the `K` and `D` modules. Concrete use cases include managing static analysis contexts where keys represent program elements and data holds associated proof obligations or annotations.",
      "description_length": 429,
      "index": 1208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with set-like operations, supporting element insertion, membership checks, iteration, and state tracking for computed values. It operates on string collections and integrates with Frama-C's parameter system to enable configuration management and dynamic updates in project-specific workflows. Key use cases include handling aliased parameters, customizing serialization, and maintaining state consistency during analysis tool execution.",
      "description_length": 493,
      "index": 1209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemBytes.LOADER",
      "library": "frama-c-wp.core",
      "description": "This module enables precise memory modeling by providing operations to load and store typed values (integers, floats, pointers) at specific memory locations, compute memory footprints, and verify memory separation or equality constraints. It operates on memory states (`sigma`), typed memory locations (`loc`), C type descriptors (`c_int`, `c_float`), and logical terms (`F.term`), while managing conversions between memory regions and symbolic pointers. Its functionality supports static analysis tasks like program verification and symbolic execution, where tracking memory effects and pointer relationships is critical.",
      "description_length": 622,
      "index": 1210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DynCall",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing boolean parameters with integrated command-line interface handling, including option parsing with aliases, help message generation, and project-specific state persistence. It works with a typed boolean structure (`t`) and unit-triggered state transitions (`on`/`off` functions) to manipulate internal flags, leveraging dynamic typing and marshaling via the `Datatype` module for serialization. Specific use cases include configuring command-line switches and tracking shared state across project components with type-safe persistence.",
      "description_length": 579,
      "index": 1211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout",
      "library": "frama-c-wp.core",
      "description": "This module configures timeouts for kernel functions, supporting operations to set, retrieve, compare values, manage defaults, register change hooks, and handle dynamic updates via aliases. It operates on string-based configuration data and structured categories, enabling command-line integration, persistent state management through serialization, and introspection for runtime parameter adjustments.",
      "description_length": 402,
      "index": 1212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Tactical.Fmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a map structure for tactical fields, supporting operations to create, retrieve, and update values associated with specific fields. It works with the abstract type `t` representing a map and the polymorphic `field` type for keyed access. Use this module to manage per-field state within tactical operations, such as storing and retrieving analysis data during proof execution.",
      "description_length": 398,
      "index": 1213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTimeout",
      "library": "frama-c-wp.core",
      "description": "This module manages configurable integer parameters with constraint enforcement, focusing on runtime value manipulation, bounds validation, and persistent state management. It operates on numeric parameters with associated min/max limits, supporting dynamic updates through atomic increments, range restrictions, and event hooks that trigger on value changes. The implementation facilitates command-line configuration with aliased options, contextual help messages, and project-specific serialization, making it suitable for scenarios requiring robust timeout configuration with user-defined boundaries and persistent state tracking across sessions.",
      "description_length": 649,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicAssigns.Make",
      "library": "frama-c-wp.core",
      "description": "Implements memory domain analysis and assignment logic for regions, using location-based memory models. It computes the heap footprint of a memory region and applies assignment constraints across memory states. Useful for verifying memory safety properties by tracking how assignments affect heap regions.",
      "description_length": 305,
      "index": 1215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout.Range",
      "library": "frama-c-wp.core",
      "description": "This module manages range-based regions within a layout, providing operations to check inclusion of positions within ranges and to compute overlapping regions. It works with range structures that define intervals, typically used to represent spatial or positional data in a layout. Concrete use cases include determining if a point lies within a defined region and merging intersecting regions to form a consolidated range.",
      "description_length": 423,
      "index": 1216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.Fun",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical functions in the Wp plugin's low-level logic language. It provides operations to inspect function properties such as their result sort, parameter list, and logical category, along with hashing, comparison, and pretty-printing utilities. It is used to analyze and process logical terms during verification tasks such as proof generation and constraint solving.",
      "description_length": 406,
      "index": 1217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptMode",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based configuration parameters for script execution modes, supporting operations to validate and constrain acceptable values, bind update hooks, and persist state across sessions. It works with string parameters that may represent function names or plain values, providing utilities for command-line argument parsing, default value assignment, and custom serialization. Typical use cases include configuring script behavior through validated string inputs and maintaining consistent parameter states during plugin execution.",
      "description_length": 551,
      "index": 1218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusAll",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared boolean state with operations to set, retrieve, and monitor changes to its value, including support for command-line configuration, default value initialization, and project-specific persistence. It leverages a companion `Datatype` module to handle equality, comparison, and marshaling for the boolean state, enabling seamless integration with Frama-C's project system. Typical use cases include toggling analysis features, tracking completion states of workflows, or enabling conditional logic based on the boolean flag's value.",
      "description_length": 558,
      "index": 1219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters for file paths, enabling operations like adding elements, checking emptiness, and iterating over collections while supporting hooks to track value changes. It works with validated string parameters, categorized groups, and integrates with Frama-C's state system to manage parameter persistence across projects. Specific use cases include customizing serialization formats, defining aliases for parameter sets, and handling dynamic updates to parameter lists during project execution.",
      "description_length": 527,
      "index": 1220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Ctypes.AinfoComparable",
      "library": "frama-c-wp.core",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Wp.Ctypes.arrayinfo`. It enables ordering and identity checks between array information structures, which are used to represent metadata about C arrays in the WP plug-in. Concrete use cases include comparing array bounds, element types, and structural equivalence in static analysis tasks.",
      "description_length": 375,
      "index": 1221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "This module enables manipulation of verification contexts through frame management and call context operations, handling memory environments tied to code locations. It compiles C logical constructs into semantic models, analyzing memory states, regions, and logical terms for safety verification. Key applications include memory safety proofs, lemma compilation, and region-based analysis during formal verification of code properties.",
      "description_length": 435,
      "index": 1222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing command-line parameters as lists of file paths (`Frama_c_kernel.Filepath.t list`), supporting element addition, iteration, folding, and dynamic modification via prepending/appending. It integrates with the Frama-C kernel's project and state mechanisms to enable persistent configuration, value change hooks, and alias resolution, while also handling custom serialization. A nested category system allows organizing parameters under named options like `@none`, `@default`, and `@all` for structured configuration scenarios.",
      "description_length": 567,
      "index": 1223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Status",
      "library": "frama-c-wp.core",
      "description": "This component manages state and modifications for boolean options, offering operations to set values directly, track changes via hooks, and maintain project-scoped defaults. It operates on shared boolean states integrated with Frama-C's project system, supporting marshaling for persistence and scoped state computation. Typical use cases include configuring plugin behaviors with dynamic updates, persisted settings, or context-sensitive default values across analysis sessions.",
      "description_length": 480,
      "index": 1224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.StaticGeneratorID",
      "library": "frama-c-wp.core",
      "description": "This module implements a static generator identifier context using a key module `K` and data module `D`, providing direct access to identifier registration and lookup operations. It supports key-based data storage with functions to check existence (`mem`), retrieve (`get`, `find`), insert (`set`), and remove (`remove`, `clear`) mappings. Concrete use cases include managing unique identifiers during static analysis or code generation phases where model-independent tracking is required.",
      "description_length": 489,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VCS.Pset",
      "library": "frama-c-wp.core",
      "description": "This module offers functional set operations for managing immutable collections of prover elements, supporting union, intersection, ordered traversal, and transformations like filtering or mapping. It works with persistent sets (`Pset.t`) and sequences of prover elements, maintaining total ordering for comparisons and bulk conversions between these structures. It is useful for tracking disjoint proof results, prioritizing prover execution order, or aggregating verification outcomes in formal verification workflows.",
      "description_length": 520,
      "index": 1226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DryFinalizeScripts",
      "library": "frama-c-wp.core",
      "description": "This module manipulates a boolean state to control dry-run execution of finalization scripts, offering operations to toggle the flag (`on`/`off`), register state-change hooks, and define aliases. It operates on a `bool` value encapsulated in a state-aware datatype, ensuring synchronized access and marshaling. Specifically used to enable/disable script validation workflows in the WP plugin without permanent execution.",
      "description_length": 420,
      "index": 1227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BoundForallUnfolding",
      "library": "frama-c-wp.core",
      "description": "This module manages a bounded integer parameter with operations to set, increment, and query its value within configurable min/max limits, while providing state tracking (e.g., computed status) and lifecycle management for verification workflows. It works with mutable integer state constrained by bounds, supporting use cases like tuning proof parameters in formal verification where controlled adjustments and observability are required. CLI integration features enable configuration via command-line flags with help documentation and aliases.",
      "description_length": 545,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report",
      "library": "frama-c-wp.core",
      "description": "This module supports managing command-line parameters that handle collections of file paths, enabling operations like element addition, iteration, and emptiness checks. It works with list-based data structures enhanced with validation logic and categorization features (e.g., `@all`/`@default` behaviors) for structured parameter grouping. Designed for Frama-C integration, it facilitates project-specific state management, serialization workflows, and automated help documentation generation.",
      "description_length": 493,
      "index": 1229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Heap",
      "library": "frama-c-wp.core",
      "description": "This module defines hash, equality, and comparison operations for heap chunks, enabling precise manipulation of memory regions in program verification tasks. It supports set and map structures specialized for heap-allocated data, with operations like union, intersection, and lookup tailored for symbolic execution and static analysis. Use cases include tracking memory states and managing key-value associations over heap regions with domain-specific merging and filtering.",
      "description_length": 474,
      "index": 1230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.TimeMargin",
      "library": "frama-c-wp.core",
      "description": "This module defines a parameter type for time margins using strings, enabling configuration through a command-line interface with features like help messages and aliases, while supporting hooks for tracking value changes and integration with Frama-C's kernel for state management and typing. It provides operations to validate and manipulate string-based parameters, including checks for acceptable values and function names, using string lists for allowed value sets. Typical use cases include configuring time margin settings via CLI, validating parameter inputs, and persisting parameter states across project sessions.",
      "description_length": 622,
      "index": 1231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.StmtSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "Supports operations for constructing and manipulating control flow graphs (CFGs) and associated proof goals, including",
      "description_length": 118,
      "index": 1232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadassumes",
      "library": "frama-c-wp.core",
      "description": "This module provides a boolean parameter abstraction with state-modifying operations to enable or disable dead assumption checking, featuring hooks for change detection, command-line interface visibility, and alias support. It operates on a custom data type managed through the Datatype submodule, enabling serialization, project-specific state tracking, and integration with the WP plugin's configuration system. The primary use case involves toggling verification behaviors in static analysis workflows by persisting and monitoring this critical option.",
      "description_length": 555,
      "index": 1233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ExtEqual",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with configuration capabilities, enabling operations to set and retrieve values, register state change hooks, and handle aliases for feature toggles. It operates on parameterized data structures that encapsulate boolean state alongside metadata such as default values, project-specific overrides, and CLI integration logic. Typical use cases include dynamically controlling plugin behavior through command-line switches, persisting feature states across sessions, and implementing conditional logic based on project-scoped configuration flags.",
      "description_length": 582,
      "index": 1234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofEngine.Node",
      "library": "frama-c-wp.core",
      "description": "Handles individual proof nodes with operations to compare, hash, and display them. Works directly with the `node` type from the `Wp.ProofEngine` module. Used to uniquely identify and inspect different states or steps within an interactive proof session.",
      "description_length": 253,
      "index": 1235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Detect",
      "library": "frama-c-wp.core",
      "description": "This module provides boolean state management for detection modes with operations to set, retrieve, and monitor changes to flags, including support for default values, command-line exposure, and project-specific persistence. It works with boolean values and associated metadata structures to handle aliases, equality checks, and marshaling, while integrating with Frama-C's state system. Typical use cases include enabling/disabling analysis features like runtime error detection or proof obligations through toggleable flags that persist across sessions or adapt to project configurations.",
      "description_length": 590,
      "index": 1236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Interactive",
      "library": "frama-c-wp.core",
      "description": "This module enables managing interactive configuration parameters through operations like setting and validating string-based values, registering change hooks, and handling aliases. It works with parameters that support default values, visibility controls, and project-specific state tracking, while also providing validation logic for function names and input constraints. Key use cases include cross-project state synchronization, dynamic UI updates via value change notifications, and enforcing valid parameter configurations through customizable validation rules.",
      "description_length": 567,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitSwitch",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean switch parameter with operations to toggle its state, register callbacks for value changes, and handle aliases or marshaling logic. It operates on a shared boolean state integrated with Frama-C's parameter system, supporting command-line configuration, default value management, and project-specific persistence. Use cases include dynamically enabling/disabling analysis features or tracking stateful options across plugin sessions.",
      "description_length": 462,
      "index": 1238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line options and tactic state through operations on string lists and structured parameters, supporting tasks like value registration, alias handling, and state validation. It enables configuration workflows for tactic behavior, including category-based organization, iterative updates, and persistent state tracking. Use cases include parsing command-line arguments with custom validation, dynamically extending parameter sets via hooks, and serializing tactic configurations for the WP plugin.",
      "description_length": 522,
      "index": 1239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Ground",
      "library": "frama-c-wp.core",
      "description": "This module provides boolean parameter management with lifecycle hooks, serialization, and integration into Frama-C's state system, enabling configuration options to be toggled, persisted, and synchronized with project state. It operates on a shared boolean state through a type `t` that supports default values, command-line exposure, and aliasing, with unary functions to explicitly set states to `on` or `off`. Designed for tracking and configuring boolean flags in the WP plugin, it facilitates use cases like enabling analysis features or runtime diagnostics through a consistent interface.",
      "description_length": 595,
      "index": 1240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgInit.Make",
      "library": "frama-c-wp.core",
      "description": "Implements initialization logic for global variables and kernel functions in the context of the WP plugin. Processes global initialization by transforming properties based on the environment and target function. Works with kernel functions and property types to refine or annotate initial states during analysis.",
      "description_length": 312,
      "index": 1241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCalculus.Make",
      "library": "frama-c-wp.core",
      "description": "Implements symbolic computation over logical propositions using a configurable calculus engine. Operates on weighted propositional logic formulas with explicit mode and property parameters. Useful for formal verification tasks requiring precise control over proof strategies and constraint propagation.",
      "description_length": 302,
      "index": 1242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyIsCint",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter controlling simplification logic during C integer analysis, including set/get functionality, change observation hooks, and command-line interface integration. It works with a boolean state value, supporting project-specific configuration persistence and custom marshaling for serialization. The parameter is used to enable or disable simplification rules when analyzing C integer operations, with aliases and help documentation for user configuration.",
      "description_length": 513,
      "index": 1243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Let",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean flags for feature toggles or configuration settings, offering operations to set and retrieve values, register state change callbacks, and define command-line aliases. It operates on a shared boolean state (`t = bool`) and integrates with project-specific contexts, enabling persistent configuration across sessions. Typical use cases include enabling/disabling analysis features via CLI options, propagating state changes through hooks, and maintaining user-friendly aliases for serialization or help documentation.",
      "description_length": 543,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpPropId.PropId",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and comparing property identifiers, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing property IDs, which are used to uniquely identify properties in different contexts such as loop invariants. The module supports deep copying, membership checks over projects, and provides structural descriptions for integration with other systems.",
      "description_length": 438,
      "index": 1245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.T",
      "library": "frama-c-wp.core",
      "description": "This module manages relocatable terms paired with sigma mappings, enabling term creation, retrieval, and relocation within a control flow graph. It supports operations to bundle terms with their generating sigma sequences, extract terms, and adjust terms when moved across graph nodes. Concrete use cases include tracking and relocating intermediate terms during control flow analysis and transformation passes.",
      "description_length": 411,
      "index": 1246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.Field",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical fields in the context of the WP plug-in's logic language. It provides operations for comparing, hashing, and pretty-printing fields, along with converting them to logic sorts. Concrete use cases include managing field identifiers during symbolic reasoning and debugging logical expressions.",
      "description_length": 337,
      "index": 1247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.MemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared boolean state to control memory context behavior through operations for setting values, registering update hooks, and managing aliases and serialization. It facilitates project-specific state tracking, integrates with command-line interfaces for option parsing and help display, and supports dynamic toggling of boolean flags to enable or disable features. Use cases include configuring memory context settings via CLI, persisting state changes across sessions, and synchronizing behavior with project lifecycle events.",
      "description_length": 548,
      "index": 1248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels.LabelSet",
      "library": "frama-c-wp.core",
      "description": "This module implements a functional set abstraction for managing ordered collections of normalized C-labels, supporting operations like union, intersection, difference, and structural equality checks. It works with sets of `c_label` elements processed in ascending order by default, enabling efficient membership tests, transformations, and logical predicates over ordered data. Use cases include static analysis tasks requiring precise label tracking, such as propagating labels through control flow graphs or validating label consistency in program logic, where ordered traversal and sequence-based bulk operations are critical.",
      "description_length": 630,
      "index": 1249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Verbose",
      "library": "frama-c-wp.core",
      "description": "This module manages verbosity levels through integer parameters, supporting operations to set value ranges, increment levels, and monitor changes. It integrates with Frama-C's state management and serialization systems, enabling project-specific configuration via command-line options with aliases and dynamic adjustments through value-change hooks. The core data structures include bounded integer values and their associated metadata for range enforcement and persistence.",
      "description_length": 474,
      "index": 1250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ProofTrace",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean state flag that controls proof tracing behavior, including setting, retrieving, and monitoring changes to the flag's value. It works with structured data through the `Datatype` module, supporting serialization, project-specific persistence, and hook-based state updates. Specific use cases include enabling or disabling proof trace generation dynamically and tracking configuration changes across analysis sessions.",
      "description_length": 467,
      "index": 1251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusMaybe",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter, including setting and retrieving its value, registering change hooks, handling serialization, and maintaining project-specific state. It supports command-line configuration, alias management, and integrates with Frama-C's state and parameter frameworks. The boolean state can be toggled using simple on/off operations, enabling use cases like dynamic option adjustments and event-driven updates.",
      "description_length": 458,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.MINDEX",
      "library": "frama-c-wp.core",
      "description": "This module provides a polymorphic map-like structure with typed keys from the model hierarchy, supporting standard dictionary operations (insertion, lookup, deletion) alongside batch processing (sequence-based updates) and functional transformations (folding, filtering). It operates on key-value pairs where keys are model identifiers and values are polymorphic, enabling efficient aggregation, bulk initialization, and in-place modification of structured data. Typical applications include managing model-specific metadata, accumulating statistics across model elements, or transforming hierarchical data in a type-safe manner.",
      "description_length": 630,
      "index": 1253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Literals",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean configuration parameter, supporting state transitions via `set`, `get`, and `clear` actions, along with lifecycle hooks for change notifications. It operates on a boolean type `t` and integrates with Frama-C's parameter system to enable serialization, alias handling, and dynamic configuration updates. It is particularly suited for toggling analysis modes or feature flags within the WP plugin's workflow.",
      "description_length": 458,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.S",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to identify and compare model registration contexts using unique identifiers, hash values, equality checks, and ordering. It works with the abstract type `t` representing a model registration context. Concrete use cases include managing and distinguishing different model registration sessions within the WP plug-in.",
      "description_length": 348,
      "index": 1255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Procs",
      "library": "frama-c-wp.core",
      "description": "This module manages procedural parameters as integer values, enabling operations to set, query, and monitor changes via hooks, while enforcing valid bounds and supporting project-specific state serialization. It provides utilities to define aliases, customize marshaling, and manipulate parameter constraints, such as incrementing values or restricting ranges. These capabilities are used to configure plugin behavior under controlled limits, persist parameter states, and synchronize settings across distinct project contexts.",
      "description_length": 527,
      "index": 1256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitBranch",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter controlling branch splitting behavior, offering functions to toggle its state, register change listeners, and bind command-line flags. It operates on a boolean value augmented with metadata, supporting introspection, serialization, and project-specific state tracking through computed dependencies and update hooks. Typical applications include dynamically enabling/disabling branch splitting during analysis and customizing CLI interactions for different project workflows.",
      "description_length": 514,
      "index": 1257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.CheckMemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean option, including setting, retrieving, and monitoring value changes, with support for update hooks, custom marshaling, and alias handling. It works with boolean values and structured state data through the `Datatype` module, primarily facilitating memory context checks in static analysis workflows. Specific use cases include enabling or disabling memory checks via state toggles and tracking configuration changes for analysis tools.",
      "description_length": 487,
      "index": 1258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemLoader.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements memory loading operations for compound values, handling domain computation, value extraction, and equation generation for memory assignments and initializations. It operates on C objects and memory locations, producing terms and equations used in symbolic memory reasoning. Concrete use cases include modeling memory reads, writes, and initializations during program verification tasks.",
      "description_length": 409,
      "index": 1259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.LogicCompiler.Make",
      "library": "frama-c-wp.core",
      "description": "This module enables modeling logical frames with local variables, symbolic execution environments with variable bindings, and compilation of logic expressions and lemmas. It operates on types like `frame`, `env`, and logic terms to support formal verification tasks such as reasoning about C function pre/post-conditions, symbolic state transitions, and type-checking logical assertions within the Frama-C kernel. Key use cases include verifying memory states, evaluating predicates across contexts, and integrating lemma definitions into verification workflows.",
      "description_length": 562,
      "index": 1260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Probes",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameter states through operations like setting values, registering change hooks, and defining command-line interfaces, while tracking computed states within Frama-C projects. It works with boolean values and project-specific data structures to support use cases such as user-configurable analysis toggles, internal state synchronization, and serialized parameter persistence across sessions.",
      "description_length": 421,
      "index": 1261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters and collections, enabling operations like value modification, element iteration, and state-change hooks. It organizes parameters into categorized, validated data structures with serialization support, tailored for dynamic plugin configuration and project management scenarios requiring strict CLI parsing constraints.",
      "description_length": 374,
      "index": 1262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.P",
      "library": "frama-c-wp.core",
      "description": "This module represents predicates bundled with their associated sigma mappings and provides operations to manipulate and analyze them. It supports creating relocatable predicates from sigma maps and logical expressions, retrieving their underlying predicate, and determining data dependencies and control flow nodes. Use cases include tracking predicate validity across control flow graph transformations and generating conditions for path-sensitive analysis.",
      "description_length": 459,
      "index": 1263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Offset",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for working with memory offsets in the context of C types and structures. It provides functions to create, compare, and pretty-print offset values, as well as compute type information, field positions, and size details using a cache for efficiency. Concrete use cases include analyzing struct field layouts, determining memory ranges for offset chains, and supporting precise memory reasoning in static analysis.",
      "description_length": 443,
      "index": 1264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Filter",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean filter state with operations to toggle its value, register change listeners, and synchronize with project-specific contexts. It works with boolean values (`t`) and integrates with project state management systems through the `Datatype` module. It is particularly used to implement command-line options and persistent filter settings that adapt to different project environments.",
      "description_length": 408,
      "index": 1265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Session",
      "library": "frama-c-wp.core",
      "description": "This module manages a specific session directory for the WP plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of session-specific storage. Use cases include storing and retrieving session-specific configuration files or intermediate data during analysis.",
      "description_length": 400,
      "index": 1266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgCompiler.C",
      "library": "frama-c-wp.core",
      "description": "This module represents conditions tied to a specific sigma sequence, enabling their relocation to new sequences. It provides operations to create, retrieve, and compare conditions, along with extracting the domain of variables they depend on. Useful for managing logical conditions across different control flow points in a program analysis.",
      "description_length": 341,
      "index": 1267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Timeout",
      "library": "frama-c-wp.core",
      "description": "This module provides integer-based timeout management with operations to enforce value constraints, track changes via hooks, and persist configurations. It works with integer parameters extended by metadata for default states, valid ranges, and project-specific context, enabling structured manipulation of timeout settings. Typical use cases include configuring analysis timeouts in the plugin, validating against user-defined bounds, and synchronizing parameter changes across different components.",
      "description_length": 500,
      "index": 1268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing command-line parameters as string lists, including value manipulation, alias handling, and notification hooks for changes. It works with categorized parameters that support validation and state tracking, enabling use cases like dynamic plugin configuration and command-line interface integration where serialization, comparison, and iterative processing are required.",
      "description_length": 412,
      "index": 1269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Matrix",
      "library": "frama-c-wp.core",
      "description": "Handles matrix-like region layouts with operations for computing greatest common divisors, pretty-printing integer lists, calculating sizes based on element counts, and merging integer lists. Works directly with integer lists and integers to support layout computations. Used for aligning and structuring memory regions in the WP plugin.",
      "description_length": 337,
      "index": 1270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Usage",
      "library": "frama-c-wp.core",
      "description": "This module manages layout usage information for regions in the WP plugin. It provides operations to merge usage data, check if a region is shifted or aliased, and format usage information for display. It works directly with the `Wp.Layout.usage` type to support analysis of memory regions in program verification tasks.",
      "description_length": 320,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model",
      "library": "frama-c-wp.core",
      "description": "This module supports operations for managing command-line parameters as string lists and collections, enabling tasks like value assignment, retrieval of current or default states, and change tracking via hooks. It works with structured data types such as parameter categories (with access rules and aliases), string-element collections, and serialized project states. Specific use cases include configuring plugin behavior through CLI arguments, synchronizing parameter updates with project states, and generating contextual help documentation for parameter sets.",
      "description_length": 563,
      "index": 1272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.VCS.Pmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a map structure for associating prover identifiers with arbitrary values, offering efficient insertion, deletion, ordered traversal, and extremum queries. It supports sequence-based transformations like bulk loading and ordered iteration, enabling use cases such as aggregating verification results across provers or processing prover-specific data in deterministic key order. Operations ensure deterministic handling of key ordering and batch manipulations, such as merging and filtering, while maintaining compatibility with list and sequence representations.",
      "description_length": 584,
      "index": 1273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice.Absurd",
      "library": "frama-c-wp.core",
      "description": "Implements the absurd tactical for discharging goals by contradiction. Works with logical propositions and proof contexts to derive conclusions from inconsistent assumptions. Useful in proof scripts where a contradiction is explicitly needed to validate a step.",
      "description_length": 261,
      "index": 1274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Letify.Defs",
      "library": "frama-c-wp.core",
      "description": "This module manages definitions extracted from logical predicates, supporting operations to add, merge, and extract definitions. It works with logical variables and predicates from the `Wp.Lang.F` module, maintaining mappings from variable identifiers to their defining expressions. Concrete use cases include tracking variable definitions during weakest precondition computation and simplifying logical expressions by substituting defined variables.",
      "description_length": 450,
      "index": 1275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for deep copying, equality checking, comparison, hashing, and pretty-printing, primarily used for representing and manipulating proof obligations. It supports structured data management through associated Set, Map, and Hashtbl modules, enabling ordered collections, efficient lookups, and state tracking. Concrete use cases include managing symbolic analysis states, verifying program properties, and handling structured verification data with precise identity and ordering constraints.",
      "description_length": 534,
      "index": 1276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.Index",
      "library": "frama-c-wp.core",
      "description": "This module manages a model-specific registry of named entities, supporting operations to define, retrieve, and manipulate data associated with unique keys. It provides key-based lookups, memoization with circularity protection, and callbacks for value changes, working with key and data types defined by the parameter module E. Concrete use cases include tracking logical symbols, axioms, or proof obligations within the WP plugin's verification process.",
      "description_length": 455,
      "index": 1277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitMax",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage an integer parameter representing a bounded maximum split value, supporting configuration through command-line interfaces, default value handling, and update hooks. It works with integer values constrained to a dynamically defined range, enforcing min/max limits during manipulation. Key use cases include static analysis parameter tuning, interactive configuration with range validation, and integration with project state management systems for persistent settings.",
      "description_length": 509,
      "index": 1278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ExternArrays",
      "library": "frama-c-wp.core",
      "description": "This module provides configuration and state management operations for a boolean option that controls external array analysis behavior in the WP plugin. It works with simple boolean values to enable/disable features, supports state toggling via `on`/`off` functions, and allows customization through hooks, aliases, and marshaling. Specific use cases include dynamically adjusting analysis sensitivity to external array operations during verification tasks.",
      "description_length": 457,
      "index": 1279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.Raw",
      "library": "frama-c-wp.core",
      "description": "This module tracks variable usage by reporting all variable accesses as by-value. It operates on `varinfo` structures from CIL types, providing functions to iterate over variables and extract parameter information. Use it to analyze memory contexts where variables are accessed directly rather than through pointers.",
      "description_length": 316,
      "index": 1280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Generate",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage boolean parameters with support for command-line configuration, default value tracking, and project-specific state persistence. It works with structured data types to handle value serialization, alias resolution, and update hooks, enabling use cases like plugin configuration toggles and runtime state synchronization with Frama-C's kernel. Key features include atomic state updates via direct value setting and dependency-aware customization of parameter behavior.",
      "description_length": 507,
      "index": 1281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcode",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage boolean flags for feature control, including value setting, hook registration, alias resolution, and serialization customization. It operates on configuration parameters that track project-specific state and default values, enabling runtime toggling of behaviors like smoke deadcode analysis. The design supports use cases such as command-line interface integration and dynamic feature activation without requiring code changes.",
      "description_length": 470,
      "index": 1282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wpo.GOAL",
      "library": "frama-c-wp.core",
      "description": "This module manages goal states in a verification process, providing operations to create, compute, and inspect goals using sequents and proposition IDs. It supports data types like `t` for goal representations, `Wp.Conditions.sequent` for logical conditions, and `Wp.Lang.F.pred` for proof terms. Concrete use cases include generating proof obligations, computing goal descriptions, and retrieving timing information for proof attempts.",
      "description_length": 437,
      "index": 1283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InitWithForall",
      "library": "frama-c-wp.core",
      "description": "This module enables managing boolean parameter configurations through operations that set, retrieve, and track state changes, with support for aliases, marshaling, and project-scoped persistence. It works with boolean values as primitive state switches and structured parameter definitions to control dynamic behavior in the plugin environment. Specific use cases include toggling analysis features at runtime and synchronizing configuration states across different project contexts.",
      "description_length": 483,
      "index": 1284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Plang.Env",
      "library": "frama-c-wp.core",
      "description": "This module manages a binding environment for pretty-printing logical terms, providing operations to create, copy, and clear environments, track used identifiers, generate fresh names, and define or unfold term bindings. It works with string identifiers and terms from `Wp.Lang.F`, supporting name sanitization, sharing detection, and variable indexing. Concrete use cases include managing variable bindings during term pretty-printing and ensuring unique identifier generation in logical formula output.",
      "description_length": 504,
      "index": 1285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoWidth",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage an integer parameter constrained within a mutable range, supporting value adjustments via increment, bounded assignment, and range configuration. It works with integer values and structured state representations that include min/max bounds, integrating change tracking, command-line parsing, and serialization. Typical use cases involve numeric configuration settings requiring range validation, such as width parameters in a toolchain where values must stay within dynamically defined limits while supporting persistence and cross-context synchronization.",
      "description_length": 598,
      "index": 1286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Print",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter controlling printing behavior, including setting and retrieving values, registering state change callbacks, and handling command-line configuration with aliases and help documentation. It works with boolean values and structured data through the Datatype module, enabling persistent state management and serialization for analysis workflows in Frama-C projects. Use cases include dynamically toggling output verbosity and synchronizing print settings across project sessions.",
      "description_length": 537,
      "index": 1287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Share",
      "library": "frama-c-wp.core",
      "description": "This module manages the plugin's share directory configuration by setting, retrieving, and validating directory paths. It provides direct access to specific directories and files within the share directory, ensuring they exist and are of the correct type. Concrete use cases include locating plugin-specific resources such as configuration files or auxiliary data directories.",
      "description_length": 376,
      "index": 1288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.ADT",
      "library": "frama-c-wp.core",
      "description": "This module represents algebraic data types (ADTs) within a logic language, providing operations for structural comparison, hashing, and pretty-printing. It works directly with the abstract type `t` representing ADT terms, supporting manipulation and inspection of logical expressions. Concrete use cases include managing term identities during theorem proving, generating human-readable debug output, and facilitating term-based computations requiring structural equality or ordering.",
      "description_length": 485,
      "index": 1289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Debug",
      "library": "frama-c-wp.core",
      "description": "This module provides configuration and control mechanisms for integer-based debug parameters, supporting operations like value modification within bounded ranges, change tracking, and command-line interface integration for dynamic adjustment. It works with integer values enhanced by metadata for structured inspection, serialization, and project-specific state persistence, primarily used in debugging workflows to manage logging levels, tracing flags, or analysis thresholds. The design enables interactive debugging tools to expose runtime-configurable options while maintaining type-safe data representation.",
      "description_length": 612,
      "index": 1290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoDepth",
      "library": "frama-c-wp.core",
      "description": "This module manipulates an integer parameter with optional range constraints, supporting operations to increment, set, and retrieve its value, define valid ranges, and manage update hooks. It integrates with Frama-C's parameter system for command-line configuration and persistence, enabling dynamic adjustment of analysis depth settings in project-specific contexts. The parameter tracks state across sessions and enforces value validity through customizable bounds.",
      "description_length": 467,
      "index": 1291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Value",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing, merging, and inspecting layout values, which represent structured data regions in memory. It supports concrete operations like `compare` and `equal` for ordering and equivalence checks, `merge` for combining values with a custom strategy, and `pointed` for extracting underlying data. Use cases include analyzing memory layouts during static analysis and managing region-based data structures in program verification.",
      "description_length": 463,
      "index": 1292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.BackTrack",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a tracked integer state with backtracking capabilities, supporting dynamic value modification, change notifications, and project-specific persistence control. It also enables constrained integer parameters with bounded ranges and incremental adjustments, catering to use cases like runtime configuration tuning, stateful computation management, and validated numerical input handling in development tools.",
      "description_length": 447,
      "index": 1293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Provers",
      "library": "frama-c-wp.core",
      "description": "This module enables managing prover-related command-line parameters through operations like setting values, registering change hooks, and handling serialization, while supporting iteration, folding, and validation of string-based option lists. It operates on `string list` collections to track project-specific configurations, enforce parameter categories, and integrate with command-line interfaces. Key use cases include maintaining default values, dynamically updating parameter states, and appending predefined lists during workflow execution.",
      "description_length": 547,
      "index": 1294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Core",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage boolean parameters with state tracking, including setting values (on/off), handling change notifications, and integrating with command-line interfaces (e.g., help messages, aliases). It works with boolean states and metadata, leveraging the `Datatype` module for serialization, and supports use cases like configuring plugin behavior through CLI arguments or persisting analysis settings across sessions.",
      "description_length": 446,
      "index": 1295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrecondWeakening",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter to toggle precondition weakening behavior, offering operations to set, retrieve, and observe value changes via hooks. It works with a simple boolean type augmented by configuration capabilities for command-line arguments, default values, serialization, and backward-compatible aliases. It is used to control analysis options dynamically, enforce consistent defaults, and adapt legacy configurations seamlessly.",
      "description_length": 450,
      "index": 1296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Definitions.Trigger",
      "library": "frama-c-wp.core",
      "description": "Converts terms and predicates into trigger annotations for SMT solvers. Uses variables from triggers to guide quantifier instantiation. Useful for specifying patterns that influence proof search in automated reasoning tasks.",
      "description_length": 224,
      "index": 1297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.OldReportJson",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage string-valued parameters with validation, including setting allowed values, validating inputs against predefined rules or functions, and handling pre/post-update hooks. It works with string parameters, function-name validators, and project-specific state, supporting custom marshaling and command-line integration. It is used to enforce controlled configuration updates and input validation in Frama-C plugin workflows.",
      "description_length": 461,
      "index": 1298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Prune",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a boolean parameter, including setting and retrieving values, registering update hooks, handling aliases, and supporting serialization and introspection. It operates on a shared boolean state and associated structured data, enabling use cases such as dynamically controlling pruning behavior during program analysis and persisting configuration settings.",
      "description_length": 396,
      "index": 1299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CodeSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "This module evaluates and manipulates abstract values, expressions, and memory locations, with operations including type casting, expression evaluation, and conversion to logical terms or memory states. It works with data structures such as abstract values, memory states (sigma), and CIL expressions, supporting static analysis tasks like memory modeling, constraint checking, and variable initialization verification.",
      "description_length": 419,
      "index": 1300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.For_export",
      "library": "frama-c-wp.core",
      "description": "This module handles term rebuilding and manages built-in functions for equality and ordering in a logic language. It works with terms, mappings, and function definitions to support transformations and state operations. Use cases include customizing equality checks, injecting stateful computations, and integrating with external logic APIs.",
      "description_length": 340,
      "index": 1301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F",
      "library": "frama-c-wp.core",
      "description": "This module enables the construction and manipulation of logical expressions, arithmetic operations, and symbolic terms with support for quantifiers, binders, and logical connectives. It operates on structured data types like terms, predicates, variables, and substitutions, leveraging efficient collections such as variable maps, predicate sets, and term graphs to facilitate symbolic reasoning, theorem proving, and formal verification tasks where precise logical analysis and term evaluation are critical.",
      "description_length": 508,
      "index": 1302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage string sets as command-line parameters, including value manipulation, update hooks, serialization, and categorization. It works with a string set data structure to support configuration management, plugin systems, and project state tracking, offering features like dynamic updates, membership checks, and custom marshaling.",
      "description_length": 365,
      "index": 1303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Cluster",
      "library": "frama-c-wp.core",
      "description": "This module manages memory layout clusters for static analysis, providing operations to manipulate and query structured memory regions. It supports dereferencing lazy pointers, shifting offsets, merging clusters, and checking properties like emptiness or garbling. Use cases include tracking memory state during symbolic execution and aligning data structures in formal verification.",
      "description_length": 383,
      "index": 1304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicSemantics",
      "library": "frama-c-wp.core",
      "description": "This module compiles C logical constructs into semantic models, handling memory environments and logical terms for safety verification. It supports operations on memory states, regions, and frame management to enable proof of memory safety and lemma compilation. Concrete use cases include analyzing code properties during formal verification and managing call contexts for region-based logical reasoning.",
      "description_length": 405,
      "index": 1305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofStrategy",
      "library": "frama-c-wp.core",
      "description": "This module defines and manages proof strategies and their alternatives for verifying program properties. It provides operations to retrieve, name, and apply strategies to proof nodes, along with extracting prover configurations and fallback behaviors. Use cases include directing automated theorem proving by selecting appropriate strategy alternatives based on heuristics or explicit hints.",
      "description_length": 392,
      "index": 1306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacUnfold",
      "library": "frama-c-wp.core",
      "description": "This module implements a built-in unfold tactical that expands function definitions in proof terms. It operates on logical functions and terms, supporting interactive proof refinement by applying unfold steps to selected subterms. Use cases include simplifying complex expressions during verification and exposing function behavior in proof goals.",
      "description_length": 347,
      "index": 1307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgInfos",
      "library": "frama-c-wp.core",
      "description": "This module analyzes control flow graphs and function behaviors, providing access to properties like unreachable code, termination dependencies, and call relationships. It works with kernel functions, control flow automata, and statement-level annotations. Concrete use cases include determining if a function is recursive, checking if a statement is unreachable, or retrieving properties that affect termination.",
      "description_length": 413,
      "index": 1308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVar",
      "library": "frama-c-wp.core",
      "description": "Tracks variable usage in memory contexts by analyzing direct variable accesses and static CIL variable information. It operates on CIL `varinfo` and kernel function structures, providing functions to iterate over variables, extract parameter representations, and initialize variable tracking. Used to analyze memory contexts where variables are accessed directly, and to track variable dependencies in C code based on static declarations.",
      "description_length": 438,
      "index": 1309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacInduction",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in range tactical that automatically registers with the WP plugin. It provides the `tactical` value of type `Wp.Tactical.tactical`, enabling proof strategies based on range analysis. This module is used to apply induction tactics over numeric ranges during verification condition generation.",
      "description_length": 310,
      "index": 1310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCompound",
      "library": "frama-c-wp.core",
      "description": "This module implements a compound tactical that combines multiple proof strategies into a single, prioritized tactic. It works with proof selections and strategies, allowing dynamic composition of automated proof steps. Use it to define complex proof automation that applies different tactics based on the current proof state.",
      "description_length": 326,
      "index": 1311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgAnnot",
      "library": "frama-c-wp.core",
      "description": "This module normalizes annotations by reorganizing and relabeling them for use in proof and dispatching within the CfgCalculus. It processes function behaviors, loop contracts, and code assertions, extracting structured information such as preconditions, postconditions, assigns, and termination conditions. Concrete use cases include retrieving function behavior goals, generating loop invariants, and extracting code assertions for verification tasks.",
      "description_length": 453,
      "index": 1312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Footprint",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for analyzing and manipulating term footprints in a breadth-first manner. It works with terms from `Wp.Lang.F` and strings to represent footprint patterns, supporting concrete tasks like matching, locating, and retrieving specific term occurrences. Use cases include identifying subterm positions and extracting matching components within formal expressions.",
      "description_length": 390,
      "index": 1313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VC",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates the lifecycle of formal verification tasks, focusing on generating, managing, and proving logical obligations derived from code properties and function behaviors. It manipulates structured data like proof obligations (with metadata such as validity status and prover results), kernel function specifications, and prover configurations, while enabling parallelized proof execution through task servers. Key applications include validating behavioral contracts in static analysis, automating theorem proving for safety-critical systems, and integrating formal methods into development workflows via command-line interfaces or asynchronous proof strategies.",
      "description_length": 679,
      "index": 1314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCalculus",
      "library": "frama-c-wp.core",
      "description": "Implements symbolic computation over logical propositions using a configurable calculus engine. Operates on weighted propositional logic formulas parameterized by mode and property types. Enables formal verification tasks requiring precise control over proof strategies and constraint propagation.",
      "description_length": 297,
      "index": 1315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Tactical",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for constructing and composing logical proof tactics, manipulating selections, clauses, terms, and conditions through transformations like rewrite, replace, and split. It supports UI-driven configurations via controls (checkboxes, spinners) and manages tactic registration, parameterization, and composition for structured term manipulation. These capabilities are applied in theorem-proving workflows to enable interactive proof strategies, dynamic tactic assembly, and debug visualization of logical structures.",
      "description_length": 545,
      "index": 1316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang",
      "library": "frama-c-wp.core",
      "description": "This module facilitates the translation of C constructs into logical representations, supporting the construction of algebraic data types (ADTs), logic functions, and predicates. It operates on CIL types, logical terms, and substitution environments, enabling formal verification tasks like theorem proving and constraint solving by converting C types into logic types (e.g., `tau`, `adt`), managing verification contexts, and defining built-in symbols or external logic functions tied to C structures. Key use cases include generating identifiers for CIL elements, handling field-level logic translations, and maintaining scoping or hypothesis tracking during proof obligations.",
      "description_length": 679,
      "index": 1317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice",
      "library": "frama-c-wp.core",
      "description": "This module provides tacticals for logical branching, contradiction discharge, and contrapositive reasoning. It works with proof goals, logical propositions, and tactics to guide proof search and transformation. Used to implement decision points in automated proof strategies, derive conclusions from contradictions, and restructure implications by negation.",
      "description_length": 358,
      "index": 1318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cstring",
      "library": "frama-c-wp.core",
      "description": "This module handles string literals and wide string literals, providing operations to access their properties and contents. It defines functions to retrieve the length, character values, and unique identifiers for string literals, as well as a way to obtain the cluster where strings are stored. Concrete use cases include analyzing or generating code that involves string constants and their memory representations.",
      "description_length": 416,
      "index": 1319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacRange",
      "library": "frama-c-wp.core",
      "description": "This module defines a tactical for specifying integer range constraints during proof automation. It provides fields `vmin` and `vmax` to set the minimum and maximum values, and a `strategy` function to apply the tactical with a given selection and priority. It is used to guide proof search by restricting the range of integer expressions considered during tactic application.",
      "description_length": 376,
      "index": 1320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Ptip",
      "library": "frama-c-wp.core",
      "description": "Handles visibility and structuring of proof terms within a proof session. It defines how parts of terms are displayed or folded, supporting operations to manipulate term visibility states and associate them with specific goals or steps. Used to control the presentation of complex proof terms during interactive theorem proving.",
      "description_length": 328,
      "index": 1321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cmath",
      "library": "frama-c-wp.core",
      "description": "This module defines conversions between integers, real numbers, and booleans, along with mathematical functions such as absolute value and square root. It operates on terms and unary operations from the Wp.Lang.F module, and provides specific functions like `int_of_bool`, `real_of_int`, `f_iabs`, and `f_sqrt`. Concrete use cases include manipulating arithmetic expressions in formal verification tasks, such as converting boolean results to integers or computing square roots in logical formulas.",
      "description_length": 498,
      "index": 1322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Plang",
      "library": "frama-c-wp.core",
      "description": "This module manages memory allocation and identifier tracking for logical terms and predicates, providing functions to allocate terms, predicates, and variable sets within a scoped environment. It works with logical terms and variables from `Wp.Lang.F`, using a pool to control resource management and ensure consistent identifier handling. Concrete use cases include tracking variable usage during term pretty-printing and managing scoped allocations for logical formulae generation.",
      "description_length": 484,
      "index": 1323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpReport",
      "library": "frama-c-wp.core",
      "description": "This module captures and exports analysis statistics, including proof success rates and resource usage. It defines a `fcstat` type to hold these metrics and provides functions to generate reports in standard and JSON formats. Use it to log verification outcomes and performance data for later analysis or integration with external tools.",
      "description_length": 337,
      "index": 1324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacBitrange",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in tactical for handling bit range operations within the WP plug-in. It provides the `tactical` function for bit range manipulation and the `strategy` function to define selection strategies with optional priority. This module is used to automate proofs involving bitwise operations and memory layout manipulations in program verification tasks.",
      "description_length": 364,
      "index": 1325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for modeling memory regions and structured data layouts through integer range manipulation, alias analysis, and symbolic representation of offsets and lvalues. It works with data structures like range sets, memory clusters, and hierarchical layouts to support tasks such as tracking heap allocations, analyzing pointer aliasing, and verifying memory safety in symbolic execution contexts. Specific use cases include formal verification of memory operations, static analysis of array bounds, and precise modeling of compound data structures during program analysis.",
      "description_length": 596,
      "index": 1326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemEmpty",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling and verification capabilities, including operations for configuring memory states, performing load/store and pointer arithmetic, and validating memory segments. It operates on abstract memory locations (`loc`), memory states (`sigma`), and logical predicates to enforce constraints like heap initialization, pointer validity, and separation between memory regions. These features are used in formal verification tasks to align symbolic memory representations with C semantics and track dependencies during program analysis.",
      "description_length": 560,
      "index": 1327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpReached",
      "library": "frama-c-wp.core",
      "description": "This module analyzes control flow reachability for smoke testing in C code verification. It provides functions to determine if statements, annotations, or code paths are dead or unreachable, using memoized reachability data for functions. Key operations include checking if a statement requires smoke testing, identifying dead code annotations, and determining if a predicate is trivially true or false. Use cases include optimizing test generation by skipping unreachable code and verifying that critical statements are properly covered by tests.",
      "description_length": 547,
      "index": 1328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemZeroAlias",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling and verification operations for program analysis, focusing on pointer arithmetic, memory state transformations, and safety checks. It works with memory locations (`loc`), memory states (`sigma`), and segments to handle tasks like initialization tracking, allocation, and logical formula generation for memory safety proofs. Key use cases include analyzing pointer validity, managing memory partitions, and verifying properties of low-level memory operations in C programs.",
      "description_length": 509,
      "index": 1329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify",
      "library": "frama-c-wp.core",
      "description": "This module combines substitution, definition management, and occurrence tracking to support selective variable binding and predicate augmentation. It operates on logical variables, substitutions, and predicates to enable precise control over definition propagation and case analysis. Concrete use cases include refining proof contexts by injecting relevant definitions and prioritizing proof splits based on predicate frequency.",
      "description_length": 429,
      "index": 1330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc",
      "library": "frama-c-wp.core",
      "description": "Implements tacticals for introducing and managing non-deterministic state changes in proofs, specifically for modeling undefined behavior and memory safety in C-like languages. Works with program variables, memory states, and logical assertions to enable precise verification of heap-manipulating functions. Directly supports use cases such as verifying memory separation, enforcing aliasing constraints, and validating safe variable elimination during proof construction.",
      "description_length": 472,
      "index": 1331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofSession",
      "library": "frama-c-wp.core",
      "description": "Manages proof scripts for verification tasks, including loading, saving, and removing scripts associated with proof obligations. It handles file paths and JSON data to store and retrieve proof artifacts, supporting batch, update, dry, and init modes. Used to control proof session behavior, track script status, and manage temporary or persistent proof data during analysis.",
      "description_length": 374,
      "index": 1332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacClear",
      "library": "frama-c-wp.core",
      "description": "Clears local hypotheses from the proof context to simplify verification conditions. Works directly with the logical environment by removing unnecessary assumptions. Useful when focusing on specific goals by eliminating irrelevant hypotheses.",
      "description_length": 241,
      "index": 1333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler",
      "library": "frama-c-wp.core",
      "description": "This component provides functions to construct and analyze control flow graphs using nodes, predicates, and guarded transitions, enabling path-sensitive reasoning through operations like branching, concatenation, and conditional execution. It models memory effects, havoc, and assumptions over execution traces and memory states, translating CFGs into logical constraints within sigma domains to support static analysis tasks",
      "description_length": 425,
      "index": 1334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Context",
      "library": "frama-c-wp.core",
      "description": "This module manages contextual values with dynamic scoping, allowing creation, binding, and manipulation of named values within a context. It supports operations like setting, getting, and updating values, as well as binding and freeing context values during function execution. Concrete use cases include managing configuration settings or state that needs to be temporarily modified and restored during analysis or transformation tasks.",
      "description_length": 438,
      "index": 1335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Passive",
      "library": "frama-c-wp.core",
      "description": "This module manages passive forms, which represent symbolic constraints and variable relationships in logical formulas. It supports operations like union, binding, and joining of variables, along with applying and extracting conditions based on predicates. Use cases include manipulating logical expressions in static analysis tasks, such as tracking variable equivalences or simplifying constraints during verification.",
      "description_length": 420,
      "index": 1336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CodeSemantics",
      "library": "frama-c-wp.core",
      "description": "This module evaluates and manipulates abstract values, expressions, and memory locations, offering operations such as type casting, expression evaluation, and conversion to logical terms or memory states. It operates on data structures including abstract values, memory states (sigma), and CIL expressions, enabling tasks like memory modeling, constraint checking, and variable initialization verification. Use cases include analyzing program behavior during static analysis and transforming expressions into logical representations for verification.",
      "description_length": 550,
      "index": 1337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Definitions",
      "library": "frama-c-wp.core",
      "description": "This component organizes logical entities like axioms, lemmas, and functions into clusters, enabling structured management through operations such as creation, comparison, and source-position tracking. It handles logic definitions (including typed functions, lemmas, and CIL-based types) alongside SMT solver triggers, supporting term transformation, compilation, and resolution tasks. These capabilities facilitate formal verification workflows, structured proof organization, and integration with automated reasoning tools.",
      "description_length": 525,
      "index": 1338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cint",
      "library": "frama-c-wp.core",
      "description": "This module provides arithmetic and bitwise operations, conversions between integer representations, and management of arithmetic models (natural vs. machine). It operates on `c_int` and `Lang.F` terms, supporting low-level bit manipulation, logical condition simplification, and pattern recognition for bitmasks or powers of two. Key use cases include optimizing overflow-aware integer computations, streamlining logical expressions by removing redundant type checks, and verifying bit-level properties in formal verification workflows.",
      "description_length": 537,
      "index": 1339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacCongruence",
      "library": "frama-c-wp.core",
      "description": "This module provides a tactical and strategy for handling product and division comparisons in proofs. It works with logical expressions involving arithmetic operations, particularly focusing on equality and inequality reasoning. Use cases include automating proof steps that require rewriting or simplifying terms involving multiplication and division.",
      "description_length": 352,
      "index": 1340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory",
      "library": "frama-c-wp.core",
      "description": "This module defines core data structures and operations for modeling memory states, including equations, access modes, and memory values like addresses and chunks. It supports precise representation of memory updates and l-values through types like `update` and `s_lval`, enabling reasoning about C and ACSL code semantics. Concrete use cases include tracking memory assignments, modeling pointer accesses, and managing memory state transitions during program analysis.",
      "description_length": 469,
      "index": 1341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Filtering",
      "library": "frama-c-wp.core",
      "description": "Performs predicate simplification by removing sub-expressions that do not meet a given condition, replacing them with true or false constants. Works directly on logical predicates and sequents, using custom filtering functions to determine which parts to erase. Useful for optimizing proof obligations by eliminating irrelevant hypotheses or simplifying complex conditions during static analysis.",
      "description_length": 396,
      "index": 1342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing memory chunks and environments, including comparison, merging, variable retrieval, and domain manipulation, alongside functions for transforming and iterating over memory states. It operates on sigma environments and chunk data structures, with specialized support for heap-allocated data and domain-specific memory regions, enabling precise tracking and verification of memory accesses in program analysis workflows.",
      "description_length": 462,
      "index": 1343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpTac",
      "library": "frama-c-wp.core",
      "description": "This module provides term manipulation operations for converting and analyzing logical expressions in the context of tacticals. It includes functions to transform terms into conjunctive (CNF) and disjunctive (DNF) normal forms, handle conditionals (ITE), equivalences (IFF), and exclusive or (XOR), and check whether a term already conforms to CNF or DNF. These operations are used to simplify and reason about logical formulas during proof automation.",
      "description_length": 452,
      "index": 1344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemTyped",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to model and manipulate memory locations, including pointer arithmetic, field/array access, and memory state transitions with formal constraints. It works with memory segments, validity states, and blocks to support tasks like validating heap states, verifying allocation correctness, and generating logical constraints for program analysis. Key functionalities include computing byte distances, asserting memory validity, and managing separation or inclusion of memory regions during verification.",
      "description_length": 530,
      "index": 1345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Pcfg",
      "library": "frama-c-wp.core",
      "description": "This module manages a program control flow graph (CFG) with labeled nodes and edges, supporting operations to create and query the graph structure. It works with terms, labels, and memory values to track control flow transitions, variable updates, and visibility. Concrete use cases include analyzing program paths, determining reachable nodes, and tracking term dependencies in the CFG.",
      "description_length": 387,
      "index": 1346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemMemory",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for modeling memory states, including memory allocation, initialization, and equality checks over memory regions. It works with types like `tau` for memory representations and provides functions such as `f_eqmem` for comparing memory states and `f_memcpy` for copying memory regions. It supports concrete memory reasoning tasks like checking initialization status and managing memory frames in static analysis.",
      "description_length": 441,
      "index": 1347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Matrix",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates matrices in the context of the WP plug-in, supporting operations such as creation from dimensions, comparison, and pretty-printing. It works with matrices whose dimensions and elements are tied to logical terms and variables from the `Wp.Lang.F` module, and it integrates with environments that track size and index variables. Concrete use cases include modeling array bounds, managing matrix dimensions in formal verification, and generating human-readable output for debugging matrix structures.",
      "description_length": 536,
      "index": 1348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cache",
      "library": "frama-c-wp.core",
      "description": "This module manages caching behavior for the WP plug-in, providing operations to set and retrieve cache modes, track cache statistics, and control result persistence. It works with a `mode` type that dictates cache behavior and uses digest-based keys to identify cached results. Concrete use cases include enabling cache updates, checking cache hits during result retrieval, and clearing or promoting cached results based on version control system outcomes.",
      "description_length": 457,
      "index": 1349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpTarget",
      "library": "frama-c-wp.core",
      "description": "This module identifies and processes kernel functions and their associated properties based on command-line options. It computes target functions, their callees, and related specifications such as behaviors, properties, and RTE assertions. Use it to determine which functions and assertions are subject to analysis or proof in a given WP session.",
      "description_length": 346,
      "index": 1350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cleaning",
      "library": "frama-c-wp.core",
      "description": "This module tracks and transforms logical constructs during symbolic execution. It works with usage contexts, terms, and predicates to model how values are consumed or constrained. Functions record how variables are used in terms, predicates, or type assertions, and filter predicates based on their role in the logic.",
      "description_length": 318,
      "index": 1351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.NormAtLabels",
      "library": "frama-c-wp.core",
      "description": "This module manages label mappings for C statements and functions, providing operations to generate and manipulate label contexts for preconditions, postconditions, and assignments. It works with CIL types such as `kernel_function`, `stmt`, `term`, and `predicate`, along with logic labels and from lists. Concrete use cases include preprocessing logical annotations and terms with label substitutions, handling function and loop-specific label contexts, and checking assignments for post-assignment behavior.",
      "description_length": 509,
      "index": 1352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Rformat",
      "library": "frama-c-wp.core",
      "description": "Handles time formatting and command structure manipulation within the WP plug-in. Provides functions to pretty-print time values and ranges, and to construct command structures from strings. Useful for generating human-readable time representations and formatting command output in a structured way.",
      "description_length": 299,
      "index": 1353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacLemma",
      "library": "frama-c-wp.core",
      "description": "This module defines and manages reusable proof lemmas as tacticals, providing operations to create named lemmas, look them up by name, and integrate them into proof strategies. It works with lemma values derived from definitions and tacticals, supporting structured proof automation. Concrete use cases include registering and applying custom lemmas during interactive proving sessions.",
      "description_length": 386,
      "index": 1354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgDump",
      "library": "frama-c-wp.core",
      "description": "This module offers operations to construct and transform logical propositions (`t_prop`) within a verification environment (`t_env`), leveraging Frama-C kernel elements like logic variables, statements, and expressions to manage control flow constructs (e.g., conditionals, loops) and memory effects (e.g., havoc). It supports formal verification tasks such as generating proof obligations for function calls, termination checks, and functional dependencies, while enabling logical implications and hypothesis management. Key use cases include validating preconditions, modeling program state transitions, and ensuring correctness of imperative code through structured axiomatic reasoning.",
      "description_length": 689,
      "index": 1355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_error",
      "library": "frama-c-wp.core",
      "description": "This module handles error reporting and formatting within the WP plug-in. It provides functions for generating and printing logic labels, assigns clauses, and string lists, specifically tailored for use with Frama-C's CIL types. Use cases include displaying error messages with contextual information, formatting logic expressions for output, and debugging internal WP structures.",
      "description_length": 380,
      "index": 1356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacRewrite",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical and strategy for rewriting in a specified direction (`Left` or `Right`), operating on selections within the WP proof context. Uses direction flags to control term transformation during tactic application. Useful for implementing directed simplification or equivalence-based reasoning steps in interactive proofs.",
      "description_length": 334,
      "index": 1357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofEngine",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for navigating and modifying proof trees, including querying proof status, traversing hierarchical relationships (parents, children, subgoals), and managing tactics and strategies. It operates on proof nodes, forks, trees, and associated scripts, enabling interactive proof control through script-node binding, tactic application, and state manipulation. Specific use cases include proof script management, tactic-driven branch forking, and hierarchical inspection of proof goals and metadata.",
      "description_length": 525,
      "index": 1358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters",
      "library": "frama-c-wp.core",
      "description": "This module manages configuration parameters and diagnostic utilities for formal verification workflows, focusing on boolean flags, integer thresholds, and string-based command-line options with support for state tracking, validation, and cross-session persistence. It operates on structured data types like `warn_category`, `Group.t`, file paths, and kernel functions, enabling dynamic control of analysis features, feature toggling, and proof strategy customization through CLI integration and declarative configuration hooks. Key use cases include static analysis tuning, deprecation handling, and orchestrating verification tasks with conditional logging and exception-safe execution contexts.",
      "description_length": 697,
      "index": 1359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacInstance",
      "library": "frama-c-wp.core",
      "description": "This module implements instance-based tacticals for the WP plugin, providing operations to bind variables to selected terms, compute binding complexity, and generate instantiated goals or hypotheses. It works with logical predicates, variable-term bindings, and selection strategies to automate reasoning steps in proof construction. Concrete use cases include guiding automated instantiation of quantifiers and managing term selections during interactive proving.",
      "description_length": 464,
      "index": 1360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacBittest",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical and strategy for bit-test range analysis in program verification. It operates on bit-level expressions and memory states to automate proofs involving bitwise operations and range constraints. Useful for verifying low-level code with bit manipulations, such as device drivers or cryptographic routines.",
      "description_length": 323,
      "index": 1361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicBuiltins",
      "library": "frama-c-wp.core",
      "description": "This module enables registration and configuration of logic primitives, including functions, predicates, and types, while supporting driver and library integration for external theory linking. It manipulates symbolic representations like terms and types, facilitating transformations and option-driven customization during program verification workflows. Key applications include extending verification contexts with domain-specific logic and bridging analysis tools with third-party formal libraries.",
      "description_length": 501,
      "index": 1362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_eva",
      "library": "frama-c-wp.core",
      "description": "Performs value analysis computations and manages the state of value analysis models. It provides functions to check whether the analysis has been computed and to retrieve the value state associated with a specific instruction. This module is used to query the results of the value analysis pass, enabling precise reasoning about program variables at specific program points.",
      "description_length": 374,
      "index": 1363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacNormalForm",
      "library": "frama-c-wp.core",
      "description": "This module provides a tactical and strategy for transforming goals into normal form during proof automation. It operates on logical goals and selections within the WP proof system. Use it to simplify expressions and apply auto-registered normalization rules in tactic-based proofs.",
      "description_length": 282,
      "index": 1364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module tracks memory usage and parameter validity for functions, providing operations to define and analyze memory partitions. It works with variables, kernel functions, and parameter modes like `ByAddr` or `InArray`, enabling precise memory behavior modeling. Concrete use cases include setting parameter constraints for function calls, computing memory partitions for analysis, and adding or warning on specific memory behaviors during verification.",
      "description_length": 456,
      "index": 1365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Repr",
      "library": "frama-c-wp.core",
      "description": "This module defines a high-level representation of terms and predicates using algebraic data types like `repr`, supporting operations such as logical connectives, arithmetic expressions, function calls, and record manipulation. It works with data types including terms, predicates, variables, fields, and logical functions, enabling precise construction and deconstruction of formal expressions. Concrete use cases include building and analyzing logical formulas for verification conditions, symbolic execution, and constraint solving.",
      "description_length": 535,
      "index": 1366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.RefUsage",
      "library": "frama-c-wp.core",
      "description": "This module tracks how variables are accessed in memory, distinguishing between no access, reference, array, value, and address uses. It provides direct lookups of variable access patterns, iteration over tracked variables, and checks for nullable pointers. It is used to analyze variable usage in C code for verification purposes, such as determining if a variable is dereferenced or used as an array.",
      "description_length": 402,
      "index": 1367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Ctypes",
      "library": "frama-c-wp.core",
      "description": "This module provides type modeling, conversion, and introspection operations for C language constructs, focusing on numeric types (integers, floats), pointers, arrays, and composite structures. It works with OCaml representations like `c_int`, `c_float`, `c_object`, `arrayinfo`, and `compinfo` to enable static analysis tasks such as bounds checking, size calculations, and structural equivalence comparisons. Specific use cases include CIL-based program verification, type property analysis (e.g., signedness, bit-width), and managing object state tracking during formal verification of C code.",
      "description_length": 596,
      "index": 1368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProverSearch",
      "library": "frama-c-wp.core",
      "description": "This module implements proof search strategies for verifying program correctness using a tree-based proof structure. It provides operations to navigate and manipulate proof trees through functions like `first`, `index`, `search`, and `backtrack`, which select or generate proof branches based on strategies and heuristics. It works directly with proof trees, nodes, and sequents to support tasks such as automated theorem proving and interactive proof refinement.",
      "description_length": 463,
      "index": 1369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.AssignsCompleteness",
      "library": "frama-c-wp.core",
      "description": "This module checks whether a function's assigns specification is precise enough for memory model hypothesis computation, marking it as incomplete if not. It works with `Frama_c_kernel.Kernel_function.t` values and provides functions to compute completeness, check status, and issue warnings for incomplete specifications. It is used during static analysis to ensure accurate memory modeling by flagging underspecified functions.",
      "description_length": 428,
      "index": 1370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Mstate",
      "library": "frama-c-wp.core",
      "description": "This module manages memory states and symbolic values in the context of program analysis. It provides operations to create, update, and query memory states using terms and symbolic expressions, supporting precise tracking of memory values during verification. Key use cases include evaluating expressions in a given state, iterating over memory values, and collecting updates for symbolic execution.",
      "description_length": 399,
      "index": 1371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext",
      "library": "frama-c-wp.core",
      "description": "This module manages verification model registration and context lifecycle, supporting operations like dynamic scope switching, hypothesis generation, and hierarchical organization of model-state associations through typed scopes and MINDEX-indexed structures. It works with abstract key-data registries to enable memoization and callback-driven tracking of logical symbols, axioms, and proof obligations in both global and function-specific verification contexts.",
      "description_length": 463,
      "index": 1372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCompute",
      "library": "frama-c-wp.core",
      "description": "Implements a compute tactical for symbolic evaluation and term normalization within proof strategies. It provides `tactical` for applying computational reductions and `strategy` for defining prioritized selection of computation rules. Useful for automating simplifications and canonicalizing expressions during proof construction.",
      "description_length": 330,
      "index": 1373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cfloat",
      "library": "frama-c-wp.core",
      "description": "This API provides arithmetic operations (addition, subtraction, multiplication, division), comparisons (equality, ordering), and type conversions for 32-bit and 64-bit floating-point numbers, operating on `Wp.Ctypes.c_float` values. It supports configurable arithmetic models (real or floating-point) via functions like `configure`, enabling precise numerical behavior representation in program analysis tasks such as static verification, where accuracy in floating-point operations and model-specific properties (e.g., epsilon, delta) is critical.",
      "description_length": 548,
      "index": 1374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Factory",
      "library": "frama-c-wp.core",
      "description": "This module configures and instantiates memory models and drivers for the WP plugin. It supports operations to select heap and variable models, compile memory configurations, and apply specifications to set up verification contexts. Concrete use cases include selecting `Typed` pointer models for precise memory reasoning or `Region` heaps for separation logic, and configuring drivers to generate proof obligations for C functions.",
      "description_length": 432,
      "index": 1375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacArray",
      "library": "frama-c-wp.core",
      "description": "This module provides a built-in tactical and strategy for array operations within the WP plug-in. It enables automated reasoning over array manipulations by integrating with the WP proof engine. Concrete use cases include verifying memory safety and correctness of array transformations in C programs.",
      "description_length": 301,
      "index": 1376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Prover",
      "library": "frama-c-wp.core",
      "description": "This module handles the execution and management of proof tasks for verification conditions (VCs). It provides operations to simplify, prove, and spawn proof tasks with support for configuration, progress tracking, and result handling. It works directly with VCs, prover configurations, and task pools, enabling precise control over proof strategies and asynchronous execution. Use cases include launching automated proofs, managing proof attempts with different provers, and integrating proof results into analysis workflows.",
      "description_length": 526,
      "index": 1377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Pcond",
      "library": "frama-c-wp.core",
      "description": "This module provides functions for printing and dumping logical sequents and condition bundles in a human-readable format, supporting detailed customization through optional parameters. It operates on data types such as `sequent`, `bundle`, and `sequence` from the Wp.Conditions module, integrating with the Plib printer interface. Concrete use cases include debugging logical conditions during proof generation and exporting structured proof states for external analysis or logging.",
      "description_length": 483,
      "index": 1378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.ProverTask",
      "library": "frama-c-wp.core",
      "description": "Handles task scheduling and execution for automated provers, including spawning parallel tasks with monitoring and resource management. Works with tasks, thread pools, and system processes, supporting callbacks for result handling and resource allocation. Used to run prover jobs concurrently, manage task validation, and control execution flow in verification workflows.",
      "description_length": 371,
      "index": 1379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Script",
      "library": "frama-c-wp.core",
      "description": "This module processes script inputs by parsing tokens, handling errors, and reading identifiers or keywords. It works with `input` streams and `token` values, supporting operations like skipping, reading, and matching specific token types. Concrete uses include parsing script files for the WP plug-in, validating token sequences, and extracting identifier lists.",
      "description_length": 363,
      "index": 1380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicUsage",
      "library": "frama-c-wp.core",
      "description": "This module manages logic lemmas and axiomatic sections, providing operations to retrieve, iterate, and fold over lemmas, as well as associate them with types, logic functions, and proof contexts. It works with data types such as `logic_lemma`, `axiomatic`, and `logic_section`, extracting and organizing logical properties and dependencies. Concrete use cases include querying lemmas by name, determining lemma sections, and printing logic function profiles or dumps for analysis.",
      "description_length": 481,
      "index": 1381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCut",
      "library": "frama-c-wp.core",
      "description": "This module implements a tactical for applying cut operations in proof strategies, supporting two modes: CASES and MODUS. It works with proof goals and selections, enabling focused reasoning by restricting the context or deriving contradictions. Use it to refine proof steps by cutting away irrelevant branches or strengthening hypotheses.",
      "description_length": 339,
      "index": 1382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacBitwised",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in tactical for handling bitwise equality, providing a `tactical` value for direct use and a `strategy` function that configures selection based on bit width and priority. Works with integer types and bitvector representations to automate reasoning about bitwise operations. Useful in proof strategies where exact bit-level equivalence must be established, such as verifying low-level arithmetic or data encoding routines.",
      "description_length": 441,
      "index": 1383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Stats",
      "library": "frama-c-wp.core",
      "description": "This module tracks and aggregates statistical data from proof verification processes, including prover performance metrics and sub-goal outcomes. It provides operations to compute cumulative statistics, format output for reports, and derive verification results from aggregated data. Concrete use cases include generating detailed performance breakdowns of different provers and evaluating the completeness of proof scripts.",
      "description_length": 424,
      "index": 1384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Register",
      "library": "frama-c-wp.core",
      "description": "This module handles command-line arguments for proof processing, specifically invoking the `do_wp_proofs` function to execute proofs using specified provers on a collection of WPOs (Weakest Precondition Obligations). It works with data types such as `Why3.Whyconf.prover` for prover configurations and `Wp.Wpo.t Frama_c_kernel.Bag.t` representing a bag of proof obligations. A concrete use case includes launching a batch of verification tasks from the command line with custom prover settings.",
      "description_length": 494,
      "index": 1385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicAssigns",
      "library": "frama-c-wp.core",
      "description": "Handles assignment logic for program variables in the context of weakest precondition calculations. Works with program state representations and logical expressions to model variable updates and side effects. Used during symbolic execution to track how assignments affect preconditions and postconditions of code blocks.",
      "description_length": 320,
      "index": 1386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Generator",
      "library": "frama-c-wp.core",
      "description": "This module generates proof obligations for code analysis. It provides functions to configure the generator setup based on command line options and to instantiate a proof obligation generator with optional dumping and custom driver settings. It works with the `Wp.Factory.setup`, `Wp.Factory.driver`, and `Wp.Wpo.generator` types, enabling integration of custom analysis pipelines and proof backends. Use cases include setting up and launching proof obligation generation for static analysis tasks.",
      "description_length": 498,
      "index": 1387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Why3Provers",
      "library": "frama-c-wp.core",
      "description": "This module provides functionality for managing prover configurations, querying prover properties like availability and counterexample support, and controlling global settings such as process counts. It operates on prover data structures from `Why3.Whyconf` and includes utilities for representing and formatting syntax terms via the `model` type alias and `pp_model` function. These capabilities support workflows involving automated theorem proving and debugging of syntax representations in the WP plugin.",
      "description_length": 508,
      "index": 1388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Driver",
      "library": "frama-c-wp.core",
      "description": "This module initializes and provides access to the logic driver used by the WP plugin, based on current configuration options. It ensures the driver is loaded only once and exposes operations to retrieve and interact with the driver instance. Use this module to obtain the configured logic driver for tasks like proof generation or verification.",
      "description_length": 345,
      "index": 1389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Warning",
      "library": "frama-c-wp.core",
      "description": "This module manages contextual warnings with structured data including source, severity, and location. It provides operations to create, emit, and handle warnings, along with utilities to organize and query sets of warnings. Concrete use cases include static analysis diagnostics, error aggregation during code verification, and structured reporting of validation issues with fallback strategies.",
      "description_length": 396,
      "index": 1390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal",
      "library": "frama-c-wp.core",
      "description": "This module implements a memory model interface supporting configuration, manipulation of abstract memory locations (pointers, variables, fields, and array elements), and operations like pointer arithmetic, casting, and memory state transformations. It works with memory segments, logical predicates, and dependency graphs to express constraints, validity, and separation properties, enabling formal verification tasks such as heap state reasoning, scope management, and proof obligation generation for memory-related program properties.",
      "description_length": 537,
      "index": 1391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacSequence",
      "library": "frama-c-wp.core",
      "description": "Implements a sequence tactical that applies a list of tactics in order, each to the current proof goal. Works with lists of tactics and integrates directly with the proof engine's goal management system. Useful for structuring complex proofs by composing multiple transformation steps into a single, ordered application.",
      "description_length": 320,
      "index": 1392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofScript",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for constructing and analyzing hierarchical proof scripts composed of provers and tactics, with support for inspecting script properties like proof status and pending steps. It works with script data structures containing nested alternatives, VCS prover results, and JSON representations for serialization, enabling use cases such as persistent storage of proof strategies, automated tactic configuration through parameter selection, and cross-system communication via standardized data interchange.",
      "description_length": 531,
      "index": 1393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.StmtSemantics",
      "library": "frama-c-wp.core",
      "description": "StmtSemantics defines operations for analyzing and transforming individual statements within control flow graphs. It works with statement nodes and their associated proof goals, enabling precise manipulation of program logic at the statement level. Concrete use cases include refining preconditions, propagating assertions, and generating verification conditions for specific code paths.",
      "description_length": 387,
      "index": 1394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cvalues",
      "library": "frama-c-wp.core",
      "description": "This module supports modeling memory states and logical constraints through operations that convert memory constructs into logical terms, compare C data structures, and handle pointer arithmetic with null-checks. It operates on memory values, regions, logical predicates, and C types to enable formal verification tasks like tracking initialization status, validating volatile accesses, and proving memory safety properties in low-level code. Specific capabilities include transforming C constants into logic expressions, defining memory access patterns, and verifying structural equality for arrays and structs.",
      "description_length": 612,
      "index": 1395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Splitter",
      "library": "frama-c-wp.core",
      "description": "The module provides operations to split, merge, and filter logical fragments tagged with structured control-flow constructs (e.g., conditionals, loops, assertions), enabling precise manipulation of proof obligations during program verification. It works with a structured container (`Splitter.t`) that holds typed elements, allowing transformations like union, mapping, and predicate-based selection to refine or combine verification goals. This supports use cases such as isolating subgoals for targeted analysis, validating universal or existential properties, and reassembling fragments into cohesive logical objectives.",
      "description_length": 623,
      "index": 1396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemDebug",
      "library": "frama-c-wp.core",
      "description": "This module implements memory debugging utilities for inspecting and formatting memory-related structures during verification. It provides functions to pretty-print sequences, equations, access paths, values, and location references, specifically working with memory models involving locations, segments, and memory states. These operations support concrete tasks such as tracing memory effects, validating pointer arithmetic, and debugging memory safety violations in low-level code.",
      "description_length": 484,
      "index": 1397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgInit",
      "library": "frama-c-wp.core",
      "description": "Implements initialization logic for global variables and kernel functions in the context of the WP plugin. Processes global initialization by transforming properties based on the environment and target function. Works with kernel functions and property types to refine or annotate initial states during analysis.",
      "description_length": 312,
      "index": 1398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage, simplify, and resolve proof obligations while supporting validity checks (e.g., trivial, fully valid) and status tracking through hooks. It works with structured representations of obligations indexed by functions or axiomatics, handling metadata, prover logs, and timing information. Key use cases include caching proofs, generating verification conditions, consolidating prover results, and inspecting goal statuses via traversal functions for diagnostic reporting.",
      "description_length": 510,
      "index": 1399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicCompiler",
      "library": "frama-c-wp.core",
      "description": "This module compiles logic expressions and lemmas into verifiable conditions, handling symbolic execution environments and logical frames. It works with `env`, `frame`, and logic term structures to support tasks like verifying C function contracts, evaluating predicates across symbolic states, and integrating lemmas into formal proofs. Concrete use cases include checking memory state validity, compiling pre/post-conditions for functions, and asserting logical properties during verification.",
      "description_length": 495,
      "index": 1400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacShift",
      "library": "frama-c-wp.core",
      "description": "Implements a shift tactical for reordering proof goals, providing `tactical` to apply goal permutation and `strategy` to define prioritized selection strategies. Works with proof goals and selection data structures from the Wp.Tactical and Wp.Strategy modules. Useful for customizing proof search order in interactive theorem proving sessions.",
      "description_length": 343,
      "index": 1401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgWP",
      "library": "frama-c-wp.core",
      "description": "Implements weakest precondition calculations over control flow graphs. Provides functions to compute preconditions for program paths, handle loop invariants, and propagate assertions through control nodes. Works with CFG structures to generate verification conditions for static analysis tools.",
      "description_length": 294,
      "index": 1402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Conditions",
      "library": "frama-c-wp.core",
      "description": "This module centers on constructing and transforming structured logical conditions for formal verification, focusing on sequents, proof steps, and bundled tasks. It supports operations like quantifier introduction, sequence composition, and branching logic to manage assumptions, conclusions, and variable contexts, while enabling predicate rewriting and structural modifications. Key applications include building and simplifying proof tasks with solvers, tracking step metadata, and manipulating hierarchical logical domains for verification workflows.",
      "description_length": 554,
      "index": 1403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpRTE",
      "library": "frama-c-wp.core",
      "description": "Implements runtime error checking for C functions by generating missing annotations based on a given model. Works with kernel functions and models to identify and insert necessary preconditions and postconditions. Used to ensure safety properties like array bounds and pointer validity in generated Frama-C annotations.",
      "description_length": 319,
      "index": 1404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Strategy",
      "library": "frama-c-wp.core",
      "description": "This module implements selection and occurrence-checking operations for terms and predicates within a logical sequent, providing precise navigation and extraction capabilities. It supports structured strategy creation with configurable priority, tactical application, and argument binding, enabling targeted proof automation. Use cases include building custom proof strategies that select specific subterms or predicates in a goal sequent and apply tactics with controlled parameters.",
      "description_length": 484,
      "index": 1405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgGenerator",
      "library": "frama-c-wp.core",
      "description": "Implements functions to generate control flow graphs from source code, providing concrete CFG construction and traversal operations. Works with abstract syntax trees and control flow primitives to model program paths. Used to produce WPO (Weak Partial Order) representations for static analysis tasks like slicing and dependency tracking.",
      "description_length": 338,
      "index": 1406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacSplit",
      "library": "frama-c-wp.core",
      "description": "This module implements a built-in split tactical that decomposes logical goals into subgoals based on case analysis or conjunctions. It provides the `tactical` value for splitting proof obligations and the `strategy` function to apply splitting with configurable priority and selection. It operates on proof goals represented in the `Wp.Tactical` and `Wp.Strategy` interfaces, enabling structured proof development by breaking down complex conditions into manageable cases.",
      "description_length": 473,
      "index": 1407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Auto",
      "library": "frama-c-wp.core",
      "description": "This module provides tactical strategies for automated reasoning in program verification, focusing on manipulating logical goals and proof states through operations like case analysis, goal splitting, hypothesis management, and symbolic computation. It works with logical terms, proof goals, and hypotheses, often leveraging structured control flow and domain-specific analyses such as integer range constraints or lemma application. Use cases include decomposing complex proof obligations into manageable subgoals, applying domain-specific optimizations, and orchestrating structured verification workflows.",
      "description_length": 608,
      "index": 1408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemLoader",
      "library": "frama-c-wp.core",
      "description": "This module implements memory loading operations for compound values, handling domain computation, value extraction, and equation generation for memory assignments and initializations. It operates on C objects and memory locations, producing terms and equations used in symbolic memory reasoning. Concrete use cases include modeling memory reads, writes, and initializations during program verification tasks.",
      "description_length": 409,
      "index": 1409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.ProverWhy3",
      "library": "frama-c-wp.core",
      "description": "Handles goal proving using Why3 backends, focusing on specialized equality and proof strategies. It provides functions to add custom equality checks and invoke Why3 provers with specific configurations. Useful for verifying program properties with tailored proof obligations and prover parameters.",
      "description_length": 297,
      "index": 1410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProverScript",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates proof exploration and prover interaction for a verification system. It provides operations to spawn and manage proof tasks, search proof trees with customizable strategies, and retrieve proof outcomes. Designed for use in automated reasoning pipelines, it directly supports iterative proof attempts with specific provers, backtracking, and progress tracking tailored to formal verification goals.",
      "description_length": 421,
      "index": 1411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacOverflow",
      "library": "frama-c-wp.core",
      "description": "Implements a tactic that handles integer overflow conditions in proofs. Works with integer arithmetic expressions and overflow constraints. Useful for verifying safety properties in low-level code involving fixed-size integers.",
      "description_length": 227,
      "index": 1412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacModMask",
      "library": "frama-c-wp.core",
      "description": "This module defines a tactical that filters proof obligations based on their associated module mask. It operates on `Wp.Tactical.tactical` values and interacts with module mask data structures to selectively apply tactics. It is used to restrict tactic application to specific parts of the codebase, such as focusing on obligations from particular modules during proof sessions.",
      "description_length": 378,
      "index": 1413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacFilter",
      "library": "frama-c-wp.core",
      "description": "This module implements a built-in filtering tactic that configures and applies logical strategies based on boolean fields. It works with tacticals and strategies, allowing conditional execution through parameters like priority and anti. Concrete use cases include selectively applying proof tactics during automated reasoning based on predefined criteria.",
      "description_length": 355,
      "index": 1414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for creating and normalizing logic labels tied to C control-flow constructs (like pre, here, next, and loop-specific labels), converting between C statements and their logical representations, and performing structural comparisons or set-based manipulations. It operates on CIL statements and logic labels, using ordered sets and maps to track label relationships. These capabilities are critical for static analysis tasks requiring precise label consistency across control-flow paths, such as verifying loop invariants or function contracts.",
      "description_length": 574,
      "index": 1415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VCS",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage provers (e.g., Why3, Qed) and their execution modes, along with types to represent proof verdicts (e.g., Valid, Timeout) and associated metadata like timing or error details. It works with sets and maps for prover collections, supporting queries to compare results, determine proof validity, or extract configuration parameters. It is used in formal verification workflows to track prover status, evaluate proof outcomes, and optimize tactic selection based on result metrics.",
      "description_length": 518,
      "index": 1416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp",
      "library": "frama-c-wp.core",
      "description": "The module provides formal verification operations for C programs, focusing on weakest precondition (WP) techniques, symbolic execution, and memory modeling. It works with CIL-based program representations, logical terms, memory states (sigma), control flow graphs (CFGs), and verification conditions. Specific use cases include proving memory safety properties, handling integer/pointer arithmetic constraints, and validating program correctness through automated reasoning and interactive theorem proving.",
      "description_length": 507,
      "index": 1417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Verbose.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values through a descriptor and provides deep copying and membership checks for project-related data. Use it to manage and manipulate complex GUI parameter values with built-in type safety and persistence.",
      "description_length": 347,
      "index": 1418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Undo.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a data type for representing values that can be stored and manipulated in the context of the `-undo` option in the Frama-C GUI plug-in. It supports operations for equality checking, comparison, hashing, pretty-printing, deep copying, and project membership testing, enabling precise handling of state snapshots and rollbacks. The type is used to manage and track changes to GUI parameters that can be undone, ensuring accurate restoration of previous states during analysis.",
      "description_length": 494,
      "index": 1419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Debug.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines operations for managing and manipulating a specific datatype used in the GUI plugin's debugging parameters. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying of values, along with introspection via project membership testing. The module works directly with a custom type `t` and supports use cases such as tracking and comparing debug parameter values across different projects.",
      "description_length": 446,
      "index": 1420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Project_name.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a datatype for handling project names within a GUI plug-in, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a custom type `t` representing project names, along with associated descriptors, packed representations, and project skeletons. Concrete uses include managing and comparing project name values in GUI settings, checking project membership, and ensuring deep copies for safe manipulation.",
      "description_length": 466,
      "index": 1421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Design.Feedback",
      "library": "frama-c.gui",
      "description": "This module manages visual feedback markers in the source code editor's left margin, specifically for indicating property status. It provides functions to declare themed icons and place marks at specific source code positions, optionally tied to call sites. Concrete use cases include highlighting assertion statuses and call statements in static analysis results.",
      "description_length": 364,
      "index": 1422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Session",
      "library": "frama-c.gui",
      "description": "This module manages the session directory for a GUI plugin, providing functions to retrieve or create directories and files within the session path. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing configuration of the session directory through `set` and `get` operations. Concrete use cases include storing temporary session data, caching plugin-specific files, or organizing user-specific settings during analysis.",
      "description_length": 445,
      "index": 1423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Debug",
      "library": "frama-c.gui",
      "description": "This module provides facilities for managing integer debug parameters in GUI plugins, supporting operations like value increment, range validation (via min-max pairs), and change monitoring with pre/post-update hooks. It works with integer parameters that can be marshaled, compared, and aliased, while integrating with project state tracking for persistence. Typical use cases include dynamic configuration of runtime analysis tools, enforcing value constraints during debugging sessions, and synchronizing UI elements with underlying parameter states.",
      "description_length": 553,
      "index": 1424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Share",
      "library": "frama-c.gui",
      "description": "This module manages the plug-in's share directory configuration by providing functions to set, retrieve, and check the directory path. It supports operations to locate specific files or subdirectories within the share directory, ensuring they exist and are of the correct type. Use cases include loading plug-in-specific resources such as configuration files or auxiliary data from a predefined directory structure.",
      "description_length": 415,
      "index": 1425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Undo",
      "library": "frama-c.gui",
      "description": "This module manages a boolean parameter for controlling undo functionality, offering operations to set, retrieve, and observe state changes with support for pre/post-update hooks and custom serialization. It operates on a shared mutable boolean value, enabling toggling between active and inactive states while integrating with a project state system to track and persist undoable configurations. Use cases include dynamically enabling/disabling undo features in a GUI and synchronizing state changes with application-wide undo mechanisms.",
      "description_length": 539,
      "index": 1426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_printers.LinkPrinter",
      "library": "frama-c.gui",
      "description": "This module formats varinfos and types with `link:vidN` and `link:typN` tags respectively, enabling reactive display in the GUI. It works directly with variable and type data structures, wrapping them in annotated format strings. Use this when rendering clickable or interactive elements in GUI components that reference variables or types.",
      "description_length": 340,
      "index": 1427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.Icon",
      "library": "frama-c.gui",
      "description": "This module manages icon loading and registration for custom and predefined icon kinds, using image files from the Frama-C share directory. It provides functions to register custom icons by name and file path, retrieve pixbufs for icons, and reset icons when the theme changes. Use cases include displaying status feedback icons in the GUI, such as marking or unfolding elements in the interface.",
      "description_length": 396,
      "index": 1428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Verbose",
      "library": "frama-c.gui",
      "description": "This module provides integer-based configuration operations for managing verbosity levels in a GUI plugin environment, supporting value constraints, incremental adjustments, and change notifications. It works with integer parameters to enforce valid ranges, persist state, and integrate with project management systems through custom marshaling and alias handling. Typical use cases include logging control in analysis tools, user-adjustable diagnostic output settings, and coordinating verbose behavior across plugin components.",
      "description_length": 529,
      "index": 1429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Pretty_source.Locs",
      "library": "frama-c.gui",
      "description": "This module tracks and manages source code locations within a Gtk TextBuffer during pretty-printing operations. It provides functions to create and reset state information that maps abstract syntax tree nodes to their corresponding text positions. Concrete use cases include maintaining accurate source location references when repainting or updating highlighted code regions in a GUI editor.",
      "description_length": 392,
      "index": 1430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Cache_dir",
      "library": "frama-c.gui",
      "description": "This module manages a cache directory for a GUI plugin, providing functions to retrieve and set directories and files within that cache. It works with file paths represented by the `Frama_c_kernel.Filepath.t` type, allowing optional path creation. Concrete use cases include storing and accessing cached data such as user-specific configurations or temporary files.",
      "description_length": 365,
      "index": 1431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.MAKE_CUSTOM_LIST",
      "library": "frama-c.gui",
      "description": "This module defines a functor for constructing custom Gtk lists with specialized data handling. It works with arrays and custom data types through a cell renderer, enabling creation of view columns that display transformed data. It is used to build user interfaces with dynamic list views where each row contains structured data.",
      "description_length": 329,
      "index": 1432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Property_navigator.Rte",
      "library": "frama-c.gui",
      "description": "This module implements a registry for status accessors that provide Boolean states of runtime environment (RTE) checks associated with kernel functions. It allows registration of functions to retrieve and set status information for properties displayed in the GUI navigator. This enables dynamic updating and visualization of RTE verification results within the property interface.",
      "description_length": 381,
      "index": 1433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Config_dir",
      "library": "frama-c.gui",
      "description": "This module handles retrieval of directory and file paths for GUI-related configurations, ensuring paths exist if specified. It operates on string identifiers and returns structured file paths. Use it to access predefined directories or files in the GUI plug-in context, such as locating resource files or configuration directories.",
      "description_length": 332,
      "index": 1434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.Configuration",
      "library": "frama-c.gui",
      "description": "This module enables storage and retrieval of GUI configuration constants through a type-aware key-value interface, supporting integers, booleans, floats, strings, lists, and enumerated values. It provides operations to set, load, and reset these values while handling type coercion and default fallbacks, ensuring consistent UI behavior across sessions. Typical use cases include managing visual parameters like window dimensions, layout ratios, and persistent user preferences with type-safe accessors and comparison-based updates for enumerated options.",
      "description_length": 555,
      "index": 1435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.State_dir",
      "library": "frama-c.gui",
      "description": "This module manages file paths for a plugin's state directory, providing operations to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, ensuring the existence of required locations when needed. Concrete use cases include storing and accessing plugin-specific configuration or state files during analysis sessions.",
      "description_length": 388,
      "index": 1436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.File_manager",
      "library": "frama-c.gui",
      "description": "Manages file operations for GUI components, including opening, saving, and tracking file states. Works with file paths, buffers, and GUI widgets. Used to handle user interactions with files in the interface, such as loading configurations or saving analysis results.",
      "description_length": 266,
      "index": 1437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Warning_manager",
      "library": "frama-c.gui",
      "description": "Manages warnings in a GUI interface by providing functions to display, append, and clear warning messages. It works with `Frama_c_kernel.Log.event` to represent individual warnings and uses a custom type `t` for the warning display widget. This module is used to build and maintain a graphical warning log view, where each warning can be interactively inspected.",
      "description_length": 362,
      "index": 1438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.GSourceView",
      "library": "frama-c.gui",
      "description": "This module integrates GtkSourceView widgets and related objects for building source code editing interfaces. It provides functions to create and configure source buffers with syntax highlighting, completion providers, and undo management, along with view settings like indentation, line numbers, and margins. Concrete use cases include embedding a customizable code editor in a GUI application, enabling real-time syntax highlighting, and implementing auto-completion features for specific programming languages.",
      "description_length": 513,
      "index": 1439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.History",
      "library": "frama-c.gui",
      "description": "Manages navigation through a history of source code locations and global entities, supporting backward and forward traversal. It stores elements as either global entities or localizable source positions, allowing clients to push new entries, retrieve or show the current position, and restore previous states. Useful for implementing navigation features in a GUI, such as \"go back\" and \"go forward\" after selecting different parts of the source code.",
      "description_length": 450,
      "index": 1440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wutil",
      "library": "frama-c.gui",
      "description": "This module handles GUI utility functions for managing widgets, styling, and event timing. It provides operations for enabling or hiding widgets, setting fonts and tooltips, controlling paned window ratios, and scheduling actions on idle. Concrete use cases include adjusting UI element visibility, applying monospace fonts to text displays, and deferring execution of UI updates.",
      "description_length": 380,
      "index": 1441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Analyses_manager",
      "library": "frama-c.gui",
      "description": "Manages the lifecycle and configuration of static analysis sessions through automated setup and teardown routines. It handles internal state transitions and resource allocation for analysis plugins during execution. This module is used to initialize and coordinate analysis workflows when launching or stopping Frama-C sessions with custom plugins.",
      "description_length": 348,
      "index": 1442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Wutil_once",
      "library": "frama-c.gui",
      "description": "This module provides a function `once` that ensures a given function is executed only once during the program's lifetime, caching and returning the result on subsequent calls. It works with any function type `'a -> 'b`, transparently wrapping it to enforce single execution. Useful for lazy initialization of expensive resources or ensuring idempotent setup routines.",
      "description_length": 367,
      "index": 1443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Pretty_source",
      "library": "frama-c.gui",
      "description": "This module formats and displays source code in a Gtk TextBuffer, mapping AST elements to text positions for precise highlighting and navigation. It supports operations like folding and unfolding preconditions at call sites, retrieving source locations for statements, and identifying localizable elements at specific file lines. Use cases include rendering function bodies with accurate source references and enabling interactive code exploration in a GUI editor.",
      "description_length": 464,
      "index": 1444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Launcher",
      "library": "frama-c.gui",
      "description": "This module displays a configuration dialog for launching Frama-C with custom parameters. It provides the `show` function, which opens the launcher window with optional height and width settings, integrated into a main window interface. It is used to set up and initiate Frama-C analyses through a graphical interface.",
      "description_length": 318,
      "index": 1445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_form",
      "library": "frama-c.gui",
      "description": "This module provides functions to create and manage GUI widgets for plugin options in a deprecated framework, including checkboxes, menus, spinners, labels, and buttons. It works with boolean, integer, and string values, along with GTK widget packing and event handling. Concrete use cases include synchronizing plugin settings with UI elements and refreshing interface components in response to user input.",
      "description_length": 407,
      "index": 1446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Widget",
      "library": "frama-c.gui",
      "description": "This module creates and manages GUI widgets for labels, buttons, groups, and selectors with specific alignment, styling, and icon integration. It handles data types like align, style, color, and icon, including support for custom and shared icons via GdkPixbuf. Concrete use cases include building interactive analysis controls, visualizing structured data, and customizing interface elements in a GUI application.",
      "description_length": 414,
      "index": 1447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_printers",
      "library": "frama-c.gui",
      "description": "This module provides functions to format and parse types, variables, and locations with reactive GUI tags. It directly works with `typ`, `varinfo`, and `location` data structures from the Cil_types module. Use it to render clickable type and variable references in GUI components or to resolve tagged links back into their original data structures.",
      "description_length": 348,
      "index": 1448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Property_navigator",
      "library": "frama-c.gui",
      "description": "This module extends the GUI to navigate and interact with ACSL properties, providing functions to display, select, and update property states dynamically. It works with property data structures and integrates with RTE status tracking to reflect verification results in real time. Concrete use cases include visualizing proof statuses, enabling user-driven property inspection, and synchronizing GUI elements with underlying analysis data.",
      "description_length": 438,
      "index": 1449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wpalette",
      "library": "frama-c.gui",
      "description": "This module implements a configurable vertical palette of tools with a scrollbar, allowing dynamic addition and organization of widgets. It manages each tool as a three-component widget, supporting interactive elements like buttons or input fields. Useful for creating customizable UI panels in analysis tools or interactive environments.",
      "description_length": 338,
      "index": 1450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Book_manager",
      "library": "frama-c.gui",
      "description": "Manages a collection of source code tabs within a GUI application using GTK. It provides operations to add, remove, and navigate between tabs, retrieve specific tabs by index, and control notebook properties like scrollability and popup menus. This module is used to organize and display multiple source views in a structured tabbed interface.",
      "description_length": 343,
      "index": 1451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Source_viewer",
      "library": "frama-c.gui",
      "description": "This module creates a source viewer widget and provides access to the underlying buffer containing Frama-C's pretty-printed AST. It works with GTK widgets and source buffers specifically for displaying and interacting with parsed C code. Use this to embed a read-only view of Frama-C's AST in a GUI, allowing users to navigate and inspect the structured representation of loaded C files.",
      "description_length": 387,
      "index": 1452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Project_manager",
      "library": "frama-c.gui",
      "description": "Manages project switching within the GUI by handling the creation, loading, and context updates of projects. It works with project state data structures to maintain and switch between different analysis sessions. This module enables users to seamlessly transition between multiple projects without restarting the application.",
      "description_length": 325,
      "index": 1453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Design",
      "library": "frama-c.gui",
      "description": "This module integrates custom extensions into the source code analysis interface, enabling dynamic visual updates in response to user interactions. It supports creating reactive source code buffers that track selections and highlight changes, specifically for analyzing C code elements like functions and global variables. Key applications include visualizing analysis results, such as assertion outcomes and call site annotations, directly within the editor.",
      "description_length": 459,
      "index": 1454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper",
      "library": "frama-c.gui",
      "description": "This module provides utilities for constructing and managing graphical user interfaces with dynamic widget creation, structured data visualization, and interactive controls. It operates on Gtk text buffers with tagged regions, hierarchical UI layouts like paned windows, and structured lists with customizable data views, while supporting operations such as input validation, logging integration, and process orchestration. Specific applications include building file/string selection dialogs, implementing responsive configuration panels, and creating custom interactive widgets with state synchronization and contextual tooltips.",
      "description_length": 631,
      "index": 1455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Wpane",
      "library": "frama-c.gui",
      "description": "This module organizes widgets into panels with configurable expansion behavior, supporting tabbed interfaces and dynamic widget arrays. It handles layout management for GUI components like single-line fields, multiline panels, and fixed-size elements. Use it to build structured, resizable dialog windows with grouped controls and tab navigation.",
      "description_length": 346,
      "index": 1456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wfile",
      "library": "frama-c.gui",
      "description": "This module provides functions for opening file and directory selection dialogs, allowing users to interactively choose files or directories based on the specified `filekind` type. It works directly with GTK file chooser widgets and handles user responses to return selected paths as strings. Concrete use cases include selecting source code files for analysis or choosing output directories for generated reports.",
      "description_length": 414,
      "index": 1457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Filetree",
      "library": "frama-c.gui",
      "description": "This module manages a tree view displaying analysis units and global declarations, supporting dynamic column updates. It operates on filetree nodes representing files or global entities like functions and variables. Use it to visualize and navigate structured program elements within a graphical interface.",
      "description_length": 306,
      "index": 1458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Help_manager",
      "library": "frama-c.gui",
      "description": "Manages help content registration and retrieval for GUI components. It associates contextual help with specific interface elements using unique identifiers. Useful for displaying targeted documentation or tooltips when users interact with different parts of the interface.",
      "description_length": 272,
      "index": 1459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wbox",
      "library": "frama-c.gui",
      "description": "This module implements layout management for GUI components using box packing, supporting horizontal and vertical alignment with expansion policies. It operates on widget types, allowing structured composition of interfaces with elements like labels, toolbars, sidebars, and scrollable or split-pane regions. Concrete use cases include building structured panels with fixed and expandable widgets, creating scrollable views, and arranging toolbars with left-right alignment.",
      "description_length": 474,
      "index": 1460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Source_manager",
      "library": "frama-c.gui",
      "description": "This module manages a multi-tab source code viewer widget with file loading, tab selection, and user interaction features. It works with source files represented by file paths and supports line navigation, clickable source elements, and dynamic tab management. Concrete use cases include displaying and interacting with C source files in a graphical interface, such as showing a specific line of code or handling user clicks on code elements.",
      "description_length": 442,
      "index": 1461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters",
      "library": "frama-c.gui",
      "description": "This module provides logging and diagnostic messaging with configurable severity levels, manages warning categories and UI configuration parameters, and supports persistent session settings and structured parameter handling. It operates on formatted messages, event options, and hierarchical configuration data, enabling use cases such as message filtering, diagnostic output control, and persistent GUI state management in Frama-C.",
      "description_length": 432,
      "index": 1462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Menu_manager",
      "library": "frama-c.gui",
      "description": "This module creates and manages entries for toolbars and menus in a GUI application, supporting dynamic sensitivity and callbacks. It works with GTK+ stock items, strings for labels and tooltips, and functions for user interaction. Concrete use cases include adding clickable toolbar buttons with tooltips and creating menu items that respond to user actions.",
      "description_length": 359,
      "index": 1463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui",
      "library": "frama-c.gui",
      "description": "Facilitates graphical interface development for static analysis by managing tabbed source code displays, file hierarchies, and analysis dashboards. It operates on source buffers, abstract syntax trees, project structures, and analysis results, supporting use cases like interactive code navigation, dynamic property visualization, and GTK-based UI components for project management and analysis coordination.",
      "description_length": 408,
      "index": 1464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Slicing.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type for representing abstract values used in security slicing pre-analysis, including operations for equality, comparison, hashing, and pretty-printing. It supports working with Frama-C's type system and project structures by providing deep copying, membership checks over projects, and descriptors for structural manipulation. Concrete use cases include tracking and comparing abstract values during slicing, filtering values based on project conditions, and serializing or displaying them for debugging and analysis.",
      "description_length": 546,
      "index": 1465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Verbose.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values that represent security slicing parameters. It supports structured data with descriptors, representants, and project membership checks, enabling precise type manipulation and analysis. Concrete use cases include managing and comparing abstract representations of slicing configurations during static analysis.",
      "description_length": 408,
      "index": 1466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Debug.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in security slicing. It supports structured data representation with descriptors, packed types, and deep copying, enabling precise manipulation of type instances. The module is used to manage and query complex data structures in the context of static analysis and program transformation tasks.",
      "description_length": 427,
      "index": 1467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Cache_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Concrete use cases include storing and retrieving intermediate analysis results or persistent plugin data.",
      "description_length": 371,
      "index": 1468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Debug",
      "library": "frama-c-security_slicing.core",
      "description": "This module offers utilities to configure and manipulate integer debug parameters with bounded ranges, supporting dynamic alias definitions, update hooks, and serialization customization. It integrates command-line interaction and project-specific state management, enabling adaptable parameter handling in security analysis workflows.",
      "description_length": 335,
      "index": 1469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Share",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages paths related to a shared directory for a plugin, providing operations to set, retrieve, and check the existence of the directory. It supports locating specific subdirectories or files within the shared directory, ensuring they exist and are of the correct type. Use cases include loading plugin-specific resources such as configuration files or auxiliary data from a predefined site directory.",
      "description_length": 414,
      "index": 1470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.State_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages directory and file paths within a security slicing plugin, providing operations to retrieve, set, and check a user-specific directory. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, supporting dynamic path resolution with optional directory creation. Concrete use cases include handling plugin state storage, ensuring required directories exist, and accessing named files within the plugin's working directory.",
      "description_length": 455,
      "index": 1471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Verbose",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages verbosity parameters through integer state manipulation, supporting operations like range validation, value incrementing, and callback registration for state changes. It works with constrained integer types to enforce configuration boundaries and provides mechanisms for command-line integration, serialization, and project-specific updates. These features enable dynamic adjustment of logging detail levels and secure parameter handling in security slicing workflows.",
      "description_length": 488,
      "index": 1472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Config_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages file paths for a plugin's configuration directory, providing operations to retrieve or create directories and files within it. It works with string names and `Frama_c_kernel.Filepath.t` paths, handling path resolution and existence checks. Concrete use cases include setting up user-specific configuration storage, accessing plugin resources, and ensuring required files or directories exist at runtime.",
      "description_length": 423,
      "index": 1473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Session",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages file and directory paths within a session-specific context, providing operations to retrieve or create directories and files, set and query a user directory. It works with string identifiers and file path structures from the Frama-C kernel. Concrete use cases include handling session-specific storage for analysis results or configuration files in a plug-in environment.",
      "description_length": 391,
      "index": 1474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Slicing",
      "library": "frama-c-security_slicing.core",
      "description": "This module provides mechanisms to control a boolean flag that activates or deactivates security slicing pre-analysis, including functions to set, retrieve, and monitor changes to the flag. It utilizes boolean values and state management constructs to facilitate dynamic configuration via aliases and integration with Frama-C's project and kernel systems, enabling adaptive analysis workflows and runtime parameter adjustments.",
      "description_length": 427,
      "index": 1475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Components",
      "library": "frama-c-security_slicing.core",
      "description": "This module implements security slicing by computing code components related to statement dependencies. It provides operations to retrieve direct, indirect backward, and forward components of a given statement, as well as performing impact analysis from a kernel function and statement. These functions work with CIL statements and kernel functions, enabling precise tracking of control and data dependencies in C code for vulnerability analysis and program understanding.",
      "description_length": 472,
      "index": 1476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters",
      "library": "frama-c-security_slicing.core",
      "description": "This module configures diagnostic output, warning suppression, and runtime parameters for security slicing workflows, handling data such as logging categories, verbosity levels, warning thresholds, and file paths. It enables use cases like fine-grained control of analysis feedback, dynamic adjustment of diagnostic detail during slicing, and integration with Frama-C's command-line infrastructure for security-critical code analysis. Operations include registering logging hierarchies, toggling warning classes, and persisting session-specific settings to coordinate security slicing executions.",
      "description_length": 596,
      "index": 1477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing",
      "library": "frama-c-security_slicing.core",
      "description": "This module performs security slicing by analyzing control and data dependencies in C code through operations that identify backward, forward, and direct code components relative to a given statement. It works with CIL statements and kernel functions to support vulnerability analysis, impact tracking from security-critical functions, and program comprehension tasks. The module also includes parameter handling for configuring slicing diagnostics, warning suppression, and runtime settings, enabling integration with command-line analysis and session-specific security evaluations.",
      "description_length": 583,
      "index": 1478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Map.Make",
      "library": "frama-c-impact.core",
      "description": "This module creates a map structure specialized for a given data type, enabling operations like lookup, comparison, and pretty printing. It works with key-value pairs where the value type is defined by the `Data` module. Concrete use cases include managing analysis results keyed by program elements, tracking variable states in a control flow graph, or storing and querying structured metadata across different analysis passes.",
      "description_length": 428,
      "index": 1479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl.Key",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with project-aware values through `mem_project` and enables deep copying of key instances. Concrete use cases include managing and querying keys in a hash table that stores analysis-related data indexed by project-specific identifiers.",
      "description_length": 395,
      "index": 1480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.As_string.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a datatype for handling string-based command-line parameters where variables are treated as unmodified. It provides standard operations like equality, comparison, hashing, and pretty-printing for values of type `t`, along with deep copying and project membership checks. It is used to represent and manipulate string parameters in a way that ensures immutability of variables within the analysis context.",
      "description_length": 424,
      "index": 1481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.As_string.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a datatype for handling string-based command-line parameters with annotations, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and project-specific data through the `Project_skeleton.t` type, enabling precise parameter representation and manipulation. Concrete use cases include parsing and validating annotated string options in command-line tools and managing project-specific configurations.",
      "description_length": 480,
      "index": 1482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl.Make",
      "library": "frama-c-impact.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data management tasks such as deep copying, membership testing by project, and type representation for integration with Frama-C's kernel. Concrete use cases include tracking and manipulating collections of analysis data indexed by project-specific keys.",
      "description_length": 429,
      "index": 1483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Map.Key",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with `Project_skeleton.t` values through membership checks and deep copying. Concrete use cases include managing and comparing unique key values within a map, ensuring structural integrity during copy operations, and facilitating debugging via human-readable output formatting.",
      "description_length": 440,
      "index": 1484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.As_string",
      "library": "frama-c-impact.core",
      "description": "This module enables configuration and validation of string-based command-line parameters through operations like value registration, alias handling, and state synchronization. It works with string collections and project-specific state data to enforce allowed value constraints, track dynamic parameter updates, and support help documentation generation. Typical use cases include building CLI tools with validated string inputs, managing parameter state across command executions, and generating usage guides with enumerated options.",
      "description_length": 534,
      "index": 1485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl",
      "library": "frama-c-impact.core",
      "description": "This module implements imperative hash tables for key-value associations using keys of type `Impact.Reason_graph.Reason.t`, supporting standard operations like insertion, lookup, and iteration. It extends basic hash table functionality with ordered traversal, sorted key/value iteration via custom comparators, and bulk updates through sequences, while ensuring safe key management with project-specific semantics. Typical applications include memoization, maintaining dynamic mappings with structured keys, and scenarios requiring deterministic traversal order or sorted access patterns.",
      "description_length": 588,
      "index": 1486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Debug.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin development. It includes descriptors and representants for structural introspection, and supports deep copying and project membership checks. It is used to manage and manipulate complex data structures within Frama-C's analysis framework, particularly for debugging and option handling.",
      "description_length": 440,
      "index": 1487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Set",
      "library": "frama-c-impact.core",
      "description": "This module offers ordered set operations for managing collections of `Reason.t` elements, emphasizing ordered traversal, transformation, and efficient membership queries. It supports functional and imperative-style modifications (union, intersection, filtering), ordered iteration (including reverse), and specialized lookups for nearest elements relative to a key. Designed for contexts requiring precise ordering guarantees, it is suited for applications like dependency analysis or graph traversal where element relationships depend on sorted sequences or project-specific membership checks.",
      "description_length": 595,
      "index": 1488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Upward.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks for project membership via predicates. The type is used to represent and manipulate analysis options with deep copying and structural inspection capabilities.",
      "description_length": 363,
      "index": 1489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.Category",
      "library": "frama-c-impact.core",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with parameter categories tied to a state list and an accessor, allowing categories to be added, enabled, or modified with specific behaviors. Concrete use cases include organizing and controlling the activation of related command-line options in a static analysis tool.",
      "description_length": 453,
      "index": 1490,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Slicing.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type and operations for slicing based on impacted statements, supporting equality, comparison, hashing, and pretty-printing. It provides functions to check membership of project values, perform deep copies, and work with a list of representants and descriptors. Concrete use cases include managing and analyzing program slices in static analysis, particularly for tracking dependencies and impacts in a program's control flow.",
      "description_length": 453,
      "index": 1491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Print.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives for structural analysis. The type is used to model and manipulate values that include project membership checks and deep copying capabilities, specifically for tracking and printing impacted statements in a structured format.",
      "description_length": 455,
      "index": 1492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Reason.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` and associated operations for representing and manipulating abstract data values in the context of impact analysis. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying, along with utilities for inspecting and querying project-related data embedded within values. These operations support precise tracking and explanation of dependencies and effects in static analysis results.",
      "description_length": 458,
      "index": 1493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Verbose.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It includes functions for deep copying values, checking membership based on project properties, and exposing structural representations via descriptors and a unique name. Concrete use cases include managing and comparing abstract data types in Frama-C plugins, particularly during semantic analysis and transformation passes.",
      "description_length": 486,
      "index": 1494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a custom abstract data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling command-line parameters that represent sets. It supports deep copying, membership testing based on project properties, and provides representants along with type and descriptor information. Concrete use cases include managing and querying structured command-line options in static analysis tools built on the Frama-C platform.",
      "description_length": 468,
      "index": 1495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Annot.Category",
      "library": "frama-c-impact.core",
      "description": "This module manages categories for command-line parameter annotations, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with types like `elt` for elements and `t` for category structures, using accessors and state lists to control category behavior. Concrete use cases include setting up default parameter interpretations, enabling all parameters under a specific category, or mapping `@all` to a custom category for fine-grained control over command-line options.",
      "description_length": 527,
      "index": 1496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type for representing annotated values with support for equality, comparison, hashing, and pretty-printing. It provides operations to check membership within projects, create deep copies, and describe values using type descriptors and project-specific predicates. The module is used to manage and manipulate annotated data structures in the context of static analysis plugins for Frama-C.",
      "description_length": 415,
      "index": 1497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.As_string",
      "library": "frama-c-impact.core",
      "description": "This module manages string-based command-line parameters with validation, state tracking, and alias handling, operating on plain strings augmented with metadata like allowed values and default states. It provides utilities to enforce input constraints, resolve function names (e.g., for C interop), and track parameter changes, making it suitable for CLI tools requiring strict input validation or dynamic parameter behavior. Key use cases include parsing project-specific configuration flags and bridging string inputs with executable function references.",
      "description_length": 556,
      "index": 1498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Slicing",
      "library": "frama-c-impact.core",
      "description": "This module manages a boolean state that controls whether slicing originates from impacted statements, providing toggle operations (`on`/`off`) and change-notification hooks to react dynamically to modifications. It integrates with command",
      "description_length": 239,
      "index": 1499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Session",
      "library": "frama-c-impact.core",
      "description": "This module manages a specific session directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of a session directory. Concrete use cases include initializing plugin-specific storage locations and ensuring consistent access to session files during analysis.",
      "description_length": 439,
      "index": 1500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.State_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages a plugin-specific state directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing clients to set, get, and check the existence of the state directory. Concrete use cases include storing and accessing plugin-generated files such as logs, caches, or intermediate results in a dedicated location.",
      "description_length": 419,
      "index": 1501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot",
      "library": "frama-c-impact.core",
      "description": "This module provides operations for managing command-line parameters with impact annotations, enabling value assignment, update hooks, alias resolution, and state persistence. It works with annotated values (`Impact.Options.Annot.t`), sets of kernel functions (`Frama_c_kernel.Cil_datatype.Kf.Set`), and categorized parameter groups, supporting use cases like dynamic configuration systems and project-specific state tracking in analysis tools.",
      "description_length": 444,
      "index": 1502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Verbose",
      "library": "frama-c-impact.core",
      "description": "This module manages verbose level configurations in static analysis tools through integer parameters, supporting operations like value setting/retrieval, range constraints, alias definitions, and serialization. It utilizes a stateful integer type with project-specific overrides, default tracking, and bounded validity ranges to enforce controlled value management. These features enable integration with plugin systems like Frama-C's kernel for consistent analysis behavior across projects and dynamic value adjustments during tool execution.",
      "description_length": 543,
      "index": 1503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Pdg_aux.NS",
      "library": "frama-c-impact.core",
      "description": "This module manages sets of node-zone associations where overlapping zone entries for the same node are automatically merged using `Zone.join`, ensuring each node appears only once with a consolidated zone. It supports set operations like union, intersection, and difference, along with folding over nodes to accumulate zone-aware computations, while guaranteeing nodes never exist with empty zones. It is particularly useful in program analysis scenarios requiring merged dataflow information across multiple paths, such as tracking memory regions or dependency chains where overlapping zones must be collapsed.",
      "description_length": 612,
      "index": 1504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Cache_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Use cases include storing temporary analysis results or persistent plugin data in a structured location.",
      "description_length": 369,
      "index": 1505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Reason",
      "library": "frama-c-impact.core",
      "description": "This module provides operations to manage boolean state flags that control tracking and logging behavior in impact analysis workflows. It centers on a custom type representing command-line options, offering capabilities to set values, register change listeners, and customize serialization, while maintaining internal boolean flags to enable/disable impact graph generation. These features are specifically used to explain dependencies by determining whether to record or suppress reasoning about node relationships during static analysis.",
      "description_length": 539,
      "index": 1506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.ReasonType",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type and operations for working with reason types in a graph structure, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership of project values, perform deep copies, and manage type descriptors for structured data handling. Concrete use cases include analyzing and manipulating graph nodes with typed reasoning in static analysis contexts.",
      "description_length": 416,
      "index": 1507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Config_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages the creation, retrieval, and configuration of plugin-specific directories and files within a Frama-C environment. It operates on file paths using the `Frama_c_kernel.Filepath.t` type, allowing optional directory creation when accessing resources. Concrete use cases include setting up user-specific configuration directories, safely retrieving existing directories or files, and checking whether a configuration directory has been initialized.",
      "description_length": 463,
      "index": 1508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason",
      "library": "frama-c-impact.core",
      "description": "This module defines a composite data type representing a triple of nodes and a reason type, supporting equality, comparison, hashing, and pretty-printing operations. It provides deep copying, project membership checks, and standard type and descriptor utilities for integration with Frama-C's kernel. The associated Set, Map, and Hashtbl submodules enable efficient, ordered, and hash-based collections tailored for dependency tracking, graph analysis, and project-aware data management.",
      "description_length": 487,
      "index": 1509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Print",
      "library": "frama-c-impact.core",
      "description": "This module provides a boolean option to control the printing of impacted statements to stdout, with functions to enable, disable, or toggle the setting. It supports integration with Frama-C's option system through a typed parameter, allowing project-specific state management and dynamic behavior customization via value change hooks. Typical use cases include selectively logging impacted statements during static analysis runs or debugging sessions.",
      "description_length": 452,
      "index": 1510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Share",
      "library": "frama-c-impact.core",
      "description": "This module manages paths related to a plugin's share directory, providing functions to set, retrieve, and check the existence of this directory. It supports operations to locate specific files or subdirectories within the share directory, ensuring they exist and are of the correct type. Use cases include loading plugin-specific resources such as configuration files or templates from a predefined directory structure.",
      "description_length": 420,
      "index": 1511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Upward",
      "library": "frama-c-impact.core",
      "description": "This component provides state management for boolean options, enabling value manipulation, update hook registration, serialization, and default handling, while integrating with analysis systems to control behavior. It operates on a boolean option type (`t`) and project-scoped state structures, supporting use cases like enabling/disabling analysis features, tracking execution modes, or propagating state changes upward through call hierarchies.",
      "description_length": 446,
      "index": 1512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Debug",
      "library": "frama-c-impact.core",
      "description": "This module manages integer-based debugging parameters with dynamic constraints and change notifications, supporting integration with Frama-C's plugin system. It operates on bounded integers with configurable min/max ranges, enabling value validation, incremental adjustments, and customizable serialization through marshaling routines. Typical use cases include configuring analysis options in Frama-C that require runtime adjustments, enforcing value boundaries during program analysis, or synchronizing debug settings across components via command-line interfaces and persistent storage.",
      "description_length": 590,
      "index": 1513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip",
      "library": "frama-c-impact.core",
      "description": "This module provides command-line option management for string-based sets, enabling operations like element insertion, membership checks, and iterative processing. It works with a custom abstract type derived from string sets, integrating project-specific state tracking and category-based parameter organization. Designed for static analysis tools, it supports use cases such as command-line variable validation, plugin configuration, and alias handling within Frama-C's analysis framework.",
      "description_length": 491,
      "index": 1514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.DatatypeReason",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type and operations for representing and manipulating values of a specific structured type, including equality, comparison, hashing, and pretty-printing. It supports working with lists of these values, provides deep copying, and includes a predicate to check for the presence of matching project values within a value. Use cases include managing structured data with project associations, such as analyzing or transforming abstract syntax trees in a static analysis context.",
      "description_length": 501,
      "index": 1515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph",
      "library": "frama-c-impact.core",
      "description": "This module manages graph-based reasoning structures with typed edges, supporting operations to construct, manipulate, and visualize dependency graphs. It works with nodes, kernel functions, and structured reason types to track intraprocedural and interprocedural effects in static analysis. Concrete use cases include generating DOT representations of dependency chains and analyzing code impacts across function calls.",
      "description_length": 420,
      "index": 1516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options",
      "library": "frama-c-impact.core",
      "description": "This module offers logging and diagnostic operations for managing output verbosity, warnings, and errors in static analysis plugins, using categories, formatted messages, and source positions. It also provides configuration management for stateful parameters, command-line options, and session-specific settings, supporting use cases like plugin customization, analysis result verification, and command-line-driven behavior adjustments.",
      "description_length": 436,
      "index": 1517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Pdg_aux",
      "library": "frama-c-impact.core",
      "description": "This module provides operations for manipulating nodes paired with memory zones, including pretty-printing and managing sets of node-zone associations with automatic zone merging. It supports precise dataflow analysis by tracking how nodes from one function propagate into another during calls, capturing both input and output dependencies with zone-aware consolidation. Concrete use cases include analyzing memory region dependencies across function calls and merging overlapping dataflow paths in program dependency graphs.",
      "description_length": 525,
      "index": 1518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Register",
      "library": "frama-c-impact.core",
      "description": "This module computes impact analysis results based on program annotations or specific statements and PDG nodes. It processes CIL statements and PDG node sets to determine impacted code elements, supporting precise slicing and output based on analysis parameters. It is used to identify and extract code sections affected by changes or faults in a C program.",
      "description_length": 357,
      "index": 1519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Compute_impact",
      "library": "frama-c-impact.core",
      "description": "This module computes the impact of statements or nodes within a function, returning sets of affected nodes and associated reason graphs. It operates on control flow statements and PDG nodes, mapping impacts across function boundaries. Use cases include analyzing how changes to specific code elements propagate through a program's structure, such as identifying affected execution paths after modifying a function's body.",
      "description_length": 421,
      "index": 1520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact",
      "library": "frama-c-impact.core",
      "description": "This module analyzes code impact through precise dataflow and dependency tracking across function boundaries. It works with control flow statements, program dependency graphs (PDGs), and memory zones to identify affected execution paths and dependencies after code changes. Concrete use cases include impact propagation analysis, change impact visualization via DOT graphs, and slicing affected code sections in C programs based on PDG nodes or annotations.",
      "description_length": 457,
      "index": 1521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact_gui.Register_gui",
      "library": "frama-c-impact.gui",
      "description": "This module extends the graphical user interface to integrate functionality specific to the impact plugin. It enhances existing GUI components with additional controls and visualizations tailored for plugin operations. Use this module to enable plugin-specific interactions directly within the application's main interface.",
      "description_length": 323,
      "index": 1522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact_gui",
      "library": "frama-c-impact.gui",
      "description": "This module integrates impact plugin functionality into the graphical user interface by extending existing components with specialized controls and visualizations. It operates on GUI elements to enable direct interaction with plugin features such as configuration, real-time feedback, and data display. Use it to embed plugin-specific UI elements into the main application interface for seamless user experience.",
      "description_length": 412,
      "index": 1523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence_gui.Register_gui",
      "library": "frama-c-occurrence.gui",
      "description": "This module extends the graphical user interface to integrate functionality specific to the occurrence plugin. It enhances the existing GUI components to support features like visualizing occurrence data and configuring related settings interactively. Concrete use cases include displaying occurrence statistics in a dedicated tab and enabling user input for occurrence-based analysis parameters.",
      "description_length": 396,
      "index": 1524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence_gui",
      "library": "frama-c-occurrence.gui",
      "description": "This module integrates occurrence data visualization and configuration into the GUI, adding interactive controls and displays for analyzing occurrences. It works with occurrence datasets and user interface elements like tabs, input fields, and charts. Specific uses include rendering occurrence statistics in a dedicated tab and capturing user-defined analysis parameters through form inputs.",
      "description_length": 392,
      "index": 1525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing_gui.Register_gui",
      "library": "frama-c-slicing.gui",
      "description": "This module extends the graphical user interface to enable interactive visualization of slicing operations on data structures. It integrates directly with GUI components to display and manipulate slices, enhancing user interaction during analysis or debugging. Concrete use cases include highlighting subsets of arrays or sequences in real-time within a visual interface.",
      "description_length": 371,
      "index": 1526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing_gui",
      "library": "frama-c-slicing.gui",
      "description": "This module extends the GUI to support interactive slicing operations on data structures, allowing users to visually select and manipulate subsets of arrays or sequences. It provides functions for rendering slices in real-time, updating visual representations based on user input, and synchronizing slice views with underlying data changes. Concrete use cases include debugging tools that highlight active data segments and analysis interfaces that let users explore structured data interactively.",
      "description_length": 497,
      "index": 1527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Instantiate.Global_context",
      "library": "frama-c-instantiate.core",
      "description": "This module provides a function `get_variable` that retrieves or creates a global variable by name using a provided function. It operates on string identifiers and values of type `Frama_c_kernel.Cil_types.varinfo`. A typical use case is ensuring a specific global variable exists in the CIL representation during static analysis, such as when lazily initializing analysis-specific variables.",
      "description_length": 391,
      "index": 1528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate.Transform",
      "library": "frama-c-instantiate.core",
      "description": "Registers an instantiator function generator to extend the visitor, enabling the creation of new instantiator functions from a generator signature. Works with instantiator modules that conform to the `Generator_sig` interface. Used to dynamically add instantiator logic during module initialization.",
      "description_length": 299,
      "index": 1529,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Instantiate.Instantiator_builder",
      "library": "frama-c-instantiate.core",
      "description": "Constructs a module implementing the `Instantiator` interface based on a given `Generator_sig` signature. It operates on type generators and their associated environments, enabling the creation of concrete type instantiations from polymorphic type schemes. This module is used during type checking to handle generic type expansion and specialization in the context of OCaml's module system.",
      "description_length": 390,
      "index": 1530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate",
      "library": "frama-c-instantiate.core",
      "description": "This module implements type instantiation and variable management for OCaml's module system and static analysis tools. It constructs instantiators from type generators, transforms visitor logic to extend instantiation capabilities, and manages global variable creation in CIL-based analyses. Concrete uses include expanding polymorphic types during type checking and ensuring analysis-specific global variables exist in CIL.",
      "description_length": 424,
      "index": 1531,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_boot.Boot",
      "library": "frama-c.boot",
      "description": "This module serves as the main entry point for initializing and launching Frama-C. It handles command-line argument parsing, plugin loading, and core system setup. Concrete use cases include starting the Frama-C kernel, registering plugins, and managing the initial configuration before analysis begins.",
      "description_length": 303,
      "index": 1532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_boot",
      "library": "frama-c.boot",
      "description": "This module initializes the Frama-C core system, handling command-line parsing, plugin registration, and configuration setup. It works with internal Frama-C data structures to prepare the environment for static analysis. Concrete use cases include launching the Frama-C kernel, loading analysis plugins, and setting up initial analysis parameters from user input.",
      "description_length": 363,
      "index": 1533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From.Callwise",
      "library": "frama-c-from.core",
      "description": "Implements iteration and lookup over kinstr keys in a global mapping of Eva.Assigns.t values. Provides direct access to per-instruction assignment data using Cil_types.kinstr as the key. Useful for analyzing or transforming assignments associated with specific control-flow points in the IR.",
      "description_length": 291,
      "index": 1534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From",
      "library": "frama-c-from.core",
      "description": "This module implements per-function and per-instruction assignment analysis, providing operations to compute, retrieve, and display assignment data for kernel functions and individual instructions. It works with kernel functions, memory zones, and assignment states, exposing functions to query whether analysis is computed, perform analysis, and access memory effects. Concrete use cases include tracking memory modifications across function calls and instructions, and analyzing data dependencies at specific control-flow points in the IR.",
      "description_length": 541,
      "index": 1535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Report.Register",
      "library": "frama-c-report.core",
      "description": "Handles the registration and output of report data. Works with internal data structures to collect and format information. Used to generate final reports by printing accumulated data to standard output.",
      "description_length": 202,
      "index": 1536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Report",
      "library": "frama-c-report.core",
      "description": "Handles registration and output of structured report data using internal data structures to collect and format information. Provides functions to accumulate report entries and print the final output to standard deviation. Used to generate detailed reports by processing collected data at the end of execution.",
      "description_length": 309,
      "index": 1537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sparecode.Register",
      "library": "frama-c-sparecode.core",
      "description": "Registers and manages unused code detection settings for Frama-C projects. It provides functions to retrieve configured options and remove unused global variables and types from a project. This module is used during static analysis to refine project data by eliminating elements that do not contribute to function outputs, annotations, or slicing annotations.",
      "description_length": 359,
      "index": 1538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sparecode",
      "library": "frama-c-sparecode.core",
      "description": "Registers and manages unused code detection settings for Frama-C projects. It provides functions to retrieve configured options and remove unused global variables and types. Used during static analysis to refine project data by eliminating elements that do not contribute to function outputs, annotations, or slicing annotations.",
      "description_length": 329,
      "index": 1539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string-based kernel functions in server parameters, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project skeletons to manage function representations and membership tests. Concrete use cases include storing and manipulating function sets as strings, checking project membership, and ensuring deep copies for data integrity in server configurations.",
      "description_length": 460,
      "index": 1540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling sets of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It supports membership testing with project-specific predicates and provides deep copying to ensure no shared state. Concrete use cases include managing string-based configuration options in server plugins where atomic updates and comparisons are required.",
      "description_length": 409,
      "index": 1541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based parameters in a server configuration, providing standard operations like equality, comparison, hashing, and pretty printing. It supports values of type `As_string.Datatype.t`, which represent string parameters with associated metadata. Concrete use cases include managing and validating server plugin options, such as command-line arguments or configuration file entries, where each parameter must be uniquely named, compared, and displayed.",
      "description_length": 498,
      "index": 1542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling sets of strings in a server configuration context, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with string-based parameters that can be associated with projects, enabling checks and transformations via functions like `mem_project` and `copy`. Concrete use cases include managing and validating server plugin options that require string set semantics.",
      "description_length": 458,
      "index": 1543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string lists as string parameters in a server configuration. It provides operations for equality, comparison, hashing, and pretty-printing string list values, along with deep copying and membership checks for project-related data. It is used to manage and manipulate string list parameters within server plugins and options.",
      "description_length": 368,
      "index": 1544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string parameters in a server configuration, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string-based data structures that allow multiple bindings for the same key, specifically tailored for server-side parameter maps. Concrete use cases include managing and manipulating server configuration entries, such as parsing command-line arguments or validating plugin-specific string inputs.",
      "description_length": 486,
      "index": 1545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based parameters in a server configuration, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values represented as `As_string.Datatype.t` and includes utilities for project membership checks and deep copying. Concrete use cases include managing and validating string configuration options within server plugins.",
      "description_length": 420,
      "index": 1546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a string-based parameter type with support for equality, comparison, hashing, and pretty-printing operations. It represents parameters as strings with a unique name and descriptor, ensuring no multibindings are allowed in the map structure. It is used to manage server configuration options that require string values with strict identity and comparison semantics.",
      "description_length": 384,
      "index": 1547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines operations for a string-based datatype used to represent and manipulate kernel function parameters. It includes standard utilities for equality, comparison, hashing, and pretty-printing string values, along with deep copying and project membership checks. It is used to handle parameter values that are string representations of kernel functions, supporting precise storage, comparison, and project-specific queries.",
      "description_length": 436,
      "index": 1548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for managing string-based parameters in a server configuration, including equality checks, comparison, hashing, and pretty printing. It supports working with lists of string values and provides functionality for checking membership based on project predicates and performing deep copies. Concrete use cases include handling multi-value string options in server plugins, such as command-line arguments or configuration file entries.",
      "description_length": 479,
      "index": 1549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing string-based representations of kernel functions. It supports values of type `t` that encode function declarations or prototypes, enabling precise equality checks, ordering via `compare`, and project-aware membership testing through `mem_project`. Use cases include managing and querying sets of function names in a server plugin context, such as tracking defined functions or handling customizable parameters tied to function declarations.",
      "description_length": 532,
      "index": 1550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string-based file paths in server configurations, providing standard operations like comparison, hashing, and pretty printing. It supports values that may contain project-specific information, allowing checks on associated projects via `mem_project` and creating independent copies with `copy`. Concrete use cases include managing and comparing file path parameters in server plugins, ensuring deep copies for safe manipulation across different project contexts.",
      "description_length": 507,
      "index": 1551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string-based parameters in a server plugin context, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project-specific descriptors, enabling efficient representation and manipulation of configuration values. Concrete use cases include managing server options that require structured string data with associated metadata and validation.",
      "description_length": 442,
      "index": 1552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based parameters in a server configuration, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and includes functionality for checking membership in projects and performing deep copies. Concrete use cases include managing and validating string configuration options in server plugins.",
      "description_length": 398,
      "index": 1553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality, comparison, hashing, and pretty printing. It works with string-based representations of file paths and includes utilities for project membership checks and deep copying. Concrete use cases include managing and manipulating file path configurations within server plugins.",
      "description_length": 383,
      "index": 1554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list.As_string",
      "library": "frama-c-server.core",
      "description": "This module enables managing string list parameters as string values in server configurations, supporting operations like setting allowed values, validation against predefined options, and alias resolution. It works with string lists and individual strings, incorporating features such as state change tracking, default value handling, and custom marshaling for persistence. Use cases include server command-line option parsing, project-specific configuration persistence, and validating dynamic parameters against restricted string sets.",
      "description_length": 538,
      "index": 1555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for organizing and manipulating parameter sets in a server configuration system. It provides operations to define named categories, set default behaviors, and control the special `@all` category's interpretation. Functions support creating categories with accessors, enabling global behavior, and mapping `@all` to other categories, primarily working with `Parameter_category.t` and related state types. Use cases include grouping server plugin options and defining dynamic parameter scopes.",
      "description_length": 522,
      "index": 1556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing kernel functions within a server plugin context. It provides operations to define, retrieve, and configure categories such as `none`, `default`, and `all`, along with their behaviors and dependencies. Use cases include structuring plugin parameters and controlling function visibility or activation based on category settings.",
      "description_length": 385,
      "index": 1557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage string-typed server configuration parameters stored in a map structure where each key maps to a single string value. It supports value validation against allowed lists, alias resolution, command-line integration, and state management with computed defaults, operating on string values and strict identity semantics. Use cases include dynamic configuration of server plugins, parameter validation workflows, and maintaining hierarchical state with tracked dependencies.",
      "description_length": 510,
      "index": 1558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include setting up plugin parameter groups, enabling all parameters with specific interpretations, and redirecting `@all` to another category.",
      "description_length": 446,
      "index": 1559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Bool.Datatype",
      "library": "frama-c-server.core",
      "description": "Implements boolean server parameters with support for equality, comparison, hashing, and pretty printing. Exposes operations to check membership within projects and perform deep copies of values. Suitable for configuring and managing boolean options in server plugins with strict type safety and structural integrity.",
      "description_length": 317,
      "index": 1560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, providing operations to define, retrieve, and configure named categories with accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and related state types, enabling fine-grained control over plugin behavior. Concrete use cases include setting up configurable parameter groups for plugins, enabling global defaults, and defining special categories like `@all` for collective parameter control.",
      "description_length": 480,
      "index": 1561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.AutoLog.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating log-related data structures within a server plugin. It supports equality checks, hashing, pretty printing, and deep copying, along with project membership testing. Concrete use cases include managing and monitoring log entries with structured descriptors and type representations.",
      "description_length": 374,
      "index": 1562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a set of operations for managing a collection of function declarations, including equality checks, comparison, hashing, and pretty-printing. It works with the `Datatype.t` type, representing individual function declarations, and provides methods to handle sets of these declarations efficiently. Concrete use cases include tracking and comparing function definitions during static analysis and ensuring unique representation in data structures.",
      "description_length": 467,
      "index": 1563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C kernel plugins. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling precise handling of type information and deep copying. Concrete use cases include defining and manipulating abstract data types in static analysis plugins, such as representing program states or analysis results.",
      "description_length": 481,
      "index": 1564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_list.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a list-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports list values through a structured descriptor, providing deep copying and membership checks for project-related data. Concrete use cases include managing collections of analysis parameters and tracking project-specific configurations in server plugins.",
      "description_length": 376,
      "index": 1565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete implementation of a set-like structure for a specific datatype, providing operations such as membership testing, comparison, hashing, and pretty printing. It works with values of type `Datatype.t`, supporting deep copies, equality checks, and project-based filtering through `mem_project`. Concrete use cases include managing and manipulating sets of analysis parameters or configuration values within a server plugin, ensuring consistent handling of structured data during static analysis.",
      "description_length": 521,
      "index": 1566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module offers string parameter management for server configurations, enabling operations such as value validation, alias handling, update hooks, and customizable marshaling. It works with string values and project states to enforce allowed input constraints, track modifications, and support serialization customization. Specific applications include configuring kernel function parameters with function name validation or unrestricted string options in server plugins.",
      "description_length": 474,
      "index": 1567,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Zero.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C server plugins. It supports structured values through a descriptor and provides deep copying and project membership checks. Typical use cases include representing and manipulating analysis parameters or configuration settings within Frama-C plugins.",
      "description_length": 390,
      "index": 1568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Custom.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use as a server parameter. It includes a unique name, a type descriptor, and support for deep copying and project membership checks. Concrete use cases include defining and managing custom configuration types in server plugins, ensuring values are properly compared, stored, and displayed.",
      "description_length": 412,
      "index": 1569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter collections, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter accessors and state dependencies, allowing dynamic configuration of plugin behavior. Concrete use cases include setting default parameter interpretations, enabling global category behavior, and defining how `@all` is resolved in different contexts.",
      "description_length": 465,
      "index": 1570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter collections, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, enabling precise control over parameter behavior in different contexts. Use cases include setting default category behavior, enabling all parameters with specific interpretations, and defining dependencies for custom categories.",
      "description_length": 438,
      "index": 1571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Int.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling integer values within a server plugin context, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports integration with Frama-C's kernel structures by defining a unique name, type representation, and descriptor handling. Concrete use cases include managing server configuration parameters that require persistence, comparison, and user-friendly display in analysis plugins.",
      "description_length": 463,
      "index": 1572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module enables the management of string-based server configuration parameters through operations such as setting allowed values, validating inputs against predefined lists or function checks, registering update hooks, and supporting serialization and default value handling. It operates on string values and string sets, providing functionality to enforce restricted input options for server parameters, validate command-line arguments, and maintain consistent project-specific state across configuration changes.",
      "description_length": 518,
      "index": 1573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter grouping in a server plugin context, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with `Category.t` values, which represent parameter categories, and interacts with `Frama_c_kernel.State.t` lists to define category behavior. Concrete use cases include setting up default and '@all' categories for plugin options, enabling conditional parameter activation, and defining custom category hierarchies for plugin configuration.",
      "description_length": 548,
      "index": 1574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for a string set parameter in a server plugin, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with the `Category.t` type, which wraps a parameter category from the Frama-C kernel, and includes functions to add custom categories, set dependencies, and control behavior of the `@all` category. Concrete use cases include organizing command-line options into logical groups and controlling how sets of parameters are enabled or interpreted in the context of Frama-C plugins.",
      "description_length": 572,
      "index": 1575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module enables managing string-based server configuration parameters with associated metadata, offering operations to set and retrieve values, define validation rules, and handle command-line interactions. It works with string data enriched with attributes like aliases and allowed value lists, supporting equality checks and serialization. Typical use cases include enforcing valid parameter states during server setup and dynamically adjusting configurations through user-defined hooks.",
      "description_length": 493,
      "index": 1576,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete implementation of a datatype representing a list of file paths, specifically tailored for use in server configuration and plugin parameters. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to manage and manipulate lists of file paths in a type-safe manner within the server's parameter system.",
      "description_length": 444,
      "index": 1577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module provides utilities for managing string-based server configuration parameters with constrained values, including validation against allowed options and C-style identifier rules. It operates on string lists to define permissible values, supports dynamic state tracking through change hooks, and facilitates command-line argument parsing with custom serialization. Typical use cases include enforcing restricted configuration options, validating function name parameters in server plugins, and synchronizing runtime settings with command-line interfaces.",
      "description_length": 563,
      "index": 1578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module offers operations to manage string-based file path parameters in server configurations, including validation against allowed values, function name extraction with C-ified naming rules, and serialization. It works with string file paths contextualized within projects, supporting comparisons, marshaling, and association checks. Specific use cases include enforcing valid dynamic parameter updates, resolving aliased paths, and ensuring function references adhere to naming constraints during server runtime.",
      "description_length": 519,
      "index": 1579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a map where keys are strings and values are lists of `Datatype.t`, supporting operations like insertion, lookup, and iteration over string-indexed collections of multi-valued entries. It provides functions to manipulate and query this structure, including merging, filtering, and pretty-printing contents. It is used to manage server plugin parameters that associate string identifiers with multiple typed values.",
      "description_length": 436,
      "index": 1580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for organizing and selecting groups of parameters in a server plugin configuration. It provides operations to define named categories, set default and \"all\" categories, and control their behavior with respect to activation and dependencies. Use cases include grouping related parameters under logical categories (e.g., \"@default\", \"@all\") and enabling/disabling entire sets of parameters through category-level controls.",
      "description_length": 451,
      "index": 1581,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for representing sets of strings, providing operations for equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's project management system through `mem_project` and enables deep copying of values. Concrete use cases include managing collections of string identifiers that must be persisted across different analysis sessions or compared efficiently.",
      "description_length": 418,
      "index": 1582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.False.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C server plugins. It supports structured data representation with a unique name, type descriptor, and packed representation for efficient storage and retrieval. Use cases include managing plugin-specific configuration parameters and ensuring consistent value handling across different analysis sessions.",
      "description_length": 442,
      "index": 1583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling multiple map parameters in a server plugin context, supporting operations like equality, comparison, hashing, and pretty printing. It works with a polymorphic type `t` representing map entries, alongside project-specific descriptors and representations. Concrete use cases include managing and comparing map-based configuration parameters, checking project membership within values, and ensuring deep copies for safe manipulation in different contexts.",
      "description_length": 496,
      "index": 1584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling sets of filled strings with operations for membership testing, comparison, and pretty printing. It supports efficient set operations and is used to manage string-based configurations or parameters in server plugins. The type ensures unique string storage and provides utilities for project-specific filtering and deep copying.",
      "description_length": 371,
      "index": 1585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage a string-based server parameter that supports dynamic updates through hooks, validation against predefined allowed values, and handling of aliases or serialized representations. It operates on string values representing kernel function names or prototypes, with mechanisms to enforce constraints, compute derived states, and interact with command-line interfaces via custom parsing. Typical use cases include configuring server plugins that require validated function identifiers, dynamically adjusting parameters with side effects, or bridging project state management with runtime option parsing.",
      "description_length": 640,
      "index": 1586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Debug.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for structural manipulation and comparison, including equality, hashing, and pretty printing. It supports integration with Frama-C's kernel by providing type and descriptor definitions compatible with the plugin system. The type is used to represent and manage debug parameters within the server plugin architecture, enabling deep copies, project membership checks, and structured serialization.",
      "description_length": 443,
      "index": 1587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data structure for mapping file paths to values, supporting operations like lookup, insertion, and traversal. It works with file path strings as keys and arbitrary values, ensuring efficient and deterministic access. Concrete use cases include tracking file-specific configurations or analysis results within a server plugin.",
      "description_length": 347,
      "index": 1588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_list.As_string",
      "library": "frama-c-server.core",
      "description": "This module enables managing string-based configuration parameters with operations to define allowed values, validate inputs against predefined lists, and register hooks for change tracking. It works with string values and collection-like structures to enforce constraints, support alias resolution, and maintain default states. These capabilities are particularly useful for server settings requiring strict validation, dynamic updates tied to project lifecycle events, or persistent state management across sessions.",
      "description_length": 518,
      "index": 1589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Doc.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines operations for managing and manipulating datatype representations, including equality, comparison, hashing, and pretty printing. It works with descriptors, packed structures, and lists of datatype instances, supporting introspection and project membership checks. Concrete use cases include generating documentation for server plugin parameters and ensuring deep copies of complex datatype values.",
      "description_length": 417,
      "index": 1590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing parameters in a server plugin context. It provides operations to create, modify, and query parameter categories, including special categories like `@none`, `@default`, and `@all`. Functions allow setting accessors, enabling all parameters with specific interpretations, and defining dependencies, directly working with `Category.t` and related state types.",
      "description_length": 415,
      "index": 1591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Polling.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type and operations for managing polling intervals in milliseconds, including equality, comparison, hashing, and pretty-printing. It supports values of type `t` representing polling configurations, with utilities for deep copying and checking project membership. Concrete use cases include configuring server idle wait times and serializing polling settings for analysis plugins.",
      "description_length": 406,
      "index": 1592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, providing operations to define, retrieve, and configure named categories with accessors and dependencies. It works with `Category.t`, representing parameter categories, and interacts with states and accessors from the `Frama_c_kernel` module. Concrete use cases include setting up default categories, enabling an '@all' category with specific interpretations, and mapping categories to control plugin behavior through command-line options.",
      "description_length": 500,
      "index": 1593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Empty_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling empty strings in server plugin parameters, providing equality, comparison, hashing, and pretty-printing operations. It supports structural comparisons and deep copying, ensuring values can be uniquely identified and manipulated safely across different contexts. Concrete use cases include managing configuration options that require empty string placeholders or validating parameter states in server plugins.",
      "description_length": 452,
      "index": 1594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Action.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in server plugin parameters. It supports structured values through a descriptor and representants, enabling introspection and serialization. Use cases include managing configuration values with rich semantics, such as structured options or plugin-specific settings, ensuring deep copying and project membership checks.",
      "description_length": 448,
      "index": 1595,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Enum.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations to check membership in projects, perform deep copies, and provides structural descriptors for integration with analysis frameworks. Concrete use cases include representing server configuration options as finite variants, ensuring consistent comparison and serialization across analysis sessions.",
      "description_length": 434,
      "index": 1596,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a string map datatype with operations for equality, comparison, hashing, and pretty-printing. It provides standard dictionary functionality like adding, finding, and removing key-value pairs. Concrete use cases include managing server configuration parameters and tracking plugin-specific string-indexed data.",
      "description_length": 332,
      "index": 1597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module enables managing string-valued server configuration options with operations for atomic updates, validation against allowed values, and change tracking via hooks. It operates on individual strings and string lists, supporting serialization, alias handling, and plugin integration to enforce constraints and manage dynamic parameters in project-specific contexts.",
      "description_length": 373,
      "index": 1598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Float.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling optional floating-point parameters in a server configuration. It supports operations like equality checking, comparison, hashing, and pretty-printing for float values, including those with optional decimal points. Use cases include managing numeric configuration options that may be absent or require precise representation.",
      "description_length": 368,
      "index": 1599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for managing and comparing structured values, including equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's project system through deep copying and project membership checks. The type is used to represent and manipulate kernel-specific data with customizable argument handling, such as function declarations and prototypes.",
      "description_length": 410,
      "index": 1600,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based server configuration parameters, offering operations to enforce value constraints via whitelists, normalize string identities, and resolve aliases. It operates on collections of string parameters, supporting state persistence across projects, default value definitions, and command-line interface integration. Specific applications include validating user-provided settings against predefined options, tracking computed parameter states, and marshaling configurations for storage or distributed use",
      "description_length": 531,
      "index": 1601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for organizing and selecting groups of parameters in a server plugin configuration. It provides operations to define named categories, set default and `@all` categories, and control their behavior with accessors and dependencies. Use cases include grouping related configuration options and enabling/disabling sets of parameters through command-line flags or API settings.",
      "description_length": 403,
      "index": 1602,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based configuration parameters with multibinding capabilities, offering operations to set, validate, and retrieve values while supporting aliases, hooks, and custom marshaling. It operates on a map data structure where keys associate with multiple string values, enabling flexible handling of server options and state tracking. Typical use cases include parsing command-line arguments with repeated flags, enforcing whitelist-restricted settings, and maintaining project-specific configurations across distributed systems.",
      "description_length": 549,
      "index": 1603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for a server plugin configuration system, where each category represents a logical grouping of parameters with specific access rules. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, using a map-based structure that disallows multibindings. Functions include creating named categories with dependencies, setting default behavior, and enabling the `@all` category with custom interpretations for use in parameter propagation and state management.",
      "description_length": 546,
      "index": 1604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.True.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C server plugins. It supports structured data representation with a descriptor, a list of representants, and project membership checks, enabling precise type handling and deep copying. It is used to manage parameter values in server plugins where type consistency and project-specific filtering are required.",
      "description_length": 447,
      "index": 1605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.WithOutput.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a structured datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in server plugin configurations. It supports complex data representation with deep copying, membership testing within projects, and type descriptors for runtime inspection. Concrete use cases include managing and comparing analysis configurations, serializing plugin state, and ensuring consistent value handling across distributed server contexts.",
      "description_length": 479,
      "index": 1606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type for representing file paths within a server configuration, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with a custom `Datatype.t` that encapsulates file path values, along with standard types like `string`, `int`, and `Format.formatter`. Use cases include managing server plugin file paths, validating configuration inputs, and ensuring consistent serialization and comparison of file path data.",
      "description_length": 492,
      "index": 1607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type for representing string-based server parameters, including operations for equality checking, comparison, hashing, and pretty-printing. It supports structured values with deep copying, project membership testing, and type descriptors for integration with Frama-C's plugin system. It is used to manage string configuration options within server plugins, ensuring consistent handling of parameter values across different projects and sessions.",
      "description_length": 481,
      "index": 1608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a concrete data type for handling lists of strings within the server plugin system. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to represent and manipulate string-based configuration parameters that may vary across different analysis projects.",
      "description_length": 382,
      "index": 1609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing kernel functions within a server plugin context. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, each controlling how functions are interpreted and enabled. Use cases include setting up function visibility, enabling default behaviors, and defining global function handling through category associations.",
      "description_length": 424,
      "index": 1610,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_list.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for organizing and selecting groups of parameters in a server plugin system. It provides operations to define, retrieve, and configure named categories, including special categories like `@none`, `@default`, and `@all`, with support for dependencies and access control. Use cases include grouping related server options and controlling their activation through command-line flags or configuration files.",
      "description_length": 434,
      "index": 1611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type `t` and associated operations for managing kernel function maps in a server plugin context. It provides functions for equality checks, comparison, hashing, pretty printing, and deep copying, along with descriptors for type representation and project membership testing. It is used to handle function declarations and prototypes in static analysis, supporting customization of argument handling and structural comparisons.",
      "description_length": 453,
      "index": 1612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Verbose.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It provides a structured way to handle values with project membership checks and deep copying. Use cases include managing configuration parameters in a server plugin, where values must be compared, stored, and displayed consistently.",
      "description_length": 352,
      "index": 1613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a parameter type for server plugins where each parameter is a unique key-value map without multibindings. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with project membership testing. It is used to manage structured configuration data in server plugins, ensuring safe and consistent handling of parameter values across different project contexts.",
      "description_length": 429,
      "index": 1614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Float",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage server configuration parameters storing optional floating-point values, including setting and retrieving values, defining valid numeric ranges, and registering hooks for change notifications. It works with OCaml float values and optional decimal-point representations, supporting use cases like server tuning parameters (e.g., timeouts, resource quotas) that require constrained numerical inputs or command-line option integration.",
      "description_length": 473,
      "index": 1615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list",
      "library": "frama-c-server.core",
      "description": "This module offers structured management of file path lists as server configuration parameters, enabling operations like addition, iteration, emptiness checks, and change monitoring via hooks, while organizing values into categorized groups with activation controls. It operates on `Frama_c_kernel.Filepath.t list` and supports default values, command-line exposure, and serialization, making it ideal for plugin-driven server systems requiring dynamic configuration updates and grouped parameter management. Use cases include handling file-based inputs, tracking runtime configuration changes, and persisting server state across sessions.",
      "description_length": 639,
      "index": 1616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jfile",
      "library": "frama-c-server.core",
      "description": "Handles JSON serialization and deserialization for file path data in the Frama-C kernel. Works directly with `Frama_c_kernel.Filepath.t` and JSON values. Used to convert file paths to and from JSON representations for communication between the server and clients.",
      "description_length": 263,
      "index": 1617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Action",
      "library": "frama-c-server.core",
      "description": "The module provides operations to set boolean values using `on` and `off` functions, retrieve their current state, and monitor changes via hooks, with support for command-line visibility and alias management. It works with boolean parameters encapsulated in a structured datatype that includes marshaling, equality checks, and integration with project-specific state. This enables configuring server plugins dynamically through command-line flags or maintaining consistent settings across different projects.",
      "description_length": 508,
      "index": 1618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Functions",
      "library": "frama-c-server.core",
      "description": "This module provides operations to iterate over kernel functions, retrieve unique identifiers for them, and access a stateful array of kernel functions. It works directly with `Frama_c_kernel.Cil_types.kernel_function` values. Concrete use cases include analyzing or transforming specific kernel functions during static analysis passes.",
      "description_length": 336,
      "index": 1619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Junit",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON and a unit type representation for JUnit test data. Works with `Server.Data.json` and `Server.Data.Junit.t`, which is a unit type. Used to serialize and deserialize JUnit test results to and from JSON format.",
      "description_length": 240,
      "index": 1620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Record",
      "library": "frama-c-server.core",
      "description": "This module implements a domain-specific language to define structured record types with typed fields, supporting required and optional fields with associated metadata. It operates on abstract signature and field descriptors to build and seal record schemas. Concrete use cases include defining configuration structures, data models, or API payloads with explicit field constraints and documentation.",
      "description_length": 400,
      "index": 1621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Static",
      "library": "frama-c-server.core",
      "description": "This module implements an indexer for mapping integer identifiers to keys from module `M`, with JSON serialization and deserialization capabilities. It supports lookup by integer ID, key registration, and removal, while providing safe access through `find` and `get`. Concrete use cases include managing project-specific identifiers during package processing and maintaining transient index tables for fast key recovery.",
      "description_length": 420,
      "index": 1622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.True",
      "library": "frama-c-server.core",
      "description": "This module provides operations for managing boolean server plugin options and kernel parameters, including setting values via `on`/`off` functions, defining change hooks, and handling command-line visibility. It works with boolean values (`t = bool`) and integrates with a `Datatype` module for serialization and project-specific state management. Use cases include configuring server behavior with dynamic defaults, tracking computed state, and ensuring consistent parameter handling across projects through custom marshaling and alias support.",
      "description_length": 546,
      "index": 1623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jtext",
      "library": "frama-c-server.core",
      "description": "This module handles rich text encoding and decoding using JSON representations. It provides functions to convert between JSON values and rich text structures, ensuring proper serialization and deserialization. Use this module when working with formatted text data that needs to be stored or transmitted as JSON.",
      "description_length": 311,
      "index": 1624,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Package.Derived",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manipulate and derive identifiers for server packages, including signaling, getting, setting, and fetching data. It works with `Server.Package.ident` to manage state and configuration in a server context. Concrete use cases include handling dynamic package identifiers during server initialization, reloading configurations, and decoding identifiers for routing or storage operations.",
      "description_length": 419,
      "index": 1625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_project.ProjectInfo",
      "library": "frama-c-server.core",
      "description": "Handles serialization and deserialization of project data using JSON. Works with `Frama_c_kernel.Project.t` and JSON structures. Used to convert project information to and from JSON for transmission or storage.",
      "description_length": 210,
      "index": 1626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_main.LogEvent",
      "library": "frama-c-server.core",
      "description": "Handles conversion of log events to and from JSON format. Works with Frama_c_kernel.Log.event values. Used to serialize and deserialize log data for transmission or storage.",
      "description_length": 173,
      "index": 1627,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Value_string",
      "library": "frama-c-server.core",
      "description": "This module implements a string-based value type for server parameters, providing core operations for parsing, comparison, and serialization. It supports string validation through `of_string` and `to_string` functions, ensuring correct representation during configuration handling. Use cases include managing string-typed options in server plugins, such as path settings or identifier strings.",
      "description_length": 393,
      "index": 1628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Polling",
      "library": "frama-c-server.core",
      "description": "This module configures and manages server polling intervals by manipulating bounded integer values representing idle waiting times in milliseconds. It supports dynamic adjustments via update hooks, command-line parameter handling, and serialization, while tracking valid ranges and state changes across projects. The functionality integrates with plugin systems to enable adaptive control over polling durations during server operation.",
      "description_length": 436,
      "index": 1629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_user_dir",
      "library": "frama-c-server.core",
      "description": "This module constructs a `User_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` functions to retrieve or create subdirectories and files under a specified parent path. Use it when setting up plugin-specific storage locations or organizing analysis outputs within a predefined base directory.",
      "description_length": 330,
      "index": 1630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set",
      "library": "frama-c-server.core",
      "description": "This module supports operations for manipulating sets of kernel functions (`Kf.Set.t`) through server plugin options, including dynamic updates, membership queries, and state tracking. It integrates with submodules for string-based parameter handling and category organization, enabling configuration of analysis tools that require precise control over kernel function sets. Use cases include static analysis plugins needing to manage function-specific behaviors or constraints within Frama-C's extensible framework.",
      "description_length": 516,
      "index": 1631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Joption",
      "library": "frama-c-server.core",
      "description": "This module defines an option type `t` based on the parameter module `A`, and provides JSON serialization and deserialization functions `of_json` and `to_json`. It works with JSON data structures, enabling handling of optional values during data encoding. Use this module to represent and convert optional data fields in JSON-based communication or storage.",
      "description_length": 357,
      "index": 1632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map",
      "library": "frama-c-server.core",
      "description": "This module provides a parameterized map-based configuration system enforcing unique key-value bindings, supporting operations to set and retrieve values, monitor state changes through hooks, and manage defaults with validation. It works with string-typed parameters, category groupings with dependency tracking, and supports command-line integration, custom marshalling, and structured configuration management where dynamic updates and validity checks are required. The design enables server plugins to handle hierarchical settings with strict single-binding semantics while maintaining interoperability with external contexts.",
      "description_length": 629,
      "index": 1633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jint",
      "library": "frama-c-server.core",
      "description": "This module encodes and decodes integer values to and from JSON representations. It provides conversion functions `of_json` and `to_json` for transforming JSON values into typed integers and vice versa. Useful when handling numeric data in JSON format during API requests or configuration parsing.",
      "description_length": 297,
      "index": 1634,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Value_int",
      "library": "frama-c-server.core",
      "description": "This module implements integer values for server parameters, providing essential operations for parsing, comparison, and serialization. It supports data types related to integer values with functions for conversion from/to strings, equality checks, hashing, and pretty-printing. Concrete use cases include handling numeric configuration options and ensuring consistent representation and comparison of integer-based server settings.",
      "description_length": 432,
      "index": 1635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Decl",
      "library": "frama-c-server.core",
      "description": "This module handles the conversion of abstract syntax tree (AST) declarations to and from JSON format, using a memoized unique identifier for indexing and retrieval. It operates on the `t` type, which represents Frama-C kernel declarations with their associated tags. Concrete use cases include serializing AST declarations for storage or transmission, and deserializing them back into their original form using a unique identifier.",
      "description_length": 432,
      "index": 1636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set",
      "library": "frama-c-server.core",
      "description": "This module manages string sets as server configuration parameters, providing validation, alias resolution, and serialization via `Frama_c_kernel.Datatype.String.Set.t`. It supports operations like membership checks, iteration, and context-aware state synchronization to enforce input constraints and track changes across different execution contexts. Use cases include server plugin options requiring validated arguments and project-specific configuration management with persistent state handling.",
      "description_length": 499,
      "index": 1637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.PrinterTag",
      "library": "frama-c-server.core",
      "description": "This module offers pretty-printing utilities for CIL and ACSL data structures, focusing on AST nodes like variables, types, expressions, statements, loop annotations, and function specifications. It formats these elements using OCaml's `Format.formatter` to produce structured, human-readable output tailored for debugging, logging, or analysis tool integration. Specific functions address contextual rendering needs, such as controlling annotation visibility, structural formatting (e.g., brace placement), and version-specific representations of logic constructs like predicates or behaviors.",
      "description_length": 594,
      "index": 1638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jfloat",
      "library": "frama-c-server.core",
      "description": "This module encodes and decodes floating-point numbers to and from JSON. It provides `of_json` and `to_json` functions for converting between `float` values and the `json` type. Use this module when handling numeric data in JSON format, such as parsing or serializing floating-point values in API requests or configuration files.",
      "description_length": 329,
      "index": 1639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Custom",
      "library": "frama-c-server.core",
      "description": "This module enables defining customizable server parameters and command-line options with features like value assignment, validation, pre/post-update hooks, and project-specific state integration. It operates on an abstract type `t` (aliased from `V.t`) for parameter values, string lists for aliases and restricted value sets, and includes controls for marshaling, visibility, and deprecation. Typical applications include configuring server plugins with dynamic settings, enforcing CLI parameter constraints, and managing cross-cutting concerns like project state synchronization or value change triggers.",
      "description_length": 607,
      "index": 1640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Enum",
      "library": "frama-c-server.core",
      "description": "This module implements an enum factory for creating tagged data types with bidirectional mappings between values and tags. It works with dictionary structures that register tags or prefix tags, each associated with optional values, labels, and descriptions. Concrete use cases include defining JSON-serializable enumerations where tags are explicitly declared, such as status codes, command types, or configuration options, ensuring safe and consistent encoding and decoding.",
      "description_length": 475,
      "index": 1641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Bool",
      "library": "frama-c-server.core",
      "description": "This module provides operations to configure, query, and track boolean parameters within a server environment, supporting actions like toggling values (`on`/`off`), defining default states, and attaching hooks for change notifications. It operates on `Typed_parameter.t` values, enabling type-safe manipulation of command-line options and project-specific configuration settings, particularly for kernel-level state management and plugin-driven server extensions. Use cases include dynamic parameter updates during runtime, serialization of configuration states, and ensuring consistency across distributed server plugins.",
      "description_length": 622,
      "index": 1642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Tagged",
      "library": "frama-c-server.core",
      "description": "This module implements an indexed lookup system for values of type `A.t`, using string identifiers. It supports operations to register, retrieve, and remove values by their string keys, with `find` and `get` enabling direct access. Use cases include managing named configurations or cached data entries where fast string-keyed access is required.",
      "description_length": 346,
      "index": 1643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package.IdMap",
      "library": "frama-c-server.core",
      "description": "This module implements an ordered map for associating identifiers with arbitrary values, supporting insertion, deletion, lookup, and merging using a predefined key ordering. It provides ordered traversal (ascending/descending), transformation (mapping, filtering), and conversion from key-value sequences, along with specialized operations for merging hierarchical data and maintaining sorted associations. Such structures are suited for scenarios requiring consistent key ordering, such as configuration management or dependency resolution.",
      "description_length": 541,
      "index": 1644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set",
      "library": "frama-c-server.core",
      "description": "This module provides set-like operations for managing hierarchical configuration parameters in server plugins, supporting element manipulation (add, mem, fold), alias registration with deprecation metadata, and lifecycle-aware state updates. It operates on structured values of type Datatype.t alongside string-based parameters enriched with visibility flags and category groupings, enabling use cases like CLI-driven configuration, static analysis rule sets, and project-specific parameter evolution tracking. Serialization hooks and category-based organization further facilitate persistent state management and cross-plugin compatibility.",
      "description_length": 641,
      "index": 1645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Zero",
      "library": "frama-c-server.core",
      "description": "This module provides operations for managing integer-based configuration parameters in a server plugin context, supporting value manipulation, range constraints, update hooks, and CLI integration features like option aliases and help documentation. It works with integer types enhanced with state tracking capabilities, allowing project-specific behavior customization and marshaling control. The functionality is applicable for implementing shared configuration state in kernel systems like Frama-C, where parameters must enforce validity constraints and respond to dynamic updates.",
      "description_length": 583,
      "index": 1646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map",
      "library": "frama-c-server.core",
      "description": "This module provides a map structure to associate kernel functions (and optionally pure prototypes) with values, supporting operations to set, retrieve, and monitor changes to these associations while enabling project-specific state tracking and customization of argument handling. It organizes entries using categories and aliases, incorporates marshaling customization, and integrates with command-line interfaces for dynamic parameter updates and validation. It is designed for server plugins requiring prototype-aware parameter mappings, extensible configuration systems, or context-sensitive function data management.",
      "description_length": 622,
      "index": 1647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Marker",
      "library": "frama-c-server.core",
      "description": "This module serializes and deserializes marker data to and from JSON, using a unique string tag for identification. It provides conversions through `of_json` and `to_json`, and uses `index` to generate or retrieve a unique identifier for a marker. Use cases include persisting marker information across sessions and resolving markers from their string identifiers during analysis.",
      "description_length": 380,
      "index": 1648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Jpair",
      "library": "frama-c-server.core",
      "description": "Encodes and decodes JSON data for pairs of values, converting between a JSON object and a tuple of two elements. It operates on the product type formed by two data modules, handling structured data exchange in network protocols or storage formats. Used when transmitting or persisting paired data, such as key-value entries or coordinate pairs.",
      "description_length": 344,
      "index": 1649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jany",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON values and a polymorphic variant type representing package data. It provides `of_json` and `to_json` for encoding and decoding values of type `Server.Data.json` to and from the `t` type. Used when serializing or deserializing package metadata during network transmission or storage operations.",
      "description_length": 325,
      "index": 1650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package.Scope",
      "library": "frama-c-server.core",
      "description": "Manages the visibility and resolution of package identifiers within a plugin context. It tracks reserved names and declared identifiers, ensuring correct symbol resolution. Used to enforce scope rules during package loading and prevent identifier conflicts.",
      "description_length": 257,
      "index": 1651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module manages multi-valued server configuration parameters using a map structure where string keys associate with lists of values (`V.t`), supporting operations like conditional updates, alias registration, and constraint enforcement. It provides utilities for tracking state changes, serializing configurations, and integrating with CLI interfaces through custom marshaling rules. Typical use cases include handling project-specific server settings with dynamic defaults, propagating updates across plugins, and persisting hierarchical configuration states.",
      "description_length": 564,
      "index": 1652,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_ast.Information",
      "library": "frama-c-server.core",
      "description": "This module registers and manages printer functions for AST marker information, enabling the display of structured data such as labels, titles, and optional descriptions. It works with string identifiers, format printers, and localizable messages to produce output for tools or interfaces consuming AST data. Use it to define custom visual representations of AST elements that can be dynamically enabled or updated in response to analysis changes.",
      "description_length": 447,
      "index": 1653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Position",
      "library": "frama-c-server.core",
      "description": "This module handles the conversion of position data to and from JSON format. It operates on the `t` type, which represents file positions with fields like file, dir, basename, and line. Use this module to serialize or deserialize position information for storage or transmission.",
      "description_length": 279,
      "index": 1654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map",
      "library": "frama-c-server.core",
      "description": "This module provides operations for maintaining a mutable key-value map where validated file paths serve as keys, supporting value assignment, retrieval, and change tracking through callback hooks. It works with file path\u2013based data structures paired with arbitrary values, offering iteration, folding, and search capabilities alongside parameter categorization and string-based serialization. The design targets scenarios like server plugin configuration management and analysis result storage, where dynamic updates and state persistence across sessions are required.",
      "description_length": 569,
      "index": 1655,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_set",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage string sets as configurable server plugin options, supporting modification, membership queries, iteration, and state persistence. It operates on sets of strings represented via `Frama_c_kernel.Datatype.String.Set.t` and integrates with Frama-C's project system for serialization and analysis workflows. Use cases include tracking dynamic configuration flags, validating categorized string inputs, and maintaining analysis-specific state across sessions.",
      "description_length": 495,
      "index": 1656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_site_dir",
      "library": "frama-c-server.core",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure, using a parent directory and a new directory name. It provides `get_dir` and `get_file` to retrieve validated paths within the site, ensuring the target exists and matches the expected type (directory or file). It is used to manage structured resource locations within a server plugin environment, such as locating configuration files or subdirectories within a project site.",
      "description_length": 457,
      "index": 1657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Doc",
      "library": "frama-c-server.core",
      "description": "This module provides operations for managing server plugin parameter state, including value setting and retrieval, change hooks, command-line option handling, and serialization. It works primarily with file paths (`Frama_c_kernel.Filepath.t`) and integrates with datatype management and project state tracking modules. Use cases include configuring plugins, persisting server state, and dynamically reacting to parameter changes.",
      "description_length": 429,
      "index": 1658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.AutoLog",
      "library": "frama-c-server.core",
      "description": "This module manages a boolean server parameter to control automatic logging behavior, offering operations to set state, register change hooks, and persist configurations. It works with boolean values and structured log data through the `Datatype` module, enabling use cases like dynamic logging control, audit trail generation, and project-specific state synchronization.",
      "description_length": 371,
      "index": 1659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Session",
      "library": "frama-c-server.core",
      "description": "This module manages file paths for a session directory in a server plugin, providing operations to retrieve or create directories and files within it. It works with string names and `Frama_c_kernel.Filepath.t` paths, handling path resolution and existence checks. Concrete use cases include setting up and accessing session-specific storage locations for plugin data during server execution.",
      "description_length": 391,
      "index": 1660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage and query file path configurations through typed parameters, supporting actions like value assignment, emptiness checks, and change monitoring. It works with a custom `Datatype.t` representation of file paths, integrating with project state tracking and command-line interfaces for persistent configuration. Use cases include server plugin systems requiring dynamic file path updates via hooks or serialization, such as Frama-C kernel's configuration handling.",
      "description_length": 502,
      "index": 1661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set",
      "library": "frama-c-server.core",
      "description": "This module manages sets of Cil function declarations (`fundec`) with operations for addition, iteration, membership checks, and set transformations, while integrating server plugin functionality like serialization, dynamic update hooks, and project state synchronization. It leverages `Fundec.Set.t` for efficient set storage and combines validation-ready string parameters and category-based grouping to support use cases such as tracking function sets across codebases, managing aliases, and handling configuration changes with structured, observable updates.",
      "description_length": 562,
      "index": 1662,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_list",
      "library": "frama-c-server.core",
      "description": "This module supports operations to manage server configuration parameters represented as string lists, enabling element addition, iteration, folding, and value validation alongside command-line interface integration. It tracks dynamic parameter states with change hooks, default value handling, and alias resolution, while organizing parameters into categorized groups for structured configuration management. Use cases include server plugin setup, analysis project-specific settings, and persistent parameter storage with runtime updates.",
      "description_length": 539,
      "index": 1663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Cache_dir",
      "library": "frama-c-server.core",
      "description": "This module manages the cache directory for a plugin, providing functions to retrieve or create directories and files within the cache, using the `Frama_c_kernel.Filepath.t` type for path manipulation. It allows setting and querying a user-specific cache directory without creating it, and supports conditional path creation when accessing files or directories. Concrete use cases include storing temporary analysis results, caching plugin-specific data, or managing persistent storage for plugin configurations.",
      "description_length": 512,
      "index": 1664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Tag",
      "library": "frama-c-server.core",
      "description": "Handles serialization and deserialization of package tag information using JSON. Converts between JSON values and the `tagInfo` type, ensuring data consistency during transmission. Useful for persisting or transmitting package metadata over network interfaces.",
      "description_length": 260,
      "index": 1665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String",
      "library": "frama-c-server.core",
      "description": "This module manages string-based server configuration options with validation, aliases, and serialization capabilities. It operates on string values and structured state through a rich datatype supporting equality, comparison, and marshaling, enabling integration with plugin systems and project state management. Specific use cases include validating parameter values, handling dynamic configuration changes via hooks, and persisting server settings across sessions.",
      "description_length": 467,
      "index": 1666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Jlist",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON and lists of type `A.t`. Provides `of_json` and `to_json` for serializing and deserializing list data. Useful when transmitting or storing structured list data in JSON format.",
      "description_length": 207,
      "index": 1667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list",
      "library": "frama-c-server.core",
      "description": "This module enables dynamic management of list-valued server configuration parameters through operations like element addition, folding, and iteration, alongside alias registration with visibility and deprecation controls. It works with lists of `E.t`-derived elements, incorporating serialization logic and integrating helper modules for string validation (`As_string`) and hierarchical category organization (`Category`). Use cases include tracking mutable plugin state, enforcing configuration constraints via validated aliases, and structuring server options into categorized hierarchies.",
      "description_length": 592,
      "index": 1668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jalpha",
      "library": "frama-c-server.core",
      "description": "This module encodes and decodes JSON data into a specialized string representation, ensuring compatibility with the `Server.Package.jtype` type. It provides `of_json` to convert JSON values to this string format and `to_json` to reverse the process. These functions enable precise handling of structured data in JSON workflows, such as parsing API inputs and serializing outputs.",
      "description_length": 379,
      "index": 1669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Index",
      "library": "frama-c-server.core",
      "description": "This module implements an index for mapping integer identifiers to keys from module `M`. It supports operations to register, retrieve, and remove indexed items, along with JSON serialization and deserialization. Use this to maintain a bidirectional mapping between integers and keys, particularly when working with serialized data formats.",
      "description_length": 339,
      "index": 1670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Empty_string",
      "library": "frama-c-server.core",
      "description": "This module provides operations for managing string parameters, particularly empty string placeholders, within a server plugin environment. It supports setting and retrieving values, defining change hooks, handling aliases, customizing marshaling, and validating function names, while working with string data and global state. Specific use cases include configuring plugin options and ensuring proper serialization of parameter values.",
      "description_length": 436,
      "index": 1671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.False",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage boolean server plugin parameters, including setting values via `on`/`off` functions, tracking changes through hooks, and handling aliases, command-line visibility, and serialization. It works with boolean state variables and structured metadata, leveraging custom marshaling for persistence across project sessions. These capabilities are used to configure server plugins dynamically, enforce state consistency, and support extensible parameter management in analysis workflows.",
      "description_length": 520,
      "index": 1672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_ast.Stmt",
      "library": "frama-c-server.core",
      "description": "This module defines operations for handling statement markers in the AST, specifically converting between JSON representations and the CIL statement type. It works directly with `Cil_types.stmt` and JSON data structures. Concrete use cases include serializing and deserializing AST statements during analysis or transformation tasks.",
      "description_length": 333,
      "index": 1673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jbool",
      "library": "frama-c-server.core",
      "description": "This module encodes and decodes boolean values to and from JSON. It provides `of_json` and `to_json` functions for converting between JSON representations and OCaml boolean values. It is used when handling JSON data in server-side logic that requires strict boolean interpretation, such as configuration parsing or API request validation.",
      "description_length": 338,
      "index": 1674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Identified",
      "library": "frama-c-server.core",
      "description": "This module implements an indexed storage system for uniquely identifiable data items, providing operations to register, retrieve, and remove values by integer identifiers. It works with any data type through the parameterized module `A`, maintaining an internal mapping between integer keys and values. Use this module when managing a collection of uniquely identifiable entities, such as user sessions or cached resources, where fast access and removal by ID are required.",
      "description_length": 474,
      "index": 1675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jstring",
      "library": "frama-c-server.core",
      "description": "Handles JSON string encoding and decoding for server-side data. Converts between JSON values and string representations using `of_json` and `to_json`. Used when serializing or parsing string fields in JSON payloads during API request/response handling.",
      "description_length": 252,
      "index": 1676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Lval",
      "library": "frama-c-server.core",
      "description": "This module represents and manipulates l-value markers in the AST, specifically tracking memory locations and their associated program points. It provides conversion to and from JSON, membership checks, and retrieval of l-value data. Concrete use cases include analyzing memory accesses during static analysis and tracking variable assignments across program execution paths.",
      "description_length": 375,
      "index": 1677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module supports managing mappings between kernel functions and associated value lists, with customization options for function declarations and prototype handling. It provides operations for setting and retrieving parameter values, tracking changes via hooks, and organizing entries into categorized groups with support for serialization, aliasing, and dependency management. These features are particularly useful for plugins that need to associate parameters with specific kernel functions while ensuring state persistence across Frama-C sessions or handling visibility and deprecation rules for parameter groups.",
      "description_length": 620,
      "index": 1678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jarray",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON arrays and OCaml arrays of a specified type. Works with `Server.Data.json` values and transforms them into typed arrays (`A.t array`) during decoding, and serializes such arrays back into JSON arrays during encoding. Useful for processing list-like data structures in JSON payloads, such as API request/response bodies containing sequences of structured values.",
      "description_length": 393,
      "index": 1679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module supports operations for managing a polymorphic multimap where each key maps to a list of values, enabling advanced configuration workflows with multibindings, aliases, and category-based organization. It provides functionality for setting and retrieving parameter values, serializing complex types, enforcing constraints via change hooks, and tracking state across project-specific contexts. Use cases include dynamic server configuration with hierarchical data, multi-tenant setups requiring scoped overrides, and systems needing robust change tracking or backward-compatible alias resolution.",
      "description_length": 606,
      "index": 1680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map",
      "library": "frama-c-server.core",
      "description": "This module provides a structured way to manage server configuration parameters stored in string-keyed maps, supporting operations like value insertion, lookup, and removal, along with lifecycle management via update hooks and default value handling. It works with key-value pairs where keys are strings and values conform to a consistent type `V.t`, while also enabling metadata-driven features like categorization, aliasing, and deprecation tracking. Typical use cases include configuring plugin-specific settings, enforcing immutable parameters, and maintaining project-scoped state with customizable serialization.",
      "description_length": 618,
      "index": 1681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jmarkdown",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON and a specific markdown text type used for documentation or structured text representation. Works directly with `Frama_c_kernel.Markdown.text` and JSON values. Used to serialize and deserialize markdown content for storage or transmission over JSON-based interfaces.",
      "description_length": 298,
      "index": 1682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jtriple",
      "library": "frama-c-server.core",
      "description": "Encodes and decodes JSON data into a triple structure of types A, B, and C. Converts between JSON values and the corresponding tuple representation. Useful for handling structured JSON payloads where each field maps to a distinct data type.",
      "description_length": 240,
      "index": 1683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Enum",
      "library": "frama-c-server.core",
      "description": "This module provides operations for managing configuration parameters constrained to a finite set of allowed values, supporting value setting/retrieval, change notification hooks, command-line parsing, and serialization. It operates on a variant type `t` with structural equality, primarily used for server plugin options and Frama-C's analysis frameworks to enforce fixed-choice parameters, handle project-specific state, and integrate with parameter systems via value aliases and typed descriptors.",
      "description_length": 500,
      "index": 1684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Kinstr",
      "library": "frama-c-server.core",
      "description": "Handles conversion of `kinstr` type instructions between JSON and OCaml representations. Works directly with `kinstr` values from `Frama_c_kernel.Cil_types` and `json` structures. Used for serializing and deserializing instruction markers during communication between analysis tools and external systems.",
      "description_length": 304,
      "index": 1685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.WithOutput",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manage boolean parameters with output control, enabling dynamic configuration updates and dependency tracking between parameters and result outputs. It works with boolean state values and structured data representations via the `Datatype` module, supporting custom marshaling and integration with project-specific state management. Use cases include server configuration systems where parameter changes trigger conditional output updates or propagate dependencies across related components.",
      "description_length": 525,
      "index": 1686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Debug",
      "library": "frama-c-server.core",
      "description": "This module provides a system for managing integer parameters with operations to set, retrieve, increment values, enforce range constraints, and attach hooks for change notifications. It supports integer parameters with customizable bounds, integrating marshaling, aliases, and Frama-C's state management for serialization, default tracking, and project-specific configurations, enabling dynamic debug settings adjustment, reactive updates via value hooks, and consistent state persistence across sessions.",
      "description_length": 506,
      "index": 1687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Share",
      "library": "frama-c-server.core",
      "description": "This module manages the plugin's share directory configuration, providing functions to set, retrieve, and check the directory path. It supports operations to locate specific files or subdirectories within the share directory, ensuring they exist and are of the correct type. Use cases include loading plugin-specific resources such as configuration files or auxiliary data from predefined locations within the share directory.",
      "description_length": 426,
      "index": 1688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Config_dir",
      "library": "frama-c-server.core",
      "description": "This module manages the configuration directory for a server plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring existence based on optional flags. Concrete use cases include setting up plugin-specific storage locations, accessing configuration files, or ensuring directory structures exist before writing logs or persistent data.",
      "description_length": 440,
      "index": 1689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.State_dir",
      "library": "frama-c-server.core",
      "description": "This module manages file paths for a plugin's state directory, providing operations to retrieve or create directories and files within it. It works with string names and `Frama_c_kernel.Filepath.t` paths, handling path resolution and existence checks. Use it to access plugin-specific storage locations, such as for caching results or persisting configuration data.",
      "description_length": 365,
      "index": 1690,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Verbose",
      "library": "frama-c-server.core",
      "description": "This module manages an integer-based verbosity level with constraints and dynamic state tracking. It provides operations to adjust the value within configurable bounds, register change notifications, and persist settings through serialization or project-specific storage. Key use cases include runtime verbosity control with safety limits and integrating server configuration via command-line flags or event-driven updates.",
      "description_length": 423,
      "index": 1691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_user_dir_opt",
      "library": "frama-c-server.core",
      "description": "This module constructs a configurable user directory option from an existing user directory, using a parent directory and a named directory. It provides operations to retrieve or set the directory path, create files or subdirectories within it, and check if the directory is configured. Concrete use cases include managing plugin-specific storage paths and handling environment variable overrides for user data directories.",
      "description_length": 423,
      "index": 1692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States",
      "library": "frama-c-server.core",
      "description": "This module synchronizes values and states between server and client, enabling registration of projectified values, mutable states, and arrays with associated signals and update hooks. It operates on data types like `'a Server.States.model` for structured data and `'a Server.States.array` for synchronized collections, supporting operations to reload, update, or remove entries. Concrete use cases include exposing server-side configuration values, tracking analysis state changes, and synchronizing client views of server-managed arrays such as analysis results or user-defined annotations.",
      "description_length": 592,
      "index": 1693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_project",
      "library": "frama-c-server.core",
      "description": "Converts project data to and from JSON format. Operates on `Frama_c_kernel.Project.t` and JSON structures. Used to serialize project information for storage or transmission, and to reconstruct projects from JSON data.",
      "description_length": 217,
      "index": 1694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_main",
      "library": "frama-c-server.core",
      "description": "Handles serialization and deserialization of log events to and from JSON. Operates on `Frama_c_kernel.Log.event` values. Used for transmitting or persisting log data in a structured format.",
      "description_length": 189,
      "index": 1695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast",
      "library": "frama-c-server.core",
      "description": "This module handles serialization and manipulation of abstract syntax tree (AST) components, including positions, declarations, markers, l-values, statements, and instructions. It works with CIL types, JSON representations, and custom tagged structures to support precise analysis and transformation tasks. Concrete use cases include serializing AST nodes for inter-process communication, tracking memory accesses via l-values, and pretty-printing CIL and ACSL constructs for debugging and tool integration.",
      "description_length": 507,
      "index": 1696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters",
      "library": "frama-c-server.core",
      "description": "This module provides configuration and diagnostic management for server plugins through structured logging, warning categorization, and typed parameter handling. It operates on data structures like `warn_category` for message classification, `Log.warn_status` for error tracking, and `Cmdline.Group.t` for CLI integration, supporting use cases such as session directory management, dynamic boolean/integer options, and validation of file paths or enums. Key operations include verbosity-controlled output, deprecation handling, and state-change hooks for persistent, project-specific settings.",
      "description_length": 593,
      "index": 1697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_properties",
      "library": "frama-c-server.core",
      "description": "Handles reloading of kernel property status data. Works with internal server state to refresh property status information. Used to ensure up-to-date property status is available after configuration changes.",
      "description_length": 206,
      "index": 1698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data",
      "library": "frama-c-server.core",
      "description": "This module provides JSON serialization and deserialization operations for converting between structured data and OCaml types, with support for primitives (booleans, integers, strings), collections (lists, arrays, optional values), and domain-specific formats (JUnit test results, file paths, rich text). It enables robust data modeling through bidirectional mappings for records, enums, and tagged unions, while error-handling utilities ensure precise diagnostics during decoding failures. Use cases include transmitting structured data over networks, persisting application state, and automating type-safe conversions with metadata-rich representations.",
      "description_length": 655,
      "index": 1699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_doc",
      "library": "frama-c-server.core",
      "description": "This module organizes and publishes server documentation pages grouped by chapters like protocol, kernel, or plugins. It provides functions to define pages, generate markdown content, and dump documentation files with optional metadata. Use cases include publishing API documentation, plugin descriptions, and protocol specifications with structured navigation and cross-references.",
      "description_length": 382,
      "index": 1700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Main",
      "library": "frama-c-server.core",
      "description": "This module provides operations for handling JSON-based `GET`, `SET`, and `EXEC` requests, managing client interactions through signal-driven communication, and executing asynchronous tasks. It operates on server state, JSON request/response structures, and event callbacks, enabling use cases like scalable network services, real-time data synchronization, or event-driven workflow automation. Key functionality includes lifecycle management (e.g., checking server status with `is_active`), signal handling, and registering custom request processors.",
      "description_length": 551,
      "index": 1701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Request",
      "library": "frama-c-server.core",
      "description": "This module registers and manages server requests with support for named parameters and results, signal handling, and dictionary exports. It works with JSON data structures, signals, and request signatures to define operations like `GET`, `SET`, and `EXEC` that map to OCaml functions. Concrete use cases include defining API endpoints with optional and required parameters, emitting signals to notify clients of state changes, and exporting enumerated dictionaries for client-side consumption.",
      "description_length": 494,
      "index": 1702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package",
      "library": "frama-c-server.core",
      "description": "This module enables structured management of package metadata, including dynamic configuration and symbol resolution for plugin systems. It operates on identifiers, JSON-like type descriptions, and package declarations, using ordered maps and scoped environments for efficient manipulation. Key functionalities include declaration registration, automated name generation, and conversion of internal structures into Markdown documentation through customizable formatters.",
      "description_length": 470,
      "index": 1703,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Jbuffer",
      "library": "frama-c-server.core",
      "description": "This module implements rich text buffers with support for structured output formatting and JSON serialization. It provides operations to create and manipulate buffers with customizable indentation and margins, including formatted printing, tag management, and direct JSON conversion. Concrete use cases include generating JSON-encoded diagnostic messages, pretty-printing structured data, and building nested JSON outputs from formatted text streams.",
      "description_length": 450,
      "index": 1704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server",
      "library": "frama-c-server.core",
      "description": "This module implements a JSON-based server framework with structured request handling, client communication, and state synchronization. It supports operations for processing `GET`, `SET`, and `EXEC` requests, managing signals, and serializing diverse data types including log events, project data, AST components, and rich text buffers. Concrete use cases include building networked analysis tools, synchronizing client-server state for interactive IDEs, and exposing structured APIs for plugin systems.",
      "description_length": 503,
      "index": 1705,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.Vars",
      "library": "qed",
      "description": "This module offers set-theoretic operations (union, intersection, difference, subset checks) and functional transformations (filtering, partitioning, element mapping) over an abstract variable set type `Vars.t`, where elements are represented by `Vars.elt`. It supports analysis of logical expressions through membership queries, size computation, and list-based extraction of variables. Typical applications include dependency tracking in symbolic logic, simplification of term structures, and verification of variable relationships in formal proofs.",
      "description_length": 551,
      "index": 1706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make.Map",
      "library": "qed",
      "description": "This module implements polymorphic map structures with keys of type `t`, offering operations for insertion, lookup, transformation, and traversal (including sorted-order iteration). It supports combining maps through union, intersection, and difference operations with customizable merging logic, while enabling filtering, partitioning, and comparison (e.g., subset checks, equality). Use cases include managing hierarchical data, merging configurations with conflict resolution, or processing key-value pairs in ordered contexts.",
      "description_length": 530,
      "index": 1707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.STset",
      "library": "qed",
      "description": "This module implements a structurally ordered set for logic terms, supporting insertion, union, intersection, and order-aware transformations like filtering or partitioning based on element structure. It operates on sets and sequences, enabling ordered traversal (ascending or descending) and bulk operations such as converting lists or sequences to sets while preserving structural relationships. Designed for logic expression manipulation where element hierarchy defines ordering, such as canonicalizing terms or analyzing subterm dependencies.",
      "description_length": 546,
      "index": 1708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore.Make.Env",
      "library": "qed",
      "description": "This module manages a binding environment for terms during the exportation process, providing operations to create, copy, and clear environments, track used identifiers, generate fresh names, and register or manipulate term definitions. It works with a custom environment type `t`, strings for identifiers, and terms of type `T.term`. Concrete use cases include managing variable bindings when translating or exporting logical terms to external formats like Why-3 or Alt-Ergo.",
      "description_length": 476,
      "index": 1709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_why3.Make.Env",
      "library": "qed",
      "description": "This module manages a binding environment for terms during Why-3 exportation. It supports operations to define, freshen, and track term usage, working with `T.term` and string-identified bindings. Concrete use cases include managing variable renaming, term sharing, and ensuring unique symbol generation during term serialization.",
      "description_length": 330,
      "index": 1710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Term",
      "library": "qed",
      "description": "Implements logic term operations including hashing, equality checks, and comparison for efficient manipulation of symbolic expressions. Works directly with the `term` type to support structural analysis and transformation. Useful for building theorem provers or symbolic computation systems where term identity and structure are critical.",
      "description_length": 338,
      "index": 1711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make.Set",
      "library": "qed",
      "description": "This module provides standard set operations\u2014union, intersection, difference, and membership checks\u2014alongside traversal functions for iteration, folding, and filtering. It operates on a set data structure (`Set.t`) with elements of type `Set.elt`, supporting transformations via mapping functions and conversions from lists to sets, enabling tasks like data deduplication, set algebra, and efficient membership queries.",
      "description_length": 419,
      "index": 1712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.STmap",
      "library": "qed",
      "description": "This module provides ordered map operations for logic expressions as keys, supporting efficient insertion, deletion, ordered traversal, and aggregation with structural comparison. It maintains keys in a canonical order, enabling extreme binding extraction, monotonic predicate queries, and sequence-based bulk transformations while relying on physical equality for optimized lookups. Typical applications include managing term-indexed data with ordered access requirements or merging hierarchical logic structures under strict structural constraints.",
      "description_length": 550,
      "index": 1713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export.Make.TauMap",
      "library": "qed",
      "description": "The module provides a polymorphic map structure with ordered keys supporting insertion, deletion, merging, and ordered traversal operations like finding first/last bindings or folding over key ranges. It works with key-value pairs where keys have a total ordering, enabling bulk sequence conversions, predicate-based filtering, and structural transformations while preserving immutability. This is useful for applications requiring ordered key-value storage with efficient bulk processing, such as indexing ordered datasets or implementing functional, sequence-driven workflows.",
      "description_length": 578,
      "index": 1714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Tset",
      "library": "qed",
      "description": "This module implements a high-performance set structure for logic terms, offering operations like union, intersection, difference, and membership checks, alongside transformations such as filtering, partitioning, and element-wise mapping. It works with sets of type `Tset.t` containing elements of type `term`, prioritizing machine-efficient comparisons and merges over structural analysis. It is particularly suited for applications requiring rapid set manipulation in logic processing, such as merging term environments or extracting subsets during theorem proving.",
      "description_length": 567,
      "index": 1715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export.Make.Env",
      "library": "qed",
      "description": "This module manages a binding environment for terms during code export, tracking variable usage and providing fresh variable names. It supports defining and unfolding term bindings, checking shared or shareable terms, and iterating over bound variables. Concrete use cases include managing variable capture and substitution when generating code from term representations.",
      "description_length": 371,
      "index": 1716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Var",
      "library": "qed",
      "description": "This module manages logic expression variables with operations for hashing, equality checks, comparison, and string representation. It works with the `Var.t` type, representing logic variables, and supports concrete use cases like variable substitution, term normalization, and debugging output in logical reasoning tasks. Key functions include extracting variable sort and base names, comparing variables for ordering, and generating human-readable or debug-friendly output.",
      "description_length": 475,
      "index": 1717,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.Tmap",
      "library": "qed",
      "description": "This module provides ordered maps with logic expressions as keys, supporting efficient dictionary operations (insertion, lookup, deletion), transformations (map, filter, fold), and customizable merging strategies for handling key collisions. The maps rely on machine-dependent term ordering to enable fast comparisons and subset checks, making them suitable for applications requiring high-performance term-indexed data manipulation where structural equality is not critical. Specific use cases include merging logic expression mappings with domain-specific combination rules or partitioning terms under non-structural equivalence criteria.",
      "description_length": 640,
      "index": 1718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Vmap",
      "library": "qed",
      "description": "This module provides a polymorphic map structure for key-value manipulation, supporting operations like insertion, lookup, transformation via higher-order functions (`map`, `fold`, `filter`), and set-like combinations (`union`, `inter`) with customizable merging strategies. It operates on maps from variable keys (`var`) to arbitrary values, enabling use cases such as symbolic computation or logical term processing where dynamic variable binding management and precise control over key-value association merging or comparison are required.",
      "description_length": 542,
      "index": 1719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Subst",
      "library": "qed",
      "description": "Implements term substitution with support for variable binding, term replacement, and filtering. Operates on logic expressions (`term`) and variable sets (`Vars.t`), maintaining a pool of bound variables. Useful for implementing rewriting rules, term normalization, and variable capture-avoiding substitution in formal logic systems.",
      "description_length": 333,
      "index": 1720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Tau",
      "library": "qed",
      "description": "Implements equality, comparison, and pretty-printing for logic expressions represented as `tau` terms. Provides hash generation, structural comparison, and string conversion for use in theorem proving and term manipulation tasks. Supports operations essential for managing logical formulas in automated reasoning systems.",
      "description_length": 321,
      "index": 1721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Cache.Binary",
      "library": "qed",
      "description": "Implements a binary caching mechanism that stores computed values in a fixed-size in-memory buffer. Works directly with arbitrary value types through the `A` submodule for equality checks and storage. Useful for optimizing repeated computations where results depend on binary inputs, such as cryptographic operations or checksum calculations.",
      "description_length": 342,
      "index": 1722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition.Make",
      "library": "qed",
      "description": "This module implements union-find-based partitions with operations to merge elements, check equivalence, and query partition structure. It works with elements of type `E.t` and sets of elements using `S.t`. Concrete use cases include managing dynamic equivalence relations, such as tracking connected components in a graph or grouping variables in unification algorithms.",
      "description_length": 371,
      "index": 1723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxmap.Make",
      "library": "qed",
      "description": "This module implements associative maps with indexed keys (`K.t`) and supports transformations, queries, and combinations of key-value pairs using functions like `map`, `filter`, `fold`, and specialized variants such as `mapf` (conditional mapping) or `interf` (custom intersection). It enables advanced operations on maps, including merging with user-defined strategies (`merge`, `interq`), comparing structures (`subset`, `diffq`), and conditional updates (`change`, `insert`), making it suitable for scenarios requiring precise key-based logic or combining heterogeneous map data.",
      "description_length": 583,
      "index": 1724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore.Make",
      "library": "qed",
      "description": "This module implements an exportation engine for logical terms, supporting operations to manage term bindings, generate fresh identifiers, and handle triggers and type definitions during translation to external formats. It works with terms of type `T.term`, variables of type `T.var`, functions of type `T.Fun.t`, and types of type `T.tau`. Concrete use cases include exporting proof terms to Why-3 or Alt-Ergo, where environment tracking and name generation are required for correct output generation.",
      "description_length": 502,
      "index": 1725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export.Make",
      "library": "qed",
      "description": "This module implements an export engine for transforming term representations into code, using polymorphic maps and binding environments to manage variable naming and term structure. It provides operations for defining type declarations, triggering code generation steps, and processing terms with ordered key-value mappings. Concrete use cases include compiling formal proof terms into executable code while preserving variable scoping and term relationships.",
      "description_length": 460,
      "index": 1726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Kind.MakeTau",
      "library": "qed",
      "description": "This module implements hash, equality, comparison, and pretty-printing operations for a datatype combining logic types from modules F and A. It supports concrete operations like generating string representations for debugging, comparing structural equality, and producing hash values for use in maps or sets. Typical use includes managing symbolic logic expressions where distinct type handling and normalization are required.",
      "description_length": 426,
      "index": 1727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make",
      "library": "qed",
      "description": "This module implements hashable, comparable data structures for key-based operations, supporting map and set types with custom element types. It enables efficient lookups, ordered traversal, and algebraic operations on maps and sets, such as union, intersection, and difference with customizable merging. Concrete use cases include managing configuration trees with conflict resolution, performing set algebra on deduplicated collections, and processing key-value data in sorted order.",
      "description_length": 485,
      "index": 1728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset.Make",
      "library": "qed",
      "description": "This module provides efficient set operations for managing collections of indexed elements using a Patricia trie representation. It supports creation, modification, membership queries, set algebra (union, intersection, difference), and transformations like mapping and filtering over the abstract set type `t` containing elements of type `elt`. Typical use cases include scenarios requiring persistent set structures with fast lookups and updates, such as symbolic computation or finite-state machine implementations where indexed elements represent states or terms.",
      "description_length": 566,
      "index": 1729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Cache.Unary",
      "library": "qed",
      "description": "Implements a unary cache that stores and retrieves values of type `'a` based on a single input key. It supports cache creation with a specified size limit, cache clearing, and cache-aware value computation. This module is useful for optimizing repeated computations where results can be reused based on a single input value.",
      "description_length": 324,
      "index": 1730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make",
      "library": "qed",
      "description": "This system provides operations for constructing and analyzing logical expressions, including term creation (arithmetic, equality, quantifiers), binder management (lambda, existential), and structural optimization through sharing and simplification. It operates on terms, variables, logical sorts, and state contexts, enabling formal verification tasks like theorem proving, symbolic computation, and term normalization where variable binding, custom rewriting, and efficient subterm analysis are critical. Key patterns involve embedding typed values into terms, managing free/bound variables, and state-driven term transformations with caching.",
      "description_length": 645,
      "index": 1731,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Listset.Make",
      "library": "qed",
      "description": "This module provides operations for managing ordered list-based collections with set semantics, supporting element comparison, combination, and partitioning. It works with lists of elements that enforce uniqueness and ordering, as well as lists of these structures for batch aggregation operations. The functionality is particularly useful for scenarios requiring precise set relationship analysis (e.g., computing overlaps or differences) or consolidating multiple datasets into unified representations.",
      "description_length": 504,
      "index": 1732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Listmap.Make",
      "library": "qed",
      "description": "This module implements a polymorphic associative list structure offering key-based dictionary operations (insertion, lookup, deletion), transformations (mapping, filtering), and comparisons (equality checks). It operates on Listmap data structures parameterized by a key module `K` that defines key semantics, supporting both single-map manipulations and cross-map operations like union, intersection, and difference. It is particularly useful for managing heterogeneous key-value associations, merging datasets with custom key types, or analyzing relationships between structured data collections.",
      "description_length": 598,
      "index": 1733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pretty.Make",
      "library": "qed",
      "description": "This module implements a pretty-printing environment for generating human-readable representations of terms and definitions. It manages variable binding, name freshness, and mark tracking while printing, ensuring consistent and readable output. Key operations include environment updates, term printing with or without side effects, and definition formatting, all applied to a structured term type provided by the parameter module.",
      "description_length": 431,
      "index": 1734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pool.Make",
      "library": "qed",
      "description": "This module manages a collection of uniquely identified variables, each associated with a base name, rank, and type value. It supports creating fresh variables with unique IDs, comparing and hashing variables by identifier, and maintaining multiple variable pools for separate scopes or contexts. Typical use cases include managing bound variables in a type checker or handling alpha-equivalence in formal logic systems.",
      "description_length": 420,
      "index": 1735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_why3.Make",
      "library": "qed",
      "description": "This module implements a term binding and renaming environment for the Why-3 export pipeline. It provides operations to register, freshen, and resolve term bindings using `T.term` and string keys, ensuring unique symbol generation and term sharing during serialization. Concrete use cases include managing variable renaming and tracking term usage in the export engine.",
      "description_length": 369,
      "index": 1736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergeset.Make",
      "library": "qed",
      "description": "This module provides set operations like union, intersection, difference, and subset checks for elements grouped into a polymorphic structure indexed by integers, where each key maps to a list of elements. It combines list-based storage with integer indexing to enable efficient merging and partitioning of element collections, particularly useful for scenarios requiring hierarchical set manipulation or versioned state tracking. The design supports folding, filtering, and comparison across these grouped elements, making it suitable for applications like change-set reconciliation or layered configuration management.",
      "description_length": 620,
      "index": 1737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergemap.Make",
      "library": "qed",
      "description": "This module provides operations for combining, transforming, and comparing key-value maps with support for handling key collisions and ordered traversal. It works with maps that have keys of type `K.t` and values of arbitrary types, enabling operations like union, intersection, difference, and custom folding over single or paired map entries. Typical use cases include merging datasets with conflicting keys, filtering or mapping values under key constraints, and aggregating results from multiple map sources while preserving key ordering.",
      "description_length": 542,
      "index": 1738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection",
      "library": "qed",
      "description": "Implements hashable and comparable map and set types with custom element support, enabling efficient key-based lookups, ordered traversal, and algebraic operations like union, intersection, and difference with custom merging strategies. Useful for managing configuration trees with conflict resolution, performing set algebra on deduplicated data, and processing sorted key-value collections.",
      "description_length": 392,
      "index": 1739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset",
      "library": "qed",
      "description": "Efficiently manages sets of indexed elements using Patricia tries, supporting operations like union, intersection, difference, and membership checks. Works with abstract set types containing elements of type `elt`, typically used in symbolic computation and finite-state machine implementations where elements represent states or terms. Enables fast lookups and persistent modifications for scenarios requiring efficient set manipulation.",
      "description_length": 438,
      "index": 1740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pretty",
      "library": "qed",
      "description": "This module implements a pretty-printing environment for generating human-readable representations of structured terms and definitions. It provides operations for managing variable bindings, ensuring name freshness, and formatting terms with or without side effects, all while tracking marks for consistent output. Concrete use cases include printing formal terms with proper indentation and variable scoping, and generating readable definitions from a term structure supplied by a parameter module.",
      "description_length": 499,
      "index": 1741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Engine",
      "library": "qed",
      "description": "This module defines core data types and operations for representing logical expressions, including operators, function calls, substitution patterns, and scoping rules. It supports constructing and manipulating terms with specific call styles, associativity, and type modes such as integer, real, and propositional contexts. Concrete use cases include parsing and evaluating symbolic logic expressions, managing term rewriting, and handling substitutions in formal verification tasks.",
      "description_length": 483,
      "index": 1742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Hcons",
      "library": "qed",
      "description": "This module provides hash-consing utilities for efficient structural comparison and hashing of lists, arrays, and options. It includes functions for generating hash values using custom hash functions and comparing structures for equality or ordering. Concrete use cases include memoization, hash table keys, and ensuring canonical representations of data structures.",
      "description_length": 366,
      "index": 1743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Plib",
      "library": "qed",
      "description": "This module provides utilities for constructing and manipulating formatted output, focusing on pretty-printing lists, expressions, and operator-based structures. It supports operations on strings, regular expressions, formatters, and indexed lists, with features like template-driven substitution, binary/n-ary operator layout, and iterative list processing. Typical applications include generating human-readable representations of data structures, code formatting, and templated text generation.",
      "description_length": 497,
      "index": 1744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listmap",
      "library": "qed",
      "description": "This module implements a polymorphic associative list structure with key-based dictionary operations including insertion, lookup, and deletion, along with transformations like mapping and filtering. It works with Listmap data structures parameterized by a key module `K`, supporting both single-map manipulations and cross-map operations such as union, intersection, and difference. It is useful for managing heterogeneous key-value associations and merging or analyzing datasets with custom key types.",
      "description_length": 502,
      "index": 1745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term",
      "library": "qed",
      "description": "This module represents and manipulates logical expressions as terms, supporting operations like variable binding, substitution, and term comparison. It works with data structures that model first-order logic terms, including constants, variables, and function applications. Concrete use cases include building and analyzing logical formulas for theorem proving or symbolic computation.",
      "description_length": 385,
      "index": 1746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxmap",
      "library": "qed",
      "description": "This module implements associative maps with indexed keys, supporting operations like `map`, `filter`, `fold`, `merge`, and `subset`. It works with key-value pairs where keys implement an index-preserving interface. Concrete use cases include managing symbol tables with unique identifiers, performing precise key-based transformations, and combining or comparing heterogeneous map data with custom strategies.",
      "description_length": 410,
      "index": 1747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore",
      "library": "qed",
      "description": "This module implements an exportation engine for translating logical terms to external formats like Why-3 or Alt-Ergo. It provides operations for managing term bindings, generating fresh identifiers, and handling triggers and type definitions during translation. It works with terms, variables, functions, and types from the `T` module, specifically supporting use cases such as exporting proof terms with correct environment tracking and name generation.",
      "description_length": 455,
      "index": 1748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Kind",
      "library": "qed",
      "description": "This module handles logic type manipulations, including computing sorts, degrees, and merging types. It operates on logic data types and sorts, providing functions for type parameter extraction, pretty-printing, and structural comparisons. Concrete use cases include type analysis in formal verification, normalization of type expressions, and generating human-readable representations of logic types.",
      "description_length": 401,
      "index": 1749,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Listset",
      "library": "qed",
      "description": "This module implements set operations on ordered lists, providing functions for union, intersection, difference, and comparison of elements. It works with lists of comparable elements and collections of such lists, ensuring uniqueness and order. It is useful for tasks like merging configuration sets, analyzing overlaps in sorted datasets, or consolidating multiple list-based set representations into a single structure.",
      "description_length": 422,
      "index": 1750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergemap",
      "library": "qed",
      "description": "This module implements a merging map functor that supports union, intersection, difference, and custom folding operations over key-value maps. It works with maps where keys conform to the `Key` module type, allowing ordered traversal and collision handling during merges. It is used for combining datasets with shared keys, aggregating values from multiple map sources, and transforming paired map entries under key-based constraints.",
      "description_length": 434,
      "index": 1751,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export_why3",
      "library": "qed",
      "description": "This module implements a term binding and renaming environment for the Why-3 export pipeline. It provides operations to register, freshen, and resolve term bindings using `T.term` and string keys, ensuring unique symbol generation and term sharing during serialization. Concrete use cases include managing variable renaming and tracking term usage in the export engine.",
      "description_length": 369,
      "index": 1752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition",
      "library": "qed",
      "description": "This module implements union-find data structures for managing dynamically connected elements. It provides operations to merge disjoint sets, find canonical representatives, and track equivalence classes. Concrete use cases include efficiently managing connected components in graphs and solving dynamic connectivity problems.",
      "description_length": 326,
      "index": 1753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pool",
      "library": "qed",
      "description": "This module manages a collection of uniquely identified variables, each associated with a base name, rank, and type value. It supports creating fresh variables with unique IDs, comparing and hashing variables by identifier, and maintaining multiple variable pools for separate scopes or contexts. Typical use cases include managing bound variables in a type checker or handling alpha-equivalence in formal logic systems.",
      "description_length": 420,
      "index": 1754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Intset",
      "library": "qed",
      "description": "This module offers creation, querying, and modification functions for integer sets, with efficient set-theoretic operations like union, intersection, and subset checks implemented via Patricia Trees. It operates on an abstract type representing integer sets as binary tries, enabling fast lookups, merges, and memory-efficient storage of sparse ranges. Typical applications include dataflow analysis, network routing table management, or combinatorial algorithms where rapid set manipulation and subset checks are critical.",
      "description_length": 523,
      "index": 1755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Bvars",
      "library": "qed",
      "description": "This module tracks sets of bound variables using bitwise operations, supporting efficient union, containment checks, and scoping operations. It works with a single abstract type `t` representing variable footprints, where variables are identified by integers. It is used to manage variable binding in formal verification tasks, such as tracking free and bound variables in logical expressions or ensuring proper variable capture during substitution.",
      "description_length": 449,
      "index": 1756,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Cache",
      "library": "qed",
      "description": "Implements unary and binary caching mechanisms for optimizing repeated computations. Supports cache creation with size limits, value retrieval, and cache-aware computation. Useful for scenarios like memoizing cryptographic hashes or expensive unary and binary operations.",
      "description_length": 271,
      "index": 1757,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic",
      "library": "qed",
      "description": "This module defines core constructs for first-order logic, including binders like universal and existential quantifiers, sorts for data types such as integers and arrays, and logical values for ternary logic. It provides interfaces for symbols, variables, functions, and terms to represent logical expressions and program structures. Concrete use cases include formal verification of program properties and symbolic reasoning over arithmetic and data structures.",
      "description_length": 462,
      "index": 1758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergeset",
      "library": "qed",
      "description": "This module implements set operations such as union, intersection, difference, and subset checks on polymorphic data grouped by integer keys, where each key maps to a list of elements. It supports efficient merging and partitioning of element collections, enabling hierarchical set manipulation and versioned state tracking. Concrete use cases include reconciling change sets across distributed systems and managing layered configurations with conflict resolution.",
      "description_length": 464,
      "index": 1759,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export",
      "library": "qed",
      "description": "This module implements an export engine for transforming term representations into code, using polymorphic maps and binding environments to manage variable naming and term structure. It provides operations for defining type declarations, triggering code generation steps, and processing terms with ordered key-value mappings. Concrete use cases include compiling formal proof terms into executable code while preserving variable scoping and term relationships.",
      "description_length": 460,
      "index": 1760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Intmap",
      "library": "qed",
      "description": "This module provides functions for creating, modifying, and querying integer-keyed maps implemented as Patricia Trees, supporting efficient insertion, deletion, membership checks, value updates, and transformations over keys and values. It also enables advanced operations like predicate-based filtering, custom-logic merging, subset/intersection analysis, and structure-aware pretty-printing, making it ideal for sparse array manipulation, compiler environment management, or scenarios requiring high-performance map combinations with domain-specific merge strategies.",
      "description_length": 569,
      "index": 1761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed",
      "library": "qed",
      "description": "This module provides operations for manipulating logical terms, managing variable scoping, and optimizing symbolic computations through caching and efficient data structures like hash-consed terms, Patricia trees, and union-find structures over integers and logical expressions. It supports use cases such as formal verification, compiler analysis frameworks, and code generation where precise term representation and efficient logical operations are critical.",
      "description_length": 460,
      "index": 1762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopAnalysis.Loop_analysis",
      "library": "frama-c-loop-analysis.core",
      "description": "This module analyzes loops within a function to estimate their maximum iteration bounds. It processes statements in the CIL intermediate language, specifically targeting kernel functions and their associated control flow structures. The `analyze` function performs the loop analysis, while `get_bounds` retrieves the estimated bound for a specific loop statement, and `fold_bounds` applies a function to each loop and its bound within the analyzed function. Use cases include optimizing static analysis by limiting loop unrolling or providing guarantees for verification tools.",
      "description_length": 577,
      "index": 1763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopAnalysis",
      "library": "frama-c-loop-analysis.core",
      "description": "Analyzes loops in CIL intermediate language functions to estimate maximum iteration bounds. Provides `analyze` to perform the analysis, `get_bounds` to retrieve bounds for specific loops, and `fold_bounds` to process all loop bounds in a function. Used to optimize static analysis by limiting loop unrolling and providing iteration guarantees for verification tools.",
      "description_length": 366,
      "index": 1764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Fundec_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating strings in a way that supports deep copying, equality checks, comparison, and pretty-printing. It works with string-based values and includes functionality to check membership based on project conditions. It is used to handle string identifiers in static analysis contexts, such as tracking memory writes tied to specific project elements.",
      "description_length": 421,
      "index": 1765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines operations for a string-based datatype used in tracking memory zone statements, including equality, comparison, hashing, and pretty-printing functions. It provides a deep copy operation and a membership check for project skeletons, ensuring values can be uniquely identified and compared. The module is used to represent and manipulate string parameters associated with kernel function analyses in static code verification.",
      "description_length": 443,
      "index": 1766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling sets of strings with operations for comparison, hashing, and pretty-printing. It supports membership checks with project-specific predicates and deep copying to ensure no shared references. Concrete use cases include managing collections of string identifiers in static analysis contexts, such as tracking memory regions or variable names.",
      "description_length": 384,
      "index": 1767,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating values derived from a string-based map with multibindings. It includes standard functionalities such as comparison, hashing, pretty printing, and deep copying, tailored for use in memory analysis computations. Concrete use cases include tracking and comparing memory states with string keys and managing project-specific data in a non-sharing manner.",
      "description_length": 432,
      "index": 1768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It supports working with Frama-C projects by allowing membership checks and deep copying of values. Concrete use cases include managing configuration options or command-line arguments as a unified string representation.",
      "description_length": 372,
      "index": 1769,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality checking, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type and includes utilities for project membership testing and deep copying. Concrete use cases include managing and comparing file path configurations in static analysis tools.",
      "description_length": 382,
      "index": 1770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing file paths as strings, with operations for equality, comparison, hashing, and pretty-printing. It includes functions for checking membership in projects, creating deep copies, and managing type descriptors for integration with analysis frameworks. Use cases include tracking file path data in static analysis tools and ensuring consistent handling of string-based paths across different analysis contexts.",
      "description_length": 454,
      "index": 1771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing string-based values, along with deep copying and membership testing within projects. It works with string representations of data, supporting concrete use cases like tracking and analyzing memory zone statements in static analysis. The type supports standard operations needed for use in sets and maps, with strict equality and ordering semantics.",
      "description_length": 439,
      "index": 1772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for handling string-based representations of kernel function sets in Frama-C plugins. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to manage and manipulate sets of kernel functions as strings within Frama-C's analysis framework.",
      "description_length": 371,
      "index": 1773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type and operations for handling sets of strings as a single string parameter, with standard equality, comparison, and hashing functions. It provides utilities for pretty-printing values, checking membership within a project context, and performing deep copies without shared references. Concrete use cases include managing configuration options or command-line arguments as a unified string set within static analysis tools.",
      "description_length": 452,
      "index": 1774,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines operations for a string-based datatype used in tracking memory zone statements, including equality, comparison, hashing, and pretty-printing functions. It works with string values and project skeletons to manage and query memory-related data. Concrete use cases include storing and comparing function names associated with memory operations and formatting these values for debugging or analysis output.",
      "description_length": 422,
      "index": 1775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing string-based values, along with deep copying and project membership checks. It works with string representations and project skeletons, supporting precise equality and structural comparisons. Concrete use cases include managing and querying string-based configurations or identifiers within a project analysis framework.",
      "description_length": 412,
      "index": 1776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a data type with operations for managing string-based representations in a memory analysis context. It provides equality, comparison, hashing, and pretty-printing functions tailored to string values used in static analysis of C code. The type supports deep copying, membership checks over project skeletons, and integrates with Frama-C's type and descriptor system for structured data handling.",
      "description_length": 417,
      "index": 1777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling string values with operations for comparison, hashing, and pretty-printing. It supports checking membership within projects, deep copying, and provides representants for the type. It is used to manage string parameters in a context where unique naming and structural equality are required.",
      "description_length": 333,
      "index": 1778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating values as strings, including equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's project management by providing membership checks and deep copying capabilities. Use cases include handling string-based configurations, tracking memory zones, and managing project-specific data in analyses.",
      "description_length": 409,
      "index": 1779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling string values within a memory analysis framework. It implements standard operations like equality, comparison, hashing, and pretty-printing for string values, alongside deep copying and project membership checks. It is used to represent and manipulate string data in memory states during static analysis.",
      "description_length": 348,
      "index": 1780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides utilities for managing string-based command-line parameters with validation, default handling, and alias resolution, while supporting integration with memory analysis workflows. It operates on string values and structured parameter definitions, enabling controlled access through value constraints and callback hooks. Key use cases include parsing and validating function names or memory region identifiers in static analysis tools, ensuring inputs conform to predefined allowed values or dynamic validation rules.",
      "description_length": 535,
      "index": 1781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for analyzing memory representations in static code analysis. It supports deep copying and membership checks over project skeletons, ensuring structural integrity during analysis. Concrete use cases include tracking and comparing memory states, validating properties across different program points, and facilitating serialization for storage or communication.",
      "description_length": 473,
      "index": 1782,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Int.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing integer options in a static analysis context, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the abstract `Datatype.t` type, providing concrete implementations for handling integer values within Frama-C's plugin architecture. Use cases include tracking and manipulating integer values during memory analysis and program transformation tasks.",
      "description_length": 439,
      "index": 1783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a list-based structure for representing and manipulating collections of values with support for equality, comparison, and deep copying. It provides operations to check membership within a project context, compute hashes, and format values for display. It is used to manage lists of representants in a way that ensures structural integrity and efficient comparison.",
      "description_length": 387,
      "index": 1784,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing string-based configuration parameters with support for value validation, update hooks, default handling, and command-line interface integration. It operates on strings and string lists, enabling use cases such as defining customizable analysis options in Frama-C where values must adhere to specific constraints or trigger actions on modification. Key features include alias registration, custom marshaling, and project state synchronization for robust parameter management.",
      "description_length": 519,
      "index": 1785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter configurations, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types that represent distinct configuration states, including special categories like `@none`, `@default`, and `@all`. Concrete use cases include setting up configurable analysis modes in static analysis tools, where categories control how different parts of the codebase are processed or reported.",
      "description_length": 497,
      "index": 1786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a string map for the `Studia.Options` module, providing operations to manage key-value pairs where keys are strings and values are of the `Studia` datatype. It supports efficient lookup, insertion, and iteration over string-indexed data, specifically tailored for handling memory zone statements in static analysis. Use cases include tracking variable bindings and managing analysis state keyed by string identifiers.",
      "description_length": 440,
      "index": 1787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module offers operations to manage string-valued options representing file paths, including validation against allowed values, function name extraction, and dynamic value change hooks. It works with strings interpreted as file paths, constrained value lists, and function identifiers, supporting project-specific state management via equality and comparison logic. Typical use cases include configuring file path parameters with restricted input sets, command-line interface integration for path-based options, and ensuring valid function references in dynamic dispatch scenarios.",
      "description_length": 585,
      "index": 1788,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Enum.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations to check membership within a project context, perform deep copies, and provides structural descriptors for integration with analysis frameworks. Concrete use cases include representing finite configuration options and enumerated states in static analysis tools.",
      "description_length": 400,
      "index": 1789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based configuration parameters with dynamic value handling and validation rules, operating on string maps augmented with metadata like allowed values, aliases, and serialization callbacks. It supports use cases such as command-line option parsing, static analysis configuration, and runtime parameter validation through hooks that enforce constraints or trigger side effects when values change. Key operations include registering value constraints, defining default behaviors, and bridging between string representations and functional logic in analysis tools.",
      "description_length": 587,
      "index": 1790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides utilities for managing string-based command-line parameters with validation, aliasing, and lifecycle hooks. It operates on string values and associated metadata, supporting operations to restrict inputs to predefined sets, resolve function names against a curated list, and track state changes. Typical use cases include enforcing valid configuration options, handling deprecated parameter names, and bridging string inputs with programmatic logic through customizable validation and serialization.",
      "description_length": 519,
      "index": 1791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for organizing memory zone statements, using types `elt` and `t` based on `Frama_c_kernel.Parameter_category`. It provides operations to create, modify, and enable categories such as `none`, `default`, and `all`, with support for dependencies and accessors. Use cases include configuring analysis settings where specific memory zones are categorized and selectively enabled or disabled during static analysis.",
      "description_length": 452,
      "index": 1792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides utilities for managing string-based configuration parameters that represent memory zone computation settings. It supports validation against allowed strings or function names, change tracking, and serialization customization, while maintaining default values and project-specific state. These operations are particularly useful in scenarios requiring strict validation of parameter values against predefined function declarations or prototypes in memory analysis workflows.",
      "description_length": 494,
      "index": 1793,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter grouping, using `Frama_c_kernel.Parameter_category.t` as the main structure. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with their accessors and dependencies. Use cases include configuring analysis parameters and controlling default or global behavior in static analysis setups.",
      "description_length": 393,
      "index": 1794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.WithOutput.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for structural comparison, hashing, and pretty-printing, specifically tailored for use in static analysis computations involving memory zones. It supports representant tracking, deep copying, and project membership checks, enabling precise manipulation of analysis states. Concrete use cases include managing abstract values during program analysis and persisting or comparing analysis results across different program points.",
      "description_length": 473,
      "index": 1795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.True.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin development. It supports structured data representation with a descriptor, packed descriptor, and list of representatives, enabling precise type handling. It is used to model and manipulate values within Frama-C's abstract interpretation frameworks, particularly for tracking memory states and project-specific data.",
      "description_length": 466,
      "index": 1796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a data structure for mapping string keys to values, supporting multiple entries per key. It provides operations for inserting, looking up, and iterating over key-value pairs, with specialized handling for Frama-C project data. Use cases include tracking memory zone statements and managing dynamic mappings between string identifiers and analysis data in Frama-C plugins.",
      "description_length": 394,
      "index": 1797,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a data structure for mapping file paths to arbitrary values, supporting efficient lookups, insertions, and deletions. It works with string-based file paths and associates them with a polymorphic value type. It is used to track and manage per-file data during static analysis, such as annotations or metadata tied to specific source files.",
      "description_length": 361,
      "index": 1798,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.False.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype implementation with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with a descriptor, packed descriptor, and representative values. It is used to manage and manipulate abstract values within Frama-C's plugin system, particularly for tracking and comparing memory states across projects.",
      "description_length": 380,
      "index": 1799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Empty_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` representing computations over memory zones where empty strings are significant. It provides standard operations including equality, comparison, hashing, and pretty-printing for values of type `t`, along with functions for deep copying and checking membership based on project projections. It is used to handle memory analysis scenarios in which empty string values must be explicitly tracked and distinguished.",
      "description_length": 447,
      "index": 1800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for managing values that can be stored in a map without multibindings. It supports standard operations such as equality testing, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used when working with unique, structured values that require strict identity and comparison semantics, such as tracking distinct memory states or analysis artifacts.",
      "description_length": 445,
      "index": 1801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Debug.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the Frama-C kernel's type system. It supports deep copying, membership checks over project skeletons, and provides representants for structural descriptions. It is used to model and manipulate memory zone statements with precise type and descriptor information.",
      "description_length": 394,
      "index": 1802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for a parameter map, where each category is associated with a name, an accessor, and optional dependencies. It provides operations to create, enable, and configure categories such as `@none`, `@default`, and `@all`, with support for dynamic interpretation and aliasing. Use cases include organizing and controlling the behavior of parameters in memory analysis, particularly for handling default and global settings in a structured way.",
      "description_length": 479,
      "index": 1803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Fundec_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based configuration parameters with controlled value sets, validation, and state integration. It operates on global parameter states to enforce allowed inputs through `set_possible_values`/`get_possible_values`, ensures valid C-ified function names via `get_function_name`, and supports unvalidated string retrieval with `get_plain_string`. Key use cases include command-line option parsing, project state synchronization, and analysis tool configurations requiring strict value constraints or dynamic value hooks.",
      "description_length": 541,
      "index": 1804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for representing file paths in a normalized, platform-independent manner. It supports operations for equality checking, comparison, hashing, and pretty-printing of file path values. The type `t` is used to model absolute or relative file paths, enabling robust handling of file system operations within static analysis contexts.",
      "description_length": 359,
      "index": 1805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Action.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for representing memory zone statements with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks over projections, working with `Frama_c_kernel.Project_skeleton.t` and `Datatype.t`. Concrete use cases include tracking and comparing memory state computations in static analysis.",
      "description_length": 370,
      "index": 1806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter configurations, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types that represent distinct configuration contexts, such as `@none`, `@default`, and `@all`, and allows dynamic setup of category behavior. Concrete use cases include enabling global category interpretations, setting default category values, and defining custom categories with specific states and accessors for analysis configurations.",
      "description_length": 537,
      "index": 1807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for organizing and selecting interpretations of memory zones in static analysis. It provides operations to define named categories, set default behaviors, and control the special `@all` category's interpretation. Use cases include configuring analysis scopes and enabling/disabling groups of memory zone statements dynamically.",
      "description_length": 358,
      "index": 1808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations to manage string-valued configuration parameters with change tracking, validation, and marshaling capabilities. It works with string-based values constrained by allowed value lists or function name checks, supporting use cases like static analysis of memory zone statements and project-specific state synchronization. Key features include alias management, default value handling, and validation pipelines for configuration inputs.",
      "description_length": 463,
      "index": 1809,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling lists of file paths, providing operations to compare, hash, and pretty-print these lists. It supports efficient equality checks and deep copying, ensuring values can be uniquely identified and manipulated safely. Concrete use cases include tracking sets of file paths in memory zones and comparing or serializing them during analysis passes.",
      "description_length": 385,
      "index": 1810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for handling values that may include project-specific information. It supports equality checks, comparison, hashing, and pretty-printing, along with deep copying and membership testing within projects. The type `t` works with `Frama_c_kernel.Project_skeleton.t` and is used to manage representational values in static analysis contexts. Concrete use cases include tracking and comparing function declarations and prototypes within Frama-C's analysis framework.",
      "description_length": 507,
      "index": 1811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Float.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling optional floating-point values with operations for equality, comparison, hashing, and pretty printing. It supports integration with Frama-C's type system by providing type descriptors, representants, and project membership checks. Use cases include representing and manipulating floating-point parameters in static analysis plugins where optional values must conform to Frama-C's structural type requirements.",
      "description_length": 454,
      "index": 1812,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Bool.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a boolean-like data type with operations for equality, comparison, hashing, and pretty-printing. It supports values representing true and false states, along with deep copying and project membership checks. Useful for modeling binary choices or flags within a memory analysis framework.",
      "description_length": 306,
      "index": 1813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Fundec_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for a collection of elements, typically used to classify or group related computations in memory analysis. It provides operations to define, modify, and enable categories such as `none`, `default`, and `all`, along with dependency tracking and access control. Concrete use cases include configuring analysis scopes and enabling/disabling sets of related states in static analysis workflows.",
      "description_length": 421,
      "index": 1814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for representing sets of values with operations for equality, comparison, hashing, and pretty-printing. It supports set-like structures where elements are of a specified datatype, enabling efficient membership checks and set manipulations. Concrete use cases include tracking sets of memory zones or type descriptors in static analysis, ensuring deep copying and project-aware filtering.",
      "description_length": 418,
      "index": 1815,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing a configurable string parameter, including validation against predefined values, serialization, and change tracking through hooks. It operates on string values that may represent individual strings or sets, with support for restricting inputs to allowed options and integrating with Frama-C's state/project system for persistent configuration. Use cases include command-line argument parsing, static analysis tool configuration, and validating string inputs against known function names or restricted domains.",
      "description_length": 554,
      "index": 1816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of strings that are guaranteed to be non-empty. It provides operations to create, compare, hash, and pretty-print these sets, along with deep copying and project membership checks. Concrete use cases include tracking collections of memory zone identifiers where emptiness is not a valid state, ensuring robust handling of zone statements in analysis passes.",
      "description_length": 411,
      "index": 1817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for managing multiple bindings in a map structure, supporting equality, comparison, hashing, and pretty-printing. It works with a list of representant values and provides deep copying, membership testing for project skeletons, and standard type information. Concrete use cases include tracking and manipulating sets of memory zone statements with multibinding maps in static analysis tools.",
      "description_length": 437,
      "index": 1818,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Custom.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in memory analysis computations. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. Concrete use cases include representing and manipulating analysis states with custom type parameters in Frama-C plugins.",
      "description_length": 390,
      "index": 1819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for a string set collection, using the `Frama_c_kernel.Parameter_category` structure. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with support for accessors and state dependencies. Concrete use cases include configuring analysis modes and controlling the interpretation of category-based filters in memory zone computations.",
      "description_length": 428,
      "index": 1820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for a collection of elements, using the `Frama_c_kernel.Parameter_category` structure. It provides operations to create named categories, set default and `@all` category behaviors, and enable categories with specific accessors and dependencies. These categories are used to group and control the interpretation of memory-related computations in static analysis, particularly for enabling or disabling analyses based on category membership.",
      "description_length": 482,
      "index": 1821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing configurable string parameters with validation, change tracking, and serialization capabilities. It works with string values representing kernel function sets, along with associated metadata like allowed value lists and update hooks, to enforce constraints and handle dynamic configuration. These features are particularly useful in static analysis tools for validating function name inputs against predefined rules and maintaining consistent parameter states during program analysis.",
      "description_length": 529,
      "index": 1822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types that represent sets of states and accessors tied to parameter handling in a kernel environment. Concrete use cases include configuring default and special-purpose categories like `@none`, `@default`, and `@all`, enabling global category behaviors, and linking categories to specific state interpretations.",
      "description_length": 510,
      "index": 1823,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Fundec_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of function declarations, including operations for equality, comparison, hashing, and pretty-printing. It supports working with function declaration data structures that include type information, names, descriptors, and project membership checks. Concrete use cases include tracking and manipulating collections of function definitions in static analysis tools, particularly for determining memory write effects in C programs.",
      "description_length": 480,
      "index": 1824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations to manage string-based file path parameters with validation, default handling, and alias resolution, while supporting hooks for value change tracking and integration with analysis frameworks. It operates on string data representing file paths and maintains a global parameter state to enforce value constraints, validate inputs against predefined rules, and manage serialization for tool interactions. Specific use cases include configuring project state management systems, implementing command-line interfaces with strict path validation, and marshaling file path options in analysis workflows.",
      "description_length": 628,
      "index": 1825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter customization in a kernel function analysis context. It provides operations to define, retrieve, and configure categories such as `none`, `default`, and `all`, each associated with specific states and access rules. These categories control how function parameters are interpreted and grouped in static analysis scenarios.",
      "description_length": 366,
      "index": 1826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for a collection of file paths, providing operations to define, enable, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include setting up configurable groups of file paths for analysis, enabling global interpretations, and defining default or special behaviors for category handling.",
      "description_length": 468,
      "index": 1827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Zero.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports deep copying, membership testing within projects, and provides representants and descriptors for type handling. Concrete use cases include modeling analysis states, tracking memory properties, and integrating with Frama-C's plugin infrastructure for value analysis.",
      "description_length": 446,
      "index": 1828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` for representing and manipulating function declarations in a memory analysis context. It provides operations for equality checking, comparison, hashing, pretty-printing, and deep copying, along with descriptors for integration with Frama-C's type system. It is used to track and analyze function definitions and prototypes within a program's memory zones.",
      "description_length": 391,
      "index": 1829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing optional string values with customizable validation, default handling, and command-line integration, supporting use cases like configuration parameter management and CLI argument parsing. It works with string-based data structures, including predefined value sets for input validation and marshaled representations for serialization, while enabling hooks for value changes and alias definitions. Key functionalities include restricting inputs to allowed values, validating function names, and handling raw string arguments with custom parsing logic.",
      "description_length": 594,
      "index": 1830,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Verbose.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis computations. It supports deep copying, membership testing within projects, and provides representants for structural descriptors. The type is used to model memory zone statements with verbose tracking, enabling precise analysis and debugging in Frama-C plugins.",
      "description_length": 411,
      "index": 1831,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages named categories for a collection of string-based parameters, providing operations to define, enable, and configure categories such as `@none`, `@default`, and `@all`. It works with category types that include accessors and dependencies on kernel states, allowing dynamic configuration of parameter behavior. Concrete use cases include setting up default interpretations for command-line options and enabling global behaviors in static analysis plugins.",
      "description_length": 473,
      "index": 1832,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing command-line options with string values, including setting allowed values, defining aliases, and validating inputs against constraints. It works with global parameter state to enforce valid function names or raw string values, supporting use cases like configuring analysis tools where inputs must adhere to predefined choices or dynamic validation rules. Key features include state synchronization, deprecation controls, and marshaling hooks for integrating with external systems.",
      "description_length": 526,
      "index": 1833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for string list parameters, providing operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values and state lists, allowing the association of accessors and dependencies with named categories. Concrete use cases include configuring parameter behavior in static analysis tools, where categories control how string lists are interpreted and propagated across analysis passes.",
      "description_length": 475,
      "index": 1834,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling lists of strings in a way that supports comparison, hashing, and pretty-printing. It provides operations to check equality, compare, hash, and format string lists, along with deep copying and project membership checks. It is used to represent and manipulate collections of string-based identifiers or paths within a memory analysis context.",
      "description_length": 385,
      "index": 1835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-valued parameters with change hooks, validation, and command-line integration for memory zone computation settings, supporting controlled access through allowed values and custom marshaling of string data or function names. It enables use cases like enforcing valid configuration inputs, tracking parameter state across projects, and persisting defaults with dynamic update capabilities.",
      "description_length": 414,
      "index": 1836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks and deep copying, ensuring no shared state between original and copied values. The type is integrated with Frama-C's project management system, allowing filtering based on project properties.",
      "description_length": 368,
      "index": 1837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string parameters with validation and dynamic value handling, including setting allowed values and ensuring valid function names. It operates on strings and string sets through the `Datatype` module, supporting command-line interaction and state tracking. Commonly used in static analysis for memory region identifiers and project-specific parameter validation.",
      "description_length": 381,
      "index": 1838,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter customization in a kernel function map, allowing the definition and manipulation of named categories such as `@none`, `@default`, and `@all`. It provides operations to create categories with accessors and dependencies, set default behavior, and enable or alias the `@all` category. Use cases include configuring how function parameters are interpreted across different analysis states in static code analysis.",
      "description_length": 454,
      "index": 1839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.State_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages a specific directory path for storing state-related files, providing operations to retrieve or create directories and files within that path. It works with file paths represented as `Frama_c_kernel.Filepath.t` and includes functions to set, get, and check the existence of the base directory. Concrete use cases include handling plugin-specific storage for analysis results or intermediate data in a structured and isolated manner.",
      "description_length": 451,
      "index": 1840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_site_dir",
      "library": "frama-c-studia.core",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` operations to retrieve validated directory or file paths within the site, ensuring correct type and existence checks. It works directly with `Frama_c_kernel.Filepath.t` values, supporting concrete use cases like safely locating resources in a file hierarchy during analysis setup.",
      "description_length": 399,
      "index": 1841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_map",
      "library": "frama-c-studia.core",
      "description": "This module provides a string-indexed key-value storage system with values of a polymorphic type, supporting operations to manipulate entries, track state changes via hooks, and handle aliases or deprecated keys. It works with global mutable collections, command-line option parsers, and category-organized configurations, enabling use cases like validated parameter management in static analysis tools or persistent memory zone tracking with dynamic reconfiguration.",
      "description_length": 467,
      "index": 1842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Enum",
      "library": "frama-c-studia.core",
      "description": "This component provides functionality for managing enumerated options represented as variant types with structural equality, enabling operations such as value setting/querying, change hooks, command-line interface integration, and project state synchronization. It works with fixed-value enumerated types that require `to_string` conversion and interact with Frama-C's parameter system through `Frama_c_kernel.Typed_parameter.t`. Typical use cases involve analysis frameworks needing to track option states, handle project-specific computations, or customize serialization for enumerated settings.",
      "description_length": 597,
      "index": 1843,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.WithOutput",
      "library": "frama-c-studia.core",
      "description": "This module enables managing boolean options with dynamic state updates, output dependencies, and conditional execution. It operates on typed parameters (`Frama_c_kernel.Typed_parameter.t`) and option values (`t`), supporting features like command-line aliasing, marshaling customization, and analysis-driven output control. These capabilities are particularly useful for Frama-C plugins requiring context-sensitive configuration handling, such as enabling/disabling analysis features based on project state or triggering output only when specific conditions are met.",
      "description_length": 567,
      "index": 1844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing configurable string list parameters with support for value tracking, default values, and command-line integration. It supports element addition, list iteration, folding, and category-based organization, along with serialization and alias management for use in static analysis configuration and memory analysis workflows.",
      "description_length": 365,
      "index": 1845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Config_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages file paths for a plugin-specific configuration directory. It provides operations to retrieve or create directories and files within that directory, using a user-defined path that must be explicitly set. Typical use cases include storing and accessing plugin-specific configuration files during static analysis sessions.",
      "description_length": 339,
      "index": 1846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing dynamic lists of elements with customizable behavior, including value mutation, comparison, and lifecycle hooks. It works with lists of `E.t` elements and string-validated parameters, supporting stateful interactions like marshaling, project-specific tracking, and category-based memory zone organization. Typical use cases involve scenarios requiring tracked list modifications with pre/post-append logic, validated string configuration, or alias management for memory regions.",
      "description_length": 523,
      "index": 1847,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String",
      "library": "frama-c-studia.core",
      "description": "This module provides utilities to manage string-based configuration parameters, supporting operations like setting values with optional validation against allowed strings, defining aliases, custom marshaling, and filtering through validation callbacks. It interacts with a global parameter state and integrates with analysis frameworks to enable runtime configuration, command-line interface synchronization, and introspection tasks such as state serialization or dynamic value constraints enforcement.",
      "description_length": 502,
      "index": 1848,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_set",
      "library": "frama-c-studia.core",
      "description": "This module enables managing configurable string sets with support for addition, membership checks, and iteration, alongside mechanisms to register change hooks and enforce validation rules. It operates on string collections with set semantics, integrating with project state management and serialization systems to handle dynamic configuration in static analysis workflows. Key use cases include defining whitelists/blacklists for code analysis, persisting user-defined string sets across sessions, and synchronizing configuration changes with Frama-C's analysis infrastructure.",
      "description_length": 579,
      "index": 1849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Cache_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages a cache directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing clients to set and query the cache directory location. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured way.",
      "description_length": 368,
      "index": 1850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_user_dir_opt",
      "library": "frama-c-studia.core",
      "description": "This module provides functions to manage a user directory path, including retrieving, setting, and checking the existence of the directory. It works with string names and file paths represented as `Frama_c_kernel.Filepath.t`. Concrete operations include creating paths, fetching files or directories by name, and setting or querying the current user directory.",
      "description_length": 360,
      "index": 1851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Debug",
      "library": "frama-c-studia.core",
      "description": "This module manipulates integer-based configuration parameters for debugging, supporting operations like value modification, range constraints, and change notifications. It centers on an integer state type with associated metadata, enforcing valid value ranges and enabling serialization through Frama-C's infrastructure. The design targets use cases requiring precise debug-level control in static analysis workflows, integrating with project state persistence and command-line configuration interfaces.",
      "description_length": 504,
      "index": 1852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Share",
      "library": "frama-c-studia.core",
      "description": "This module manages paths related to a plugin's share directory, providing operations to set, retrieve, and validate directory and file paths within that structure. It works with `Frama_c_kernel.Filepath.t` values, ensuring correct resolution of named directories and files relative to the configured share location. Concrete use cases include locating plugin-specific resources like configuration files or templates by name, aborting on missing or incorrect entries.",
      "description_length": 467,
      "index": 1853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Value_string",
      "library": "frama-c-studia.core",
      "description": "This module implements a string-based value type with operations for equality, comparison, hashing, and pretty printing. It supports conversions to and from regular strings, deep copying, and membership testing for project values. It is used to represent and manipulate string values in a way that integrates with Frama-C's option system and type descriptors.",
      "description_length": 359,
      "index": 1854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_multiple_map",
      "library": "frama-c-studia.core",
      "description": "This module implements a multi-binding map structure that associates keys with lists of values, enabling operations to set, retrieve, and reset entries while tracking state changes through customizable hooks. It works with key-value pairs where keys conform to a comparable type and values are stored as lists, alongside supporting modules for string serialization, category grouping, and alias management. The structure is particularly suited for configuration systems requiring hierarchical defaults, static analysis frameworks tracking memory state transitions, or applications needing versioned updates with rollback capabilities via its snapshot and diff mechanisms.",
      "description_length": 671,
      "index": 1855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath",
      "library": "frama-c-studia.core",
      "description": "This module offers operations to manage configurable file paths with normalized representations, supporting dynamic value updates through hooks and alias resolution. It works with `Frama_c_kernel.Filepath.t` values to handle default states, project-specific persistence, and custom serialization, while providing utilities to check empty paths and integrate with kernel parameters. Use cases include tracking analysis targets, configuring input/output locations with fallback paths, and maintaining consistent file references across sessions.",
      "description_length": 542,
      "index": 1856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.False",
      "library": "frama-c-studia.core",
      "description": "This module provides operations to manage a boolean parameter with associated state, enabling features such as setting values, registering change hooks, handling command-line interactions, and supporting serialization. It operates on boolean values and structured data through the `Datatype` module, facilitating synchronization of memory state configurations across Frama-C projects. Specific use cases include toggling analysis features or runtime behaviors via `on`/`off` controls while maintaining consistency with external interfaces.",
      "description_length": 539,
      "index": 1857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list",
      "library": "frama-c-studia.core",
      "description": "This module manages configurable collections of file paths with operations to add, iterate, and fold over elements, supporting dynamic value updates through change hooks. It works with `Frama_c_kernel.Filepath.t` lists and provides utilities for serialization, comparison, and category-based organization of paths. Designed for memory analysis workflows, it enables tracking project-specific state and validating file path configurations during static code analysis.",
      "description_length": 466,
      "index": 1858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Empty_string",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing string-valued options with support for setting, update hooks, and value retrieval, alongside handling structured state transitions and serialization. It works with string data and compound state types to track configuration changes and memory zone computations in static analysis workflows. The functionality supports use cases like parameter validation for Frama-C kernel extensions and project-specific state synchronization during plugin execution.",
      "description_length": 496,
      "index": 1859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set",
      "library": "frama-c-studia.core",
      "description": "This module offers operations for managing set-based options with change tracking and configuration parameters with categorization. It works with sets of values (via `Datatype.t`), string-based parameters, and abstract element collections, supporting operations like membership checks, iteration, and state synchronization. Use cases include project-specific state management, parameter validation, and maintaining synchronized collections with visibility or deprecation metadata.",
      "description_length": 480,
      "index": 1860,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Zero",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing stateful integer options with customizable update hooks and project-specific behavior, alongside configurable integer parameters constrained by dynamic ranges. It works with stateful integer values supporting serialization, comparison, and command-line visibility, as well as bounded integer parameters with incrementable values. These capabilities are designed for static analysis plugins requiring fine-grained control over analysis parameters and memory write tracking configurations.",
      "description_length": 532,
      "index": 1861,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Verbose",
      "library": "frama-c-studia.core",
      "description": "This module manages integer-based verbosity levels with dynamic configuration, supporting operations to adjust values within bounded ranges, register change notifications, and persist state across sessions. It works with integer parameters augmented by metadata for range constraints, aliases, and marshaling behavior, while integrating with Frama-C's project state tracking. Typical use cases include command-line interface setup, real-time logging level adjustments via pre/post-update hooks, and ensuring valid verbosity transitions during analysis workflows.",
      "description_length": 562,
      "index": 1862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Value_int",
      "library": "frama-c-studia.core",
      "description": "This module implements an integer-based value type with standard operations including equality, comparison, hashing, and pretty printing. It supports conversions to and from strings, deep copying, and project membership testing via predicates. The type is used to represent and manipulate integer values in a memory analysis context, particularly for tracking and comparing integer states across program executions.",
      "description_length": 415,
      "index": 1863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set",
      "library": "frama-c-studia.core",
      "description": "This module offers a customizable framework for managing sets of kernel functions, supporting operations to add, query, and iterate over elements while enabling state tracking across projects. It integrates validated string parameters and categorized groups to configure static analysis settings, with introspection capabilities for debugging and dynamic updates. Use cases include defining analysis options with custom validation and organizing parameters into logical categories for structured configuration.",
      "description_length": 510,
      "index": 1864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Custom",
      "library": "frama-c-studia.core",
      "description": "This module enables managing stateful, customizable options with support for value change hooks, default handling, and serialization customization. It operates on an abstract type `t` (aliased from `V.t`) and string lists for defining aliases or allowed values, with a focus on command-line interface configuration, project-specific state tracking, and memory-safe manipulation of typed parameters through its associated datatype module. Key use cases include validating option constraints, deprecating legacy flags, and bridging configuration data between runtime and persistent storage.",
      "description_length": 588,
      "index": 1865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_user_dir",
      "library": "frama-c-studia.core",
      "description": "This module provides functions to retrieve or create a directory and its associated file path within a parent directory structure. It operates on string identifiers for directories and files, returning paths as `Frama_c_kernel.Filepath.t` values. Concrete use cases include managing memory zone statement outputs by ensuring directory structures exist before writing results.",
      "description_length": 375,
      "index": 1866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Float",
      "library": "frama-c-studia.core",
      "description": "This module manages optional floating-point parameters with configurable ranges, enabling stateful value handling, change tracking, and alias management while integrating with Frama-C's type system. It operates on `float` values encapsulated in a stateful abstraction that supports default values, project-specific computation tracking, and customizable serialization, primarily used for kernel-level parameter configuration in analyses requiring bounded float values or command-line option handling.",
      "description_length": 500,
      "index": 1867,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Int",
      "library": "frama-c-studia.core",
      "description": "This module manages integer-valued command-line parameters with state tracking, supporting operations like value setting/retrieval, range constraints, and change notifications. It works with abstracted integer types `t` and `Datatype.t`, enabling use cases such as configurable plugin parameters with validation, incremental adjustments, and persistent state serialization. Key applications include enforcing min/max bounds for analysis settings and triggering callbacks when option values update.",
      "description_length": 497,
      "index": 1868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map",
      "library": "frama-c-studia.core",
      "description": "This module provides operations for managing a mutable map associating file paths with arbitrary values, supporting insertion, retrieval, deletion, and change tracking through hooks. It operates on string-based keys with validation, serialization, and category-based organization, enabling use cases like tracking per-file analysis state, handling project-specific configurations, and propagating updates via notifications. The structure accommodates default values and workflows requiring iterative processing or equality checks over file-path-centric data.",
      "description_length": 558,
      "index": 1869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Session",
      "library": "frama-c-studia.core",
      "description": "This module manages file and directory paths within a session-specific context, providing direct access to session resources. It allows retrieving or creating session directories and files using a consistent path structure, and tracks the current session directory state. Concrete use cases include storing and accessing session-specific configuration files or intermediate computation results in a structured filesystem hierarchy.",
      "description_length": 431,
      "index": 1870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map",
      "library": "frama-c-studia.core",
      "description": "This module manages single-binding key-value mappings with support for state tracking, dynamic value updates, and configuration lifecycle management. It operates on structured maps where keys and values are governed by separate modules (K and V), incorporating features like pre/post-update hooks, custom serialization, and aliased key resolution. Designed for configuration systems requiring validated string representations, categorized parameter grouping, and deterministic state transitions, it enables use cases such as runtime configuration reloading, audit trails for value changes, and hierarchical parameter organization with type-safe access.",
      "description_length": 652,
      "index": 1871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map",
      "library": "frama-c-studia.core",
      "description": "This module manages mappings between Frama-C kernel functions and lists of typed values (`V.t list`), supporting operations to set, update, and query entries with optional hooks for change notifications. It integrates with project state management and command-line option handling, leveraging aliases, category-based configuration, and custom serialization for structured data manipulation. Primarily used in memory zone computation workflows, it enables tracking and analyzing function-specific metadata during static analysis phases.",
      "description_length": 535,
      "index": 1872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set",
      "library": "frama-c-studia.core",
      "description": "This module supports configuration management, set operations, and integration with command-line interfaces for non-empty string collections. It organizes strings into categorical, parameterized sets with validation, dynamic updates, and custom marshaling capabilities. Primarily used for static analysis configuration, memory region tracking, and project-specific state management in analysis workflows.",
      "description_length": 404,
      "index": 1873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map",
      "library": "frama-c-studia.core",
      "description": "This module manages mappings between kernel functions and analysis values with state tracking, supporting memory analysis by associating functions to computed states. It operates on structured maps with customizable parameter aliases, semantic categories, and serialization capabilities for static analysis configurations. Key applications include parameter customization, cross-function state propagation, and integration with Frama-C's type system for precise memory zone analysis.",
      "description_length": 483,
      "index": 1874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.True",
      "library": "frama-c-studia.core",
      "description": "This module offers a framework for managing boolean parameters with dynamic behavior, supporting operations to set values (`on`/`off`), register update hooks, define aliases, and customize serialization. It operates on a typed parameter representing the option's state alongside project-specific data, leveraging Frama-C's kernel infrastructure for plugin configuration and state persistence. The design facilitates integration with static analysis workflows where runtime option adjustments and cross-component synchronization are critical.",
      "description_length": 541,
      "index": 1875,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Action",
      "library": "frama-c-studia.core",
      "description": "This module provides operations to manage boolean states tied to configuration parameters, supporting enabling/disabling features through command-line flags, default value handling, and change tracking. It works with boolean values and `Frama_c_kernel.Typed_parameter.t` instances, integrating with Frama-C's state management for persistent option serialization and dynamic reconfiguration. Specific use cases include toggling analysis modules or runtime behaviors via global flags and synchronizing option states across project sessions.",
      "description_length": 538,
      "index": 1876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Reads",
      "library": "frama-c-studia.core",
      "description": "Computes statements that read a specified memory zone, distinguishing between direct reads and indirect reads through function calls. Works with CIL statements and memory zones from the Frama-C kernel. Used to analyze data dependencies and track how memory locations are accessed in C code.",
      "description_length": 290,
      "index": 1877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options",
      "library": "frama-c-studia.core",
      "description": "This module orchestrates logging, diagnostics, and configuration workflows for Frama-C plugins, focusing on conditional output control, error handling, and parameter management. It operates on structured logging categories, verbosity levels, warning flags, and typed parameters (booleans, integers, strings, paths), with support for session state tracking and command-line integration. Key use cases include kernel-level static analysis configuration, memory workflow diagnostics, and plugin-specific option persistence with validation.",
      "description_length": 536,
      "index": 1878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Writes",
      "library": "frama-c-studia.core",
      "description": "This module identifies statements that modify a specified memory zone, classifying each modification as a direct assignment, a direct function call, or an indirect modification within a called function. It also captures initializations of global variables and formal parameters, including associated call sites for the latter. Use this module to analyze memory write operations in C code, such as tracking where and how a variable is modified or initialized across different execution paths.",
      "description_length": 491,
      "index": 1879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia",
      "library": "frama-c-studia.core",
      "description": "Analyzes memory access patterns in C code by identifying statements that write to or read from specific memory zones, classifying modifications and accesses by origin and type. Works directly with CIL statements and memory zones to track data dependencies and variable usage across execution paths. Used for static analysis tasks such as tracing variable initialization, detecting indirect modifications, and understanding control flow impacts on memory state.",
      "description_length": 460,
      "index": 1880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a string set data structure with operations for equality, comparison, hashing, and pretty-printing. It supports membership testing with project-specific predicates and provides deep copying to ensure no shared state. Concrete use cases include managing collections of string identifiers in Frama-C plugins, such as tracking variable names or function signatures across different analysis phases.",
      "description_length": 415,
      "index": 1881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based datatype used to represent and manipulate function keys in a map structure. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to handle function declarations and prototypes in static analysis contexts where string identifiers are associated with function data.",
      "description_length": 417,
      "index": 1882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based data type, including equality, comparison, hashing, and pretty-printing functions. It provides a structured way to handle string values with support for deep copying, membership checks in projects, and type descriptors for integration with analysis frameworks. Concrete use cases include representing and manipulating string identifiers in static analysis tools where precise type handling and project-specific filtering are required.",
      "description_length": 484,
      "index": 1883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling string-based representations of kernel functions, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and project-specific data through `Frama_c_kernel.Project_skeleton.t`. Use cases include managing function identifiers in a plugin, comparing and storing function representations, and generating user-friendly output for debugging or logging.",
      "description_length": 450,
      "index": 1884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based datatype used in API generation, including equality, comparison, hashing, and pretty-printing functions. It works with string values represented as `As_string.Datatype.t` and provides utilities for checking membership in projects and creating deep copies. Concrete use cases include managing and manipulating string identifiers within Frama-C's API framework, ensuring consistent handling of string data across different analysis modules.",
      "description_length": 488,
      "index": 1885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations in a map structure. It supports deep copying, membership testing within projects, and provides descriptors for type handling. It is used to manage and manipulate string values within Frama-C's plugin architecture, ensuring consistency and immutability across operations.",
      "description_length": 420,
      "index": 1886,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string list data type used as a standard string parameter, including equality, comparison, hashing, and pretty-printing functions. It supports working with lists of strings as a single concatenated string, providing representants, descriptors, and project membership checks. Concrete use cases include handling command-line arguments, configuration values, or any grouped string data requiring structured storage and comparison.",
      "description_length": 465,
      "index": 1887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based datatype used to represent file paths in a static analysis context. It includes standard functions for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate file path data within analysis plugins, particularly for tracking and comparing source file information across different analysis states.",
      "description_length": 433,
      "index": 1888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It provides a structured way to handle string-based representations with support for deep copying and membership testing within projects. Use cases include managing and manipulating string-identified entities in static analysis tools, ensuring value uniqueness and structural integrity.",
      "description_length": 405,
      "index": 1889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a map where keys are strings and values are collections of strings, supporting operations like insertion, lookup, and iteration over the mapped values. It provides typed representations for a custom data structure used in static analysis plugins, ensuring type safety and structural consistency. Concrete use cases include managing string-based configurations or annotations across different analysis contexts in Frama-C plugins.",
      "description_length": 452,
      "index": 1890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty-printing, tailored for string-based representations. It supports structured data handling with functions for checking membership in projects, deep copying, and type descriptors for integration with analysis frameworks. Concrete use cases include representing and manipulating string-structured data in static analysis tools where project-specific values must be tracked and compared efficiently.",
      "description_length": 504,
      "index": 1891,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports working with Frama-C projects by allowing checks on project membership and providing deep copying to avoid shared references. Concrete use cases include managing and comparing file path configurations in static analysis tools.",
      "description_length": 386,
      "index": 1892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based datatype used to represent and manipulate function keys in a kernel API. It supports equality checks, comparison, hashing, and pretty-printing for string values, ensuring they can be stored and compared efficiently. The module is used to handle function names as unique identifiers in API generation, allowing for deep copying, membership checks in projects, and structured representation.",
      "description_length": 439,
      "index": 1893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for handling string-based representations in a multi-map context. It supports equality checks, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to manage and manipulate string-identified entities with associated properties in static analysis plugins.",
      "description_length": 358,
      "index": 1894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for representing and manipulating values as strings, including equality, comparison, hashing, and pretty-printing. It supports structured data handling with capabilities for deep copying, membership testing within projects, and type descriptors for integration with the Frama-C kernel. Use cases include managing string-based identifiers or configurations in static analysis plugins where structured data persistence and comparison are essential.",
      "description_length": 494,
      "index": 1895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a parameter map with multibindings, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and includes functions to add custom categories with accessors and dependencies or to configure the behavior of global categories. Use cases include organizing and controlling parameter groupings in a configuration system where multiple bindings per key are allowed.",
      "description_length": 510,
      "index": 1896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a string set collection, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types that associate string names with accessors and dependency states. Concrete use cases include configuring parameter categories with specific accessors, enabling all categories with a given interpretation, or redirecting `@all` to another category.",
      "description_length": 446,
      "index": 1897,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for organizing and manipulating collections of file paths, primarily used in the context of parameter handling and state management. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with custom categories that include accessors and dependencies. Use cases include configuring analysis parameters, enabling or disabling groups of options, and defining how global categories like `@all` behave in different contexts.",
      "description_length": 509,
      "index": 1898,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based parameters representing file paths, offering operations to validate values against constraints (e.g., whitelists), set and retrieve values with optional hooks, and handle command-line arguments. It works with strings interpreted as file paths, supporting use cases like configuring static analysis tools, enforcing valid input paths, and serializing parameter state. Specific applications include restricting file access to predefined directories and dynamically updating parameters during analysis workflows.",
      "description_length": 542,
      "index": 1899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a collection, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameterized states and accessors, allowing dependencies and interpretations to be specified. Concrete use cases include configuring analysis settings in Frama-C plugins, where categories control the behavior of different analysis modules through command-line options or API calls.",
      "description_length": 479,
      "index": 1900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for type representation, comparison, hashing, and project membership checks. It works with a type `t` that represents a structured data type, supporting deep copying, pretty printing, and integration with Frama-C's project system. Concrete use cases include managing and comparing complex data structures in static analysis tools built on the Frama-C platform.",
      "description_length": 407,
      "index": 1901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` representing kernel function datatypes, with operations for equality, comparison, hashing, and pretty-printing. It includes metadata such as type information, name, and descriptors, supporting deep copying and project membership checks. It is used to manage and manipulate kernel function representations in a type-safe and structured way during static analysis.",
      "description_length": 398,
      "index": 1902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling string maps with operations for comparison, hashing, pretty printing, and deep copying. It supports values of type `Datatype.t` and provides functionality for checking membership within projects and structural equality. Concrete use cases include managing and manipulating string-indexed data structures in static analysis tools, ensuring consistent representation and efficient lookups.",
      "description_length": 432,
      "index": 1903,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides utilities for managing string parameters with dynamic validation, value hooks, and command-line integration, supporting operations to define allowed values, register update callbacks, and validate inputs against function name constraints. It works with string-valued options and parameter configurations, leveraging a datatype for structured value comparison and marshaling. Primarily used in Frama-C plugins to enforce kernel function parameter rules, handle user-defined aliases, and ensure safe string value propagation across different analysis contexts.",
      "description_length": 579,
      "index": 1904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling string values within a plugin's internal representation, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with the abstract type `Datatype.t` and supports deep copying, membership testing for project skeletons, and structural descriptions. Concrete use cases include managing string-based identifiers, annotations, or configuration values in Frama-C plugins.",
      "description_length": 449,
      "index": 1905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-valued command-line parameters with validation, aliasing, and dynamic value handling, including hooks for value changes and integration with project state systems. It works with strings and sets of allowed values, using global state to enforce constraints and support serialization. It is useful for building CLI tools that require strict parameter validation, cross-project configuration management, or deprecation workflows for legacy options.",
      "description_length": 497,
      "index": 1906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for grouping and organizing kernel functions in a static analysis tool. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, using names, accessors, and dependency lists. Use cases include defining function groups with shared behavior, setting default interpretations, and enabling global category rules for analysis configurations.",
      "description_length": 414,
      "index": 1907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for grouping and organizing kernel functions, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and uses `Frama_c_kernel.State.t` lists and accessors to define behavior and dependencies. Concrete use cases include setting up default function categories, enabling global category behavior, and mapping functions to specific categories with custom accessors.",
      "description_length": 519,
      "index": 1908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, along with support for deep copying and project membership checks. It works with a structured type `Datatype.t` that includes a type descriptor, a name, and a packed representation. Concrete use cases include managing and manipulating structured data values in static analysis tools, such as tracking and comparing analysis states or configurations.",
      "description_length": 453,
      "index": 1909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include configuring parameter behavior across different analysis modes and enabling global category interpretations in static analysis setups.",
      "description_length": 443,
      "index": 1910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling lists of file paths in a way that supports equality checks, comparison, hashing, and pretty printing. It provides operations to check membership based on project criteria, perform deep copies, and integrates with Frama-C's type and descriptor system. It is used to manage and manipulate collections of file paths within Frama-C plugins, particularly for analysis configurations and file-based data tracking.",
      "description_length": 451,
      "index": 1911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with support for structural equality, comparison, hashing, and pretty-printing, tailored for handling multibinding maps. It includes operations to check membership within projects, create deep copies, and manage type representations, making it suitable for static analysis contexts where precise data flow tracking is required. The module is used to represent and manipulate complex, project-aware data structures in Frama-C plugins.",
      "description_length": 464,
      "index": 1912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides functionality for defining and validating command-line parameters that accept file paths or function names, with support for value marshaling, alias resolution, and update hooks. It operates on string values constrained by allowed value sets, enabling use cases like configuration management in static analysis tools where parameters must enforce validity and trigger side effects on change. Key capabilities include validating inputs against predefined lists, distinguishing function names from plain strings, and customizing parameter behavior through dynamic hooks.",
      "description_length": 589,
      "index": 1913,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling sets of strings with operations for equality, comparison, hashing, and pretty printing. It supports membership testing with project-specific predicates and provides deep copying to ensure no shared state. Use cases include managing collections of string identifiers in static analysis tools where project-specific contexts must be tracked and compared efficiently.",
      "description_length": 409,
      "index": 1914,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Enum.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling enumerated values with operations for comparison, hashing, and pretty-printing. It supports a fixed variant type `t` with structural equality, providing functions like `equal`, `compare`, `hash`, and `pretty`. Use cases include representing finite sets of values in analysis plugins, where deep copying, membership checks, and project-based filtering are required.",
      "description_length": 408,
      "index": 1915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module supports configuration management, validation, and serialization for string-based parameters in Frama-C's API, operating on string data and lists of permissible values. It enables command-line interface setup, project-specific state handling, and input validation through value whitelists or function name checks, with support for custom marshaling and alias management.",
      "description_length": 382,
      "index": 1916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Int.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides a descriptor, representants, and a unique name for the type, along with functions for deep copying and project membership checking. It is used to define and manipulate structured data types within the Frama-C kernel, particularly for plugin development requiring custom data representations and analyses.",
      "description_length": 424,
      "index": 1917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-based configuration parameters with support for value validation, change hooks, and serialization. It works with string values constrained by allowed lists, function name validators, and global parameter states, primarily used to handle plugin configuration in the Frama-C kernel and enforce valid function identifier usage in kernel extensions.",
      "description_length": 397,
      "index": 1918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.True.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structural manipulation of values through deep copying and membership checks over project skeletons, ensuring full independence between original and copied values. Typical use cases include representing and managing analysis states or abstract values in Frama-C plugins.",
      "description_length": 440,
      "index": 1919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based configuration parameters for kernel APIs, offering operations to validate, set, and retrieve values while enforcing allowed function name patterns or plain string constraints. It works with string keys representing function names and parameter definitions that track allowed values, supporting use cases like command-line interface parsing and dynamic configuration with runtime validation. The module also enables alias handling and state synchronization through update hooks, ensuring consistency between string inputs and typed function references.",
      "description_length": 584,
      "index": 1920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Action.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use with Frama-C's kernel structures. It includes descriptors for type representation, a unique name, and functions to manage project membership and deep copying of values. It is used to define and manipulate custom datatypes within Frama-C plugins, ensuring compatibility with the kernel's type system and memory management.",
      "description_length": 446,
      "index": 1921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.WithOutput.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for type representation, comparison, hashing, and pretty-printing, specifically tailored for use within the Frama-C kernel. It supports values of type `Datatype.t`, providing deep copy, membership checks over project skeletons, and structural equality and comparison. Concrete use cases include managing and manipulating abstract values in static analysis plugins, such as tracking dataflow or storing annotated program states.",
      "description_length": 474,
      "index": 1922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.False.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structured data representation with a descriptor, packed descriptor, and a list of representative values. The module is used to manage and manipulate analysis-specific data in a way that ensures deep copying and project-aware membership checks.",
      "description_length": 404,
      "index": 1923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Debug.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use with Frama-C's kernel structures. It includes descriptors and representants for type inspection, and supports deep copying and project membership checks. It is used to manage and manipulate structured data within Frama-C plugins, particularly for debugging and analysis tasks involving complex data representations.",
      "description_length": 453,
      "index": 1924,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module offers functions to manage string parameters with support for value validation, command-line integration, and serialization customization, including mechanisms to enforce allowed values or function name constraints. It operates on strings and string lists\u2014either concatenated or parameterized\u2014enabling use cases like configuration management, input validation, and state tracking in command-line analysis frameworks.",
      "description_length": 428,
      "index": 1925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage a string option with hooks for value changes, serialization customization, and command-line integration, alongside utilities to define allowed values and validate inputs against function names or strings. It operates on string-based keys representing function declarations and prototypes, paired with parameter-specific allowed value lists, to enable aliasing, default handling, and project-specific state tracking in static analysis workflows. Use cases include configuration validation, dynamic parameter binding for analysis tools, and conditional retrieval of function identifiers based on contextual validation rules.",
      "description_length": 664,
      "index": 1926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Custom.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for integration with Frama-C's kernel. It supports deep copying, membership checks over project skeletons, and provides representants along with a packed descriptor for structural manipulation. Concrete use cases include defining and manipulating analysis-specific data within Frama-C plugins, ensuring compatibility with the kernel's type system and project management.",
      "description_length": 490,
      "index": 1927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Bool.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a boolean datatype with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project values, and includes type descriptors for integration with the Frama-C kernel. Use cases include representing logical states in static analysis and managing binary flags in program transformations.",
      "description_length": 372,
      "index": 1928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Verbose.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides access to type information through `ty`, `descr`, and `packed_descr`, and supports deep copying, membership testing via `mem_project`, and introspection through `reprs`. It is used to represent and manipulate structured data types within a static analysis framework, enabling precise handling of project-specific values.",
      "description_length": 449,
      "index": 1929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling string-based multiple maps in the context of Frama-C's internal representations. It includes functions for checking membership within projects, deep copying values, and exposing type descriptors for integration with Frama-C's plugin system. Concrete use cases include managing and manipulating abstract values in static analysis plugins, particularly when tracking string-indexed data across different project contexts.",
      "description_length": 545,
      "index": 1930,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` and associated operations for managing a set of function declarations, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership based on project criteria, perform deep copies, and expose type descriptors for integration with Frama-C's kernel. Concrete use cases include tracking and manipulating function definitions during static analysis and plugin development within Frama-C.",
      "description_length": 461,
      "index": 1931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-based command-line parameters with validation, including setting allowed values, enforcing function name constraints, and handling default states. It works with string parameters and associated metadata like allowed value lists, supporting use cases in Frama-C plugin development where options require strict input validation, dynamic state tracking, and conditional marshaling between raw strings and function identifiers. Specific features include validating values against predefined sets, extracting function names with safety checks, and maintaining project-specific configuration state.",
      "description_length": 644,
      "index": 1932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a collection, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameterized elements and state lists, supporting dynamic category creation with accessors and dependencies. Concrete use cases include configuring analysis options in Frama-C plugins, where categories control the behavior of parameters across different analysis passes.",
      "description_length": 468,
      "index": 1933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-based command-line parameters in Frama-C plugins, including validation against allowed values, alias resolution, and serialization. It works with string data (`type t = string`) stored in a parameter map structure, supporting metadata operations like default value handling and help message generation. Specific use cases include defining plugin options with restricted value sets, validating inputs via function rules, and maintaining project-specific state through string-valued parameters.",
      "description_length": 544,
      "index": 1934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. It works with a list of representants and a packed descriptor, supporting structural operations on a custom datatype. Concrete use cases include managing and manipulating structured data values with consistent identity, comparison, and serialization behavior.",
      "description_length": 432,
      "index": 1935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, providing operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with `Category.t` values, which represent individual categories, and interacts with `Frama_c_kernel.State.t` lists for state dependencies. Concrete use cases include defining a new category with `add`, enabling a catch-all category with specific behavior using `enable_all` or `enable_all_as`, and managing default category settings through `set_default`.",
      "description_length": 533,
      "index": 1936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Float.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for representing floating-point numbers with optional decimal points, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the `Datatype.t` structure and includes functions for deep copying values, checking membership within projects, and generating user-friendly output. Concrete use cases include handling floating-point parameters in Frama-C plugins, ensuring correct type representation and efficient value comparison.",
      "description_length": 497,
      "index": 1937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter collections, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter states and accessors, allowing dynamic configuration of category behavior. Concrete use cases include setting up default parameter interpretations, enabling global category behavior, and defining dependencies for specific categories.",
      "description_length": 444,
      "index": 1938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides utilities for managing string-based command-line parameters with validation, default handling, and alias support, operating on string data and structured parameter configurations. It enables defining allowed value sets, validating inputs against these constraints, and conditionally resolving strings as either function names or literal values. Primarily used for configuring Frama-C plugins through CLI options with strict value semantics and extensible validation rules.",
      "description_length": 493,
      "index": 1939,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for organizing and manipulating collections of file paths in a configuration system. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with custom named categories that include accessors and dependencies. Use cases include setting up configurable groups of file paths for analysis tools, where categories control how different paths are processed or interpreted.",
      "description_length": 456,
      "index": 1940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling lists of strings with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function and supports project membership checks through custom predicates. The type is integrated with Frama-C's datatype system for use in analysis plugins.",
      "description_length": 315,
      "index": 1941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-based command-line parameters with support for multiple values, validation against allowed strings, and handling aliased or deprecated option names. It works with map-like structures that permit multibindings, string collections, and validation functions to enforce value constraints or parse inputs. Specific use cases include configuring CLI tools with options that accept multiple string arguments, validating user-provided strings against predefined sets, and maintaining project-specific state with serialized string representations.",
      "description_length": 590,
      "index": 1942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string-based configuration parameters, including setting values, defining allowed options, and validating inputs against predefined rules or function name patterns. It works with string data and structured parameter definitions that support aliasing, default values, and customizable serialization, while integrating with command-line interfaces. Key use cases include configuration management for static analysis tools and enforcing value constraints during program state tracking.",
      "description_length": 527,
      "index": 1943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling file paths within a project, supporting operations like equality checks, comparison, hashing, and pretty printing. It provides a structured way to manage and manipulate file path data, including deep copying and project membership testing. Concrete use cases include tracking source file paths in static analysis tools and managing project-specific file references.",
      "description_length": 409,
      "index": 1944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a string set data structure with standard operations including membership testing, comparison, hashing, and pretty-printing. It supports efficient set manipulation and is used to represent collections of unique strings in a way that is compatible with Frama-C's internal type system. Concrete use cases include tracking sets of variable names, function identifiers, or other string-based entities during static analysis.",
      "description_length": 440,
      "index": 1945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Zero.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives for type inspection and manipulation. It is used to model and manage analysis-specific data types with deep copying, project membership checks, and user-friendly output formatting.",
      "description_length": 449,
      "index": 1946,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a structured datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C kernel plugins. It supports deep copying, membership testing within projects, and maintains a list of representative values alongside a packed descriptor. Concrete use cases include managing abstract syntax tree nodes, analysis results, or plugin-specific data that must integrate with Frama-C's project system and type machinery.",
      "description_length": 472,
      "index": 1947,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a map-based collection, supporting operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Category.t`, which wraps a parameter category over `elt`, and allows associating accessors and dependencies with categories. Use cases include setting up configurable behavior for analysis modules, enabling global category overrides, and defining default or special-case handling for parameterized elements.",
      "description_length": 496,
      "index": 1948,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Api_generator.Self.String_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a string set, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with the `Category.t` type, which wraps a parameter category from the Frama-C kernel, and supports adding new categories with dependencies and accessors. Concrete use cases include configuring analysis parameters with specific enable/disable behavior and setting global defaults or aliases for category handling.",
      "description_length": 481,
      "index": 1949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in a map structure that disallows multibindings. It includes functionality for checking membership based on project properties and supports deep copying of values. Concrete use cases include managing unique, structured values in analysis contexts where precise identity and ordering are required.",
      "description_length": 416,
      "index": 1950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a kernel function set, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with the `t` type, which represents a category, and supports associating categories with accessors and state dependencies. Concrete use cases include setting up parameter categories for plugin options and controlling default and global behavior in Frama-C kernel extensions.",
      "description_length": 455,
      "index": 1951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Empty_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling empty strings within a plugin's type system. It implements standard operations like equality, comparison, hashing, and pretty-printing, tailored for values representing empty string literals. The type is used to model and manipulate string constants that are guaranteed to be empty, enabling precise static analysis in Frama-C plugins.",
      "description_length": 379,
      "index": 1952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing string command-line options with state tracking, including value setting/retrieval, change hooks, alias resolution, and serialization. It works with string parameters that enforce allowed values and validate inputs against function name rules or predefined lists. Designed for configuration management in static analysis tools, it supports use cases like dynamic option updates, input validation, and project-specific state synchronization.",
      "description_length": 485,
      "index": 1953,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values within a file path mapping context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. The type supports structural operations required for integration with Frama-C's kernel libraries, particularly for handling projects and datatype descriptors.",
      "description_length": 426,
      "index": 1954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to control behavior. Use cases include configuring parameter visibility and enabling/disabling groups of parameters based on analysis needs.",
      "description_length": 407,
      "index": 1955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Action",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage boolean options with capabilities for setting, retrieving, and toggling values, along with handling default states, update hooks, and serialization. It supports command-line interaction through named options, aliases, and help messages, while integrating with project-wide state management systems. The core data structure is a shared boolean state, designed for use in dynamic configuration scenarios, kernel state synchronization, and application settings with declarative CLI interfaces.",
      "description_length": 532,
      "index": 1956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Enum",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing enumerated types with set/get functionality, value change hooks, command-line interface handling, and project state integration. It works with a fixed variant type supporting structural equality, along with serialization, aliases, and Frama-C's typed parameter system for handling enumerated values in analysis plugins. The design facilitates parameter configuration and state management in Frama-C's analysis workflows.",
      "description_length": 465,
      "index": 1957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_site_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a `Site_dir` by cloning an existing one, using a parent directory and a new directory name. It provides `get_dir` and `get_file` to retrieve subdirectories and files by name, ensuring they exist and are of the correct type. It is useful for managing hierarchical site structures with strict path validation.",
      "description_length": 330,
      "index": 1958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing mutable string lists as configurable options, supporting actions like element addition, iteration, folding, and validation, along with hooks for update notifications and command-line integration. It works with string lists as core data structures, incorporating aliases, default values, and categorized parameter groups to organize configurations within Frama-C's plugin system. The functionality is particularly used for analysis tools requiring project-specific state management, serialization, and dynamic configuration updates during command-line-driven workflows.",
      "description_length": 613,
      "index": 1959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Cache_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Use cases include storing temporary analysis results or persistent plugin data in a structured manner.",
      "description_length": 367,
      "index": 1960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set",
      "library": "frama-c-api-generator.core",
      "description": "This module manages sets of function declarations with operations for membership testing, iteration, and aggregation, while integrating configuration handling through string-based parameters and categorized options. It supports tracking function definitions across analyses, validating plugin state, and persisting data via serialization hooks compatible with Frama-C's project system. Typical applications include implementing custom static analyses that require precise function scope tracking or developing configurable plugins with validated command-line parameters.",
      "description_length": 570,
      "index": 1961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list",
      "library": "frama-c-api-generator.core",
      "description": "This module provides list-centric operations with dynamic value management, including change tracking, default value handling, and project state integration. It works with lists of elements (`E.t list`), string-based parameters, and category hierarchies to support use cases like Frama-C plugin analysis configurations, persistent state management, and aliased collection manipulation with validation. Key features include marshaling for persistence, iterative transformations, and category-based organization of options.",
      "description_length": 521,
      "index": 1962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Session",
      "library": "frama-c-api-generator.core",
      "description": "This module manages file paths within a session directory for a plugin, providing operations to retrieve or create directories and files. It works with string identifiers and handles paths using the `Frama_c_kernel.Filepath.t` type. Concrete use cases include setting and accessing session-specific directories and files during plugin execution.",
      "description_length": 345,
      "index": 1963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Float",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage floating-point parameters with optional decimal precision, including setting value ranges, registering update callbacks, and handling command-line interactions. It works with `float` values encapsulated in a `Datatype.t` structure for state management and serialization. Use cases include configuring numerical settings in Frama-C plugins, persisting parameter states across sessions, and enforcing value constraints in static analysis tools.",
      "description_length": 484,
      "index": 1964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set",
      "library": "frama-c-api-generator.core",
      "description": "This module supports creation, modification, and querying of string sets through operations like element addition, membership checks, and iterative processing. It operates on abstract string sets and structured parameter configurations, enabling use cases such as command-line option parsing, project-specific state synchronization, and plugin configuration management in Frama-C. Serialization, alias resolution, and update hooks further facilitate integration with plugin systems and persistent data handling.",
      "description_length": 511,
      "index": 1965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing mappings between kernel functions and lists of values, along with key-value collections that support aliases, category-based grouping, and customizable marshaling. It works with data structures such as `Frama_c_kernel.Cil_datatype.Kf.Map.t` for kernel function associations, and modules for string-based parameter handling and category management. These features are used to configure static analysis settings, bind functions with dynamic behaviors, and maintain state persistence across projects through hooks and project integration.",
      "description_length": 580,
      "index": 1966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Value_string",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a string-based data type with standard operations including equality, comparison, hashing, and pretty printing. It supports conversions to and from regular strings, deep copying, and membership testing over project skeletons. The type is integrated with the Frama-C kernel for use in analysis plugins requiring string values with rich semantic operations.",
      "description_length": 378,
      "index": 1967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing file path values with support for dynamic updates, change tracking, and custom serialization. It works with a type `t` (aliased from `Frama_c_kernel.Filepath.t`) to handle stateful file path configurations, including checks for empty paths and integration with command-line interfaces. Specific use cases include persistent state management in analysis tools and synchronization of file path settings across different components of a project.",
      "description_length": 487,
      "index": 1968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a string-indexed map of value lists with operations for setting, retrieving, and clearing entries, along with change tracking and category management. It works with data structures that associate string keys to lists of values, supporting marshaling, equality checks, and aliases, while integrating with Frama-C's plugin system for context-aware state updates. It is used in plugin development for handling configurable options, validating parameters, and maintaining project-specific settings with dynamic default values and help documentation.",
      "description_length": 565,
      "index": 1969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Verbose",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a configurable integer value representing verbosity levels, supporting operations to adjust its range, increment it, and track changes via hooks. It works with internal state to enforce bounds, serialize values, and compare equality, while integrating command-line parsing and help generation. The design targets static analysis tools needing runtime verbosity control, project-specific configuration persistence, and dynamic state updates during analysis workflows.",
      "description_length": 486,
      "index": 1970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Config_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages the creation, retrieval, and configuration of plugin-specific directories and files within a Frama-C environment. It operates directly on file paths using the `Frama_c_kernel.Filepath` type, allowing controlled access to a user directory without automatically creating it. Concrete use cases include setting up persistent storage for plugin data, safely retrieving configuration files, and ensuring directory existence before file operations.",
      "description_length": 462,
      "index": 1971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Custom",
      "library": "frama-c-api-generator.core",
      "description": "This module enables stateful management of custom types with support for value observation, serialization, and project-specific state tracking, operating on a wrapped type `t` derived from `V.t`. It facilitates defining command-line interfaces with constrained parameters through alias configuration, value validation, and metadata attachment using `Typed_parameter.t`. Use cases include extending analysis frameworks with user-defined stateful options and creating type-safe CLI tools with dynamic parameter constraints.",
      "description_length": 521,
      "index": 1972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing configurable string sets with support for dynamic updates, persistent state tracking, and category-based organization. It works with `Frama_c_kernel.Datatype.String.Set.t` for set manipulations and category types to group related parameters, enabling use cases like handling validated command-line arguments, maintaining project-specific configuration state, and orchestrating global parameter aliases with custom serialization. Key capabilities include membership checks, iterative transformations, default value management, and integrating with runtime hooks for reactive updates.",
      "description_length": 627,
      "index": 1973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.WithOutput",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing boolean-valued configuration options with state tracking and dependency-driven output control. It works with a typed parameter (`t`) for option state, a `Datatype` module for structured data manipulation and persistence, and `State.t` dependencies to govern output behavior. These features enable use cases like command-line interface configuration with dynamic defaults and plugin output systems that react to state changes efficiently.",
      "description_length": 482,
      "index": 1974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing stateful string-indexed maps with support for value mutation tracking, pre/post-update hooks, and default value handling. It operates on map structures of type `V.t` where keys are strings, enabling use cases like static analysis tool configuration with project-scoped state management, command-line parameter validation, and dynamic updates through submodules for string value abstraction and category-based parameter grouping.",
      "description_length": 473,
      "index": 1975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.OUT.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing. It includes descriptors for structural representation, a packed version of the descriptor, and functions for checking membership of project values and performing deep copies. It is used to represent and manipulate structured data types within the Frama-C kernel, particularly for handling type information and project-specific values in static analysis plugins.",
      "description_length": 469,
      "index": 1976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.State_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a specific state directory for a plugin, providing direct access to directories and files within it. It supports operations to retrieve or create paths, set and query the current state directory, and check if a directory has been initialized. Concrete use cases include persisting plugin-specific data, managing configuration files, or handling temporary storage during analysis.",
      "description_length": 399,
      "index": 1977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set",
      "library": "frama-c-api-generator.core",
      "description": "The module supports operations for manipulating, querying, and serializing sets of kernel functions (`Frama_c_kernel.Cil_datatype.Kf.Set.t`), including membership checks, iteration, and alias management. It integrates with Frama-C's project model for state management and command-line option handling, featuring validation modules for string parameters and categorical organization of functions. This enables use cases like managing analysis contexts, enforcing parameter rules, and handling dynamic state changes in kernel plugins.",
      "description_length": 532,
      "index": 1978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Bool",
      "library": "frama-c-api-generator.core",
      "description": "The module provides operations to manage boolean parameters with capabilities to set values (`on`/`off`), retrieve their state, and track modifications through hooks, supporting dynamic configuration during static analysis or program transformations. It works with boolean values encapsulated in typed parameters, offering features like default initialization, aliasing, and serialization for integration with state management systems. This enables use cases such as configuring analysis plugins, enforcing transformation rules, or monitoring flag changes in formal verification workflows.",
      "description_length": 589,
      "index": 1979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages file path mappings where each path is associated with a value of type `V.t`, supporting operations to set, retrieve, and track modifications with pre- and post-update hooks. It organizes key-value pairs into project-specific states, enabling custom serialization, comparison, and categorization into configurable groups. This functionality is utilized in static analysis tools to maintain file-specific data with contextual constraints and structured parameter handling.",
      "description_length": 490,
      "index": 1980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing stateful single-binding map parameters with change notifications, default value handling, and custom marshaling, supporting element manipulation (add, find, mem, iter, fold) alongside metadata management. It operates on key-value pairs where keys and values are defined by distinct modules (K and V), enhanced with string serialization and categorized configuration metadata through auxiliary modules. These capabilities enable use cases such as project-specific computed state tracking, command-line configuration interfaces, and structured key-value associations requiring controlled mutability and cross-component state synchronization.",
      "description_length": 684,
      "index": 1981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.TSC.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use with Frama-C's kernel structures. It includes descriptors and representants for structural manipulation, supporting precise type handling in API generation. Use cases include managing and comparing complex data structures in static analysis tools and ensuring deep copying for safe data transformation.",
      "description_length": 427,
      "index": 1982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_list",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for handling lists of file paths (`Frama_c_kernel.Filepath.t`) through both configurable options and mutable data structures, enabling dynamic updates via hooks and serialization. It supports command-line interface interactions with features like option aliases, validation, category grouping, and visibility control, while integrating with project state management. Use cases include parsing and validating file path inputs from CLI arguments, organizing paths into logical categories, and maintaining synchronized state across tool sessions.",
      "description_length": 575,
      "index": 1983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_user_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a `User_dir` by cloning an existing directory structure. It provides `get_dir` and `get_file` functions to access or create subdirectories and files within the new directory, using paths derived from the parent. It operates directly on `Frama_c_kernel.Filepath.t` values, ensuring correct path resolution and directory creation when needed. Use this when replicating directory layouts for user-specific data storage or configuration management.",
      "description_length": 467,
      "index": 1984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Zero",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing stateful integer options with change tracking, serialization, and project-specific state synchronization, as well as configurable integer parameters with enforced range constraints. It operates on optional integer values and bounded integer types, supporting command-line interface integration, marshaling for static analysis plugins, and dynamic value validation. These capabilities are particularly useful in static analysis tools requiring persistent state management, user-configurable parameters, and cross-component data consistency.",
      "description_length": 584,
      "index": 1985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String",
      "library": "frama-c-api-generator.core",
      "description": "This module provides utilities for configuring and validating string-based plugin parameters, supporting operations like value assignment, change tracking via hooks, and command-line interface integration with aliases and help documentation. It works with string values and global parameters, enabling use cases such as enforcing allowed input values, validating function names, and persisting configuration state across projects. The functionality is particularly suited for managing dynamic settings in static analysis tools where default values, user input validation, and project-specific overrides are required.",
      "description_length": 616,
      "index": 1986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Value_int",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a value type for integers with operations for comparison, hashing, serialization, and pretty printing. It supports integer values with standard equality, ordering, and hash functions, along with project membership checks and deep copying. It is used to represent and manipulate integer values in a way that integrates with the broader framework for project analysis and data representation.",
      "description_length": 410,
      "index": 1987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a multi-binding map that associates keys of type `K.t` with lists of values (`V.t`), supporting operations like setting entries, tracking modifications via hooks, and resolving aliased keys. It enables static analysis plugins to maintain precise state tracking with project-aware persistence, while also handling configuration tasks through CLI parameter parsing, category grouping, and customizable serialization of complex data. Use cases include Frama-C plugin development for scalable data management, validated configuration storage, and cross-project state synchronization with alias-aware key resolution.",
      "description_length": 631,
      "index": 1988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Empty_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing mutable string options with support for value serialization, update hooks, and command-line integration, primarily working with string types and lists. It enables configuration of validated string parameters through `Typed_parameter.t` structures, allowing restriction to predefined values and association with kernel extension functions. These capabilities are specifically used in static analysis plugins to handle customizable settings, enforce parameter constraints, and bridge user-facing interfaces with Frama-C's internal state management.",
      "description_length": 591,
      "index": 1989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing sets with change tracking, default values, and project state integration, alongside configuration parameter handling for string-based settings and categorized options. It works with structured types built from `E.Set.t`, string data for configuration, and parameter definitions supporting visibility and deprecation flags. These features are designed for static analysis frameworks like Frama-C plugins, enabling tasks such as command-line option parsing, alias management, and analysis configuration with state synchronization.",
      "description_length": 573,
      "index": 1990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Share",
      "library": "frama-c-api-generator.core",
      "description": "This module manages paths within a plugin's share directory, providing functions to set and retrieve a base directory, check its existence, and locate specific files or subdirectories within it. It operates on `Frama_c_kernel.Filepath.t` values, ensuring correct resolution of paths for resources stored in the plugin's site directory. Concrete use cases include accessing plugin-specific configuration files or shared data stored in a predefined directory structure.",
      "description_length": 467,
      "index": 1991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a map associating kernel functions with customizable values, supporting operations for insertion, lookup, iteration, and aggregation while handling aliases and categories. It enables configuration and serialization workflows through string-based parameters and marshaling customization, with hooks for tracking dynamic updates to the map's state.",
      "description_length": 366,
      "index": 1992,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Int",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations for managing configurable integer parameters with state tracking, including setting and retrieving values, defining valid ranges, incrementing values, and registering hooks for change notifications. It works with global integer states and structured data types that support serialization, command-line interface integration, and project-specific configuration. These features are particularly useful in plugin development scenarios where parameters require controlled modification, validation, and persistent state management across sessions.",
      "description_length": 574,
      "index": 1993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_user_dir_opt",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a `User_dir_opt` from an existing `User_dir`, using a parent directory and a named directory with optional environment variable integration. It provides operations to retrieve and set file paths, check if a path exists, and access files or directories with optional creation. Concrete use cases include managing user-specific directories and files in a structured way, such as handling configuration or output paths in analysis tools.",
      "description_length": 457,
      "index": 1994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.False",
      "library": "frama-c-api-generator.core",
      "description": "This module offers operations for managing boolean state with associated actions, including value setting/getting, hook registration for state changes, command-line alias handling, and project-specific state serialization. It operates on a boolean type `t` and a structured `Datatype` module, following patterns for plugin development and option parsing in Frama-C. Use cases include implementing user-configurable flags with side effects and handling stateful boolean parameters in analysis tools.",
      "description_length": 498,
      "index": 1995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.True",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage boolean configuration options with state tracking, including setting values via `on`/`off`, registering hooks, handling serialization, and defining aliases or help messages. It operates on a `bool` type augmented with project-specific state management through its `Datatype` submodule. These features are used to configure and query plugin behavior within Frama-C's kernel, enabling integration with the system's parameter handling and user interaction workflows.",
      "description_length": 505,
      "index": 1996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self",
      "library": "frama-c-api-generator.core",
      "description": "This module supports diagnostic logging with configurable severity levels, warning category management, and stateful parameter handling for static analysis tools. It operates on structured data including logging categories, file paths, typed parameters (integers, strings, enums), and session state, with patterns for CLI integration and runtime configuration. Specific use cases include suppressing diagnostic messages during analysis, validating plugin parameters via command-line flags, and synchronizing analysis settings across distributed sessions.",
      "description_length": 554,
      "index": 1997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.TSC",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage boolean parameters in a static analysis context, including setting, retrieving, and observing state changes through hooks, with support for command-line interface features like help generation and alias handling. It works with a registered state type that encapsulates typed parameters and implicit boolean values, enabling serialization, equality comparisons, and project-specific state tracking. These capabilities are used to configure analysis tools, track computed states, and implement feature toggles via direct `on`/`off` controls.",
      "description_length": 581,
      "index": 1998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.OUT",
      "library": "frama-c-api-generator.core",
      "description": "This module provides operations to manage configurable file path options, including value setting/retrieval, update hook registration, command-line alias handling, and state persistence. It works with `Frama_c_kernel.Filepath.t` for path manipulation and includes a unit-to-boolean check for empty paths, supporting type-safe data handling via the `Datatype` module. These features enable use cases like project-specific state tracking, CLI integration, and serialized configuration management.",
      "description_length": 494,
      "index": 1999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiTactic",
      "library": "frama-c-wp.gui",
      "description": "This module defines types for callbacks used in GUI-driven tactic automation. It includes `auto_callback` for handling heuristic-based strategy generation with parameters like depth and width, and `callback` for selecting a specific proof strategy. These types support interactive tactic selection and automated strategy exploration in user interfaces.",
      "description_length": 352,
      "index": 2000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiProver",
      "library": "frama-c-wp.gui",
      "description": "This module defines status icons for visual feedback in a GUI, including no status, success, failure, waiting, and smoke test states. It also includes a filter function to select specific provers based on their status. These elements are used to display and manage prover outcomes within a graphical interface.",
      "description_length": 310,
      "index": 2001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiSource",
      "library": "frama-c-wp.gui",
      "description": "This module manages source code selections in a GUI, supporting three selection types: no selection, function, property, and call. It provides operations to create, inspect, and manipulate these selections, enabling context-specific actions in the interface. Concrete use cases include highlighting selected functions, displaying associated properties, or navigating to call sites in the source code.",
      "description_length": 400,
      "index": 2002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiPanel",
      "library": "frama-c-wp.gui",
      "description": "This module manages dynamic updates and event handling for a graphical interface panel. It provides functions to trigger and subscribe to update and reload events, as well as to register the panel with a main window and run proof operations with selected provers. It works with GUI extension points, prover configurations, and source selections to support interactive verification tasks.",
      "description_length": 387,
      "index": 2003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiNavigator",
      "library": "frama-c-wp.gui",
      "description": "Creates a navigator interface within the Frama-C GUI, allowing users to interact with and traverse the program's control flow graph. It integrates directly with the main window's extension points to display navigation controls specific to the analysis context. This is used when implementing custom exploration tools for static analysis results.",
      "description_length": 345,
      "index": 2004,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp_gui",
      "library": "frama-c-wp.gui",
      "description": "This module provides components for building and managing a graphical user interface tailored to program analysis tasks. It includes functions for navigating control flow graphs, managing source code selections, and displaying prover statuses with interactive elements like panels and lists. Concrete use cases involve implementing custom analysis exploration tools, interactive verification interfaces, and context-aware source code navigation.",
      "description_length": 445,
      "index": 2005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Region",
      "library": "frama-c-region.core",
      "description": "This module handles normalization and analysis of hierarchical memory regions in control flow graphs, supporting equivalence queries, parent-child relationships, and type-driven variable associations. It operates on region nodes stored in maps and trees, with operations for inclusion checks (`included`, `separated`), structural decomposition (`field`, `index`, `footprint`), and expression/lvalue tracking derived from C AST elements. Applications include static analysis for memory safety verification, region-based optimizations, and aliasing checks in compiler middle-ends.",
      "description_length": 578,
      "index": 2006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl.Make",
      "library": "frama-c-metrics.core",
      "description": "This module implements a hash table where keys are of type `Data.t` and values are optional. It provides standard operations such as `mem`, `find`, `add`, and `remove`, along with equality, comparison, and hashing functions for the table's contents. It is used to track and manipulate key-value pairs in a mutable state, particularly when handling analysis data in Frama-C plugins.",
      "description_length": 381,
      "index": 2007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl.Key",
      "library": "frama-c-metrics.core",
      "description": "This module defines a key type for a hash table that supports operations such as equality checking, comparison, hashing, and pretty printing. It works with a specific key data structure used in the context of metrics tracking, which includes project membership checks and deep copying. Use cases include managing and querying metric data associated with keys that carry project-specific information.",
      "description_length": 399,
      "index": 2008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map.Make",
      "library": "frama-c-metrics.core",
      "description": "This module implements a map structure where keys are of type `Data.t` and values are optional. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as support for project membership checks and deep copying. The map is used to represent and manipulate sparse collections of values associated with keys from the `Data` module, with the ability to handle absence of values efficiently.",
      "description_length": 432,
      "index": 2009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map.Key",
      "library": "frama-c-metrics.core",
      "description": "This module defines a data type for keys used in a map structure, providing essential operations including equality, comparison, hashing, and pretty-printing. It supports working with lists of key representatives, deep copying of key values, and checking membership based on project data. Concrete use cases include managing and querying distinct key values in metric tracking systems, particularly when integrating with project-specific data and persistence mechanisms.",
      "description_length": 470,
      "index": 2010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl",
      "library": "frama-c-metrics.core",
      "description": "This module implements imperative hash tables with keys of type `Metrics.Metrics_base.OptionKf.t`, supporting standard operations like insertion, deletion, and lookup, as well as advanced features such as in-place filtering, folding over entries, and bulk updates from sequences. It manages key-value pairs with custom equality, comparison, and hashing logic, designed for handling optional or variable metrics configurations. These structures are optimized for use cases like dynamic data aggregation, memoization, and state tracking in Frama-C plugins where precise key semantics and efficient iteration are critical.",
      "description_length": 619,
      "index": 2011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map",
      "library": "frama-c-metrics.core",
      "description": "This module implements ordered key-value maps with optional values, supporting operations like insertion, deletion, merging, and ordered traversal. It works with keys that are comparable and printable, enabling efficient lookups, range queries, and transformations over data structures used for metric aggregation. Typical applications include tracking sparse metrics, managing hierarchical key-value configurations, and processing time-series data with optional or missing values.",
      "description_length": 481,
      "index": 2012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf",
      "library": "frama-c-metrics.core",
      "description": "This module implements a data type for optional kernel function values with support for equality, comparison, hashing, and pretty-printing operations. It works with `Frama_c_kernel.Kernel_function.t option` values, providing deep copy, membership testing within projects, and standard data manipulation functions. Concrete use cases include tracking optional function references in metrics, managing sparse function associations, and enabling precise value comparisons in Frama-C plugin analyses.",
      "description_length": 496,
      "index": 2013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.BasicMetrics",
      "library": "frama-c-metrics.core",
      "description": "Tracks and calculates fundamental code metrics for C functions and files, including counts of statements, loops, conditionals, function calls, and complexity measures. Operates on a record type containing fields like `cslocs` (source lines of code), `ccyclo` (cyclomatic complexity), and `cdecision_points`. Useful for static analysis tools assessing code quality, maintainability, or refactoring needs based on structural metrics.",
      "description_length": 431,
      "index": 2014,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_base",
      "library": "frama-c-metrics.core",
      "description": "Implements data types and operations for handling optional kernel function values and basic code metrics. Works with `Frama_c_kernel.Kernel_function.t option` and metric records containing fields like `cslocs` and `ccyclo`. Used for tracking sparse function references and calculating maintainability metrics in static analysis plugins.",
      "description_length": 336,
      "index": 2015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_cilast",
      "library": "frama-c-metrics.core",
      "description": "This module provides a function `get_metrics_map` that computes a nested map of basic metrics for functions in a C program, indexed by file paths and function keys. It processes the abstract syntax tree of C code to gather metrics such as line count, cyclomatic complexity, and nesting depth. A concrete use case is analyzing source code structure for maintainability or refactoring purposes.",
      "description_length": 392,
      "index": 2016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_coverage",
      "library": "frama-c-metrics.core",
      "description": "Computes syntactic coverage for a given kernel function, returning a set of variable identifiers involved in the coverage analysis. It takes a boolean flag to include libc functions and processes kernel functions to identify relevant variables. This function is used to analyze code coverage in the context of static analysis, specifically for identifying variables that are part of the syntactic structure of the code under analysis.",
      "description_length": 434,
      "index": 2017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics",
      "library": "frama-c-metrics.core",
      "description": "This module provides functions to compute syntactic coverage metrics, handle optional kernel function values, and calculate code metrics from C abstract syntax trees. It works with data types such as variable identifiers, kernel function options, and metric records containing line counts and complexity values. Concrete use cases include static analysis for identifying coverage-relevant variables, tracking sparse function references, and evaluating maintainability through cyclomatic complexity and nesting depth metrics.",
      "description_length": 524,
      "index": 2018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map.Make",
      "library": "Pdg_types",
      "description": "This module implements a map indexed by `NodeSet` keys with values of type `Data.t`, providing standard map operations such as comparison, equality, hashing, and pretty printing. It supports structured data manipulation for PDG analysis, including project membership checks and deep copying to ensure value integrity. Concrete use cases include tracking data dependencies and transformations across program nodes in static analysis.",
      "description_length": 432,
      "index": 2019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map.Key",
      "library": "Pdg_types",
      "description": "This module defines the key type used in maps where keys are node sets from a program dependency graph (PDG). It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate PDG node sets as unique map keys in analysis tools.",
      "description_length": 361,
      "index": 2020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map.Key",
      "library": "Pdg_types",
      "description": "This module defines the key type used in maps keyed by PDG nodes, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with node identifiers that encapsulate project-specific information, enabling precise tracking and manipulation of PDG elements. Use cases include managing node-based mappings in analysis passes and ensuring consistent handling of node keys across different data structures.",
      "description_length": 447,
      "index": 2021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl.Make",
      "library": "Pdg_types",
      "description": "This module creates a hash table implementation for a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that can be stored in a `NodeSet.Hashtbl`, enabling efficient lookups and manipulations. Concrete use cases include managing node-based data structures with unique keys, such as symbol tables or caches in static analysis plugins.",
      "description_length": 410,
      "index": 2022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map.Make",
      "library": "Pdg_types",
      "description": "This module implements a map indexed by PDG nodes, where each node maps to a value of the provided `Data` module type. It supports operations like equality checking, comparison, hashing, pretty-printing, and deep copying, tailored specifically for maps with PDG node keys. It is used to associate structured data with nodes in a program dependency graph for analysis or transformation tasks.",
      "description_length": 391,
      "index": 2023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl.Key",
      "library": "Pdg_types",
      "description": "This module defines a key type for use in a hash table that stores PDG nodes, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that can represent project-specific values, allowing for deep copying and membership checks based on project criteria. Concrete use cases include managing and querying node identifiers in a PDG structure, particularly when integrating with Frama-C's project system for static analysis.",
      "description_length": 473,
      "index": 2024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl.Make",
      "library": "Pdg_types",
      "description": "This module implements a hash table specialized for PDG nodes, where each node's key maps to values of a specified `Data` module type. It provides standard hash table operations\u2014`add`, `find`, `remove`, and iteration\u2014along with equality, comparison, and hashing functions tailored to PDG node data. Use cases include tracking node-specific metadata across PDG analyses and efficiently querying node attributes during inter-procedural analysis.",
      "description_length": 443,
      "index": 2025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl.Key",
      "library": "Pdg_types",
      "description": "This module defines a key type for use in hash tables that store PDG nodes, providing standard operations like equality, comparison, hashing, and pretty printing. It supports efficient key-based lookups and manipulations, specifically tailored for node identifiers within a program dependence graph. The module also includes functions for checking project membership and deep copying keys to ensure proper handling of project-specific data.",
      "description_length": 440,
      "index": 2026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSetLattice.O",
      "library": "Pdg_types",
      "description": "This module provides a functional set-like abstraction for managing collections of PDG nodes with operations like union, intersection, and difference, alongside lattice-specific functionality for element selection and predicate-based membership checks. It works with immutable sets of `Node.t` elements, supporting transformations via higher-order functions and offering utilities for comparison, hashing, and structured data representation. These capabilities are particularly useful in static analysis tasks requiring precise tracking of node relationships, such as dataflow analysis or dependency graph manipulation, where persistent data structures and lattice operations enable efficient fixed-point computations.",
      "description_length": 718,
      "index": 2027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.LocInfo.LOffset",
      "library": "Pdg_types",
      "description": "This module provides lattice-based operations and interval mapping utilities for representing and manipulating offset location data in program dependency graphs. It works with interval-associative maps and a structured type `t` that supports equality, hashing, and lattice joins to model memory offset relationships during static analysis. Key use cases include tracking variable memory layouts, merging offset constraints via lattice operations, and integrating with analysis frameworks through kernel-compatible metadata and caching mechanisms.",
      "description_length": 546,
      "index": 2028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Pdg.Printer",
      "library": "Pdg_types",
      "description": "This module provides functions to print and visualize PDG (Program Dependence Graph) structures, including node and edge attributes, graph layout, and subgraph extraction. It works with PDG graphs composed of nodes and edges defined in the `PdgTypes` module, along with Graphviz dot attributes for rendering. Concrete use cases include generating visual representations of program dependencies for analysis or debugging, and customizing graph output for specific visualization tools.",
      "description_length": 483,
      "index": 2029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map",
      "library": "Pdg_types",
      "description": "This module provides functional transformations, ordered traversal, and associative operations for maps where keys are structured node sets from a program dependency graph (PDG). It supports static analysis tasks like tracking data dependencies and structural relationships by enabling key-based queries, merging, filtering, and range-based iteration over node set associations. The module also includes utilities for converting between maps and sequences, along with pretty-printing and ordered traversal capabilities to facilitate precise analysis of PDG structures.",
      "description_length": 568,
      "index": 2030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Set",
      "library": "Pdg_types",
      "description": "This module offers operations for creating and manipulating ordered sets of PDG nodes using standard set operations and transformations. It works with sets of `Pdg_types.PdgTypes.Node.t` elements, leveraging a total ordering for efficient querying, structural comparisons, and ordered traversal, while supporting conversions to lists or sequences. These capabilities are particularly useful in program analysis tasks requiring precise tracking of data dependencies, control flow relationships, or iterative refinement of node sets during PDG traversal.",
      "description_length": 552,
      "index": 2031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl",
      "library": "Pdg_types",
      "description": "This module supports key-based access, bulk updates from sequences, and ordered iteration over hash tables mapping PDG nodes to arbitrary values. It works with hash tables that use structural equality on PDG nodes as keys, enabling efficient lookups and memoization during graph analysis. Typical use cases include tracking dependencies between nodes, caching computed properties of PDG elements, or aggregating values across program dependence structures.",
      "description_length": 456,
      "index": 2032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.G.E",
      "library": "Pdg_types",
      "description": "This module defines the edge type for a program dependence graph, where each edge connects two nodes representing computations and carries a label describing the dependency. It provides functions to access the source node, destination node, and label of an edge. Concrete use cases include building and analyzing program dependence graphs during static analysis to track data and control dependencies between operations.",
      "description_length": 420,
      "index": 2033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Set",
      "library": "Pdg_types",
      "description": "This module offers operations for manipulating ordered collections of PDG nodes, including union, intersection, difference, element-wise modifications, and conversions to ordered structures like lists and sequences. It supports advanced set transformations such as filtering, mapping, and partitioning, along with utilities for deep copying, proximity-based element queries, and formatted output. These functionalities are designed to facilitate analysis of program dependencies and data flow relationships within a function's PDG.",
      "description_length": 531,
      "index": 2034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl",
      "library": "Pdg_types",
      "description": "This module implements a mutable hash table optimized for mapping PDG node sets to arbitrary values, supporting imperative operations like insertion, deletion, and in-place transformations alongside bulk updates from sequences. It emphasizes deterministic traversal order and memoization capabilities, tailored for static analysis plugins requiring efficient manipulation of node sets in program dependence graphs. The structure integrates with Frama-C's project-aware PDG node keys, enabling use cases like dependency tracking and analysis state management.",
      "description_length": 558,
      "index": 2035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map",
      "library": "Pdg_types",
      "description": "This module provides standard associative map operations\u2014including adding, removing, and updating entries\u2014and advanced utilities like merging and ordered traversal for maps where keys are PDG nodes and values are arbitrary. These capabilities support tasks such as tracking dependencies, performing data flow analysis, and transforming node-associated data in program dependency graphs.",
      "description_length": 386,
      "index": 2036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.G",
      "library": "Pdg_types",
      "description": "This module implements a program dependence graph (PDG) structure, where nodes represent computations and edges represent dependencies between them. It provides operations to create a new graph, add nodes with associated keys, and establish dependency edges with labels and optional location zones. The graph is used during static analysis to model and traverse data and control dependencies between program operations.",
      "description_length": 419,
      "index": 2037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex.FctIndex",
      "library": "Pdg_types",
      "description": "This module maps function elements to associated data, using keys to identify statements, labels, or call sites. It supports operations to add, retrieve, and merge information for both function-level elements and call statements, which are stored with distinct types. It is used to associate PDG nodes with function elements or track dataflow marks in program slices.",
      "description_length": 367,
      "index": 2038,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Pdg",
      "library": "Pdg_types",
      "description": "The module provides functions for constructing, inspecting, and traversing Program Dependence Graphs (PDGs), including operations to handle uncomputable graphs (`top`) and errors for functions without callsites. It works with PDG nodes, edges, dependency metadata, and indexing structures mapping nodes to functions, supporting use cases like static analysis and dependency visualization. Key capabilities include querying data and control dependencies with location context, generating Graphviz `.dot` files, and iterating over graph components in analysis workflows.",
      "description_length": 568,
      "index": 2039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgMarks.F_Fct",
      "library": "Pdg_types",
      "description": "This module implements mark creation, indexing, and propagation for function-level data in a program dependence graph (PDG). It supports operations like `mark_and_propagate` to apply and track marks across function calls using a provided selection strategy, and `create` to initialize a marked PDG structure. It is used to analyze and trace properties such as taint or usage through function call dependencies.",
      "description_length": 410,
      "index": 2040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node",
      "library": "Pdg_types",
      "description": "The module provides operations for equality checking, comparison, hashing, pretty-printing, deep copying, and project membership verification of PDG nodes. It works with PDG nodes (`Node.t`) and includes specialized collection modules like sets, maps, and hash tables for efficient node management. These features support tasks such as data flow analysis, dependency tracking, graph traversal, and debugging in program analysis workflows.",
      "description_length": 438,
      "index": 2041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Dpd",
      "library": "Pdg_types",
      "description": "This module provides dependency labels for graph edges with three distinct kinds (control, address, data) and supports set-like operations (union, intersection, difference) to combine or analyze dependencies. It operates on a sum type with boolean flags for each dependency category, offering membership checks and bitwise manipulation. The design enables efficient tracking of program dependence relationships while allowing human-readable visualization through formatter-based output.",
      "description_length": 486,
      "index": 2042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet",
      "library": "Pdg_types",
      "description": "This module implements a set structure for managing PDG nodes with operations like union, intersection, membership, and element manipulation, alongside utilities for deep copying, hashing, and pretty-printing. It supports static analysis tasks such as data flow tracking and dependency resolution by providing maps and hash tables keyed by node sets, enabling efficient handling of heterogeneous set operations with customizable merging, cache-aware transformations, and conflict resolution. The design optimizes program analysis workflows through functions like folding over intersections, replacing elements based on structural shapes, and clearing internal caches.",
      "description_length": 667,
      "index": 2043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex.Key",
      "library": "Pdg_types",
      "description": "This module provides key values to identify elements of a function, such as parameters, variables, statements, and call sites,",
      "description_length": 126,
      "index": 2044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex",
      "library": "Pdg_types",
      "description": "This module provides keys to identify function elements like parameters, variables, and call sites, and maps these keys to associated data such as PDG nodes or dataflow marks. It supports adding, retrieving, and merging information specific to functions or call statements, which are stored with distinct types. Concrete use cases include tracking relationships between function elements and PDG nodes or managing dataflow annotations in program slices.",
      "description_length": 453,
      "index": 2045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes",
      "library": "Pdg_types",
      "description": "This module defines core data structures and operations for representing and manipulating Program Dependence Graphs (PDGs). It includes labeled dependency edges, nodes with identity and structural properties, and specialized sets for managing node collections. These components enable precise modeling of program dependencies during static analysis, supporting tasks like data flow tracking, graph traversal, and visualization.",
      "description_length": 427,
      "index": 2046,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgMarks",
      "library": "Pdg_types",
      "description": "This module defines data structures and operations for attaching and propagating marks across program dependence graph (PDG) elements. It provides functions to select nodes or memory zones, associate typed marks with them, and propagate these marks through dependencies. It is used to track properties like data flow or taint analysis through function calls and memory interactions in static analysis.",
      "description_length": 401,
      "index": 2047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types",
      "library": "Pdg_types",
      "description": "This module defines the core data structures for Program Dependence Graphs (PDGs), including nodes with identity and structural properties, labeled dependency edges, and specialized sets for node collections. It supports operations for building, traversing, and analyzing PDGs, enabling precise modeling of program dependencies. Concrete use cases include data flow analysis, graph traversal during slicing, and visualization of program structure.",
      "description_length": 447,
      "index": 2048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence.Register",
      "library": "frama-c-occurrence.core",
      "description": "This module tracks and classifies variable occurrences in CIL code, providing functions to retrieve and print lists of variable uses. It works with CIL types such as `varinfo`, `kernel_function`, `kinstr`, and `lval`, associating each variable with its access points and instruction context. Concrete use cases include analyzing variable usage patterns, identifying read/write accesses, and supporting static analysis tools that require precise variable occurrence data.",
      "description_length": 470,
      "index": 2049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence",
      "library": "frama-c-occurrence.core",
      "description": "Tracks and classifies variable occurrences in CIL code, offering functions to retrieve and print variable uses with their access points and instruction context. Works directly with CIL types like `varinfo`, `kernel_function`, `kinstr`, and `lval`. Supports static analysis tasks such as identifying read/write accesses and analyzing variable usage patterns.",
      "description_length": 357,
      "index": 2050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.As_string.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type for representing root elements as strings in a callgraph analysis context. It provides standard operations including equality, comparison, hashing, and pretty printing, along with functions to check project membership and perform deep copies. The type is used to handle command-line parameters specifying analysis roots, enabling precise control over which parts of a program are analyzed.",
      "description_length": 421,
      "index": 2051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.As_string.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type for representing service root options as strings, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with sets of strings as command-line parameters, specifically for the Callgraph plugin. Concrete use cases include managing and comparing service root identifiers in a callgraph analysis context.",
      "description_length": 372,
      "index": 2052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type with standard comparison, hashing, and pretty-printing operations, along with deep copying and project membership checking. It works with a concrete type `t` that represents a collection of service roots, supporting set-like operations through a descriptor and packed representation. It is used to manage and manipulate collections of service roots as part of command-line options in the Callgraph plugin.",
      "description_length": 437,
      "index": 2053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.Category",
      "library": "frama-c-callgraph.core",
      "description": "This module defines and manages categories for a collection of service roots in the Callgraph plugin. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, using names, accessors, and dependency lists. These categories control how service roots are interpreted and activated during command-line processing.",
      "description_length": 357,
      "index": 2054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Verbose.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a concrete data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports structured values with project membership checks and deep copying, suitable for representing and manipulating analysis options in a callgraph plugin. The type is used to store and manage configuration settings that influence the plugin's behavior during static analysis.",
      "description_length": 410,
      "index": 2055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a custom data type with operations for representing and manipulating a collection of values, specifically tailored for command-line parameter handling. It includes standard operations like equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. The type is used to manage representable values within a plugin's option system, ensuring safe and structured data handling.",
      "description_length": 454,
      "index": 2056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating callgraph analysis options. It supports deep copying and membership checks over project skeletons, ensuring structural integrity and value consistency. Concrete use cases include managing and querying analysis configurations within the callgraph plugin.",
      "description_length": 407,
      "index": 2057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.As_string",
      "library": "frama-c-callgraph.core",
      "description": "This module provides functionality for managing and validating string-based command-line parameters representing service root identifiers, including operations to set and retrieve values, handle aliases, register update hooks, and support custom marshaling. It works with plain strings and validated function names, enabling use cases such as configuring service root settings in the Callgraph plugin with tracked changes and persistent state. The module ensures flexibility through customizable validation and serialization while maintaining efficient state management for dynamic configurations.",
      "description_length": 597,
      "index": 2058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Services.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a concrete data type `t` with standard operations including equality, comparison, hashing, and pretty-printing. It provides a descriptor, name, and representants for the type, supporting deep copying and project membership checks. Used to manage and manipulate structured values within the callgraph plugin, particularly for analysis configurations or state representations.",
      "description_length": 394,
      "index": 2059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.Category",
      "library": "frama-c-callgraph.core",
      "description": "This module defines and manages categories for a collection of elements in the Callgraph plugin, such as `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with custom accessors and dependencies, allowing fine-grained control over how elements are interpreted in different contexts. Use cases include configuring root selection behavior through command-line parameters and defining default or global interpretations for category-based settings.",
      "description_length": 490,
      "index": 2060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Filename.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type for representing filenames within the callgraph plugin, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with a concrete type `t` that encapsulates filename values, along with standard OCaml types like `string`, `formatter`, and `int`. Use cases include managing and comparing source file paths during callgraph analysis, ensuring deep copies for project-specific data isolation, and displaying filenames in a user-friendly format during output or debugging.",
      "description_length": 541,
      "index": 2061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Debug.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values within the Callgraph plugin's debugging context. It includes standard functions for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle and inspect structured data values that represent elements of the callgraph during analysis.",
      "description_length": 405,
      "index": 2062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled_leaf.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating uncalled leaf nodes in a callgraph. It supports functionalities such as checking membership within projects, deep copying to avoid shared references, and provides descriptors for integration with Frama-C's kernel structures. Concrete use cases include tracking and analyzing functions that are never called in static code analysis.",
      "description_length": 498,
      "index": 2063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.As_string",
      "library": "frama-c-callgraph.core",
      "description": "This module enables configuration and validation of string-based analysis roots for a static analysis tool, supporting operations to set, retrieve, and validate values against function name constraints or raw string inputs. It works with string collections as command-line parameters, integrating change hooks for dynamic updates and marshaling logic to persist state. Specific use cases include defining entry points for callgraph analysis and enforcing valid root identifiers during project configuration.",
      "description_length": 507,
      "index": 2064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Cg.Subgraph",
      "library": "frama-c-callgraph.core",
      "description": "Extracts a subgraph rooted at the functions specified by `Options.Roots.get ()`, using the full callgraph from `get ()`. It operates on the callgraph data structure `G.t`, which represents functions and their call relationships. This module is used to isolate and analyze specific parts of the callgraph, such as entry points or components of interest.",
      "description_length": 352,
      "index": 2065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.State_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages file paths for a plugin's state directory, providing operations to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, ensuring the existence of required paths when needed. Concrete use cases include storing and accessing plugin-specific state files during analysis sessions.",
      "description_length": 367,
      "index": 2066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Services.Subgraph",
      "library": "frama-c-callgraph.core",
      "description": "Computes the subgraph of services reachable from the roots specified in `Options.Roots.get ()`. It operates on the service graph structure `G.t` defined in the parent module. This function is used to isolate and analyze specific service components within the larger callgraph.",
      "description_length": 276,
      "index": 2067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Verbose",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a configurable integer parameter for verbosity levels, supporting operations to set, retrieve, and increment values within a bounded range while enforcing constraints. It handles project-specific state, default values, and marshaling, allowing dynamic adjustment through hooks and aliases. Use cases include fine-grained control of logging output and persisting configuration across sessions.",
      "description_length": 412,
      "index": 2068,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Cache_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages file paths for a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, ensuring safe access to cache resources. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 383,
      "index": 2069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Service_roots",
      "library": "frama-c-callgraph.core",
      "description": "This module manages command-line configurations for tracking service roots as sets of function kernels, supporting operations like addition, iteration, and membership checks over `kernel_function` collections. It integrates with string-based parameters and categorized groups, enabling dynamic updates and serialization for persistent state management. Use cases include configuring analysis scopes in static code analysis tools and maintaining project-specific callgraph contexts during command-line execution.",
      "description_length": 511,
      "index": 2070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Session",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the session directory for the Callgraph plugin, providing direct access to files and directories within the session path. It supports operations to retrieve or create session-specific files and directories, and allows setting or checking the session directory path. Concrete use cases include storing intermediate analysis results or configuration files specific to a Frama-C session.",
      "description_length": 404,
      "index": 2071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Config_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the configuration directory for a plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include setting up and accessing plugin-specific configuration files and directories during analysis.",
      "description_length": 360,
      "index": 2072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Services",
      "library": "frama-c-callgraph.core",
      "description": "This module provides operations for managing boolean options with support for state manipulation, change observation, and serialization. It works with a custom boolean type `t` that integrates with Frama-C's parameter system for command-line configuration and project-specific state management. The functionality is used to control features like service toggles in the callgraph plugin, enabling dynamic configuration during analysis.",
      "description_length": 434,
      "index": 2073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled_leaf",
      "library": "frama-c-callgraph.core",
      "description": "This module provides state manipulation operations for a boolean setting that governs analysis behavior related to uncalled leaf nodes in call graphs. It operates on boolean values and custom analysis state types, enabling feature toggling (activation/deactivation) and tracking state changes through hooks. The functionality is specifically used to control whether uncalled leaf node analysis is performed during call graph processing in the Frama-C kernel environment.",
      "description_length": 470,
      "index": 2074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots",
      "library": "frama-c-callgraph.core",
      "description": "This module provides operations for managing command-line options representing sets of function keys (Frama_c_kernel.Cil_datatype.Kf.Set.t) and supports modifying, querying, and tracking analysis roots through iteration, membership checks, and predicate evaluation. It integrates string-based configuration and category management for kernel function collections, enabling use cases like static analysis workflows where roots are dynamically updated, project lifecycles are tracked, and command-line parameters are processed.",
      "description_length": 525,
      "index": 2075,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Filename",
      "library": "frama-c-callgraph.core",
      "description": "This module manages filename-based options with capabilities like setting, retrieving, and serializing values, along with tracking state changes through hooks and aliases. It operates on file paths represented by `Frama_c_kernel.Filepath.t`, abstracted via a `t` type that supports comparison, emptiness checks, and pretty-printing. These features are particularly useful in scenarios like validating input files or mapping dependencies during callgraph construction.",
      "description_length": 467,
      "index": 2076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Share",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the plugin's shared directory configuration by setting, retrieving, and validating directory and file paths within the site. It provides direct access to specific resources through strict existence checks, ensuring correct file or directory types. Concrete use cases include locating plugin-specific assets, configuration files, or compiled artifacts stored in the shared directory.",
      "description_length": 402,
      "index": 2077,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Debug",
      "library": "frama-c-callgraph.core",
      "description": "This module provides configuration management for debugging settings using an integer-based type with dynamic state tracking, supporting operations to set, retrieve, and constrain values within valid ranges. It includes mechanisms for attaching update hooks, defining aliases, and integrating with command-line interfaces, while enforcing value validity through range checks and marshaling customizations. It is suited for scenarios requiring fine-grained control over numeric debugging parameters, such as adjusting log levels or trace verbosity in development tools.",
      "description_length": 568,
      "index": 2078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Uncalled",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a boolean configuration flag that controls the runtime behavior of the Callgraph plugin, offering operations to toggle its state, track changes via hooks, and persist values through serialization. It works with boolean data integrated into Frama-C's state management system, enabling seamless interaction with project-wide configurations. The flag is typically used to enable or disable specific analysis features dynamically, with alias handling and comparison support ensuring consistency across different plugin components.",
      "description_length": 546,
      "index": 2079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Uses",
      "library": "frama-c-callgraph.core",
      "description": "This module provides functions to traverse and analyze the callgraph structure, specifically iterating over functions in caller-to-callee or callee-to-caller order, and exploring the direct and indirect callers or callees of a given function. It operates on the `Frama_c_kernel.Kernel_function.t` type, representing functions in the analyzed program. These operations are useful for tasks like dependency analysis, impact assessment of function changes, or propagating information through the call hierarchy.",
      "description_length": 508,
      "index": 2080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Services",
      "library": "frama-c-callgraph.core",
      "description": "Builds and manages a graph representation of services based on the callgraph, using a custom graph structure `G.t`. It computes the full graph, extracts subgraphs based on root services, and supports dumping the result to a file. Key operations include graph computation, traversal, and visualization attribute handling.",
      "description_length": 320,
      "index": 2081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options",
      "library": "frama-c-callgraph.core",
      "description": "This module provides configuration and diagnostic utilities for analysis tools, focusing on logging control, warning management, and runtime behavior customization. It operates on categorized messages, severity levels, file paths, and plugin-specific state to enable use cases like conditional output based on terminal capabilities, deprecation notice handling, and analysis behavior tuning via command-line flags or shared session data. Key patterns include dynamic state tracking for verbosity/debug settings and integration with framework-level logging and error continuation mechanisms.",
      "description_length": 590,
      "index": 2082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Cg",
      "library": "frama-c-callgraph.core",
      "description": "Manages the construction and manipulation of a callgraph representation, providing functions to compute the graph, retrieve it, and extract subgraphs rooted at specific functions. Operates on the `G.t` data structure, which encodes functions and their call relationships. Used to analyze program structure by isolating entry points or components of interest and exporting them to files.",
      "description_length": 386,
      "index": 2083,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph",
      "library": "frama-c-callgraph.core",
      "description": "The module constructs and analyzes callgraphs using the `G.t` graph structure, enabling operations like subgraph extraction, traversal, and visualization. It works with function call relationships and supports use cases such as dependency analysis, impact assessment, and exporting call hierarchies to files. Key functions include graph building, root-based traversal, and integration with logging and configuration controls for analysis tuning.",
      "description_length": 445,
      "index": 2084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling collections of string parameters associated with kernel functions, supporting operations like equality, comparison, hashing, and pretty printing. It works with strings and project-specific data through functions like `mem_project` and `copy`, ensuring deep copies and proper project membership checks. Concrete use cases include managing and manipulating string-based configuration or annotation data tied to C functions in Frama-C plugins.",
      "description_length": 485,
      "index": 2085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are statements (`Stmt.t`) and values are of a user-specified `Data` module. It provides standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing capabilities. It is used to associate statement-indexed metadata with custom data types, such as tracking analysis results or annotations per statement in CIL-based plugins.",
      "description_length": 425,
      "index": 2086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table structure specialized for a given `Data` module, enabling efficient storage and retrieval of values with operations including equality checks, comparison, hashing, and pretty printing. It supports deep copying, project membership testing, and provides type descriptors for integration with Frama-C's internal systems. Concrete use cases include managing versioned control flow graph nodes or tracking analyzed states in abstract interpretation where unique identifiers and efficient lookups are critical.",
      "description_length": 537,
      "index": 2087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of strings as string values, supporting operations like membership testing, comparison, hashing, and pretty-printing. It works with string sets represented as a `t` type and includes functions for checking project membership and performing deep copies. Concrete use cases include managing string-based configurations or tracking sets of identifiers within Frama-C plugins.",
      "description_length": 421,
      "index": 2088,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string lists as string values within a plugin system. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with functions for project membership checks and deep copying. It is used to manage and manipulate string list configurations or parameters in a plugin's state.",
      "description_length": 358,
      "index": 2089,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type equipped with equality, comparison, and hashing operations for efficient storage and retrieval of versioned control flow graph nodes. It supports concrete use cases such as tracking and comparing automaton states during abstract interpretation or analysis passes. The key type is used internally to manage node identities uniquely across different versions of the control flow graph.",
      "description_length": 425,
      "index": 2090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation where keys are statements from CIL and values are of a specified data type. It supports standard operations such as equality checking, comparison, hashing, and pretty printing for these hash tables. Concrete use cases include tracking and managing statement-value associations during static analysis, such as storing and retrieving analysis results for specific C statements.",
      "description_length": 423,
      "index": 2091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are `Varinfo` values and values are of a specified `Data` module type, providing standard map operations like lookup, insertion, and traversal. It supports structured data management tasks such as equality checks, comparison, hashing, and pretty printing, tailored for CIL variable information. It is suitable for tracking variable-specific metadata across different analysis contexts in static analysis plugins.",
      "description_length": 452,
      "index": 2092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling command-line parameters as strings, specifically for file paths. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to define and manage string-based command-line options that represent file paths within the Frama-C kernel.",
      "description_length": 379,
      "index": 2093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for storing and manipulating vertex sets from unrolled control flow graphs with normalized loop structures. It provides standard operations like equality checks, comparison, hashing, and pretty-printing for vertex set values, along with deep copying and project membership testing. It is used to track and analyze reachable states in abstract interpretation workflows involving modified control flow graphs.",
      "description_length": 443,
      "index": 2094,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling string list parameters as a single string, including equality, comparison, hashing, and pretty-printing functions. It works with the `As_string.Datatype.t` type, representing command-line options as strings. Concrete use cases include parsing and managing command-line arguments that accept multiple string values aggregated into a single option.",
      "description_length": 390,
      "index": 2095,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths as strings within a plugin, supporting operations like equality, comparison, hashing, and pretty printing. It works with standard string lists and integrates with project management features through membership checks and deep copying. Concrete use cases include managing and comparing sets of file paths during static analysis plugin execution.",
      "description_length": 408,
      "index": 2096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of function declarations (`Fundec`) represented as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports command-line parameter parsing by providing a structured way to represent and manipulate these sets, including deep copying and membership checks for project-specific values. Concrete use cases include configuring analysis options that require filtering or specifying functions via string-based identifiers.",
      "description_length": 500,
      "index": 2097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling collections of strings as plugin parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of string values, enabling checks on project membership and deep copying of data. Concrete use cases include managing and validating string list configurations in Frama-C plugins, such as command-line options or stored analysis settings.",
      "description_length": 434,
      "index": 2098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed on vertices of an interpreted automaton with unrolled unnatural loops, where each binding associates a vertex with a value of a specified data type. It provides standard map operations\u2014lookup, insertion, iteration, and equality checks\u2014along with serialization, pretty-printing, and project membership checks. It is used to track and manipulate per-vertex data during abstract interpretation or analysis passes over control flow graphs.",
      "description_length": 470,
      "index": 2099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table that maps vertices in an unrolled control flow graph to associated values. It supports operations for equality checking, comparison, hashing, and pretty-printing keys, as well as deep copying and checking membership based on project-specific criteria. It is used to efficiently manage and query vertex-related data during abstract interpretation of programs.",
      "description_length": 420,
      "index": 2100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-based parameter type with standard operations including equality, comparison, hashing, and pretty printing. It supports storage and manipulation of string values within Frama-C's plugin system, enabling deep copies and membership checks for project-specific data. Concrete use cases include managing string configuration options and tracking string identifiers across different analysis phases in a plugin.",
      "description_length": 438,
      "index": 2101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map parameter type for command-line options, supporting operations like equality, comparison, hashing, and pretty printing. It works with string keys and values, providing a structured way to handle collections of string parameters. Concrete use cases include defining and managing configurable string map options in Frama-C plugins, such as setting analysis-specific string mappings via the command line.",
      "description_length": 437,
      "index": 2102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents command line parameters as strings mapped to kernel functions, supporting multiple function entries. It provides operations for equality, comparison, hashing, and pretty printing of these string-function mappings, along with deep copying and project membership checks. It is used to handle command line arguments that refer to functions in the kernel, including support for both defined functions and pure prototypes.",
      "description_length": 440,
      "index": 2103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string values associated with file paths in a plugin, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with file path strings in a structured way, ensuring deep copying and project membership checks. Concrete use cases include managing and comparing file path configurations or settings within a Frama-C plugin.",
      "description_length": 413,
      "index": 2104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling sets of kernel functions represented as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports set manipulations and project membership checks, enabling efficient management of string-identified kernel functions within a plugin. Use cases include tracking and querying registered kernel functions by their string identifiers in static analysis plugins.",
      "description_length": 435,
      "index": 2105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling sets of strings with operations for comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering via `mem_project`. Use cases include managing collections of string identifiers in Frama-C plugins, such as tracking variable names or function signatures across different analysis phases.",
      "description_length": 388,
      "index": 2106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on `Varinfo` from the CIL library, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working directly with variable information as keys in associative data structures, enabling efficient lookups and management of variable-related metadata. Concrete use cases include tracking variable properties across different analysis phases or maintaining per-variable state in static analysis plugins.",
      "description_length": 490,
      "index": 2107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps within an intermediate representation of control flow graphs with modified unnatural loops. It provides operations for equality checks, comparison, hashing, and pretty-printing keys, as well as deep copying and project membership testing. These keys are essential for tracking and manipulating control points and transitions in the modified control flow graphs during abstract interpretation.",
      "description_length": 446,
      "index": 2108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string-based command line parameters with operations for comparison, hashing, pretty printing, and project membership checks. It works with string values and project skeletons to manage parameter state across different analysis contexts. Concrete use cases include defining configurable options for plugins, such as input file paths or analysis modes, with support for deep copying and user-friendly display.",
      "description_length": 452,
      "index": 2109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by version identifiers, where values are of a parameterized `Data` type. It provides standard map operations\u2014lookup, insertion, iteration, and equality checks\u2014along with serialization, pretty-printing, and project membership checks. It is used to manage versioned data in unrolled automata, such as tracking state or transition properties across different program versions.",
      "description_length": 408,
      "index": 2110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hashtbl, including equality, comparison, hashing, and pretty printing. It works with the `Varinfo.Hptset.Hashtbl.key` type, which represents variable information keys tied to project-specific data. Concrete use cases include managing and querying variable metadata in a thread-aware, project-scoped analysis.",
      "description_length": 358,
      "index": 2111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for handling multiple string values as command-line parameters, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string-based data structures that require set-like semantics for managing collections of values. Concrete use cases include parsing and manipulating command-line arguments that accept multiple string inputs, such as include paths or symbol definitions.",
      "description_length": 451,
      "index": 2112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling sets of function declarations (`Fundec_set`) represented as strings, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with Frama-C projects by allowing checks on project membership and deep copying of values. Concrete use cases include managing and comparing sets of function declarations during static analysis or transformation passes in a plugin.",
      "description_length": 452,
      "index": 2113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for values of a given data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type specified by the `Data` parameter, ensuring deep copies and project-aware membership checks. Concrete use cases include managing collections of CIL variables or annotations with efficient lookups and serialization.",
      "description_length": 423,
      "index": 2114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling string-based parameters associated with kernel functions, including equality, comparison, hashing, and pretty-printing. It works with the `t` type representing string values and supports project-specific membership checks and deep copying. Concrete use cases include managing and manipulating string configuration options tied to function declarations in Frama-C plugins.",
      "description_length": 415,
      "index": 2115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string-based parameter type that supports multiple bindings, enabling command-line options to accept and process repeated string values. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include handling multi-value command-line flags like `-include` or `-define`, where each occurrence contributes a distinct string entry to the parameter's map.",
      "description_length": 480,
      "index": 2116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters in a plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings as the primary data structure, along with project-based filtering through `mem_project` and deep copying. Concrete use cases include managing configuration values, command-line arguments, or persistent settings within Frama-C plugins.",
      "description_length": 424,
      "index": 2117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hashtbl used in a CIL statement analysis context, providing standard operations like equality, comparison, hashing, and pretty printing. It works with a key type that represents statements in a CIL-based program analysis framework. Concrete use cases include managing statement-specific data in a hash table, where keys must be compared, hashed, and displayed for analysis plugins.",
      "description_length": 420,
      "index": 2118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify vertices in an unrolled control flow graph with normalized loop structures. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as functions for deep copying and checking membership based on project-specific predicates. The key type is used to manage and manipulate vertex identifiers in abstract interpretation workflows, ensuring correct handling of graph nodes during analysis and transformation passes.",
      "description_length": 518,
      "index": 2119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling sets of strings as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as managing lists of filenames, identifiers, or configuration keys passed via the command line. The module ensures deep copying and project membership checks for analysis-specific data.",
      "description_length": 389,
      "index": 2120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling sets of strings as plugin parameters, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string-based data structures that require representation, comparison, and project membership checks. Concrete use cases include managing string sets in Frama-C plugins for static analysis configurations or result tracking.",
      "description_length": 405,
      "index": 2121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string-based data type for command line parameters, supporting operations like equality, comparison, hashing, and pretty printing. It works with string values represented as `As_string.Datatype.t` and includes utilities for project membership checks and deep copying. Concrete use cases include parsing and managing string options in Frama-C plugins, such as handling file paths or identifier lists via command line arguments.",
      "description_length": 448,
      "index": 2122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are statement handles from CIL, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working directly with `Stmt.Hptset.Map.key` values, which uniquely identify statements in the CIL abstract syntax tree. Use cases include managing per-statement data in analyses or transformations, such as tracking control flow or annotating specific program points.",
      "description_length": 448,
      "index": 2123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths as strings in command-line parameters. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copy and project membership checks. It is used to manage file path inputs in a structured and type-safe way, particularly for Frama-C plugins requiring file path configurations.",
      "description_length": 390,
      "index": 2124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling multiple string values with operations for equality, comparison, hashing, and pretty printing. It supports structured data management through descriptors and provides deep copying and project membership checks. Concrete use cases include managing collections of string parameters in Frama-C plugins, such as command-line options or configuration settings.",
      "description_length": 400,
      "index": 2125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling sets of strings as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports defining and managing string sets with a unique name, descriptor, and representation, suitable for use in Frama-C plugins requiring structured command-line interfaces. Concrete use cases include specifying lists of files, identifiers, or configuration flags that must be parsed, stored, and compared efficiently during analysis.",
      "description_length": 508,
      "index": 2126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string-based parameter type for command-line options that represent key-value maps without multibindings. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to create and manage string parameters that must uniquely associate keys with string values in Frama-C command-line interfaces.",
      "description_length": 409,
      "index": 2127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of strings as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with descriptors and type information, enabling integration with Frama-C's option parsing and project management systems. Use cases include defining configurable string list options in plugins, such as include paths or source file lists.",
      "description_length": 446,
      "index": 2128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string values with standard operations including equality, comparison, hashing, and pretty printing. It supports plugin-specific data management by providing deep copy functionality and project membership checks. Use this module to store and manipulate string-based parameters in Frama-C plugins, particularly when integrating with analysis projects that require value tracking and comparison.",
      "description_length": 437,
      "index": 2129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based representations of kernel functions, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings as keys for function maps, enabling precise tracking and manipulation of function declarations and prototypes. Concrete use cases include managing function-specific parameters and configurations in Frama-C plugins, ensuring accurate string-based identification and processing of kernel functions.",
      "description_length": 499,
      "index": 2130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` for representing kernel functions, equipped with standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying of values, membership testing within projects, and provides a list of representative values for the type. This module is used to implement command-line options that manipulate sets of kernel functions, ensuring consistent handling of their properties and relationships within Frama-C's analysis framework.",
      "description_length": 506,
      "index": 2131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for associating bases with memory maps, where each memory map is parameterized by the `Data` module. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate memory state representations in static analysis plugins for Frama-C.",
      "description_length": 388,
      "index": 2132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of immutable set operations for managing collections of control flow vertices, represented as sorted, balanced tree-based structures. It supports efficient set construction, transformation, and querying\u2014including union, intersection, filtering, and ordered iteration\u2014while maintaining elements in sorted order according to a predefined comparator. These operations are particularly useful for analyzing or manipulating control flow graphs in abstract interpretation tasks, such as tracking reachable states or managing transitions between control points in a program's execution.",
      "description_length": 620,
      "index": 2133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure where keys are based on a set of ordered values from the `Data` module. It provides operations for comparing, hashing, and pretty-printing map instances, along with deep copying and membership checks based on project conditions. Concrete use cases include managing and querying structured data representations in static analysis tools.",
      "description_length": 376,
      "index": 2134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters associated with the `-cpp-extra-args-per-file` option, supporting operations such as equality checks, comparison, hashing, and pretty printing. It works with strings and project skeletons to manage how preprocessor arguments are applied per file. Concrete use cases include storing and comparing per-file C preprocessor configurations and ensuring correct serialization and project membership checks during analysis.",
      "description_length": 485,
      "index": 2135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for a given data type, enabling operations like insertion, lookup, and iteration with strong type guarantees. It works with arbitrary data types through the `Data` parameter, supporting equality, comparison, and hashing consistent with standard OCaml conventions. Concrete use cases include tracking analysis results per function or variable in static analysis plugins, where each entry corresponds to a specific program element.",
      "description_length": 489,
      "index": 2136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.True.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line option parsing. It provides a structured way to handle values with a unique name, type representation, and descriptor, supporting deep copying and membership checks within projects. Use it to implement custom command-line parameters that integrate seamlessly with Frama-C's option system and project management.",
      "description_length": 457,
      "index": 2137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for floating-point values, using a provided data module. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage collections of floating-point data with efficient lookups and structural consistency in static analysis plugins.",
      "description_length": 388,
      "index": 2138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Enum.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered enumeration type with operations for comparison, hashing, pretty-printing, and deep copying. It works with a variant type `t` that represents a fixed set of values, requiring structural equality. Concrete use cases include defining plugin-specific configuration options or analysis modes that need serialization, comparison, and project membership checks.",
      "description_length": 388,
      "index": 2139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line options that accept multiple string values, supporting operations to set, retrieve, validate, and track changes to these values, along with aliases and project-specific state management. It works with string-based parameters stored in a multibinding map structure, allowing duplicates, and includes checks for valid function names or predefined allowed values. Typical use cases include processing command-line arguments that require multiple string inputs, enforcing constraints on acceptable values, and maintaining configuration state across projects.",
      "description_length": 596,
      "index": 2140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for integer keys and a given value type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with any value type provided by the `Data` module, ensuring deep copying and project membership checks. Concrete use cases include managing integer-mapped configurations, tracking analysis states, or storing integer-indexed abstract values in static analysis plugins.",
      "description_length": 459,
      "index": 2141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string set data type with operations for equality, comparison, hashing, and pretty-printing. It supports command-line option handling by providing a structured descriptor and deep copy functionality. Concrete use cases include managing sets of strings as part of Frama-C plugin configurations or analysis parameters.",
      "description_length": 338,
      "index": 2142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for logic information in CIL-based analyses. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. The key type is used to uniquely identify and manipulate logic-related data within Frama-C's analysis framework.",
      "description_length": 396,
      "index": 2143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear.Vector",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and manipulating fixed-size vectors of scalar values in a linear space. It supports concrete operations such as vector initialization to zero, setting and retrieving elements by index, computing the size and norm, and element-wise maximum between vectors. Use cases include implementing linear filters for static analysis, where vector bounds and convergence behavior are critical, such as in numerical abstract domains or invariant computation.",
      "description_length": 494,
      "index": 2144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-based plugin parameters that represent sets of kernel functions, enabling operations like validation against known function names, alias resolution, and serialization. It works with string data structures to enforce allowed values, retrieve arguments as valid identifiers or raw strings, and integrate with Frama-C's plugin system for static analysis tools requiring precise function name handling. Use cases include defining plugin command-line options that accept kernel function names with fallback to verbatim strings or managing dynamic function sets with runtime validation.",
      "description_length": 631,
      "index": 2145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage string-based plugin parameters in Frama-C, enabling value assignment, validation, and retrieval while supporting aliases and customizable marshaling. It operates on string and string list data tied to kernel functions, allowing parameters to accept either function names or plain strings as arguments. Key use cases include configuring plugin behavior, tracking project-specific state, and serializing parameter values for analysis workflows.",
      "description_length": 482,
      "index": 2146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered maps associating CIL statement handles (from `Stmt.Hptset.t`) with arbitrary data, supporting standard operations like insertion, deletion, lookup, and ordered traversal. It includes utilities for functional transformations, filtering, and bulk construction from sequences, with specialized functions for handling list-valued maps and maintaining key order. Such structures are useful in static analysis plugins for tracking statement-level properties, managing control-flow sensitive data, or implementing algorithms requiring ordered key-value associations over CIL code elements.",
      "description_length": 611,
      "index": 2147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores and compares memory zone identifiers with validity information. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checking for project-specific data. Use cases include tracking and managing distinct memory regions in static analysis plugins, ensuring correct handling of memory validity across different program states.",
      "description_length": 474,
      "index": 2148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate logic type information with unique identifiers. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used efficiently in map structures. The keys are specifically designed to manage and manipulate logic type metadata within the CIL framework, supporting tasks like type analysis and transformation.",
      "description_length": 425,
      "index": 2149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps with rational numbers, providing equality, comparison, hashing, and pretty-printing operations. It supports structured values with project membership checks and deep copying, ensuring no shared references. Use cases include managing unique rational keys in maps with precise semantic comparisons and efficient storage.",
      "description_length": 371,
      "index": 2150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are compared using structural equality based on the provided `Data` module. It supports standard operations like `equal`, `compare`, `hash`, and `pretty`, and is suitable for use in contexts requiring stable, structural comparison of hash tables, such as analysis state tracking or value representation in CIL-based plugins. The module is particularly useful when working with complex data structures that must be compared or stored efficiently in a normalized form.",
      "description_length": 519,
      "index": 2151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by CIL expressions, using the structure provided by the `Data` parameter for the values. It supports standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing. Concrete use cases include tracking expression-associated metadata across CIL transformations or maintaining analysis results keyed by expressions in Frama-C plugins.",
      "description_length": 426,
      "index": 2152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by native integers, using the provided `Data` module for value handling. It supports standard map operations like lookup, insertion, and iteration, along with type-specific functionality such as equality checks, comparison, hashing, and pretty printing. It is suitable for managing collections of values that require efficient access by native integer keys, such as symbol tables or indexed data caches.",
      "description_length": 444,
      "index": 2153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure specialized for abstract memory representations, where keys are bases and values are memory slices. It provides operations for equality checking, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate abstract memory states in static analysis, particularly when tracking data flow and memory contents across program points.",
      "description_length": 443,
      "index": 2154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map with keys based on CIL expressions that use structural equality, strict constant comparison, and size-based comparison for `sizeof` expressions. It provides standard map operations such as lookup, insertion, and traversal, along with equality, comparison, and hashing functions. It is used to manage maps where keys are CIL expressions with precise structural identity, suitable for analysis plugins requiring exact expression matching in contexts like value tracking or constraint solving.",
      "description_length": 519,
      "index": 2155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure where keys are based on the `V` value type and values are determined by the `Data` parameter. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with project membership checks and deep copying. It is used to manage abstract memory mappings in static analysis, such as tracking value assignments across program states.",
      "description_length": 400,
      "index": 2156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps with operations for comparison, hashing, and pretty-printing. It works with ordered key types and supports set operations through deep copying, membership testing, and project filtering. Concrete use cases include managing unique keys in map structures and performing efficient key-based lookups and transformations.",
      "description_length": 356,
      "index": 2157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map based on `Term_offset` values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with deep copying, membership testing for project-related values, and type descriptors for integration with Frama-C's internal systems. Concrete use cases include tracking term offsets in CIL-based analyses and managing key-value associations in map structures.",
      "description_length": 453,
      "index": 2158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify terms in CIL (C Intermediate Language) within the Frama-C framework. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate term identifiers in a structured and efficient way during static analysis tasks.",
      "description_length": 410,
      "index": 2159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling lists of strings as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports defining and parsing string list options in Frama-C plugins, enabling use cases such as specifying multiple input files or configuration tags via the command line. The module includes necessary functionality for integration with Frama-C's project system, such as deep copying and project membership checks.",
      "description_length": 487,
      "index": 2160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with deep copying, membership checks for project-related values, and type descriptors for integration with Frama-C's analysis infrastructure. This module is used to handle CIL offset-based data in a type-safe and efficient manner during static analysis.",
      "description_length": 458,
      "index": 2161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a lattice-structured map backed by a hash table, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying and includes functionality to check membership based on project-specific predicates. Concrete use cases include managing and querying symbolic execution states where keys represent abstract memory locations or program variables.",
      "description_length": 431,
      "index": 2162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and controlling command-line options related to kernel functions. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, each influencing how function-related parameters are interpreted and enabled. Use cases include organizing function analysis options and controlling their activation patterns through command-line flags.",
      "description_length": 422,
      "index": 2163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps associating vertices of an interpreted automaton with values. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, as well as functions for deep copying and checking the presence of project-related data. It is used to manage and manipulate vertex-based mappings in the context of abstract interpretation and control flow analysis.",
      "description_length": 440,
      "index": 2164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage and validate string parameters for plugin configuration, supporting value setting/retrieval, alias handling, and marshaling customization. It works with string-based global parameters and validation lists, enabling use cases like command-line argument parsing, project-specific state storage, and ensuring values conform to valid function names or plain string formats. The module integrates with Frama-C's plugin system to enforce parameter constraints and trigger updates via registered hooks.",
      "description_length": 537,
      "index": 2165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that uniquely identifies CIL types while ignoring attributes, supporting efficient equality, comparison, and hashing operations. It provides standard utilities such as `equal`, `compare`, `hash`, and `pretty` for working with these keys directly. Use cases include managing type-based mappings in CIL analyses where structural equivalence (ignoring attributes) is required, such as caching type information or tracking type-specific properties across a program.",
      "description_length": 508,
      "index": 2166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a hash table, specifically for rational numbers. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership checks for project-specific data. These keys are used to uniquely identify and manipulate rational-number-based values within Frama-C's analysis framework.",
      "description_length": 369,
      "index": 2167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL types compared by name without unrolling, and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage type-indexed data in CIL-based analyses, such as tracking type-specific properties or annotations across C program elements.",
      "description_length": 432,
      "index": 2168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a service graph, where each edge connects two vertices and carries a label. It provides operations to create edges, retrieve their source and destination vertices, access their labels, and compare edges. Concrete use cases include modeling function call relationships with labeled transitions in static analysis tools.",
      "description_length": 359,
      "index": 2169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table specific to term l-values in CIL. It provides equality, comparison, hashing, and pretty-printing functions for these keys, which are essential for managing and querying term l-value data in analyses. The module supports deep copying and project membership checks, enabling precise manipulation and traversal of CIL term structures in plugin development.",
      "description_length": 414,
      "index": 2170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure indexed by memory locations (with base and offset in bits) and parameterized by a data type. It supports standard map operations including lookup, insertion, and traversal, along with serialization, comparison, and pretty-printing. It is used to track and manipulate per-location data, such as analysis results or annotations, in a precise and efficient manner.",
      "description_length": 397,
      "index": 2171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for grouping command-line parameters, specifically working with `Category.t` and `elt` types. It allows creating named categories, setting default behaviors, and enabling the special `@all` category with custom interpretations. Use cases include organizing related options under logical groups and controlling global behavior through the `@all` category.",
      "description_length": 397,
      "index": 2172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL label-based hashtables, enabling efficient storage and retrieval of CIL-related data indexed by labels. Concrete use cases include tracking variable annotations or mapping control-flow labels to analysis results in static analysis plugins.",
      "description_length": 436,
      "index": 2173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types and state lists to control plugin behavior through command-line options. Concrete use cases include setting up configurable parameter groups for analysis plugins, enabling or disabling entire sets of parameters via `@all`, and defining default or special-purpose categories like `@none`.",
      "description_length": 497,
      "index": 2174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by CIL statements, where each map instance is built based on the provided `Data` module that defines the value type. It supports standard map operations such as lookup, insertion, and iteration, along with type-specific functionality like equality checks, comparison, hashing, and pretty printing. It is used to associate statement-indexed data in CIL-based analyses, such as attaching annotations or analysis results to specific points in the control flow graph.",
      "description_length": 497,
      "index": 2175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype based on a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that provides defined `equal`, `compare`, and `hash` functions, organizing values into a map structure. Concrete use cases include managing collections of analyzed program elements where key-based access and structural comparison are required.",
      "description_length": 423,
      "index": 2176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a map structure, including equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing map keys, supporting deep copies and membership checks over project skeletons. Concrete use cases include efficient key manipulation in maps used for term indexing and project-specific data tracking.",
      "description_length": 386,
      "index": 2177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables associated with emitters, providing standard operations like equality, comparison, hashing, and pretty printing. It works with emitter-specific data structures, particularly keys that may contain project information. Concrete use cases include managing and comparing emitter keys in a hash table, checking project membership, and ensuring deep copies to avoid shared state.",
      "description_length": 427,
      "index": 2178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables used in the set implementation, providing standard operations like equality, comparison, hashing, and pretty printing. It works with the `Hashtbl.Key.t` type, which represents keys in a hash table structure. Concrete use cases include managing unique identifiers for set elements and enabling efficient lookups, insertions, and deletions in hash-based collections.",
      "description_length": 411,
      "index": 2179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers functionality for configuring and managing string-based command-line parameters, particularly for file paths and function names, with support for validation, default values, and dynamic value updates through hooks. It integrates with Frama-C's project state system to handle serialization and custom option parsing, ensuring safe parameter customization and alias management for command-line interfaces. The module works with string parameters that enforce allowed values or formats, making it suitable for scenarios requiring strict input validation or cross-platform file path handling.",
      "description_length": 607,
      "index": 2180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps used in pretty-printing source code with location-aware AST elements. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate keys that uniquely identify and describe elements needing localization in the AST during pretty-printing.",
      "description_length": 410,
      "index": 2181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype based on an existing value datatype, enabling operations like insertion, lookup, and iteration with proper handling of equality, hashing, and memory management. It works with any data type that provides defined `equal` and `hash` functions, organizing values into a hash table structure. Concrete use cases include efficiently managing sets of analyzed program elements or tracking variable states during static analysis passes.",
      "description_length": 470,
      "index": 2182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a parameter type for command-line options representing maps without multibindings. It supports standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to define and manage structured command-line parameters with unique keys and strict value semantics.",
      "description_length": 363,
      "index": 2183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are of type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage collections of values with efficient lookup and structural operations specific to Frama-C's analysis framework.",
      "description_length": 356,
      "index": 2184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map datatype with operations for equality, comparison, hashing, and pretty-printing. It supports working with values indexed by strings, enabling efficient lookups and manipulations in plugin-specific data structures. It is suitable for managing named analysis results or configuration settings tied to Frama-C projects.",
      "description_length": 352,
      "index": 2185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with localized AST elements by integrating with the `Frama_c_kernel` type and descriptor system, enabling deep copying and project membership checks. Concrete use cases include managing and manipulating structured data during static analysis, such as tracking and printing source code annotations or analysis results.",
      "description_length": 492,
      "index": 2186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on CIL constants with strict comparison, including textual representation when available. It supports standard map operations like lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing. It is used to manage collections of CIL analysis data indexed by constants, such as storing and retrieving expressions or values tied to specific constant keys.",
      "description_length": 434,
      "index": 2187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate memory location zones with specific data. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used in map structures with correct semantics. The keys are used to manage and query memory zones in static analysis contexts, such as tracking base addresses and bit ranges during value analysis.",
      "description_length": 418,
      "index": 2188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table that maps bases to memory slices within an abstract memory model. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. Concrete use cases include managing and querying memory regions in static analysis tools that track value abstractions, such as those built on the Frama-C platform.",
      "description_length": 454,
      "index": 2189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing elements in a kernel function multiple map, using string-named categories and accessors. It provides operations to define, retrieve, and configure special categories like `@none`, `@default`, and `@all`, and control their behavior in parameter parsing and state management. Use cases include customizing plugin command-line options and structuring function analyses by category.",
      "description_length": 437,
      "index": 2190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype based on a given value datatype, providing standard operations like `equal`, `compare`, `hash`, and `pretty` for hash tables of that value type. It supports concrete use cases such as managing collections of analyzed program elements with custom equality and hashing, enabling efficient lookups and comparisons in static analysis plugins. The resulting `t` type is a wrapper around `Data.t Hashtbl.t`, with full support for project membership checks and deep copying.",
      "description_length": 509,
      "index": 2191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.Key.t` type, offering functions to manage key representations, check membership in projects, and perform deep copies. Concrete use cases include managing and manipulating hash table keys in a type-safe manner, ensuring consistent behavior across operations like storage, retrieval, and comparison.",
      "description_length": 463,
      "index": 2192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps associating data with edges in an interpreted automaton. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and project membership checks. It is used to manage and manipulate edge-specific information in abstract interpretation workflows, such as tracking conditions and actions on control flow transitions.",
      "description_length": 413,
      "index": 2193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with any data type provided by the `Data` module parameter, ensuring deep copies and structural comparisons. Concrete use cases include managing collections of CIL-based values with efficient lookups and persistence across analysis phases.",
      "description_length": 414,
      "index": 2194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of the `Data` module, using structural equality and comparison that respects CIL type definitions. It supports operations like equality checking, comparison, hashing, and pretty-printing, along with project-aware membership and deep copying. Concrete use cases include managing collections of CIL types or expressions where structural identity and efficient lookups are required.",
      "description_length": 444,
      "index": 2195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for attribute handling in the CIL (C Intermediate Language) representation. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate attribute keys in a type-safe manner during static analysis of C code.",
      "description_length": 405,
      "index": 2196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given `Data` module, enabling storage and retrieval of values with project-aware equality, comparison, and copying. It supports operations like `mem_project` to check for project membership and `pretty` for formatted output, tailored to the internal state management needs of Frama-C plugins. Concrete use cases include tracking analysis results per project or maintaining stateful mappings in inter-procedural analyses.",
      "description_length": 480,
      "index": 2197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a map structure, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing logic constructor keys, supporting efficient key-based data management. Concrete use cases include managing and comparing keys in maps that store logic constructor information during static analysis.",
      "description_length": 376,
      "index": 2198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for logic types, where keys are based on the provided `Data` module's type. It supports standard hash table operations such as equality, comparison, hashing, and pretty printing, tailored for logic-level CIL types. Use cases include managing and querying collections of logic type values with efficient lookups and maintaining type-specific metadata in static analysis plugins.",
      "description_length": 431,
      "index": 2199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with logic variables, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing logic variable keys, supporting efficient lookups and comparisons. Concrete use cases include managing and manipulating logic variable identifiers during static analysis, ensuring unique key handling in map structures.",
      "description_length": 404,
      "index": 2200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by kernel functions, where each entry holds a value of a specified type. It supports operations like equality, comparison, hashing, and pretty-printing for maps, along with deep copying and project membership checks. It is used to associate structured data with kernel functions, enabling analysis or transformation plugins to track function-specific properties.",
      "description_length": 396,
      "index": 2201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values of type `Lval.Hashtbl.key`. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hashtable structure that holds CIL l-values, ensuring structural integrity and efficient lookups.",
      "description_length": 407,
      "index": 2202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control how plugin parameters are grouped and activated. Concrete use cases include setting up configurable parameter groups for plugins, enabling or disabling entire sets of parameters via the `@all` category, and defining default or special-purpose categories like `@none`.",
      "description_length": 533,
      "index": 2203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are rationals and values are of a specified data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership checks over projects, and type descriptors for integration with Frama-C's internal systems. Concrete use cases include tracking value associations in static analysis plugins, such as mapping program expressions to rational-approximated results.",
      "description_length": 495,
      "index": 2204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.V",
      "library": "frama-c.kernel",
      "description": "This module represents vertices in a service graph, providing operations to create, compare, hash, and retrieve labels for graph nodes. It works with labeled vertices of type `V.t`, where labels are of type `V.label`, and supports efficient equality checks and ordering. Concrete use cases include managing function nodes in a callgraph analysis where each node must be uniquely identified and compared based on its label.",
      "description_length": 422,
      "index": 2205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with the abstract type `Hashtbl.Key.t`, supporting deep copying, membership checks for project-related values, and type representation through descriptors. Concrete use cases include managing and comparing keys in hash tables that store analysis data indexed by keys tied to Frama-C's project structure.",
      "description_length": 450,
      "index": 2206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with `Wide_string` keys and `Data.t` values, providing deep copy and project-aware membership checks. Concrete use cases include managing typed CIL-wide string mappings in static analysis plugins, such as tracking function-specific data across translation units.",
      "description_length": 450,
      "index": 2207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are term-based logical values (lvals) in CIL. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in maps that associate CIL term lvals with other data, ensuring structural integrity and efficient lookups.",
      "description_length": 389,
      "index": 2208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a map structure, including equality, comparison, hashing, and pretty-printing. It works with the `Int64.Map.Key.t` type, which represents keys in a map. Concrete use cases include managing and comparing key values within a map, performing deep copies of key instances, and checking project membership within keys.",
      "description_length": 361,
      "index": 2209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling kernel functions in Frama-C plugins. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling precise data manipulation and analysis. Concrete use cases include managing function declarations and prototypes in static analysis plugins, where deep copying and structural checks are required.",
      "description_length": 496,
      "index": 2210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL type information and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate type-indexed data in static analysis plugins, such as tracking type-specific properties or annotations.",
      "description_length": 398,
      "index": 2211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are compared using structural equality based on the `OffsetStructEq` semantics, and values are of the parameter module `Data`. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing tailored to structural equivalence. Concrete use cases include managing CIL-based analyses that require maps keyed on struct-like values with offset-sensitive equality.",
      "description_length": 458,
      "index": 2212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling file paths as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports parsing and validating file path strings, ensuring they conform to expected formats or existence constraints. Concrete use cases include defining options like input or output file paths in Frama-C plugins, where precise path handling and user feedback are required.",
      "description_length": 440,
      "index": 2213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL enumeration items. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate keys representing CIL enum items in a thread-safe and efficient manner.",
      "description_length": 357,
      "index": 2214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for CIL types where structural comparison of values is done by key identity without unrolling. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include managing and comparing structured CIL data such as type definitions or annotations within static analysis plugins.",
      "description_length": 445,
      "index": 2215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for managing versioned control flow graph data in abstract interpretation frameworks. It works with keys representing versions of unrolled automata, which track structured control flow paths in programs, particularly handling unnatural loops by normalizing entry points. The maps support efficient lookups, ordered traversal, and data aggregation, enabling use cases like tracking state transitions during program analysis or accumulating version-specific properties for reachability checks.",
      "description_length": 535,
      "index": 2216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered string-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing within projects, and provides descriptors for type representation. Concrete use cases include managing string identifiers in Frama-C plugins, such as storing and comparing variable names or function signatures in static analysis tools.",
      "description_length": 407,
      "index": 2217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by `Logic_label` with values of a specified type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It provides functionality for working with logic labels in the context of CIL-based analyses, enabling precise tracking and manipulation of labeled values. Concrete use cases include managing logic annotations and reasoning about labeled program elements during static analysis.",
      "description_length": 466,
      "index": 2218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps, providing operations such as equality, comparison, hashing, and pretty printing. It supports concrete data types that require unique representation and structural comparison, such as identifiers or structured values in static analysis. Use cases include managing symbol tables, tracking analysis states, and ensuring key consistency in map-based data structures.",
      "description_length": 416,
      "index": 2219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and managing logic real values in a hash table with deep copying, membership testing by project, and type-safe access. The resulting `t` type is a wrapper around `Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.t` with fully defined type and structural descriptors.",
      "description_length": 489,
      "index": 2220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and retrieving CIL type information with structural comparisons and project-aware membership checks. The hash tables are used to manage and manipulate type descriptors in a way that ensures deep copying and structural consistency.",
      "description_length": 455,
      "index": 2221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling lists of file paths as command-line parameters. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to define and manage command-line options that accept multiple file paths, ensuring correct serialization, comparison, and user-facing display.",
      "description_length": 393,
      "index": 2222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic information, where keys are associated with values of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings involving logic expressions or annotations in static analysis plugins.",
      "description_length": 409,
      "index": 2223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating sets of kernel functions, supporting operations like equality, comparison, hashing, and pretty-printing. It works with function declarations and prototypes, enabling precise handling of command-line parameters related to function sets. Concrete use cases include tracking and validating function targets in static analysis plugins and managing function-specific configuration options.",
      "description_length": 450,
      "index": 2224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys based on CIL statement sets (`Hptset.t`) and arbitrary value types, enabling efficient imperative operations like insertion, lookup, and iteration alongside advanced features such as deterministic folding, in-place filtering, and sequence transformations. It supports ordered traversal via custom comparison functions and includes utilities for memoization, optional lookups, and default value handling. Designed for Frama-C's CIL analysis framework, it is particularly suited for tasks like tracking statement-level metadata, managing analysis results, or implementing data-flow-sensitive transformations in static code analysis.",
      "description_length": 675,
      "index": 2225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for edge values in an interpreted automaton, where each edge represents a transition with associated guards and actions. It provides standard operations like equality, comparison, hashing, and pretty-printing for these edge-based hash tables, enabling efficient storage and retrieval of edge-related data. Concrete use cases include tracking transitions during abstract interpretation or managing edge-specific metadata in program analysis.",
      "description_length": 488,
      "index": 2226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by memory zones, where each zone is associated with a value of a specified data type. It provides operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate zone-indexed data in static analysis plugins, such as tracking memory state or analysis results per zone.",
      "description_length": 411,
      "index": 2227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing equality, comparison, and hashing operations. It supports concrete key types that can be stored and compared within maps, with functions for pretty-printing, deep copying, and project membership checks. Use cases include managing symbolic keys in static analysis plugins, such as tracking memory locations or program variables across different analysis phases.",
      "description_length": 434,
      "index": 2228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically supporting structural equality and strict constant comparison of CIL lvalues. It provides standard operations including equality testing, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hashtable structure when precise structural identity and comparison are required.",
      "description_length": 429,
      "index": 2229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Custom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a customizable data type interface for command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It works with a custom type `t` and integrates with Frama-C's project system through deep copying and project membership checks. Concrete use cases include implementing custom parameter types for plugins, such as parsing and validating domain-specific configuration values.",
      "description_length": 434,
      "index": 2230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL type information. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys that uniquely identify type information entries within a CIL-based analysis context.",
      "description_length": 376,
      "index": 2231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype where keys and values are governed by the provided `Data` module, which must define the underlying value type and its properties. It supports standard map operations such as comparison, equality, hashing, and pretty printing, along with project-aware membership checks and deep copying. It is suitable for managing structured collections of values with strong type guarantees, such as tracking analysis results keyed by program elements.",
      "description_length": 475,
      "index": 2232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing 64-bit integer keys in a hash table, including equality, comparison, hashing, and pretty-printing. It works with the `Int64.Hashtbl.key` type, which represents 64-bit integer values. Concrete use cases include storing and retrieving values indexed by 64-bit integers in a hash table, and performing key comparisons and hashing for efficient lookups.",
      "description_length": 393,
      "index": 2233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, where each category defines how options are grouped and interpreted. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. Use cases include organizing related command-line flags under named categories and controlling their activation behavior during option parsing.",
      "description_length": 421,
      "index": 2234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations such as equality, comparison, hashing, and pretty printing. It works with the `Hashtbl.key` type and includes functions for checking membership based on project properties and performing deep copies. Concrete use cases include managing and comparing keys in hash tables that store analysis data across different projects in Frama-C plugins.",
      "description_length": 422,
      "index": 2235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that orders properties based on function criteria such as kernel function name, kinstr, property kind, and property ID. It provides standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and query structured property data in static analysis plugins for Frama-C.",
      "description_length": 406,
      "index": 2236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear.Matrix",
      "library": "frama-c.kernel",
      "description": "This module implements matrix operations for fixed-size matrices, including arithmetic operations like addition, multiplication, and scalar multiplication, as well as matrix-specific functions such as transpose, inverse, and norms. It works with matrices parameterized over row and column dimensions using Peano naturals, and supports element access and modification via finite indices. Concrete use cases include representing and manipulating linear transformations and state transition matrices in static analysis filters.",
      "description_length": 524,
      "index": 2237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a list-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of values of a given type, providing deep copy functionality and membership checks for project-related data. Concrete use cases include managing collections of analysis results or configuration settings within a plugin, where structural equality and efficient traversal are required.",
      "description_length": 428,
      "index": 2238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with key values that may contain project-specific data, enabling checks on project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing keys in map structures where keys must be uniquely identified and efficiently handled during analysis tasks.",
      "description_length": 445,
      "index": 2239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by `Logic_real` values, with operations for equality, comparison, hashing, and pretty-printing. It supports typed maps through a `Data` module parameter, ensuring type-safe insertion and retrieval of values. Use cases include managing logic real-indexed data in static analysis plugins, such as mapping symbolic expressions to computed properties.",
      "description_length": 397,
      "index": 2240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, with operations including equality, comparison, hashing, and pretty printing. It supports concrete use cases like tracking and comparing structured CIL term lhost data within Frama-C plugins. The module also provides deep copying, membership checks over projects, and type descriptors for integration with Frama-C's internal analysis infrastructure.",
      "description_length": 440,
      "index": 2241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Float.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float data type with operations for equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's plugin system by providing descriptors and representations for structural handling. Use it to register and manipulate floating-point values within plugin contexts that require precise data type management.",
      "description_length": 354,
      "index": 2242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are standard integers and values are of a specified type, supporting operations like equality, comparison, hashing, and pretty printing. It is designed for use with Frama-C's internal type system and project management features, enabling storage and manipulation of values with deep copying and project-specific membership checks. Concrete use cases include managing collections of analysis results or configuration settings within Frama-C plugins.",
      "description_length": 501,
      "index": 2243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map from integers to values of a specified data type, supporting standard operations such as lookup, insertion, and iteration. It provides typed equality, comparison, hashing, and pretty-printing for maps, along with deep copying and project membership checks. Concrete use cases include tracking value associations in static analysis plugins, such as mapping variable identifiers to abstract values or analysis results.",
      "description_length": 445,
      "index": 2244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables that map vertex sets from unrolled control flow graphs to arbitrary values, supporting efficient insertion, lookup, and bulk updates via sequences. It provides ordered iteration and folding over keys (vertex sets) and values, along with memoization capabilities tailored for abstract interpretation tasks. These structures are particularly useful in program analysis scenarios where vertex sets represent control points in modified unnatural loops, enabling tracking of state transitions or aggregating analysis results across unrolled paths.",
      "description_length": 577,
      "index": 2245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by CIL types, where values are of the type provided by the `Data` parameter. It supports standard map operations including lookup, insertion, and traversal, along with type-specific equality, comparison, and hashing. It is used to associate type-indexed metadata, such as analysis results or annotations, with CIL type representations in a type-safe manner.",
      "description_length": 392,
      "index": 2246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are identifiers and values are of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership checks for project-related values, and type-safe serialization through descriptors. Concrete use cases include tracking and manipulating collections of CIL terms associated with identifiers, such as variable annotations or function metadata in static analysis plugins.",
      "description_length": 513,
      "index": 2247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module parameter, ensuring deep copies and project-aware membership checks. It is used to manage collections of CIL-based values with unique keys, such as storing and retrieving function or variable metadata in static analysis plugins.",
      "description_length": 452,
      "index": 2248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify type information in CIL-based analyses. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and query distinct type representations within Frama-C's internal data structures.",
      "description_length": 365,
      "index": 2249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string command-line parameters, including setting and retrieving values, defining hooks for change tracking, handling aliases, and customizing serialization. It supports string parameters with optional validation against predefined values or function names, enabling use cases such as configuring Frama-C plugins with strict value constraints or dynamically resolving function identifiers from command-line inputs.",
      "description_length": 456,
      "index": 2250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map lattice that combines maps and sets with lattice structures. It provides standard key functionalities such as comparison, hashing, equality, and pretty printing, along with support for project membership checks and deep copying. It is used to manage and manipulate keys in a lattice-aware map structure, particularly when integrating with project-based data that requires filtering and representation tracking.",
      "description_length": 479,
      "index": 2251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Float.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float parameter type for command-line options, handling parsing of decimal values and providing standard comparison, hashing, and pretty-printing operations. It works with OCaml float values and integrates with Frama-C's project system for deep copying and project membership checks. It is used to implement configurable numeric options in Frama-C plugins and tools.",
      "description_length": 388,
      "index": 2252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that conforms to the `Data` module signature, enabling structured storage and retrieval of values within the Frama-C kernel environment. Concrete use cases include managing collections of CIL-based model information where efficient lookup and manipulation are required.",
      "description_length": 476,
      "index": 2253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete data structures such as logic information entries tied to CIL types, enabling efficient lookups and manipulations in static analysis contexts. Use cases include tracking and managing logic-related data across different analysis phases in Frama-C plugins.",
      "description_length": 453,
      "index": 2254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage string parameters with validation and command-line integration, including default value handling, function name verification, and project-specific state tracking. It works with string-based parameters and function identifiers, supporting use cases like plugin configuration, command-line argument parsing, and enforcing allowed value constraints during analysis.",
      "description_length": 402,
      "index": 2255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are integers and values are of the provided `Data` module's type. It supports standard map operations like equality, comparison, hashing, and pretty-printing, along with project membership checks and deep copying. It is used to manage integer-indexed collections of a specific data type, enabling structured storage and retrieval in analysis plugins.",
      "description_length": 396,
      "index": 2256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for managing polymorphic values indexed by keys derived from `Varinfo.Hptset.t`, a type representing variable information sets. It supports associative operations like insertion, lookup, and removal, along with transformations (e.g., `map`, `filter`), set-theoretic merges, and ordered traversal, enabling efficient aggregation and manipulation of variable-related metadata. Designed for static analysis contexts, it facilitates tasks such as tracking variable properties or analysis results across C program elements.",
      "description_length": 562,
      "index": 2257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for mapping memory locations (as base-offset pairs in bytes) to values of a specified data type. It supports standard hash table operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to efficiently store and query data associated with specific memory addresses in static analysis plugins.",
      "description_length": 423,
      "index": 2258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hashtables that supports strict structural equality and hashing of CIL expressions. It provides operations for comparing, hashing, and pretty-printing keys, as well as deep copying and checking membership based on project skeletons. The module is used to uniquely identify and manage CIL expressions in contexts requiring precise structural comparison, such as analysis state tracking or caching.",
      "description_length": 431,
      "index": 2259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option groups, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter elements and state lists, allowing dependencies and accessors to be specified when adding new categories. Concrete use cases include organizing related command-line options under a common category and controlling their activation behavior through default or global settings.",
      "description_length": 496,
      "index": 2260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL instruction-related data. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. The type `t` represents keys with embedded project information, supporting precise and efficient key management in hash tables used during static analysis.",
      "description_length": 428,
      "index": 2261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing command-line parameters, particularly for kernel functions. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with their behaviors and dependencies. Use cases include structuring plugin options and controlling parameter activation through predefined categories.",
      "description_length": 383,
      "index": 2262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by `Kinstr.t` values, where the associated data type is specified by the `Data` parameter. It provides standard map operations such as lookup, insertion, and traversal, along with serialization, comparison, and pretty-printing capabilities for analysis and debugging. It is used to track and manipulate instruction-indexed data during static analysis, such as per-instruction annotations or transformation states.",
      "description_length": 448,
      "index": 2263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on the `PredicateStructEq` type and values are of the parameter module `Data`. It provides standard map operations\u2014`equal`, `compare`, `hash`, `mem_project`, and `pretty`\u2014specialized for maps containing structured equality checks on CIL predicates. It is suitable for analysis plugins needing to track or compare sets of predicate-based values across Frama-C projects.",
      "description_length": 418,
      "index": 2264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module, ensuring deep copies and project-aware membership checks. It is used to manage collections of values with efficient lookups and persistent storage in analysis plugins.",
      "description_length": 392,
      "index": 2265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys compared using strict structural equality, including constants. It supports standard operations like equality, comparison, hashing, and pretty-printing for maps, and is suitable for use in analysis plugins requiring precise value tracking. Concrete use cases include managing and comparing CIL-based value abstractions during static analysis.",
      "description_length": 396,
      "index": 2266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are based on CIL types with structural comparison and no unrolling. It supports standard hash table operations like equality, comparison, hashing, and pretty printing, while ensuring deep copies and project membership checks. It is used to manage collections of CIL type values with precise structural identity in static analysis plugins.",
      "description_length": 391,
      "index": 2267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for grouping command-line options related to string sets. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. Concrete use cases include organizing and controlling the behavior of command-line parameters in Frama-C plugins, particularly for enabling or disabling groups of options collectively.",
      "description_length": 429,
      "index": 2268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling keys in a hash table that use wide strings as key values. It provides standard key functionalities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used when managing hash tables where keys are represented as wide strings, particularly in contexts requiring persistence, comparison, or structured data traversal.",
      "description_length": 428,
      "index": 2269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling keys in a hash table, specifically for native integers. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. These functions support efficient key management and are used when storing or retrieving native integer keys in persistent or project-aware contexts.",
      "description_length": 378,
      "index": 2270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with key-value pairs where keys are from the `Term` module and values are of type `Data.t`. Concrete use cases include managing term-indexed collections of custom data during CIL analysis or transformation passes, such as tracking term-specific analysis results or annotations.",
      "description_length": 458,
      "index": 2271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype for values of a specified type, using positions in files as keys. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project membership checks and deep copying. This module is useful for tracking and managing data associated with specific source code locations in CIL-based analyses.",
      "description_length": 362,
      "index": 2272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete data structures such as term offsets in CIL, enabling efficient lookups and manipulations tied to C analysis tasks. Use cases include tracking and comparing term offsets during static analysis, such as in value analysis or slicing plugins.",
      "description_length": 438,
      "index": 2273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps where each key is associated with a value that forms a lattice structure. It provides operations for comparing, hashing, and pretty-printing such maps, along with deep copying and checking membership based on project values. It is used to manage and manipulate maps in static analysis contexts where lattice properties are essential, such as abstract interpretation.",
      "description_length": 394,
      "index": 2274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with a unique name, equality, comparison, and pretty-printing operations, working with values of type `Datatype.t`. It supports deep copying, membership testing within projects, and provides a descriptor for structural representation. Concrete use cases include managing plugin-specific data representations in Frama-C, such as abstract states or analysis results, ensuring they can be compared, printed, and copied consistently.",
      "description_length": 461,
      "index": 2275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are constants and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with CIL constants as keys and arbitrary values, enabling efficient lookups and manipulations. Concrete use cases include tracking constant-value associations during static analysis, such as mapping integer constants to analysis results or symbolic expressions.",
      "description_length": 444,
      "index": 2276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify logic types by their name and type information. It provides operations to compare, hash, and pretty-print these keys, along with introspection capabilities via descriptors and representants. Use cases include managing and retrieving logic type definitions in a type-safe manner, ensuring uniqueness and consistency across different parts of an analysis plugin.",
      "description_length": 425,
      "index": 2277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are of type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checks. It is used to manage collections of values with efficient lookup and structural comparison.",
      "description_length": 318,
      "index": 2278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements key operations for a map where keys are based on logic types by name. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. It is used to manage and manipulate logic type identifiers in a map structure, specifically supporting operations required for Frama-C's analysis and transformation plugins.",
      "description_length": 410,
      "index": 2279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based data structure where keys are managed with a lattice structure and values conform to a specified data type. It provides operations for equality checking, comparison, hashing, deep copying, and pretty printing, along with project membership testing. It is used to represent and manipulate stateful data in static analysis plugins, particularly when tracking value approximations across program points.",
      "description_length": 442,
      "index": 2280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Empty_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling empty strings as command-line parameters, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's project system through deep copying and project membership checks. Concrete use cases include defining command-line options that accept empty string values in plugin development.",
      "description_length": 390,
      "index": 2281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic constructor information and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying. Concrete use cases include managing and manipulating logic constructor-specific data in static analysis plugins, such as storing and retrieving analysis results or annotations tied to specific logic constructors.",
      "description_length": 439,
      "index": 2282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for `Fundec.t` values with standard operations such as membership testing, comparison, and pretty printing. It supports command line option handling by providing deep copying, hashing, and project-aware filtering through `mem_project`. Concrete use cases include tracking and manipulating sets of functions during static analysis, particularly for options that require persistent or configurable function sets.",
      "description_length": 454,
      "index": 2283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map for handling multiple values per key, supporting operations like insertion, lookup, and iteration. It works with string keys and abstract data values of type `Datatype.t`, ensuring efficient storage and retrieval. Concrete use cases include managing command-line options with multiple string arguments or tracking configurations where keys map to several string-based settings.",
      "description_length": 421,
      "index": 2284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a comparable key type for maps, including equality, comparison, and hashing operations. It works with abstract key values that represent map keys in a structured and typed manner. Concrete use cases include managing map keys in data structures, ensuring consistent comparison and hashing for efficient lookups, and supporting pretty-printing and deep copying of key values.",
      "description_length": 393,
      "index": 2285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by normalized filepaths, where each map entry holds values of a specified type. It supports standard map operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is ideal for tracking file-specific data across different analysis projects, ensuring type safety and structural consistency.",
      "description_length": 396,
      "index": 2286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, ensuring structural equality and proper handling of CIL types. It supports standard operations like `equal`, `compare`, `hash`, and `pretty`, tailored for working with CIL lvalues and structures. Concrete use cases include managing and comparing analyzed C code elements such as variables or expressions in static analysis plugins.",
      "description_length": 422,
      "index": 2287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps, providing essential operations like equality, comparison, hashing, and pretty-printing. It works with the abstract type `Map.Key.t`, offering functions to compare, hash, and display values, along with utilities for project membership checks and deep copying. Concrete use cases include managing and manipulating map keys in Frama-C plugins, ensuring consistent handling of structured data within analysis tools.",
      "description_length": 465,
      "index": 2288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based parameters with operations for setting, retrieving, and validating values, including support for hooks, aliases, and marshaling customization. It operates on global string parameters integrated with Frama-C's plugin system, tracking default values and project-specific state. Key use cases include command-line interface configuration, persistent state management, and ensuring valid function name inputs through validation mechanisms.",
      "description_length": 468,
      "index": 2289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by CIL functions (`Fundec.t`), where each function maps to values of a specified type `Data.t`. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and pretty-printing functions for the map. This structure is useful for analyzing or transforming C code, where per-function data needs to be stored and queried efficiently.",
      "description_length": 414,
      "index": 2290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table used in pretty-printing source code with location-aware AST elements. It provides standard operations like equality, comparison, hashing, and pretty-printing for keys, along with deep copying and project membership checks. It is used to manage and manipulate keys that uniquely identify entries in a structured, serializable hash table tied to source code locations.",
      "description_length": 414,
      "index": 2291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL global annotations, enabling tracking and manipulation of annotated data across C code analysis. Concrete use cases include storing and retrieving function-specific metadata during static analysis, such as annotation-based security checks or code transformation rules.",
      "description_length": 465,
      "index": 2292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table indexed by memory locations, where each entry maps a base address to a range of bits. It provides standard operations like equality, comparison, hashing, and pretty-printing for these tables, along with deep copying and project membership checks. It is used to track and manipulate memory zones in static analysis, such as during value propagation or alias analysis.",
      "description_length": 402,
      "index": 2293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with `Nativeint` values, including equality, comparison, hashing, and pretty-printing. It supports data types that can be stored in Frama-C's internal structures, such as project-specific identifiers or numeric keys. Concrete use cases include managing and comparing unique identifiers in static analysis plugins and persisting or serializing map keys across different analysis phases.",
      "description_length": 438,
      "index": 2294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line parameters in Frama-C's kernel, specifically for the `-load-library` option. It provides operations for equality checks, comparison, hashing, and pretty-printing string values, along with deep copying and project membership testing. Concrete use cases include managing and validating library paths passed via the command line and integrating them into Frama-C's internal project structure.",
      "description_length": 460,
      "index": 2295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "The module enables managing string-based plugin parameters using a multiple map structure, supporting operations like value retrieval, alias resolution, and command-line argument integration with state tracking. It works with validated function names and string data types, providing hooks for updates and marshaling customization. This facilitates use cases such as tracking analysis configurations, project-based workflows, and ensuring valid function references in Frama-C plugins.",
      "description_length": 484,
      "index": 2296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are expressions with structural equality, treating equivalent expressions within `sizeof` operations as equal. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate CIL expressions in contexts requiring structural identity, such as analysis state tracking or value abstraction.",
      "description_length": 474,
      "index": 2297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for defining and managing string-based command-line options, including value validation, alias handling, and state change hooks. It works with string parameters and function names, ensuring arguments correspond to valid function declarations or prototypes when required. These tools are used to implement customizable command-line options that accept function names as input, support dynamic value constraints, and require specialized serialization.",
      "description_length": 480,
      "index": 2298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are expressions with structural equality, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with CIL expressions in a way that treats structurally equivalent expressions as equal keys. Use cases include managing expression-based mappings in analyses where structural identity is semantically meaningful, such as value numbering or expression memoization.",
      "description_length": 462,
      "index": 2299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table used in tracking and comparing declaration elements during pretty printing of C source code. It supports operations like equality checking, comparison, hashing, and pretty printing, specifically tailored for handling and distinguishing between different declaration keys in the context of Frama-C's AST. The module is used to manage and query declaration-specific data across different projects, ensuring accurate and consistent source representation.",
      "description_length": 499,
      "index": 2300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associating CIL enumeration items with other data. It provides standard map key functionality such as equality, comparison, hashing, and pretty printing, specifically for `Enumitem.Map.key` values derived from CIL types. These keys are used to uniquely identify and efficiently manage mappings involving CIL enumeration items in static analysis plugins.",
      "description_length": 406,
      "index": 2301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It works with logic type keys that avoid unrolling, supporting deep copies and project membership checks. Concrete use cases include managing unique logic type identifiers in static analysis plugins, ensuring efficient lookups and comparisons.",
      "description_length": 363,
      "index": 2302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a specialized hashtbl, including operations for equality, comparison, hashing, and pretty printing. It supports structured keys with associated type and descriptor information, enabling precise handling of machine-dependent data. Use cases include managing and querying machine-specific configurations and state within static analysis plugins.",
      "description_length": 392,
      "index": 2303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for storing values of a given `Data` module type, leveraging a kernel function Hptset as the underlying structure. It provides standard operations including equality checks, comparison, hashing, deep copying, and project membership testing through `mem_project`. Concrete use cases include efficiently managing and querying collections of analysis data tied to kernel functions, such as value states or abstract properties, across different projects.",
      "description_length": 510,
      "index": 2304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys based on the `OffsetStructEqStrict` type, providing standard operations like `equal`, `compare`, `hash`, and `pretty`. It supports strict structural equality and deep copying of map contents, ensuring no shared references. Concrete use cases include managing and comparing structured CIL data in static analysis plugins, such as tracking memory offsets or structured constants.",
      "description_length": 431,
      "index": 2305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL attributes and project-specific data, enabling storage and manipulation of typed values in static analysis contexts. Concrete use cases include tracking variable annotations or function-specific metadata during C code analysis.",
      "description_length": 424,
      "index": 2306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing essential operations including equality, comparison, hashing, and pretty-printing. It supports working with `Map.key` values, which are typically used to index map collections. Concrete use cases include managing unique identifiers for map entries, ensuring deep copying of key values, and checking membership within projects using predicate functions.",
      "description_length": 426,
      "index": 2307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for file paths, providing operations to associate values with file path keys. It supports standard map operations such as insertion, lookup, and iteration, all keyed by file paths. Concrete use cases include tracking per-file analysis results or configuration settings in Frama-C plugins.",
      "description_length": 344,
      "index": 2308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by base memory zones, where each zone maps to a value of a specified type. It supports operations like equality checking, comparison, hashing, and pretty-printing for the map, along with deep copying and project membership testing. It is used to manage and manipulate memory zone mappings with concrete values, such as associating metadata or analysis results with specific memory regions.",
      "description_length": 423,
      "index": 2309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are managed with the `Hashtbl` structure and values are of a specified `Data` module's type. It provides standard operations including equality, comparison, hashing, and pretty printing for these tables, along with deep copying and project membership checks. It is used to manage collections of data indexed by hashable keys in a way consistent with Frama-C's internal type and project handling mechanisms.",
      "description_length": 459,
      "index": 2310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL labels, including equality, comparison, hashing, and pretty-printing. It supports data types that represent labels in CIL, enabling efficient key-based lookups and manipulations. Concrete use cases include managing and comparing label identifiers during static analysis of C code.",
      "description_length": 342,
      "index": 2311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by 32-bit integers, where the value type is defined by the `Data` module. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the map itself. It is used to manage collections of values indexed by integer identifiers, such as tracking analysis results per program point or storing configuration settings by numeric key.",
      "description_length": 444,
      "index": 2312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype specialized for values of a given module `Data`, with operations for equality, comparison, hashing, and pretty printing. It supports structured values tied to CIL expressions, using `eid`-based equality and enabling deep copies and project-aware membership checks. Useful for managing collections of CIL-related data where structural identity and efficient lookups are required.",
      "description_length": 408,
      "index": 2313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and customizing analysis parameters tied to kernel functions. It supports operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, with support for accessors and state dependencies. It is used to control parameter behavior across different analysis contexts, such as enabling or disabling groups of functions based on category rules.",
      "description_length": 420,
      "index": 2314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table within a project management system, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with project-specific keys that may contain references to project skeletons, enabling introspection via the `mem_project` function. Concrete use cases include managing and tracking internal states associated with different projects in a Frama-C plugin, ensuring deep copies and proper comparison semantics.",
      "description_length": 504,
      "index": 2315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a purely functional set structure for managing collections of HPT (Heap, Points-to, Type) sets over CIL statements, supporting efficient membership queries, ordered traversal, and set-theoretic operations like union and intersection. It provides ordered iteration, nearest-element searches, and conversions to sequences/lists, optimized via balanced tree representations for performance-critical static analysis tasks. Typical use cases include tracking program state abstractions in Frama-C plugins, where precise manipulation of hierarchical statement sets is required for analysis or transformation passes.",
      "description_length": 632,
      "index": 2316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` for keys used in maps that associate memory locations with bit-level offsets. It provides standard operations for equality testing, comparison, hashing, and pretty-printing keys, as well as functions for checking membership based on project properties and performing deep copies. These keys are used to represent and manipulate memory locations with bit-level precision, enabling analysis plugins to track and reason about memory accesses at a fine granularity.",
      "description_length": 497,
      "index": 2317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling keys in a hash table, specifically for logic labels in CIL-based analyses. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and membership checks over project skeletons. These operations support efficient key management and are essential for implementing and querying logic label-based data structures in static analysis plugins.",
      "description_length": 437,
      "index": 2318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables structured management of string-valued plugin parameters, primarily for file paths and function names, with operations to validate, filter, and transform values through customizable rules. It operates on global string parameters, integrating project-specific state tracking and marshaling for serialization across analysis sessions. Typical use cases include enforcing valid file path configurations, resolving aliases for dynamic parameter updates, and persisting plugin settings with type-safe conversions.",
      "description_length": 528,
      "index": 2319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for CIL statement data types, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data structures containing CIL statements with deep copying and project-aware membership checks. Concrete use cases include managing and analyzing collections of CIL statements in Frama-C plugins, such as tracking control flow or storing function-specific data.",
      "description_length": 435,
      "index": 2320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map where keys are units and values are of the type provided by the `Data` module. It includes standard operations like `equal`, `compare`, `hash`, and `pretty` for map manipulation and inspection. It is useful for managing maps with singleton keys in scenarios like abstract interpretation or program analysis where each key corresponds to a unique value.",
      "description_length": 378,
      "index": 2321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based representations of kernel functions, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project-specific data through `Project_skeleton.t`, enabling precise manipulation and analysis of function representations. Concrete use cases include tracking function properties across different analysis contexts and ensuring consistent string-based identifiers in kernel extensions.",
      "description_length": 492,
      "index": 2322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed on edges of an interpreted automaton, where each edge represents a transition in a control flow graph with associated guards and actions. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for analysis and storage. The map is used to associate data with transitions in a program's abstract interpretation, enabling precise tracking of state changes and conditions during static analysis.",
      "description_length": 504,
      "index": 2323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a graph structure, where each edge has a source and destination vertex along with a label. It provides operations to create edges, retrieve their source, destination, and label, and compare edges based on their direction. It is used to model labeled, directed relationships between vertices in an imperative graph, particularly for constructing and analyzing service dependencies derived from a callgraph.",
      "description_length": 446,
      "index": 2324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage string-valued plugin parameters with capabilities for value validation, alias handling, and persistent state integration via Frama-C's project system. It works with string collections and function name verifications, enabling use cases like configuring analysis options, tracking parameter changes through hooks, and enforcing valid identifier syntax in plugin workflows. The module supports serialization, default value management, and filtering of strings against predefined constraints or naming conventions.",
      "description_length": 551,
      "index": 2325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Action.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, packed descriptions, and project membership checks. Concrete use cases include managing plugin-specific data types that require serialization, comparison, and integration with Frama-C's project model.",
      "description_length": 412,
      "index": 2326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identifies built-in logic information entries. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checks over project skeletons. The keys combine a type and a string name, ensuring structured and efficient map manipulations in analyses involving logic definitions.",
      "description_length": 410,
      "index": 2327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing symbolic path entries as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports managing and querying symbolic paths used in Frama-C's kernel, particularly for handling the `-add-symbolic-path` option. Concrete uses include tracking and manipulating path mappings during analysis, ensuring correct path resolution and project-specific filtering.",
      "description_length": 432,
      "index": 2328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control how parameters are grouped and interpreted. Concrete use cases include setting up configurable parameter groups for plugins, defining default and special categories like `@all` and `@none`, and enabling category-based parameter activation logic.",
      "description_length": 511,
      "index": 2329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for logic variables, using the provided `Data` module to define the value type. It supports standard operations like insertion, lookup, and iteration, along with deep copying, equality checking, and pretty printing. It is used when managing collections of logic variable bindings in static analysis plugins.",
      "description_length": 367,
      "index": 2330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are attributes and values are of the type provided by the `Data` parameter. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing for use in data structures. It is suitable for tracking attribute-value associations in CIL-based analyses, such as mapping function attributes to analysis results.",
      "description_length": 403,
      "index": 2331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete data types that require structured handling within Frama-C's analysis framework, such as CIL-based constructs. Use cases include tracking and manipulating CIL instructions or expressions in a hash table while preserving type-specific properties and relationships.",
      "description_length": 462,
      "index": 2332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map",
      "library": "frama-c.kernel",
      "description": "This module provides map operations that associate vertex sets from unrolled control flow graphs with arbitrary values, enabling set-based key management and ordered traversal. It supports functional transformations, conditional searches, and bulk updates while leveraging key ordering for efficient analysis workflows in abstract interpretation tasks like state merging and path-sensitive reasoning. The structure is particularly suited for tracking vertex-specific data during program analysis where hierarchical control flow manipulations are required.",
      "description_length": 555,
      "index": 2333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map used to represent logic constants in CIL-based analyses. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used in map and set structures. Use cases include tracking and managing unique identifiers for logic constants during static analysis, enabling efficient lookups and transformations.",
      "description_length": 402,
      "index": 2334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for attribute handling in the CIL (C Intermediate Language) representation. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate attribute keys in a type-safe manner during static analysis of C code.",
      "description_length": 405,
      "index": 2335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports creating and managing typed, project-aware data maps with deep copying and membership checks based on project properties. Use this to associate and manipulate structured data keyed by identifiers in static analysis plugins.",
      "description_length": 390,
      "index": 2336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in global map structures, providing equality, comparison, hashing, and pretty-printing functions. It works with the `Global.Map.Key.t` type, which represents keys in a map that associates global CIL entities with values. Concrete use cases include managing and comparing keys for global variables or functions in CIL-based analyses, such as tracking project-specific properties or performing key-based lookups in map data structures.",
      "description_length": 478,
      "index": 2337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associating field information in CIL structures. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. It is used when managing field-specific data during static analysis, such as tracking annotations or properties tied to struct or union fields.",
      "description_length": 389,
      "index": 2338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.As_string",
      "library": "frama-c.kernel",
      "description": "This component manages string-based plugin parameters with support for validation, marshaling, and command-line integration, enabling state tracking and project-specific behavior. It operates on individual strings and string lists, offering utilities to validate values (e.g., function names), handle aliases, and customize serialization or default settings. Typical use cases include defining analysis configuration options that require structured string inputs, such as specifying target functions or parsing user-defined rules during static analysis.",
      "description_length": 553,
      "index": 2339,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure that associates float values with key values. It supports key comparison, equality, hashing, and pretty-printing, enabling efficient map manipulation and inspection. Specific use cases include managing and querying sets of floating-point values indexed by structured keys in static analysis contexts.",
      "description_length": 380,
      "index": 2340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores CIL label data, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports efficient key-based lookups and ensures deep copying and project membership checks for analysis-specific data. Concrete use cases include managing and retrieving CIL label information during static analysis, where keys must uniquely identify and describe label properties in a hash table.",
      "description_length": 465,
      "index": 2341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hashtbl specialized to logic types in CIL, providing equality, comparison, and hashing operations required for efficient storage and retrieval. It works with logic type keys that may include project-specific data, supporting deep copying and membership checks against project skeletons. Concrete use cases include managing and querying logic type metadata in Frama-C plugins, such as tracking type-specific properties across different analysis contexts.",
      "description_length": 484,
      "index": 2342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for identified predicates in CIL-based analyses. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with functions for deep copying and checking project membership. The key type supports structured data representation and efficient lookups in contexts requiring persistent or project-aware storage of predicate information.",
      "description_length": 448,
      "index": 2343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t` with structural equality and comparison, where expressions inside `sizeof` are compared structurally rather than by identifier. It supports standard operations such as `equal`, `compare`, `hash`, and `pretty`, along with deep copying and project membership checks. Concrete use cases include managing and comparing CIL expressions within Frama-C plugins, particularly when handling type analyses or transformations that require structural equivalence.",
      "description_length": 524,
      "index": 2344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths in a plugin, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project-related values within file path lists. Concrete use cases include managing and comparing sets of file paths during static analysis plugin execution.",
      "description_length": 371,
      "index": 2345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-valued plugin parameters, including validation of allowed values, alias resolution, and lifecycle hooks for state changes. It operates on strings and string lists to enforce parameter constraints, filter inputs, and integrate with Frama-C's command-line parsing and project serialization systems. Typical use cases include defining configurable options for plugins that require validated string inputs, such as function name filters or customizable analysis modes.",
      "description_length": 513,
      "index": 2346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL locations. It provides standard operations such as equality, comparison, hashing, and pretty printing, enabling efficient storage and retrieval of values associated with CIL locations. Use cases include tracking and managing analysis data tied to specific points in C source code during static analysis.",
      "description_length": 387,
      "index": 2347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in attribute maps, including equality, comparison, hashing, and pretty-printing. It works with key values that may contain project-specific data, supporting checks for project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing keys in maps that store CIL attribute information during static analysis.",
      "description_length": 395,
      "index": 2348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify terms in CIL (C Intermediate Language) with operations for equality, comparison, hashing, and pretty-printing. It works with CIL types and project-aware data structures, enabling efficient lookups and management of term identifiers in static analysis plugins. Concrete use cases include tracking and comparing CIL expressions or statements across different analysis phases.",
      "description_length": 438,
      "index": 2349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps where keys are CIL types compared by name without unrolling. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Use cases include managing type-based mappings in static analysis plugins, such as tracking type-specific properties across C codebases.",
      "description_length": 383,
      "index": 2350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for a given value type, supporting operations like equality, comparison, hashing, and pretty-printing. It works with project-specific data types that require deep copying and structural inspection, such as analysis results tied to Frama-C's AST. Concrete use cases include managing and querying collections of values linked to Frama-C projects, such as storing and retrieving function summaries or variable annotations.",
      "description_length": 466,
      "index": 2351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of CIL variable descriptors (`Varinfo`) with standard algebra (union, intersection, difference) and transformations (map, filter) that exploit comparison-based ordering for element identity. It supports efficient membership queries, ordered traversal via `fold`/`iter`, and decomposition using range operations (`split`, `to_seq_from`) or partitioning. These capabilities are used in static analysis plugins for tasks like data flow tracking and code optimization, where precise variable set manipulation and ordered enumeration enable efficient analysis state management.",
      "description_length": 608,
      "index": 2352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that conforms to the `Data` module signature, enabling structured storage and retrieval of values. Concrete use cases include managing collections of CIL-based identified predicates with efficient lookups and maintaining project-specific data in analysis plugins.",
      "description_length": 470,
      "index": 2353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter builders, allowing the association of states and accessors to control behavior. Concrete use cases include setting up default option groups, enabling all options under a specific interpretation, or mapping `@all` to a custom category.",
      "description_length": 463,
      "index": 2354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hashtbl, specifically supporting operations such as equality, comparison, hashing, and pretty printing. It works with the abstract type `t` representing hashtbl keys, and includes functions for deep copying values, checking membership based on project conditions, and providing representants for the type. Concrete use cases include managing and manipulating keys in a hashtbl structure within Frama-C plugins, particularly when dealing with project-specific data.",
      "description_length": 514,
      "index": 2355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by integers, where values are of a specified data type. It provides standard operations including equality checks, comparison, hashing, and pretty-printing for map instances. Concrete use cases include managing integer-indexed collections of analysis data or configuration values within static analysis plugins.",
      "description_length": 361,
      "index": 2356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP.V",
      "library": "frama-c.kernel",
      "description": "This module defines a vertex type for a service graph, where each vertex is labeled and supports comparison, hashing, and equality checks. It works with comparable vertex labels and provides operations to create vertices from labels and retrieve their labels. Concrete use cases include representing function nodes in a callgraph with unique identifiers and associated metadata.",
      "description_length": 378,
      "index": 2357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based lattice structure where each entry's value contributes to the lattice properties. It supports standard lattice operations like equality, comparison, and pretty-printing, specifically tailored for data types that form a lattice. It is used to manage and manipulate collections of values with hierarchical relationships, ensuring efficient lookups and structural consistency.",
      "description_length": 415,
      "index": 2358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL type representations. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, ensuring correct handling of type information during analysis. Concrete use cases include tracking and comparing CIL type keys in Frama-C plugins, such as during type-based analyses or transformation passes that require efficient key-based lookups.",
      "description_length": 463,
      "index": 2359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table indexed by `Fieldinfo` values, where the keys are CIL structure or union fields and the values are of a specified type. It provides standard operations like equality, comparison, hashing, and pretty-printing for these tables, along with deep copying and project-aware membership checks. It is used to track or analyze per-field data during C code analysis, such as field-specific properties or annotations.",
      "description_length": 439,
      "index": 2360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports imperative hash table operations for managing mappings from CIL variable metadata (`Varinfo.Hptset.t`) to arbitrary values, enabling efficient insertion, lookup, iteration, and in-place transformations. It facilitates advanced use cases like tracking variable state during static analysis, memoizing computation results, and aggregating metadata across C codebases using ordered folds or custom comparators. The structure is optimized for scenarios requiring mutable, high-performance associative storage tied to CIL's variable representations.",
      "description_length": 565,
      "index": 2361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t` with structural equality and strict constant comparison, ensuring that expressions within `sizeof` are compared structurally rather than by identifier. It provides standard operations including equality, comparison, hashing, pretty printing, deep copying, and project membership checking, all tailored to the structural semantics of CIL expressions. Concrete use cases include managing and comparing CIL expressions in static analysis plugins where precise structural identity and hash-based lookups are required.",
      "description_length": 586,
      "index": 2362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by interpreted automaton vertices, with values parameterized by the `Data` module. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, along with project membership checks. It is used to associate vertex-specific data with control flow graph nodes in abstract interpretation tasks, such as tracking state or annotating vertices with analysis results.",
      "description_length": 445,
      "index": 2363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map over kernel functions, supporting operations like equality, comparison, hashing, and pretty-printing for structured data types. It works with descriptors and representants to manage type-specific behaviors and project membership checks. Concrete use cases include tracking and manipulating function-related data across different analysis contexts, such as storing and retrieving function-specific annotations or configurations.",
      "description_length": 465,
      "index": 2364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Enum.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations to check membership in projects, perform deep copies, and provides a list of all possible values. It is used to implement command-line options with a restricted set of allowed inputs, ensuring type safety and consistent serialization.",
      "description_length": 373,
      "index": 2365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are term lhosts and values are of type `Data.t`. It provides standard map operations including lookup, insertion, and traversal, along with equality, comparison, and hashing functions. It is used to manage and manipulate term lhost-indexed data in static analysis plugins, such as tracking expressions or annotations tied to specific program points.",
      "description_length": 389,
      "index": 2366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.True.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with full support for comparison, hashing, pretty-printing, and deep copying. It works with a specific type `t` that represents values with associated structural descriptions, equality, and project membership checks. Use this module when implementing custom data types that require serialization, comparison, or integration with Frama-C's project management and analysis features.",
      "description_length": 421,
      "index": 2367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports hash table operations for versioned control points in modified control flow graphs, including insertion, deletion, lookup, iteration, and advanced in-place filtering. It works with key-value pairs where keys represent versioned states in unrolled unnatural loops, enabling ordered traversal, sorting, and memoization. The structure is optimized for managing state transitions during abstract interpretation of C programs with complex loop constructs.",
      "description_length": 471,
      "index": 2368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key interface for a map implementation over hash-consed trees, providing essential operations for equality, comparison, hashing, and pretty-printing. It supports keys that may contain embedded project data, enabling checks for project membership and deep copying to avoid shared structures. Concrete use cases include managing and querying keys in a Patricia tree-based map where key integrity and efficient comparison are critical.",
      "description_length": 456,
      "index": 2369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, preserving their type and operations. It supports standard hash table functionalities like equality, comparison, hashing, and pretty printing, tailored to CIL syntactic scopes. It is used to manage scoped CIL data in analyses, enabling precise tracking and manipulation of values across different project contexts.",
      "description_length": 405,
      "index": 2370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables within a lattice implementation, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with abstract key values that may contain project-specific data, supporting deep copying and membership checks based on project properties. Concrete use cases include managing and querying abstract interpretation states keyed by project elements in static analysis plugins.",
      "description_length": 456,
      "index": 2371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines key operations for a map using positions in a file as keys. It provides standard map key functionalities such as equality, comparison, hashing, and pretty printing for `Frama_c_kernel.Cil_datatype.Position.Map.key` values. It is used to manage and manipulate mappings based on source code positions in CIL-based analyses.",
      "description_length": 341,
      "index": 2372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage and validate string-based parameters representing file paths within a Frama-C plugin, including setting values, registering update callbacks, and handling aliases. It operates on string lists and individual strings, with support for marshaling, validation logic, and integration with project state management. Typical use cases involve processing command-line arguments for file paths, validating user-provided function names in C contexts, or maintaining persistent file path configurations across plugin sessions.",
      "description_length": 555,
      "index": 2373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, preserving their logic type properties without unrolling. It supports standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage collections of logic types in a way that maintains structural integrity and efficient lookups.",
      "description_length": 408,
      "index": 2374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are enum items and values are of type `Data.t`. It provides standard map operations including comparison, equality, hashing, pretty-printing, and deep copying, along with project-related membership checks. It is used to manage and manipulate mappings from CIL enum items to arbitrary data in a type-safe and structured way.",
      "description_length": 363,
      "index": 2375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include enabling all options under a category, setting a default category behavior, or defining how `@all` should be interpreted in different contexts.",
      "description_length": 465,
      "index": 2376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for `Compinfo` structures in the CIL (C Intermediate Language) representation. It provides standard operations such as equality, comparison, hashing, and pretty printing, enabling efficient and correct handling of `Compinfo` entries in hash-based collections. Concrete use cases include tracking and managing component information during static analysis, where fast key-based lookups and unique identification of components are required.",
      "description_length": 513,
      "index": 2377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table specialized for CIL lvalue keys with structural equality and serialization support. It handles data structures involving CIL expressions and statements, ensuring proper comparison and hashing based on their structure. Useful for tracking or caching analysis results tied to specific CIL constructs across different program points.",
      "description_length": 351,
      "index": 2378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent memory locations with bit-level precision, combining base addresses and bit offsets. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to track and manipulate memory locations in static analysis plugins where bit-level accuracy is required.",
      "description_length": 401,
      "index": 2379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a string-based hashtbl, providing equality, comparison, and hashing operations tailored to key values. It supports structured data management with functions like `equal`, `compare`, and `hash`, and includes utilities for pretty printing and deep copying key values. Concrete use cases include managing unique identifiers or string-based keys in analysis plugins requiring precise data tracking and comparison.",
      "description_length": 457,
      "index": 2380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uses structural equality with strict constant comparison and handles expressions within `sizeof` by comparing their structure rather than identifiers. It supports operations like equality checking, comparison, hashing, and pretty printing for keys, along with deep copying and project membership testing. It is used in contexts requiring precise structural analysis of CIL expressions, particularly when managing maps keyed by such expressions.",
      "description_length": 489,
      "index": 2381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are floating-point numbers and values are of the specified `Data` module type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions. It is used to manage and manipulate collections of floating-point indexed data in static analysis plugins for Frama-C.",
      "description_length": 371,
      "index": 2382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by `Kf` with values of a specified `Data` type, providing standard map operations. It supports key-based lookups, insertion, and traversal, along with equality, comparison, and hashing functions for map instances. It is used to manage collections of CIL-related data indexed by kernel functions, such as associating function-specific metadata or analysis results.",
      "description_length": 404,
      "index": 2383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by logic constants, with values parameterized by the `Data` module. It provides standard map operations including comparison, hashing, pretty-printing, and project membership checks, along with deep copying and type descriptors for integration with Frama-C's internal machinery. It is used to manage collections of logic constant-indexed data in a type-safe and efficient manner, particularly in static analysis plugins requiring precise value tracking.",
      "description_length": 503,
      "index": 2384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table that maps interpreted automaton edges to associated values. It provides standard operations including equality, comparison, hashing, and pretty-printing, enabling efficient storage and retrieval of edge-related data. Concrete use cases include tracking edge-specific metadata such as analysis results or transformation rules during abstract interpretation.",
      "description_length": 418,
      "index": 2385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line options with support for value setting, change tracking via hooks, default retrieval, alias handling, and validation against predefined lists or function names. It operates on string data augmented with constraints, enabling use cases like safe parameter parsing, project-specific state management, and serialization of validated configurations.",
      "description_length": 391,
      "index": 2386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are properties ordered by a specific function, and values are of the type provided by the `Data` module. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the entire map. It is suitable for tracking property-indexed data in static analysis plugins, such as associating per-property analysis results or metadata.",
      "description_length": 453,
      "index": 2387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered, immutable sets for managing versioned states in control flow graphs, supporting operations like union, intersection, and difference alongside ordered iteration, filtering, and transformation. It works with elements of type `Version.t`, leveraging a user-defined total order to enable efficient membership checks, extremum selection, and nearest-neighbor queries. These sets are particularly useful in abstract interpretation tasks such as tracking reachable states or analyzing loop unrolling paths, where precise ordering and version comparison are critical for correctness.",
      "description_length": 607,
      "index": 2388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling file paths as a registered data type within a plugin, including equality, comparison, hashing, and pretty-printing functions. It supports the `Datatype.t` type, representing file paths, and provides utilities for deep copying values and checking membership within projects. Concrete use cases include managing and comparing file path data in static analysis plugins, such as tracking source file locations or analyzing file-based dependencies.",
      "description_length": 487,
      "index": 2389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table that stores global annotations associated with CIL (C Intermediate Language) elements. It provides operations for equality checking, comparison, hashing, and pretty-printing these keys, along with functions for deep copying and inspecting project membership. The key type is specifically designed to represent and manipulate global annotations in the context of Frama-C plugin development, enabling efficient and precise tracking of analysis data tied to C program elements.",
      "description_length": 536,
      "index": 2390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table mapping memory locations to byte-based offsets, supporting operations like equality, comparison, hashing, and pretty-printing. It works with the `Location_Bytes.Hashtbl.key` type, which represents memory locations in terms of base pointers and byte offsets. Concrete use cases include tracking and manipulating memory regions during static analysis, such as in pointer analysis or memory model implementations.",
      "description_length": 452,
      "index": 2391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling map keys, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing map keys and supports operations like deep copying, membership testing within projects, and provides descriptors for type representation. It is used to manage key values in maps where project-specific filtering, structural comparison, and serialization are required.",
      "description_length": 431,
      "index": 2392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by `Compinfo` values, with values determined by the provided `Data` module. It supports standard map operations including lookup, insertion, and traversal, along with serialization, comparison, and pretty-printing. It is used to associate structured data with CIL component info entries in Frama-C analyses and plugins.",
      "description_length": 360,
      "index": 2393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype based on a provided `Data` module, supporting standard operations like `equal`, `compare`, `hash`, and `pretty`. It works with key-value pairs where the key type is defined by the `Data` module and the value type is determined by the map's construction. Concrete use cases include managing symbol tables, tracking variable associations, and implementing configurations where keys and values have well-defined equality and ordering.",
      "description_length": 466,
      "index": 2394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, project membership checks, and type descriptors for integration with the Frama-C kernel. Use cases include managing collections of values with efficient lookups and persistence across analysis sessions.",
      "description_length": 381,
      "index": 2395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps used in model information handling, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Model_info.Map.key` type, which represents keys in a map structure tied to CIL model data. Concrete use cases include managing and comparing keys that identify model elements in static analysis plugins, such as tracking project-specific values and ensuring deep copies for correct state manipulation.",
      "description_length": 466,
      "index": 2396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores memory zone bases, including operations for equality, comparison, hashing, and pretty-printing. It supports data types that represent memory base keys, along with functions to check membership based on project properties and perform deep copies. It is used to manage and manipulate keys in a hash table that tracks valid memory zones within an analysis context.",
      "description_length": 423,
      "index": 2397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a map key type with strict structural equality for expressions, providing standard operations like comparison, hashing, and pretty-printing. It works with CIL expressions and project-specific data through deep copying and membership checks. Concrete use cases include managing expression-based keys in maps for analysis plugins, ensuring strict equality and efficient lookup.",
      "description_length": 395,
      "index": 2398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are term offsets and values are of the `Data` type. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings involving CIL term offsets in Frama-C plugins.",
      "description_length": 334,
      "index": 2399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing command-line parameters, providing operations to define, enable, and modify categories with specific accessors and dependencies. It works with the `t` type, which represents categories, and interacts with `State.t` lists to control parameter behavior. Use cases include creating custom parameter groups, setting default category behavior, and enabling the '@all' category to control aggregate parameter interpretation.",
      "description_length": 477,
      "index": 2400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store and manage logic real values in the CIL intermediate language. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to implement efficient, type-safe mappings involving logic real expressions in static analysis plugins for Frama-C.",
      "description_length": 406,
      "index": 2401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types tied to plugin parameters and state dependencies, enabling precise control over plugin behavior through named categories and accessors. Concrete use cases include setting up configurable parameter groups for analysis plugins, where categories dictate how parameters are interpreted and activated during analysis.",
      "description_length": 515,
      "index": 2402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for CIL expressions, providing structural equality, comparison, and hashing operations based on expression identity (`eid`). It supports working with `Exp.Hashtbl.key` values, enabling efficient storage and retrieval of CIL expressions in hash tables. Use cases include caching analysis results per expression or grouping expressions based on their structural identity in static analysis plugins.",
      "description_length": 438,
      "index": 2403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining command-line parameters that accept string values validated against a predefined set of allowed options or function names. It works with string-based data structures to enforce constraints, offering retrieval of validated values, alias handling, and hooks for state changes. Typical use cases include plugin configuration options requiring restricted input (e.g., selecting from enumeration-like sets or valid function identifiers) with automatic error handling for invalid entries.",
      "description_length": 527,
      "index": 2404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where values are of a specified type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate collections of values in a way that ensures structural consistency and efficient lookup.",
      "description_length": 365,
      "index": 2405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.WithOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling precise data manipulation and analysis. Concrete use cases include managing abstract values, analyzing program states, and implementing custom data structures within Frama-C's analysis framework.",
      "description_length": 468,
      "index": 2406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines hash table keys based on normalized filepaths, providing equality, comparison, and hashing operations tailored for type-safe string handling. It supports structured data management with functions for deep copying, pretty printing, and checking project membership within key values. Use cases include tracking file-based identifiers in analysis plugins or managing unique, normalized path representations in a hash table.",
      "description_length": 440,
      "index": 2407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module defines command-line parameters that store single string values, supporting operations like validation against predefined allowed values, update hooks, and alias resolution. It manages parameters as maps without multibindings, providing functions to enforce constraints (e.g., valid function names) or retrieve unvalidated strings, with state persistence across projects. It is suited for configuring analysis tools where strict parameter validation is required, such as restricting inputs to specific identifiers or formats.",
      "description_length": 537,
      "index": 2408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are syntactic scopes and values are of a specified data type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions. It is used to manage and manipulate scope-indexed data in CIL-based analyses, such as tracking variable bindings or analysis states per scope.",
      "description_length": 378,
      "index": 2409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, project membership checks, and type descriptors for structural representation. Use cases include managing dynamic collections of `Data.t` values with efficient lookups and persistence across analysis sessions.",
      "description_length": 388,
      "index": 2410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that represent logic types without unrolling, including operations for equality, comparison, hashing, and pretty-printing. It works with CIL logic types and project-based data, supporting deep copying and membership checks over project skeletons. Use this module to manage and manipulate keys in maps that index logic types in a CIL analysis context.",
      "description_length": 390,
      "index": 2411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on CIL lvalues, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with `Lval` structures, using `eid`-based equality, and includes utilities for deep copying, checking project membership, and type representation. Concrete use cases include managing and tracking CIL lvalue-based identifiers in static analysis plugins, such as value abstractions or program property mappings.",
      "description_length": 478,
      "index": 2412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables where keys are based on CIL statement identifiers. It provides standard operations including equality, comparison, hashing, and pretty printing for these keys. The module supports efficient key-based lookups and ensures deep copying and project membership checks for analysis-specific data.",
      "description_length": 343,
      "index": 2413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.Parameter_category.t` and associated state lists, allowing the association of accessors and dependencies with each category. Concrete use cases include setting up default behavior for option groups, enabling all options under a unified category, and defining how negative occurrences of `@all` are interpreted.",
      "description_length": 522,
      "index": 2414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for CIL function definitions, enabling efficient storage and retrieval of function data. It supports operations like equality checks, comparison, hashing, and pretty-printing for analysis and transformation tasks. Use cases include tracking function properties across CIL AST traversals and managing plugin-specific function metadata during static analysis.",
      "description_length": 402,
      "index": 2415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by `Logic_type_info` values, where each map entry holds a value of a specified `Data` type. It supports standard operations including equality, comparison, hashing, pretty-printing, and deep copying, as well as project membership checks. It is suitable for tracking logic type-specific metadata across different analysis projects in static analysis plugins.",
      "description_length": 407,
      "index": 2416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, providing standard operations including equality, comparison, hashing, and pretty-printing. It works with a specific key type derived from CIL model information, enabling efficient storage and retrieval of model-related data. Concrete use cases include managing model-specific metadata in a thread-safe, project-aware manner, particularly during static analysis tasks in Frama-C plugins.",
      "description_length": 441,
      "index": 2417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps associated with usable emitters, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that can be used as keys in map structures, ensuring deep copying and project membership checks. Concrete use cases include managing and distinguishing emitter-related data within Frama-C's analysis framework, such as tracking annotation sources or property statuses tied to specific projects.",
      "description_length": 476,
      "index": 2418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that use `OffsetStructEq`-equivalent keys, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured keys derived from CIL types, enabling precise key management in maps used for analysis or transformation passes in Frama-C plugins. Concrete use cases include tracking struct offsets in memory models or mapping struct fields to analysis results.",
      "description_length": 438,
      "index": 2419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table type where keys are bases and values are memory maps offset by a base address. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate memory state representations in static analysis plugins.",
      "description_length": 351,
      "index": 2420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set-like datatype with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with project membership checks and deep copying, tailored for plugin-specific data management. Use cases include tracking analysis states or managing project-specific metadata in Frama-C plugins.",
      "description_length": 350,
      "index": 2421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing hash table keys and includes functions for deep copying values, checking membership based on project criteria, and describing the type. Concrete use cases include managing and manipulating keys in custom hash table implementations and ensuring type-safe, consistent key handling across different modules.",
      "description_length": 491,
      "index": 2422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associating functions (`Fundec`) with data in the context of Frama-C's CIL representation. It supports equality checks, comparison, hashing, and pretty-printing for these keys, enabling efficient storage and retrieval in map structures. Concrete use cases include managing function-specific analyses or annotations across different projects within Frama-C plugins.",
      "description_length": 417,
      "index": 2423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with hash tables where keys and values are based on the `Data` module's type. Concrete use cases include managing logic type information with unique keys, such as tracking and comparing typed expressions or logic variables in static analysis plugins.",
      "description_length": 438,
      "index": 2424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage string-based plugin parameters in Frama-C, including validation against predefined values or function identifiers, command-line parsing, and state synchronization across projects. It handles string parameters with customizable constraints, supporting features like default values, deprecation notices, and serialization for persistent state tracking. Typical use cases involve defining plugin options that require strict value validation, function name resolution, or integration with Frama-C's analysis workflows and project management systems.",
      "description_length": 585,
      "index": 2425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are based on the `Model_info` type and values are of a specified `Data` module type. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project membership checks. It is used to manage and manipulate mappings involving CIL model information in a type-safe and structured way.",
      "description_length": 401,
      "index": 2426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing collections of files as strings, supporting operations such as equality, comparison, hashing, and pretty printing. It works with file lists passed via command-line parameters, enabling deep copies, membership checks based on project properties, and structured serialization. Concrete use cases include handling input file sets during static analysis and managing file-based configurations in plugin development.",
      "description_length": 460,
      "index": 2427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by logic types without unrolling, where each value is of a specified `Data` module type. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, ensuring structural integrity and project-specific membership checks. It is suitable for managing and manipulating logic type-indexed data in static analysis plugins, such as tracking type-specific annotations or analysis results.",
      "description_length": 481,
      "index": 2428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for handling string-based command-line parameters that represent function declarations (`Fundec`) or function names. It supports value validation, alias resolution, and project-specific state management, working with strings that must conform to predefined allowed values or syntactic constraints. Typical use cases include parsing and validating function name arguments in command-line tools, converting raw inputs into structured values, and generating help documentation with default or allowed value summaries.",
      "description_length": 546,
      "index": 2429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Zero.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command-line option parsing with support for defining, comparing, and serializing custom data types. Provides operations for equality checks, hashing, pretty-printing, and deep copying values, ensuring consistent handling of structured data. Useful for plugin developers needing to register and manage typed configuration options within Frama-C.",
      "description_length": 356,
      "index": 2430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps over CIL offsets, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with CIL offset values that include project-specific data, enabling key functionality such as deep copying, membership testing, and structural representation. Concrete use cases include managing and querying structured offset data in static analysis plugins, such as tracking memory layout or field positions in C structures.",
      "description_length": 496,
      "index": 2431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables that map memory location zones to values. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate keys representing memory zones in static analysis plugins for Frama-C.",
      "description_length": 366,
      "index": 2432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for CIL type values, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data structures involving CIL types with deep copying, membership checks over projects, and type descriptors for runtime handling. Concrete use cases include managing type-specific metadata across CIL structures in static analysis plugins.",
      "description_length": 413,
      "index": 2433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line arguments in Frama-C's kernel, specifically for the `-cpp-extra-args` option. It provides operations for equality checking, comparison, hashing, pretty printing, and deep copying of these string arguments, ensuring proper handling of project-specific values. It is used to manage and manipulate string collections passed to the C preprocessor during analysis.",
      "description_length": 430,
      "index": 2434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing map keys based on integers, including equality, comparison, hashing, and pretty-printing. It supports data types involving `Frama_c_kernel.Datatype.Int.Map.key` and provides utilities for deep copying, membership testing within projects, and handling type descriptors. Concrete use cases include building and manipulating maps keyed by integer values in static analysis plugins.",
      "description_length": 436,
      "index": 2435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are global annotations and values are of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project membership checking. It is used to manage and manipulate maps of CIL global annotations in Frama-C plugins.",
      "description_length": 343,
      "index": 2436,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with logic constants stored in a hash table structure, providing deep copying, membership checks over projects, and type descriptors for integration with Frama-C's analysis infrastructure. Concrete use cases include managing collections of logic expressions or annotated values during static analysis, where each entry must be uniquely identified, compared, or serialized for display.",
      "description_length": 572,
      "index": 2437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype specialized for filepaths, providing standard operations like `equal`, `compare`, `hash`, and `pretty`. It supports type-safe manipulation of filepaths as keys, ensuring normalized handling and project-aware membership checks via `mem_project`. Useful for tracking and comparing sets of filepaths in static analysis plugins.",
      "description_length": 354,
      "index": 2438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored to handle CIL structure offsets with equality semantics. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, along with utilities for project membership testing and deep copying. The key type is used to uniquely identify and manage structural offsets in the context of CIL-based analyses, ensuring consistent handling across different modules and operations.",
      "description_length": 483,
      "index": 2439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for hash-consed trees managed by the underlying Patricia tree implementation. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring compatibility with hash table manipulations. Concrete use cases include managing unique identifiers for abstract syntax tree nodes or other hash-consed structures in static analysis tasks.",
      "description_length": 455,
      "index": 2440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by memory locations associated with byte offsets, where each map value adheres to the provided `Data` module's type. It supports standard map operations such as lookup, insertion, and traversal, along with equality, comparison, and hashing for use in data structures like hash tables. Concrete use cases include tracking per-location metadata, such as analysis results or annotations, where each memory location's byte offset is significant.",
      "description_length": 476,
      "index": 2441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of functions for managing a collection of function declarations (`Fundec`) within a Frama-C plugin. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of function declaration data, along with project membership testing. It is used to track and manipulate sets of function definitions in static analysis plugins, enabling precise handling of C function semantics across different analysis contexts.",
      "description_length": 474,
      "index": 2442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for vertices in an interpreted automaton, supporting operations like equality, comparison, hashing, and pretty-printing. It works with vertex data structures that include project-specific information, enabling efficient lookups and manipulations in hash tables. Concrete use cases include tracking control points in a program's abstract interpretation and managing transitions with associated guards and actions.",
      "description_length": 454,
      "index": 2443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are based on `Logic_info` with structural comparison and values are of a provided `Data` type. It supports standard operations like equality, comparison, hashing, and pretty printing, along with project-aware membership checks and deep copying. It is used to manage structured logic information in a hash table while preserving type-specific properties and relationships.",
      "description_length": 424,
      "index": 2444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a map where each key is a string-based datatype. It provides functions for equality checks, comparison, hashing, and pretty-printing keys, along with deep copying and project membership checks. It is used when implementing or manipulating string-keyed maps that require structural and project-aware operations.",
      "description_length": 362,
      "index": 2445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are attributes and values are of the type provided by the `Data` parameter. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage attribute-value mappings in CIL-based analyses, such as tracking function or variable annotations during static analysis.",
      "description_length": 408,
      "index": 2446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables managing string-based configuration parameters for plugins, offering operations to define allowed values, validate inputs against predefined lists or patterns, and handle serialization with custom marshaling. It works with individual strings and string lists, supporting use cases like tracking project-specific settings, enforcing valid command-line argument subsets, or dynamically updating values through registered callbacks. The module also facilitates alias resolution and default value handling in plugin configuration scenarios.",
      "description_length": 556,
      "index": 2447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps over `Kinstr` values, including equality, comparison, hashing, and pretty-printing. It supports data types that represent instructions in CIL (C Intermediate Language) and provides utilities to manage their identity and structure. Use cases include tracking and comparing individual instructions during static analysis or transformation passes in Frama-C plugins.",
      "description_length": 416,
      "index": 2448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps over CIL enumeration information, including equality, comparison, hashing, and pretty-printing. It supports data types representing keys for mapping CIL enum definitions, with functions to check membership in projects and perform deep copies. Concrete use cases include managing and querying enum-related data across different analysis contexts in Frama-C plugins.",
      "description_length": 417,
      "index": 2449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that conforms to the `Data` module signature, enabling structured storage and retrieval of values within Frama-C's analysis framework. Concrete use cases include managing sets of program analysis results or configuration parameters with custom value types.",
      "description_length": 461,
      "index": 2450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing kernel functions within a plugin, allowing the creation and configuration of named categories with associated accessors and dependencies. It works with category types and state lists to define how functions are interpreted and enabled. Concrete use cases include defining a category for all functions (`@all`), setting a default category, or enabling functions under specific conditions using state lists.",
      "description_length": 464,
      "index": 2451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps representing memory bases within the Value analysis plugin. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used efficiently in map structures. It also supports deep copying and project membership checks, enabling precise manipulation and analysis of memory states.",
      "description_length": 391,
      "index": 2452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, using CIL locations as keys. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings from CIL locations to custom data values within Frama-C plugins.",
      "description_length": 373,
      "index": 2453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores CIL term lhost values, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports efficient key-based lookups and ensures structural integrity for term lhost data used in static analysis plugins. Use cases include tracking and managing term lhost entries in analysis contexts where persistence, comparison, and project-specific filtering are required.",
      "description_length": 456,
      "index": 2454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table that stores CIL enumeration information. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. The keys are specifically designed to manage and manipulate CIL enum data within analysis plugins.",
      "description_length": 344,
      "index": 2455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that use `Term_lhost` values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working directly with `Term_lhost` keys in map structures, ensuring proper handling of their identity and structure. Use cases include tracking and managing term-based memory locations in static analysis plugins.",
      "description_length": 381,
      "index": 2456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are compared using structural equality based on the `ExpStructEq` semantics. It supports operations like equality checking, comparison, hashing, and pretty-printing for values stored in the hash table. A concrete use case is managing CIL expressions or structured data with semantic equivalence, such as tracking equivalent code fragments or expressions across different program states.",
      "description_length": 439,
      "index": 2457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps where each key is a kernel function from the `Hptset`. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate individual kernel functions as unique identifiers within map structures.",
      "description_length": 361,
      "index": 2458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in a hash table for managing abstract memory values, specifically tailored for byte-indexed locations and scalar values like integers and floats. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to efficiently store and retrieve abstract values indexed by memory locations or scalar identifiers in static analysis contexts.",
      "description_length": 472,
      "index": 2459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based plugin parameters in Frama-C, including validation, alias handling, and marshaling, with support for command-line configuration and project state persistence. It operates on strings, string lists, and pattern-based validators to enforce constraints on acceptable values, particularly for function name parameters. Use cases include defining configurable options for plugins, validating user-provided strings against predefined patterns, and synchronizing parameter changes with external systems.",
      "description_length": 553,
      "index": 2460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set of operations for managing and comparing kernel functions within a plugin, including equality, comparison, hashing, and pretty-printing. It works with the `t` type, representing kernel functions, and supports project membership checks and deep copying. Concrete use cases include tracking function representations, ensuring unique identification, and facilitating analysis across different project contexts.",
      "description_length": 433,
      "index": 2461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for boolean keys, where each hash table maps keys to values of a specified data type. It provides standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage boolean-keyed hash tables in Frama-C plugins, particularly when tracking or analyzing program states tied to boolean conditions.",
      "description_length": 446,
      "index": 2462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a map structure, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing map keys and supports operations like `equal`, `compare`, `hash`, and `pretty`. Concrete use cases include efficiently comparing and printing key values within map data structures.",
      "description_length": 361,
      "index": 2463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on CIL constants with strict comparison semantics, including textual representation. It supports standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate map keys in static analysis plugins requiring precise constant handling.",
      "description_length": 398,
      "index": 2464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL locations and values are of the `Data` module's type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project membership checks. It is used to associate and manipulate data with specific positions in C source code, such as tracking variable states or analysis results at specific program points.",
      "description_length": 419,
      "index": 2465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.Key.t` type, offering functions to manage key representations, descriptors, and project membership checks. Concrete use cases include managing unique identifiers in analysis plugins and ensuring consistent key handling across different hash table implementations.",
      "description_length": 428,
      "index": 2466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, specifically tailored to handle CIL offset values with structural equality. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, ensuring keys can be efficiently stored and retrieved. Use cases include managing and tracking CIL offset data within analysis plugins, where unique identification and structural equivalence are critical.",
      "description_length": 436,
      "index": 2467,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by logic variables, with values parameterized by the `Data` module. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the map itself. It is used to manage collections of logic variable bindings in a type-safe manner, suitable for analysis and transformation tasks in the Frama-C environment.",
      "description_length": 428,
      "index": 2468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL code annotations, enabling efficient storage and retrieval of annotated data associated with C code elements. Concrete use cases include tracking function-specific annotations or maintaining mappings between CIL constructs and plugin-generated metadata during analysis.",
      "description_length": 466,
      "index": 2469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype with keys of type `Data.t`, using structural equality and strict constant comparison for key comparisons. It provides standard operations including equality, comparison, hashing, pretty-printing, and deep copying, along with a type descriptor and representants for the hash table. Concrete use cases include managing collections of CIL expressions with strict equality semantics, such as tracking sets of expressions across different analysis states or caching results of expression evaluations.",
      "description_length": 537,
      "index": 2470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with CIL component information (`Compinfo`) in a type-safe manner, enabling efficient lookups and manipulations. Concrete use cases include managing and querying collections of CIL entities such as functions, global variables, or types during static analysis or transformation passes.",
      "description_length": 482,
      "index": 2471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are properties ordered by function criteria, including kernel function name, kinstr, property kind, and property ID. It provides standard operations like comparison, equality, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate property-based keys in map structures within Frama-C's analysis framework.",
      "description_length": 437,
      "index": 2472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables structured manipulation of command-line parameters representing file paths and function names, offering operations to set, validate, and retrieve values while supporting change tracking, default handling, and project-specific state integration. It works with string-based data structures and is used in Frama-C plugins to manage file path options, enforce valid function name arguments, and customize parameter marshaling during analysis configurations.",
      "description_length": 473,
      "index": 2473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for abstract memory values, where keys are indexed locations and values represent bytes in memory. It supports standard hash table operations like equality, comparison, hashing, and pretty-printing, tailored for analyzing C programs' memory states. Concrete use cases include tracking variable bindings during static analysis and managing memory abstractions in value analysis plugins.",
      "description_length": 445,
      "index": 2474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map implementation based on hash-consed trees. It includes standard operations such as equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copying. The key type is used to index into a map structure where keys are hash-consed trees, enabling efficient lookups and memory usage. Concrete use cases include managing unique identifiers for abstract syntax trees in static analysis tools, where fast key comparisons and structural sharing are critical.",
      "description_length": 573,
      "index": 2475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table specific to field information in CIL. It provides equality, comparison, hashing, and pretty-printing functions for these keys, which are essential for managing and querying field data in static analysis plugins. Use cases include tracking and comparing structural elements of C programs during analysis, such as identifying and handling struct fields uniquely.",
      "description_length": 421,
      "index": 2476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling string-based data types used in command-line option autocompletion. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with utilities for project membership checks and deep copying. It works directly with string representations of data types, supporting autocompletion logic for command-line parameters in Frama-C plugins.",
      "description_length": 418,
      "index": 2477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of the `Data` module, with operations including equality, comparison, hashing, and pretty printing. It supports project-aware membership checks, deep copying, and provides type descriptors for integration with Frama-C's typing and serialization systems. Concrete use cases include managing and querying collections of typed, project-scoped data elements during static analysis.",
      "description_length": 438,
      "index": 2478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps where keys are based on CIL expressions, using their unique identifiers for equality and comparison. It provides standard operations like `equal`, `compare`, `hash`, and `pretty` for working with these expression-based keys in data structures and user output. Use cases include tracking or indexing CIL expressions uniquely within analyses or transformations that require structural identity based on expression identifiers.",
      "description_length": 467,
      "index": 2479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map type for values of a specified data module, using hash-consed trees as keys. It supports operations like equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used when associating structured values with keys derived from hash-consed tree representations, enabling efficient lookups and manipulations tied to the tree's structure.",
      "description_length": 425,
      "index": 2480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are based on the `Data` module's type and values are instances of a specified type. It supports standard map operations such as `equal`, `compare`, `hash`, and `pretty`, along with deep copying and project membership checks. It is used to manage structured collections of analysis data indexed by a specific key type in Frama-C plugins.",
      "description_length": 382,
      "index": 2481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure where keys are wide strings and values are of a specified type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with maps (`t`) built from key-value pairs, where keys are wide strings and values are determined by the `Data` module. Concrete use cases include managing collections of CIL-related data indexed by wide strings, such as symbol tables or configuration settings in static analysis plugins.",
      "description_length": 490,
      "index": 2482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, with operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases like tracking and comparing sets of memory base values in static analysis plugins. The module also provides deep copying, membership checks over projects, and type descriptors for integration with Frama-C's internal systems.",
      "description_length": 414,
      "index": 2483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure where keys are hash-consed trees and values are of a specified `Data` type, using big-endian Patricia trees for efficient lookups and updates. It supports operations like equality checking, comparison, hashing, pretty printing, and deep copying, along with project membership queries. It is suitable for managing structured, hierarchical data with efficient access and manipulation, such as abstract syntax trees or semantic representations in program analysis.",
      "description_length": 497,
      "index": 2484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.WithOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured datatype with support for equality, comparison, hashing, and pretty-printing operations. It handles values of type `Datatype.t`, providing deep copy functionality and project membership checks. Concrete use cases include managing command-line option values with custom representations and descriptors for analysis tools.",
      "description_length": 353,
      "index": 2485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are determined by the `Data` module and values are stored with support for equality, comparison, hashing, and pretty-printing. It provides operations to check membership based on project conditions, perform deep copies, and expose type information for integration with Frama-C's internal systems. Concrete use cases include managing collections of typed values indexed by specific keys, such as tracking variable states or analysis results in a Frama-C plugin.",
      "description_length": 500,
      "index": 2486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control plugin behavior through accessors and dependencies. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific states, or aliasing the `@all` category to another category.",
      "description_length": 448,
      "index": 2487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate global annotations with specific keys derived from CIL (C Intermediate Language) elements. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and checking the presence of project-related data. It is used to manage and manipulate keys that uniquely identify global annotations within the context of CIL-based analyses.",
      "description_length": 438,
      "index": 2488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing these keys. It supports working with project-related data by allowing checks on embedded project skeletons and enabling deep copies of key values. Concrete use cases include managing and tracking internal states within a project, such as ensuring uniqueness and handling project-specific data representations.",
      "description_length": 451,
      "index": 2489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with the `Frama_c_kernel.Parameter_category.t` type, allowing creation of categories like `@none`, `@default`, and `@all`, and controls how these categories interact with plugin states. Concrete use cases include setting up configurable behavior for plugin parameters, enabling or disabling groups of parameters collectively, and defining fallback or global categories for consistent state management.",
      "description_length": 584,
      "index": 2490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure specialized for a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with key-value pairs where values conform to the `Data` module's type and provides deep copying and project membership checks. Concrete use cases include managing machine-dependent configurations or mappings between identifiers and structured values in static analysis contexts.",
      "description_length": 455,
      "index": 2491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps that associate CIL component information with other data. It supports key comparison, equality, hashing, and pretty-printing, enabling efficient and readable manipulation of map keys. Concrete use cases include tracking and managing CIL components such as variables or functions within analysis plugins.",
      "description_length": 356,
      "index": 2492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL types with structural comparison and no unrolling of types. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. Concrete use cases include managing and querying collections of CIL types in a hash table without expanding composite types during comparison.",
      "description_length": 450,
      "index": 2493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are identifiers and values are of type `Data.t`. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project membership checks. It is suitable for managing collections of structured data indexed by identifiers in static analysis plugins.",
      "description_length": 348,
      "index": 2494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.key` type, providing utilities to manage key values within a map structure. Concrete use cases include efficient key-based lookups, set operations, and map traversals.",
      "description_length": 332,
      "index": 2495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps that identifies CIL types by structural equivalence, handling comparisons and hashing based on type definitions rather than identifiers. It supports operations like equality checking, comparison, deep copying, and pretty-printing for type keys, which are used to uniquely represent CIL types in a map structure. Concrete use cases include managing type-based analyses and ensuring consistent type handling across CIL transformations.",
      "description_length": 476,
      "index": 2496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps with operations for equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing logic type map keys, supporting efficient lookups and structural manipulations. Concrete use cases include managing and comparing keys in maps that track logic type information during static analysis.",
      "description_length": 355,
      "index": 2497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by strings, where the values are of a specified type provided by the `Data` module. It includes standard operations for equality, comparison, hashing, and pretty-printing, as well as support for project membership checks and deep copying. It is used to manage string-indexed collections of values with full semantic support in Frama-C's analysis framework.",
      "description_length": 397,
      "index": 2498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Custom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered custom data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured values through a descriptor and provides deep copying, project membership checks, and representant handling. Concrete use cases include managing analysis-specific data within Frama-C plugins, such as abstract states or custom annotations.",
      "description_length": 383,
      "index": 2499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for CIL variable information, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with `Varinfo` structures to support efficient lookups and storage in hash tables. Concrete use cases include managing variable metadata across different analysis phases and tracking variable occurrences in C programs.",
      "description_length": 386,
      "index": 2500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype with operations like `equal`, `compare`, `hash`, and `pretty` for value types that support comparison and hashing. It works with key-value pairs where the value type is equipped with equality, ordering, and hash functions. It is suitable for building typed maps used in static analysis to track value states across program points.",
      "description_length": 365,
      "index": 2501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based datatype for managing collections of values with customizable equality and hashing. It provides operations for comparing, hashing, and pretty-printing hash tables, along with deep copying and membership checks based on project-specific predicates. It is used when building structured datatypes that require efficient lookups and value tracking in analysis plugins.",
      "description_length": 406,
      "index": 2502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are compared using structural equality on CIL types that include offset information. It supports operations like equality checking, comparison, hashing, and pretty-printing for values stored in the hash table. Concrete use cases include managing and comparing CIL-based data structures with precise offset tracking during static analysis.",
      "description_length": 391,
      "index": 2503,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with `Varinfo` values, including equality, comparison, hashing, and pretty-printing. It supports data types that represent variables in CIL, enabling efficient key-based lookups and manipulations. Concrete use cases include managing variable-specific metadata across different analysis passes in Frama-C plugins.",
      "description_length": 365,
      "index": 2504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure parameterized by a `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing for values stored in the table. It works with abstract memory representations defined by the `Frama_c_kernel.Cvalue` module, specifically mapping bases to memory slices. Concrete use cases include managing and manipulating abstract memory states during static analysis, such as tracking variable bindings or memory regions in value analysis.",
      "description_length": 512,
      "index": 2505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Bool.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean datatype with standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying and membership testing within project contexts. Concrete use cases include managing boolean configuration flags and state values in Frama-C plugins.",
      "description_length": 299,
      "index": 2506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command line parameters linked to kernel functions, enabling value setting, retrieval with validation against function names, and alias handling. It operates on string values and function declarations, supporting use cases like restricting parameter inputs to a whitelist of valid function identifiers or serializing configuration states. Key patterns include integrating hooks for dynamic value modification and ensuring parameter consistency with project-specific function definitions.",
      "description_length": 520,
      "index": 2507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command-line options for string parameters with operations for equality, comparison, hashing, and pretty-printing. Works with string-based data types and project-specific configurations. Used to define and manage string-valued analysis options in Frama-C plugins.",
      "description_length": 274,
      "index": 2508,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It works with the abstract key type and project-related values, supporting deep copies and membership checks over project skeletons. Concrete use cases include managing and comparing keys in a hash table that stores analysis-specific data indexed by these keys.",
      "description_length": 400,
      "index": 2509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype with values based on the `Data` module, using structural equality and strict constant comparison. It supports standard operations like `equal`, `compare`, `hash`, and `pretty`, along with deep copying and project membership checks. This module is useful for managing collections of CIL values in a type-safe and efficiently hashable form.",
      "description_length": 368,
      "index": 2510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for CIL code annotations, where keys are associated with values of the provided `Data` module type. It supports standard map operations including equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage and manipulate mappings tied to CIL elements in Frama-C plugins, such as associating metadata or analysis results with specific code annotations.",
      "description_length": 481,
      "index": 2511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic type names and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings involving logic types in CIL-based analyses.",
      "description_length": 344,
      "index": 2512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Int.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered integer-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports project membership checks and deep copying, ensuring no shared references between original and copied values. It is used to manage and manipulate integer values within Frama-C plugins, providing necessary functionality for analysis and transformation tasks.",
      "description_length": 397,
      "index": 2513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for list-typed parameters, providing operations to define, parse, and manipulate list values. It works with a list of representants of a given datatype, supporting equality checks, comparison, hashing, and pretty printing. Concrete use cases include defining options that accept multiple values, such as file paths or analysis targets, and ensuring consistent handling of list-based configurations.",
      "description_length": 450,
      "index": 2514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given data type, using `Location_Bits` to manage memory locations at the bit level. It supports operations like equality checking, comparison, hashing, and pretty printing, tailored to the provided `Data` module. Concrete use cases include tracking and manipulating sets of bit-level memory locations with efficient lookups and storage.",
      "description_length": 402,
      "index": 2515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a map structure, providing essential operations such as equality, comparison, hashing, and pretty printing. It supports data types related to `Frama_c_kernel.Datatype.Unit.Map.key`, including handling project membership checks and deep copying of key values. Concrete use cases include managing and manipulating map keys in static analysis plugins, particularly when tracking project-specific data across different analysis phases.",
      "description_length": 479,
      "index": 2516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in attribute maps, including equality, comparison, hashing, and pretty-printing. It supports data types that represent attributes in CIL, such as identifiers or structured keys with project-specific data. Use cases include managing and comparing keys when storing or retrieving CIL attributes in maps, particularly during static analysis tasks like tracking variable annotations or function properties.",
      "description_length": 447,
      "index": 2517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores and compares CIL term offsets. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be efficiently used in hash tables. The module also supports deep copying and introspection of keys for project-specific filtering.",
      "description_length": 351,
      "index": 2518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL types ignoring attributes and values are of a specified data type. It provides standard map operations including comparison, equality, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include managing type-indexed data in CIL analyses, such as tracking type-specific properties or annotations across C program elements.",
      "description_length": 422,
      "index": 2519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map specialized for values of type `Data.t`, offering standard operations like comparison, hashing, and pretty printing. It supports maps with keys tied to the `Declaration` module's structure, enabling efficient lookups and manipulations. Use it to manage and transform declaration-associated data with strong type guarantees, such as tracking analysis results per declaration across different projects.",
      "description_length": 426,
      "index": 2520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for expressions with structural equality in the context of CIL-based analysis. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking the presence of project-related data. It is used to manage and manipulate keys that represent CIL expressions in a way that supports efficient storage and retrieval in analysis plugins.",
      "description_length": 485,
      "index": 2521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for code annotations in the CIL framework. It provides standard operations including equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copying. The key type supports structured data representation and is used to manage and manipulate annotated code elements in static analysis plugins.",
      "description_length": 423,
      "index": 2522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Action.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured datatype with support for comparison, hashing, pretty-printing, and deep copying, tailored for command-line option handling. It works with a specific type `t` and associated descriptor structures, providing precise equality checks, memory project queries, and user-friendly value representation. Concrete use cases include defining and managing configurable parameters in Frama-C plugins with strict type safety and persistence guarantees.",
      "description_length": 472,
      "index": 2523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and manipulating service graphs, which are derived from callgraphs to compute analysis services. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of service graph instances, along with support for project membership queries. The module works directly with `Service_graph.t` and integrates with Frama-C's project system to enable analysis-specific data management and traversal.",
      "description_length": 475,
      "index": 2524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are labels and values are of a specified data type, providing standard operations like comparison, equality, hashing, and pretty-printing. It supports structured data management with deep copying, project membership checks, and type-safe representations. Concrete use cases include tracking label-value associations in CIL-based analyses, such as mapping variable labels to their associated data during static analysis.",
      "description_length": 459,
      "index": 2525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify predicates in CIL-based analyses. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checks over project skeletons. The keys are used to manage and query predicate-specific data within static analysis plugins.",
      "description_length": 364,
      "index": 2526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing keys for a map that associates memory locations with byte-level offsets. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and membership checks over projections. These keys are used to manage and manipulate memory location mappings in static analysis plugins, enabling precise tracking and transformation of memory states.",
      "description_length": 439,
      "index": 2527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.key` type, providing utilities to manage key values within a map structure. Concrete use cases include efficient key-based lookups, set operations, and serialization for analysis plugins.",
      "description_length": 352,
      "index": 2528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters that support multiple bindings, allowing the definition and manipulation of named categories with associated states and accessors. It provides operations to create, enable, and configure categories such as `@none`, `@default`, and `@all`, each controlling how parameters are interpreted and activated. Use cases include organizing related command-line options into logical groups and defining how they should be enabled or disabled together.",
      "description_length": 500,
      "index": 2529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter collections, using accessors and state dependencies to control behavior. Concrete use cases include setting up configurable groups of parameters with shared activation rules and default interpretations.",
      "description_length": 423,
      "index": 2530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with the `Frama_c_kernel.Parameter_category.t` type, which encapsulates category behavior and dependencies. Concrete use cases include setting up default category behavior, enabling all options with specific interpretations, and defining custom categories with associated accessors and dependencies.",
      "description_length": 490,
      "index": 2531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are global variables and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It provides functionalities to manage and manipulate such maps, including deep copying, membership testing with project filtering, and type-specific descriptors. Concrete use cases include tracking variable-value associations across different program analysis phases or maintaining structured state information in plugins.",
      "description_length": 503,
      "index": 2532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing parameters in a plugin, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with the `Parameter_category.t` type, which encapsulates category behavior and dependencies on plugin states. Concrete use cases include setting up parameter groups with specific accessors and dependencies, enabling global parameter behavior through `@all`, and redirecting `@default` to control fallback category logic.",
      "description_length": 513,
      "index": 2533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are of type `Data.t` and values are abstract. It provides standard map operations including insertion, lookup, equality, comparison, hashing, and pretty-printing. Use cases include managing collections of values indexed by a specific key type, such as symbol tables or configuration settings.",
      "description_length": 347,
      "index": 2534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic information in CIL, where keys are built from the `Data` module and values are stored in a typed map. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate logic-related CIL data during static analysis, such as tracking built-in logic functions or annotations across different analysis contexts.",
      "description_length": 498,
      "index": 2535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL term l-values and provides a deep copy function to ensure no shared references. Concrete use cases include managing collections of term l-values with efficient lookups and ensuring structural integrity during analysis passes in Frama-C plugins.",
      "description_length": 437,
      "index": 2536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table implementation, specifically tailored for integer-based keys within the Frama-C kernel. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate hash table keys in a type-safe manner during static analysis tasks.",
      "description_length": 401,
      "index": 2537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map data structure with operations for key-value association management, including insertion, lookup, and iteration. It works with string keys and arbitrary values conforming to the `Datatype` signature, supporting serialization, comparison, and pretty printing. Concrete use cases include managing configuration settings or command-line option values indexed by string identifiers.",
      "description_length": 414,
      "index": 2538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for logic information with structural comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate logic keys in a way that ensures structural consistency and efficient lookup.",
      "description_length": 388,
      "index": 2539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for storing values associated with vertices in an interpreted automaton. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to manage per-vertex data during abstract interpretation, such as state tracking or analysis results.",
      "description_length": 382,
      "index": 2540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given CIL enumeration item type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with `Enumitem` values in a type-safe manner, including deep copying and membership testing within projects. Concrete use cases include managing and querying collections of CIL enumeration items during static analysis plugin development.",
      "description_length": 438,
      "index": 2541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with logic labels as keys and values tied to the `Data` module, enabling efficient lookups and structural manipulations. Concrete use cases include managing and querying logic label-value pairs during static analysis, such as tracking variable annotations or function specifications.",
      "description_length": 471,
      "index": 2542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing keys used in a character-based hashtbl structure, including equality, comparison, hashing, and pretty printing. It works with the abstract type `t` representing hashtbl keys and supports operations required for efficient key handling in hash tables. Concrete use cases include storing and retrieving character keys in a hash table with custom equality and comparison semantics.",
      "description_length": 435,
      "index": 2543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing character map keys, including equality, comparison, hashing, and pretty-printing. It works with the abstract key type used in character maps, providing representants, descriptors, and project membership checks. Concrete use cases include key manipulation in map structures, ensuring deep copies, and integrating with project-based data analysis through filtering and structural descriptions.",
      "description_length": 449,
      "index": 2544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are based on CIL constants with strict comparison semantics, ensuring that textual representations influence equality checks. It supports standard hash table operations like lookup, insertion, and iteration, while providing deep copying, hashing, and pretty-printing tailored to the contained values. It is suitable for scenarios requiring precise tracking and comparison of CIL constants, such as static analysis passes that rely on exact constant representations.",
      "description_length": 518,
      "index": 2545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps where keys are based on CIL types with structural comparison by reference and no unrolling. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate type-based keys in map structures within Frama-C's kernel, particularly for analysis plugins requiring precise type handling.",
      "description_length": 460,
      "index": 2546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that supports structural equality and strict constant comparison, specifically for use with CIL expressions involving `sizeof` operations. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and compare CIL expressions in contexts where structural identity and size-based equivalence are required, such as analysis plugins that track expression semantics across different program states.",
      "description_length": 552,
      "index": 2547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing 32-bit integer keys used in map structures, including equality, comparison, hashing, and pretty-printing. It supports data types related to `Int32.t` and provides utilities for deep copying, membership testing within projects, and descriptor handling. Concrete use cases include building and manipulating maps keyed by 32-bit integers in Frama-C plugins and analysis tools.",
      "description_length": 431,
      "index": 2548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map.Make",
      "library": "frama-c.kernel",
      "description": "Implements a map where keys are positions in source files and values are determined by the `Data` module. It supports standard map operations like lookup, insertion, and iteration, along with equality, comparison, and pretty printing. Useful for tracking per-position metadata, such as annotations or analysis results, during CIL-based static analysis.",
      "description_length": 352,
      "index": 2549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a boolean map, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the `Frama_c_kernel.Datatype.Bool.Map.key` type, which represents keys in a map where values are boolean. Concrete use cases include managing and querying boolean associations tied to project-specific keys, such as tracking analysis flags or configuration settings in Frama-C plugins.",
      "description_length": 444,
      "index": 2550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for mapping kernel functions with support for equality, comparison, hashing, and pretty-printing operations. It works with function declarations and prototypes, enabling precise handling of Frama-C kernel functions in command-line option parsing. Concrete use cases include tracking and comparing function definitions during static analysis and extending option processing to support function-specific arguments.",
      "description_length": 446,
      "index": 2551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for defining and managing string-based command line parameters with customizable validation constraints, including support for static value sets, dynamic checks (e.g., function name validation), and runtime value manipulation. It operates on string values tied to project-specific state, enabling features like default tracking, help message visibility control, and marshaling for persistent configuration. Typical use cases include parsing and validating command line arguments in tools requiring strict parameter value restrictions or dynamic integration with analysis frameworks.",
      "description_length": 613,
      "index": 2552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates hash tables indexed by a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that conform to the `Hashtbl` signature, enabling efficient key-value lookups and manipulations. Concrete use cases include managing dynamic collections of values with unique keys, such as tracking variable bindings or caching computed results in analysis plugins.",
      "description_length": 440,
      "index": 2553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing command-line parameters that accept string values, including validation against allowed values, function name resolution, and dynamic behavior via update hooks. It works with string-based data types, enforcing constraints through mechanisms like `set_possible_values` to restrict inputs or `get_function_name` to resolve valid identifiers. It is used to implement configurable options in the Frama-C kernel where parameters require strict validation or dynamic interaction with other components.",
      "description_length": 553,
      "index": 2554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps within the Value's abstract memory representation. It provides standard operations such as equality, comparison, hashing, and pretty printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate keys that represent memory locations or values in abstract interpretation contexts.",
      "description_length": 378,
      "index": 2555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL attributes and is designed for managing structured data in static analysis plugins. Concrete use cases include tracking and manipulating attribute-laden CIL elements like function annotations or variable metadata during analysis.",
      "description_length": 426,
      "index": 2556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages category definitions and configurations for plugin parameters, providing operations to create, modify, and query categories such as `@none`, `@default`, and `@all`. It works with category values and state lists, supporting precise control over plugin behavior through named categories and accessors. Concrete use cases include defining default parameter behaviors, enabling all parameters under a specific interpretation, and setting up global category aliases.",
      "description_length": 481,
      "index": 2557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by `Lval` values, where the keys are compared using their `eid`-based equality, and the values are of a specified `Data` type. It provides standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing capabilities. It is suitable for tracking value analyses or annotations tied to specific CIL l-values in static analysis plugins.",
      "description_length": 426,
      "index": 2558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uses strict structural equality, including precise constant comparison, based on CIL lvalues. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate map keys in analyses requiring precise key identity and structural comparison, such as value analysis or transformation passes over CIL code.",
      "description_length": 463,
      "index": 2559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation for a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that can be stored in a hash table and includes functionality for deep copying, checking project membership, and generating type descriptors. Concrete use cases include managing stateful data structures in Frama-C plugins, such as symbol tables or cached analysis results.",
      "description_length": 453,
      "index": 2560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps where each key is a normalized filepath. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, along with functions to check project membership and perform deep copies. It is used when managing map structures that associate data with filepaths in a type-safe manner, ensuring correct handling of file-based analyses.",
      "description_length": 408,
      "index": 2561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table that supports strict structural equality and comparison of CIL types, particularly for use in analyses requiring precise type discrimination. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include managing type-specific analysis data in Frama-C plugins, such as tracking type-based value abstractions or analysis results across different project contexts.",
      "description_length": 519,
      "index": 2562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a lattice-equipped hashtbl, providing standard operations including equality, comparison, hashing, and pretty printing. It supports concrete data types that can be stored in a `Hashtbl` and used within a lattice structure, ensuring deep copying and project membership checks. Use cases include managing symbolic execution states and tracking analysis data in Frama-C plugins where precise key handling in a lattice is required.",
      "description_length": 469,
      "index": 2563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.key` type, providing utilities to manage key values within a map structure. Concrete use cases include efficient key-based lookups, set operations, and map traversal with proper value representation and comparison semantics.",
      "description_length": 389,
      "index": 2564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with logic real values, including equality, comparison, hashing, and pretty-printing. It supports data types that represent logic real keys, providing deep copy and membership checks for project-specific values. Concrete use cases include managing and comparing symbolic logic expressions in static analysis tools.",
      "description_length": 367,
      "index": 2565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate code annotations with unique identifiers, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with structured data types representing CIL code annotations, including project-specific metadata. Use cases include managing and querying annotated CIL elements in static analysis plugins, such as tracking function contracts or variable invariants across different analysis passes.",
      "description_length": 474,
      "index": 2566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL locations, including equality, comparison, hashing, and pretty-printing. It supports data types that represent keys in a map structure, specifically tied to CIL locations and project-aware values. Use cases include managing and comparing keys in maps that associate CIL locations with project-specific data.",
      "description_length": 369,
      "index": 2567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps with strict structural equality, specifically for use with CIL types that require precise constant comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing for keys, along with deep copying and project membership checks. Concrete use cases include managing and comparing CIL-based data structures in static analysis plugins where strict key identity is required.",
      "description_length": 453,
      "index": 2568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by CIL variable information (`Varinfo.t`) with values of a specified type `Data.t`. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, along with project membership checks. It is used to associate and manipulate data specific to C variables across Frama-C analyses or transformations.",
      "description_length": 379,
      "index": 2569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys based on `Logic_info_structural` and values determined by the `Data` parameter. It provides standard operations including equality, comparison, hashing, pretty printing, and deep copying, all tailored to the structural properties of the map's contents. Concrete use cases include managing collections of logic-related values with structural identity, such as tracking annotations or logical properties across different analysis contexts.",
      "description_length": 491,
      "index": 2570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hashtbl that uniquely identify CIL global entities, supporting operations like equality, comparison, hashing, and pretty-printing. It works with CIL's global key type, which includes references to global variables, functions, and other top-level constructs in C programs. Concrete use cases include tracking and managing global symbols during static analysis, enabling efficient lookups and ensuring consistent handling of global identifiers across different analysis phases.",
      "description_length": 506,
      "index": 2571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports working with sets of strings in a way that ensures deep copying, structural comparison, and integration with project-based data through membership checks. It is used in contexts requiring persistent storage or analysis of string sets within Frama-C plugins.",
      "description_length": 406,
      "index": 2572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that conform to the `Data` module signature, enabling efficient lookups and storage keyed by CIL variable information. Concrete use cases include tracking variable-specific analyses or mappings during static analysis where each variable has associated data that must be efficiently queried and compared.",
      "description_length": 491,
      "index": 2573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on CIL predicates with structural equality. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with functions for deep copying and checking the presence of project values. It is used when implementing or manipulating map structures that require keys to be compared or displayed based on their predicate content.",
      "description_length": 436,
      "index": 2574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for logic constructor information in the context of CIL-based analysis. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with utilities for deep copying and checking the presence of project-specific data. The key type is used to uniquely identify and manage logic constructor entries within analysis plugins.",
      "description_length": 433,
      "index": 2575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type for values of a specified data module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with a list of hash table instances through representants and descriptors for type handling in Frama-C's analysis context. Concrete use cases include managing and comparing sets of analysis results or annotations tied to specific projects or code entities.",
      "description_length": 440,
      "index": 2576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like datatype with operations for comparing, hashing, and pretty-printing values. It works with a specific datatype `t` that represents values with a name, descriptor, and structural properties. Concrete use cases include managing command-line option values with project-specific filtering and deep copying.",
      "description_length": 336,
      "index": 2577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables managing string-based plugin parameters with validation, alias handling, and marshaling customization. It operates on strings and string lists to support configuration workflows such as command-line argument parsing, default value assignment, and project-specific state management. Typical use cases include defining validated string options for plugins, enforcing allowed value constraints, and bridging configuration data between runtime and storage formats.",
      "description_length": 480,
      "index": 2578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for native integers, where each table's keys are native integers and values are of a specified datatype. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage mappings from native integers to structured values within Frama-C's analysis framework.",
      "description_length": 416,
      "index": 2579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations such as equality checking, comparison, hashing, and pretty printing. It works with the abstract type `Hashtbl.key`, supporting deep copying, membership testing within projects, and type representation. Concrete use cases include managing and comparing keys in hash tables that store analysis data across different project contexts in Frama-C plugins.",
      "description_length": 432,
      "index": 2580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by `Fieldinfo` values, where the mapped values have the type provided by the `Data` parameter. It supports standard map operations including lookup, insertion, iteration, and traversal, along with serialization, comparison, and pretty-printing. It is suitable for tracking field-specific annotations or analyses in CIL-based tools.",
      "description_length": 366,
      "index": 2581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hashtbl used to represent logic type information in CIL. It provides operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and checking membership based on project-specific criteria. The keys are used to uniquely identify and manage logic type data within Frama-C's analysis framework.",
      "description_length": 358,
      "index": 2582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control parameter behavior across plugins. Concrete use cases include setting default parameter interpretations, enabling global category behavior with `@all`, and defining custom categories that group related parameters for consistent handling.",
      "description_length": 503,
      "index": 2583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for 64-bit integers, where each table's keys are of type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty-printing, alongside deep copying and project membership checks. Concrete use cases include managing collections of integer-indexed values with efficient lookups and persistence across analysis sessions.",
      "description_length": 407,
      "index": 2584,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent built-in logic information in CIL, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `key` type, which encapsulates logic identifiers along with their associated type and project membership. Use cases include managing and distinguishing logic function keys in static analysis plugins, ensuring correct handling of built-in logic entities across different analysis contexts.",
      "description_length": 475,
      "index": 2585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with hash tables mapping logic constructor info keys to values of type `Data.t`, providing deep copy, project membership checks, and type descriptors. Concrete use cases include managing and manipulating logic constructor metadata in CIL-based analyses, such as tracking function contracts or type invariants.",
      "description_length": 497,
      "index": 2586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Bool.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a boolean command line option datatype with support for equality, comparison, hashing, and pretty printing. It provides operations to check membership of project-related values and to create deep copies of values. Concrete use cases include defining and managing boolean configuration flags in Frama-C plugins that require serialization, comparison, or user-facing output.",
      "description_length": 395,
      "index": 2587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are booleans and values are of the provided `Data` module's type. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and pretty printing. It is suitable for managing boolean-indexed data in static analysis plugins, such as configuration flags or binary state tracking.",
      "description_length": 368,
      "index": 2588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype with values of a specified type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with comparable data types that define `equal` and `compare` functions, organizing them into map structures. Concrete use cases include managing sets of structured values where each key maps to a typed value, such as tracking variable bindings or analysis results in static analysis plugins.",
      "description_length": 456,
      "index": 2589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL term representations. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hashtable where each key represents a CIL term construct.",
      "description_length": 356,
      "index": 2590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL function keys within the Frama-C kernel. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys that uniquely identify functions in CIL representations during static analysis tasks.",
      "description_length": 400,
      "index": 2591,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control how parameters are grouped and interpreted. Concrete use cases include setting up configurable parameter groups for plugins, enabling or disabling entire categories of parameters, and defining default or special-purpose categories like `@all` and `@none`.",
      "description_length": 521,
      "index": 2592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype built from a given `Data` module, providing standard operations like `equal`, `compare`, `hash`, and `pretty` for values stored in the table. It supports concrete use cases such as managing collections of typed values with efficient lookup, comparison, and serialization, particularly in static analysis plugins requiring structured data handling. The module also includes deep copying and project membership checks, enabling use in multi-project analysis scenarios.",
      "description_length": 511,
      "index": 2593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent logic constants in CIL (C Intermediate Language) within Frama-C. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with deep copying and checking the presence of project-specific data. The keys are used to uniquely identify and manipulate logic constants during static analysis tasks such as value analysis or plugin-specific transformations.",
      "description_length": 445,
      "index": 2594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL constants. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys representing CIL constant values in a type-safe manner.",
      "description_length": 340,
      "index": 2595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type based on CIL expressions with structural equality, where expressions are considered equal if they have the same structure and size. It supports operations such as equality checking, comparison, hashing, and pretty-printing for use in hash tables that require structural equivalence for keys. Concrete use cases include managing and caching analysis results keyed on structurally equivalent C expressions, particularly in static analysis plugins for Frama-C.",
      "description_length": 499,
      "index": 2596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by characters, where each key maps to a value of the provided `Data` module type. It supports standard map operations such as lookup, insertion, and iteration, tailored specifically for character-indexed data. Use cases include managing per-character metadata or efficiently dispatching actions based on character keys.",
      "description_length": 353,
      "index": 2597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by file paths with support for standard operations like insertion, lookup, and iteration. It works with abstract data types representing file paths and associated values, ensuring correct handling of path-based keys in a functional setting. Concrete use cases include tracking file-specific analysis results or configuration settings across different source files in a project.",
      "description_length": 412,
      "index": 2598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given `Data` module type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that require structured representation, project membership checks, and deep copying, particularly for Frama-C's analysis and transformation plugins. Concrete use cases include tracking and manipulating declaration-specific data during source code analysis or transformation passes.",
      "description_length": 478,
      "index": 2599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Zero.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, along with support for project membership checks and deep copying. It works with a specific type `t` and integrates with Frama-C's project and datatype systems. Concrete use cases include managing analysis results or configuration values within plugins, ensuring proper serialization, comparison, and display behavior.",
      "description_length": 432,
      "index": 2600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, where keys are based on CIL identifiers. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Use cases include managing collections of CIL terms indexed by identifiers, such as tracking variable annotations or function-specific data during static analysis.",
      "description_length": 427,
      "index": 2601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps where each key is associated with a value of a lattice structure, enabling operations such as equality, comparison, hashing, and pretty printing on these map-based lattice instances. It supports data types built from a provided `Data` module, which must define the lattice properties of the values stored in the map. Concrete use cases include managing and analyzing symbolic states in static analysis, where each key might represent a program variable and the associated value represents an abstract domain element tracking possible values or constraints.",
      "description_length": 584,
      "index": 2602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type and associated operations for a map structure that manages memory mappings from bases to offset maps. It provides standard key functionalities such as comparison, hashing, equality, and pretty printing, along with support for project membership checks and deep copying. The key type is used to uniquely identify and manipulate entries in memory maps, particularly in the context of static analysis and program transformation tasks.",
      "description_length": 462,
      "index": 2603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, including operations for equality, comparison, hashing, and pretty-printing. It works with the `Frama_c_kernel.Base.Base.Map.key` type and includes utilities for checking membership in projects and deep copying keys. Concrete use cases include managing and manipulating map keys in memory zone abstractions with precise validity tracking.",
      "description_length": 379,
      "index": 2604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are expressions or structures with equality and values are of a specified type. It provides standard operations like comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage structured data associated with CIL expressions in a type-safe and efficient manner.",
      "description_length": 359,
      "index": 2605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter builders, allowing the association of states and accessors to control behavior. Use cases include setting default category behavior, enabling all options with specific interpretations, and defining dependencies for custom categories.",
      "description_length": 462,
      "index": 2606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a map key type for CIL types where structural equivalence is determined by type keys, ignoring attributes. It provides standard operations including equality, comparison, hashing, and pretty-printing for use in maps and sets. Typical use cases involve managing type-based mappings in analyses where attribute-agnostic type identity is required.",
      "description_length": 364,
      "index": 2607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store kernel function-related data, providing standard operations like equality, comparison, hashing, and pretty printing. It works with the `Frama_c_kernel.Kernel_function.Hptset.Hashtbl.key` type, which represents keys tied to kernel functions and project data. Concrete use cases include managing per-function metadata in plugins, such as analysis results or configuration settings, ensuring efficient and type-safe access.",
      "description_length": 484,
      "index": 2608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL constants, including equality, comparison, hashing, and pretty-printing. It supports data types that represent constant values in the CIL intermediate language, such as integers, floats, and expressions. Use cases include managing and querying constant values during static analysis, such as tracking constant propagation or evaluating expressions at compile time.",
      "description_length": 426,
      "index": 2609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map with keys based on CIL expressions with structural equality and strict constant comparison. It supports standard map operations including lookup, insertion, and traversal, while ensuring deep copying, precise equality, and proper hashing for use in analysis plugins. It is suitable for tracking and manipulating CIL expressions in a map context during static analysis.",
      "description_length": 397,
      "index": 2610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with hash tables where keys and values are based on the `Data` module's type. Concrete use cases include managing collections of logic values with efficient lookups and persistence across analysis states.",
      "description_length": 392,
      "index": 2611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in wide string maps, including equality, comparison, hashing, and pretty-printing. It supports data types involving wide strings and project-specific values, enabling efficient key-based lookups and comparisons. Use cases include managing and manipulating wide string identifiers within CIL-based analyses.",
      "description_length": 351,
      "index": 2612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Int.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling integer-based command-line parameters with operations for comparison, hashing, pretty printing, and deep copying. It works with a specific type `t` representing parameter values, alongside project-aware equality and membership checks. Concrete use cases include defining and managing configurable integer options in Frama-C plugins, such as setting analysis thresholds or numeric limits via the command line.",
      "description_length": 452,
      "index": 2613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are properties ordered by function criteria, including kernel function name, instruction, property kind, and ID. It supports operations like equality checking, comparison, hashing, and pretty-printing for property-ordered hash tables, specifically working with `Property.t` keys and user-defined `Data.t` values. It is used to manage and query property-based data in Frama-C analyses, such as storing and retrieving analysis results keyed by property.",
      "description_length": 498,
      "index": 2614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL constants with strict comparison semantics. It provides operations for equality checking, comparison, hashing, and pretty-printing keys, along with utilities for project membership testing and deep copying. The key type is designed to support efficient and precise manipulation of constant values in analyses that require tracking based on their textual representation.",
      "description_length": 453,
      "index": 2615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are compared based on their structural equality, not physical identity. It supports standard operations such as `equal`, `compare`, `hash`, and `pretty`, enabling use in hash tables and ordered maps. The type `t` represents values that can be structurally compared and copied, making it suitable for managing keys in persistent or mutable map structures where value equivalence is required.",
      "description_length": 441,
      "index": 2616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values that include project-specific data. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is suitable for managing and manipulating keys in a hashtable where each key may contain a `Project.t` value that needs to be inspected or preserved independently.",
      "description_length": 438,
      "index": 2617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are term l-values and values are of type `Data.t`. It provides standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing capabilities. It is suitable for tracking or analyzing CIL term l-value associations in static analysis plugins.",
      "description_length": 339,
      "index": 2618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for abstract interpretation, where keys are integers and values are of a given abstract domain type provided by the `Data` module. It supports standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking for analysis purposes. Concrete use cases include tracking abstract values associated with integer identifiers in static analysis, such as mapping variable identifiers to their abstract domains during program analysis.",
      "description_length": 560,
      "index": 2619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with key-value pairs where values conform to the `Data` type, enabling efficient lookups and storage. Concrete use cases include managing term-based mappings in static analysis plugins, such as tracking variable bindings or expression evaluations.",
      "description_length": 435,
      "index": 2620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map used to manage addressable memory zones. It provides equality, comparison, hashing, and pretty-printing functions for keys, which are essential for maintaining and querying memory zone mappings. The module supports deep copying and project membership checks, enabling precise manipulation and analysis of memory representations in static analysis tasks.",
      "description_length": 422,
      "index": 2621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module enables management of command-line parameters that accept string or string list values, supporting validation through allowed value constraints, alias handling, and serialization customization. It operates on string lists and individual strings, integrating with project system infrastructure for option parsing and state management. Typical use cases include plugins requiring validated command-line arguments, such as restricting inputs to predefined options or processing structured list parameters with dynamic validation rules.",
      "description_length": 544,
      "index": 2622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are logic types and values are of the `Data` module's type. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage collections of logic-type-indexed data in a way that supports analysis and transformation tasks within Frama-C plugins.",
      "description_length": 396,
      "index": 2623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered string list data type with standard operations including equality, comparison, hashing, and pretty printing. It supports deep copying and membership testing for project values within the list. Concrete use cases include managing collections of strings that require persistence, comparison, and display within Frama-C plugin contexts.",
      "description_length": 366,
      "index": 2624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.False.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command line options with Boolean values that default to false. Operates on a Boolean data type, providing equality, comparison, hashing, and pretty-printing functions. Useful for defining configurable flags in Frama-C plugins that start in a disabled state and can be activated via the command line.",
      "description_length": 311,
      "index": 2625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are integers and values are of the provided `Data` module's type. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing for use in collections. It is suitable for managing structured collections of values with integer keys, such as sparse arrays or indexed metadata.",
      "description_length": 381,
      "index": 2626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored to handle CIL function declarations (`Fundec`) within the Frama-C kernel. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, ensuring keys can be efficiently stored and retrieved. The module supports deep copying and project membership checks, facilitating manipulation of CIL function data in analyses that require key-based access to function-specific information.",
      "description_length": 492,
      "index": 2627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map for handling multiple instances of a registered plugin datatype, supporting operations like equality, comparison, hashing, and pretty-printing. It works with the `Datatype.t` type and plugin-specific representations, enabling efficient storage and retrieval of plugin data associated with unique string keys. Concrete use cases include managing plugin configurations, tracking analysis results per function or file, and persisting plugin state across different Frama-C sessions.",
      "description_length": 522,
      "index": 2628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with keys in a hash table, including equality, comparison, hashing, and pretty-printing. It provides a structured way to manage key representations, descriptors, and project membership checks. Concrete use cases include efficiently managing and querying hash table keys with custom equality and hash functions.",
      "description_length": 353,
      "index": 2629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and managing CIL constants in a hash table with deep copying and project-aware membership checks. The data structure is designed for integration with Frama-C's internal analysis and transformation passes that require efficient, value-based hash tables.",
      "description_length": 477,
      "index": 2630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables where keys are CIL types compared by name without unrolling. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Use cases include managing type-based mappings in Frama-C plugins where structural equivalence by name is required.",
      "description_length": 372,
      "index": 2631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line string parameters with validation constraints and state tracking. It operates on string values that can be restricted to predefined sets or resolved as function names, supporting use cases like configuration options requiring specific value ranges or dynamic symbol resolution. Key features include default value handling, project-specific state serialization, and alias management for flexible parameter naming.",
      "description_length": 445,
      "index": 2632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent syntactic scopes in CIL, including operations for equality, comparison, hashing, and pretty-printing. It works with CIL-specific types such as `Type.t`, `Project_skeleton.t`, and `Descr.t`, ensuring deep copying and project membership checks. Concrete use cases include managing and distinguishing syntactic scopes during static analysis, such as tracking variable bindings or function contexts in C programs.",
      "description_length": 466,
      "index": 2633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for string sets in Frama-C plugins, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control plugin behavior through command-line options. Concrete use cases include enabling all parameters under a category, setting default interpretations, or defining custom categories with specific accessors and dependencies.",
      "description_length": 460,
      "index": 2634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are managed with the `Hashtbl` structure and values are of a specified type. It supports operations like equality checking, comparison, hashing, and pretty-printing for hash tables containing these values. It is useful for managing collections of data with unique keys, such as tracking variable bindings or caching function results.",
      "description_length": 386,
      "index": 2635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with logic labels, providing equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing logic label keys and includes utilities for checking project membership and performing deep copies. Concrete use cases include managing and comparing keys in map structures for static analysis tasks, such as tracking logic labels across different analysis phases.",
      "description_length": 447,
      "index": 2636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line parameters in Frama-C kernel extensions. It supports operations like equality checking, comparison, hashing, and pretty-printing for values of this type, along with deep copying and project membership testing. It is used to manage and manipulate string representations of loadable modules in Frama-C's plugin system.",
      "description_length": 387,
      "index": 2637,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are based on CIL l-values with structural equality, and values are of a specified `Data` module type. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is suitable for analyses requiring associative storage keyed on CIL expressions with structural identity, such as value analysis or abstract interpretation domains.",
      "description_length": 477,
      "index": 2638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that represent syntactic scopes in CIL (C Intermediate Language) structures. It provides standard operations such as equality, comparison, hashing, and pretty printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate scoped identifiers during static analysis of C code.",
      "description_length": 362,
      "index": 2639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and retrieving CIL enumeration information with structural integrity and project-aware membership checks. The hash tables are used to manage and manipulate CIL data during static analysis tasks, such as tracking enum values across different analysis states.",
      "description_length": 487,
      "index": 2640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases like managing project-specific keys in a hash table, where each key can be checked against project criteria using `mem_project`. The module also enables deep copying of keys to ensure no shared references between copies.",
      "description_length": 389,
      "index": 2641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a hash table, specifically for integer-based keys. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Use cases include efficient key management in hash tables that require stable and deterministic behavior across different analysis states.",
      "description_length": 370,
      "index": 2642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are compared structurally, treating equivalent expressions involving `sizeof` as equal. It supports standard map operations like lookup, insertion, and iteration, with values parameterized by the `Data` module. Useful for analyses tracking expression-based keys with structural equality, such as value analysis or slicing.",
      "description_length": 362,
      "index": 2643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with strings, state lists, and category accessors to structure parameter handling. Concrete use cases include defining the `@none`, `@default`, and `@all` categories, enabling all parameters with specific interpretations, and mapping categories to control command-line option behavior.",
      "description_length": 471,
      "index": 2644,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map from integers to values of a specified data type, providing standard operations for equality, comparison, hashing, and pretty-printing. It supports operations like membership testing with project functions, deep copying, and integrates with Frama-C's type and descriptor system for abstract interpretation. Concrete use cases include tracking abstract values in static analysis, such as mapping variable identifiers to abstract domains during program analysis.",
      "description_length": 489,
      "index": 2645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate values with declaration identifiers in the context of pretty printing source code with located AST elements. It provides standard operations for equality, comparison, hashing, and pretty printing keys, as well as deep copying and checking the presence of project-specific data. It is used to manage and manipulate keys representing declarations in a map structure during source analysis and transformation tasks.",
      "description_length": 467,
      "index": 2646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a specialized hash table type for a given data module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that require structured representation, project membership checks, and deep copying, ensuring each instance maintains unique identity and integrity. Concrete use cases include managing machine-dependent values with custom semantics, such as tracking project-specific identifiers or configurations in static analysis plugins.",
      "description_length": 509,
      "index": 2647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values that involve CIL predicates and structural equality. It provides standard operations such as equality checking, comparison, hashing, and pretty printing, along with utilities for deep copying and checking the presence of project-related data. It is suitable for managing and manipulating keys in a hashtable where each key represents a structured CIL predicate.",
      "description_length": 448,
      "index": 2648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a 32-bit integer hashtbl, providing equality, comparison, and hashing operations required for key management. It supports structured values that may contain project-specific data, enabling operations like deep copying, pretty printing, and membership testing within project contexts. Concrete use cases include managing mappings between 32-bit integers and other values in Frama-C plugins, particularly for analyses requiring persistent or project-scoped storage.",
      "description_length": 511,
      "index": 2649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.False.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugin development. It supports structured data representation with a descriptor, type information, and a list of representative values, enabling introspection and serialization. Concrete use cases include defining custom analysis data structures that integrate with Frama-C's internal project management and transformation passes.",
      "description_length": 473,
      "index": 2650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for 32-bit integers, where each table's keys are 32-bit integers and values are of a provided `Data` module's type. It supports standard hash table operations such as lookup, insertion, and iteration, along with deep copying, equality checking, and pretty printing. It is used when building analyses or plugins that require persistent, efficiently searchable mappings from integer keys to structured values.",
      "description_length": 461,
      "index": 2651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in integer maps within a lattice implementation, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing abstract values in static analysis, where keys must be uniquely identified and efficiently manipulated. The module also includes functions for project membership checks and deep copying to ensure value integrity during analysis transformations.",
      "description_length": 488,
      "index": 2652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a boolean hashtbl structure, providing equality, comparison, and hashing operations required for key management. It supports operations like deep copying, pretty printing, and checking membership of project values within keys. This is specifically used to manage key-value associations in contexts requiring precise boolean state tracking, such as static analysis passes or value tracking plugins.",
      "description_length": 445,
      "index": 2653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing kernel functions in command line option configurations. It provides operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. Concrete use cases include structuring plugin options and controlling function activation based on command line arguments.",
      "description_length": 382,
      "index": 2654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Empty_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in plugin development. It supports structured data representation with a unique name and descriptor, enabling integration with Frama-C's plugin system. Concrete use cases include managing and manipulating abstract values within static analysis plugins, such as tracking string-based identifiers or symbolic expressions across program states.",
      "description_length": 461,
      "index": 2655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like comparison, equality, hashing, and pretty-printing. It supports data management tasks such as deep copying, membership testing via project functions, and type representation with descriptors. Concrete use cases include tracking and manipulating structured memory base mappings in static analysis contexts.",
      "description_length": 408,
      "index": 2656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL position data. It includes standard operations like equality, comparison, hashing, and pretty-printing to support efficient storage and retrieval of position-based keys. The module is used to manage and manipulate keys that uniquely identify positions in source files during static analysis.",
      "description_length": 375,
      "index": 2657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and operations for a lattice-equipped map, including equality, comparison, hashing, and pretty-printing functions. It provides utilities to manage key representations, type descriptors, and project membership checks for analysis projects. These features support precise dataflow analysis and abstract interpretation tasks in static code analysis.",
      "description_length": 379,
      "index": 2658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that store logic information, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports data types used in CIL (C Intermediate Language) analysis, particularly for managing and manipulating logic-related keys in a map structure. Use cases include tracking and comparing logic expressions or identifiers during static analysis of C code.",
      "description_length": 420,
      "index": 2659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL statements as values. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. It is used to manage and manipulate statement-based key structures in static analysis plugins.",
      "description_length": 322,
      "index": 2660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Verbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and user-friendly value display. Concrete use cases include managing plugin-specific data structures that require serialization, comparison, and integration with Frama-C's project system.",
      "description_length": 473,
      "index": 2661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are logic information structures with structural comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checks. It is used to manage and manipulate logic keys in a map, ensuring structural consistency and efficient lookups.",
      "description_length": 372,
      "index": 2662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are compared using physical equality and values are of a specified datatype. It provides standard operations including equality, comparison, hashing, pretty-printing, and deep copying, along with support for project membership checks. It is suitable for managing collections of values with efficient lookup and insertion, particularly when working with custom data types that require structured storage and traversal.",
      "description_length": 473,
      "index": 2663,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table datatype specialized for string keys and a given value type, supporting operations like equality, comparison, hashing, and pretty-printing. It works with string-indexed hash tables containing values of a specified datatype. Useful for managing string-mapped data with efficient lookups and structural comparisons, such as symbol tables or configuration settings.",
      "description_length": 383,
      "index": 2664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Debug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and user-friendly value display. Concrete use cases include managing and comparing complex analysis data within Frama-C plugins, such as tracking and displaying abstract values during static analysis.",
      "description_length": 494,
      "index": 2665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by 64-bit integers with values of a specified data type, supporting standard operations like lookup, insertion, and iteration. It provides typed equality, comparison, hashing, and pretty-printing for the map values. Concrete use cases include managing state across analysis passes or tracking numeric identifiers in static analysis plugins.",
      "description_length": 374,
      "index": 2666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to define and manage string-based command line parameters, particularly for handling function names in Frama-C's kernel configuration. It works with string values (`As_string.t`) and supports validation against allowed function identifiers, serialization, and project-specific state tracking. Use cases include defining options that require valid function identifiers (e.g., analysis targets) with support for aliases, dynamic value updates, and strict or lenient retrieval of function names.",
      "description_length": 522,
      "index": 2667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype with structural equality and strict constant comparison for values. It provides standard operations including hash, equality, comparison, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate hash tables containing CIL data types in a way that ensures strict value-based semantics.",
      "description_length": 384,
      "index": 2668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing essential operations including equality, comparison, hashing, and pretty-printing. It supports key management in maps with functions to check membership within projects, deep copy keys, and describe their type and structure. Concrete use cases include managing and manipulating map keys in Frama-C plugins, ensuring keys are uniquely identifiable and efficiently handled in dataflow analyses.",
      "description_length": 466,
      "index": 2669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table implementation, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with `Hashtbl.Key.t` values, enabling creation of key representations, checking membership within projects, and deep copying of key instances. Concrete use cases include managing and manipulating hash table keys in a type-safe manner, particularly for plugins requiring persistent or project-aware key storage and comparison.",
      "description_length": 514,
      "index": 2670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map data structure that supports multiple bindings per key, with operations for equality, comparison, hashing, and pretty-printing. It works with arbitrary data types through a type parameter `Datatype.t`, providing deep copy and project membership checks. Concrete use cases include managing command-line options with multiple values per key and persisting structured configurations across analysis sessions.",
      "description_length": 443,
      "index": 2671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map type with multibindings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with arbitrary data types through a type parameter `Datatype.t`, and includes functionality for project membership checks and deep copying. Concrete use cases include managing collections of plugin-specific values where multiple entries per key are allowed, such as tracking analysis results across different program points.",
      "description_length": 475,
      "index": 2672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are offsets and values are of the type provided by the `Data` parameter. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing for map values. It is suitable for tracking per-offset data in CIL-based analyses, such as value abstractions or annotations in memory models.",
      "description_length": 378,
      "index": 2673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a hash table specific to logic variables in CIL. It provides equality, comparison, hashing, and pretty-printing functions for these keys, ensuring they can be used efficiently in hash tables. Use cases include tracking and manipulating logic variable keys during static analysis, such as in dataflow analyses or when storing and retrieving variable-specific information.",
      "description_length": 422,
      "index": 2674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based representations of generated specification customizations, supporting operations like equality, comparison, hashing, and pretty-printing. It works with strings and project skeletons to manage how specifications are customized during analysis. Concrete use cases include configuring Frama-C's behavior for specific analysis scenarios by manipulating and querying string-based specification parameters.",
      "description_length": 458,
      "index": 2675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of strings with filled semantics, providing operations for membership testing, addition, and iteration. It works with string data types and is used to manage collections of unique string values in a way that supports efficient querying and manipulation. Concrete use cases include tracking sets of identifiers, managing command-line option arguments, or handling string-based configurations within Frama-C's analysis framework.",
      "description_length": 456,
      "index": 2676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are CIL types with structural comparison ignoring attributes, and values are of a specified `Data` module type. It provides standard operations like `equal`, `compare`, `hash`, and `pretty` for managing and interacting with the hash table. Concrete use cases include tracking and manipulating mappings from CIL types to arbitrary data in static analysis plugins, such as associating type-specific metadata or analysis results.",
      "description_length": 479,
      "index": 2677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for handling string sets within a plugin's type system, including equality, comparison, hashing, and pretty-printing. It works with a concrete `Datatype.t` type representing strings and provides utilities for checking membership in projects and creating deep copies. Use cases include managing string-based identifiers or configurations in a plugin while ensuring proper type handling and project-specific filtering.",
      "description_length": 459,
      "index": 2678,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of key representatives, deep copying of keys, and checking membership based on project values. Concrete use cases include managing and manipulating key-based data in machine-dependent maps, such as tracking and comparing architectural states or configurations.",
      "description_length": 434,
      "index": 2679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports data types that can be stored in a `Hashtbl` and includes functionality for deep copying and checking the presence of project-related values. Concrete use cases include managing and manipulating hash table keys in Frama-C plugins, particularly for analysis data indexed by complex key types.",
      "description_length": 457,
      "index": 2680,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, ensuring proper handling of equality, comparison, and hashing. It supports operations such as `equal`, `compare`, `hash`, and `pretty` for data integrity and visualization, along with `copy` for deep duplication and `mem_project` for project membership checks. It is ideal for managing collections of structured values in static analysis plugins where precise data representation and manipulation are critical.",
      "description_length": 488,
      "index": 2681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a hash table that maps memory locations to values, specifically working with `Hashtbl.Key.t` values. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, ensuring correct behavior in hash table manipulations. Concrete use cases include managing and querying memory maps in static analysis plugins, where keys represent memory offsets and require precise identity and structural handling.",
      "description_length": 483,
      "index": 2682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use with a hashtbl, including operations for equality, comparison, hashing, and pretty printing. It supports deep copying and provides introspection capabilities through type descriptors and project membership checks. Concrete use cases include managing and querying structured data keys in a hashtbl with precise control over key behavior and representation.",
      "description_length": 394,
      "index": 2683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for character keys, where each value is of a provided `Data` type. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings from characters to structured values within Frama-C's analysis framework.",
      "description_length": 383,
      "index": 2684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are `Enuminfo` values and values are of a specified `Data` module type. It provides standard map operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate mappings involving CIL enumeration information in Frama-C plugins.",
      "description_length": 362,
      "index": 2685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps for associating logic type metadata (`Logic_type_info.t`) with arbitrary values, offering associative operations (insertion, lookup, removal), ordered traversal (ascending/descending iteration, folding), and transformations (filtering, partitioning, mapping with key-aware functions). It supports structural queries (splitting, membership checks), sequence conversions, and customizable pretty-printing, tailored for static analysis tasks requiring precise management of logic type information in CIL-based tools. The ordered key structure enables efficient reasoning about type hierarchies and dependencies during program analysis.",
      "description_length": 668,
      "index": 2686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.WTO",
      "library": "frama-c.kernel",
      "description": "Implements algorithms for constructing and manipulating weak topological orderings (WTO) of control flow graphs, using a partition-based approach. It provides functions to compute a WTO partition from a graph's nodes and successor relationships, compare and print components and partitions. This supports efficient chaotic iteration strategies with widenings for abstract interpretation tasks like program analysis.",
      "description_length": 415,
      "index": 2687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter`, `map`, and `fold_left`, which apply functions across list elements within a monadic context. It handles computations over lists where each element transformation or effect may produce a monadic result. Concrete use cases include processing sequences of values with side effects, accumulating results conditionally, or transforming list elements while threading state or error handling through the monad.",
      "description_length": 485,
      "index": 2688,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are integers and values are of the Data module's type. It provides standard hash table operations such as insertion, lookup, and iteration, along with deep copying, equality, comparison, and pretty-printing. It is used to manage mappings from integers to arbitrary data in a way that supports project-aware operations and structural comparison.",
      "description_length": 391,
      "index": 2689,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintAsIs.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating values involved in the `-print-as-is` option's behavior, including equality, comparison, hashing, and pretty-printing operations. It works with a concrete type `t` that encapsulates values subject to project-based filtering and deep copying. Use cases include managing and inspecting structured data during kernel execution, particularly when preserving or transforming program representations in a plugin or analysis module.",
      "description_length": 491,
      "index": 2690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers imperative hash tables for integer keys with polymorphic values, supporting insertion, deletion, lookup, and deterministic ordered iteration with custom key-value comparisons. It provides bulk updates from sequences, value memoization, and safe retrieval with defaults, alongside folding and conversion to/from sequential representations. These features are optimized for abstract interpretation tasks like tracking program state abstractions or variable mappings during static analysis, where precise integer-keyed data management and ordered traversal are critical.",
      "description_length": 586,
      "index": 2691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables keyed by CIL statement identifiers (Stmt.t), offering imperative operations like insertion, deletion, and lookup, along with bulk sequence-based updates, ordered traversal, and statistical tracking. Tailored for Frama-C plugins analyzing C code, it supports efficient statement manipulation, memoization, and large-scale data processing through in-place filtering and fold-based aggregations.",
      "description_length": 427,
      "index": 2692,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line parameters with set semantics, supporting operations like membership checks, element iteration, and state change hooks. It works with a set-like data structure built from comparable, hashable elements (via `E` and `Datatype`), allowing project-aware value tracking and category-based configuration. Key use cases include CLI option parsing with dynamic set updates and configuration systems requiring validated, serialized set membership.",
      "description_length": 480,
      "index": 2693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable ordered set data structure with operations for element manipulation, set algebra, and ordered traversal. It works with quadruple-wrapped elements (`elt`) stored in a sorted structure (`t`), using a comparator for ordering, and supports transformations like `map`, `filter`, and `fold`, as well as conversions to/from lists and sequences. It is particularly useful in static analysis contexts requiring precise set operations, ordered iteration, or integration with project-specific data representations through deep copying and introspection.",
      "description_length": 578,
      "index": 2694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash table operations for `Logic_info.t` keys, including creation, insertion, lookup, deletion, and bulk updates from sequences, alongside ordered iteration and folding over keys, entries, or values. It manages mappings from `Logic_info.t` keys to arbitrary values, supporting both imperative modifications and functional transformations with safe",
      "description_length": 370,
      "index": 2695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditPrepare.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. It works with structural descriptions and representants, supporting introspection and manipulation of data structures in the context of the `-audit-prepare` option. Concrete use cases include analyzing and transforming project data during audit preparation, such as tracking and comparing analysis states or configurations.",
      "description_length": 500,
      "index": 2696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Option",
      "library": "frama-c.kernel",
      "description": "This module provides `iter` and `map` functions for processing values wrapped in an option type within a lattice context that distinguishes bottom values. It works with `'a option` types and integrates computations that may result in a lattice bottom. Use cases include safely transforming or iterating over optional lattice values while preserving bottom semantics, such as in static analysis when handling potentially undefined or uninitialized states.",
      "description_length": 454,
      "index": 2697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps for bit-level memory locations, supporting insertion, lookup, merging, and ordered traversal over base-offset key pairs. It handles polymorphic value associations with keys structured as bit-precise location descriptors, enabling efficient filtering, partitioning, and bidirectional iteration. The operations cater to static analysis scenarios requiring fine-grained memory modeling, such as tracking pointer arithmetic or bitfield accesses in program verification.",
      "description_length": 513,
      "index": 2698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Set",
      "library": "frama-c.kernel",
      "description": "This module offers set-theoretic operations (union, intersection, difference) and ordered traversal capabilities (iteration, folding, mapping) for sets of machine-dependent values, with specialized functions for nearest-element queries, sequence conversions, and monotonic predicate handling. It works with sets containing `Frama_c_kernel.Machdep.Machdep.t` elements, sequences derived from these sets, and ordered structures requiring physical equality preservation. Typical applications include managing architecture-specific configurations, optimizing code generation through set transformations, and verifying properties across heterogeneous machine models.",
      "description_length": 661,
      "index": 2699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for mapping declaration keys to arbitrary values, supporting creation, insertion, lookup, removal, iteration, folding, and sequence-based initialization, replacement, and conversion. It works with `Frama_c_kernel.Printer_tag.Declaration.t` keys and sequences, enabling efficient data management during C source analysis and pretty printing, particularly for memoization and sorted iteration over keys, entries, or values. Use cases include tracking declaration-specific metadata and streamlining transformations in Frama-C's AST processing workflows.",
      "description_length": 591,
      "index": 2700,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLib.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use with the Frama-C kernel's project management and type representation systems. It supports deep copying of values, checking membership based on project properties, and provides structured representations for debugging or analysis. Concrete use cases include managing and querying abstract data types during static analysis, such as tracking and printing library paths or analyzing type descriptors across different project contexts.",
      "description_length": 565,
      "index": 2701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for manipulating collections of kernel function descriptors (`Kf.t`), including union, intersection, filtering, and ordered iteration, while supporting transformations like `filter_map` and nearest-element queries. It works with ordered sets that maintain uniqueness and provide conversions to and from lists and sequences, leveraging `Ord.compare` for ordering. These operations are particularly useful in static analysis for tracking function properties, partitioning code elements, or transforming sets during CIL-based program analysis.",
      "description_length": 582,
      "index": 2702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepSwitch.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for managing values related to the `-keep-switch` option in Frama-C. It supports equality checks, comparison, hashing, and pretty printing, along with deep copying and membership testing for project-specific values. The module is used to handle and manipulate switch-preservation logic during analysis, ensuring correct handling of project-specific switches across different Frama-C components.",
      "description_length": 452,
      "index": 2703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for CIL constants with strict comparison semantics, where equality considers textual representations. It supports efficient union, intersection, difference, and ordered traversal, along with filtering, mapping, and nearest-element queries over sets of `ConstantStrict.t` values. These structures are particularly useful in static analysis scenarios requiring precise distinctions between constants that might otherwise compare equal numerically but differ in source-level representation.",
      "description_length": 531,
      "index": 2704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map",
      "library": "frama-c.kernel",
      "description": "This module suite supports command-line option handling with stateful mappings between kernel functions and extensible values, enabling dynamic parameter customization and project-based computation tracking. It operates on `kernel_function` keys paired with `V.t` values, leveraging marshaled data types and category hierarchies to organize function configurations. Use cases include parsing aliased function arguments, persisting state across sessions, and integrating pure prototypes into analysis workflows via configurable command-line hooks.",
      "description_length": 546,
      "index": 2705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralVerbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports structured data representation with capabilities for deep copying, membership testing within projects, and type descriptors for integration with Frama-C's verbose output system. It is used to manage and manipulate values that represent verbose output configurations in kernel extensions.",
      "description_length": 418,
      "index": 2706,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for machine-dependent keys, including insertion, deletion, lookup, and both functional and in-place transformations. It supports ordered traversal using custom comparison functions, bulk updates from sequences, and value-based lookups with memoization or default handling, tailored for static analysis tasks requiring precise data structure manipulation. The design emphasizes structured key handling and typed table construction, enabling efficient management of machine-specific data in analysis workflows.",
      "description_length": 551,
      "index": 2707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered maps with string keys and arbitrary values, supporting insertion, deletion, merging, and ordered traversal. It includes functions for conditional searches, filtering, mapping, partitioning, and structural comparisons, along with utilities to build maps from sequences and format them for output. These operations are optimized for managing hierarchical data, efficient lookups with ordered keys, and functional transformations using key-based predicates.",
      "description_length": 483,
      "index": 2708,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for logic labels in Frama-C's CIL framework, supporting element manipulation (insertion, removal, union, intersection), structural queries (subset checks, cardinality, nearest elements), and ordered traversal (iteration, folding, sequence conversion). It works with sets of `Logic_label.t` elements using a fixed comparison function, enabling efficient analysis of label relationships in program annotations or verification conditions. Typical use cases include managing logical assertion labels, tracking code annotations during static analysis, and resolving label ordering in formal verification tasks.",
      "description_length": 647,
      "index": 2709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatNormal.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing a specific data type `t` related to floating-point normalization settings. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership checks over project skeletons. The type `t` is used to represent and manipulate internal states tied to the `-float-normal` option, enabling precise control and analysis of floating-point behaviors in Frama-C.",
      "description_length": 441,
      "index": 2710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype for lattice values that may include a bottom element, based on a given domain. It provides operations for equality, comparison, hashing, pretty printing, and deep copying, along with descriptors for type representation and project membership checks. It is used to handle abstract values in static analysis where the bottom element represents an absence or undefined state.",
      "description_length": 406,
      "index": 2711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.True",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean configuration options in a plugin system, supporting value setting/retrieval, change hooks, command-line interface integration, and alias definitions. It works with a boolean type abstracted as `t`, incorporating default values, project-specific state persistence, and serialization capabilities through an associated `Datatype` module. Typical use cases include enabling/disabling plugin features via command-line flags or module-level state toggling, with support for tracking configuration changes across analysis sessions.",
      "description_length": 579,
      "index": 2712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.True",
      "library": "frama-c.kernel",
      "description": "This module enables defining boolean command-line options with support for activation/deactivation, default value handling, and value-change callbacks, while integrating with Frama-C's project state management. It works with boolean parameters through typed objects that allow serialization via custom marshaling and maintain consistency across sessions. Typical applications include implementing toggleable analysis features or configuration switches that require persistent state tracking and project-specific behavior adjustments.",
      "description_length": 533,
      "index": 2713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a strictly ordered set structure for CIL expressions with structural equality and size-aware comparisons, enabling precise manipulation of expression data where identity depends on syntactic form and constant values. It supports efficient set operations like union, intersection, and filtering, alongside ordered traversal, nearest-element queries, and project-specific metadata handling, all grounded in the type's strict equality semantics. Designed for Frama-C's analysis kernel, it serves use cases requiring canonical representation of expressions\u2014such as static analysis passes or transformation pipelines\u2014where expressions with equivalent structure or size-equivalent operands must be treated as indistinguishable.",
      "description_length": 744,
      "index": 2714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of C lvalues (left-hand side values) represented via `LvalStructEq.t`, supporting insertion, union, intersection, and transformations like mapping or filtering. It maintains elements in a consistent order using a comparison function, enabling efficient membership checks, subset analysis, and ordered traversal, which is critical for deterministic static analysis tasks. Typical use cases include tracking memory locations, analyzing variable dependencies, or handling equivalence classes of expressions in Frama-C plugins.",
      "description_length": 590,
      "index": 2715,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.M",
      "library": "frama-c.kernel",
      "description": "This module manages associations between memory bases and bit-level offset intervals. It provides operations to iterate over, fold, and query these associations, enabling precise tracking of memory regions at the bit level. Concrete use cases include analyzing low-level memory manipulations, such as bitfield accesses and pointer arithmetic in C programs.",
      "description_length": 356,
      "index": 2716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module implements maps with structurally equivalent CIL expressions as keys, supporting insertion, deletion, merging, and ordered queries like range searches and extremum retrieval. It provides transformations, filtering, and ordered traversal over key-value pairs, with structural key comparison governing all operations. Useful for static analysis tasks requiring precise structural equality and ordered processing of CIL expressions.",
      "description_length": 441,
      "index": 2717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Set",
      "library": "frama-c.kernel",
      "description": "This set structure provides operations for managing collections of CIL expressions where elements are compared structurally, with special handling for `sizeof` expressions to prioritize size equivalence over identity. It supports ordered set operations like nearest-element queries (`nearest_elt_ge`, `nearest_elt_le`), bidirectional iteration, and bulk transformations, while leveraging structural equality and size-based comparison for deterministic ordering. Designed for static analysis tasks, it is particularly useful in scenarios requiring canonicalization of expressions with equivalent runtime behavior, such as symbolic evaluation or constraint simplification where `sizeof` expressions must be normalized.",
      "description_length": 716,
      "index": 2718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables using structural comparisons of logic information keys to manage associations between program analysis data and custom values. It supports imperative operations like insertion, lookup, and iteration alongside ordered traversal, sequence conversion, and memoization patterns tailored for CIL-based static analysis workflows. These structures are particularly useful for tracking logic entities in Frama-C plugins where structural equality of key data (e.g., function contracts or annotations) drives analysis precision.",
      "description_length": 553,
      "index": 2719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Verbose",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage integer-based configuration settings with bounded values, primarily for controlling verbosity levels in plugins. It supports incrementing, constraining, and querying integer parameters, along with integrating command-line interfaces, serialization, and project-specific state persistence. These features are particularly useful for plugins requiring dynamic configuration adjustments and seamless interaction with Frama-C's project model and plugin services.",
      "description_length": 500,
      "index": 2720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable ordered set abstraction for CIL constants, supporting operations like union, intersection, difference, and element-wise transformations while maintaining strict ordering via a comparison function. It provides utilities for efficient membership checks, ordered traversal, and conversion to/from sequences or lists, with specialized functions for finding nearest elements relative to a key. These capabilities are particularly useful in static analysis plugins that track constant values during C program analysis, enabling precise manipulation of constant domains in tasks like value range propagation or symbolic execution.",
      "description_length": 659,
      "index": 2721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module specializes in hash tables with keys based on the `Option_with_collections` type, enabling operations like insertion, deletion, and lookup alongside ordered iteration and value-based filtering. It supports both imperative updates and functional transformations, with utilities for memoizing functions over keys that combine optional values and collection structures. Typical applications include caching analysis results for Frama-C plugins and managing structured data with optional or nested keys in static analysis workflows.",
      "description_length": 540,
      "index": 2722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyCfg.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing and comparing structured values used in the control flow graph simplification logic. It includes functions for equality checks, comparison, hashing, pretty printing, and deep copying, along with utilities for inspecting project membership within values. The type `t` represents the core data structure being manipulated, with `reprs` providing a list of representative values and `mem_project` enabling project-based filtering.",
      "description_length": 487,
      "index": 2723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables for managing mappings between CIL l-values compared by structural equality and arbitrary data, supporting operations like insertion, lookup, and iteration with customizable ordering. It works with keys representing l-value structures from CIL's abstract syntax and is designed for static analysis tasks such as memoization, equivalence tracking, and integration with Frama-C's type system during program analysis. The tables facilitate efficient storage and retrieval of analysis-related metadata tied to structurally equivalent l-values in C code.",
      "description_length": 583,
      "index": 2724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash table operations for wide string keys, supporting creation, modification, querying, and iteration with ordered traversal and in-place filtering. It manages mappings between `Wide_string.t` values and arbitrary data, enabling structured traversal, persistence, and memoization in static analysis workflows\u2014particularly for CIL-based plugins handling cross-translation unit state or requiring robust key-safe lookups during program analysis.",
      "description_length": 467,
      "index": 2725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map",
      "library": "frama-c.kernel",
      "description": "This module implements maps associating memory locations, represented as byte-level base-offset pairs, with arbitrary values, supporting functional operations like insertion, deletion, ordered traversal, and predicate-based queries. It provides advanced capabilities for memory state manipulation, including merging maps, filtering ranges, and bulk updates from sequences, tailored for static analysis tasks such as detecting memory errors, analyzing pointer arithmetic, or tracking heap allocations in C programs.",
      "description_length": 514,
      "index": 2726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map",
      "library": "frama-c.kernel",
      "description": "This module supports associative operations on maps where keys are memory bases and values are memory slices, enabling precise memory state manipulation. It provides ordered map functionalities including insertion, deletion, lookup, merging, and ordered traversal, along with transformations, bulk updates, and pretty-printing. These operations are utilized in static analysis to track memory evolution, merge abstract memory states, and perform ordered inspections of memory bindings during program verification.",
      "description_length": 513,
      "index": 2727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameter collections, supporting operations to define, enable, and configure categories such as `@none`, `@default`, and `@all`. It works with types like `t` for categories and `elt` for elements, along with accessors and states. Use cases include setting up and modifying parameter categories for plugins using the `-load-library` option.",
      "description_length": 388,
      "index": 2728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G.V",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing vertices in a control flow graph representation of interpreted automata, where each vertex represents a control point in a program. It provides functions to create vertices from labels, retrieve vertex labels, and compare, hash, and check equality of vertices. These operations support analysis tasks such as tracking reachable states and associating guards or actions with transitions between control points.",
      "description_length": 453,
      "index": 2729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table structure for mapping memory zone identifiers (represented as `Frama_c_kernel.Base.t` and `Hptset.t` combinations) to arbitrary values, enabling efficient insertion, lookup, and in-place modification with customizable comparison logic. It supports ordered traversal of entries, bulk operations via sequences, and memoization patterns, tailored for managing metadata or state associated with distinct memory regions in static analysis. Specific applications include tracking memory validity, caching analysis results per memory block, or aggregating properties across dynamic memory zones during program verification.",
      "description_length": 652,
      "index": 2730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered, immutable set abstraction supporting efficient membership tests, element insertion/removal, and set algebra operations (union, intersection, difference). It manipulates elements constrained by a total ordering relation, enabling ordered traversal, nearest-neighbor queries, and conversions to/from lists and sequences. The structure is particularly suited for static analysis tasks requiring precise set manipulations with ordered elements, such as tracking program state abstractions or managing hierarchical data relationships.",
      "description_length": 564,
      "index": 2731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps keyed by CIL enumeration items (`Enumitem.t`), offering persistent storage with efficient search, traversal, and transformation operations like `find`, `fold`, `filter`, and `merge`. It maintains strict key ordering for tasks such as range queries, structural comparisons, and conversions to ordered sequences, tailored for static analysis plugins managing C enumeration definitions, their relationships, or value tracking during code analysis.",
      "description_length": 480,
      "index": 2732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map",
      "library": "frama-c.kernel",
      "description": "This module implements an associative map structure with rational number keys, supporting standard operations like insertion, deletion, lookup, and updates, as well as advanced functions for merging, union, and ordered traversal. It provides utilities for ordered iteration, transformation, filtering, bulk operations, and customizable formatting, along with set-like queries and splitting capabilities. Designed for static analysis applications, it facilitates managing key-value associations with rational keys, enabling precise data flow tracking and integration with Frama-C's analysis frameworks.",
      "description_length": 601,
      "index": 2733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered, immutable sets of CIL types compared structurally by name (without unrolling), supporting operations like union, intersection, and difference alongside transformations (map, filter), membership checks, and conversions to/from lists/sequences. It works with `TypByName.t` elements, which represent C type information in Frama-C's analysis framework, and provides efficient traversal, subset queries, and ordered iteration. Specific use cases include static analysis plugins requiring precise type set manipulations, such as tracking type dependencies or validating type consistency in C programs.",
      "description_length": 627,
      "index": 2734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module constructs a `User_dir_opt` from a `User_dir`, defining operations to retrieve or set a directory path with optional environment variable integration. It provides functions to access directories or files within the user-specified path, supporting use cases like locating configuration or resource files in a configurable base directory. The module directly works with `Frama_c_kernel.Filepath.t` and string identifiers for directory and file resolution.",
      "description_length": 465,
      "index": 2735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Make_Table.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table data structure indexed by kernel functions, providing operations for managing and querying values associated with these functions. It supports standard hash table functionalities such as equality checks, comparison, hashing, and pretty printing, while ensuring deep copying and project-aware membership checks. Concrete use cases include tracking per-function analysis results or storing function-specific metadata across different projects.",
      "description_length": 474,
      "index": 2736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Set",
      "library": "frama-c.kernel",
      "description": "This module offers standard set operations (union, intersection, difference, element insertion/removal) and advanced ordered traversal, filtering, and mapping capabilities for sets of logic constructor info entries. It supports efficient membership queries, subset checks, and conversions between sets and sequences, with specialized utilities for monotonic predicate evaluation and project-specific condition checks. These operations are particularly useful in static analysis plugins for manipulating logical constructs during CIL-based program analysis.",
      "description_length": 556,
      "index": 2737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping CIL constants to arbitrary values, offering creation, mutation, and traversal operations with support for imperative and functional styles. It enables ordered key-value iteration via custom comparisons, safe key retrieval using `find_opt`, and type-aware structuring through `structural_descr`, making it suitable for memoization, static analysis state management, and plugin workflows requiring efficient constant-based lookups.",
      "description_length": 472,
      "index": 2738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables for mapping CIL types (compared structurally, ignoring attributes) to arbitrary values, supporting operations like insertion, lookup, iteration, and folding. It works with keys of type `TypNoAttrs.t`\u2014representing CIL types with structural equality\u2014and provides utilities for bulk updates, ordered traversal, and memoization. Designed for static analysis plugins, it enables efficient type-based key management in scenarios requiring precise type equivalence checks without attribute sensitivity.",
      "description_length": 530,
      "index": 2739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations including insertion, deletion, lookup, iteration, and folding for tables mapping memory zone base keys (`Frama_c_kernel.Base.Base.t`) to arbitrary values, supporting ordered traversal, bulk updates via sequences, and safe access with `find_opt`/`find_def`. It is used in managing memory zone metadata, memoizing computations over addressable regions, and aggregating analysis results requiring efficient lookups and in-place modifications.",
      "description_length": 480,
      "index": 2740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Lemmas.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's logic environment. It supports deep copying and project-aware membership checks, ensuring values can be uniquely identified and manipulated across different project contexts. Concrete use cases include managing logic lemmas with precise type descriptors and representants for formal verification tasks.",
      "description_length": 442,
      "index": 2741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module specializes in hash tables with keys tied to memory map bases and arbitrary values, enabling efficient insertion, lookup, and ordered traversal operations essential for memory state modeling. It supports sorted iterations and folds using custom key/value comparisons, along with sequence conversions and memoization utilities, catering to static analysis plugins that track variable bindings or heap structures. The design bridges low-level memory representations with higher-level abstract interpretations in Frama-C's analysis pipelines.",
      "description_length": 551,
      "index": 2742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations specialized for logic labels as keys, supporting creation, insertion, lookup, iteration, bulk updates from sequences, ordered folding, and memoization. It manages hash tables mapping `Logic_label.t` keys to arbitrary values parameterized by a `Data` module, enabling efficient ordered traversal and structural manipulation. These capabilities are particularly useful in static analysis for tracking logic label associations, caching computed results, and maintaining program property mappings with precise key ordering.",
      "description_length": 562,
      "index": 2743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for a given data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with a specified data type `Data.t` to build a map with values of that type, along with associated metadata such as type descriptors and representants. Concrete use cases include managing and manipulating collections of emitter-related data with efficient lookups, comparisons, and serialization for analysis tasks in Frama-C plugins.",
      "description_length": 493,
      "index": 2744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Version.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing version-related data within the Frama-C kernel. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, along with descriptors and representants for structural manipulation. It is used to handle version information with precise semantic control, particularly in the context of project management and option parsing.",
      "description_length": 433,
      "index": 2745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables that map syntactic scopes (representing C code structure contexts) to arbitrary values, supporting operations like ordered iteration, folding over key-value pairs, value memoization, and safe lookups with default values. It works with sequences for bulk initialization or updates and provides standard hash table functionalities such as creation, modification, and traversal. These structures are specifically used in Frama-C's static analysis to track scope-specific data, such as variable bindings or analysis results, during C code processing.",
      "description_length": 581,
      "index": 2746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` representing logic datatypes, along with operations for equality, comparison, hashing, and pretty printing. It provides access to the type's name, descriptor, and list of representants, supporting deep copying and project membership checks. Use cases include managing and manipulating logic datatype representations in Frama-C's kernel, such as during type analysis or transformation passes.",
      "description_length": 436,
      "index": 2747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyTrivialLoops.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling simplified loop representations during the `-simplify-trivial-loops` analysis phase. It supports equality, comparison, hashing, and pretty-printing for values of type `t`, which represent loop structures in an abstract form. The module also provides utilities for deep copying, membership testing within projects, and integration with Frama-C's type and descriptor system for analysis and transformation tasks.",
      "description_length": 470,
      "index": 2748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered map structure for key-value associations where keys are of a specialized unit type, supporting insertion, deletion, and functional updates while enabling ordered traversal and comparison. It provides operations for transforming, filtering, and querying these maps, with utilities for bidirectional iteration, binding selection, and conversion to/from lists. Designed for static analysis plugins, it facilitates efficient key-based lookups and structured data manipulation in scenarios requiring ordered key handling and deterministic map operations.",
      "description_length": 583,
      "index": 2749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_ctor_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and comparing abstract syntax tree (AST) constructor information during diff computation. It supports operations for equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to track and differentiate logic constructor data across Frama-C projects.",
      "description_length": 368,
      "index": 2750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Set",
      "library": "frama-c.kernel",
      "description": "This module supports union, intersection, and difference operations on sets of CIL types, with structural equality comparisons that exclude attributes, alongside traversal, filtering, and conversion utilities for sequences and lists. It works with ordered, sorted sets of `TypNoAttrs.t` values, enabling efficient membership checks, ordered element manipulation, and type representation tasks like hashing or pretty-printing. It is particularly useful in static analysis plugins for managing type hierarchies, analyzing struct definitions without attribute interference, or optimizing type comparison workflows in CIL-based code transformations.",
      "description_length": 645,
      "index": 2751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides the `only_if` function, which conditionally executes a monadic action based on a boolean flag. It operates on monadic values of type `unit t`, where `t` is a composed monad built from an interior and exterior monad. Use `only_if` to gate execution of effects\u2014such as logging or state updates\u2014based on runtime conditions without altering the structure of the monadic computation.",
      "description_length": 399,
      "index": 2752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent dictionary with ordered keys of CIL types using structural comparison without unrolling, enabling efficient insertion, deletion, and merging of polymorphic values alongside ordered traversal and filtering. It maintains key order for precise type handling in static analysis plugins, supporting advanced operations like bidirectional iteration, sequence conversion, and structural transformations tailored to Frama-C's static analysis needs.",
      "description_length": 476,
      "index": 2753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered key-value maps with logic real numbers as keys, supporting associative storage, retrieval, and transformation of polymorphic values. It includes ordered traversal, range queries, and structural operations like merging and filtering, designed for use in static analysis tasks requiring precise numeric key handling and ordered data manipulation.",
      "description_length": 373,
      "index": 2754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of CIL locations with operations for set algebra (union, intersection, difference), ordered iteration and folding, reverse traversal, and nearest-element lookups. It supports transformations like mapping and filtering under monotonicity constraints, conversions to/from lists/sequences, and project-specific membership tests, while enforcing strict ordering guarantees. These capabilities are particularly useful for static analysis tasks requiring precise tracking and manipulation of source code positions in CIL representations, such as Frama-C plugin development.",
      "description_length": 603,
      "index": 2755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Axiomatics.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in logic environments. It supports deep copying, membership checks over project skeletons, and provides descriptors for type and structural representation. Concrete use cases include managing logical type representations in Frama-C's kernel, ensuring correct handling of project-specific data with custom rehashing constraints.",
      "description_length": 447,
      "index": 2756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enumitem.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and comparing abstract syntax tree (AST) elements in the context of computing diffs between projects. It supports operations such as equality checking, comparison, hashing, and pretty printing, specifically tailored for enum items in the AST. The module also provides utilities for deep copying values and checking the presence of specific project-related data within them.",
      "description_length": 421,
      "index": 2757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys based on CIL data types that enforce strict structural equality, supporting operations like insertion, lookup, iteration, and in-place transformations. It works with key-value pairs where keys are compared using precise type-discriminating equality, enabling use cases such as memoization, static analysis, and ordered traversal with custom comparison logic. The design facilitates robust plugin development by ensuring type-safe construction and efficient manipulation of CIL-based data structures.",
      "description_length": 544,
      "index": 2758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for managing associations between CIL code annotations and arbitrary values, including insertion, lookup, deletion, and deterministic traversal via customizable key ordering. It supports specialized data structures for static analysis plugins that need to track annotated CIL elements, enabling use cases like memoizing analysis results or aggregating metadata across code annotations. Advanced features include bulk updates from sequences and ordered folding over keys, values, or entries, which are particularly useful for deterministic processing of annotated control-flow graphs or program points.",
      "description_length": 655,
      "index": 2759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations specialized for CIL locations, supporting imperative modifications, ordered traversal by keys or values, and bulk updates from sequences. It manages mappings from CIL location keys to arbitrary values, enabling efficient data association with code positions. These features are particularly useful in static analysis plugins for tasks like memoization, iterative analysis, and tracking code-specific properties.",
      "description_length": 454,
      "index": 2760,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable set data structure for 32-bit integers, enabling efficient creation, manipulation (union, intersection, difference), and transformation (map, filter) operations. It supports ordered iteration, membership queries, and conversions between sets, lists, and sequences, with additional utilities for nearest-element searches and integration with Frama-C's analysis systems through type descriptors. Such functionality is particularly useful in static analysis plugins for tracking integer ranges, managing program state constraints, or implementing domain-specific analyses requiring precise set operations.",
      "description_length": 638,
      "index": 2761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations to retrieve, set, and manage boolean parameters in a loaded Frama-C plugin. It supports getting and setting `bool` values by name, checking if a parameter is set or uses the default, and toggling values with `on` and `off`. Use cases include configuring plugin behavior through named boolean flags, such as enabling or disabling analysis features.",
      "description_length": 379,
      "index": 2762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of ACSL properties sorted by a composite key of kernel function name, instruction, property kind, and identifier. It supports standard set manipulations (union, intersection, difference) alongside ordered traversal (monotonic search, in-order iteration/folding) and structure-preserving transformations (map, filter, partition). The ordered sets facilitate static analysis workflows requiring deterministic property processing sequences, such as incremental analysis state management or ordered proof obligation generation.",
      "description_length": 590,
      "index": 2763,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of CIL structure and union type descriptors (`Compinfo.t`), supporting functional and imperative patterns like union, intersection, filtering, and ordered traversal. It provides utilities for element queries, nearest-key searches, and conversions to/from lists/sequences, alongside type-specific equality and hashing. These operations are used in static analysis to track and compare composite type definitions, enabling tasks like type inference, structural equivalence checks, and code transformation pipelines.",
      "description_length": 580,
      "index": 2764,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations implemented via balanced binary trees, supporting element manipulation (addition, removal, membership checks), set algebra (union, intersection, difference), and ordered transformations (filtering, mapping, partitioning). It works with ordered elements of type `Set.elt` stored in `Set.t` structures, leveraging comparison logic to maintain sorted invariants. Designed for scenarios requiring efficient ordered collection management, such as static analysis plugins tracking program state dependencies or hierarchical data relationships.",
      "description_length": 579,
      "index": 2765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys based on CIL predicates and structural equality. It supports imperative operations such as creation, modification, lookup, and ordered iteration or folding (using custom or default key comparisons), alongside utilities for safe value retrieval, memoization, and sequence-driven initialization. These structures are particularly useful for managing mappings where keys require structural equivalence checks, enabling deterministic traversal or caching in analyses involving predicate-based computations.",
      "description_length": 547,
      "index": 2766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, specifically tailored for small integer sets and intervals. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage keys that represent either small integer sets or intervals in contexts like value analysis or abstract interpretation.",
      "description_length": 403,
      "index": 2767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps keyed by usable emitters, enabling precise management of emitter-to-data associations through operations like insertion, deletion, merging, and ordered traversal. It supports value transformation, filtering, and structural queries while maintaining key order, with utilities for pretty-printing and sequence-based construction. Designed for static analysis plugins, it facilitates tracking annotations or properties emitted by Frama-C emitters, allowing project-aware data aggregation and manipulation during analysis workflows.",
      "description_length": 564,
      "index": 2768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a functional set abstraction for managing ordered collections of comparable elements, supporting standard operations like union, intersection, difference, and cardinality, alongside element queries such as `min_elt`, `max_elt`, and nearest-value searches. It provides functional transformations (`map`, `filter`), iteration via `fold` and `to_seq`, and conversions to/from sequences, all leveraging a total ordering from an associated `Ord` module. It is suited for static analysis tasks requiring precise set semantics and ordered data manipulation, such as tracking value ranges or state spaces in program verification.",
      "description_length": 644,
      "index": 2769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations on abstract memory values, including union, intersection, difference, and membership tests, as well as iteration, folding, and mapping while preserving element order. It supports efficient search using monotonic predicates, conversions between sequences and ordered sets, and computations of extremal elements, enabling use cases like tracking possible memory states and analyzing value ranges during program verification.",
      "description_length": 468,
      "index": 2770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintVersion.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating version information in the context of the `-print-version` command-line option. It supports equality checks, comparison, hashing, pretty-printing, and deep copying of version data, along with introspection via descriptors and representants. It is used to manage and query structured version metadata within Frama-C's kernel, particularly during version reporting or comparison tasks.",
      "description_length": 475,
      "index": 2771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables that store properties associated with program elements in Frama-C plugins. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and query property keys tied to specific analysis projects or contexts.",
      "description_length": 380,
      "index": 2772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for polymorphic key-value pairs, supporting creation, insertion, deletion, and combination with ordered traversal. It works with comparable key types and structured data representations like sequences, lists, and custom-formatted key-value pairs. Designed for static analysis tasks, it enables efficient map manipulation, ordered binding queries, and precise data transformation in scenarios requiring key ordering guarantees.",
      "description_length": 470,
      "index": 2773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedOverflow.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for handling signed integer overflow scenarios in static analysis. It provides equality, comparison, hashing, and pretty-printing functions for values of this type, along with deep copying and membership checks over project skeletons. The module is used to manage and analyze signed overflow behavior in C code during static analysis, particularly when the `-warn-signed-overflow` option is enabled.",
      "description_length": 457,
      "index": 2774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module specializes in imperative hash table operations for abstract memory values, using keys that represent byte locations or scalar values from C programs. It provides functionality for creating, modifying, and iterating over these structures while preserving order and enabling analysis-specific workflows. Typical applications include tracking memory state transformations during static analysis and memoizing computations on abstract values.",
      "description_length": 451,
      "index": 2775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing sets of structural offsets, including union, intersection, element queries, and transformations. These sets store `Offset.t` values representing field offsets in C structures, enabling tasks like memory layout analysis and static code optimization within the Frama-C framework. Specific functions for nearest element queries and reverse iteration support precise manipulation of hierarchical data layouts in C abstract syntax trees.",
      "description_length": 475,
      "index": 2776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module offers set operations for managing collections of C function declarations (`Fundec`) and string/category-based plugin parameters, supporting tasks like addition, iteration, filtering, and persistence via custom marshaling. It works with `Fundec.Set.t` for function sets, validated strings, and categorized parameters, enabling use cases such as command-line option parsing, stateful analysis across projects, and dynamic update hooks for plugin-specific logic. Key applications include static analysis plugins requiring selective function processing, parameter validation, and cross-session state management.",
      "description_length": 620,
      "index": 2777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_set_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for managing and manipulating statement references within Frama-C's kernel, including equality, comparison, hashing, and pretty-printing. It works with the `t` type, representing a collection of statements, and supports deep copying and project membership checks. Concrete use cases include tracking and analyzing control flow statements during static analysis, such as in plugin development or custom linting rules.",
      "description_length": 459,
      "index": 2778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LibEntry.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing library entry points in Frama-C, including operations for equality, comparison, hashing, and pretty-printing. It provides access to metadata such as the type, name, and descriptor of each entry point, along with utilities for deep copying and checking project membership. Concrete use cases include analyzing and manipulating entry point data during plugin development or processing command-line options related to library entry behavior.",
      "description_length": 487,
      "index": 2779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.List",
      "library": "frama-c.kernel",
      "description": "This module provides operations to iterate over, map, and fold lists within a lattice context that supports top values. It works with lists of values wrapped in a lattice monad that tracks top elements. Use it to process lists in static analysis contexts where top represents an over-approximation of possible values.",
      "description_length": 317,
      "index": 2780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys of type `Frama_c_kernel.Cil_datatype.Logic_real.t`, supporting operations like creation, lookup, ordered iteration, folding, and value memoization. It handles mappings from logic real keys to arbitrary values, enabling deterministic traversal via custom comparators and safe value retrieval with fallback defaults. The structure is particularly useful in static analysis plugins for tasks requiring precise key ordering, stateful computations over CIL logic reals, or sequence-driven updates integrated with Frama-C's type system.",
      "description_length": 575,
      "index": 2781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing key-value pairs with ordered keys, supporting creation, in-place modification, iteration, filtering, and conversion to sequences. It works with `Hashtbl.t` structures where keys are ordered and typed (via Frama-C's type system) and values are polymorphic, enabling efficient lookups and ordered traversals. Use cases include memoization, state management in plugins, and handling collections requiring sorted key/value processing or fallback values.",
      "description_length": 505,
      "index": 2782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for keys based on CIL lvalues with structural equality and strict constant comparison, enabling precise identity checks. It supports creation, insertion, lookup, and ordered traversal of entries, along with bulk updates from sequences and memoization. Designed for scenarios requiring exact structural equivalence, it is particularly useful in static analysis tasks like tracking memory locations or optimizing redundant computations over CIL constructs.",
      "description_length": 495,
      "index": 2783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Bool_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean reference datatype with standard operations including equality, comparison, hashing, and pretty printing. It provides a deep copy function, membership testing for project values, and includes type descriptors for structural manipulation. Concrete use cases include managing boolean state within Frama-C plugins, where reliable value comparison, storage, and transformation are required.",
      "description_length": 416,
      "index": 2784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with normalized, type-safe filepaths as keys, offering operations for creation, insertion, deletion, and safe lookup. It supports ordered iteration and folding over entries, along with memoization of values derived from filepaths, enabling efficient management of file-related metadata. Typical applications include caching file-specific data, tracking project resources, and ensuring consistent path handling across analyses.",
      "description_length": 461,
      "index": 2785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing loaded libraries in the kernel, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with lists of representants, project membership tests, and deep copying to manage state across analysis sessions. Concrete use cases include tracking loaded libraries during command-line processing and ensuring consistent data handling during project serialization.",
      "description_length": 441,
      "index": 2786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.String",
      "library": "frama-c.kernel",
      "description": "This module provides operations to retrieve, set, and manage string-valued plugin parameters at runtime. It supports checking whether a parameter has been set or is still at its default value, as well as clearing a parameter back to its default. These functions are used to interact with specific named string configuration options exposed by loaded plugins.",
      "description_length": 358,
      "index": 2787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and manipulating ordered sets, including union, intersection, difference, and membership checks, alongside transformations like filtering, mapping, and folding over elements. It works with a parameterized set type (`Set.t`) whose elements (`Set.elt`) must support comparison and equality, ensuring sorted internal representation. Specific use cases include managing collections of unique values with sorted traversal, performing set-theoretic analysis in static program verification, and integrating with sequences for ordered data processing.",
      "description_length": 592,
      "index": 2788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map",
      "library": "frama-c.kernel",
      "description": "This module provides associative operations for mapping keys composed of a type and string identifier to arbitrary values, supporting insertion, deletion, lookup, and ordered traversal with deterministic comparison semantics. It includes specialized utilities for list-valued maps, functional updates, and analysis-aware construction, while maintaining key ordering for efficient search and bulk processing. These operations are designed for managing built-in logic information in CIL during static analysis, enabling tasks like property tracking and transformation across typed program elements.",
      "description_length": 596,
      "index": 2789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map",
      "library": "frama-c.kernel",
      "description": "This module provides associative map operations for managing associations between CIL term l-values and arbitrary data, supporting imperative modifications, ordered key traversal, and functional transformations. It handles both standard key-value maps and bidirectional mappings, offering specialized operations for static analysis tasks like tracking term l-value relationships, aggregating analysis results, or transforming CIL-based representations with ordered key sequences and safe/unsafe value access.",
      "description_length": 508,
      "index": 2790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map",
      "library": "frama-c.kernel",
      "description": "This module provides associative map operations for managing key-value bindings with ordered memory offset keys, supporting insertions, deletions, ordered traversal (min/max/first), and list-specific updates like `add_to_list`. It works with polymorphic maps (`'a Map.t`) over a fixed key type representing memory offsets, enabling structural transformations (map, filter, fold), comparisons, and memory state queries. Designed for static analysis tasks, it facilitates memory map merging, ordered processing of memory regions, and tracking dynamic memory states during program verification.",
      "description_length": 591,
      "index": 2791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Gcc_builtin_templates_loaded.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis of C code. It includes descriptors for structural representation, support for project membership checks, and deep copying to ensure no shared state. Concrete use cases include managing and analyzing GCC built-in types within Frama-C's kernel, such as tracking type properties and ensuring consistent type representations across analyses.",
      "description_length": 481,
      "index": 2792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Compinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing abstract values in the context of computing AST differences between C projects. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to manage and manipulate structural differences in C abstract syntax trees during analysis.",
      "description_length": 375,
      "index": 2793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppGnuLike.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use with the `-cpp-frama-c-compliant` behavior. It includes functions to inspect and manipulate values of type `t`, such as deep copying, membership testing in projects, and access to type descriptors and representants. Use cases include analyzing and transforming C code during parsing under the Frama-C kernel's compliant preprocessing mode.",
      "description_length": 477,
      "index": 2794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map",
      "library": "frama-c.kernel",
      "description": "This module provides an ordered map structure for associating data with CIL statements, enabling precise static analysis tasks like tracking statement-specific properties or transforming code. It supports key-based operations such as insertion, deletion, lookup, and merging, along with ordered traversal, filtering, and structural queries, all maintaining strict statement key ordering via a comparison function. Designed for Frama-C's analysis plugins, it facilitates managing associations between statements and metadata, such as control flow information or transformation rules, in C code processing workflows.",
      "description_length": 614,
      "index": 2795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Int",
      "library": "frama-c.kernel",
      "description": "This module provides facilities for creating and managing integer command-line parameters with optional range constraints, including value modification, change notifications, alias handling, and persistent state management. It operates on integer values and bounded ranges, supporting use cases such as configuring analysis thresholds or iteration counts in Frama-C plugins that require integration with the command-line interface and project system.",
      "description_length": 450,
      "index": 2796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Set",
      "library": "frama-c.kernel",
      "description": "This module provides standard set operations for managing collections of CIL attributes, including creation, union, intersection, difference, and membership checks, alongside transformations like mapping and filtering. It works with sets of `Attributes.t` elements, preserving physical equality for unchanged values and supporting ordered traversal, iteration, and conversion to/from lists and sequences. Specific use cases include static analysis tasks such as tracking variable annotations, function attributes, or metadata during C program analysis, where efficient set manipulation and structural comparisons (e.g., hashing, pretty-printing) are required.",
      "description_length": 659,
      "index": 2797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.E",
      "library": "frama-c.kernel",
      "description": "This module defines edge structures for control flow graphs, where each edge connects two vertices and carries a label. It provides operations to create edges, retrieve their source and destination vertices, and access their labels. The module supports directed edges with ordering, enabling graph construction and traversal in abstract interpretation workflows.",
      "description_length": 362,
      "index": 2798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing key-value maps indexed by file paths, enabling configuration through command-line parameters and dynamic state updates. It works with string-based keys representing file paths and function names, supporting validation, default values, aliases, and serialization, while integrating with plugin-specific categories and change-tracking hooks. It is particularly useful for Frama-C plugins requiring file-specific analysis settings, runtime configuration adjustments, or hierarchical option grouping with type-safe persistence.",
      "description_length": 568,
      "index": 2799,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingForce.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` and associated operations for managing and comparing structured data representations. It provides functions for equality checks, comparison, hashing, pretty printing, and deep copying, along with utilities to inspect and filter data based on project membership. The module is used to handle complex data types in the context of Frama-C's kernel, particularly for implementing the `-ulevel-force` option behavior.",
      "description_length": 455,
      "index": 2800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for a given data type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with any data type provided by the `Data` module parameter, ensuring deep copies and project-aware membership checks. Concrete use cases include managing collections of abstract values with custom semantics, such as tracking intervals or symbolic expressions in static analysis.",
      "description_length": 448,
      "index": 2801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecMode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling generated specification modes in the kernel. It provides utilities to check membership within a project context, create deep copies, and manage type representations through descriptors and packed forms. Concrete use cases include managing and comparing specification mode values during static analysis, ensuring correct project-specific behavior in Frama-C's kernel operations.",
      "description_length": 520,
      "index": 2802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to manage symbolic path configurations through string-based command-line options, focusing on parsing, validation, and dynamic state management for symbolic path entries. It operates on string lists to enforce value constraints, validates function names or paths against predefined rules, and supports serialization for persistent project state. Common use cases include configuring Frama-C's `-add-symbolic-path` behavior, ensuring correct path-to-name mappings, and tracking analysis context across sessions.",
      "description_length": 541,
      "index": 2803,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.M",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for associating bases with intervals, enabling key-based access and iteration over base-interval pairs. It supports operations like lookup (`find`), iteration (`iter`), and folding (`fold`) across base-interval entries, along with extracting the shape of the map. It is used to manage abstract memory representations where each base corresponds to a range of values, such as tracking possible values for memory locations in static analysis.",
      "description_length": 479,
      "index": 2804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Frama_c_builtins.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling built-in function representations during CIL processing. It supports deep copying, membership checks over project skeletons, and provides descriptors for structural and packed representations. Concrete use cases include managing and comparing built-in function metadata during static analysis, ensuring correct handling of C standard library functions in Frama-C's kernel.",
      "description_length": 502,
      "index": 2805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set",
      "library": "frama-c.kernel",
      "description": "This module provides set-based configuration management for plugins, supporting operations like element addition",
      "description_length": 112,
      "index": 2806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive set of immutable map operations for ordered key-value associations, supporting creation, transformation, and querying with functions like insertion, deletion, filtering, and ordered traversal. It works with key types that have defined equality, comparison, and hashing, enabling efficient data manipulation through functional patterns that return new maps instead of modifying existing ones. The module is particularly suited for static analysis tasks requiring symbolic key handling and ordered data representation, such as program analysis or structured data transformations.",
      "description_length": 612,
      "index": 2807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic function `only_if` that conditionally executes a monadic action based on a boolean value. It operates on the `unit t` monadic type, allowing boolean conditions to control the flow of monadic computations. A concrete use case is selectively running a logging or analysis step in a larger monadic pipeline when a given flag is true.",
      "description_length": 361,
      "index": 2808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidPointer.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing invalid pointer representations in Frama-C's kernel. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Use cases include tracking and comparing invalid pointer states during static analysis and emitting user-friendly diagnostics.",
      "description_length": 383,
      "index": 2809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Model_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing abstract model information in the context of computing AST differences. It supports operations for equality checking, comparison, hashing, and pretty printing, as well as deep copying and project membership testing. The type is used to handle model data with structural descriptions, enabling precise tracking and manipulation of representants and descriptors during diff computation.",
      "description_length": 433,
      "index": 2810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Permissive.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling abstract data representations in kernel extensions. It supports introspection via descriptors and project membership checks, enabling precise data analysis and transformation tasks. Typical use cases include implementing custom data types for static analysis plugins and managing structured values within the kernel's internal logic.",
      "description_length": 470,
      "index": 2811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a functional interface for creating and manipulating sets of `Term.t` values, supporting operations like union, filtering, ordered iteration, and safe element access via optional variants. It includes utilities for converting sets to sequences, finding nearest elements relative to a value, and maintaining uniqueness and order during transformations. These capabilities are particularly useful in static analysis plugins for tracking and reasoning about CIL terms during code verification or transformation tasks.",
      "description_length": 533,
      "index": 2812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Float",
      "library": "frama-c.kernel",
      "description": "This module enables the registration and management of floating-point parameters for plugins, offering operations to set and retrieve values, define hooks for change detection, handle aliases, and integrate with marshaling systems. It operates on `float` values, which can be constrained within configurable min/max bounds, and is particularly useful for plugin configuration and state management in Frama-C's extensible architecture",
      "description_length": 433,
      "index": 2813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Lval_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a hash table for lvalues with support for efficient lookups, insertions, and equality checks. Works with CIL lvalue representations, including variables, memory accesses, and field selections. Useful for tracking and comparing memory locations during static analysis passes such as value analysis or slicing.",
      "description_length": 319,
      "index": 2814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a finite map implementation over ordered keys, supporting insertion, deletion, merging, and querying operations. It manages maps binding global variables to arbitrary data, offering ordered traversal, transformation, and conversion functions for tasks like program analysis where ordered key handling and range-based operations are critical.",
      "description_length": 362,
      "index": 2815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PreprocessAnnot.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. It works with structural descriptions, type representations, and project skeletons to support analysis of annotated C code during preprocessing. Concrete use cases include managing and querying data structures during static analysis, ensuring deep copies for state manipulation, and formatting values for diagnostic output.",
      "description_length": 500,
      "index": 2816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` by extending an existing directory with a new subdirectory. It provides `get_dir` and `get_file` to retrieve subdirectories and files within the site, ensuring they exist and are of the correct type. It is used to organize and access plugin-specific resources within Frama-C's directory structure.",
      "description_length": 333,
      "index": 2817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfigJson.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating structured configuration data used by the `-print-config-json` option. It supports values of type `t` with functionalities for equality checks, comparison, hashing, pretty-printing, and deep copying, along with introspection via descriptors and representants. It is used to serialize and inspect kernel configuration state in JSON format, particularly during option processing and configuration dumping.",
      "description_length": 497,
      "index": 2818,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module provides a string-indexed map structure for managing plugin-specific value lists, supporting operations to set, update, and query entries, as well as register hooks for change notifications. It integrates with Frama-C's project system to enable state persistence, analysis computation tracking, and command-line option handling, with use cases including parameter validation, custom marshaling, and deprecation warning management for plugin development.",
      "description_length": 465,
      "index": 2819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered set abstraction for wide strings, supporting functional operations like union, intersection, difference, and ordered traversal, along with element-wise transformations and predicates. It works with immutable sets of `Wide_string.t` values, leveraging their total ordering for efficient membership tests, nearest-neighbor queries, and structural operations like pretty-printing or hashing. Typical use cases include static analysis tasks requiring precise manipulation of string sets, such as tracking string constants in C code or enforcing semantic constraints during program verification.",
      "description_length": 624,
      "index": 2820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Check.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values within the context of the `-check` option's behavior. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle structured data during static analysis, particularly for tracking and comparing check-related values across different analysis states.",
      "description_length": 427,
      "index": 2821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.C11.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It works with structured descriptors and representants, supporting introspection and manipulation of C11-related data in kernel extensions. Concrete use cases include managing and comparing C11 datatype representations within static analysis plugins.",
      "description_length": 429,
      "index": 2822,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Option_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling optional reference values within a state-building context, supporting operations like equality, comparison, hashing, and pretty-printing. It works with the `t` type representing optional references and includes utilities for project membership checks and deep copying. Concrete use cases include managing nullable state elements in static analysis plugins, such as tracking the presence or absence of specific analysis artifacts.",
      "description_length": 473,
      "index": 2823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Offsetmap.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "This module implements narrowing operations for offsetmaps, which represent abstract memory slices as mappings from bit intervals to values. It provides two functions: `narrow` computes an over-approximated intersection without bitwise reinterpretation, potentially leading to unsound results, while `narrow_reinterpret` reinterprets values to their normal forms before intersecting, ensuring more accurate results despite possible inclusion loss. These operations are used during abstract interpretation to refine memory states by combining information from two offsetmaps covering the same memory range.",
      "description_length": 605,
      "index": 2824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping memory locations\u2014represented as base-offset pairs in bytes\u2014to arbitrary values, supporting standard imperative operations (insertion, deletion, lookup), bulk transformations (iteration, folding, sequence conversion), and in-place modifications with utilities like `filter_map_inplace`. It enables ordered traversal of keys or entries using custom comparison logic and includes mechanisms for safe value retrieval, memoization, and statistical tracking. These structures are primarily used in static analysis to model and track memory regions and their associated data during program verification tasks.",
      "description_length": 645,
      "index": 2825,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for managing key-value pairs with customizable key types, supporting creation, in-place modification, iteration, and bulk updates from sequences. It works with hash tables (`'a Hashtbl.t`) and emphasizes type-safe, efficient manipulations for use cases like memoization, ordered data processing, and analysis tasks requiring precise key management in Frama-C.",
      "description_length": 400,
      "index": 2826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Filepath",
      "library": "frama-c.kernel",
      "description": "This module provides operations to retrieve, set, and manage file path parameters for plugins, using the `Frama_c_kernel.Filepath.t` type. It allows checking whether a parameter has been set or is at its default value, and supports clearing parameter values. Concrete use cases include configuring plugin input/output paths or resource locations dynamically during analysis.",
      "description_length": 374,
      "index": 2827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Empty_string",
      "library": "frama-c.kernel",
      "description": "This module enables plugins to register and manage string parameters with validation, change hooks, and serialization support, operating on string values integrated with Frama-C's plugin system via the `Datatype` module. It facilitates use cases like enforcing allowed values for configuration options (e.g., file paths, identifiers) and tracking parameter lifecycle events to react dynamically to updates during analysis. The module also supports alias management and function name validation, ensuring robust state mutation handling and compatibility with plugin workflows.",
      "description_length": 575,
      "index": 2828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage persistent, observable global string sets as plugin parameters, supporting element addition, membership checks, iteration, and modification with change hooks. It integrates with Frama-C's project system for state management and serialization, enabling use cases like command-line option configuration, dynamic validation through the As_string module, and category-based organization of analysis settings. The underlying data structure provides atomic updates and persistence across analyses while ensuring compatibility with Frama-C's state snapshotting and restoration mechanisms.",
      "description_length": 621,
      "index": 2829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with 32-bit integer keys, offering operations for creating, modifying, and traversing key-value pairs with support for ordered iteration, bulk updates from sequences, and safe value retrieval using defaults or memoization. It works with structured keys and values, enabling efficient storage and deterministic traversal while maintaining compatibility with Frama-C's plugin framework for tasks like state management or data analysis. Use cases include scenarios requiring predictable key ordering, incremental table construction, and integration into static analysis plugins needing compact integer-keyed data representations.",
      "description_length": 661,
      "index": 2830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.MainFunction.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating the entry point of a program analysis. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying of values, as well as utilities to inspect and filter values based on embedded project data. The type `t` is used to capture the semantics of the `-main` command-line option, enabling precise handling of analysis entry points in a way that supports extensible and structured data manipulation.",
      "description_length": 522,
      "index": 2831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map",
      "library": "frama-c.kernel",
      "description": "This module provides finite maps keyed by CIL expressions, using their unique `eid` identifiers for comparison and ordering. It supports standard map operations like `add`, `remove`, and `find`, along with higher-order functions for transformation (`map`, `mapi`), combination (`merge`, `union`), and ordered traversal (`iter`, `fold`). These maps are particularly useful in static analysis tasks where CIL expressions serve as keys for associating metadata, such as tracking expression-specific properties or performing expression-indexed dataflow computations.",
      "description_length": 562,
      "index": 2832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps with float keys, supporting operations like `add`, `remove`, `merge`, and value transformations via functions such as `update` and `add_to_list` for list-valued maps. It provides ordered traversal, filtering, and conversion to/from lists and sequences, with utilities for static analysis tasks such as tracking floating-point values and numeric ranges in Frama-C. Specialized features include monotonic predicate searches, bidirectional iteration, and pretty-printing for debugging analysis results.",
      "description_length": 534,
      "index": 2833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations\u2014creation, insertion, lookup, iteration, and conversion to/from sequences\u2014for keys based on CIL types with structural identity comparison that avoids unrolling. It is designed for scenarios requiring precise type analysis in C code, such as tracking typedefs or structs without expanding them, enabling use cases like memoization of type-sensitive computations or managing analysis state where structural equivalence is critical. The module ensures compatibility with Frama-C's analysis semantics by preserving key identity and supporting ordered traversal over entries.",
      "description_length": 612,
      "index": 2834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map",
      "library": "frama-c.kernel",
      "description": "This module implements attribute-keyed maps with ordered traversal and efficient operations for static analysis tasks involving CIL attributes. It provides ordered key-value maps where keys are CIL attributes and values can be arbitrary data, supporting insertion, deletion, filtering, and conversion to/from lists/sequences while preserving key ordering. Designed for static analysis scenarios like tracking source-code annotations, optimizing attribute-based transformations, or managing metadata during C program analysis, it offers both exception-safe lookups and bulk operations with physical equality optimizations to minimize memory overhead.",
      "description_length": 649,
      "index": 2835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with character keys and ordered operations, supporting creation, modification, and iteration with safe value retrieval (`find_opt`, `find_def`), bulk updates from sequences, and memoization. It works with `Frama_c_kernel.Datatype.Char.t` keys and associated values, enabling ordered folding over keys, values, or entries. Typical use cases include managing character-indexed mappings requiring predictable traversal order, efficient lookups, or cached computations in plugin development scenarios.",
      "description_length": 532,
      "index": 2836,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps that associate memory zones\u2014represented by base addresses and bit ranges\u2014with arbitrary data, supporting operations like insertion, deletion, merging, and ordered traversal. It provides utilities for filtering, transforming, and querying these associations, with specialized functions for static analysis tasks such as tracking memory state or analyzing variable ranges. The structure emphasizes ordered key-based manipulation, sequence conversion, and customizable formatting, making it suitable for applications in program analysis where precise memory region handling is critical.",
      "description_length": 618,
      "index": 2837,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing by project, and integrates with Frama-C's type and descriptor system for runtime type information. Concrete use cases include managing collections of properties with efficient lookups and ensuring type-safe storage within Frama-C plugins.",
      "description_length": 452,
      "index": 2838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map",
      "library": "frama-c.kernel",
      "description": "This module provides standard map operations (insertion, removal, lookup) and advanced traversal, transformation, and filtering functions (e.g., `map`, `fold`, `filter`, `partition`) for maps with keys derived from CIL global annotations. It emphasizes functional programming patterns with immutable data structures, ordered key processing, and utilities for handling absent keys via `option` types, while supporting use cases like static analysis and transformation of C code in Frama-C plugins. Additional features include reverse iteration, sequence-based construction, and pretty-printing for debugging or visualization of annotation-value mappings.",
      "description_length": 653,
      "index": 2839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G.V",
      "library": "frama-c.kernel",
      "description": "This module defines vertices for a state dependency graph, where each vertex is labeled and uniquely identified by its associated state. It provides operations to create vertices from labels, retrieve vertex labels, and compare, hash, and check equality of vertices. The module is used to represent and manipulate nodes in a graph tracking dependencies between program states during static analysis.",
      "description_length": 399,
      "index": 2840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map",
      "library": "frama-c.kernel",
      "description": "This module provides associative map operations for boolean keys, supporting insertion, deletion, lookup, and ordered traversal with physical equality optimizations. It works with polymorphic maps where keys are `Frama_c_kernel.Datatype.Bool.t` values, enabling functional transformations, filtering, and analysis of key-value pairs. Designed for static analysis tasks, it is particularly useful in tracking boolean flags or configuration states within Frama-C plugins, offering efficient ordered iteration and customizable data representation.",
      "description_length": 544,
      "index": 2841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing operations to iterate, map, and fold over list elements within a monadic context. It works with lists of values and monadic functions that return values wrapped in a composed monad. Concrete use cases include processing lists of inputs where each element requires a stateful or effectful computation, such as parsing or analysis passes in a compiler or static analysis tool.",
      "description_length": 432,
      "index": 2842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph",
      "library": "frama-c.kernel",
      "description": "This module provides imperative manipulation of labeled, directed graphs with explicit support for vertex and edge labeling, offering operations to query structural properties (counts, degrees, adjacency), modify graph elements (add/remove edges with automatic vertex handling), and traverse predecessor/successor relationships. It operates on graphs where vertices and edges are associated with rich metadata, enabling analysis of service dependencies in callgraphs through tasks like impact propagation and dependency resolution. The structure is optimized for dynamic graph updates while maintaining efficient access patterns for large-scale software analysis.",
      "description_length": 663,
      "index": 2843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in property maps, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with project-specific values through membership checks and deep copying. Concrete use cases include managing and querying properties associated with analysis projects in Frama-C plugins.",
      "description_length": 347,
      "index": 2844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for monadic composition and value extraction, specifically `(>>-)`, `(let*)`, `(>>-:)`, and `(let+)`, which facilitate chaining monadic actions and applying functions within a monadic context. It operates on any monad that implements the minimal interface based on `bind`, allowing for concise and idiomatic monadic code. Concrete use cases include sequencing effectful computations, transforming results, and flattening nested monadic expressions without explicit use of `bind`.",
      "description_length": 515,
      "index": 2845,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Custom",
      "library": "frama-c.kernel",
      "description": "This module enables defining customizable plugin parameters with associated state and rich semantic operations, supporting structured data through a custom type `t` and the `Datatype` module. It provides functionality to configure validation constraints, manage aliases with metadata, and handle marshaling, primarily operating on string lists and unit values. It is particularly useful for advanced plugin configurations requiring hierarchical data structures, validated input ranges, or versioned parameter schemas with deprecation handling.",
      "description_length": 543,
      "index": 2846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations\u2014such as creation, insertion, deletion, and lookup\u2014alongside functional transformations like folding and iteration, all optimized for boolean keys. It manages associations between `Frama_c_kernel.Datatype.Bool.t` keys and arbitrary values, supporting ordered traversal, value comparison, and memoization. Designed for static analysis, it excels in scenarios where boolean keys represent program states or conditions, enabling efficient state tracking and function result caching in formal verification workflows.",
      "description_length": 565,
      "index": 2847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Modules.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's logic environment. It supports values that may contain project-specific data, with functions to check membership in projects and perform deep copies. Concrete use cases include managing and comparing logic expressions or types within Frama-C analyses.",
      "description_length": 384,
      "index": 2848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module constructs a map datatype based on a given value datatype, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module, enabling structured storage and manipulation of typed values within maps. Concrete use cases include managing collections of analyzed program elements with associated metadata in static analysis plugins.",
      "description_length": 421,
      "index": 2849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatHex.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a specific data type used to represent and manipulate floating-point hexadecimal values. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Use cases include handling and analyzing floating-point constants in Frama-C's kernel, particularly when processing the `-float-hex` option.",
      "description_length": 393,
      "index": 2850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map",
      "library": "frama-c.kernel",
      "description": "The module provides operations for managing a command-line parameter map that allows multiple values per key, including adding entries, checking existence, folding over elements, and handling aliases with visibility and deprecation controls. It works with key-value pairs defined by modules K and V, incorporates project-specific state management, and supports marshaling customization through Datatype and As_string submodules. This structure is used for handling multi-binding command-line options like include paths, tracking configuration changes, and persisting analysis settings across sessions.",
      "description_length": 601,
      "index": 2851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters for library loading, offering operations to set and validate allowed values, extract function names, and handle plain strings. It works with parameterized string values and collections of possible inputs, supporting use cases like configuring loadable modules, enforcing value constraints, and bridging user-provided arguments with internal kernel state. Key features include dynamic value validation, alias handling, and integration with Frama-C's project management system for persistent configuration tracking.",
      "description_length": 570,
      "index": 2852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for defining and managing list-based command-line options with dynamic configuration, including value updates, serialization, and alias handling, while supporting validation and category organization. It operates on lists of typed elements (E.t), string lists, and category states to enable use cases like parsing hierarchical options, tracking project-wide state changes, and enforcing structured configuration constraints.",
      "description_length": 459,
      "index": 2853,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a functional set interface for hash-consed tree keys using big-endian Patricia trees, supporting efficient operations like union, intersection, ordered traversal, and predicate-based queries. It works with ordered sets of hash-consed keys, offering transformations, structural comparisons, and conversions to sequences/lists while leveraging Patricia trees for optimized memory and performance. Designed for scenarios requiring precise ordered set manipulation, it suits applications like static analysis where hierarchical key structures demand efficient membership testing, deep copying, or project-specific introspection.",
      "description_length": 645,
      "index": 2854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of a given data type, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that conform to the `Data` module signature, enabling structured storage and retrieval of values with project-specific context. Concrete use cases include managing emitter-specific annotations or tracking property statuses across different analysis projects.",
      "description_length": 449,
      "index": 2855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps keyed by memory zone bases, supporting operations to manipulate key-value pairs with precise control over ordering and structure. It provides functions for merging, filtering, transforming, and querying associative collections, along with utilities to handle list-valued keys and extract ordered bindings. Designed for static analysis memory models, it enables tracking addressable regions and their validity through deep copy and pretty-printing capabilities.",
      "description_length": 495,
      "index": 2856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a functional set interface for managing collections of source code positions, offering operations like union, intersection, difference, and transformations via `map` and `filter`. It works with immutable sets of `Position.t` values, which represent locations in C source code, and supports efficient iteration, membership checks, and ordered traversals. The module is particularly useful for static analysis tasks in Frama-C plugins, where precise tracking and manipulation of code regions are required, such as during slicing, dependency tracking, or error propagation.",
      "description_length": 593,
      "index": 2857,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set abstraction for `Logic_real.t` values with ordered set operations like union, intersection, and difference, alongside transformations such as map, filter, and fold. It works with sets of logical real numbers, supporting conversions to sequences/lists, nearest-element queries, and comparisons using `Ord.compare`. It is designed for use in static analysis plugins requiring precise numerical set manipulations, such as tracking value ranges or constraint domains in program verification.",
      "description_length": 516,
      "index": 2858,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, with operations including equality, comparison, hashing, and pretty-printing. It supports introspection via `mem_project` to check properties of embedded project values and provides deep copying to avoid shared state. Use cases include managing collections of memory zones with associated validity information, where each entry's identity and structure must be preserved across operations.",
      "description_length": 476,
      "index": 2859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Zero",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing integer configuration parameters with range constraints, including value setting/retrieval, update hooks, and serialization. It works with shared integer values that support bounded ranges, offering functions to enforce valid intervals, track modifications, and integrate with command-line interfaces or project state systems. Typical use cases involve plugin configuration options requiring numeric validation, such as limiting analysis iterations or defining threshold values in static analysis tools.",
      "description_length": 548,
      "index": 2860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Zero",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing integer command-line parameters with support for value setting, change hooks, and custom serialization, as well as shared integer parameters constrained to specific ranges. It operates on integers with optional min/max bounds, allowing operations like incrementing, range validation, and state tracking, suitable for plugin configurations that require dynamic parameter updates or integration with Frama-C's project system.",
      "description_length": 465,
      "index": 2861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps for associating CIL locations with arbitrary data, offering insertion, deletion, and modification operations alongside ordered traversal and list-accumulation utilities. It supports analysis workflows requiring precise location tracking through functions like `add_to_list`, `find_first`, and `filter_map`, while enabling structured data transformations via iterators, mappers, and pretty-printing. Designed for static analysis tasks, it facilitates managing location-centric data such as code annotations, error reports, or transformation metadata in CIL-based tools.",
      "description_length": 616,
      "index": 2862,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables that map CIL variable information (`Varinfo`) to arbitrary values, offering imperative and functional operations for insertion, lookup, iteration, and folding. It supports sorted traversal via custom comparators, value-based memoization, and safe key access with default values, enabling efficient analysis of variable-related data in static analysis workflows. Use cases include tracking variable properties, dependency resolution, and managing metadata during CIL-based program transformations.",
      "description_length": 531,
      "index": 2863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_list.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic list datatype from a given element module `T`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with lists of type `T.t` in a type-safe manner, ensuring deep copying and proper memory management. Concrete use cases include defining and manipulating lists of abstract syntax tree nodes or analysis values within Frama-C plugins.",
      "description_length": 424,
      "index": 2864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set operations for CIL types that are structurally compared by key without unrolling, including insertion, deletion, union, intersection, and membership checks. It supports iteration, filtering, conversion between sets/lists/sequences, and introspection via hashing, equality testing, and pretty-printing. These capabilities are particularly useful in static analysis tools where preserving the original structure of C types (e.g., avoiding unrolling of structs/unions) is critical for accurate program modeling and transformation.",
      "description_length": 552,
      "index": 2865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a state dependency graph, where each edge connects two vertices of type `State.t` and carries a label. It provides operations to create edges, retrieve source and destination vertices, and access edge labels. Concrete use cases include modeling dependencies between program states during static analysis, such as tracking control flow or data flow with labeled transitions.",
      "description_length": 414,
      "index": 2866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Bool",
      "library": "frama-c.kernel",
      "description": "This module represents boolean values within a lattice structure that explicitly handles top and bottom elements. It provides operations to manipulate boolean lattice values, such as combining or comparing them while respecting lattice semantics. Concrete use cases include symbolic execution and static analysis where boolean conditions must be tracked with precision, such as determining whether a program path is definitely taken or not.",
      "description_length": 440,
      "index": 2867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Int",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage integer parameters by name, including getting, setting, incrementing, and checking the state of parameters. It works with string identifiers and integer values, supporting dynamic access and modification of plugin configuration settings. Concrete use cases include retrieving and updating numeric options during plugin execution, such as iteration counts or threshold values.",
      "description_length": 417,
      "index": 2868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing abstract values used in the autocomplete feature, supporting operations like equality, comparison, hashing, and pretty-printing. It works with structured descriptors, project skeletons, and lists of representants to manage and query data types in the context of command-line option autocompletion. Concrete use cases include checking membership in projects, creating deep copies of values, and formatting values for user display.",
      "description_length": 478,
      "index": 2869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of unit elements with standard operations like union, intersection, and difference, alongside ordered traversal, filtering, and conversion to sequences or sorted lists. It relies on total ordering for efficient membership checks, subset comparisons, and transformations while preserving structural invariants. Such functionality is useful for managing hierarchical program analyses or tracking disjoint element groups in static analysis workflows.",
      "description_length": 483,
      "index": 2870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing code elements with operations for comparison, hashing, pretty-printing, and deep copying. It supports structured data manipulation and inspection, particularly for analyzing and transforming C code within the kernel. Use cases include implementing custom data representations for code entities and enabling precise code analysis through project membership checks and value comparisons.",
      "description_length": 434,
      "index": 2871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map",
      "library": "frama-c.kernel",
      "description": "This module implements maps with CIL types as keys, using structural equality that disregards attributes for comparison. It supports ordered map operations like insertion, merging, filtering, and ordered iteration, along with utilities for extremal binding extraction and bidirectional conversion with sequences. These maps are particularly useful in CIL analyses requiring efficient type-based key management, such as merging type information across scopes or tracking structural type properties where attribute differences are irrelevant.",
      "description_length": 540,
      "index": 2872,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Exp_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for expressions (`Exp`) with support for efficient lookups, insertions, and equality checks. It works with `Exp.t`, the expression type in CIL (C Intermediate Language), and is used to track or memoize expression-related data across analyses. Concrete use cases include caching results of expression evaluations or managing expression-based mappings in static analysis plugins.",
      "description_length": 413,
      "index": 2873,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Zero_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a state builder for a zero-initialized integer reference type. It provides standard operations including equality, comparison, hashing, and pretty-printing for the built type, along with deep copying and project membership checks. It is used to create and manage stateful integer references initialized to zero within Frama-C's analysis framework.",
      "description_length": 367,
      "index": 2874,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables with keys of type `Frama_c_kernel.Project.Datatype.t`, enabling efficient association and manipulation of project-specific internal states tied to Frama-C's AST computations. It supports standard operations like insertion, lookup, and in-place filtering, along with bulk updates from sequences, ordered traversal, and memoization with project-aware equality and copying semantics. Designed for Frama-C's multi-project environment, it facilitates use cases such as tracking analysis results per project, batch-processing state changes, and ensuring consistent key comparisons across project boundaries.",
      "description_length": 647,
      "index": 2875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing key-value pairs with specialized key types derived from a quadruple structure, supporting imperative and functional manipulations such as insertion, deletion, ordered iteration, and bulk updates from sequences. It works with `'a Hashtbl.t` data structures, enabling ordered traversal by keys, values, or entries, and includes utilities for safe value retrieval, memoization, and integration with Frama-C's analysis plugins. Specific use cases include caching intermediate results during static analysis or maintaining stateful mappings with structural typing guarantees.",
      "description_length": 626,
      "index": 2876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.WTO",
      "library": "frama-c.kernel",
      "description": "This module implements algorithms for partitioning control flow graphs into weak topological orderings (WTOs) using a comparison function to guide the ordering. It operates on nodes and components of an automaton graph where unnatural loops have been normalized. The module provides functions to compute and compare partitions, as well as pretty-print them for debugging or analysis purposes.",
      "description_length": 392,
      "index": 2877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing hash tables specialized for CIL logic types, supporting key-based storage and retrieval with polymorphic values. It enables efficient insertion, lookup, iteration, and transformation over keys of type `Logic_type.t`, with utilities for sorted traversal, memoization, and handling optional or default values. Designed for use in static analysis plugins, it facilitates tasks like caching logic type metadata or aggregating analysis results keyed by CIL logic expressions.",
      "description_length": 513,
      "index": 2878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with CIL type keys that use structural equality after unrolling typedefs, offering imperative operations like `add`, `remove`, and `find`, alongside higher-order transformations such as `fold`, `iter`, and in-place filtering, with support for sequence-based bulk updates and traversal. It is designed for static analysis plugins needing efficient type-indexed mappings, enabling tasks like caching analysis results or managing type-specific metadata during C program processing.",
      "description_length": 513,
      "index": 2879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a user directory option for a plugin, providing functions to set, retrieve, and check the existence of a directory path. It works with `Frama_c_kernel.Filepath.t` to handle file and directory paths, supporting operations like directory creation and file access. Concrete use cases include configuring plugin-specific storage locations and managing runtime file paths based on user input or environment variables.",
      "description_length": 444,
      "index": 2880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kernel_function_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for kernel functions, providing operations for equality checks, comparison, hashing, and pretty-printing of entries. It manages a list of representants for type descriptors and supports deep copying and project membership testing via custom predicates. Concrete use cases include tracking and managing function-specific data across different analysis projects in Frama-C plugins.",
      "description_length": 442,
      "index": 2881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables keyed by CIL component information (`Compinfo.t`), supporting creation, modification, lookup, and bulk updates from sequences. It includes utilities for ordered iteration, folding over entries, and memoization, along with a `Make` functor to derive type-safe hash table modules. These capabilities are optimized for static analysis tasks like mapping CIL components to analysis results, transforming CIL structures with key-preserving operations, and efficiently managing metadata during code analysis.",
      "description_length": 546,
      "index": 2882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "This module provides two functions, `narrow` and `narrow_reinterpret`, which compute over-approximations of the intersection between two interval-to-value maps. The `narrow` function treats values strictly, potentially leading to empty intersections for equivalent representations, while `narrow_reinterpret` reinterprets values bitwise to improve precision. These functions are used when refining abstract values in static analysis, particularly when merging or comparing memory states with offset-based intervals.",
      "description_length": 515,
      "index": 2883,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between kernel functions and lists of values, supporting operations to register, modify, and query function-specific data with support for aliases and category-based grouping. It operates on structured data types like strings and string lists, leveraging customizable marshaling for serialization and project state management. Key use cases include tracking plugin state during static analysis, configuring parameters tied to function declarations, and organizing function-related metadata into hierarchical categories.",
      "description_length": 548,
      "index": 2884,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Value_int",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling integer values within a plugin system, including equality checks, comparison, hashing, and pretty printing. It supports data type registration with unique naming and description, enabling integration into Frama-C's plugin architecture. Concrete uses include persisting integer values through string serialization and managing project-specific data representations.",
      "description_length": 408,
      "index": 2885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.StringList",
      "library": "frama-c.kernel",
      "description": "This module manages lists of string parameters for Frama-C plugins, providing operations to get, set, add, remove, and iterate over strings associated with a parameter name. It works with the type `string list` and supports dynamic access and modification of plugin configuration values. Concrete use cases include handling command-line options, plugin-specific settings, or runtime-modifiable lists of strings such as include paths or analysis targets.",
      "description_length": 453,
      "index": 2886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map",
      "library": "frama-c.kernel",
      "description": "This module supports polymorphic map operations with keys representing logic constructor metadata, enabling efficient insertion, deletion, ordered traversal, and key-based queries using physical equality. It provides ordered map functionality for key-value pairs, including range iteration, transformation, filtering, and comparison, while maintaining key order and offering customizable pretty-printing and sequence conversions. Designed for static analysis tasks, it manages logic constructor-specific data associations with precise control over bindings and efficient functional updates.",
      "description_length": 590,
      "index": 2887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Quiet.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data representation with descriptors, packed descriptions, and project membership checks. Use it to manage values that require deep copying, structural comparison, and integration with Frama-C's project system.",
      "description_length": 352,
      "index": 2888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsGenerate.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. It works with structural descriptions, type descriptors, and project skeletons to manage and manipulate data representations. Concrete use cases include handling and inspecting data structures during the processing of the `-asm-contracts` option in kernel extensions.",
      "description_length": 444,
      "index": 2889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.TypeCheck.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing abstract data types during type checking, including equality, comparison, hashing, and pretty printing. It works with a polymorphic type `t` representing data types, descriptors, and project skeletons. Concrete use cases include validating type representations, checking project membership, and ensuring deep copies of type structures for analysis plugins.",
      "description_length": 414,
      "index": 2890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for managing collections of CIL type information elements, supporting set algebra (union, intersection, difference), ordered traversal, and transformation via functional (immutable) interfaces. It works with sets of `Typeinfo.t` elements, offering utilities for extremal element retrieval, monotonic predicate filtering, and conversions to ordered sequences or lists. Designed for static analysis plugins, it enables tasks like type hierarchy aggregation, set-based dataflow analysis, and ordered processing of type metadata while preserving immutability.",
      "description_length": 599,
      "index": 2891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for key-value pairs where keys are abstract, project-specific values tied to static analysis semantics. It supports creation, modification, and ordered traversal of tables with arbitrary value types, including bulk updates from sequences, safe key lookups, and memoization. Designed for static analysis plugins, it enables precise data modeling tasks like tracking program states or caching computed results with type-safe key management.",
      "description_length": 479,
      "index": 2892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module specializes in imperative hash tables for storing and manipulating CIL attributes, offering operations like insertion, lookup, and in-place filtering with statistics tracking. It supports ordered iteration and folding over keys, values, or entries, enabling safe value retrieval and memoization for static analysis tasks such as tracking type properties or structural relationships in C code. Designed for Frama-C plugin development, it integrates with the framework's type system to manage attribute-based data efficiently during program analysis.",
      "description_length": 560,
      "index": 2893,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map",
      "library": "frama-c.kernel",
      "description": "This module offers associative map operations for key-value pairs where keys are CIL types compared structurally by name (not unrolled), supporting insertion, deletion, lookup, and ordered traversal. It works with parametric value types and provides transformations, filtering, and ordered combinations via functions like `merge`, `map`, and `filter`, maintaining key ordering during iteration. Designed for CIL-based static analysis, it enables managing type-specific metadata (e.g., attributes or equivalence mappings) where name-based key comparison is critical.",
      "description_length": 565,
      "index": 2894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports project-compliant mutable states by enabling deep copies and project membership checks through `copy` and `mem_project`. Concrete use cases include managing stateful values across analysis phases and persisting state representations in a structured format.",
      "description_length": 447,
      "index": 2895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable set structure for rational numbers with efficient operations like union, intersection, and difference, along with ordered traversal and element queries. It works with sets of rational values represented as `Frama_c_kernel.Datatype.Rational.Set.t`, relying on their total ordering for sorted iteration and consistent comparison. Typical use cases include static analysis plugins requiring precise numeric range representations, interval arithmetic, or algorithms needing ordered set operations like nearest-neighbor searches and monotonic transformations.",
      "description_length": 590,
      "index": 2896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module manipulates ordered key-value maps with total key ordering, offering insertion, deletion, merging, and transformation operations. It operates on `Map.t` structures, supporting efficient key-based queries, ordered traversal via functions like `min_binding` and `max_binding`, and conversions to sequences or lists, with use cases including sorted data management, key-conditioned filtering, and structured data formatting with customizable iteration order.",
      "description_length": 467,
      "index": 2897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set-theoretic operations and ordered traversals over collections of C enum constants (represented as `Enumitem.t` values), supporting tasks like static analysis or transformation of C code involving enumerations. It includes functions for set algebra (union, intersection, difference), element queries (membership, nearest elements), and ordered iteration (ascending/descending sequences), along with utilities for conversion to lists and project-specific analyses. The data structure is optimized for handling CIL-level enum constants, enabling precise manipulation of enumerated type values during program analysis.",
      "description_length": 638,
      "index": 2898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.JsonCompilationDatabase.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling JSON compilation database entries. It supports deep copying, membership checking within projects, and provides descriptors for structural representation. Concrete use cases include managing and querying compilation database records during static analysis, ensuring project-specific data integrity, and facilitating serialization or debugging through structured representations.",
      "description_length": 520,
      "index": 2899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing `iter`, `map`, and `fold_left` to sequence monadic actions over list elements. It works with lists and monadic values parameterized by a type `'a`. Use it to traverse lists while accumulating effects like state or error handling in a monadic context.",
      "description_length": 308,
      "index": 2900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include storing plugin-specific settings, caches, or logs in a structured directory hierarchy.",
      "description_length": 352,
      "index": 2901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for abstract memory states, supporting union, intersection, difference, and element-wise comparisons alongside transformations like filtering, mapping, and partitioning. It works with immutable sets of `Frama_c_kernel.Cvalue.Model.t` elements, leveraging ordered storage to enable efficient nearest-element queries, ordered traversal, and type introspection via hashing or serialization. Use cases include static analysis workflows requiring precise tracking of memory state possibilities, such as merging divergent execution paths or verifying memory safety properties through functional set manipulations.",
      "description_length": 653,
      "index": 2902,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCppCommands.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, specifically tailored for representing and manipulating abstract data structures related to C preprocessing commands. It supports deep copying, membership testing within projects, and provides descriptors for type and structural representation. Concrete use cases include managing and analyzing preprocessor command data during static analysis, ensuring accurate tracking and transformation of C code elements.",
      "description_length": 510,
      "index": 2903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set algebra operations (union, intersection, difference), ordered element queries (min, max, nearest), and transformation functions (map, filter, fold) over collections of base-offset memory locations. It operates on sets of byte-level address representations, which model memory regions as pairs of base identifiers and byte offsets. These capabilities are particularly useful for analyzing memory access patterns, resolving overlapping address ranges, and performing static analysis on low-level memory manipulations in program verification tasks.",
      "description_length": 570,
      "index": 2904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppCommand.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and manipulating values related to C preprocessor command-line options. It supports operations such as equality checking, comparison, hashing, pretty-printing, deep copying, and project membership testing. It is used to handle and inspect values passed via the `-cpp-command` option in Frama-C's kernel, enabling precise control over preprocessor behavior during analysis.",
      "description_length": 420,
      "index": 2905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintPluginPath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values related to plugin paths in Frama-C's kernel. It supports deep copying, membership testing within projects, and provides descriptors for type and structure. Concrete use cases include managing and querying plugin path configurations during static analysis and handling project-specific data transformations.",
      "description_length": 463,
      "index": 2906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for properties, where keys are properties and values are of a specified data type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for use in analysis plugins. Concrete use cases include tracking property-value associations during static analysis, enabling precise value propagation and property-based reasoning.",
      "description_length": 453,
      "index": 2907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line parameters for C preprocessor arguments, offering operations to set, retrieve, and monitor changes to string-based values while supporting aliases and project-specific state integration. It operates on string parameters and collections (lists) of arguments, with utilities for validation, marshaling, and comparison. Typical use cases include handling `-cpp-extra-args` values in Frama-C plugins, validating function names, and serializing raw string arguments for analysis configurations.",
      "description_length": 522,
      "index": 2908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash tables with integer keys for efficient data management, supporting operations like insertion, deletion, lookup, and iteration with customizable ordering. It works with arbitrary value types, enabling use cases such as memoization, caching in analysis plugins, and handling sparse integer-mapped data. Features like sorted iteration, safe key access with defaults, and integration with Frama-C's type system make it suitable for symbolic analysis and state management in program verification tools.",
      "description_length": 521,
      "index": 2909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports imperative hash table operations and bulk transformations for CIL constants under strict equality semantics, managing associations between keys of type `ConstantStrict.t` and arbitrary values. It ensures key comparisons account for textual representation when present, enabling precise static analysis tasks such as memoization and context-sensitive constant tracking in C code. The module also provides ordered iteration, safe key lookups with defaults, and bulk updates from sequences, tailored for scenarios where exact constant representations must dictate equality and ordering.",
      "description_length": 604,
      "index": 2910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps with keys derived from CIL constants, supporting insertion, deletion, lookup, and aggregation operations alongside ordered traversal and predicate-based filtering. It provides utilities for transforming, comparing, and converting maps through folds, mappings, and list/sequence interoperations, leveraging key ordering for structural analysis. Designed for static analysis tasks like constant propagation and expression evaluation in C programs, it integrates with CIL's intermediate representation to track and manipulate value bindings during code analysis.",
      "description_length": 607,
      "index": 2911,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This implementation offers hash tables for managing keys ordered by function-specific criteria, including kernel function name, instruction, property kind, and identifier. It supports operations like insertion, lookup, ordered iteration, folding over key-value pairs, bulk updates from sequences, and memoization, all optimized for structured analysis data in Frama-C plugins. The design targets use cases requiring precise ordering of ACSL properties, such as static analysis tools that rely on deterministic traversal or dependency tracking across program elements.",
      "description_length": 567,
      "index": 2912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.With_Cardinality",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations for maps combined with sets, supporting cardinality checks and element enumeration. Provides functions to verify if a value has at most one element, compute over-approximated differences, fold over elements, and extract singleton bindings. Useful for static analysis tasks where precise cardinality constraints and map/set manipulations are required.",
      "description_length": 380,
      "index": 2913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Kernel_function.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and comparing kernel functions in the context of computing AST diffs. It provides operations for equality checking, comparison, hashing, and pretty-printing, along with utilities for project membership testing and deep copying. The type is used to track and analyze changes to kernel functions across different project versions, ensuring accurate rehashing and structural comparison.",
      "description_length": 432,
      "index": 2914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepUnusedFunctions.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with operations for managing and querying values related to the `-keep-unused-functions` option. It supports equality checks, comparison, hashing, and pretty-printing, along with deep copying and membership testing within projects. Use cases include tracking and manipulating function retention policies during static analysis.",
      "description_length": 366,
      "index": 2915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Verbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with descriptors, packed descriptions, and deep copying, ensuring no shared references. Use cases include managing and manipulating verbose data structures in kernel extensions, such as tracking and comparing analysis states or project-specific values.",
      "description_length": 412,
      "index": 2916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing immutable ordered sets of CIL expressions with structural equality, supporting standard set manipulations like union, intersection, and difference, as well as transformations (map, filter), membership checks, and conversions to/from sequences or lists. It works with sets of `ExpStructEq.t` values\u2014expressions compared by structural equivalence rather than reference identity\u2014leveraging a total ordering for element organization. These sets are particularly useful in static analysis plugins requiring precise tracking of structurally equivalent expressions, such as optimizing dataflow analyses or verifying control flow equivalence in C programs.",
      "description_length": 693,
      "index": 2917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.V",
      "library": "frama-c.kernel",
      "description": "This module represents vertices in a control flow graph, providing operations to create, compare, hash, and label vertices. It works with vertex values of type `V.t` and their associated labels of type `V.label`, supporting the construction and manipulation of graph structures used in abstract interpretation. Concrete use cases include modeling control points in interpreted automata, such as tracking program states and transitions during static analysis.",
      "description_length": 458,
      "index": 2918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with keys based on CIL expressions that enforce structural equality and strict comparison of constants, including specialized handling of `sizeof` expressions. It supports precise static analysis tasks like constant propagation and expression tracking, where exact structural equivalence (rather than identifier-based equality) is required. Operations include ordered traversal, bidirectional iteration, and transformations tailored for analysis scenarios requiring strict expression matching.",
      "description_length": 529,
      "index": 2919,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module performs forward dataflow analysis on control flow graphs with unnatural loops normalized to enter through their heads. It computes abstract values at each node using a given initial state and a worklist algorithm guided by the weak topological order. The analysis processes edges with guards and actions represented as CIL expressions and instructions, tracking reachable states through transitions in the operational semantics.",
      "description_length": 441,
      "index": 2920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered, immutable set structure supporting efficient membership tests, element insertion/removal, and set algebra operations (union, intersection, difference). It works with elements of a type `elt` ordered via a parameterized comparator, enabling persistent manipulation through functional transformations like mapping, filtering, and folding. Typical use cases include static analysis tasks requiring precise set manipulations, such as tracking program state dependencies, analyzing control flow graphs, or managing collections of abstract values with ordered relationships.",
      "description_length": 603,
      "index": 2921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered map structure with keys based on CIL l-values under structural equality, enabling efficient key-based operations like insertion, lookup, filtering, and ordered traversal. It supports transformations, comparisons, and sequence conversions while preserving immutability and physical equality where possible. Such maps are particularly useful in static analysis contexts for tracking relationships between program variables or expressions where structural identity of keys is critical.",
      "description_length": 516,
      "index": 2922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing lexicographically ordered sets of strings, supporting standard set manipulations (union, intersection, difference), element insertion/removal, and transformations via functions like `map`, `filter`, and `fold`. It provides efficient querying (membership, subset checks, cardinality), structural operations (splitting, partitioning), and conversions to sorted lists or sequences, leveraging the inherent ordering for predictable behavior. These capabilities are particularly useful in static analysis contexts where ordered string collections, such as identifier tracking or symbol sets, require precise traversal, comparison, or aggregation.",
      "description_length": 684,
      "index": 2923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered associative map operations for logic labels, supporting insertion, deletion, lookup, and ordered traversal, along with transformations like filtering, partitioning, and merging. It works with maps keyed by `Logic_label.t` and values of arbitrary or list types, offering conversions to lists/sequences, equality checks, and customizable pretty-printing. It is designed for static analysis tasks such as tracking logical annotations in CIL code, aggregating analysis results with ordered keys, and generating structured outputs during Frama-C plugin development.",
      "description_length": 589,
      "index": 2924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Set",
      "library": "frama-c.kernel",
      "description": "This module provides functional set operations for managing collections of CIL left-values (Lval.t), emphasizing structural equality via `Ord.compare` for comparisons. It supports set algebra (union, intersection, difference), element queries (membership, nearest elements), transformations (map, filter), and ordered iteration (fold, to_list), with utilities for sequence conversion and pretty-printing. These operations are used in static analysis tasks requiring precise structural equivalence checks, such as tracking memory locations or variables during dataflow analysis.",
      "description_length": 577,
      "index": 2925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_weak.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table for hashconsing values of a specific datatype, ensuring memory-efficient sharing of structurally equivalent values. It provides operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage interned values that are not persisted to disk, optimizing memory usage during analysis.",
      "description_length": 400,
      "index": 2926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic4.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype with four type parameters, providing operations for type representation, comparison, hashing, and pretty printing. It works with any four underlying datatypes through their modules, supporting deep copies, structural equality, and project membership checks. Concrete use cases include defining complex structured values for static analysis plugins, where precise type handling and value manipulation are required.",
      "description_length": 456,
      "index": 2927,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module supports insertion, deletion, lookup, and aggregation operations on maps with keys derived from CIL constants, where strict comparison considers textual representations when present. It provides ordered key-value pairs with functions for traversal, transformation, filtering, and structural manipulation, ensuring precise key-based queries and ordered sequence generation. Designed for static analysis plugins, it enables robust handling of constant-based indexing and customizable formatting in scenarios requiring exact constant representation tracking.",
      "description_length": 567,
      "index": 2928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing symbolic path data, including equality checks, comparison, hashing, and pretty printing. It works with the abstract type `t` representing symbolic paths and supports deep copying and membership testing within projects. Concrete use cases include handling path substitutions during analysis and tracking symbolic execution paths in program verification.",
      "description_length": 396,
      "index": 2929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for alarm data, providing standard operations like equality, comparison, hashing, and pretty printing. It works with a user-specified `Data` module to manage the stored values, ensuring deep copies and project-aware membership checks. Concrete use cases include tracking and managing alarm states across different analysis projects in static code analysis.",
      "description_length": 404,
      "index": 2930,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadState.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating load state data types, including equality checks, comparison, hashing, and pretty printing. It works with the abstract type `t` representing load state descriptors, supporting deep copies and membership checks over project skeletons. Concrete use cases include validating and comparing load state configurations during plugin initialization and state management in Frama-C's analysis workflows.",
      "description_length": 455,
      "index": 2931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This component provides operations for managing kernel function sets via command-line options, including additions, membership checks, iteration, and aliasing with visibility control. It supports Frama-C's project system integration for state change tracking and serialization, enabling use cases like customizable option parsing, categorized parameter organization, and persistent configuration management for kernel functions.",
      "description_length": 428,
      "index": 2932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally executes a monadic action based on a boolean flag. It operates on the unit type within a composed monad structure, allowing the action to proceed only if the given boolean is true. A concrete use case is selectively running stateful or effectful operations in contexts like analysis passes or validation steps, depending on configuration flags.",
      "description_length": 412,
      "index": 2933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map",
      "library": "frama-c.kernel",
      "description": "This module provides functional map operations for key-value pairs where keys are `Kf.t` values, supporting insertion, deletion, merging, and ordered traversal. It implements an immutable, ordered map structure with total key ordering, enabling efficient queries, transformations, and range-based iterations over kernel function bindings. Typical use cases include managing function-specific data in static analysis workflows, where ordered key processing and structural sharing optimize performance for large-scale CIL data manipulations.",
      "description_length": 539,
      "index": 2934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module enables efficient management of mappings between CIL global annotations and arbitrary data, offering imperative hash table operations like insertion, lookup, and in-place filtering, along with sequence-based initialization and sorted traversal by key, value, or entry. It specializes in handling `Global_annotation.t` keys, which represent CIL-level annotations in Frama-C, and supports advanced workflows such as memoization and safe value retrieval. Typical use cases include analyzing or transforming annotated C code, tracking annotation-specific metadata, and implementing algorithms requiring ordered or bulk processing of annotation-value pairs.",
      "description_length": 664,
      "index": 2935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Constfold.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating constant-folded values during analysis. It supports equality, comparison, hashing, and pretty-printing for values of type `t`, along with deep copying and project membership checks. It is used specifically to handle data involved in constant folding optimizations and analysis within Frama-C.",
      "description_length": 384,
      "index": 2936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map",
      "library": "frama-c.kernel",
      "description": "This module implements functional ordered map manipulations for keys of type `Machdep.t`, offering insertion, deletion, ordered querying, and structural transformations. It supports operations like iteration, filtering, and comparison over totally ordered keys, with utilities for sequence conversion and pretty-printing, primarily used in static analysis to manage machine-dependent data such as architectural states and configuration mappings.",
      "description_length": 445,
      "index": 2937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of memory location descriptors, where each element encodes a base-offset pair in bits. It supports efficient set algebra (union, intersection, difference), ordered traversal, element-wise transformations, and nearest-value queries, while maintaining strict ordering of base-offset ranges. The structure is particularly suited for static program analysis tasks requiring precise memory region tracking, such as alias analysis or buffer overflow detection, where monotonicity assumptions enable optimized searches and range-based reasoning.",
      "description_length": 574,
      "index": 2938,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AggressiveMerging.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for managing and merging abstract data representations. It includes functions to check membership within projects, create deep copies, and provides descriptors for structural inspection and serialization. Use cases include analyzing and transforming program data structures during aggressive merging optimizations in static analysis plugins.",
      "description_length": 478,
      "index": 2939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` operations to retrieve subdirectories and files by name, ensuring they exist and are of the correct type. Use it to programmatically navigate and validate directory hierarchies during command-line option setup.",
      "description_length": 329,
      "index": 2940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.Category",
      "library": "frama-c.kernel",
      "description": "This module manages named categories for grouping and controlling file analysis settings. It provides operations to define, enable, and modify categories with associated accessors and dependencies. Use cases include organizing analysis parameters into logical groups like \"@default\" or \"@all\" and controlling their activation behavior during command-line processing.",
      "description_length": 366,
      "index": 2941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for mapping hash-consed tree identifiers (derived from big-endian Patricia trees) to arbitrary values, supporting efficient creation, modification, iteration, and ordered traversal. It enables advanced use cases like memoization with structural keys, value-based lookups, and ordered folds, which are critical for static analysis tasks in Frama-C where keys represent normalized abstract syntax or semantic structures. The design integrates with Frama-C's analysis infrastructure, allowing traversal ordering by keys, values, or entries while preserving type-specific optimizations from Patricia tree representations.",
      "description_length": 671,
      "index": 2942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise.Make_bitwise.LOffset",
      "library": "frama-c.kernel",
      "description": "This module provides lattice operations and interval-based mapping functionalities for analyzing memory offsets within zones, supporting operations like merging (`join`), comparison (`is_included`), and interval binding (`add_binding_ival`). It works with abstract offset values (`LOffset.t`) and interval-to-value maps, enabling precise manipulation of integer ranges and their associated data through transformations, folds, and caching strategies. These tools are designed for static analysis tasks such as tracking memory access patterns or verifying pointer arithmetic in programs.",
      "description_length": 586,
      "index": 2943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set of operations for managing polymorphic maps with ordered keys, supporting functional updates, efficient querying, and ordered traversal. It works with maps (`'a Map.t`) where keys are ordered via `Ord.compare` and values are arbitrary, offering transformations like filtering, folding, and merging, as well as ordered sequence generation and construction from key-value pairs. Typical use cases include structured data manipulation, symbol table management, and scenarios requiring deterministic iteration over key ranges or extremal elements.",
      "description_length": 584,
      "index": 2944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.List_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements state builders for list-based data structures with support for equality, comparison, hashing, and pretty printing. Works with `Datatype.t` lists, providing deep copies and project membership checks. Useful for managing and manipulating lists of project-specific data in a stateful context.",
      "description_length": 300,
      "index": 2945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing command-line parameter maps with unique keys, supporting value assignment, validation, update hooks, and default handling. It works with parameterized key-value pairs structured as typed maps, incorporating categories and string representations for introspection and display. Designed for configuring analysis tools requiring strict option constraints, it enables use cases like dynamically validated configuration systems where changes trigger state updates or project-specific behaviors.",
      "description_length": 534,
      "index": 2946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables using CIL expressions as keys, offering imperative operations like insertion, lookup, and removal alongside bulk transformations and iterators. It supports both identity-based comparisons via `eid` and structural equality through customizable key modules, enabling efficient management of expression-centric data in static analysis tasks such as caching evaluation results or tracking expression properties across C codebases. Specialized utilities include safe access patterns, in-place filtering, and memoization to streamline common workflows in program analysis plugins.",
      "description_length": 609,
      "index": 2947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.WithOutput",
      "library": "frama-c.kernel",
      "description": "This module enables managing boolean plugin options with lifecycle hooks for state changes and output control in a plugin system. It operates on a registered state paired with boolean values, offering operations to set, track, and serialize these values alongside dependencies for conditional output generation. It is particularly useful for plugins needing to optimize output based on state transitions or expose configurable options via command-line interfaces.",
      "description_length": 463,
      "index": 2948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for managing collections of logical type information elements (`Logic_type_info.t`) in Frama-C's kernel. It supports functional transformations (union, intersection, map, filter), ordered iteration, membership queries, and conversions to/from lists/sequences, leveraging a total ordering for element comparison. These capabilities are particularly useful in static analysis tasks requiring precise tracking of type constraints, dependency resolution, or hierarchical data flow computations.",
      "description_length": 536,
      "index": 2949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set manipulation for memory zone abstractions, supporting operations like union, intersection, and difference alongside element-wise transformations (map, filter) and ordered traversal. It works with sets of `Frama_c_kernel.Base.Base.t` elements, sequences, and lists, ensuring efficient physical equality preservation during modifications. Key use cases include static analysis tasks requiring precise memory validity tracking, ordered set aggregation for memory region management, and scenarios needing reversible sequence conversions or deep-copy semantics for state snapshots.",
      "description_length": 607,
      "index": 2950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map",
      "library": "frama-c.kernel",
      "description": "This module provides map operations for associating arbitrary data with source code positions, supporting insertion, deletion, querying, and ordered traversal. It includes utilities for transforming, filtering, and converting maps to lists or sequences, enabling static analysis tasks that require tracking per-position metadata like annotations or analysis results. The module emphasizes precise manipulation and ordered iteration over position-keyed data, catering to source-level tooling needs.",
      "description_length": 497,
      "index": 2951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables for CIL instructions, enabling creation, insertion, deletion, and ordered iteration over mappings from `Kinstr.t` keys to arbitrary values. It supports functional and imperative manipulation patterns, with utilities for safe value retrieval, sequence-based initialization, and memoization. Designed for static analysis tasks like tracking instruction-specific metadata or caching analysis results in Frama-C plugins.",
      "description_length": 451,
      "index": 2952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling signed downcast warnings in Frama-C's kernel. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with utilities for project membership checks and deep copying. The module is used to manage and analyze signed downcast behaviors triggered by the `-warn-signed-downcast` option during static analysis.",
      "description_length": 410,
      "index": 2953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing string command-line parameters with validation constraints, value aliases, and lifecycle hooks. It operates on string values integrated with project state, supporting use cases like restricting inputs to predefined options or valid function names. Advanced features include custom serialization and change tracking for seamless integration with Frama-C's configuration system.",
      "description_length": 418,
      "index": 2954,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map",
      "library": "frama-c.kernel",
      "description": "This module provides efficient associative operations for maps with hash-consed tree keys, supporting insertion, deletion, lookup, and ordered traversal over big-endian Patricia trees. It works with polymorphic value types and maintains structural sharing optimizations for keys derived from abstract syntax trees (ASTs). Designed for static analysis tools, it enables efficient management of identifier mappings in AST representations through bitwise key decomposition and persistent data structures.",
      "description_length": 501,
      "index": 2955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic operation `only_if` that conditionally executes a monadic action based on a boolean flag. It works with monadic values of type `unit t`, allowing actions to be gated by runtime conditions without altering the monad's structure. A concrete use case is selectively running analysis steps in static analysis tools when certain flags are enabled.",
      "description_length": 373,
      "index": 2956,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables for mapping CIL enumeration identifiers to arbitrary values, supporting operations like insertion, ordered traversal, and memoization with structural consistency. It emphasizes safe key handling through functions like `find_opt` and `memo`, enabling use cases such as caching analysis results or processing enum-based data structures in Frama-C's static analysis pipelines.",
      "description_length": 408,
      "index": 2957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.Category",
      "library": "frama-c.kernel",
      "description": "This module manages symbolic path categories, providing operations to define, enable, and manipulate named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control how symbolic paths are interpreted during analysis. Concrete use cases include configuring how Frama-C handles symbolic path expansions through command-line options and custom analysis plugins.",
      "description_length": 408,
      "index": 2958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with integer keys using a specialized integer type, supporting efficient key-value association through operations like insertion, deletion, and lookup with memoization capabilities. It provides ordered iteration and folding over keys, values, or entries, along with bulk updates from sequences, enabling use cases such as memoization caches, integer-mapped data aggregation, and ordered key-value processing. The design accommodates customizable key handling and hash table construction for scenarios requiring precise control over storage behavior.",
      "description_length": 584,
      "index": 2959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for creating, modifying, and querying immutable sets of boolean values, supporting standard set algebra (union, intersection, difference), ordered traversal, and predicate-based filtering. It provides utilities for transformation (map, filter), structural inspection (subset checks, splitting), and conversion to/from lists and sequences, leveraging the inherent ordering of boolean elements. Designed for scenarios requiring precise set manipulation\u2014such as static analysis of program properties or formal verification workflows\u2014it ensures safe and efficient handling of boolean state spaces through both exception-raising and option-returning APIs.",
      "description_length": 680,
      "index": 2960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Set",
      "library": "frama-c.kernel",
      "description": "This module supports manipulation of ordered sets of memory location ranges (`Zone.t`) with operations like union, intersection, difference, and filtering, enabling efficient queries and transformations based on ordered element properties. It provides utilities for converting sets to sequences, finding nearest elements relative to values, and integrating with Frama-C's typing and project systems via hashing, comparison, and deep-copying. Designed for static analysis tasks, it facilitates precise memory modeling and set-based reasoning in program verification scenarios.",
      "description_length": 575,
      "index": 2961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Set",
      "library": "frama-c.kernel",
      "description": "This module implements core set operations\u2014union, intersection, difference, and transformations\u2014alongside ordered element management for `Global_annotation` collections, supporting immutability and precise ordering constraints. It provides utilities for iteration, membership checks, sequence conversion, and element retrieval (e.g., min/max, nearest), while enabling use cases like static analysis annotation tracking, where ordered, persistent sets are critical for maintaining semantic relationships or processing CIL constructs in a compiler pipeline.",
      "description_length": 555,
      "index": 2962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored to work with integer value abstractions. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys that represent integer value descriptors in a thread-safe and project-aware manner.",
      "description_length": 390,
      "index": 2963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that represent and manipulate integer value abstractions. It provides standard key operations including equality, comparison, hashing, and pretty-printing, tailored to the specific structure of integer value keys. The module supports deep copying and membership checks for project-specific data, enabling precise handling of integer value descriptors in map structures.",
      "description_length": 409,
      "index": 2964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Session",
      "library": "frama-c.kernel",
      "description": "This module manages the session directory for a plugin, providing functions to retrieve or create directories and files within that session space. It works with file paths represented by the `Frama_c_kernel.Filepath.t` type, ensuring proper handling of user-specific directories. Concrete use cases include storing temporary analysis results, caching plugin-specific data, or managing configuration files during a Frama-C session.",
      "description_length": 430,
      "index": 2965,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Set",
      "library": "frama-c.kernel",
      "description": "This module offers set-theoretic operations for managing collections of CIL attributes, including union, intersection, filtering, and transformations, alongside membership tests and ordered traversals. It operates on sets of CIL attributes, leveraging OCaml's idiomatic set manipulation patterns while integrating with Frama-C's structural typing and project systems. These capabilities are particularly useful for static analysis tasks such as tracking attribute consistency across code transformations, comparing attribute sets between program elements, or extracting attributes for semantic analysis.",
      "description_length": 603,
      "index": 2966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InlineStmtContracts.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing inline statement contract representations. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, along with descriptors and representants for structural manipulation. Concrete use cases include tracking and transforming inline contracts during analysis, ensuring correct handling of project-specific data through membership checks and deep copies.",
      "description_length": 481,
      "index": 2967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating collections of files within the analysis framework. It supports operations for comparing, hashing, and pretty-printing file collections, as well as checking membership based on project properties and performing deep copies. Concrete use cases include managing lists of source files to analyze, filtering based on project criteria, and ensuring value equality and ordering for collection handling.",
      "description_length": 462,
      "index": 2968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based data structure for managing and comparing statement-related values in the context of Frama-C's kernel. It provides operations for equality checking, hashing, pretty-printing, and deep copying of statement data, enabling efficient storage and retrieval during static analysis. Concrete use cases include tracking and comparing control-flow statements or intermediate representations of C code during plugin-driven analysis.",
      "description_length": 464,
      "index": 2969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of floating-point numbers, offering operations for insertion, deletion, union, intersection, ordered traversal, and subset checks. It supports transformations through mapping, filtering, and partitioning, along with conversions to reverse-ordered sequences and nearest-element queries, leveraging a customizable comparison function to maintain order. These capabilities are particularly useful in static analysis tasks requiring precise tracking of floating-point value ranges, such as program state modeling and difference analysis.",
      "description_length": 569,
      "index": 2970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of CIL expressions (`Exp.t`) with eid-based equality, offering operations like union, intersection, difference, and structural transformations (map, filter, fold) that preserve ordering. It supports efficient membership checks, subset relations, and ordered traversal patterns, along with utilities for converting to lists/sequences and finding nearest elements relative to a predicate. These sets are used in static analysis tasks such as tracking expression dependencies, optimizing code paths, or managing symbolic constraints where structural uniqueness and ordered iteration are critical.",
      "description_length": 629,
      "index": 2971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for composing Option with other monads using a product-based approach. It supports `iter` and `map` functions that apply monadic actions to values wrapped in Option, enabling computations that handle optional values within a combined monadic context. Specifically useful for scenarios like stateful computations that may fail, where Option is the interior monad and another monad is the exterior.",
      "description_length": 436,
      "index": 2972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for managing mappings from CIL term lhost keys to arbitrary values, supporting creation, insertion, lookup, in-place updates, and traversal. It includes advanced functionality like ordered iteration with custom comparators, bulk value replacement, and memoization, tailored for handling structural data in static analysis. These tools are primarily used in Frama-C plugins to track term lhost associations during program analysis tasks such as value propagation or dependency tracking.",
      "description_length": 526,
      "index": 2973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map",
      "library": "frama-c.kernel",
      "description": "This module provides configuration management capabilities for plugins through string-indexed maps, enabling operations to register, update, and query key-value pairs with support for default values, change hooks, and category-based organization. It works with string maps (`V.t Frama_c_kernel.Datatype.String.Map.t`) and related structures for handling aliases, marshaling, and command-line integration. It is particularly useful for implementing analysis tools that require persistent configuration, validated parameter workflows, or cross-analysis state synchronization in Frama-C.",
      "description_length": 584,
      "index": 2974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Empty_string",
      "library": "frama-c.kernel",
      "description": "This module enables defining command-line parameters that accept empty string values, offering operations to set, retrieve, and validate string options with support for empty inputs. It works with string-based parameters, integrating state management for serialization and project system compatibility, while allowing hooks for dynamic value updates and alias handling. It is particularly useful in plugins requiring optional string arguments where empty values trigger specific behaviors, such as default configurations or feature toggles.",
      "description_length": 540,
      "index": 2975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_option.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype instance from a polymorphic option type, enabling concrete type manipulation with full equality, comparison, and pretty-printing capabilities. It operates on types wrapped in a polymorphic option structure, providing deep copy, hashing, and project membership checks. Useful for defining first-class datatypes with optional values in static analysis plugins.",
      "description_length": 401,
      "index": 2976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralDebug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, along with deep copying and project membership checks. It works with a concrete type `t` and lists of that type, supporting introspection and serialization through descriptors. Use cases include debugging and analyzing structured data within Frama-C plugins, particularly when tracking project-specific values or comparing intermediate representations.",
      "description_length": 452,
      "index": 2977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LogicalOperators.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing logical operators in the kernel, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a concrete type `t` that encapsulates logical operator values and integrates with project-based data through `mem_project`. Use cases include analyzing or preserving logical operator structures during transformations, particularly when the `-keep-logical-operators` option is enabled for specialized static analysis tasks.",
      "description_length": 496,
      "index": 2978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integers from a small set, and values are of a specified data type. It supports operations like equality, comparison, hashing, and pretty-printing for maps, along with deep copying and project membership checks. It is used when associating structured data with integer keys that are guaranteed to be in a bounded, non-empty set.",
      "description_length": 372,
      "index": 2979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-typed command-line parameters with autocompletion support, including setting and retrieving values, registering change hooks, handling aliases, and customizing serialization. It operates on strings that may represent plain values or constrained identifiers (e.g., valid function names), enabling use cases like plugin configuration options and kernel state management where dynamic parameter updates and user input validation are required.",
      "description_length": 490,
      "index": 2980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for associating kernel function sets (`Hptset.t`) with arbitrary data, supporting insertion, lookup, removal, iteration, and folding. It enables ordered traversal via customizable key comparisons and includes utilities for memoization, type-safe table construction, and safe value retrieval, primarily used in Frama-C plugins to manage function-specific analysis metadata and dynamically track relationships between kernel function sets and associated data.",
      "description_length": 511,
      "index": 2981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that uses rational numbers as keys. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with functions for deep copying and checking membership based on project projections. It is used to manage and manipulate mappings involving rational numbers in a way that supports persistence and project-specific queries.",
      "description_length": 423,
      "index": 2982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AbsoluteValidRange.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate absolute valid ranges. It supports deep copying, membership testing within projects, and provides descriptors for type and structural representation. Concrete use cases include managing and validating memory ranges in static analysis, ensuring accurate tracking of project-specific constraints during analysis phases.",
      "description_length": 471,
      "index": 2983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a control flow graph, connecting source and destination vertices with associated labels. It provides operations to create edges, retrieve their source and destination vertices, access edge labels, and compare edges based on their direction. Concrete use cases include modeling transitions in an interpreted automaton, such as control flow between program points with attached guards and actions.",
      "description_length": 436,
      "index": 2984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with wide strings as keys and arbitrary values, offering operations for insertion, removal, merging, and querying with physical equality optimizations. It supports advanced transformations like filtering, splitting, and ordered traversal, along with conversions to lists and sequences, ensuring key order preservation. These maps are used in CIL-based static analysis for managing associations between identifiers (e.g., variable names, AST elements) and analysis data, where deterministic processing and efficient key-based lookups are critical.",
      "description_length": 582,
      "index": 2985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables with ordered traversal and in-place modification capabilities, supporting insertion, deletion, lookup, and sorted iteration over key-value pairs. Keys represent bases in an abstract memory model (Frama_c_kernel.Cvalue.Model.t), while values can be arbitrary types, enabling efficient management of polymorphic data associated with memory regions during static analysis. It is particularly used in value analysis to track abstract memory states, handle dynamic memory mappings, and perform deterministic processing of memory slices with support for default values and memoization.",
      "description_length": 625,
      "index": 2986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_type_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for logic type information. It supports deep copying, project membership checks, and provides descriptors for structural representation. Concrete use cases include managing and manipulating logic type representations in static analysis, ensuring correct handling of project-specific values and their relationships.",
      "description_length": 434,
      "index": 2987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements a narrowing operation for memory maps that merge two maps by selecting overlapping regions and combining their values. Works with base-to-memory-map structures where each base is associated with an offset map. Useful in static analysis for refining memory states during fixpoint computations.",
      "description_length": 303,
      "index": 2988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered key-value maps with polymorphic values, supporting operations like insertion, deletion, lookup, and aggregation through functions such as `add`, `remove`, `find`, and `merge`. It provides ordered traversal, filtering, and conversion to/from lists and sequences, leveraging key-based comparisons and physical equality optimizations. Designed for structured storage and analysis in plugins, it includes utilities for integer-keyed maps, custom iteration over key subsets, and pretty-printing of bindings.",
      "description_length": 533,
      "index": 2989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module enables managing a multimap-based plugin configuration where each key can associate with multiple values, offering functions to add, query, and iterate over entries. It operates on `Datatype.t` and string representations, supporting customizable marshaling, aliasing, and update hooks to synchronize project-specific computed states. Use cases include handling command-line options that accumulate multiple values per key, tracking analysis results across program functions, and maintaining dynamic configurations with change-triggered callbacks.",
      "description_length": 558,
      "index": 2990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Option",
      "library": "frama-c.kernel",
      "description": "This module applies stateful monadic operations to optional values. It provides `iter` for performing side-effecting computations on `Some` values and `map` for transforming `option` values within a state monad context. Useful for handling state-dependent computations that may fail or return missing data.",
      "description_length": 306,
      "index": 2991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by intervals, where values are of a specified data type. It supports operations like equality, comparison, hashing, and pretty-printing for interval-based maps. It is used to represent and manipulate interval-mapped data with precise memory operations and project membership checks.",
      "description_length": 316,
      "index": 2992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for managing collections of CIL global variables, supporting transformations like union, intersection, and difference alongside element-wise manipulations such as filtering, mapping, and membership queries. It operates on sets of `Global.t` elements with deterministic ordering, providing conversions to lists/sequences, nearest-value lookups, and project-specific equality checks. Typical use cases include analyzing or transforming C program globals while preserving structural constraints, such as tracking variable dependencies or optimizing memory layouts.",
      "description_length": 607,
      "index": 2993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PointerDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically used to handle pointer downcast warnings in the kernel. It provides functions to check membership in projects, create deep copies, and access type descriptors, supporting analysis of C code pointer conversions. Use cases include tracking and comparing pointer downcast instances during static analysis and ensuring correct warning generation based on project-specific criteria.",
      "description_length": 498,
      "index": 2994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map",
      "library": "frama-c.kernel",
      "description": "This module provides immutable maps with `Term.t` keys, supporting standard operations like insertion, deletion, and merging, along with ordered traversal and efficient conditional queries",
      "description_length": 188,
      "index": 2995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set of operations for managing ordered, immutable collections of unique elements, including standard set algebra (union, intersection, difference), element queries (membership, min/max), and transformations (filtering, mapping, partitioning). It operates on sets parameterized by an ordered type with defined equality, comparison, and hashing functions, enabling efficient membership tests, ordered traversal, and nearest-neighbor searches. Designed for applications like static analysis plugins, it supports precise set manipulations in tasks such as tracking element relationships, performing range-based queries, or handling hierarchical data with project-specific equality and ordering constraints.",
      "description_length": 739,
      "index": 2996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map",
      "library": "frama-c.kernel",
      "description": "This module supports operations for managing a non-multibinding map structure in Frama-C plugin development, enabling key-value associations with unique mappings (keys of type `K.t` to values of type `V.t`). It provides functionality for atomic updates, membership checks, iterative traversal, and change notification hooks, while integrating with project state management for persistence and serialization. Typical use cases include plugin configuration storage, parameter validation with custom marshaling, and tracking analysis state across Frama-C sessions with type-safe access and category-based organization.",
      "description_length": 615,
      "index": 2997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Action",
      "library": "frama-c.kernel",
      "description": "This module provides mechanisms for managing boolean plugin options in Frama-C, enabling operations like value assignment, retrieval, and change notifications through hooks. It works with boolean state values (`t`) and leverages the `Datatype` module for structured state management, supporting features like serialization and project system integration. It is particularly useful for plugins requiring toggleable settings with customizable behavior and persistent state tracking.",
      "description_length": 480,
      "index": 2998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a mutable map that associates file paths with arbitrary values, supporting insertion, retrieval, and transformation of entries. It works with data structures involving key-value pairs where keys are file paths, and includes mechanisms for tracking changes via hooks, serializing data with custom marshaling, and organizing entries into configuration categories. It is particularly useful for plugins that need to maintain file-specific state or configuration parameters across analysis sessions, enabling reactive updates and structured data management in static analysis workflows.",
      "description_length": 627,
      "index": 2999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Time.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling time-related values in the kernel, including equality, comparison, hashing, and pretty-printing. It supports structured data management with functions like deep copy, membership testing for projects, and descriptor handling. Concrete use cases include tracking and comparing time values during analysis, and serializing or inspecting time data in a structured and project-aware manner.",
      "description_length": 445,
      "index": 3000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for managing key-value associations where keys are CIL attributes, supporting precise manipulation of attribute-value pairs in static analysis contexts. It offers persistent map functionality including insertion, lookup, filtering, and ordered traversal, alongside bulk operations like union and merge, all optimized for attribute keys with project-aware semantics. Designed for use in Frama-C's kernel, it facilitates tasks such as attribute propagation, analysis state management, and structured transformation of CIL attribute data with customizable pretty-printing for debugging or output.",
      "description_length": 637,
      "index": 3001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to values wrapped in an option type, providing `iter` for performing side effects on `Some` values and `map` for transforming `Some` values within a monadic context. It works with computations that may fail or be optional, sequencing them with monadic actions without unwrapping the underlying monad. Use cases include handling optional stateful computations or chaining operations that depend on the presence of a value, such as parsing or lookup functions in a monadic context.",
      "description_length": 517,
      "index": 3002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for constructing, modifying, and analyzing ordered collections of CIL statements, supporting set-theoretic operations (union, intersection, difference), element-wise transformations (filtering, mapping), and ordered traversal (min/max selection, reverse iteration). It works with sets of `Stmt.t` values, leveraging a fixed comparison order to enable deterministic processing of CIL code structures. Typical use cases include static analysis tasks such as tracking control flow dependencies, aggregating statements for dataflow analysis, or filtering code regions based on syntactic or semantic criteria.",
      "description_length": 634,
      "index": 3003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_templates.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports structured data representation with descriptors, type information, and project membership checks, enabling precise handling of analysis artifacts. Use cases include managing and comparing abstract values, types, and structured data during program analysis.",
      "description_length": 417,
      "index": 3004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditCheck.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. It supports structured data representation and manipulation, primarily used for managing and analyzing audit check data during static analysis. The module enables introspection of audit check structures and safe transformation through deep copies, ensuring data integrity across analysis phases.",
      "description_length": 481,
      "index": 3005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for managing collections of CIL term l-values, supporting set-theoretic operations like union, intersection, and difference, as well as ordered traversal, transformation via mapping and filtering, and precise membership queries. It maintains elements of type `Term_lval.t` in a structured format, enabling efficient analysis of CIL-level memory locations and their relationships. These capabilities are particularly useful for static analysis tasks such as tracking memory accesses, performing data flow analysis, or modeling program state in C code verification workflows.",
      "description_length": 619,
      "index": 3006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements hashconsed data structures with strong equality and efficient sharing, specifically for state-building operations in static analysis. It provides operations for creating and managing hashconsed values, including equality checks, comparison, hashing, and deep copying, all optimized for deterministic behavior in analysis passes. Concrete use cases include managing abstract values, program states, or analysis artifacts where structural identity and memory efficiency are critical.",
      "description_length": 504,
      "index": 3007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered, immutable set structure for managing memory-related elements, such as offsets or memory locations, using a customizable comparison function to maintain sorted order. It supports efficient set algebra (union, intersection, difference), ordered iteration, element transformation via mapping and filtering, and nearest-value queries, with operations optimized for ascending traversal. The sets integrate with Frama-C's analysis framework to enable precise memory state manipulation in static analysis plugins, particularly for tracking and transforming memory layouts during program verification.",
      "description_length": 628,
      "index": 3008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.DoCollapseCallCast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing representational values with support for equality, comparison, hashing, and pretty printing. It works with a specific type `t` that encapsulates values used in kernel-level analysis, particularly related to handling call and cast behaviors under the `-collapse-call-cast` option. Concrete use cases include tracking and comparing data representations during static analysis, ensuring correct type handling around memory allocation sites like `malloc`.",
      "description_length": 511,
      "index": 3009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for logic types that avoid unrolling, including creation, insertion, lookup, deletion, iteration, and folding, along with sequence-based conversions and ordered traversal by keys, values, or entries. It operates on hash tables keyed by logic type identifiers, supporting memoization and structural preservation in static analysis plugins where type identity must be maintained without unrolling complex expressions.",
      "description_length": 469,
      "index": 3010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables specialized for CIL l-values, using structural equality based on sub-expression IDs (eid) to manage associations between l-values and arbitrary data. It supports imperative operations like insertion, lookup, iteration, and bulk manipulation, with features for ordered traversal, memoization, and sequence-based initialization. These capabilities are particularly useful in static analysis for tracking properties of l-values (e.g., points-to information) or caching computed data during program analysis.",
      "description_length": 537,
      "index": 3011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for creating, modifying, and querying sets of `Builtin_logic_info.t` elements using a persistent, sorted data structure. It provides standard set operations (union, intersection, difference), element-wise transformations (map, filter), ordered traversal (fold, iter), and conversions to/from lists and sequences, along with utilities for nearest-neighbor queries, equality checks, and pretty-printing. These capabilities are particularly useful for static analysis tasks requiring efficient manipulation of ordered logic-related metadata, such as tracking built-in function properties or organizing verification conditions in a structured manner.",
      "description_length": 676,
      "index": 3012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Typeinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and comparing abstract syntax tree (AST) type information during diff computation. It supports operations like equality checking, comparison, hashing, and pretty printing for AST type values, along with deep copying and project membership testing. It is used specifically for tracking and analyzing type changes across different versions of C code within Frama-C's AST diffing framework.",
      "description_length": 435,
      "index": 3013,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered key-value map operations, including insertion, deletion, lookup, and advanced transformations like folding, filtering, and merging. It works with finite maps where keys are ordered and support equality/comparison, enabling efficient structural manipulations and ordered traversal. Typical use cases involve managing indexed collections, processing sorted data sequences, or implementing algorithms requiring predictable key ordering and efficient associative operations.",
      "description_length": 499,
      "index": 3014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AllowDuplication.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to manage and manipulate values under the `-allow-duplication` behavior. It supports deep copying and checks for the presence of project values satisfying a predicate. It is used to handle duplication logic in kernel extensions, such as tracking and comparing analysis states or values across projects.",
      "description_length": 424,
      "index": 3015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.StringSet",
      "library": "frama-c.kernel",
      "description": "This module manages sets of string parameters for plugins, providing operations to retrieve, update, and query string sets by name. It supports adding and removing individual strings, checking membership, and iterating over elements. Use it to handle named configuration options or dynamic string collections in plugin code.",
      "description_length": 324,
      "index": 3016,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LeftShiftNegative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for handling values related to the behavior of left-shifting negative integers. It provides equality, comparison, hashing, pretty-printing, deep copying, and project membership checks for its values. The type is used to represent and manipulate internal states or configurations tied to the `-warn-left-shift-negative` option in static analysis.",
      "description_length": 403,
      "index": 3017,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Set_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a state builder for a set-like reference type with a fully featured datatype. It provides operations for equality, comparison, hashing, and pretty-printing values, as well as deep copying and checking membership based on project projections. It is used to manage and manipulate structured state values in static analysis plugins, particularly when tracking sets of values across different program states.",
      "description_length": 427,
      "index": 3018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for processing lists within a composed monadic context, specifically supporting `iter`, `map`, and `fold_left` functions that operate on lists while preserving the monadic structure. It works with lists of values wrapped in a combined monad of type `'a T.t S.t`, enabling sequential traversal and transformation with effects captured by the interior and exterior monads. Concrete use cases include processing sequences of stateful or fallible computations, such as parsing or validation pipelines where each step depends on prior results and may affect shared state.",
      "description_length": 606,
      "index": 3019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnspecifiedAccess.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing unspecified access behavior in Frama-C's kernel. It provides functions for equality, comparison, hashing, and pretty-printing values of type `t`, along with utilities for deep copying and checking membership based on project projections. The module is used to handle and manipulate internal representations of unspecified access scenarios during static analysis.",
      "description_length": 437,
      "index": 3020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hashconsed key-based hash table with imperative operations like insertion, deletion, and lookup, along with iteration, folding, and in-place filtering. It manages associations between hashconsed keys (type `t` or `key`) and arbitrary values (`'a`), supporting customizable ordering and structural properties through key management. It is particularly useful in scenarios requiring efficient state management, memoization, or construction of optimized data structures within Frama-C plugin development.",
      "description_length": 526,
      "index": 3021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on rational numbers, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured data manipulation with functions for deep copying, checking project membership, and type representation. Concrete use cases include managing and querying rational-number-based keys in map structures within static analysis tools.",
      "description_length": 410,
      "index": 3022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides core hash table operations\u2014such as insertion, lookup, deletion, and iteration\u2014for mappings where keys are CIL lvalue offsets (e.g., field selections or array indices) and values are arbitrary. It supports advanced workflows like ordered traversal over key-value pairs and structural equality comparisons, tailored for static analysis plugins analyzing C code memory layouts or tracking pointer accesses. The design facilitates efficient memoization and safe value retrieval in Frama-C's CIL-based analysis pipelines.",
      "description_length": 537,
      "index": 3023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Bool",
      "library": "frama-c.kernel",
      "description": "This component offers operations to manage boolean configuration parameters in Frama-C plugins, supporting direct state manipulation through explicit `on`/`off` assignments and typed parameters of kind `Frama_c_kernel.Typed_parameter.t`. It provides capabilities for command-line interface integration, value persistence across sessions via serialization, and dependency-aware state updates through hook registration. The implementation leverages a rich boolean datatype to handle project-specific state variations and visibility constraints.",
      "description_length": 542,
      "index": 3024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic maps with keys of type `Offset.t`, supporting insertion, deletion, ordered traversal, and transformation operations under structural equality. Designed for efficient persistent updates and total ordering on keys, it is particularly suited for static analysis tasks such as modeling memory layouts or tracking field positions in C structures.",
      "description_length": 376,
      "index": 3025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations to define and manipulate boolean parameters with support for command-line configuration, value persistence, and user interaction. It works with boolean values through functions like `on` and `off` to set states, while offering hooks for change detection, serialization, and alias management. These features enable use cases such as creating customizable plugin settings in Frama-C that respond to user input or external configurations.",
      "description_length": 467,
      "index": 3026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Caml_weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table with caml-specific optimizations for managing keys with identity-based equality. Operates on arbitrary `Datatype.t` values as keys and supports efficient lookups, insertions, and deletions. Useful for tracking object identities in static analysis plugins where reference equality matters and memory usage must be controlled.",
      "description_length": 353,
      "index": 3027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Float",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing floating-point command-line parameters with configurable ranges, including parsing from decimal strings, validation against minimum and maximum bounds, and integration with Frama-C's project system for state persistence. It operates on OCaml float values, supporting operations to set and enforce numeric constraints, and is suited for use cases like numerical configuration options requiring precise decimal input and constraint enforcement.",
      "description_length": 484,
      "index": 3028,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive suite of operations for managing immutable sets, including standard set-theoretic functions like union, intersection, and difference, as well as element manipulation (addition, removal) and ordered traversal utilities. It operates on a `Set.t` collection of elements ordered by a total ordering module (`Ord`), supporting efficient membership queries, transformations, and conversions to/from sequences or lists. Designed for scenarios requiring precise set manipulation in static analysis plugins, it enables tasks like tracking variable dependencies, analyzing control flow graphs, or handling symbolic expressions with ordered elements.",
      "description_length": 676,
      "index": 3029,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_queue.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic queue datatype from a given element type, supporting standard operations such as equality, comparison, hashing, and pretty printing. It works with any element type provided by the parameter module T, enabling concrete manipulation of queue values in analysis plugins. Specific use cases include tracking sequences of values in abstract interpretation or storing ordered collections of program elements with structural operations.",
      "description_length": 463,
      "index": 3030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for managing collections of emitters, supporting efficient insertion, deletion, union, intersection, and ordered traversal. It maintains elements in sorted order using a customizable comparison function, enabling precise querying, mapping, and subset checks, while also facilitating conversions to and from sequences. These capabilities are particularly useful for orchestrating annotation workflows, prioritizing property status emissions, and analyzing hierarchical relationships between emitters.",
      "description_length": 543,
      "index": 3031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for managing polymorphic key-value pairs where keys represent abstract memory values. It supports precise manipulation of memory states through standard map operations like insertion, deletion, and lookup, alongside ordered traversal, filtering, and transformation functions that maintain ascending key order. Designed for static analysis, it facilitates tasks such as merging memory regions, extracting bounds from abstract states, and iterating over specific memory ranges during program verification.",
      "description_length": 547,
      "index": 3032,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered key-value map operations with functional persistence, supporting insertion, deletion, lookup, and aggregation over maps with comparable keys and arbitrary values, including lists. It offers safe (`_opt`) and unsafe variants, ordered iteration, transformation, and filtering, along with utilities for splitting, comparison, and pretty-printing. Designed for use cases requiring structured key management, ordered data manipulation, and seamless conversion between maps, sequences, and lists.",
      "description_length": 519,
      "index": 3033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for associating CIL component descriptors (e.g., variables, functions) with arbitrary data, supporting insertion, deletion, merging, and traversal with both ascending and descending ordering. It includes functions for filtering, splitting, and comparing key-value pairs, along with customizable pretty-printing for integration into analysis workflows. These capabilities are particularly useful for static analysis or code transformation tasks requiring efficient lookup and structured manipulation of C program elements.",
      "description_length": 565,
      "index": 3034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for keys representing CIL structure offsets with structural equality semantics. It supports imperative operations like insertion, lookup, deletion, and iteration, along with sorted folding, sequence conversion, and memoization utilities. Designed for static analysis tasks, it ensures equivalent CIL offset representations are treated as identical keys, enabling efficient dataflow analysis, code optimization, and other scenarios requiring structural equivalence of offset-based data.",
      "description_length": 521,
      "index": 3035,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps where keys are ordered by structured property attributes, including function name, instruction context, and property metadata. It supports operations like ordered traversal, merging, and filtering while preserving a deterministic key hierarchy tailored for static analysis workflows. The design enables efficient organization and querying of Frama-C properties during code verification tasks that require consistent prioritization of analysis elements.",
      "description_length": 492,
      "index": 3036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for a given data type, enabling operations like lookup, comparison, and pretty printing. It works with key-value pairs where values conform to the provided `Data` module's type. Concrete use cases include managing typed configuration parameters and tracking project-specific data during static analysis.",
      "description_length": 351,
      "index": 3037,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered key-value maps with polymorphic values, supporting functional operations like insertion, deletion, merging, and ordered traversal, along with predicates and transformations over keys and values. It provides specialized handling for integer keys, including sequence generation, pretty-printing, and integer-indexed collection management, while ensuring physical equality optimizations and ordered key comparisons. Useful for static analysis tasks requiring efficient, ordered associative containers, such as tracking variable bindings or control-flow state in program analysis.",
      "description_length": 607,
      "index": 3038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option autocompletion, defining operations to create, modify, and retrieve categories such as `@none`, `@default`, and `@all`. It works with types like `t` representing categories and `elt` representing elements within those categories, along with accessors and state dependencies. Concrete use cases include setting the default category behavior, enabling the `@all` category with specific interpretations, and adding named categories with associated accessors and dependencies for structured command-line completion.",
      "description_length": 566,
      "index": 3039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a purely functional map abstraction with 32-bit integer keys, supporting operations like ordered traversal, value transformation, filtering, and structural manipulation. It works with immutable maps that store arbitrary values indexed by `Int32.t` keys, optimized for Frama-C's analysis tasks through physical equality checks to minimize memory usage. Typical use cases include managing key-based collections during static analysis, such as tracking variable states or processing ordered data sequences in plugins.",
      "description_length": 537,
      "index": 3040,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping CIL function declarations (`Fundec.t`) to arbitrary values, supporting operations like insertion, lookup, iteration, folding, and bulk updates from sequences. It provides ordered traversal, memoization, and safe value retrieval, enabling efficient management of function-specific data in static analysis plugins that require precise tracking and transformation of C function information during analysis.",
      "description_length": 446,
      "index": 3041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatRelative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a specific data type used to manage and manipulate values related to the `-float-relative` option in Frama-C. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership checks over project skeletons. The type `t` represents the internal values governed by this module, supporting precise handling and introspection of `-float-relative` configurations.",
      "description_length": 440,
      "index": 3042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.True_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean reference initialized to `true`, equipped with standard operations including equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project values, and includes the necessary type descriptor for integration with Frama-C's state management. Concrete use cases include tracking analysis states that default to enabled or active.",
      "description_length": 409,
      "index": 3043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AstDiff.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for comparing, hashing, and pretty-printing values of that type, specifically for use with abstract syntax tree differencing. It includes functions for deep copying, membership testing within projects, and provides descriptors for structural representation. Concrete use cases include tracking and comparing AST node differences during analysis and maintaining structured data across project versions.",
      "description_length": 463,
      "index": 3044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins.Plugins",
      "library": "frama-c.kernel",
      "description": "This module manages plugin loading and configuration paths. It provides operations to retrieve configured plugin paths, list available plugins, and load plugins either individually or collectively. It works with string lists representing plugin paths and performs file system operations to load modules dynamically. Use cases include initializing plugins at startup or dynamically extending application functionality from specified directories.",
      "description_length": 444,
      "index": 3045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map",
      "library": "frama-c.kernel",
      "description": "This module supports insertion, deletion, and combination of associative maps where keys are logic types (`Logic_type.t`) and values are arbitrary, with ordered key comparisons and physical equality optimizations. It provides structural operations like folding, filtering, and pretty-printing, along with utilities for sequence conversion and bidirectional iteration. Such maps are useful in static analysis for tracking logic type relationships, managing symbol tables, or aggregating properties during CIL code transformations.",
      "description_length": 529,
      "index": 3046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version",
      "library": "frama-c.kernel",
      "description": "This module defines a version type for control flow graph states in unrolled unnatural loops, represented as a vertex paired with a set of vertices. It provides core operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. These versions are used to track and distinguish different unrolling paths in control flow analyses, particularly for abstract interpretation tasks involving loop normalization.",
      "description_length": 465,
      "index": 3047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in map structures, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports key manipulation with functions like `equal`, `compare`, `hash`, and `pretty`, along with utilities for project membership testing and deep copying. Concrete use cases include managing and comparing symbolic keys in analysis passes and tracking project-specific metadata within map-based data structures.",
      "description_length": 465,
      "index": 3048,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space.Vector",
      "library": "frama-c.kernel",
      "description": "This module implements fixed-dimension vectors over a field, supporting operations such as creating zero or repeated-value vectors, basis vectors, and accessing or modifying individual elements. It provides vector arithmetic including element-wise maximum and norm computation. These operations are used to represent and manipulate linear spaces for tasks like computing invariants in static analysis.",
      "description_length": 401,
      "index": 3049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype for lattice values combined with a top element, enabling operations like equality, comparison, hashing, and pretty printing. It works with a parameterized domain and extends its values with a top element, supporting deep copying and membership checks over project skeletons. Concrete use cases include modeling abstract domains where top represents an over-approximated or unknown value in static analysis.",
      "description_length": 440,
      "index": 3050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.VTable",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table structure for mapping control flow graph vertices to arbitrary data, supporting imperative operations like insertion, lookup, and in-place filtering, alongside ordered traversal and sequence-based initialization. It is designed to associate per-vertex metadata (e.g., analysis results, state tracking) with keys tied to the specialized vertex type from the `UnrollUnnatural` module's control flow graphs. The structure facilitates abstract interpretation passes that require efficient, ordered processing of vertices or caching of computed values with fallback defaults during static analysis.",
      "description_length": 627,
      "index": 3051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintShare.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to handle and manipulate structured data representations within the kernel. It supports deep copying and project membership checks, enabling precise data traversal and transformation tasks. This type is used to manage and reason about internal state representations, particularly when serializing or comparing complex structures during analysis.",
      "description_length": 467,
      "index": 3052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of ordered set operations for 64-bit integers, including insertion, deletion, membership testing, set algebra (union, intersection, difference), and ordered traversal via iterators or folds. It manipulates sorted, unique collections of `Int64.t` values, emphasizing predicate-based filtering, nearest-neighbor queries, and conversions to sequences or lists. Designed for static analysis tasks requiring precise integer range tracking or dependency modeling, it supports efficient transformations, subset checks, and type utilities like hashing and pretty-printing.",
      "description_length": 605,
      "index": 3053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables using CIL expressions as keys, where equality and hashing are determined by structural comparison with strict constant handling and structural equivalence for expressions within `sizeof` operations. It supports standard hash table operations like insertion, lookup, iteration, and transformation, along with ordered traversal and memoization utilities. It is particularly useful in static analysis tasks requiring precise structural equivalence of C expressions, such as deduplicating or caching analysis results for expressions with identical structures but distinct syntactic representations.",
      "description_length": 629,
      "index": 3054,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a functional set interface for managing collections of CIL variable information (`Varinfo`) with operations like union, intersection, filtering, and ordered traversal. It supports efficient membership checks, element retrieval with safe/unsafe variants, and conversions to lists/sequences, while maintaining persistent data structures for immutable variable sets. Key use cases include static analysis tasks requiring precise tracking of variable relationships, such as data flow analysis or dependency management in Frama-C plugins.",
      "description_length": 552,
      "index": 3055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered sets of l-values with strict structural equality, enabling precise set operations like union, intersection, and difference, as well as ordered iteration, filtering, and transformation. It works with `LvalStructEqStrict.t` elements, which enforce structural equality and strict constant comparison, and supports conversions to sequences/lists, nearest-element queries, and ordered traversal. It is particularly useful in static analysis scenarios requiring exact comparisons of CIL l-values, such as tracking memory accesses or analyzing control-flow structures with strict equality constraints.",
      "description_length": 623,
      "index": 3056,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Set",
      "library": "frama-c.kernel",
      "description": "This module implements sorted, persistent sets of `Identified_predicate.t` values, supporting standard operations like union, intersection, and difference, as well as element-wise transformations (`map`, `filter`), ordered iteration (`iter`, `fold`), and conversions to lists/sequences. It maintains strict ordering of elements and provides efficient membership checks, nearest-element queries, and project-aware condition validation. Such sets are useful in static analysis scenarios where collections of uniquely identified logical predicates must be manipulated, such as tracking program properties across CIL code transformations or analyzing conditional dependencies in abstract interpretation.",
      "description_length": 699,
      "index": 3057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure that associates values with states. It provides functions for equality checks, comparison, hashing, deep copying, and pretty-printing of keys, along with introspection capabilities through type descriptors and representants. These features support efficient and safe manipulation of state keys in a project-compliant context, particularly for static analysis plugins in Frama-C.",
      "description_length": 458,
      "index": 3058,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating sets of kernel functions. It provides operations to define, retrieve, and modify categories such as `none`, `default`, and `all`, along with functions to enable or alias these categories with custom behavior. These categories are used to group and control the activation of parameters in the analysis framework.",
      "description_length": 374,
      "index": 3059,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic function `only_if` that conditionally executes a monadic action based on a boolean value. It operates on the `unit t` monadic type, allowing boolean conditions to control the flow of monadic computations. A concrete use case is selectively running a logging or state-modifying operation only when a given flag is true, within a larger monadic sequence.",
      "description_length": 383,
      "index": 3060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements a narrowing operator that merges two memory states by computing their intersection, preserving only the common information. Works directly with abstract memory models representing program states. Useful for refining value approximations during static analysis iterations.",
      "description_length": 282,
      "index": 3061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a collection of ordered set operations for managing interpreted automata edges, including union, intersection, difference, filtering, and ordered traversal, leveraging a comparator to enforce set invariants. It manipulates sets of `Edge.t` values\u2014representing control flow transitions with guards and actions\u2014supporting abstract interpretation tasks like reachable state computation, path analysis, and program transformation. Additional utilities for sequence conversion, hashing, and pretty-printing enable seamless integration with analysis frameworks and tooling.",
      "description_length": 586,
      "index": 3062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype with values from `Domain` combined with top and bottom lattice elements. It supports operations like equality, comparison, hashing, and pretty-printing for these extended values. Use it to represent lattice elements with explicit top/bottom handling, such as abstract values in static analysis where precision depends on distinguishing these extremal elements.",
      "description_length": 394,
      "index": 3063,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingLevel.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing unfolding levels in the kernel, including equality, comparison, hashing, and pretty-printing functions. It works with the abstract type `t` representing unfolding level values, along with lists of such values and project-based predicates. Concrete use cases include tracking and validating unfolding behavior during analysis, ensuring deep copies of unfolding states, and displaying unfolding levels in a human-readable format.",
      "description_length": 485,
      "index": 3064,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for the `-cpp-extra-args` command-line option, allowing configuration of argument handling through named categories like `@none`, `@default`, and `@all`. It provides functions to define, enable, and modify these categories, each associated with a specific argument interpretation and state dependencies. Use cases include controlling preprocessing behavior based on source file types or analysis modes, where different argument sets are applied conditionally.",
      "description_length": 490,
      "index": 3065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and customizing generated specifications via the `-generated-spec-custom` option. It provides operations to define named categories, set default behaviors, and control the special `@all` category's interpretation. Functions support adding categories with accessors and dependencies, enabling unified handling of specification groups during analysis.",
      "description_length": 395,
      "index": 3066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module enables managing sets of kernel functions (`t`) with operations for adding, querying, and iterating over elements, alongside category-based organization and dependency tracking. It works with `Frama_c_kernel.Cil_datatype.Kf.Set.t` values, string-based parameter aliases, and named function groups, supporting use cases like grouping related functions for analysis, handling project-specific state, and customizing serialization via hooks.",
      "description_length": 450,
      "index": 3067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, including operations for equality, comparison, hashing, and pretty-printing. It works with a specific abstract key type used in map structures, supporting deep copying and membership checks for project-related values. Concrete use cases include managing and comparing keys in map-based data structures, ensuring unique identification and proper handling of project-specific data.",
      "description_length": 420,
      "index": 3068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FramaCStdLib.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, along with deep copying and project membership checks. It works with a concrete type `t` that represents structured data, supporting precise equality, ordering, and serialization. Use cases include managing and manipulating structured data within Frama-C's kernel, particularly for plugins requiring deep copies, value comparisons, or custom pretty-printing.",
      "description_length": 458,
      "index": 3069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for key-value storage with support for ordered iterations, value-based lookups, and memoization. It works with keys derived from the `List_with_collections` type hierarchy and associated values, enabling structured transformations via sequences and folds. It is particularly useful in static analysis workflows for managing dynamic mappings, caching computed results, and processing collections with deterministic traversal order.",
      "description_length": 484,
      "index": 3070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.EagerLoadSources.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, as well as checking membership based on project properties and performing deep copies. It works with a concrete type `t` and lists of that type, along with functions over project skeletons. It is used to manage and manipulate representational values in a way that supports persistence, comparison, and project-specific queries.",
      "description_length": 427,
      "index": 3071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by normalized filepaths, where each map entry holds a value of type `Data.t`. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate collections of data associated with specific file paths in a deterministic and structured way.",
      "description_length": 393,
      "index": 3072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.WithOutput",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing boolean command-line options with support for value hooks, dependency tracking, and conditional output execution. It operates on boolean states, structured data via the `Datatype` module, and lists of `State.t` dependencies, coordinating output behavior through functions that respond to state changes. It is suited for scenarios requiring customizable option parsing, project state serialization, and runtime output control tied to dynamic parameter changes.",
      "description_length": 501,
      "index": 3073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a functional set interface for managing collections of `OffsetStructEq` elements, supporting standard operations like union, intersection, and difference alongside ordered traversal via `fold` and `iter`. It provides transformations (e.g., `map`, `filter`), membership checks, and conversions to/from lists and sequences, all while preserving immutability and structural equality. Designed for use in C code analysis tasks, it enables efficient querying and manipulation of structured data, such as tracking memory offsets or analyzing dataflow dependencies in Frama-C plugins.",
      "description_length": 596,
      "index": 3074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kinstr_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for a specific data type, providing operations for key comparison, hashing, and pretty-printing. It works with a structured data type `t` that includes equality, comparison, and project membership checks. Concrete use cases include efficiently storing and retrieving values based on structural identity or project-specific attributes.",
      "description_length": 370,
      "index": 3075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTOIndex.Table",
      "library": "frama-c.kernel",
      "description": "This module maps vertices of an interpreted automaton to their weak topological order (WTO) indices and provides efficient lookups for control flow analysis. It supports operations to build an index table from a WTO, find the index of a vertex, check if a vertex is a component head, and determine if an edge is a back edge. It is used to analyze loop structures and control flow dependencies in the abstract interpretation of C programs.",
      "description_length": 438,
      "index": 3076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for managing CIL expressions with structural equality and strict constant comparison, enabling efficient storage and retrieval of keys of type `ExpStructEqStrict.t`. It supports imperative operations like insertion, lookup, iteration, and in-place filtering, along with advanced features such as sequence-based initialization, sorted traversal using custom comparators, and memoization utilities. Designed for static analysis tasks, it facilitates precise tracking of expression states and caching in scenarios requiring exact structural equivalence, such as program analysis or transformation passes where expression identity must be rigorously preserved.",
      "description_length": 692,
      "index": 3077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedOverflow.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for handling unsigned overflow warnings in the kernel. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with deep copying and membership checks for project-related data. The type `t` is used to represent and manipulate internal states related to unsigned overflow analysis during static analysis.",
      "description_length": 408,
      "index": 3078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for managing associations between CIL model information keys (`Model_info.t`) and arbitrary values, supporting creation, insertion, lookup, and ordered iteration with custom key comparisons. It facilitates efficient storage and retrieval of analysis data in Frama-C plugins by enabling sequence-based initialization, safe key access with fallbacks, and memoization patterns. Designed for structured handling of CIL-derived model data, it integrates with Frama-C's plugin architecture to streamline tasks like analysis state management and intermediate representation transformations.",
      "description_length": 637,
      "index": 3079,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-aware map operations for combining, transforming, and querying key-value associations where keys form a lattice structure. It supports polymorphic maps with ordered keys and arbitrary value types, enabling operations like merging with lattice joins, filtering by key predicates, and ordered iteration. These capabilities are particularly useful in static analysis for modeling program states with hierarchical or partially ordered domains, such as memory regions or abstract values.",
      "description_length": 511,
      "index": 3080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.List",
      "library": "frama-c.kernel",
      "description": "This module applies stateful monadic functions to lists. It provides `iter` for performing stateful effects across a list, `map` for transforming a list with stateful computations, and `fold_left` for accumulating state while traversing a list. These functions are used to manage sequential state updates over list elements, such as parsing or analyzing a sequence of values with shared state.",
      "description_length": 393,
      "index": 3081,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in the alarms database map, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with a structured key type that can contain project-specific data, enabling checks for project membership and deep copying to avoid shared state. Concrete use cases include managing and querying alarm keys in a map structure, ensuring correct value comparisons and efficient storage.",
      "description_length": 456,
      "index": 3082,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements state builders for integer-indexed hash tables with support for equality, comparison, hashing, and pretty-printing operations. Works with `Datatype.t` values, enabling efficient storage and retrieval of integer-keyed entries. Useful for managing dynamic analysis states where integer identifiers map to structured data values.",
      "description_length": 337,
      "index": 3083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_var.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing logic variables in the context of computing AST differences. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle logic variable representations in a way that supports accurate rehashing and avoids issues with projectified hashtables.",
      "description_length": 399,
      "index": 3084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Performs backward dataflow analysis on control flow graphs, computing dataflow values for each node using a given direction and worklist algorithm. It operates on graph structures built from CIL expressions and instructions, where edges represent transitions with guards and actions. This module is used to infer properties like possible program states before a given point, enabling analyses such as liveness or reaching definitions.",
      "description_length": 434,
      "index": 3085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered integer sets with operations for creation, union, intersection, and difference, along with ordered traversal, filtering, and functional transformations like map and fold. It manipulates sets of abstract integers (`Int.t`) using comparison-based ordering, supporting efficient membership checks, cardinality queries, and nearest-value searches, while integrating with Frama-C's abstract interpretation framework for static analysis tasks such as value range tracking and constraint propagation. Key applications include program analysis scenarios requiring precise integer set manipulations and symbolic reasoning over abstract domains.",
      "description_length": 666,
      "index": 3086,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Int",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage integer parameters with range constraints, including setting and retrieving values, defining valid ranges, and triggering callbacks on changes. It works with integer data types and integrates with plugin state management systems to support features like command-line argument parsing, project-specific persistence, and dynamic value validation. Typical use cases involve configuring plugin thresholds, counters, or bounded settings that require runtime updates and cross-component synchronization.",
      "description_length": 537,
      "index": 3087,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Caml_weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table for a specific data type, ensuring values are automatically reclaimed when no longer referenced. It provides standard operations like equality, comparison, hashing, and pretty-printing, tailored to the data type's structure. This is useful for managing large or transient values where memory retention is undesirable, such as caching intermediate analysis results in static code analysis.",
      "description_length": 417,
      "index": 3088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Set",
      "library": "frama-c.kernel",
      "description": "This module offers standard set operations\u2014union, intersection, difference, and ordered element manipulation\u2014for collections of CIL kernel instructions (`Kinstr.t`), leveraging a total ordering to ensure consistent semantics. It supports functional transformations (`map`, `fold`), filtering (`filter`, `partition`), and conversions to and from lists and sequences, including reverse-ordered traversal. These operations are particularly useful in static analysis and code optimization scenarios where precise tracking and manipulation of instruction sets are required, such as analyzing control flow or propagating dataflow properties across CIL code.",
      "description_length": 651,
      "index": 3089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map",
      "library": "frama-c.kernel",
      "description": "This module provides standard operations for manipulating immutable maps with ordered keys derived from logic types used in CIL analysis. It supports key-based queries, transformations, and ordered traversal (ascending or descending), along with merging, filtering, and structural comparisons, all tailored for handling logic type keys without unrolling. These operations are particularly useful in static analysis scenarios requiring precise key ordering, such as tracking expressions or variables in a structured program context.",
      "description_length": 531,
      "index": 3090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with keys representing CIL logic type names, supporting operations like insertion, lookup, traversal, and transformation while preserving key ordering. It provides both functional and imperative-style functions for managing associations between logic type identifiers and arbitrary data, including filtering, merging, and pretty-printing capabilities. Designed for use in static analysis tasks, it facilitates efficient querying and manipulation of logic type metadata during CIL code transformations or property tracking in Frama-C plugins.",
      "description_length": 577,
      "index": 3091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module enables creation and manipulation of hash tables mapping CIL global keys (representing program entities like variables and functions) to arbitrary values, supporting operations like insertion, lookup, deletion, and ordered iteration/folding over keys, values, or entries. It provides specialized utilities for static analysis tasks such as tracking program entity properties or memoizing analysis results, with keys constrained to CIL's global variable type while maintaining compatibility with standard hash table semantics. The design facilitates efficient, type-safe association of analysis data with C program elements during inspection or transformation passes.",
      "description_length": 678,
      "index": 3092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InitializedPaddingLocals.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for managing and comparing structured values, including equality, comparison, hashing, and pretty-printing. It supports working with project-specific data through membership checks and deep copying to ensure isolation. Concrete use cases include tracking and manipulating analysis states in kernel plugins, particularly for options related to local variable initialization.",
      "description_length": 421,
      "index": 3093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for a given data type, enabling operations like lookup, insertion, and iteration over key-value pairs where keys are of type `Frama_c_kernel.Base.t`. It supports concrete data manipulation tasks such as equality checking, comparison, hashing, and pretty-printing, tailored to the provided `Data` module. Use cases include managing per-base metadata in static analysis, tracking memory zone properties, or associating values with specific memory regions in Frama-C plugins.",
      "description_length": 520,
      "index": 3094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Bound_Lattice",
      "library": "frama-c.kernel",
      "description": "This module defines a semi-lattice structure with a dedicated bottom element, supporting operations such as `join`, inclusion checks via `is_included`, and equality comparison. It works with values of type `t` that wrap an underlying lattice type with a bottom marker, enabling precise abstract interpretation scenarios. Concrete use cases include modeling abstract domains in static analysis where values may be unknown or undefined, such as tracking uninitialized variables or merging control flow paths.",
      "description_length": 506,
      "index": 3095,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Set",
      "library": "frama-c.kernel",
      "description": "This module enables manipulation and querying of ordered sets containing logic constants, supporting operations like union, intersection, ordered traversal, and nearest-element queries. It provides utilities for sequence conversion, hashing, pretty-printing, and project membership checks, leveraging a comparison function from the `Ord` module to maintain order. These capabilities are particularly useful in static analysis tasks where deterministic processing of logical expressions, constraint tracking, or bounded approximation in data flow analysis are required.",
      "description_length": 568,
      "index": 3096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins.Plugins_gui",
      "library": "frama-c.kernel",
      "description": "This module manages plugin loading and configuration paths for a GUI environment. It provides operations to retrieve configured plugin paths, list available plugins, and load all or specific plugins. It works with string lists representing plugin paths and performs side effects to load plugins at runtime.",
      "description_length": 306,
      "index": 3097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating logic-related information in the context of AST differencing. It supports deep copying, project membership checks, and provides descriptors for type and structural representation. Concrete use cases include tracking and comparing logic expressions across different project versions, ensuring accurate rehashing and structural consistency in diff computations.",
      "description_length": 517,
      "index": 3098,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of `Printer_tag.Declaration.t` values, supporting membership tests, algebraic operations (union, intersection, difference), and ordered transformations (map, fold, filter). It works with immutable sets of declaration elements, enabling efficient queries, sequence interconversion, and precise navigation via ordering. Such functionality is useful for tasks like tracking unique AST nodes during source analysis or generating ordered declaration lists for code representation.",
      "description_length": 542,
      "index": 3099,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for float keys, including creation, modification, lookup, and iteration with ordered traversal. It works with float-keyed tables and ensures structural consistency through integration with Frama-C's plugin infrastructure. Designed for analysis tools requiring precise float-indexed data management and ordered processing, such as numerical analysis passes or constraint-solving plugins.",
      "description_length": 429,
      "index": 3100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and management of command-line parameters that process string lists, supporting operations like appending values, folding over entries, and dynamic validation. It organizes these parameters into categorized groups, tracks modifications with state-aware hooks, and integrates serialization for persistence. Typical use cases include handling multi-value options such as input file paths, configuration tags, or extensible filter lists in command-line tools.",
      "description_length": 489,
      "index": 3101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP",
      "library": "frama-c.kernel",
      "description": "This graph structure supports traversal and transformation operations, including vertex and edge iteration, mapping, adjacency queries, and attribute management for visualization formats like Graphviz DOT. It operates on directed graphs with labeled vertices and edges, tailored for static analysis tasks such as callgraph-based",
      "description_length": 328,
      "index": 3102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mappings with CIL field information as keys, supporting creation, insertion, lookup, and ordered iteration over entries sorted by key, value, or field metadata. It emphasizes structural consistency and ordered traversal, enabling use cases like static analysis of C struct/union fields, tracking field-specific properties, or memoizing computations on field hierarchies. The design accommodates arbitrary value types while ensuring safe access patterns through specialized folding and sequence conversion functions.",
      "description_length": 562,
      "index": 3103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.V",
      "library": "frama-c.kernel",
      "description": "This module defines a vertex type for control flow graphs with versioned labels, supporting comparison, hashing, and equality checks. It provides functions to create vertices from labels and retrieve their labels. It is used to represent control points in unrolled unnatural loops where each vertex label tracks versioned control flow information.",
      "description_length": 347,
      "index": 3104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Custom",
      "library": "frama-c.kernel",
      "description": "This module enables defining command-line parameters with custom data types, supporting features like value validation through predefined options, alias definitions with deprecation notices, and customizable serialization logic. It operates on a user-defined type `t` (aliased from `V.t`) alongside metadata structures that enforce constraints and track parameter properties. Typical applications include implementing complex configuration options in Frama-C plugins or tools requiring strict validation, backward-compatible aliases, or integration with project state management.",
      "description_length": 579,
      "index": 3105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map",
      "library": "frama-c.kernel",
      "description": "This module provides finite maps over CIL enumeration definitions, supporting insertion, deletion, ordered traversal, and structural transformations while maintaining key ordering. It works with key-value pairs where keys are CIL `Enuminfo` structures representing C enumeration constants. The module is particularly useful for static analysis plugins needing to track, query, or transform enum-related data across C codebases, such as analyzing constant propagation or generating enum usage reports.",
      "description_length": 500,
      "index": 3106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_functions.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type and associated operations for representing and manipulating built-in function types in the CIL framework. It provides functions for equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checks, all tailored to the specific structure of built-in function types. Use cases include managing type representations during CIL analysis and transformation, particularly when dealing with compiler-specific built-in functions and their type signatures.",
      "description_length": 529,
      "index": 3107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic structure with a focus on conditional execution through the `only_if` function, which includes a computation in the monad only if a given boolean condition holds. It operates on a unit type within the monad, enabling control flow decisions based on boolean values. Concrete use cases include selectively including side-effecting computations or conditional logging within a larger monadic pipeline.",
      "description_length": 429,
      "index": 3108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are integer intervals with congruence and values are of a specified data type. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Use cases include managing value abstractions in static analysis, such as tracking sets of integer values with modular constraints across program points.",
      "description_length": 426,
      "index": 3109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map",
      "library": "frama-c.kernel",
      "description": "This module implements map operations for native integer keys and arbitrary values, enabling creation, insertion, deletion, and structural modifications like union and merge. It supports ordered traversal, iteration, and transformations through functions for mapping, filtering, and partitioning, along with utilities to convert maps to sequences and lists. These features are optimized for static analysis plugins requiring efficient key-based data management and ordered binding manipulation.",
      "description_length": 494,
      "index": 3110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `User_dir` by extending an existing directory structure, allowing plugins to define and access custom subdirectories and files within Frama-C's filesystem hierarchy. It provides `get_dir` and `get_file` functions to retrieve directories or files, optionally creating intermediate paths. Concrete use cases include organizing plugin-specific resources such as log files, temporary data, or configuration files under a structured directory tree.",
      "description_length": 468,
      "index": 3111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mapping CIL source positions to arbitrary values, supporting creation, insertion, lookup, and in-place modification, along with sorted iteration and folding over entries. It works with CIL position keys and associated data structures for ordered traversal, value memoization, and structural type handling. Designed for static analysis tasks, it enables efficient tracking of source code annotations, such as variable definitions or analysis results tied to specific file locations.",
      "description_length": 528,
      "index": 3112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a functional set interface for managing ordered collections of memory zone bases (Hptset.t elements), supporting operations like union, intersection, mapping, filtering, and conversions to sequences or lists. It is designed for static analysis tasks such as tracking valid memory regions, performing set-based computations, and integrating project-specific validity checks through introspection utilities and ordered traversal.",
      "description_length": 446,
      "index": 3113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for elements with structural equality and strict constant comparison semantics, enabling precise manipulation of CIL elements like constants or composite types. It supports standard operations such as insertion, deletion, membership testing, set algebra (union, intersection, difference), and ordered traversal, while preserving strict equality constraints. It is particularly useful in static analysis tasks requiring exact equivalence checks, such as merging dataflow values or tracking unique structured entities in C code.",
      "description_length": 570,
      "index": 3114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for mappings from hash-consed tree keys (with compositional boolean annotations) to arbitrary values, supporting efficient insertion, deletion, lookup, iteration, and folding. It includes advanced features like bulk updates from sequences, sorted traversal by key or value, and memoization, enabling use cases such as structural introspection, type-safe data storage, and compositional analysis in static program verification frameworks. The underlying Patricia tree structure ensures efficient handling of tree-based keys with big-endian bitwise comparisons.",
      "description_length": 613,
      "index": 3115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Set",
      "library": "frama-c.kernel",
      "description": "This module offers functional manipulation of immutable character sets with operations like union, intersection, difference, and membership testing, alongside ordered traversal, predicate-based filtering, and conversion to/from lists and sequences. It works with immutable sets of characters (`t` type) and supports advanced queries for finding nearest elements under monotonic conditions, deep copying, and project-specific membership checks. It is particularly useful in static analysis plugins requiring precise character set handling, such as lexing, parsing, or constraint propagation tasks.",
      "description_length": 596,
      "index": 3116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with a specific key type that represents memory zone bases and includes functions to check membership in projects, create deep copies, and inspect key properties. Concrete use cases include managing and querying memory zone keys in a hash table, ensuring efficient and safe manipulation of memory base identifiers in static analysis plugins.",
      "description_length": 482,
      "index": 3117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Copy.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling deep copies of values, including equality, comparison, hashing, and pretty-printing functions. It works with a custom type `t` that represents data subject to copying, along with project-based membership checks and structural descriptors. Concrete use cases include managing copied program representations and ensuring structural integrity during analysis passes.",
      "description_length": 423,
      "index": 3118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Option",
      "library": "frama-c.kernel",
      "description": "This module provides operations to handle optional values within a lattice context that includes a top element. It supports mapping and iterating over optional values while preserving lattice properties. Useful for analyzing program states where values may be undefined or at a top lattice element.",
      "description_length": 298,
      "index": 3119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing mappings with CIL types as keys, where structural equality is determined by type names without unrolling. It supports functional and imperative updates, ordered iteration over key-value pairs, and utilities for safe lookups and memoization. These features are particularly useful for Frama-C plugins requiring precise type-based indexing, such as analyzing or transforming C code with complex type dependencies.",
      "description_length": 467,
      "index": 3120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string values, providing conversions between strings and a typed representation. It supports equality checks, comparison, hashing, and pretty-printing for string-based parameters. Use it to define and manage configurable string options in Frama-C plugins or command-line interfaces.",
      "description_length": 338,
      "index": 3121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables keyed by CIL attribute values, supporting operations like creation, lookup, iteration, and ordered traversal using customizable key comparators. It manages associations between CIL attributes and arbitrary data, ensuring type-safe access and efficient key-based queries during static analysis. Designed for tasks like tracking compiler annotations or analysis metadata, it enables safe memoization and structured traversal of attribute-associated values in C code analysis workflows.",
      "description_length": 518,
      "index": 3122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset",
      "library": "frama-c.kernel",
      "description": "This module provides a set-like structure (`Hptset.t`) for managing collections of CIL statements with operations like union, intersection, and difference, alongside utilities for deep copying, hashing, and project-aware filtering. It integrates with companion modules (`Set`, `Map`, `Hashtbl`) to enable ordered and hashed collections, supporting advanced static analysis tasks such as merging statement sets under customizable policies, cache-aware transformations, and traversal control via custom actions. Use cases include analyzing C codebases with persistent, heterogeneous statement sets while handling project lifecycle events like cache invalidation and state synchronization.",
      "description_length": 686,
      "index": 3123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates hash tables indexed by rational numbers, using the provided `Data` module for values. It implements standard operations like equality, comparison, hashing, and pretty-printing for these tables. Use it to efficiently store and retrieve data associated with precise rational number keys, such as mapping symbolic expressions to values in static analysis.",
      "description_length": 372,
      "index": 3124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on normalized filepaths, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with lists of key representatives, type descriptors, and project membership checks. Concrete use cases include managing file-based project data in a map structure and ensuring consistent handling of filepaths across different projects.",
      "description_length": 418,
      "index": 3125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing mappings from CIL labels to arbitrary values, supporting creation, insertion, deletion, lookup, and bulk transformations via sequences. It includes specialized functions for ordered iteration and folding over keys or values, safe value retrieval with optional results or defaults, and memoization of label-indexed computations. Designed for static analysis workflows, it facilitates tasks like associating CIL labels with analysis metadata, tracking annotations, or aggregating results during program transformation passes.",
      "description_length": 579,
      "index": 3126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based configuration parameters for customizing generated specifications, supporting operations to set allowed values, validate inputs, and retrieve function names or plain strings. It works with global string parameters that can have predefined value constraints and integrates with Frama-C's project state management. Typical use cases include enabling command-line customization of analysis behavior, enforcing valid parameter values, and handling value aliases or marshaling requirements.",
      "description_length": 518,
      "index": 3127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping bit-level memory location keys (`Location_Bits.t`) to arbitrary values, offering imperative operations for insertion, lookup, iteration, and transformation with support for ordered traversal and bulk sequence processing. It integrates specialized utilities like memoization, safe optional lookups, and Frama-C's structural type system for precise static analysis tasks. Designed for scenarios requiring bit-accurate memory modeling, such as low-level code analysis or plugin development, it enables efficient association of runtime data with fine-grained memory regions.",
      "description_length": 613,
      "index": 3128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for normalized filepaths, where each entry maps a filepath to a value of a specified data type. It supports standard hash table operations like lookup, insertion, and iteration, while ensuring filepaths are consistently normalized. Concrete use cases include tracking file-specific analysis results or configuration settings across different files in a project.",
      "description_length": 406,
      "index": 3129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a sorted set data structure for `Term_offset.t` values, which represent positional offsets within CIL terms, and provides operations like union, intersection, and difference alongside ordered traversal, element transformation, and nearest-neighbor queries. It supports static analysis tasks such as tracking memory layout dependencies, analyzing pointer arithmetic, or managing term hierarchies in Frama-C plugins, leveraging a total ordering to ensure consistent comparisons and efficient lookups. The module also integrates with Frama-C's infrastructure for serialization, type representation, and project-specific data management.",
      "description_length": 656,
      "index": 3130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing list-based configuration parameters, including dynamic list manipulation, alias management with visibility and deprecation controls, and state persistence across analysis sessions. It works with lists of typed elements (`E.t`), string lists, parameter states, and categorized option groups, enabling tasks like command-line argument parsing, plugin configuration, and incremental analysis state updates. Key features include collection traversal (via `iter`, `fold`), conditional validation (through `As_string`), and hierarchical organization of options (via `Category`).",
      "description_length": 617,
      "index": 3131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear",
      "library": "frama-c.kernel",
      "description": "This module defines a linear space with scalar values, vectors, and matrices to support precise computation of filter invariants in static analysis. It provides operations for vector initialization, element access, size and norm computation, and matrix arithmetic, including addition, multiplication, and inversion. These are used to model and analyze the convergence behavior of linear filters, particularly in numerical abstract domains for program verification.",
      "description_length": 464,
      "index": 3132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_ctor_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, working with a custom type `t` that includes metadata like name, descriptor, and representants. It supports deep copying, project membership checks, and integrates with structural descriptions for serialization. Concrete use cases include managing logic constructor representations in Frama-C's analysis, ensuring consistent handling of project-specific data across analyses.",
      "description_length": 478,
      "index": 3133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RightShiftNegative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling the behavior of right-shifting negative integers, specifically for the `-warn-right-shift-negative` option. It provides equality, comparison, hashing, pretty-printing, and deep copying functions for its values, along with utilities to inspect and manipulate project-related data embedded within the type. The module is used to manage and propagate the semantics of right shift operations on negative integers across Frama-C's analysis components.",
      "description_length": 506,
      "index": 3134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintComments.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for managing and manipulating comment-related information during the kernel's analysis. It supports operations for equality checking, comparison, hashing, pretty-printing, and deep copying of comment data, as well as querying project membership. The type `t` represents structured comment data, used to preserve and process comments in the abstract syntax tree under the `-keep-comments` option.",
      "description_length": 427,
      "index": 3135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps keyed by logic variables, supporting operations like insertion, deletion, lookup, and merging, along with advanced transformations such as conditional updates, list-accumulating additions, and filtered iterations. It handles arbitrary value types while preserving key ordering, offering both safe (option-based) and unsafe (exception-driven) variants for partial operations, and includes utilities for structural queries, pretty-printing, and sequence conversions. Designed for static analysis workflows, it enables precise management of logic variable mappings in CIL-based program representations, facilitating tasks like symbolic reasoning and state tracking.",
      "description_length": 710,
      "index": 3136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered, immutable sets of control flow vertices for managing state transitions in abstract interpretation workflows. It supports operations like union, intersection, and difference for set algebra, along with element-wise transformations, filtering, and ordered traversal via folds or sequences, all leveraging a total ordering of vertices. These sets are specifically used to track reachable states, analyze control dependencies, and perform path-sensitive dataflow computations in program verification tasks.",
      "description_length": 534,
      "index": 3137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic composition operators for combining two monads with a predefined `swap` function, enabling sequential and parallel computations with mixed monadic effects. It supports operations like `>>-`, `let*`, and `and*` for chaining monadic actions, along with their non-monadic counterparts such as `let+` and `and+` for value transformations. Concrete use cases include composing stateful and error-handling computations, such as parsing with backtracking state or validating data with accumulated context.",
      "description_length": 527,
      "index": 3138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations `iter` and `map` for the `option` type, enabling sequencing of effectful computations over optional values. It allows working with functions that return monadic results when processing `Some` or `None` cases of `option`. Concrete use cases include handling optional data in a pipeline where each step may produce side effects or depend on prior results, such as parsing or conditional state updates.",
      "description_length": 439,
      "index": 3139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.BackwardAnalysis.Result",
      "library": "frama-c.kernel",
      "description": "This module represents the outcome of a backward dataflow analysis over an interpreted automaton, providing access to computed abstract states at specific control points. It allows querying states at the function entry, return point, or before/after individual statements, and supports iteration over results in various orders. The module also includes utilities to visualize the results in DOT format or extract them as a hash table mapping control points to states.",
      "description_length": 467,
      "index": 3140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module enables structured manipulation of hash tables with CIL enumeration items as keys, offering operations such as bulk updates from sequences, ordered iteration and folding, safe key lookups, and memoization. It is tailored for static analysis tasks in Frama-C plugins, supporting efficient tracking of enumeration-based data mappings and aggregation of analysis results across enum values.",
      "description_length": 399,
      "index": 3141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Set_project_as_default.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing sets of project-related values with support for equality, comparison, hashing, and pretty-printing. It includes functions to check membership based on project properties, perform deep copies, and expose type descriptors for integration with Frama-C's internal systems. Concrete use cases include tracking and manipulating sets of analysis projects within Frama-C plugins.",
      "description_length": 431,
      "index": 3142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module enables management of file path lists (`Frama_c_kernel.Filepath.t list`) and string-based parameters within plugins, offering operations to add, iterate over, fold, and validate entries while tracking modifications and handling marshaling. It integrates with parameter categories and string validation modules to support use cases like command-line interface parsing, persistent configuration management, and grouping parameters into logical categories for plugin customization.",
      "description_length": 490,
      "index": 3143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module manages command-line options storing string sets, offering operations to add, query, and iterate over elements while tracking state changes via hooks. It operates on a mutable global string set (`Frama_c_kernel.Datatype.String.Set`) with utilities for alias resolution, serialization, and category-based grouping of options. Designed for configuration management in CLI tools, it supports use cases like validating input, applying defaults, and organizing related flags into logical categories.",
      "description_length": 506,
      "index": 3144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with `Code_annotation.t` keys and arbitrary value types, emphasizing functional updates and precise key ordering. It supports comprehensive operations like merging, filtering, ordered traversal (both ascending and descending), and structural transformations, along with utilities for static analysis metadata management, such as attaching and querying annotations on CIL code structures. The design enables efficient handling of code-centric metadata, such as preconditions, postconditions, or coverage information, during static analysis workflows.",
      "description_length": 585,
      "index": 3145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines operator-based combinators for monadic computations built from a bind operation with product support. It provides sequencing operators like `>>-` and `let*` for chaining monadic actions, along with `and*` for parallel composition. These operators enable concise expression of dependent and independent monadic operations over values wrapped in a monadic type `t`.",
      "description_length": 383,
      "index": 3146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for key-value storage with support for in-place updates, ordered iteration, and value-based lookups, alongside folding and filtering over sequences of entries. It works with hash tables (`'a Hashtbl.t`) where keys are of a specified type `t`, emphasizing type-safe key management and custom table construction through its submodules. Designed for Frama-C's analysis framework, it enables efficient memoization, state tracking during static analysis, and handling complex data flows requiring ordered or sequence-driven processing.",
      "description_length": 571,
      "index": 3147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Set",
      "library": "frama-c.kernel",
      "description": "This module offers structural set manipulation for CIL types, supporting union, intersection, difference, and ordered iteration while resolving type equality through structural comparison of unrolled typedefs and struct keys. It operates on immutable sets of `Typ.t` values, enabling functional transformations like mapping, filtering, and sequence conversions, alongside utilities for nearest-element queries and type-aware pretty-printing. Designed for static analysis tasks, it facilitates precise type relationship tracking in Frama-C plugins, such as analyzing struct hierarchies or canonicalizing type definitions during code transformation.",
      "description_length": 647,
      "index": 3148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space.Matrix",
      "library": "frama-c.kernel",
      "description": "This module implements standard matrix operations over a linear space, including addition, multiplication, inversion, and exponentiation, with support for identity, zero, and shifted matrices. It works with fixed-size matrices parameterized by row and column dimensions, using a scalar type defined by the linear space. Concrete use cases include computing matrix norms, manipulating linear transformations, and constructing or modifying matrices for invariant analysis in static verification tools.",
      "description_length": 499,
      "index": 3149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Orig_project.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and comparing structural elements of an original project used in computing AST diffs. It supports operations like equality checks, comparison, hashing, and pretty printing, as well as deep copying and membership testing for project skeletons. The type `t` is used to capture representational and structural information needed to analyze and manipulate project data during diff computation.",
      "description_length": 438,
      "index": 3150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for mapping CIL logic identifiers (with type and project context) to arbitrary data, supporting efficient key-based access, traversal, and memoization. It works with key-value pairs where keys are structured logic descriptors and values are user-defined, enabling use cases like static analysis tracking or transformation metadata management in CIL-based tools. The module offers ordered iteration, custom comparison, and value filtering, tailored for handling logic-related data in compiler analyses.",
      "description_length": 555,
      "index": 3151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping logic constants from CIL's type hierarchy to arbitrary values, supporting efficient insertion, lookup, iteration, and folding operations. It provides ordered traversal using custom comparisons, memoization utilities, and sequence-based initialization, with keys constrained to `Logic_constant.t` while values maintain polymorphic type flexibility. Designed for static analysis plugins, it facilitates structured manipulation of logic constant associations in Frama-C's type system and analysis workflows.",
      "description_length": 547,
      "index": 3152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module provides functional map operations for ordered key-value pairs, supporting insertion, deletion, aggregation, and ordered traversal with polymorphic values. It emphasizes immutability through persistent data structures, optimized for physical equality checks, and includes utilities for filtering, mapping, and converting between lists or sequences. Designed for scenarios like dataflow analysis in plugins, it handles ordered key spaces and offers both safe (option-returning) and unsafe (exception-raising) lookup variants.",
      "description_length": 536,
      "index": 3153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for hash-consed tree keys and arbitrary values, supporting efficient insertion, deletion, union, and merge with customizable combination logic, alongside ordered traversal, filtering, and splitting. It maintains boolean metadata per tree node to enable compositional reasoning, working with polymorphic values and ordered keys derived from Patricia trees. Use cases include static analysis tasks requiring precise key ordering, bulk updates from sequences, and transformations with selective pruning or aggregation.",
      "description_length": 559,
      "index": 3154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enuminfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and comparing abstract syntax tree (AST) differences in Frama-C, specifically for enum types. It provides operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It is used to track and manipulate variations in enum definitions across different project versions.",
      "description_length": 392,
      "index": 3155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map",
      "library": "frama-c.kernel",
      "description": "This module provides associative and ordered map operations for polymorphic maps with lattice-structured values, supporting insertion, deletion, aggregation, and transformation while preserving key ordering. It works with Hptmaps (hash-consed persistent trees) that have a fixed key type and values equipped with a lattice structure, enabling efficient lattice-based combination of maps. These operations are optimized for static analysis tasks like dataflow and abstract interpretation, where lattice properties ensure safe merging of symbolic states and ordered keys facilitate precise program analysis.",
      "description_length": 605,
      "index": 3156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfig.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing abstract data types used in the configuration printing system. It provides functions for equality checks, comparison, hashing, and pretty-printing of datatype values, along with deep copying and project membership testing. These capabilities support precise handling of configuration data during analysis and output generation.",
      "description_length": 385,
      "index": 3157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-based parameters for per-file C preprocessor configurations, including setting, retrieving, and tracking changes to values. It works with strings and structured data types to enforce validity constraints, such as allowed function names or project-specific aliases, and supports serialization for state persistence. It is used to handle command-line argument customization per source file and validate C function identifiers during static analysis setup.",
      "description_length": 502,
      "index": 3158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations `iter` and `map` for processing values within an `option` context, producing results in a monadic type `t`. It enables chaining computations that handle optional values, where each function applies a monadic effect to the contents of an option. Concrete use cases include safely processing optional data while accumulating effects like logging, error handling, or state updates.",
      "description_length": 418,
      "index": 3159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific cache directory, providing functions to retrieve or create directories and files within it. It works with file paths represented by the `Frama_c_kernel.Filepath.t` type, allowing plugins to store transient data securely. Concrete use cases include caching analysis results or temporary files during static analysis sessions.",
      "description_length": 362,
      "index": 3160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of ordered set operations for integer values, supporting creation, modification, and querying through immutable functional transformations. It works with sets of integers, enabling precise manipulation via union, intersection, and difference operations, alongside ordered traversal, filtering, and element selection with min/max extraction. Designed for use cases requiring rigorous set-theoretic reasoning\u2014such as static analysis of program invariants or symbolic value tracking\u2014it also facilitates conversions to sequences and provides utilities for nearest-neighbor queries, hashing, and structured data representation.",
      "description_length": 663,
      "index": 3161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map",
      "library": "frama-c.kernel",
      "description": "This module provides functions for creating and manipulating immutable maps with ordered keys from a set structure and arbitrary value types, supporting operations like insertion, deletion, aggregation, and bulk transformations such as filtering or partitioning. It emphasizes ordered traversal (typically ascending unless specified), structural queries (e.g., cardinality, membership checks), and conversions to sequences or lists, tailored for static analysis tasks requiring precise, side-effect-free manipulation of polymorphic maps and structured data.",
      "description_length": 557,
      "index": 3162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with keys derived from CIL labels, supporting operations like merging, iteration, filtering, and structural transformations while preserving key ordering. It provides utilities for converting between maps and sequences, pretty-printing, and comparing label-keyed associations, leveraging a comparator from the `Make` argument. These maps are used to manage label-based metadata in CIL analysis, such as tracking control-flow labels or annotating program elements with analysis results.",
      "description_length": 521,
      "index": 3163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with any data type specified via the `Data` parameter, providing deep copy functionality and project membership checks. Concrete use cases include managing sets of project-specific values with efficient lookups and ensuring consistent value representations across different parts of an analysis plugin.",
      "description_length": 473,
      "index": 3164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepBuiltinMacros.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing built-in macro descriptors used in the printing of machine-dependent built-in macros. It provides operations for equality checking, comparison, hashing, and pretty-printing instances of this type, along with utilities for deep copying and project membership testing. The type supports structured representation and manipulation of macro metadata within the kernel's analysis framework.",
      "description_length": 434,
      "index": 3165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map",
      "library": "frama-c.kernel",
      "description": "This module implements functional, persistent maps with ordered syntactic scopes as keys and arbitrary value types, supporting operations like insertion, lookup, filtering, and ordered traversal (forward/reverse). It provides utilities for static analysis tasks such as tracking scope-bound data, merging contextual information across CIL code structures, and analyzing control-flow dependencies through scoped key ranges. Key features include list-accumulating updates, customizable pretty-printing, and predicate-driven transformations tailored for C code analysis workflows.",
      "description_length": 577,
      "index": 3166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling extra command-line arguments passed to the C preprocessor. It supports operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. The primary use case is managing and manipulating collections of preprocessor arguments in a type-safe manner during analysis.",
      "description_length": 378,
      "index": 3167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module implements forward dataflow analysis over control flow graphs built using the `MakeGraph` functor. It computes dataflow values for each node in the graph using a widening operator and a worklist algorithm. The analysis processes nodes in reverse topological order, propagating information from predecessors to successors, and is suitable for problems like interval analysis or liveness detection.",
      "description_length": 408,
      "index": 3168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling generated specification data. It works with structured descriptors, project skeletons, and lists of representants to manage and manipulate complex data representations. Concrete use cases include deep copying of data structures, checking project membership, and ensuring unique identification through name and descriptor fields.",
      "description_length": 461,
      "index": 3169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps keyed by `Model_info.t` values, offering standard operations like insertion, deletion, and lookup alongside advanced transformations such as filtered mapping, partitioning, and ordered traversal. It supports value types ranging from atomic data to lists, with utilities for bulk conversion to/from lists and sequences, and includes reverse-order iteration and pretty-printing for debugging. Designed for static analysis workflows, it enables structured management of CIL model metadata, such as tracking variable annotations or function summaries during program analysis.",
      "description_length": 607,
      "index": 3170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of operations for manipulating sets of integers, including creation, union, intersection, and element-wise transformations, all maintaining elements in sorted order through pure functional updates. It supports efficient membership checks, subset relations, and ordered iteration, making it suitable for scenarios requiring precise integer set management, such as tracking program variables or memory locations in static analysis. Additional utilities for converting sets to sequences, finding nearest elements relative to a value, and integrating standard data type operations like hashing and pretty-printing further enable its use in analysis workflows where ordered collection introspection is critical.",
      "description_length": 747,
      "index": 3171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CodeOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating code output specifications. It supports equality, comparison, hashing, and pretty-printing of values, along with deep copying and membership checking over project skeletons. Use cases include managing and querying structured code output data during analysis or transformation tasks.",
      "description_length": 374,
      "index": 3172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.False_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean datatype initialized to `false`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project skeletons. Useful for tracking analysis states where a boolean flag is needed, such as marking visited nodes or controlling analysis phases.",
      "description_length": 349,
      "index": 3173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for logic information entities, supporting union, intersection, difference, and element manipulation alongside transformations like mapping and filtering. It works with sets of `Logic_info.t` values, maintaining strict ordering through `Ord.compare` to enable precise set-based computations in static analysis. Typical applications include tracking logical dependencies, analyzing program properties via set-theoretic operations, and managing ordered collections of logic entities during code verification.",
      "description_length": 552,
      "index": 3174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for creating and manipulating ordered sets of type-safe normalized filepaths, including union, intersection, difference, membership checks, and transformations via mapping and filtering. It supports iteration, conversion to and from lists and sequences, and maintains a total ordering for consistent element access and comparison. These functionalities are particularly useful for managing file collections in project contexts, such as tracking source files or dependencies with precise, normalized path handling.",
      "description_length": 545,
      "index": 3175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_pair.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic pair datatype combining two distinct types, supporting operations like equality, comparison, hashing, and pretty-printing. It works with any two modules providing their own datatypes, enabling structured representation and manipulation of paired values. Concrete use cases include modeling relationships between program elements, such as variable-value associations or abstract state pairs.",
      "description_length": 424,
      "index": 3176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SafeArrays.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling safe array representations in the kernel. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with deep copying and project membership checks. It is used to manage and manipulate array-related data structures with strong invariants, ensuring correctness in contexts like static analysis and plugin development.",
      "description_length": 421,
      "index": 3177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for chaining computations in a monad built using `map`. It provides the bind and map operators `(>>-)`, `(let*)`, `(>>-:)`, and `(let+)`, enabling concise composition of functions that produce monadic values. These operations are used to sequence actions where each step depends on the result of the previous, particularly in contexts like effectful or fallible computations.",
      "description_length": 413,
      "index": 3178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Set",
      "library": "frama-c.kernel",
      "description": "This module offers an ordered, immutable set abstraction for managing collections of localizable source elements, supporting standard operations like union, intersection, difference, and membership checks alongside transformations such as mapping and filtering. It leverages a total ordering for efficient element queries, nearest-value searches, and sequence conversions, while providing utilities for pretty-printing and deep copying. Designed for static analysis tasks, it enables precise manipulation of sets of located AST nodes, such as tracking code regions or annotations during program transformation.",
      "description_length": 610,
      "index": 3179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for values of a given type `Data.t`, where keys are states compliant with the Frama-C project model. It provides standard map operations such as lookup, insertion, and traversal, along with project-aware comparisons, deep copying, and pretty printing. Concrete use cases include tracking and manipulating state-dependent analyses or annotations across different project contexts in Frama-C plugins.",
      "description_length": 454,
      "index": 3180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for managing collections of CIL expressions with structural equality and strict constant comparison, supporting efficient set operations like union, intersection, and difference, as well as ordered traversal, filtering, and transformation. It maintains physical equality for unchanged sets and provides utilities for sequence conversion, nearest-element queries, and type-class compliant comparison/hashing. It is particularly useful in static analysis or code transformation tasks requiring precise structural identity of expressions, such as detecting redundant computations or canonicalizing intermediate representations.",
      "description_length": 668,
      "index": 3181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table creation, modification, and traversal capabilities with support for custom key comparison and ordering logic. It operates on hash tables mapping keys of a comparable type `t` (with defined `equal` and `hash` functions) to polymorphic values, enabling operations like in-place filtering, sorted iteration, and sequence-to-table conversion. It is particularly useful for scenarios requiring deterministic key ordering, such as processing symbol tables with custom equivalence rules or generating ordered aggregates from dynamic key-value collections.",
      "description_length": 578,
      "index": 3182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_ref.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype instance from a polymorphic type provided by module T. It supports operations like equality, comparison, hashing, and pretty-printing for the instantiated type, along with deep copying and project membership checks. It is used to define and manipulate structured values with unique type descriptors in static analysis contexts.",
      "description_length": 370,
      "index": 3183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables using CIL expressions with structural equality as keys, prioritizing size-based comparison for `sizeof` expressions. It supports standard operations like insertion, lookup, iteration, and folding, along with bulk updates from sequences and memoization, all respecting structural equivalence. Designed for static analysis or compiler optimizations, it enables deduplication or caching based on expression equivalence, such as grouping expressions with identical structure or size semantics in `sizeof` contexts.",
      "description_length": 545,
      "index": 3184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.ForwardAnalysis.Result",
      "library": "frama-c.kernel",
      "description": "This module provides access to the results of a forward dataflow analysis on an interpreted automaton, allowing retrieval of analysis states at specific control points such as function entry, return, and before or after individual statements. It supports iteration over analysis results either per vertex or per statement, in arbitrary or guaranteed increasing order of statement identifiers. Concrete use cases include inspecting abstract states at key program points, visualizing analysis results via DOT output, and extracting a hash table mapping control points to their computed states.",
      "description_length": 591,
      "index": 3185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.List",
      "library": "frama-c.kernel",
      "description": "This module provides operations to traverse, transform, and accumulate over lists in a lattice context where bottom values are explicitly handled. It supports `iter`, `map`, and `fold_left` functions that propagate bottom values through computations. It is used when processing lists of values that may include undefined (bottom) elements, ensuring that lattice semantics are preserved during iteration, mapping, or folding.",
      "description_length": 424,
      "index": 3186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integer value abstractions and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to track and manipulate integer-indexed data in static analysis contexts, such as associating abstract integer ranges with variable identifiers or analysis states.",
      "description_length": 439,
      "index": 3187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mappings with native integer keys, supporting creation, modification, lookup, and ordered traversal. It works with hash tables that associate native integers to arbitrary values, enabling efficient memoization, caching, and deterministic processing of entries via sorted iteration or folding. Key use cases include managing stateful mappings in static analysis plugins and optimizing repeated computations through utilities like `memo` and `find_opt`.",
      "description_length": 498,
      "index": 3188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.False",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for defining boolean command-line parameters that default to false, enabling operations to explicitly set their value, monitor state changes via hooks, and manage aliases or custom serialization. It works with typed boolean parameters tracked by `Frama_c_kernel.Typed_parameter.t`, integrating with Frama-C's state management to distinguish between default, explicitly set, and computed values. It is particularly useful for plugins requiring boolean flags that need to trigger actions when toggled or maintain synchronization with external configurations.",
      "description_length": 591,
      "index": 3189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line options as string-keyed maps with values constrained to a specific datatype, offering operations to add, retrieve, iterate, and fold over entries while supporting custom serialization, alias resolution, and equality checks. It integrates change-tracking hooks and category-based organization, primarily serving plugin configuration, dynamic option parsing, and stateful project management within Frama-C's analysis framework.",
      "description_length": 467,
      "index": 3190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integer intervals with congruence, as defined by the `Int_interval` module, and values are of a specified data type. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying of the map. Concrete use cases include tracking value ranges with congruence properties in static analysis, efficiently querying interval-based data, and maintaining distinct mappings for symbolic execution or abstract interpretation.",
      "description_length": 500,
      "index": 3191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SaveState.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating save state data during analysis, including equality checks, comparison, hashing, and pretty printing. It works with the abstract type `t` representing saved state values, along with descriptors and project representations. Concrete use cases include comparing and copying saved states, checking project membership, and generating human-readable output for debugging or logging.",
      "description_length": 438,
      "index": 3192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "The module provides hash table operations for CIL expressions with structural equality, enabling key-based lookups, insertion, and traversal. It works with key-value pairs where keys are CIL expressions compared structurally (ignoring their physical identity) and values can be arbitrary data. This is particularly useful in analysis plugins requiring precise expression equivalence checks, such as memoization or tracking structurally identical expressions during static analysis. Ordered iteration and folding over the table's elements are supported, leveraging key structure for deterministic traversal.",
      "description_length": 606,
      "index": 3193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to values wrapped in an option type. It provides `iter` for performing side-effecting operations on `option` values within a monadic context and `map` for transforming `option` values using monadic functions. It is useful when handling optional data where each step may fail or require monadic effects, such as reading from a context or logging.",
      "description_length": 383,
      "index": 3194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RemoveExn.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling values in the context of the `-remove-exn` option. It supports structured data representation with a descriptor, a list of representants, and project membership checks via `mem_project`. The type is used to manage and manipulate values during kernel analysis, particularly when dealing with effects of exception removal transformations.",
      "description_length": 475,
      "index": 3195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map",
      "library": "frama-c.kernel",
      "description": "Implements finite maps keyed by CIL function definitions, supporting standard associative operations like ordered traversal, merging, and filtering, alongside specialized variants for list-accumulation and safe/unsafe lookups. It pairs these keys with arbitrary value types, offering transformations, membership checks, and bidirectional conversions to lists and sequences while preserving key-order",
      "description_length": 399,
      "index": 3196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module enables efficient key-value storage and manipulation using hash tables where keys are instances of a datatype equipped with defined `equal` and `hash` operations. It supports operations like insertion, deletion, lookup, iteration, and folding, along with advanced features such as sorted traversal, memoization, and conversion to/from sequences, all while allowing in-place modifications and statistical tracking. It is particularly useful in static analysis plugins for managing program state, caching computed results, or handling complex data mappings where custom key structures and performance-critical lookups are required.",
      "description_length": 641,
      "index": 3197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates sets of kernel functions, providing operations for equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` and interacts with project skeletons through membership checks and deep copying. Concrete use cases include managing collections of functions during static analysis, tracking function sets across different analysis states, and ensuring consistent representation in dataflow computations.",
      "description_length": 465,
      "index": 3198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for managing collections of `Identified_term.t` values, including insertion, deletion, union, intersection, difference, and membership checks, alongside ordered element selection via `min_elt` or `max_elt`. It supports functional transformations like mapping, filtering, and partitioning, as well as conversions to and from lists and sequences, ensuring uniqueness and order preservation. These capabilities are particularly useful in static analysis tasks such as tracking and manipulating program terms during CIL-based code transformations or data-flow analysis.",
      "description_length": 609,
      "index": 3199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Model_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing logic environment model information with operations for equality, comparison, hashing, and pretty printing. It supports structured values with a descriptor, packed representation, and project membership checks. Use cases include managing and comparing logic model instances in static analysis tools.",
      "description_length": 348,
      "index": 3200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for key-value mappings with type-safe insertion, deletion, lookup, and iteration, supporting both functional and imperative manipulation patterns. It works with hash tables keyed by a comparable type `t` (from `Make_with_collections`) and storing arbitrary values `'a`, offering ordered traversal, custom comparator-based sorting, and memoization utilities. These features are particularly useful for static analysis plugins requiring deterministic processing of project-scoped data, such as caching analysis results or managing structured key-value associations with safe access patterns.",
      "description_length": 632,
      "index": 3201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines lifting operators for composing computations over lattice values that may be `Bottom` or `Top`. It provides applicative and monadic bind operations that ensure proper handling of `Bottom` and `Top` during evaluation, with `and+` and `and*` combining lattice values while preserving subtyping. These operators are used to build safe, chained analyses in static analysis plugins where lattice precision is critical.",
      "description_length": 433,
      "index": 3202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent set data structure for managing ordered collections of kernel functions, supporting efficient membership queries, ordered traversal, and set algebra operations like union and intersection. It provides both functional and imperative-style APIs for transforming sets through filtering, mapping, and partitioning, while maintaining elements in sorted order for optimized access patterns. Typical use cases include static analysis plugins requiring precise tracking of function sets with ordered enumeration or range-based queries.",
      "description_length": 563,
      "index": 3203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a specialized hashtbl structure, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured keys that can contain project-specific data, enabling precise key management in the alarms database. Use cases include tracking and comparing alarm identifiers across different analysis contexts.",
      "description_length": 380,
      "index": 3204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic composition operators for chaining computations across two layered monads, enabling sequential binding and mapping operations. It works with values of type `'a T.t S.t`, where `T` and `S` are the interior and exterior monads, respectively. These operators support concrete use cases such as combining stateful computations with optional results, where intermediate steps may fail but must preserve state flow.",
      "description_length": 437,
      "index": 3205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements a value type for strings within a plugin system, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports conversion to and from string representations, deep copying, and project membership checks. Concrete use cases include storing and manipulating string-based configuration values or symbolic identifiers within Frama-C plugins.",
      "description_length": 396,
      "index": 3206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String",
      "library": "frama-c.kernel",
      "description": "This module enables plugins to manage string-based configuration options, supporting registration, validation, and state persistence with project-specific behavior. It operates on string parameters that can be constrained to allowed values, integrated with command-line parsing, and marshaled for serialization, facilitating use cases such as user-defined settings and dynamic option updates.",
      "description_length": 392,
      "index": 3207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutoLoadPlugins.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating plugin datatypes with operations for equality, comparison, hashing, and pretty printing. It supports introspection through descriptor access and provides deep copying and project membership checks. Concrete use cases include managing plugin-specific data structures during analysis and ensuring consistent handling of plugin state across different projects.",
      "description_length": 423,
      "index": 3208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Orig_name.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling original name representations in Frama-C's kernel. It provides utilities to inspect and manipulate values of type `t`, including deep copying, membership checks over projects, and access to type descriptors. Concrete use cases include managing and comparing symbolic names during static analysis, particularly when tracking original identifiers through transformations.",
      "description_length": 499,
      "index": 3209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent map structure using keys with strict structural equality, supporting ordered operations like insertion, merging, and traversal while maintaining immutability. It works with CIL-based data structures requiring precise comparisons of composite types, such as analyzing program variables or memory layouts in static analysis. Key use cases include tracking field offsets in structs or unions with exact equality checks, and building analysis passes that require ordered key enumeration or set-theoretic operations on CIL constructs.",
      "description_length": 565,
      "index": 3210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for sequencing computations and combining values within a monadic context. It supports operations like bind (`>>-`, `let*`), map (`let+`), and product (`and*`, `and+`) over a monad built from a map and product structure. Concrete use cases include chaining analysis steps in static analysis plugins, where intermediate results are passed through monadic actions, and combining multiple analyses while preserving their structure.",
      "description_length": 466,
      "index": 3211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based options for representing file collections and validating string parameters, particularly function names. It operates on string values that may encode lists of files, supporting operations like parsing command-line arguments, serialization, default value handling, and project-specific state integration. Its use cases include configuring file analysis targets via command-line parameters and ensuring valid string inputs in contexts requiring function name resolution within Frama-C's kernel systems.",
      "description_length": 533,
      "index": 3212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing ordered sets of 32/64-bit integers, including standard set operations (union, intersection, difference), element queries, transformations via mapping and filtering, and conversions to/from lists and sequences. It ensures deterministic behavior with physical equality guarantees for unchanged sets, supports ordered traversal, and provides utilities like nearest-value searches and Frama-C-specific deep copying. These capabilities are particularly useful in static analysis tasks requiring precise integer range tracking, program state constraint manipulation, or efficient set-based computations in plugin development.",
      "description_length": 662,
      "index": 3213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for managing key-value pairs with ordered iterations, in-place filtering, and value-based lookups, integrated within a lattice-equipped map/set structure. It operates on polymorphic `'a Hashtbl.t` tables where keys are ordered using custom or standard comparisons, enabling efficient merging, folding, and memoization over structured data. It is particularly useful for program analysis tasks requiring precise state merging and ordered traversal of abstract values.",
      "description_length": 520,
      "index": 3214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Machdep.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type and associated operations for representing and manipulating abstract data types in the context of Frama-C's kernel. It provides functionality for equality checks, comparison, hashing, pretty-printing, and deep copying of values, as well as introspection via project membership testing. The module works directly with a specific abstract type `t`, descriptors, packed structures, and lists of type representants, used in managing and querying data during static analysis.",
      "description_length": 511,
      "index": 3215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a rich set of operations for manipulating ordered collections of C enum declarations (`Enuminfo.t`), including standard set algebra (union, intersection, difference), ordered traversal (via `to_seq_from`, `find_first`, `find_last`), and transformation utilities (filtering, mapping, partitioning). It works with sets of enumeration information elements derived from Frama-C's CIL intermediate representation, enabling efficient analysis of C code's type systems. Specific applications include static analysis plugins that require precise tracking of enum values, dependency resolution between declarations, or range-based processing of enumeration constants during program transformation tasks.",
      "description_length": 713,
      "index": 3216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations tailored for CIL type information keys, enabling efficient insertion, lookup, iteration, and transformation of key-value pairs where keys represent structured CIL type data. It supports imperative and functional manipulation patterns, including ordered traversal via customizable comparisons, bulk updates from sequences, and memoization strategies that respect structural equality and project-specific type semantics. Such capabilities are particularly useful in static analysis tasks requiring precise management of type hierarchies, inter-procedural data flow tracking, or transformation pipelines that depend on canonical type representations across compilation units.",
      "description_length": 713,
      "index": 3217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for chaining stateful computations in the State monad. It provides bind and map operations using familiar syntax, enabling concise composition of functions that manipulate a shared state. These operators are used to sequence state updates and transformations in a purely functional context.",
      "description_length": 326,
      "index": 3218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps keyed by `Declaration.t` values, supporting ordered insertion, querying, and transformation operations like union, filtering, and iteration. It provides utilities for structured traversal, sequence conversion, and customizable pretty-printing of mapped data, primarily used for managing and analyzing abstract syntax tree elements in source code processing tasks.",
      "description_length": 398,
      "index": 3219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for alarm-related data, where keys are determined by the `Data` module and values are of type `Data.t`. It provides standard map operations including comparison, equality, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include managing and querying collections of alarms with structured data values, such as tracking alarm states across different analysis projects.",
      "description_length": 478,
      "index": 3220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map",
      "library": "frama-c.kernel",
      "description": "Implements polymorphic maps with logic constants as ordered keys, supporting associative operations (addition, lookup, merging), ordered traversal (iteration, folding), and transformations (mapping, filtering) over key-value pairs. Provides utilities for structural queries, ordered sequence conversions, and customizable pretty-printing, with keys derived from CIL logic constants and polymorphic values",
      "description_length": 404,
      "index": 3221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module provides functionality to manage command-line options that accept lists of file paths, supporting operations like value mutation (addition, iteration, folding), serialization, and dynamic update hooks. It operates on `Filepath.t list` data structures, enabling project-specific state management, default value handling, and user-facing help message generation. Specific use cases include organizing parameters into categories, resolving aliases, and ensuring consistent configuration updates across different stages of analysis.",
      "description_length": 540,
      "index": 3222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically used to handle unsigned downcast warnings in Frama-C's kernel. It provides utilities to manage and inspect values of this type, including deep copying, membership checks over projects, and representation details. Concrete use cases include tracking and comparing warning configurations and values during static analysis.",
      "description_length": 441,
      "index": 3223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a suite of ordered set operations for managing collections of named logic types, supporting creation, modification, and querying through functions like union, intersection, and membership checks. It works with immutable sets of `Logic_type_ByName` elements, leveraging a total ordering for deterministic traversal, filtering, and element selection. These operations are particularly useful in static analysis workflows, such as tracking logic variables during code verification or transforming sets of types through iterative refinement.",
      "description_length": 556,
      "index": 3224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Set",
      "library": "frama-c.kernel",
      "description": "This module supports efficient manipulation of ordered sets containing logic type elements from CIL's intermediate representation. It provides functional and imperative operations for set algebra (union, intersection, difference), ordered traversal (iteration, folding), element transformation (filtering, mapping), and structural queries (membership, subset checks). Designed for Frama-C's static analysis tasks, it handles use cases like tracking logic type dependencies, managing type constraints, and implementing analysis algorithms requiring ordered element processing without unrolling complex type structures.",
      "description_length": 617,
      "index": 3225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps using CIL instructions as keys, offering efficient insertion, removal, and lookup operations alongside functional transformations like mapping, filtering, and folding over key-value pairs. It supports bidirectional traversal, ordered iteration, and structural comparisons, optimized for performance with physically equal keys. Primarily used in static analysis workflows, it enables associating instruction-specific metadata\u2014such as data flow information or analysis states\u2014with individual program points during C code verification.",
      "description_length": 568,
      "index": 3226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hashtbl for a custom datatype with operations for equality, comparison, hashing, and pretty printing. It supports deep copying, membership testing with project functions, and provides type descriptors for integration with Frama-C's state management. This structure is useful for managing interned or canonicalized values that must be efficiently compared and stored without preventing garbage collection.",
      "description_length": 422,
      "index": 3227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Stmt.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing statement-level differences in the AST, including operations for equality, comparison, hashing, and pretty-printing. It works with statements in the context of projectified data, supporting deep copies and project membership checks. Concrete use cases include tracking changes between project versions and analyzing statement modifications during diff computations.",
      "description_length": 414,
      "index": 3228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Varinfo_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a hash table for `Varinfo` values with efficient equality, comparison, and serialization. Provides operations to create, manipulate, and query variable information entries, including project membership checks and deep copying. Designed for use in static analysis plugins requiring persistent, project-aware variable tracking.",
      "description_length": 336,
      "index": 3229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps with integer keys and arbitrary values, supporting operations like insertion, deletion, merging, and querying with ordered key comparisons. It provides utilities for sorted traversal, predicate-based filtering, partitioning, and conversions to lists or sequences, along with bulk updates and range-based traversals. These maps are used in abstract interpretation contexts to model variable bindings or numeric state representations, enabling efficient analysis of program properties through lattice operations and structured transformations.",
      "description_length": 581,
      "index": 3230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and applying extra C preprocessor arguments per file. It defines operations to create, modify, and enable predefined categories such as `@none`, `@default`, and `@all`, each controlling how command-line options are interpreted and applied. Use cases include configuring per-file compilation flags in static analysis plugins and managing option dependencies during analysis setup.",
      "description_length": 423,
      "index": 3231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SpecialFloat.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing a custom data type `t` related to special float handling, including equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checking within projects, and provides type and descriptor information. Concrete use cases include analyzing and transforming floating-point values in C code during static analysis, particularly for tracking and comparing special float behaviors across different analysis contexts.",
      "description_length": 482,
      "index": 3232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsAutoValidate.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for representing and manipulating values related to assembly contract validation. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to handle internal state and configuration for the `-asm-contracts-auto-validate` analysis option.",
      "description_length": 358,
      "index": 3233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.BigIntsHex.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling big integers in hexadecimal representation, primarily used for internal kernel computations involving numeric analysis. It provides equality, comparison, hashing, and pretty-printing functions tailored to the needs of analyzing C code with hexadecimal integer literals. The module supports deep copying, project membership checks, and integrates representational values for use in Frama-C's abstract interpretation framework.",
      "description_length": 485,
      "index": 3234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set-theoretic operations (union, intersection, difference), ordered traversal (iteration, folding, mapping), and sequence integration (conversion, bulk insertion) for a sorted set data structure. It works with ordered elements maintained in a balanced tree-like representation, supporting efficient membership checks, ordered transformations, and project-specific filtering. Use cases include static analysis tasks requiring precise set manipulation with deterministic ordering, such as tracking program state dependencies or analyzing control-flow structures.",
      "description_length": 581,
      "index": 3235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.M",
      "library": "frama-c.kernel",
      "description": "This module manages associations between memory bases and byte-level offset intervals. It provides operations to iterate over, find, and fold through these associations, as well as to extract their structural shape. Concrete use cases include tracking memory layout information for analysis plugins, such as determining which memory regions are accessed or modified during program execution.",
      "description_length": 391,
      "index": 3236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Debug",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing debug configurations and integer parameters in a Frama-C plugin environment. It works with integer-based values (`t = int`) and range-constrained integers, offering functionality to set, retrieve, and validate values within specified bounds while supporting command-line interface integration and project state persistence. Specific use cases include enabling/disabling debug modes, configuring plugin behavior through CLI options, and ensuring parameter values adhere to predefined numeric ranges during analysis.",
      "description_length": 559,
      "index": 3237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module supports functional and structural manipulation of maps with keys based on struct-like values compared via structural equality, paired with arbitrary values. It provides ordered key traversal, transformations (e.g., filtering, mapping, partitioning), and utilities for sequence conversion, pretty-printing, and analysis-specific operations like field offset tracking. Designed for Frama-C plugins, it is particularly suited for static analysis tasks requiring precise management of C struct fields and offset-based mappings.",
      "description_length": 536,
      "index": 3238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables associated with emitters, providing standard operations like equality, comparison, hashing, and pretty printing. It works with emitter keys that may contain project-specific data, supporting deep copying and membership checks for project values. Concrete use cases include managing and querying emitter state within Frama-C plugins, such as tracking annotation sources or property statuses across different analysis runs.",
      "description_length": 475,
      "index": 3239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Share",
      "library": "frama-c.kernel",
      "description": "This module manages the plugin's share directory configuration, providing functions to set, retrieve, and check the directory path. It supports operations to locate specific files or subdirectories within the share directory, ensuring they exist and are of the correct type. These functions are used to access plugin-specific resources such as configuration files or auxiliary data during analysis.",
      "description_length": 398,
      "index": 3240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Action",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing boolean command-line options with on/off semantics, supporting state synchronization and change notifications. It operates on boolean values through a typed parameter interface, integrating with Frama-C's project state management and plugin architecture. Typical use cases involve configuring analysis features via CLI flags, such as enabling/disabling specific checks, with support for serialization and alias definitions to ensure consistent parameter handling across tools.",
      "description_length": 518,
      "index": 3241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidBool.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data handling with capabilities for deep copying, membership testing within projects, and representation through a list of values. Use cases include managing and comparing structured values in static analysis plugins, particularly for tracking and validating boolean expressions across different project contexts.",
      "description_length": 455,
      "index": 3242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_type_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and comparing logic types in the context of computing AST diffs. It provides operations for equality, comparison, hashing, and pretty-printing logic type values, along with utilities for deep copying and checking project membership. The module works with logic type descriptors and representants, supporting precise type analysis and diff computation in static analysis plugins.",
      "description_length": 426,
      "index": 3243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling a specific datatype used in the context of loading modules via the `-load-module` command-line option. It provides functionality for comparing, hashing, and pretty-printing values of type `t`, as well as checking membership within projects and performing deep copies. The module is used to manage and inspect loadable module data during plugin initialization and configuration.",
      "description_length": 421,
      "index": 3244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines hash table keys based on integer intervals with congruence, supporting operations such as equality, comparison, hashing, and pretty printing. It works directly with the `Int_interval` type, representing intervals via `min`, `max`, `rem`, and `modu`, and handles infinite bounds and modular constraints. Use cases include efficient key-based storage and retrieval of interval-based data in hash tables, particularly for static analysis tasks where interval properties must be preserved across transformations.",
      "description_length": 528,
      "index": 3245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for mappings where keys are logic variables (`Logic_var.t`) from CIL, supporting creation, insertion, lookup, deletion, and ordered iteration. It includes utilities for bulk updates from sequences, memoization, and default value handling, with data structures optimized for arbitrary value types paired with logic variable keys. Designed for static analysis, it addresses use cases like managing structural descriptions, type definitions, and program state tracking where logic variable keys require specialized equality or ordering behavior.",
      "description_length": 596,
      "index": 3246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports imperative hash tables keyed by CIL term l-values (`Term_lval.t`), offering operations like insertion, lookup, deletion, and folding, alongside advanced features such as in-place filtering, sequence-based initialization, and ordered iteration. It structures data manipulation for mappings between term l-values and arbitrary values, enabling efficient analysis of C code properties or transformation workflows in plugins. Use cases include tracking term-value associations during static analysis, memoizing computations over CIL terms, and managing structured key-value relationships with statistical insights.",
      "description_length": 631,
      "index": 3247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Value_int",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for integer values with support for parsing, comparison, hashing, and pretty-printing. It defines operations to convert integers to and from strings, check membership in projects, and create deep copies, ensuring proper handling of integer parameters in Frama-C's command-line interface. Use cases include defining and validating integer-based options for static analysis plugins.",
      "description_length": 424,
      "index": 3248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map",
      "library": "frama-c.kernel",
      "description": "This module supports insertion, deletion, merging, and ordered traversal of maps where keys represent control flow transitions in interpreted automata, each annotated with guards and actions. It works with structured key-value pairs where keys are edges (modeling CIL expressions or instructions) and values are arbitrary data, enabling precise association of metadata with program transitions. Its ordered iteration and customization features facilitate static analysis tasks like reachable state computation and program behavior modeling.",
      "description_length": 540,
      "index": 3249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module implements set-theoretic operations (union, intersection, difference) and structural transformations for collections of CIL field descriptors, which model struct/union members in C programs. It provides ordered set manipulations with comparison-based semantics, conversion utilities to/from sequences and lists, and specialized queries for field resolution in C abstract syntax trees. Typical applications include analyzing struct layout dependencies, optimizing field access patterns, or validating field existence during static analysis of C code.",
      "description_length": 561,
      "index": 3250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Keep_unused_types.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing structured type representations. It provides functions for equality, comparison, hashing, and pretty-printing, along with utilities for checking project membership and performing deep copies. The module is used to handle type descriptors in a way that supports analysis and transformation of C code within the Frama-C framework.",
      "description_length": 417,
      "index": 3251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set",
      "library": "frama-c.kernel",
      "description": "This module represents sets of control flow vertices in unrolled unnatural loops, providing operations for set manipulation, comparison, and project membership checks. It supports concrete use cases like tracking reachable states and managing transitions in abstract interpretation workflows. The data type works with control flow graphs where unnatural loops are normalized to ensure single-entry loop structures.",
      "description_length": 414,
      "index": 3252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that takes a boolean and a bottom monad, returning the same monad if the boolean is true, or a bottom value if false. It operates on the unit type wrapped in the bottom monad from the `Lattice_bounds.Bottom` module. A concrete use case is conditionally propagating lattice bottom values in static analysis based on boolean guards.",
      "description_length": 379,
      "index": 3253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Debug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for debugging and introspection within the kernel. It supports structured data representation through descriptors, packed descriptions, and a list of representative values, enabling precise type inspection and serialization. Use cases include deep copying of complex structures, checking membership within project hierarchies, and generating human-readable output for debugging purposes.",
      "description_length": 522,
      "index": 3254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on integer sets, supporting operations like equality, comparison, hashing, and pretty-printing. It works with data types including integer sets, project skeletons, and map structures, providing specific functionality for managing and querying these keys. Concrete use cases include efficiently storing and retrieving map entries associated with integer set keys, checking membership based on project conditions, and ensuring deep copies of keys for safe manipulation in different contexts.",
      "description_length": 550,
      "index": 3255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module implements maps with keys based on strictly equal CIL lvalues, enabling precise association management through operations like insertion, lookup, ordered traversal, and merging. It supports static analysis tasks requiring exact structural equivalence and strict constant comparison, such as tracking CIL expressions or values without redundancy, with utilities for filtering, folding, and deterministic iteration over key ranges.",
      "description_length": 441,
      "index": 3256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a finite map structure with keys representing CIL predicate identifiers and arbitrary data values, supporting standard associative operations like insertion, removal, and lookup, along with ordered traversal, filtering, and merging. It is designed for static analysis plugins to manage predicate-specific metadata, such as tracking analysis results or configuration settings across CIL projects, with efficient ordered key access and customizable serialization. The module also includes utilities for bidirectional iteration, project-based",
      "description_length": 562,
      "index": 3257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps with keys based on CIL variable information (`Varinfo.t`) and arbitrary value types, supporting operations like ordered traversal, merging, filtering, and bidirectional conversions to lists/sequences. It provides specialized functions for analyzing variable bindings in C programs, such as tracking variable properties during static analysis, managing hierarchical scopes, or transforming code structures with precise key ordering and customizable pretty-printing. The module is particularly useful for Frama-C plugins requiring precise variable-centric data flow analysis or structured manipulation of C abstract syntax trees.",
      "description_length": 675,
      "index": 3258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing file path configuration options in plugins, including value persistence, change notifications, and serialization. It works with `Frama_c_kernel.Filepath.t` values to handle tasks like resolving aliases and validating paths, while supporting typed parameter registration for plugin settings. Specific use cases include storing analysis input paths, output directories, or resource locations that require runtime modification and cross-plugin consistency checks.",
      "description_length": 505,
      "index": 3259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports creation, modification, and traversal of hash tables mapping CIL function keys (`Kf.t`) to arbitrary values, with operations like insertion, deletion, safe lookup, and both imperative and functional iteration. It extends functionality through ordered folding, sequence-based bulk updates, and memoization, leveraging structural typing and serialization for robust key management. Designed for Frama-C's CIL analysis framework, it facilitates tasks like tracking function-specific metadata during static analysis or caching computed results in plugin workflows.",
      "description_length": 581,
      "index": 3260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map",
      "library": "frama-c.kernel",
      "description": "This module provides map operations for 64-bit integer keys, including insertion, deletion, merging, and querying with optional values, alongside transformations like folding, filtering, and ordered iteration. It works with key-value structures where keys are `Int64` and values can be arbitrary types, supporting conversions to lists/sequences and pretty-printing. These capabilities are particularly useful in static analysis tasks requiring efficient management of large integer keys, such as tracking symbolic values or analysis states with precise key ordering and equality handling.",
      "description_length": 588,
      "index": 3261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Set",
      "library": "frama-c.kernel",
      "description": "This component provides ordered set operations for logic types, supporting union, intersection, difference, and ordered traversal. It works with sets of logical expressions (`Logic_type.t`), enabling efficient filtering, sequence conversion, and nearest-element queries in static analysis contexts. Use cases include managing logical constraints, transforming expression sets during program verification, and integrating ordered logic type processing with sequence-based algorithms.",
      "description_length": 482,
      "index": 3262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module enables creation, modification, and iteration over key-value stores with customizable ordering, supporting operations like insertion, deletion, folding, and sequence conversion. It works with hash tables where keys conform to a structured type `t` (or `key`) and values are polymorphic, offering utilities for sorted traversal, memoization, and context-aware management of plugin-specific data. Typical use cases include tracking analysis results in Frama-C plugins, memoizing stateful computations, and managing configurations with deterministic iteration over structured keys.",
      "description_length": 590,
      "index": 3263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing plugin configuration options represented as string lists, including value manipulation, change hooks, command-line integration, and serialization. It works with string lists and categorized parameter groups, enabling use cases like handling plugin-specific command-line arguments, validating input values, and persisting project-specific state across sessions.",
      "description_length": 405,
      "index": 3264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters for Frama-C kernel extensions, supporting operations to set and validate values, enforce allowed inputs, handle aliases, and integrate with the tool's state management system. It operates on parameterized string values representing loadable module options, ensuring valid C-style function names and tracking changes for use cases like module loading, user-configurable parameter constraints, and command-line argument processing with validation guarantees.",
      "description_length": 513,
      "index": 3265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.With_Cardinality",
      "library": "frama-c.kernel",
      "description": "This module extends maps with lattice structure by adding cardinality tracking and key summarization constraints. It provides operations to check if a map has zero or one element, safely extract singleton bindings, and verify cardinality limits, using a value-type cardinality function and a key summarization predicate. It is used to analyze or constrain maps where elements must be uniquely represented or bounded in count, such as tracking individual or merged memory states in static analysis.",
      "description_length": 497,
      "index": 3266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module provides map operations for associating data with kernel function sets (`Hptset.t`), supporting creation, modification, and querying with functional semantics (e.g., `add`, `remove`, `find`, `merge`). It includes ordered traversal, filtering, and transformation capabilities (like `fold`, `filter_map`, and `partition`), along with utilities for converting maps to ordered sequences or lists. These operations are optimized for scenarios requiring structured manipulation of kernel function metadata, such as static analysis or program transformation tasks where precise key-based associations and ordered iteration are critical.",
      "description_length": 641,
      "index": 3267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line parameters that associate string keys with multiple values, supporting operations to set, retrieve, and monitor changes to these associations. It works with map-like structures where keys are strings and values are lists of a specified type, incorporating category-based grouping, alias handling, and custom parsing/validation. It is designed for use cases requiring extensible configuration options with dynamic state tracking, such as analysis tools needing hierarchical or project-scoped settings.",
      "description_length": 542,
      "index": 3268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mapping CIL term constructs to arbitrary values, enabling creation, lookup, iteration, folding, and ordered traversal over keys, values, or entries. It supports deterministic processing of CIL terms in static analysis or transformation plugins, with memoization and safe key management to handle term-based mappings efficiently.",
      "description_length": 375,
      "index": 3269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Unicode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking the presence of project values. It supports structured data representation through a descriptor and a list of representatives, enabling introspection and serialization. Concrete use cases include managing and manipulating abstract data types in kernel extensions, such as analyzing or transforming program representations with Unicode support.",
      "description_length": 502,
      "index": 3270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepHeader.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing machine-dependent header information, supporting operations such as equality, comparison, hashing, and pretty printing. It works with structured descriptors, project skeletons, and lists of representants to manage and query type-specific metadata. Concrete use cases include inspecting and serializing machine-dependent data structures during kernel development and plugin execution.",
      "description_length": 432,
      "index": 3271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered finite maps using CIL term identifiers as keys, supporting insertion, deletion, and bulk transformations like mapping, filtering, and partitioning. It handles arbitrary value types with safe lookup variants and ordered traversal, suitable for static analysis tasks requiring term identifier tracking and ordered data aggregation. Functions for converting to sequences, pretty-printing, and structural queries further support analysis workflows in Frama-C.",
      "description_length": 486,
      "index": 3272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintReturn.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values related to the behavior of the `-print-return` option. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. The module is used to handle and query structured data values in the context of Frama-C's kernel, particularly for tracking and printing function return values during analysis.",
      "description_length": 459,
      "index": 3273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for managing mappings between source location-aware keys (`Localizable.t`) and arbitrary values, supporting creation, modification, iteration, and ordered traversal via custom comparison functions. It facilitates bulk updates from sequences, safe value retrieval with defaults or memoization, and integrates with project-scoped semantics for structured data handling. Key use cases include tracking position-dependent AST element associations during pretty-printing, maintaining ordered key-value relationships for analysis, and efficiently processing location-tagged data in Frama-C's typing and structural systems.",
      "description_length": 657,
      "index": 3274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing ordered collections of CIL function declarations (`Fundec.t`), supporting set-theoretic operations like union, intersection, and difference, as well as transformations (e.g., `map`, `filter`), ordered iteration, and membership queries. It maintains elements in a sorted order using a total ordering and enables efficient set manipulations, such as subset checks and element selection. Typical use cases include static analysis tasks requiring ordered traversal of functions, dependency resolution, or set-based dataflow analyses where function declarations must be processed in a specific sequence.",
      "description_length": 641,
      "index": 3275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter` for applying monadic actions to each element, `map` for transforming elements using monadic functions, and `fold_left` for accumulating values across a list using a monadic function. It operates on standard OCaml lists with elements of any type, sequencing monadic effects in the process. Concrete use cases include processing sequences of effectful computations, such as analyzing or transforming program elements in a static analysis context where each step may involve state or failure.",
      "description_length": 570,
      "index": 3276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables for mapping vertices from interpreted automata to polymorphic values, enabling efficient storage and retrieval of state-related data during abstract interpretation. It supports operations like keyed lookups, ordered iteration with custom comparisons, and sequence-based transformations, while integrating with Frama-C's structural type system for analysis plugins. Typical use cases include tracking reachable states, associating guards with transitions, or storing action metadata during program analysis.",
      "description_length": 541,
      "index": 3277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set",
      "library": "frama-c.kernel",
      "description": "This module implements command-line parameters for managing sets of strings with restricted valid options, supporting operations like element insertion, membership checks, and category-based validation. It provides structured handling of string collections through iteration, folding, and serialization mechanisms, while tracking state changes across Frama-C projects. Typical use cases include configuring plugin behaviors via whitelisted string values or defining extensible option sets with dynamic validation rules.",
      "description_length": 519,
      "index": 3278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued configuration parameters with change tracking, validation, and serialization capabilities. It operates on strings and string lists, supporting operations like value filtering, alias resolution, and project-specific state synchronization through `Project_skeleton.t`. Typical applications include kernel option configuration, plugin parameter validation, and runtime state observation with pre/post-update hooks.",
      "description_length": 445,
      "index": 3279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fundec.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing function declarations in the context of computing diffs between projects. It provides operations for equality checking, comparison, hashing, and pretty printing, as well as deep copying and project membership testing. The module is used to manipulate and analyze function declarations when tracking changes across different versions of a project.",
      "description_length": 394,
      "index": 3280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map.Make",
      "library": "frama-c.kernel",
      "description": "Implements a map structure with rational numbers as keys and values of a specified data type. Provides standard operations including comparison, hashing, pretty printing, and deep copying, along with project membership checks. Useful for managing and manipulating rational-number-indexed data in analysis plugins.",
      "description_length": 313,
      "index": 3281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_not_weak.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hashconsing table with strong references for a specific data type, ensuring stable equality and consistent hash values across runs. It provides operations for comparing, hashing, and pretty-printing values, along with deep copying and project membership checks. Suitable for managing structured data where referential integrity and exact reproducibility are critical, such as in static analysis state tracking.",
      "description_length": 435,
      "index": 3282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map structure where keys are CIL expressions compared using strict structural equality, including precise constant value checks. It provides standard map operations like insertion, deletion, lookup, and merging, along with ordered traversal, filtering, and conversion to/from lists, all enforcing key identity aligned with CIL semantics. Designed for static analysis plugins, it supports tasks requiring precise tracking of expression-based data, such as value analysis or dependency tracking, where strict key equivalence ensures accurate binding management.",
      "description_length": 596,
      "index": 3283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that represent integer intervals with congruence constraints, supporting operations such as equality, comparison, hashing, and pretty printing. It works directly with the `t` type, which encapsulates interval bounds and congruence parameters, including infinite ranges. It is used to manage and manipulate symbolic integer ranges in static analysis, such as tracking possible values of variables in program states.",
      "description_length": 454,
      "index": 3284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map with ordered keys for managing bindings of source code elements annotated with location information. It supports standard operations like insertion, deletion, and lookup, along with ordered traversal (e.g., `min_binding`, `max_binding`), merging, and filtering, while preserving key order during conversions to lists or sequences. It is specifically used in localized pretty-printing scenarios to handle AST elements with source locations, enabling precise binding iteration and customizable formatting of structured data.",
      "description_length": 563,
      "index": 3285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.ReadAnnot.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating annotation data during the parsing of Frama-C command-line options. It supports equality, comparison, hashing, and pretty-printing of annotation data, as well as deep copying and project membership checks. Use cases include handling and validating annotation inputs, inspecting parsed annotation structures, and ensuring correct data representation during option processing.",
      "description_length": 466,
      "index": 3286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic hash tables mapping CIL logic constructor metadata to arbitrary values, with operations for insertion, lookup, and deletion optimized for static analysis workflows. It supports ordered traversal and value memoization, enabling use cases like caching computed properties of logic constructors or processing key-sorted sequences during CIL-based program verification. The structures are particularly suited for analysis plugins requiring deterministic iteration over logic constructor hierarchies.",
      "description_length": 530,
      "index": 3287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative collections with type-safe normalized filepaths as keys, supporting operations like ordered key-value association, list accumulation, and custom value merging. It provides ordered finite maps with safe lookup semantics, enabling functional programming patterns such as folding, filtering, and ordered traversal over arbitrary value types. Typical applications include configuration management and file metadata tracking where robust path handling and predictable key ordering are critical.",
      "description_length": 524,
      "index": 3288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of structurally equivalent CIL predicates, supporting operations like union, intersection, difference, and nearest-element queries using a total ordering. It provides efficient membership checks, ordered traversal, and transformations while maintaining uniqueness based on structural equality of predicate elements. Typical use cases involve static analysis tasks requiring precise set-theoretic manipulation of CIL predicates, such as verifying code properties or managing equivalence classes during program transformation.",
      "description_length": 560,
      "index": 3289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Performs backward dataflow analysis on control flow graphs with unnatural loops normalized to enter only through loop heads. It processes interpreted automata by propagating dataflow information in reverse order over the graph, using a given domain module `D` to represent and manipulate dataflow facts. This supports precise analysis of program properties that depend on post-dominator structure, such as liveness or backward reaching definitions.",
      "description_length": 448,
      "index": 3290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Varinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing variable information in the context of AST differencing. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, which encapsulate variable metadata used during diff computation. The module supports deep copying, membership checks over projects, and integrates with Frama-C's type and descriptor system for structural manipulation and analysis.",
      "description_length": 463,
      "index": 3291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations tailored for memory location zones, enabling insertion, lookup, and removal of entries mapping memory ranges to values, along with bulk transformations and ordered iteration using customizable key comparisons. It supports Frama-C plugin development for memory analysis tasks such as tracking dynamic memory states, managing region-based data structures, and optimizing static analysis through efficient zone-centric lookups and memoization.",
      "description_length": 483,
      "index": 3292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLibc.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values used in the printing of C library functions. It includes functions for equality checks, comparison, hashing, pretty-printing, and deep copying, as well as support for project membership testing. The module is used to handle the internal representation of data when implementing the `-print-libc` option, ensuring accurate and consistent output formatting and data manipulation.",
      "description_length": 476,
      "index": 3293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_array.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic array datatype from a given element module `T`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with arrays of a fixed, user-specified type and includes functionality for deep copying values and checking project membership. Concrete use cases include defining and manipulating arrays of abstract values, expressions, or statements in static analysis plugins.",
      "description_length": 456,
      "index": 3294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps keyed by CIL term-based memory location identifiers (`Term_lhost.t`), enabling precise insertion, lookup, and ordered traversal while supporting transformations like `map`, `filter_map`, and `partition`. It maintains strict key ordering for operations such as `find_first_opt`, `split`, and `to_seq`, and provides utilities for merging, comparing, and converting maps with term-indexed bindings. These capabilities are particularly valuable in static analysis plugins for tasks like tracking term-labeled program states, aggregating memory location data, and processing CIL constructs in deterministic order.",
      "description_length": 644,
      "index": 3295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Float_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float reference data type with operations for equality, comparison, hashing, and pretty-printing. It supports state management by providing deep copy and project membership checks. Use it to build and manipulate numeric state variables in static analysis plugins.",
      "description_length": 285,
      "index": 3296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for associating logic info keys with arbitrary values, supporting standard manipulations like insertion, deletion, and lookup, along with ordered traversal, aggregation, and transformations such as filtering or partitioning. It is designed for static analysis tasks in CIL-based tools, enabling structured handling of logic-related data through key ordering, bulk construction from sequences, and operations that maintain or compare map bindings. Use cases include managing analysis results or logic annotations where ordered key relationships and efficient data aggregation are critical.",
      "description_length": 632,
      "index": 3297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling integer references within Frama-C's state management system. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage integer state values in a way that supports persistence and comparison across different analysis states.",
      "description_length": 379,
      "index": 3298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsInitialized.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values related to the behavior of the `-asm-contracts-ensure-init` option. It provides functions for equality, comparison, hashing, pretty-printing, deep copying, and checking membership of project values within these data structures. Use cases include managing and querying initialization states of assembly contracts in static analysis plugins.",
      "description_length": 442,
      "index": 3299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a functional map structure for integer keys and arbitrary values, supporting efficient key-value manipulation through insertion, deletion, merging, and ordered traversal. It provides persistent operations that preserve immutability, with features like predicate-based filtering, ordered iteration, and customizable serialization, making it suitable for managing hierarchical or sparse integer-indexed data. Use cases include symbol table management, configuration mapping, and scenarios requiring versioned state tracking with minimal overhead.",
      "description_length": 567,
      "index": 3300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fieldinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing field information in the context of computing AST differences. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to track and manipulate structural differences between fields in C abstract syntax trees.",
      "description_length": 360,
      "index": 3301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent, ordered set structure for `Model_info.t` elements, supporting efficient union, intersection, difference, and ordered traversal operations. It provides transformation utilities like `map`, `filter`, and sequence conversions, alongside structural queries for membership, subsetting, and nearest-element searches. Designed for static analysis tasks, it facilitates managing hierarchical or scoped CIL model data where structural integrity and efficient set manipulation are critical, such as tracking variable dependencies or analysis artifacts.",
      "description_length": 579,
      "index": 3302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, providing operations for equality, comparison, hashing, and pretty-printing. It works with a specific key type that includes metadata like name, descriptor, and project membership checks. Concrete use cases include managing and comparing keys in a type-safe manner within a hashtable structure, particularly for project-specific data.",
      "description_length": 388,
      "index": 3303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a control flow graph where each edge connects two vertices and carries a label containing versioned automaton data. It provides operations to create edges, retrieve source and destination vertices, and access edge labels, ensuring edges are ordered and comparable. Concrete use cases include modeling transitions in an abstract interpretation framework, where edges represent control flow paths modified to handle unnatural loops uniformly.",
      "description_length": 481,
      "index": 3304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing associations between edges in an interpreted automaton and arbitrary values, enabling efficient key-based access, structural traversal, and value memoization. It works with edges representing control flow transitions that carry guards and actions, supporting use cases like tracking state transitions during abstract interpretation or caching computed properties of automaton paths. The implementation includes specialized iteration, folding, and filtering capabilities to handle edge-keyed data in both operational and collection semantics contexts.",
      "description_length": 606,
      "index": 3305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line module loading, supporting operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with types like `t` representing categories and `elt` for category elements, along with accessors and states for dependencies. Concrete use cases include configuring how modules are grouped and activated through command-line options like `-load-module`, enabling selective or global module loading behavior.",
      "description_length": 484,
      "index": 3306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Set",
      "library": "frama-c.kernel",
      "description": "This module provides persistent immutable sets of ordered elements with operations for creation, modification (union, intersection, difference), and querying (membership, cardinality, extremal elements). It supports ordered traversal, filtering, mapping, and conversion to/from sequences, along with specialized operations for finding nearest elements and deep copying. Designed for use cases requiring efficient set algebra and ordered element manipulation in static analysis tasks, such as tracking program states or variable dependencies.",
      "description_length": 541,
      "index": 3307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for CIL labels, supporting efficient membership tests, set algebra (union, intersection, difference), and ordered traversals. It handles sets of `Label.t` values\u2014representing CIL control-flow labels\u2014with specialized functions for analysis tasks like tracking label propagation in static analysis or verifying program properties. Use cases include managing label dependencies during data-flow analysis and implementing label-based transformations in Frama-C plugins.",
      "description_length": 511,
      "index": 3308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map",
      "library": "frama-c.kernel",
      "description": "This module implements maps with integer keys (`Integer.t`) and arbitrary values, offering associative operations like insertion, deletion, and merging, along with transformations, filtering, and ordered iteration. It maintains key order and optimizes efficiency through immutability and physical equality reuse, supporting use cases in static analysis where integer keys model program elements like variable identifiers or control-flow points. Features such as merging, splitting, and customizable pretty-printing facilitate data aggregation and debugging in analysis tools.",
      "description_length": 575,
      "index": 3309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Enums.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating a specific datatype used in the analysis of C code, particularly in handling enumeration types. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, as well as utilities to inspect and traverse project-related data embedded within values. Concrete use cases include analyzing and transforming enum values during static analysis, ensuring correct handling of project-specific data, and supporting serialization through descriptors.",
      "description_length": 537,
      "index": 3310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.False",
      "library": "frama-c.kernel",
      "description": "This module manages boolean configuration options within Frama-C's plugin system, enabling state manipulation through `on`/`off` controls, change notifications, and command-line interface integration. It operates on a boolean type (`type t = bool`) and supports serialization for persistent state management. Typical use cases include toggling plugin features via command-line flags or GUI elements, with hooks to trigger actions when values change.",
      "description_length": 449,
      "index": 3311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific state directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing plugins to store and access persistent data. Concrete use cases include saving plugin-generated files or caching analysis results in a dedicated directory.",
      "description_length": 364,
      "index": 3312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally executes a state monad computation based on a boolean value. It works with the `unit t` type representing stateful computations without a return value. A concrete use case is to conditionally trigger state updates in analyses that track program properties, such as enabling debug output or logging based on a flag.",
      "description_length": 382,
      "index": 3313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for creating and manipulating immutable ordered sets, supporting set algebra (union, intersection, difference), ordered traversal, predicate-based filtering, and transformations like mapping and partitioning. It works with sets of elements of a type that must be ordered via a comparator, enabling efficient membership checks, nearest-element queries, and conversions to sequences, lists, or arrays. It is particularly useful in static analysis tasks requiring precise set operations over ordered data, such as tracking program states, managing dependencies, or integrating with lattice-based analyses where set-valued mappings are needed.",
      "description_length": 671,
      "index": 3314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset",
      "library": "frama-c.kernel",
      "description": "This module provides set-theoretic operations and cache-aware transformations for managing collections of CIL variable descriptors (`varinfo`), using specialized data structures like ordered sets, maps, and hash tables. It supports efficient union, intersection, difference, and membership queries, along with higher-order functions for folding, filtering, and custom merging of variable metadata. These capabilities are particularly useful in static analysis plugins for tracking variable properties, analyzing dependencies, or synthesizing information across program paths.",
      "description_length": 575,
      "index": 3315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Set",
      "library": "frama-c.kernel",
      "description": "This module implements purely functional sets using hash-consed big-endian Patricia trees, supporting ordered element traversal and efficient operations like union, intersection, and membership tests. It provides utilities for conversion between sets and sequences, nearest-neighbor searches, and predicate-based filtering, all leveraging a user-defined comparator for ordering. These structures are optimized for static analysis tasks requiring compositional tracking of program elements with guaranteed structural consistency and fast associative queries.",
      "description_length": 557,
      "index": 3316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines custom operators for composing and manipulating computations within a lattice structure that explicitly handles bottom values. It provides bind and map operations for sequencing lattice computations, pairing values, and applying functions within this context. These operators are used to implement precise static analysis logic where bottom represents an undefined or error state.",
      "description_length": 400,
      "index": 3317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines custom infix operators for sequencing and combining computations within a lattice structure that explicitly handles top values. It provides bind and map operations for working with lattice-embedded values, enabling concise expression chaining and tuple construction. These operators are used to manipulate abstract values in static analysis contexts where top represents an extremal state.",
      "description_length": 409,
      "index": 3318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable ordered set structure with operations for element insertion, deletion, and membership checks, along with set-theoretic operations like union, intersection, and difference. It organizes elements of a polymorphic type according to a comparator, supporting ordered traversal, filtering, and transformations that preserve sorted invariants. Typical applications include managing hierarchical or versioned data with strict ordering constraints, analyzing program states with monotonic properties, and bridging set operations with sequence-based algorithms through reversible conversions and nearest-neighbor queries.",
      "description_length": 647,
      "index": 3319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string sets with functionalities like adding elements, checking membership, iteration, folding, and emptiness checks. It supports type-safe string set parameters with aliases, default values, and command-line visibility, while integrating serialization and project-specific state management. Use cases include configuring Frama-C plugins via command-line options, maintaining dynamic parameter states, and handling categorized string-based settings.",
      "description_length": 494,
      "index": 3320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table structure where keys are integer abstractions and values are of a specified data type. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage and manipulate abstract integer-keyed data tables in static analysis plugins.",
      "description_length": 368,
      "index": 3321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `User_dir` by extending an existing directory path. It provides `get_dir` and `get_file` functions to retrieve subdirectories or files, optionally creating the path if it doesn't exist. It works directly with `Frama_c_kernel.Filepath.t` values, handling path resolution and validation. Use this when building custom command-line options that require structured directory layouts, such as plugin-specific output directories or configuration paths.",
      "description_length": 471,
      "index": 3322,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath",
      "library": "frama-c.kernel",
      "description": "This module enables management of command-line file path options for plugins, supporting operations like parsing, validation, default value assignment, and state change hooks. It works with file path parameters enriched with metadata for help messages and project-specific state tracking, allowing checks for emptiness or validity. Typical use cases include configuring input/output paths in plugins, ensuring robust handling of file operations with customizable validation and serialization.",
      "description_length": 492,
      "index": 3323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing file-specific C preprocessor arguments in the kernel. It supports equality checks, comparison, hashing, and pretty-printing for values representing argument configurations. It is used to handle per-file customization of preprocessor options during analysis.",
      "description_length": 317,
      "index": 3324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for associating arbitrary data with CIL types under structural equivalence, where keys are compared by unrolled typedefs and structural equality. It supports insertion, deletion, merging, and ordered traversal (e.g., min/max bindings, splitting), alongside transformations (map, filter), bulk operations (union, intersection), and conversions to sequences or lists. Designed for CIL analyses requiring type-indexed metadata management, it enables tasks like tracking type-specific properties, grouping related types, or implementing structural type-based optimizations.",
      "description_length": 613,
      "index": 3325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module supports imperative set-like manipulation of function declarations (`Fundec.t`) via command-line options, offering operations like `add`, `mem`, `fold`, and `iter` to manage and query persistent sets. It integrates string-based parameter parsing and categorization for configuration, enabling validation, alias resolution, and grouped option handling. Designed for static analysis workflows, it tracks project-specific state and reacts to dynamic changes in function set definitions, such as when filtering targets or grouping analysis scopes.",
      "description_length": 555,
      "index": 3326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set structure for logic information elements with structural comparison, enabling efficient, immutable operations like union, intersection, filtering, and transformation. It supports functional workflows through iteration, mapping, and predicate-based queries, tailored for static analysis tasks such as tracking logic properties or verifying constraints in CIL code. Integration features like deep copying and type descriptors facilitate use in plugin development for custom analysis extensions, including tasks like constraint solving or program transformation validation.",
      "description_length": 599,
      "index": 3327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure, including equality, comparison, hashing, and pretty-printing functions. It supports working with emitter-related data by providing deep copying, membership checks for project values, and type descriptors for integration with Frama-C's internal systems. Concrete use cases include managing and comparing unique emitter keys within static analysis plugins.",
      "description_length": 435,
      "index": 3328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to the `option` type, providing `iter` and `map` operations that integrate monadic effects with optional values. It works directly with `'a option` and monadic actions of type `'a t`, enabling sequencing of computations that may fail or produce optional results. Concrete use cases include handling optional data in a monadic context, such as safely processing values that may be absent while carrying monadic side effects.",
      "description_length": 461,
      "index": 3329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mapping CIL term identifiers (`Identified_term.t`) to arbitrary values, supporting insertion, deletion, lookup, and deterministic iteration via customizable key comparisons. It enables functional and imperative manipulation patterns, including safe value retrieval, memoization, and folding over keys, values, or entries, with utilities for ordered traversal and sequence conversion. Designed for static analysis workflows, it integrates with Frama-C's structural type system to manage term metadata in deterministic contexts, such as tracking analysis results or intermediate representations.",
      "description_length": 640,
      "index": 3330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for managing key-value pairs with keys drawn from an ordered set type. It supports efficient lookups, in-place modifications (insertions, deletions, updates), and ordered traversal over entries sorted by keys, values, or key-value pairs. These capabilities are particularly useful for memoizing function results, maintaining dynamic mappings, or implementing stateful analyses in Frama-C plugins where mutable storage and ordered iteration are required.",
      "description_length": 507,
      "index": 3331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mapping CIL term offsets (with built-in comparison, hashing, and pretty-printing) to arbitrary values, supporting creation, modification, ordered iteration, and safe access via utilities like `find_opt`, `memo`, and `fold_sorted`. The data structures are designed for static analysis tasks that require efficient organization of structured C code data, such as caching analysis results or associating metadata with specific term offsets. Sequence-based initialization (`of_seq`) and ordered traversal capabilities further enable processing of CIL term hierarchies during compiler analyses.",
      "description_length": 636,
      "index": 3332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized set structure for managing collections of CIL code annotations, offering operations like union, intersection, difference, and subset checks while preserving ordering. It supports transformations, filtering, and iteration over sets of annotations, with utilities for sequence conversion, nearest element queries, and integration with Frama-C's plugin system via type descriptors. Designed for static analysis tasks, it enables efficient handling of annotation metadata in code transformation or verification workflows.",
      "description_length": 554,
      "index": 3333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for associating vertices from an interpreted automaton with arbitrary values, supporting efficient functional operations like insertion, deletion, merging, and ordered traversal. It works with keys of type `Vertex.t`, which represent control points in a program's abstracted control flow graph, and values that encode analysis metadata, state properties, or transition effects. The module facilitates tasks like control flow analysis, state tracking during abstract interpretation, and manipulation of vertex-labeled data in semantic-preserving program transformations.",
      "description_length": 625,
      "index": 3334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Enum",
      "library": "frama-c.kernel",
      "description": "This module enables defining command-line options with a fixed set of allowed values (enumerations), supporting operations to set, retrieve, and monitor changes to these values, along with alias handling and serialization. It operates on a variant type `t` with structural equality, requiring `all_values` and `to_string` functions to enumerate possible values and convert them to strings. This functionality is used in Frama-C for configuring analysis settings with predefined choices, ensuring consistent state management and persistence through the project system.",
      "description_length": 567,
      "index": 3335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored to handle normalized filepaths in conjunction with project-specific data. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to uniquely identify and manage filepath-based keys within analysis plugins, ensuring correct handling across different projects and sessions.",
      "description_length": 460,
      "index": 3336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, providing operations for equality, comparison, hashing, and pretty-printing. It supports data types that can be stored as keys, including structured types with embedded project information. Use cases include managing unique identifiers or structured keys in a hash table while ensuring deep copying and proper comparison semantics.",
      "description_length": 385,
      "index": 3337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify typed parameters, primarily used for managing command-line options in the Frama-C kernel. It provides standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include tracking and comparing parameter values across different projects and ensuring consistent key handling in map structures.",
      "description_length": 448,
      "index": 3338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for logic variables, including union, intersection, difference, and transformations like mapping or filtering, while maintaining sorted uniqueness via `Ord.compare`. It supports efficient conversions between sets, lists, and sequences, with utilities for nearest-element queries, hashing, and pretty-printing, optimized for static analysis tasks requiring precise variable set manipulations in CIL-based program analysis. Safe and unsafe element retrieval variants, along with performance-tuned bulk operations like `of_list`, cater to scenarios demanding both correctness and efficiency in analysis plugins.",
      "description_length": 650,
      "index": 3339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter`, `map`, and `fold_left`, where each function applies a monadic effect to elements of a list. It operates on lists of values within a monadic context, allowing sequential composition of effects across list elements. Concrete use cases include processing lists of computations that may fail, accumulate state, or interact with external environments, such as parsing sequences or validating collections of inputs.",
      "description_length": 491,
      "index": 3340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdep.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing machine-dependent printing behaviors, primarily used to manage and query specific configurations of the `-print-machdep` option. It supports operations such as equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. Use cases include inspecting and manipulating machine-dependent print settings during analysis or plugin development.",
      "description_length": 443,
      "index": 3341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables using logic type information as keys to associate with arbitrary values, supporting standard operations like creation, insertion, lookup, deletion, iteration, folding, and sequence conversion. It includes specialized tools for ordered traversal, in-place filtering, and safe value retrieval, primarily serving static analysis plugins that require efficient management of logic variables and typed expressions during program analysis tasks involving key-based access and structured processing.",
      "description_length": 538,
      "index": 3342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Set",
      "library": "frama-c.kernel",
      "description": "This module supports creation and manipulation of ordered sets containing project state elements, enabling operations like union, intersection, difference, and element selection while maintaining deterministic behavior through total ordering. It provides utilities for transforming sets to and from sequences, filtering based on predicates, and performing membership checks with project-specific equality semantics. These structures are particularly useful for analyzing or comparing Frama-C's internal computation states across different AST-derived projects.",
      "description_length": 560,
      "index": 3343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables that store project-compliant mutable values. It provides standard operations including equality, comparison, hashing, and pretty printing for these keys, along with functions to check project membership and perform deep copies. It is used to manage and manipulate keys that uniquely identify entries in state-aware hash tables tied to specific Frama-C project contexts.",
      "description_length": 423,
      "index": 3344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with rational keys, offering operations like insertion, lookup, deletion, and ordered iteration. It manages mappings from rational numbers (`Frama_c_kernel.Datatype.Rational.t`) to arbitrary values, supporting imperative updates, functional transformations, and bulk operations from sequences. Designed for Frama-C's static analysis framework, it enables efficient handling of numerical key-value associations in tasks like symbolic value tracking or constraint propagation during program analysis.",
      "description_length": 533,
      "index": 3345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTOIndex",
      "library": "frama-c.kernel",
      "description": "This module computes and compares weak topological order (WTO) indices of vertices in an interpreted automaton. It provides operations to build and manipulate WTO index tables, which map vertices to their positions in the control flow hierarchy, enabling efficient analysis of loop structures and control dependencies. The module is used to detect changes in control flow components during abstract interpretation, such as when analyzing loop iterations or conditional branches in C code.",
      "description_length": 488,
      "index": 3346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_ref",
      "library": "frama-c.kernel",
      "description": "This module supports creating and managing monomorphic type instances from polymorphic types, providing operations to instantiate, identify, and retrieve type parameters. It works with type values and polymorphic data structures, particularly for static analysis tasks requiring precise type handling. Concrete use cases include defining typed lists, options, or custom structures with associated type metadata for Frama-C plugins.",
      "description_length": 431,
      "index": 3347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_array",
      "library": "frama-c.kernel",
      "description": "This module provides functions to create and manipulate monomorphic array datatypes by instantiating polymorphic type definitions with specific element types. It supports operations for checking type instantiation relationships and retrieving the element type used in an array's construction. Concrete use cases include defining arrays of abstract values, expressions, or statements in static analysis plugins, with support for equality, comparison, hashing, and pretty-printing through the `Make` functor.",
      "description_length": 506,
      "index": 3348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.String_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table indexed by strings, where each binding associates a string key with a typed value. It supports operations to create, add, and retrieve bindings, as well as iterate and fold over the table's contents. The module is used to manage dynamically typed values under string keys, particularly when working with type-indexed information in Frama-C plugins.",
      "description_length": 398,
      "index": 3349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.Simple_backward",
      "library": "frama-c.kernel",
      "description": "Implements backward data flow analysis by computing pre-states and post-states for statements based on a given domain. Provides operations to retrieve the state before (`pre_state`) and after (`post_state`) a statement, with `pre_state` derived by applying `transfer_stmt` to the post-state. Offers `fold_on_result` and `iter_on_result` to traverse the computed post-states of all reachable statements starting from `P.init`.",
      "description_length": 425,
      "index": 3350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for integer values with operations including equality, comparison, hashing, and pretty-printing. It provides utilities for managing integer sets, maps, and hash tables through its submodules, enabling precise handling of integer-based data structures. Use cases include static analysis tasks such as tracking variable states, managing symbol tables, and performing efficient integer-keyed lookups.",
      "description_length": 428,
      "index": 3351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and comparison operations for CIL lvalues, enabling precise handling of left-hand side expressions in C code analysis. It provides core functionalities including equality checking, hashing, deep copying, and pretty printing, specifically tailored for lvalue structures. These operations are essential for tasks like tracking memory locations, managing variable dependencies, and implementing analysis plugins that require structural identity of expressions.",
      "description_length": 497,
      "index": 3352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Predicate",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL predicates, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership within projects, deep copy predicate values, and manage type descriptors for structured data handling. Use cases include analyzing and transforming C code assertions during static analysis with Frama-C plugins.",
      "description_length": 378,
      "index": 3353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Caml_weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table for a specific data type, ensuring values are automatically reclaimed when no longer referenced. It provides standard operations like equality, comparison, hashing, and pretty-printing, tailored to the data type's structure. This is useful for managing large or transient values where memory retention is undesirable, such as caching intermediate analysis results in static code analysis.",
      "description_length": 417,
      "index": 3354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a functional map structure with integer sets as keys and arbitrary values, supporting operations like insertion, deletion, ordered traversal, and merging. It provides transformations through filtering, mapping, and partitioning, alongside utilities for sequence-based construction and structured output formatting. Designed for static analysis scenarios, it efficiently handles interval-based representations and hierarchical data modeling where ordered key processing and precise set operations are critical.",
      "description_length": 532,
      "index": 3355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and strict constant comparison for CIL expressions, providing core operations like `equal`, `compare`, `hash`, and `copy` for precise identity checks. It supports use cases such as static analysis and code transformation where exact expression equivalence is required, including tracking dependencies, canonicalizing expressions, and memoizing analysis results. The module also includes Set, Map, and Hashtbl submodules for efficient collection management based on this strict expression identity.",
      "description_length": 537,
      "index": 3356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and comparison operations for CIL offset types, enabling precise manipulation of struct field offsets in C code analysis. It provides core utilities including equality checks, hashing, deep copying, and pretty-printing, specifically tailored for analyzing and transforming C structures. The associated Set, Map, and Hashtbl submodules offer efficient, structure-aware collections for tracking and querying offset-based data in static analysis plugins.",
      "description_length": 491,
      "index": 3357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict",
      "library": "frama-c.kernel",
      "description": "This module implements strict comparison semantics for CIL constants, where equality and ordering consider textual representations when present. It provides core operations like `equal`, `compare`, and `hash` for values of type `constant`, along with utilities for deep copying, pretty printing, and project membership testing. The associated `Set`, `Map`, and `Hashtbl` modules enable precise set manipulation, key-based lookups, and hash-based associations tailored for static analysis tasks requiring exact constant representation tracking.",
      "description_length": 543,
      "index": 3358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map",
      "library": "frama-c.kernel",
      "description": "This module creates a comparable data type with fully ordered semantics, providing core operations like `equal`, `compare`, and `hash` for type `t`. It includes dedicated `Set` and `Map` modules for managing ordered collections and key-value associations, optimized for static analysis tasks requiring precise data tracking and transformation. Concrete use cases include modeling program states, analyzing value ranges, and structuring relationships between program elements with strong ordering guarantees.",
      "description_length": 507,
      "index": 3359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a rich set of map manipulation functions for polymorphic key-value stores with ordered keys, supporting operations like insertion, removal, merging, and functional transformations over bindings. It works with structured map types built from a customizable `Key` module, enabling safe lookups, ordered traversal, and serialization, while offering utilities for list- or sequence-based construction and pretty-printing. It is particularly suited for static analysis plugins requiring precise handling of program element relationships, such as tracking variable dependencies or aggregating analysis results with custom key semantics.",
      "description_length": 651,
      "index": 3360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo",
      "library": "frama-c.kernel",
      "description": "This module implements structural operations for CIL field descriptors, which represent struct/union members in C programs. It provides equality, comparison, hashing, deep copy, and pretty-printing functions for fieldinfo values, along with set-theoretic operations, map transformations, and hash table utilities tailored to static analysis tasks. Concrete use cases include resolving field dependencies, validating struct layouts, and tracking field-specific properties across C abstract syntax trees.",
      "description_length": 502,
      "index": 3361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecMode",
      "library": "frama-c.kernel",
      "description": "This module manages the behavior of a string-based command-line option controlling specification generation modes, offering operations to set, retrieve, and validate allowed values while supporting project-specific state management. It works with string parameters representing specification modes, enabling use cases like restricting valid inputs to predefined values, handling function-specific aliases, and synchronizing state changes across modules through hooks. The module also facilitates serialization and comparison of mode values, ensuring consistency during project loading or option updates.",
      "description_length": 603,
      "index": 3362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.Dot",
      "library": "frama-c.kernel",
      "description": "This module generates a Dot representation of the state dependency graph, writing it to a specified file path. It operates on the internal state dependency structures maintained by the analysis kernel. Use this module to visualize dependencies between states in the analysis, such as for debugging or reporting.",
      "description_length": 311,
      "index": 3363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintReturn",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls whether function return values are printed during static analysis. It provides state manipulation operations (enable/disable), change notifications, and serialization integration for project-specific persistence. The core `t` type tracks option state while supporting marshaling and alias handling for seamless interaction with Frama-C's project system and command-line interface.",
      "description_length": 443,
      "index": 3364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL global annotations, including equality, comparison, hashing, and pretty-printing. It provides direct access to annotation attributes and source locations, along with deep copying and project membership checks. Concrete use cases include analyzing and transforming C code annotations during static analysis or compiler passes.",
      "description_length": 373,
      "index": 3365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module supports operations to manipulate, query, and extend sets of kernel functions, including membership checks, iteration, folding, and dynamic updates with alias management, alongside hooks for change notifications and serialization. It incorporates specialized submodules for string-based configuration validation and category-driven grouping to organize functions and track state changes. These capabilities are tailored for static analysis workflows requiring adaptable, persistent management of function sets during program analysis.",
      "description_length": 546,
      "index": 3366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This implementation provides a specialized hash table structure for managing associations between Frama-C emitters and arbitrary values, supporting imperative operations like insertion, lookup, and in-place updates alongside higher-order transformations such as filtered iteration and key-ordered folding. It facilitates efficient tracking of emitter-specific data, such as annotation metadata or analysis results, while enabling safe key management and structured manipulation of emitter-value mappings. Typical use cases include caching computation results per emitter or maintaining dynamic state during property verification workflows.",
      "description_length": 639,
      "index": 3367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean datatype with standard operations including equality, comparison, hashing, and pretty-printing. It provides utilities for managing boolean values in static analysis contexts, such as deep copying, membership testing within projects, and handling representable values. The module supports precise set manipulation, mapping, and hash table operations tailored for boolean states in formal verification tasks.",
      "description_length": 436,
      "index": 3368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditPrepare",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a file path option, including setting, retrieving, and monitoring changes, with support for update hooks, custom marshaling, and project-specific persistence. It works with a file path structure to store registered paths and utilizes a datatype module for state tracking and persistence control. Specific use cases include validating configuration by checking if the file path structure is empty or handling dynamic updates to the option's value during analysis.",
      "description_length": 504,
      "index": 3369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations (add, remove, find, mem, iter, fold) tailored for keys representing command-line-configurable parameters (Typed_parameter.t), including bulk sequence operations",
      "description_length": 214,
      "index": 3370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating declaration elements in the AST, including equality checks, comparison, hashing, deep copying, and pretty printing. It works with `Declaration.t` values, which represent structured declarations in the source code, and supports project membership queries. Concrete use cases include tracking and analyzing individual AST nodes during source code processing, enabling precise declaration handling in Frama-C's analysis and transformation pipelines.",
      "description_length": 507,
      "index": 3371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Exp",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to construct and manipulate expressions for arithmetic, logical, and memory operations in CIL's abstract syntax, including constants, variables, lvalues, and control-flow labels like `here` or `loop_entry`. It operates on CIL expressions (`exp`), l-values (`lval`), and types, supporting pointer arithmetic, field access, casting, and initializer combinators. These capabilities are used in static analysis to model program behavior, verify properties via ACSL annotations, and build intermediate representations for Frama-C plugins.",
      "description_length": 564,
      "index": 3372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName",
      "library": "frama-c.kernel",
      "description": "This module defines a type `t` representing CIL types with structural comparison based on type names without unrolling. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying, membership checks over projects, and type descriptor handling. The associated `Set`, `Map`, and `Hashtbl` modules enable efficient set and associative map manipulations tailored for static analysis tasks such as tracking type dependencies and managing type-based metadata in C programs.",
      "description_length": 525,
      "index": 3373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Check",
      "library": "frama-c.kernel",
      "description": "This module provides functionality to manage a boolean kernel option that controls checking behavior, including setting and retrieving values, defining state change hooks, and handling aliases and serialization. It operates on a boolean state with dynamic updates and project-specific configuration, supporting introspection and persistent state management. This enables developers to toggle analysis-time checks and maintain context-dependent settings across sessions.",
      "description_length": 469,
      "index": 3374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InlineStmtContracts",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls inlining of statement contracts, offering operations to set, retrieve, and monitor changes to its state. It works with kernel-level data structures for option parsing, project-specific state tracking, and custom marshaling, ensuring consistency across projects. The functionality is used to dynamically enable or disable contract inlining behavior during static analysis, supporting plugin developers in controlling how contracts are processed.",
      "description_length": 509,
      "index": 3375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval",
      "library": "frama-c.kernel",
      "description": "This module implements operations for handling CIL term l-values, including equality checks, comparison, deep copying, and pretty-printing. It provides structured management of term l-values through associated Set, Map, and Hashtbl modules, enabling efficient set-theoretic operations, keyed associations, and hash-based lookups. Use cases include tracking memory locations during static analysis, modeling data flow dependencies, and verifying C program properties by analyzing term l-value relationships.",
      "description_length": 506,
      "index": 3376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing kernel function descriptors (`Kf.t`), including equality, comparison, hashing, pretty printing, deep copying, and project membership checks. It provides direct access to function identifiers and variable information, and supports structured data manipulation through dedicated `Set`, `Map`, and `Hashtbl` submodules tailored for static analysis tasks. These features enable precise tracking, transformation, and querying of CIL function data during program analysis.",
      "description_length": 510,
      "index": 3377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL term identifiers, including equality, comparison, hashing, and pretty-printing. It supports data types representing CIL terms with structural descriptors and provides deep copying and project membership checks. Concrete use cases include static analysis tasks that require precise term manipulation, such as tracking term occurrences, performing term-based data-flow analysis, and managing term metadata across analysis passes.",
      "description_length": 475,
      "index": 3378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of memory zone descriptors with efficient membership, combination, and transformation operations. It works with immutable sets containing `Frama_c_kernel.Base.t` elements, which represent addressable memory regions, and leverages their total ordering for optimized queries like nearest-neighbor searches and range-based splits. Typical use cases include static analysis tasks that require tracking disjoint memory regions, validating memory accesses, or performing lattice operations over abstract memory states where ordered set semantics enable efficient fixpoint computations.",
      "description_length": 615,
      "index": 3379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant",
      "library": "frama-c.kernel",
      "description": "This module defines operations over logic constants from CIL's type system, including equality, comparison, hashing, and pretty-printing. It supports structured manipulation through sets, maps, and hash tables keyed by logic constants, enabling precise static analysis tasks such as constraint tracking and data flow approximation. Key functions include deep copying, project membership checks, and ordered and hashed collections tailored for analysis plugins working with CIL's logical expressions.",
      "description_length": 499,
      "index": 3380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char",
      "library": "frama-c.kernel",
      "description": "This module defines a character datatype with standard operations including equality, comparison, hashing, and pretty-printing. It provides utilities for deep copying, project-specific membership checks, and managing character-based sets, maps, and hash tables. Use cases include static analysis tasks requiring precise character handling, such as tracking character sets in string analysis or managing character-indexed state in plugins.",
      "description_length": 438,
      "index": 3381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module extends a datatype with hash table functionality, enabling efficient key-based operations like insertion, lookup, and iteration. It works with datatypes that define `equal` and `hash` functions, using them to manage keys in a hash table. It is ideal for static analysis tasks requiring fast access to mapped data, such as caching analysis results or tracking program elements with custom key structures.",
      "description_length": 415,
      "index": 3382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps with rational-number keys, supporting ordered traversal, key-based queries, and value transformations. It provides operations for precise key-range searches, list-sequence conversions, and structural manipulations like merging or filtering, tailored for rational-number-indexed data. Designed for static analysis workflows, it enables efficient handling of numeric key dependencies and symbolic computations requiring exact arithmetic.",
      "description_length": 475,
      "index": 3383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_One",
      "library": "frama-c.kernel",
      "description": "Implements a low-level cache for values of type `H.t`, producing results of type `R.t`. Provides `clear` to reset the cache and `merge` to associate a function result with a key. Useful for memoizing expensive computations over hashable keys in formal analysis plugins.",
      "description_length": 269,
      "index": 3384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Map",
      "library": "frama-c.kernel",
      "description": "This module supports insertion, deletion, and lookup operations alongside advanced functionalities like ordered traversal, merging, and transformation of key-value pairs stored in ordered maps. It operates on associations between ACSL-comparable properties and arbitrary values, maintaining strict key ordering and providing efficient access to extremal elements. Typical applications include static analysis plugins requiring precise property management, aggregation of analysis results, or ordered processing of property bindings.",
      "description_length": 532,
      "index": 3385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_ctor_info",
      "library": "frama-c.kernel",
      "description": "This module provides a project-aware hashtbl implementation for managing logic constructor metadata, supporting operations like mutable binding, lookup, traversal, and memoization with string keys and `logic_ctor_info` values. It integrates with Frama-C's project system to ensure analysis consistency, offering lifecycle management via computed-state flags and custom marshaling hooks, while avoiding standard hashtbl pitfalls for keys requiring specialized rehashing. Use cases include storing and querying analysis-specific logic definitions during program verification tasks.",
      "description_length": 579,
      "index": 3386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LibEntry",
      "library": "frama-c.kernel",
      "description": "This module manages the behavior of the `-lib-entry` command-line option, which controls how entry points are validated in library mode. It operates on a global boolean state to enable or disable the option and provides direct manipulation of the library entry point string, with safety-critical operations like `unsafe_set` reserved for advanced scenarios. It supports use cases such as dynamically adjusting entry point validation rules during analysis or integrating with project-specific state management workflows.",
      "description_length": 519,
      "index": 3387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural",
      "library": "frama-c.kernel",
      "description": "This module defines logic information structures with structural comparison, supporting precise equality, ordering, and hashing operations on `logic_info` values derived from CIL types. It includes utilities for deep copying, pretty printing, and project membership testing, enabling accurate manipulation and analysis of logic entities in static analysis plugins. The associated `Set`, `Map`, and `Hashtbl` modules provide efficient, comparison-based data structures tailored for tracking and querying logic properties in CIL code, such as function contracts or annotations during constraint solving or verification tasks.",
      "description_length": 623,
      "index": 3388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fieldinfo",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage project-specific mappings between C AST fieldinfo keys and their structural correspondence data, supporting additions, replacements, lookups, and iterative transformations. It employs stateful hashtables with customizable marshaling and update hooks to track differences in field declarations across projects. Designed for AST differencing tasks, it enables use cases like comparing C struct layouts, synchronizing field metadata during merges, and detecting structural inconsistencies between code versions.",
      "description_length": 548,
      "index": 3389,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Caml_weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table using OCaml's `Weak` module, optimized for keys with identity-based equality. It supports operations like `add`, `find`, `remove`, and `merge`, which manage elements based on reference equality, automatically discarding collected entries. It is particularly useful in static analysis plugins for tracking unique object identities with controlled memory usage.",
      "description_length": 400,
      "index": 3390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto.Make",
      "library": "frama-c.kernel",
      "description": "This module implements the Bourdoncle algorithm to compute weak topological orderings (WTOs) for a given graph structure. It provides functions to partition a graph into hierarchically ordered components using a preference function, along with utilities to compare and print partitions and components. It operates on nodes defined by the `Node` module and is used to determine efficient evaluation orders for fixed-point computations in program analysis.",
      "description_length": 454,
      "index": 3391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic",
      "library": "frama-c.kernel",
      "description": "This module handles instantiation and inspection of polymorphic types with a single type variable, providing functions to create monomorphic instances, check their origin, and retrieve their type parameters. It works directly with polymorphic type constructors and their instantiated forms, enabling type-safe manipulation of specific type instances. Concrete use cases include creating and managing typed representations for data structures like lists or options with fixed element types.",
      "description_length": 489,
      "index": 3392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates source code positions in C files, providing precise location tracking through functions like `of_lexing_pos` and `to_lexing_pos` for conversion to and from lexer positions, `pretty` for user-friendly display, and `compare`, `equal`, and `hash` for ordering and equality checks. It supports static analysis tasks requiring accurate file location handling, such as error reporting, code slicing, and annotation placement. The module also includes specialized submodules Set, Map, and Hashtbl for managing collections and associations of positions efficiently.",
      "description_length": 596,
      "index": 3393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a weak hash table implementation for a custom data type `Data`, supporting internment-style value canonicalization through operations like `merge`, `add`, `find`, and `remove`. It integrates with Frama-C's state management system, enabling project-scoped persistence, garbage collection of unreferenced entries, and customizable marshaling for state saving/loading. Use cases include deduplicating equivalent values in static analysis contexts, tracking evolving data with update hooks, and managing transient state in plugins without manual memory cleanup.",
      "description_length": 578,
      "index": 3394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make",
      "library": "frama-c.kernel",
      "description": "This module combines two monads into a single composed monad using a swap function that reorders their application. It supports concrete operations like `return`, `bind`, `map`, and `flatten` for sequencing effectful computations across layered monads, and includes specialized submodules for handling booleans, options, lists, and custom operators within the composed monadic structure. It is used to build complex monadic behaviors such as stateful computations that may fail or process optional or list-based data.",
      "description_length": 517,
      "index": 3395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements hashconsed data structures with strong equality and efficient sharing for state-building operations in static analysis. It provides operations like `merge`, `add`, `find`, and `mem` to manage hashconsed values with structural identity, supporting deterministic behavior across analysis passes. Concrete use cases include managing abstract program states, analysis artifacts, or symbolic values where memory efficiency and exact structural comparison are essential.",
      "description_length": 487,
      "index": 3396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Option.Bool",
      "library": "frama-c.kernel",
      "description": "This module extends the `option` type with additional operations to support boolean-based conditional logic. It provides the `only_if` function, which returns `None` if the boolean condition is false, and preserves the input `unit option` otherwise. This is useful for integrating conditional checks into monadic chains that operate on `unit option` values, enabling more concise and expressive control flow.",
      "description_length": 408,
      "index": 3397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operators for working with `option` values, including bind, map, and product operations. It supports composing computations that may fail, enabling concise handling of optional data through infix operators. Concrete use cases include chaining safe lookups, parsing optional fields, or validating sequences of operations where any step may return `None`.",
      "description_length": 382,
      "index": 3398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind",
      "library": "frama-c.kernel",
      "description": "This module extends a minimal monad interface based on `bind` and `return`, providing derived operations like `map`, `flatten`, and monadic control structures through submodules. It supports boolean guards, optional values, lists, and operator-based composition, enabling precise sequencing of effectful computations. Use cases include building analysis passes that conditionally process program elements, handle optional data with potential failures, or apply effectful transformations across collections.",
      "description_length": 506,
      "index": 3399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintComments",
      "library": "frama-c.kernel",
      "description": "This component manages a boolean configuration flag that determines whether comments are preserved during source code analysis. It provides functions to toggle this behavior, track modifications to the flag's state, and handle the structured representation of comment data. The operations directly manipulate an internal boolean value and associated comment metadata, primarily used when processing C code to either retain or strip comments for subsequent analysis phases.",
      "description_length": 472,
      "index": 3400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Typeinfo",
      "library": "frama-c.kernel",
      "description": "This module manages type information for AST nodes during diff computation, offering operations to bind, retrieve, and transform type data while handling project-specific state. It works with `typeinfo` keys and `correspondence` structures from `Cil_types`, using custom hashtables that avoid standard `rehash` logic to ensure compatibility with projectified state. Its features support use cases like tracking type changes across code revisions, memoizing AST transformations, and enabling precise marshaling for distributed analysis tasks.",
      "description_length": 541,
      "index": 3401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables that map integer intervals (with congruence properties defined by bounds and modular arithmetic) to arbitrary values, supporting operations like insertion, lookup, deletion, iteration, folding, and sequence conversion. It includes advanced features such as sorted traversal using custom key comparisons, memoization, and in-place transformations, specifically optimized for static analysis tasks like program verification and optimization where precise interval arithmetic is required to track variable ranges or congruence constraints.",
      "description_length": 569,
      "index": 3402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with abstract integer keys (`Int_val.t`) and arbitrary values, emphasizing functional updates and structural integrity during static analysis. It supports ordered traversal, conditional searches, and lattice-aware operations like merging or splitting intervals, tailored for program analysis tasks involving integer abstractions. Key use cases include tracking integer ranges, combining dataflow information, and transforming symbolic states with precise key handling.",
      "description_length": 493,
      "index": 3403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing logic information entities in CIL-based static analysis tools. It provides equality, comparison, hashing, and pretty-printing functions for `logic_info` values, along with deep copying and project membership checks. The module supports precise manipulation of logic entities through associated set, map, and hash table structures tailored for static analysis tasks such as tracking logical dependencies and managing analysis results.",
      "description_length": 477,
      "index": 3404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module creates hash tables with custom key types that support equality and hashing operations, enabling efficient lookups and insertions. It works with any data type `t` that provides `equal` and `hash` functions, allowing deterministic handling of keys with user-defined equivalence. Concrete use cases include managing symbol tables with custom comparison logic and aggregating values indexed by structured keys requiring stable hashing and comparison.",
      "description_length": 459,
      "index": 3405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval.Make",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and analyzing floating-point intervals with support for arithmetic, trigonometric, and bitwise transformations, along with lattice operations like join and widen. It works with interval types that represent ranges of floating-point values parameterized by precision (e.g., single or double), including special values like NaN and infinities. These capabilities are used in abstract interpretation for program analysis tasks such as constraint propagation, refinement of numerical variables, and modeling memory-level representations of floating-point data through precision-aware conversions to integer ranges.",
      "description_length": 659,
      "index": 3406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RemoveExn",
      "library": "frama-c.kernel",
      "description": "This module provides operations to configure and manage a boolean flag that determines whether exceptions are stripped during static analysis. It works with internal kernel state to enable dynamic toggling of exception removal, supporting use cases like analysis phase customization, dynamic configuration updates via hooks, and integration with other kernel services requiring exception behavior control. The core data structure is a mutable boolean state with associated metadata for serialization and alias management.",
      "description_length": 521,
      "index": 3407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps with **Frama_c_kernel.Emitter.t** keys and arbitrary value types, supporting functional updates, ordered traversal, and bulk operations like merging, filtering, and splitting. It provides both imperative-style modifications (insertion, removal) and pure functional transformations (folds, maps, partitions), with key ordering enforced through dedicated **Key** module comparisons. Typical use cases include tracking emitter-generated annotations, aggregating property statuses across analysis passes, or maintaining structured metadata collections with customizable pretty-printing and sequence-based iteration.",
      "description_length": 659,
      "index": 3408,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_pair",
      "library": "frama-c.kernel",
      "description": "This module handles polymorphic pair types by providing instantiation, type checking, and decomposition operations. It works with the `Type.t` representation of Frama-C types, specifically for constructing and inspecting pairs of two distinct types. Concrete use cases include defining and manipulating compound types in static analysis plugins, such as representing key-value pairs or dual-state values.",
      "description_length": 404,
      "index": 3409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatRelative",
      "library": "frama-c.kernel",
      "description": "This module controls the behavior of floating-point comparisons by managing a boolean setting that can be toggled via command-line flags or project-specific configurations. It operates on boolean values to enable or disable relative comparison modes, supporting dynamic state updates through hooks and serialization mechanisms. The functionality is particularly useful in static analysis scenarios where floating-point precision handling needs adjustment based on user-defined policies or environmental constraints.",
      "description_length": 515,
      "index": 3410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Emitted_status",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing property status values, including equality, comparison, and hashing functions. It works with the `emitted_status` type, representing statuses of properties in the analysis. Concrete use cases include tracking and querying the status of properties during static analysis, ensuring consistent handling across different analysis phases.",
      "description_length": 391,
      "index": 3411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Set_orig",
      "library": "frama-c.kernel",
      "description": "This module provides functions to set the original representative of various AST elements during visitor traversal, enabling precise tracking and modification of element references in the AST. It operates on data types such as `varinfo`, `compinfo`, `enumitem`, `stmt`, `fundec`, and other CIL AST components. Concrete use cases include maintaining correct references when copying or transforming AST nodes, ensuring that elements in the new AST correctly point to their original counterparts in the visitor state.",
      "description_length": 514,
      "index": 3412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements backward dataflow analysis over an interpreted automaton's control flow graph, computing abstract states at control points using a domain's backward transfer function. Works with control flow graphs where edges represent transitions with guards and actions derived from CIL expressions and instructions. Computes states before transitions based on post-states, producing results accessible at function entry, return, and individual statement points, with support for iteration and visualization.",
      "description_length": 506,
      "index": 3413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutoLoadPlugins",
      "library": "frama-c.kernel",
      "description": "This module manages plugin auto-loading behavior through a boolean configuration flag, supporting operations to toggle its state, register change hooks, and define aliases. It operates on an internal boolean state and a structured data type for introspection, with capabilities for project-specific state management and serialization customization. Typical use cases include controlling plugin initialization at runtime, adapting behavior across projects, and integrating configuration persistence mechanisms.",
      "description_length": 509,
      "index": 3414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string",
      "library": "frama-c.kernel",
      "description": "This module represents wide strings as lists of 64-bit integers and provides core operations including equality, comparison, hashing, and pretty-printing. It supports static analysis tasks such as tracking and comparing string constants in C code, with deep copy and project membership checks. The module also includes Set, Map, and Hashtbl submodules for structured manipulation of wide strings in static analysis workflows.",
      "description_length": 425,
      "index": 3415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Current_loc.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with descriptors and representants for structural inspection. It supports deep copying and project membership checks, enabling precise manipulation and analysis of location-based data. Concrete use cases include tracking and comparing source code locations during static analysis and logging.",
      "description_length": 406,
      "index": 3416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Boot.Main",
      "library": "frama-c.kernel",
      "description": "Registers functions to be executed during Frama-C's initialization phase. Works with unit functions, enabling integration of custom setup logic. Useful for plugins needing to initialize state or register callbacks before analysis starts.",
      "description_length": 237,
      "index": 3417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top",
      "library": "frama-c.kernel",
      "description": "This module provides monadic and lattice operations for managing values that may represent an over-approximated \"top\" state, such as mapping, binding, narrowing, and conversion to/from optional representations. It operates on lattice-structured data that explicitly incorporates a top element, extending booleans, options, lists, and custom datatypes with semantics for abstract interpretation. These capabilities are particularly useful in static analysis and symbolic execution scenarios where uncertainty or imprecise value tracking requires explicit top-state handling.",
      "description_length": 573,
      "index": 3418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections",
      "library": "frama-c.kernel",
      "description": "This module extends a base datatype with collections support, adding dedicated modules for sets, maps, and hash tables that rely on the base type's `equal`, `compare`, and `hash` functions. It enables operations such as membership testing, ordered traversal, and key-based data manipulation, tailored for structured analysis tasks like tracking program elements or managing analysis states. Concrete use cases include static analysis plugins that require precise, efficient manipulation of sets of program entities, symbol tables with ordered keys, and memoization tables with structured keys.",
      "description_length": 593,
      "index": 3419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.SharedCounter",
      "library": "frama-c.kernel",
      "description": "This module implements a globally shared counter that persists across projects and supports marshalling. It provides operations to increment the counter, retrieve its current value, and reset it to zero. Useful for generating unique identifiers or tracking state changes in a way that remains consistent during serialization and deserialization.",
      "description_length": 345,
      "index": 3420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rangemap.Make",
      "library": "frama-c.kernel",
      "description": "This module provides structural manipulation, comparison, and transformation of immutable maps with ordered keys and typed values, using balanced binary trees that cache hashes for efficient equality checks. It supports key-based operations like insertion, deletion, and range queries, alongside interval-aware functions for merging, filtering, and traversal with fuzzy key relationships. Specific use cases include project-aware membership validation, interval decomposition, and performance-critical scenarios requiring logarithmic-time access and hash-aware structural sharing.",
      "description_length": 580,
      "index": 3421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps where keys are integer intervals with congruence constraints (supporting infinite bounds and modular arithmetic properties) paired with arbitrary values. It offers operations to merge, split, filter, and query interval-based associations using precise semantic comparisons, including finding first-matching bindings or extremal ranges. Designed for static analysis tasks, it enables tracking value ranges of program variables and propagating constraints across symbolic intervals.",
      "description_length": 520,
      "index": 3422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.Forwards",
      "library": "frama-c.kernel",
      "description": "Implements forwards data flow analysis by computing transfer functions over control flow graphs using customizable strategies. Operates on statements annotated with domain-specific data, propagating values through the program's control flow. Useful for implementing analyses like constant propagation or liveness analysis where initial statement data is known and needs to be distributed through the function.",
      "description_length": 409,
      "index": 3423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Session",
      "library": "frama-c.kernel",
      "description": "Handles plugin-specific session directories and files within Frama-C. It provides operations to retrieve or create session directories and files, set and query the user directory, and check if the user directory has been initialized. This module is used to manage persistent storage paths scoped to a plugin's execution session.",
      "description_length": 328,
      "index": 3424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL attributes, including equality, comparison, hashing, and pretty-printing, alongside deep copying and project-aware membership checks. It works with `Frama_c_kernel.Cil_types.attributes`, supporting structured manipulation of attribute data in static analysis tasks such as tracking function or variable annotations. Concrete use cases include attribute propagation, analysis state management, and metadata transformation during C program analysis.",
      "description_length": 495,
      "index": 3425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs",
      "library": "frama-c.kernel",
      "description": "This module defines a structural type representation for CIL types that excludes attributes, enabling precise equality and comparison operations based on type structure alone. It supports operations such as equality checking, hashing, pretty-printing, deep copying, and project membership testing, all focused on `Frama_c_kernel.Cil_types.typ` values. It is particularly useful in static analysis plugins for comparing and managing type definitions where attribute differences should not affect equivalence, such as analyzing struct layouts or tracking type usage across translation units.",
      "description_length": 589,
      "index": 3426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Orig_project",
      "library": "frama-c.kernel",
      "description": "This module manages the original project state used for computing AST diffs, providing operations to set, retrieve, and memoize project data. It supports tracking structural changes with hooks on update and serialization via custom marshaling functions. Concrete use cases include capturing project snapshots before analysis and comparing structural elements during diff computation.",
      "description_length": 383,
      "index": 3427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations like mapping, binding, and flattening for lattice structures that explicitly handle a bottom element, alongside lattice-specific functions such as join and narrow. It operates on values encapsulated in a `Bottom.t` wrapper, which distinguishes between valid lattice elements and undefined or error states, and extends these operations to booleans, lists, options, and custom datatypes. It is particularly useful in static analysis for propagating and combining partial or invalid information through computations.",
      "description_length": 553,
      "index": 3428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for managing collections of `Typed_parameter.t` elements, leveraging comparison-based ordering for efficient membership tests, transformations, and ordered traversals. It supports use cases like filtering parameter sets with monotonic predicates, merging configuration options via union/intersection, and converting between sets, sequences, and lists for command-line interface logic. Key features include safe and unsafe element retrieval, structural manipulation (split, partition), and utilities for project-specific membership checks or deep copying.",
      "description_length": 600,
      "index": 3429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Bool_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a boolean reference state with operations to set, get, and clear the value. It supports project-specific state tracking with hooks for updates and changes, and custom serialization. Concrete use cases include maintaining and reacting to boolean flags across different analysis phases in Frama-C plugins.",
      "description_length": 335,
      "index": 3430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.True_ref",
      "library": "frama-c.kernel",
      "description": "This module creates a boolean reference initialized to `true`, offering operations to get, set, and reset its value. It supports project-specific state tracking with hooks for updates and changes, along with custom marshaling for serialization. Concrete use cases include managing analysis flags that default to enabled, such as tracking whether a particular analysis phase has completed.",
      "description_length": 388,
      "index": 3431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and comparison for CIL expressions, treating `sizeof` expressions as equivalent if they yield the same size, rather than comparing their identities. It provides standard operations such as equality checking, hashing, comparison, deep copying, and pretty printing for the `exp` type from `Cil_types`, along with set, map, and hash table modules that use this equivalence. It is particularly useful in static analysis tasks like symbolic evaluation and constraint simplification, where expressions with equivalent runtime behavior\u2014especially those involving `sizeof`\u2014must be treated as identical.",
      "description_length": 634,
      "index": 3432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Automaton",
      "library": "frama-c.kernel",
      "description": "This module defines the core data structure for representing automata used in abstract interpretation, specifically modeling control flow graphs with states and transitions. It includes operations for equality checking, comparison, hashing, pretty-printing, and deep copying automata, as well as utilities for project membership testing and type representation. Concrete use cases include analyzing program behavior through operational semantics or computing reachable states via collection semantics, leveraging CIL expressions and instructions directly in transition definitions.",
      "description_length": 581,
      "index": 3433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Feedback",
      "library": "frama-c.kernel",
      "description": "This module defines a type `t` representing the possible statuses of a property in static analysis, such as `Valid`, `Invalid`, or `Unknown`. It provides functions to retrieve the status of a single property or the combined status of multiple properties, along with a function to format and print these statuses. These features support precise reporting and analysis of verification results in static code analysis tools.",
      "description_length": 421,
      "index": 3434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq",
      "library": "frama-c.kernel",
      "description": "This module defines structural equivalence for CIL expressions, providing equality, comparison, and hashing operations that ignore physical identity and focus on expression structure. It supports static analysis tasks requiring precise equivalence checks between expressions, such as detecting redundant computations or verifying expression normalization. The module enables the use of CIL expressions in sets, maps, and hash tables where structural identity is essential, with dedicated operations for deep copying, pretty printing, and project membership checks.",
      "description_length": 564,
      "index": 3435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom",
      "library": "frama-c.kernel",
      "description": "This module implements monadic operations and lattice combinators for values that can be either `Top`, `Bottom`, or a wrapped type. It supports binding, mapping, product construction, and flattening of lattice values, along with equality, comparison, and pretty-printing utilities. It is used to manage extremal lattice elements explicitly in static analysis domains, such as tracking abstract values with precise top and bottom handling.",
      "description_length": 438,
      "index": 3436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo_Id",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing variable information identifiers in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `varinfo` type to represent variables in C programs, providing deep copies, identity checks, and project membership queries. Concrete use cases include tracking variable definitions and uses during static analysis, and managing variable metadata across different analysis passes.",
      "description_length": 458,
      "index": 3437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Consolidation_graph",
      "library": "frama-c.kernel",
      "description": "This module tracks the consolidated status of properties in a dependency graph, including all dependencies and their statuses. It provides operations to retrieve the graph for a given property and to print the graph's contents using a formatter. Use cases include analyzing the impact of property dependencies on overall verification results and visualizing the status propagation through the graph.",
      "description_length": 399,
      "index": 3438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Fold",
      "library": "frama-c.kernel",
      "description": "This module implements a hook system that allows registering, managing, and applying a collection of transformation functions over values of type `P.t`. It supports adding functions with optional deduplication, querying the current set, and applying transformations in registration order. Concrete use cases include extending analysis phases with custom logic or injecting per-program-point modifications in static analysis tools.",
      "description_length": 430,
      "index": 3439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations with integer sets as keys and arbitrary values, supporting standard manipulations like `add`, `find`, and `remove`, along with bulk sequence operations (`add_seq`, `to_seq`). It integrates with interval-based representations for large sets, enabling efficient memoization and sorted iteration over keys or values. It is particularly used in static analysis frameworks to track or transform integer sets during program analysis, where dynamic size thresholds dictate transitions between compact set representations and interval arithmetic.",
      "description_length": 592,
      "index": 3440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.Option",
      "library": "frama-c.kernel",
      "description": "This module extends the `option` type with monadic operations compatible with the `list` monad, enabling non-deterministic computations that may also fail. It provides `iter` for performing effectful iterations over optional values and `map` for transforming optional values within a non-deterministic context. Use this module when handling computations that involve both optional results and branching possibilities, such as parsing or symbolic execution with potential failures.",
      "description_length": 480,
      "index": 3441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing file collections represented as lists of `Frama_c_kernel.Filepath.t` values, supporting operations like addition, iteration, folding, and appending. It integrates with command-line workflows through file list serialization, alias definitions, and category-based grouping for analysis tasks. Key use cases include tracking file changes via hooks, handling dynamic file list updates in plugins, and structuring multi-file analyses with customizable categorization.",
      "description_length": 506,
      "index": 3442,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Time",
      "library": "frama-c.kernel",
      "description": "This component manages string-based configuration for time tracking in Frama-C's analysis workflows, enabling operations to set and retrieve time values, register change listeners, and resolve aliases. It handles string lists and individual strings with validation logic to distinguish executable time functions from static values, supporting project state persistence and cross-session consistency. Use cases include synchronizing time-sensitive analysis phases and maintaining validated time configurations across plugin interactions.",
      "description_length": 536,
      "index": 3443,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph",
      "library": "frama-c.kernel",
      "description": "This module implements control flow graphs where vertices represent program control points and edges encode transitions with associated guards (CIL expressions) and actions (CIL instructions). It provides graph construction, modification, and traversal operations, along with algorithms for weak topological ordering (WTO) and forward/backward dataflow analysis to support abstract interpretation tasks like program verification and state reachability computation. The structure facilitates static analysis workflows by modeling program semantics through partition-based graph algorithms and worklist-driven propagation mechanisms.",
      "description_length": 631,
      "index": 3444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32",
      "library": "frama-c.kernel",
      "description": "This module implements a 32-bit integer type with standard operations including comparison, hashing, deep copying, and pretty-printing. It supports integration with Frama-C's analysis systems through type descriptors, project membership checks, and structural representations. Concrete use cases include representing and manipulating integer values in static analysis plugins, such as tracking program variables, managing analysis states, or implementing domain-specific computations requiring precise 32-bit semantics.",
      "description_length": 519,
      "index": 3445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manipulate CIL source code locations, including equality checks, semantic comparisons of start positions using normalized file and line data, and conversions to lexing positions. It operates on location values and supports collection operations through sets, maps, and hash tables specialized for these values. These tools are used in static analysis plugins to track and compare precise source code positions while abstracting away absolute character offsets.",
      "description_length": 494,
      "index": 3446,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.Share",
      "library": "frama-c.kernel",
      "description": "This module provides access to shared system configuration paths used by Frama-C. It exposes directories for architecture-independent files, the main installation directory, a concatenated search path, and the location of Frama-C's libc headers. These values are used to locate internal resources and support toolchain operations such as header resolution and plugin loading.",
      "description_length": 375,
      "index": 3447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL global variables, including equality, comparison, hashing, and pretty-printing. It provides access to global variable attributes and source locations, along with deep copying and project membership checks. Concrete uses include analyzing or transforming C program globals during static analysis, such as tracking variable properties or restructuring program elements.",
      "description_length": 419,
      "index": 3448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Iter",
      "library": "frama-c.kernel",
      "description": "This module provides iteration functions over pairs of AST elements in a visitor behavior, allowing processing of old and new versions of elements such as variables, statements, and types. It supports data types like `varinfo`, `stmt`, `fundec`, and various CIL type definitions, enabling transformations or analyses that compare or update AST nodes. Concrete use cases include tracking changes between AST versions, propagating annotations, or synchronizing metadata during AST transformations.",
      "description_length": 495,
      "index": 3449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages cache directories and files by providing functions to retrieve or create them. It works with file paths represented as `Frama_c_kernel.Filepath.t` values. Concrete use cases include ensuring the existence of specific cache directories or files during analysis, such as storing intermediate results or persistent data.",
      "description_length": 337,
      "index": 3450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic4",
      "library": "frama-c.kernel",
      "description": "This module implements a functor for creating and manipulating polymorphic types with four type variables. It provides functions to instantiate polymorphic type representations, check if a type is an instance of a polymorphic type, and retrieve the type arguments of an instantiated polymorphic type. It directly works with type representations from the `Type` module, enabling precise type handling in analyses that require parametric polymorphism.",
      "description_length": 449,
      "index": 3451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepBuiltinMacros",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls the printing of machine-dependent built-in macros, offering operations to set, retrieve, and monitor changes to its state. It operates on boolean values and custom macro metadata structures defined in its `Datatype` submodule, incorporating support for aliases, serialization, and project-scoped state persistence. The functionality enables developers to dynamically toggle macro output during analysis, aiding in debugging or inspecting compiler-specific macro expansions.",
      "description_length": 538,
      "index": 3452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SafeArrays",
      "library": "frama-c.kernel",
      "description": "This module manages the `-safe-arrays` boolean option, enabling control over array bounds checking via flags, value hooks, and project-specific state handling, while providing safe array representations with serialization, comparison, and pretty-printing capabilities. These features are used in static analysis and plugin development to enforce array safety constraints during code verification.",
      "description_length": 396,
      "index": 3453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Lemmas",
      "library": "frama-c.kernel",
      "description": "This module implements a project-aware, memoized hash table for storing logic lemmas indexed by strings, supporting operations to add, replace, retrieve, and remove entries while tracking state changes for formal verification tasks. It includes custom iteration, folding, and marshaling capabilities alongside hooks for monitoring modifications, ensuring project-specific isolation and persistence of lemma data. The structure is optimized for managing global annotations in Frama-C's logic environment, particularly where lemma state must be preserved across analysis sessions or isolated between distinct project contexts.",
      "description_length": 624,
      "index": 3454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Or_Uninitialized",
      "library": "frama-c.kernel",
      "description": "This module provides bit-level manipulation and lattice operations (meet, join, narrow) for abstract values tagged with initialization status and escaping address flags, enabling precise tracking of memory state imprecision. It operates on values that may be uninitialized or contain escaping addresses, supporting static analysis tasks like undefined behavior detection and data flow merging. Specific use cases include merging divergent code paths, refining value approximations during abstract interpretation, and handling bit-level operations on potentially uninitialized data.",
      "description_length": 581,
      "index": 3455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map",
      "library": "frama-c.kernel",
      "description": "This module extends a minimal monad with standard operations derived from `map`, enabling structured sequencing of effectful computations. It provides `return`, `bind`, `map`, and `flatten`, along with submodules for integrating booleans, options, and lists into monadic workflows. Use it to compose analysis or transformation pipelines that carry effects like state, logging, or error handling through monadic chaining.",
      "description_length": 420,
      "index": 3456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintVersion",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage a boolean option for version output control, including value accessors, change hooks, alias handling, and marshaling customization. It operates on a boolean state and structured version metadata through the Datatype module, enabling command-line option parsing, version",
      "description_length": 309,
      "index": 3457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Option.Option",
      "library": "frama-c.kernel",
      "description": "This module extends the standard `option` type with monadic operations, focusing on enhanced composition of optional values. It provides key functions like `iter` for performing side-effecting operations on contained values and `map` for transforming optional values into other optional types. These operations are useful when chaining computations that may fail, such as parsing or lookup operations where missing data must propagate cleanly.",
      "description_length": 443,
      "index": 3458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling CIL kernel instructions (`kinstr`), including equality, comparison, hashing, and pretty-printing. It supports data structures like sets, maps, and hash tables for efficient manipulation of instruction collections, enabling tasks such as control flow analysis and dataflow propagation. Specific functions include deep copying, project membership checks, and conversions from optional statements, tailored for static analysis and code optimization workflows.",
      "description_length": 500,
      "index": 3459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Register",
      "library": "frama-c.kernel",
      "description": "Registers a new state with operations to manage its lifecycle, serialization, and update hooks. Works with custom data types through the `Datatype` module, and tracks state changes per project. Used to define and control analysis states that persist across different stages of static analysis in Frama-C plugins.",
      "description_length": 312,
      "index": 3460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_templates",
      "library": "frama-c.kernel",
      "description": "This module supports memoization, iteration, and serialization of project-local state through a key-value store with custom key and data types, leveraging hash tables that safely handle keys requiring custom `rehash` logic. It provides atomic mutation tracking, hook registration for change notifications, and integration with Frama-C's project management to ensure consistent state handling across analyses. Use cases include managing built-in template metadata with precise rehashing behavior and persisting computed analysis results tied to specific project contexts.",
      "description_length": 570,
      "index": 3461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a project-specific hashtable that maps logic keys to their correspondence data during AST differencing, supporting modifications, queries, and iteration over these mappings. It works with hashtables that require custom rehashing logic for keys, ensuring correct serialization and state management through hooks and marshaling routines. It is used to track and synchronize logic information across project versions while handling edge cases where key rehashing must be explicitly controlled.",
      "description_length": 535,
      "index": 3462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Result.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for chaining and transforming `result` values in a pipeline-friendly style. It supports binding operations with `>>-` and `let*`, mapping with `>>-:` and `let+`, and combining results in parallel with `and*` and `and+`. These operators simplify sequential and concurrent error-handled computations, such as validating inputs and aggregating errors, without requiring additional monadic abstractions.",
      "description_length": 435,
      "index": 3463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple",
      "library": "frama-c.kernel",
      "description": "This module creates a product type of four existing datatypes, enabling tuple-like operations such as equality, comparison, hashing, and pretty printing. It supports structured data representation by combining four distinct values into a single, composite value. Concrete use cases include modeling complex program analysis states or intermediate representations that require grouping four related pieces of data.",
      "description_length": 413,
      "index": 3464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kernel_function_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for mapping kernel functions to arbitrary data, offering operations like insertion, lookup, iteration, folding, and memoization, alongside advanced features such as change tracking via hooks and project-aware state management. It works with kernel functions as keys and supports serializable data values, enabling use cases like caching analysis results, tracking function-specific metadata, and maintaining persistent state across Frama-C sessions. The structure is optimized for plugin development where fine-grained dependency tracking and efficient state updates are critical.",
      "description_length": 616,
      "index": 3465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Eid",
      "library": "frama-c.kernel",
      "description": "This module generates unique integer identifiers using the `next` function, which returns a new integer each time it is called. It maintains an internal counter that increments with each invocation. This is useful for assigning distinct IDs to elements in analyses or transformations requiring unique labels.",
      "description_length": 308,
      "index": 3466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Option_ref",
      "library": "frama-c.kernel",
      "description": "This module implements a state reference for optional values, providing operations to set, get, and memoize a `Data.t` value within a state-building context. It supports managing nullable state elements with functions like `set`, `get`, `clear`, and `memo`, along with change hooks and custom marshaling. Concrete use cases include tracking optional analysis artifacts in static analysis plugins, such as cached results that may be absent or need lazy computation.",
      "description_length": 464,
      "index": 3467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Fval.F",
      "library": "frama-c.kernel",
      "description": "This module implements precise floating-point interval arithmetic, handling special values like infinities and distinguishing between -0. and +0. It operates on a concrete type `t` representing floating-point values, providing conversions to and from `float`, comparison, equality checks, and pretty-printing in both decimal and hexadecimal formats. Use cases include static analysis of floating-point computations, lattice construction for abstract interpretation, and precise manipulation of floating-point bounds in program verification.",
      "description_length": 540,
      "index": 3468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Enums",
      "library": "frama-c.kernel",
      "description": "This component offers functionality to manage string-based configuration options for handling enumeration types, including defining allowed values, aliases, and serialization mechanisms. It operates on string lists, function names, and parameter constraints to validate and transform enum representations during kernel configuration. Typical use cases involve enforcing strict value sets for enum options, mapping between symbolic names and internal representations, and persisting enum state across sessions.",
      "description_length": 509,
      "index": 3469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V",
      "library": "frama-c.kernel",
      "description": "This module provides abstract interpretation operations for analyzing memory values and numeric data in C programs, focusing on lattice manipulations, arithmetic/bitwise transformations, and memory location tracking. It works with byte-indexed memory locations (`Cvalue.V.t`) that encode bases, offsets, and origins, alongside scalar integers and floats, using sets, maps, and hashtables to manage associations and imprecise values. Key use cases include value range analysis, pointer aliasing checks, bit-level precision control, and static approximation of runtime memory states for verification tasks.",
      "description_length": 604,
      "index": 3470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement.WTO",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing weak topological orderings (WTOs) of CIL statements, along with standard operations including equality, comparison, hashing, and pretty printing. It supports working with lists of WTO values, deep copying, and checking membership based on project predicates. Concrete use cases include analyzing control flow dependencies in C programs and managing iterative fixpoint computations over statement graphs.",
      "description_length": 452,
      "index": 3471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintPluginPath",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean flag controlling the `-print-plugin-path` behavior, including state modification, value observation, and lifecycle hooks. It operates on a shared internal state representing the flag's status, with support for project-specific configuration persistence and marshaling. This functionality is used to dynamically enable or disable plugin path printing during analysis configuration or command-line argument processing.",
      "description_length": 468,
      "index": 3472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term",
      "library": "frama-c.kernel",
      "description": "This module defines operations for comparing, hashing, and printing CIL terms, along with deep copying and checking project membership. It supports data types such as `Frama_c_kernel.Cil_types.term` and provides concrete functionality for managing term-based data in static analysis tasks, such as tracking expressions or statements in C code. Use cases include term comparison during analysis passes, memoization via hash tables, and set-based reasoning over CIL constructs.",
      "description_length": 475,
      "index": 3473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Ref",
      "library": "frama-c.kernel",
      "description": "This module implements reference cells for a given type `T`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports deep copying and membership checks for project skeletons, ensuring values can be inspected and manipulated independently. Concrete use cases include managing mutable state in analyses while preserving referential transparency and supporting serialization through descriptors.",
      "description_length": 438,
      "index": 3474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.StartData",
      "library": "frama-c.kernel",
      "description": "This module manages statement-indexed data storage for data flow analyses, using a hash table to associate values of type `X.t` with individual statements. It provides operations to add, retrieve, update, and iterate over these associations, along with checking existence and clearing the data. It is used to track initial data values at the start of statements during analysis.",
      "description_length": 378,
      "index": 3475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for `Emitter.t` values, supporting standard set manipulations (union, intersection, difference), ordered traversal, element-wise filtering, mapping, and partitioning. It facilitates conversions between sets",
      "description_length": 252,
      "index": 3476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for manipulating ordered sets of integers, including union, intersection, difference, membership checks, and element retrieval with ordered traversal. It works with abstract integer sets (`Int_val.Set.t`) that maintain sorted order, leveraging monotonicity guarantees for efficient iteration, filtering, and nearest-element queries. Use cases include static analysis tasks requiring precise tracking of integer ranges, dependency resolution, and over-approximated value set manipulations in abstract interpretation frameworks.",
      "description_length": 556,
      "index": 3477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq",
      "library": "frama-c.kernel",
      "description": "This module defines structural equivalence for CIL predicates, providing equality, comparison, and hashing operations that respect their syntactic structure. It supports precise manipulation of predicate values in data structures like sets, maps, and hash tables, ensuring correct behavior based on deep structural identity rather than reference equality. Use cases include static analysis tasks that require accurate equivalence checks, such as caching analysis results keyed on predicates or maintaining collections of unique predicate expressions.",
      "description_length": 550,
      "index": 3478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Build",
      "library": "frama-c.kernel",
      "description": "This module creates and manages hooks that accept parameters of type `P.t` and execute registered functions in order of registration. It supports adding, removing, and applying functions, with utilities to check presence, count, or clear extensions. Concrete use cases include dynamically extending analysis phases or instrumentation points in static analysis tools.",
      "description_length": 366,
      "index": 3479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_weak",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table for hashconsing values of a specific datatype, ensuring memory-efficient sharing of structurally equivalent values. It provides operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Use cases include managing interned values during static analysis where structural equivalence is key, such as abstract syntax trees or analysis facts, without persisting them to disk.",
      "description_length": 475,
      "index": 3480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem",
      "library": "frama-c.kernel",
      "description": "This module directly handles CIL-level enumeration constants (`enumitem` values), providing precise equality checks, ordering, hashing, and deep copying for individual enum items. It supports static analysis tasks requiring accurate manipulation of C enumeration values, such as tracking constants across translation units or comparing enum definitions. The module also includes utilities for pretty-printing, membership testing within projects, and structural representation, making it suitable for plugins analyzing or transforming C code based on enumerations.",
      "description_length": 563,
      "index": 3481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath",
      "library": "frama-c.kernel",
      "description": "This module implements type-safe, normalized filepaths with equality, comparison, and hashing operations, ensuring consistent path handling across analyses. It supports concrete use cases such as tracking source files, managing dependencies, and caching file metadata using sets, maps, and hash tables keyed by filepaths. The module enables precise file path manipulation and safe, efficient lookups in data structures tailored for project resource management.",
      "description_length": 460,
      "index": 3482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_var",
      "library": "frama-c.kernel",
      "description": "This module manages stateful mappings between logic variables and their AST difference correspondences, supporting operations like binding, lookup, iteration, and change tracking. It works with project-specific hash tables where keys are logic variables (`Cil_types.logic_var`) and values include metadata requiring custom rehashing, serialization, and memoization. It is used in scenarios like AST differencing across project versions, incremental analysis, and merging logic variable states while preserving correctness under projectified transformations.",
      "description_length": 557,
      "index": 3483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Function",
      "library": "frama-c.kernel",
      "description": "This module provides operations to create and inspect function types with optional labeled parameters. It works with type values representing functions, allowing instantiation with a label and retrieving the argument and return types along with the label. Concrete use cases include building and analyzing ML function types with labeled arguments in a type-safe manner.",
      "description_length": 369,
      "index": 3484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Set",
      "library": "frama-c.kernel",
      "description": "This module provides functions to update the representative of various AST elements during visitor traversal, ensuring consistency in the current visitor state. It supports specific CIL types such as `varinfo`, `compinfo`, `stmt`, and other structured types involved in Frama-C's AST manipulation. Use cases include rewriting or redirecting references to AST nodes during transformations, such as inlining or restructuring code elements while preserving semantic relationships.",
      "description_length": 477,
      "index": 3485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cmdline.Group",
      "library": "frama-c.kernel",
      "description": "This module represents a group of command-line options, providing access to the group's name and a default group instance. It works with the `t` type, which encapsulates command-line option groups. Concrete use cases include organizing related command-line flags under a common group for better user documentation and option management.",
      "description_length": 336,
      "index": 3486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Names",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve and manipulate property names and basenames. It operates on `Frama_c_kernel.Property.identified_property` values, generating unique identifiers and truncated basenames. Useful for labeling and tracking properties during analysis, especially when handling large sets of ACSL annotations.",
      "description_length": 329,
      "index": 3487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Type_namespace",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating logic type namespaces, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing logic type namespaces, alongside project skeletons for contextual checks. Concrete use cases include comparing and storing logic type namespaces, checking project membership, and generating human-readable representations for debugging or user output.",
      "description_length": 446,
      "index": 3488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Set",
      "library": "frama-c.kernel",
      "description": "This module supports operations for managing ordered sets of program properties, including standard set algebra (union, intersection, difference), membership queries, ordered traversal (e.g., min/max selection, range-based iteration), and transformations via mapping or filtering. It works with immutable sets of `Frama_c_kernel.Property.t` elements, leveraging a total ordering for efficient operations like nearest-element search or project-specific queries. Typical use cases involve static analysis tasks requiring precise property set manipulation, such as tracking program invariants, performing set-based reasoning, or handling hierarchical project data.",
      "description_length": 661,
      "index": 3489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info",
      "library": "frama-c.kernel",
      "description": "This module implements logic type information handling for CIL-based static analysis, providing deep copy, equality, comparison, and pretty-printing operations for `logic_type_info` values. It supports precise type constraint management through structural descriptors, hashing, and project membership checks, enabling accurate type tracking during analysis. The Set, Map, and Hashtbl submodules offer efficient data structure operations tailored for logic type metadata association, transformation, and querying in program analysis workflows.",
      "description_length": 542,
      "index": 3490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Set",
      "library": "frama-c.kernel",
      "description": "This module implements **immutable ordered sets of rational numbers** with operations for insertion, deletion, union, intersection, and ordered traversal (via `min_elt`, `max_elt`, or `elements`). It supports transformations (`map`, `filter`), membership checks (`mem`, `subset`), and conversions to lists/sequences, while enabling directional searches (`find_first`, `find_last`) and nearest-element queries. Designed for scenarios requiring precise, ordered rational number set manipulations\u2014such as symbolic analysis, mathematical modeling, or formal verification\u2014it ensures functional purity and efficient ordered processing through its structure.",
      "description_length": 651,
      "index": 3491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise.Make_bitwise",
      "library": "frama-c.kernel",
      "description": "This module implements a lattice structure for bitwise maps over memory zones, supporting operations like join, meet, and inclusion checks, alongside interval-based map manipulations such as merging, filtering, and folding over abstract domains like `LOffset.t`, `Zone.t`, and `Base.t`. It is designed for static analysis tasks such as tracking memory access patterns and verifying pointer arithmetic, with utilities for managing project-specific state via cache resets during analysis transitions.",
      "description_length": 498,
      "index": 3492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations for managing key-value associations where keys represent memory zone bases, supporting efficient insertion, deletion, combination, and transformation of mappings. It works with maps binding `Frama_c_kernel.Base.t` keys (representing memory validity regions) to arbitrary values, enabling ordered iteration, filtering, and conversion to sequences or lists. Typical use cases include memory validation and region tracking, where maintaining strict key ordering and leveraging physical equality optimizations ensure efficient manipulation of addressable memory zones.",
      "description_length": 608,
      "index": 3493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filesystem.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides infix operators `let*`, `let+`, and `let$` for concise handling of file operations that return `result` or raise exceptions. It works with file channels and functions that process files safely or with explicit error handling. Concrete use cases include chaining file reads and writes while propagating errors, or handling exceptions from file operations in a streamlined way.",
      "description_length": 396,
      "index": 3494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AggressiveMerging",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manage a boolean kernel option that controls aggressive merging behavior, including setting, retrieving, and reacting to value changes. It operates on internal state flags and integrates with Frama-C's project state system, supporting custom serialization and alias handling. Specific use cases include enabling or disabling aggressive merging during static analysis to optimize memory usage or analysis precision.",
      "description_length": 448,
      "index": 3495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing source code elements annotated with location information, including equality, comparison, hashing, and pretty-printing. It works with the `Localizable.t` type, representing AST nodes with positional data, and provides utilities for deep copying, membership testing within projects, and descriptor handling. Concrete use cases include tracking and comparing source code regions during pretty-printing, enabling structured data manipulation in static analysis tasks, and supporting precise AST transformations based on location-aware elements.",
      "description_length": 585,
      "index": 3496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Float_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a reference to a float value within a project's state, providing operations to set, get, and clear the value. It supports hooks for tracking changes and custom serialization for the float reference. Use it to maintain and observe numeric state variables in static analysis plugins.",
      "description_length": 313,
      "index": 3497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Verbose",
      "library": "frama-c.kernel",
      "description": "This module provides configuration management for integer-based verbosity levels, supporting operations to set, increment, and constrain values within bounded ranges. It enables dynamic adjustment through change hooks and name aliases, serving plugin development scenarios that require state tracking and integration with Frama-C's plugin system for adjustable diagnostic output.",
      "description_length": 379,
      "index": 3498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.Preprocessor",
      "library": "frama-c.kernel",
      "description": "This module defines configuration parameters for the C preprocessor used by Frama-C, including the command path, whether it is the default configured preprocessor, and its compatibility with GCC-like options. It provides boolean flags to check comment preservation, GNU-like behavior, and environment variable overrides, along with a list of supported architecture options for preprocessor command matching. Concrete use cases include selecting appropriate preprocessor arguments based on target architecture and ensuring compatibility with annotation-preserving modes.",
      "description_length": 569,
      "index": 3499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info",
      "library": "frama-c.kernel",
      "description": "This module implements operations for handling built-in logic metadata in CIL, including equality, comparison, hashing, and pretty-printing of `builtin_logic_info` values. It provides utilities for deep copying, project membership checks, and managing representative values of the type. The associated Set, Map, and Hashtbl submodules enable efficient set operations, associative mapping by typed identifiers, and imperative hash table management, specifically supporting static analysis tasks involving logic function properties and verification conditions.",
      "description_length": 558,
      "index": 3500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Make_Table",
      "library": "frama-c.kernel",
      "description": "This module implements a project-scoped hash table that maps kernel functions to arbitrary data, enabling operations like insertion, lookup, iteration, and folding over function-specific entries. It supports advanced features such as change tracking via hooks, serialization of stored values, and maintaining consistent state across project transitions. Typical use cases include caching analysis results per function, managing plugin-specific metadata during slicing or transformations, and synchronizing data modifications with project lifecycle events.",
      "description_length": 555,
      "index": 3501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Model_info",
      "library": "frama-c.kernel",
      "description": "This module implements a project-scoped key-value store with string keys and logic environment model data as values, offering operations for atomic updates, iteration, and dependency tracking through change hooks. It manages a global, project-specific hashtable with support for immutability constraints and custom serialization, while the associated Datatype module handles key rehashing and input normalization. The structure is optimized for static analysis scenarios requiring consistent model state tracking across project boundaries, such as memoizing analysis results or coordinating logic environment modifications.",
      "description_length": 623,
      "index": 3502,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Frama_c_builtins",
      "library": "frama-c.kernel",
      "description": "This module manages a symbol table for built-in C functions during CIL processing, offering operations to bind function names to `varinfo` entries, retrieve or replace them, and iterate over sorted or unsorted collections. It employs hashtables to map keys (function names) to individual or lists of `varinfo` values, supporting change tracking via hooks and state lifecycle management, which is critical for static analysis tasks like resolving built-in function references during initial parsing of Frama-C's libc headers.",
      "description_length": 524,
      "index": 3503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Make",
      "library": "frama-c.kernel",
      "description": "This module implements type-checking and coercion logic for ACSL annotations and expressions, operating on terms, predicates, and logic types. It provides functions to resolve field types, construct casts, infer common types in conditionals, and validate annotations against a logic environment. Concrete use cases include verifying function contracts, checking term consistency in comparisons, and translating parsed logic expressions into typed constructs.",
      "description_length": 458,
      "index": 3504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL statements, including equality, comparison, hashing, and pretty-printing. It provides functions to inspect statement properties, such as location retrieval and project membership checks, and supports deep copying of statements. Concrete use cases include static analysis tasks that require precise control over individual statements, such as rewriting code structures, tracking control flow, or extracting statement metadata during C code analysis.",
      "description_length": 500,
      "index": 3505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Unset_orig",
      "library": "frama-c.kernel",
      "description": "This module provides functions to remove entries for specific AST elements from the visitor's state, targeting types like `varinfo`, `compinfo`, `stmt`, and various logic-related entities. Each function takes a visitor and an element instance, unsetting the original representative in the visitor's mapping tables. It is used during AST transformations to manage element tracking when nodes are removed or replaced.",
      "description_length": 415,
      "index": 3506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic4",
      "library": "frama-c.kernel",
      "description": "This module provides functions to create and manipulate polymorphic type values with four type parameters. It allows instantiation of a polymorphic type with specific type arguments, checking if a type is an instance of a polymorphic type, and extracting the type arguments from an instantiated polymorphic type. It works directly with type values from the `Type` module, supporting concrete use cases such as building and deconstructing complex polymorphic types in static analysis plugins.",
      "description_length": 491,
      "index": 3507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AstDiff",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that enables or disables AST differencing functionality, providing operations to toggle its state (`on`/`off`) and track changes via hooks. It operates on a dedicated state type (`AstDiff.t`) integrated with Frama-C's parameter system, supporting project-specific persistence and marshaling customization. The feature is used to control AST comparison behavior during static analysis, particularly when analyzing code transformations or version differences in C programs.",
      "description_length": 520,
      "index": 3508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Copy",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean option that controls copying behavior in the Frama-C kernel, offering operations to set, retrieve, reset, and monitor its state. It integrates with a Datatype module for deep copying complex structures and supports project-specific state management, marshaling, and alias handling. This functionality is used to enable or disable copy operations during program analysis and to manage related kernel behaviors.",
      "description_length": 439,
      "index": 3509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array",
      "library": "frama-c.kernel",
      "description": "This module implements operations for arrays of a given type `T`, including equality, comparison, hashing, and pretty-printing. It supports working with project-based data through `mem_project` and provides deep copying to ensure no shared references. Concrete use cases include managing collections of values in Frama-C plugins, such as sets of analysis results or configurable parameters.",
      "description_length": 390,
      "index": 3510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for ordering ACSL properties based on kernel function name, instruction context, property kind, and identifier. It provides equality, comparison, hashing, and pretty-printing functions for `identified_property` values, along with deep copying and project membership checks. Concrete use cases include organizing proof obligations in a deterministic sequence and managing property sets or maps during static analysis where consistent ordering is essential for analysis stability and result reproducibility.",
      "description_length": 552,
      "index": 3511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PreprocessAnnot",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls annotation preprocessing behavior during kernel execution, offering operations to set, query, and monitor changes to its state. It operates on a typed boolean value (`t`) extended with metadata and hooks, enabling custom marshaling, aliasing, and project-specific state management. Specific use cases include toggling annotation preprocessing via the `-pp-annot` flag and integrating domain-specific logic through value-change callbacks or extended data handling.",
      "description_length": 528,
      "index": 3512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports efficient mutable key-value storage and traversal using normalized filepaths as keys, offering imperative operations like insertion, removal, and lookup alongside bulk transformations such as filtered iteration and sequence conversion. It works with hash tables mapping `Frama_c_kernel.Filepath.t` keys to arbitrary values, enabling use cases like memoization, bulk metadata association, and ordered traversal of filepath-indexed data with customizable comparison logic. Sorted iteration and folding operations facilitate structured analysis of file-related state, particularly useful in static analysis tools handling path-sensitive computations.",
      "description_length": 668,
      "index": 3513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons",
      "library": "frama-c.kernel",
      "description": "This module provides structural comparison, hashing, and deep copying for arbitrary data types through hash-consed representations, ensuring unique identifiers for equal values. It includes optimized set, map, and hash table implementations for managing state in Frama-C plugins, supporting monotonic transformations and memoization. The design facilitates project-aware data tracking, where unique identifiers enable efficient equality checks and state management across different analysis phases.",
      "description_length": 498,
      "index": 3514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register",
      "library": "frama-c.kernel",
      "description": "The module facilitates plugin registration and provides comprehensive logging, error handling, and configuration management capabilities. It operates on logging categories, verbosity levels, and typed parameters (e.g., booleans, integers, strings, file paths) to enable user-configurable settings, command-line integration, and persistent state management. These features are utilized for diagnostics, conditional execution based on analysis contexts, and synchronization with Frama-C's project model and serialization systems.",
      "description_length": 527,
      "index": 3515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Array",
      "library": "frama-c.kernel",
      "description": "Implements variable-length arrays for state builders, using a data module for element operations. Provides direct access to elements by index, iteration, and folding operations. Useful for managing dynamic collections of values within analysis plugins, such as tracking variable states or constraint sets.",
      "description_length": 305,
      "index": 3516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var",
      "library": "frama-c.kernel",
      "description": "This module defines logic variables used in CIL-based program analysis, providing operations for equality, comparison, hashing, and pretty-printing. It supports static analysis plugins by enabling deep copies, project membership checks, and integration with structural descriptions. The associated Set, Map, and Hashtbl submodules offer efficient, ordered, and hashed data management tailored for logic variable manipulation in analysis tasks.",
      "description_length": 443,
      "index": 3517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnspecifiedAccess",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls handling of unspecified memory accesses, offering operations to set, retrieve, and monitor its state through hooks and project-specific value tracking. It works with a custom `t` type to encapsulate the option's configuration and an internal boolean flag to enforce behavior during analysis. It is specifically used in kernel development to customize memory access checks and integrate with Frama-C's analysis workflows.",
      "description_length": 478,
      "index": 3518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing ordered integer sets, including element insertion, removal, union, intersection, and difference, along with ordered traversal, filtering, and membership checks. It works with integer sets represented as `t` values, which maintain elements in increasing order and automatically convert to intervals when exceeding a size threshold, returning results as `set_or_top` or `set_or_bottom` to handle cardinality constraints. It is particularly useful in static analysis contexts for tracking value ranges, performing precise set reductions, or iterating over ordered integer domains with conditional filtering.",
      "description_length": 649,
      "index": 3519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralDebug",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manipulate an integer-based debugging parameter, including range constraints, incrementing, and change notifications, alongside mechanisms to serialize state and associate aliases. It works with a simple integer state enriched with metadata for project-specific contexts, enabling use cases like dynamic debug level adjustment, bounded counter abstractions for resource control, and persistent state introspection through custom marshaling.",
      "description_length": 473,
      "index": 3520,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cabshelper.Comments",
      "library": "frama-c.kernel",
      "description": "This module manages comments associated with Cabs locations using a stateful store. It provides operations to add, retrieve, iterate over, and fold across comments linked to specific Cabs location identifiers. Useful for tracking and manipulating source code annotations during static analysis tasks.",
      "description_length": 300,
      "index": 3521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Binary_Predicate",
      "library": "frama-c.kernel",
      "description": "This module implements a binary cache for storing and querying boolean results based on pairs of values from two distinct hashable types, H0 and H1. It supports operations to clear the cache and to merge (query) results by checking if a given predicate holds for a specific H0 and H1 pair. It is useful for optimizing repeated computations that compare or combine values from two separate domains, such as type checking or constraint solving.",
      "description_length": 442,
      "index": 3522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.States",
      "library": "frama-c.kernel",
      "description": "Iterates, folds, and finds registered states, providing their values and computation status for a given project. Works with state values of any typed `'a`, string identifiers, and project contexts. Useful for inspecting or manipulating analysis state during static analysis, such as retrieving or traversing state values tied to specific projects.",
      "description_length": 347,
      "index": 3523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Varinfo_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations for managing `Varinfo` keys with associated data, including insertion, lookup, iteration, and change tracking via hooks. It facilitates project-specific state management and memoization in static analysis plugins, particularly for scenarios requiring persistent variable information across analysis phases or inter-procedural dataflow tracking. The structure supports efficient modification monitoring and serialization customization, aligning with Frama-C's kernel requirements for plugin-driven analysis consistency.",
      "description_length": 559,
      "index": 3524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for optional values based on the parameter module `T`. It provides standard operations including equality, comparison, hashing, pretty printing, and deep copying, along with support for project membership checks. It is used to handle optional data in a type-safe manner, such as representing the presence or absence of a computed value in static analysis.",
      "description_length": 386,
      "index": 3525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval",
      "library": "frama-c.kernel",
      "description": "This module implements structural manipulation of CIL left-values (lvals), providing equality, comparison, hashing, and pretty-printing operations. It supports deep copies, project membership checks, and standard data structures like sets, maps, and hash tables for efficient lval-based associations. Concrete use cases include tracking memory locations during static analysis and managing variable bindings with structural identity.",
      "description_length": 433,
      "index": 3526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingForce",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that governs function call unfolding behavior during analysis, offering operations to set, retrieve, and track changes to its state. It works with a boolean flag and associated internal state, integrating hooks for value updates, custom marshaling, and project-specific state management. It is specifically used to control the aggressiveness of function call expansion in Frama-C's kernel analysis via the `-ulevel-force` flag.",
      "description_length": 471,
      "index": 3527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.TypeCheck",
      "library": "frama-c.kernel",
      "description": "This component provides configuration management and state observation for a boolean type-checking option, enabling dynamic control through command-line flags, serialization, and callback hooks. It operates on a polymorphic state type and integrates with project-specific data to manage runtime behavior adjustments during static analysis. Key applications include toggling type checking during code analysis and synchronizing configuration changes across tool sessions.",
      "description_length": 470,
      "index": 3528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadState",
      "library": "frama-c.kernel",
      "description": "This module manages state transitions and configuration for project loading workflows, focusing on operations like setting and validating file paths, registering state change hooks, and handling aliased files. It works with `Frama_c_kernel.Filepath.t` for path manipulation and tracks loaded project states through computed status flags and default value handling. Specific use cases include processing `-load` command-line arguments, serializing state with custom marshaling, and ensuring consistency checks for empty or invalid load paths during project initialization.",
      "description_length": 571,
      "index": 3529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt_Id",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling statement identifiers in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `stmt` type representing CIL statements. Concrete use cases include tracking and comparing individual statements within a C program's control flow graph.",
      "description_length": 307,
      "index": 3530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_Two",
      "library": "frama-c.kernel",
      "description": "This module implements a binary cache for combining values of two different types, `H0.t` and `H1.t`, into a result of type `R.t`. It supports `clear` to reset cached results and `merge` to apply a function to pairs of inputs, caching the outputs. Use it when efficiently combining and reusing computations across two distinct value domains, such as abstract analysis states or intermediate representations.",
      "description_length": 407,
      "index": 3531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports hash table operations for managing key-value pairs with structured keys from the Key module, enabling efficient lookups, in-place updates, and traversal via functions like `add`, `find`, and `filter_map_inplace`. It works with memory-managed data structures, offering utilities for custom sorting, memoization, and safe value retrieval through typed hash tables. Typical applications include static analysis tasks requiring associative storage with precise key handling, such as tracking program states or caching computed results during code analysis.",
      "description_length": 573,
      "index": 3532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast.UntypedFiles",
      "library": "frama-c.kernel",
      "description": "This module manages a list of untyped CABS files, providing direct access and modification capabilities through `get` and `set`. It works with the `Frama_c_kernel.Cabs.file` list type, representing parsed but untyped C abstract syntax trees. Use cases include low-level AST manipulation and analysis during C code processing in Frama-C plugins.",
      "description_length": 344,
      "index": 3533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsGenerate",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that governs the handling of assembly contracts in static analysis. It provides state manipulation capabilities through direct flag toggling, change notification hooks, and persistence mechanisms across project sessions. The implementation centers on kernel option structures with associated metadata, enabling use cases like conditional contract generation during low-level code analysis and extension-specific behavior customization.",
      "description_length": 484,
      "index": 3534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Modules",
      "library": "frama-c.kernel",
      "description": "This module offers project-aware hash table management with operations for key-value storage, retrieval with memoization, and change tracking via event hooks. It works with string keys paired with string-source location values, leveraging custom key rehashing and project-specific state. The functionality supports use cases like caching computed results with context-sensitive invalidation, maintaining project-specific metadata with atomic updates, and synchronizing state changes across components through callback subscriptions.",
      "description_length": 532,
      "index": 3535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.Simple_forward",
      "library": "frama-c.kernel",
      "description": "Implements a forward data flow analysis over a user-defined domain `P`, computing pre- and post-states for each reachable statement. Provides direct access to the pre-state and post-state of any statement, and supports traversal of all reachable statements with their associated pre-states. Useful for analyses that require propagating information from function entry points to all reachable code points, such as constant propagation or liveness analysis.",
      "description_length": 455,
      "index": 3536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTO",
      "library": "frama-c.kernel",
      "description": "This module implements the Bourdoncle algorithm to compute weak topological orderings (WTOs) for control flow graphs represented using interpreted automata. It provides functions to partition a graph into strongly connected components with a given priority function, and to pretty-print or compare these components and partitions. Concrete use cases include optimizing abstract interpretation by structuring the analysis according to the control flow hierarchy, and enabling efficient fixpoint computations over program CFGs.",
      "description_length": 525,
      "index": 3537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.BigIntsHex",
      "library": "frama-c.kernel",
      "description": "This module manages configuration and state for a kernel option that governs hexadecimal big integer representation, offering operations to set, increment, and constrain integer parameters within defined ranges. It works with integer-valued configuration parameters, supporting dynamic updates, serialization, and integration into Frama-C's project management system. Typical use cases include adjusting analysis behavior via command-line flags, enforcing valid parameter ranges during configuration, and synchronizing option changes with project state transitions.",
      "description_length": 565,
      "index": 3538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make_bitwise",
      "library": "frama-c.kernel",
      "description": "This module provides interval maps with bitwise semantics, supporting operations to create, query, and combine maps by merging values across intervals through lattice operations like `join` and inclusion checks. It works with interval-based data structures where each interval maps to a value, enabling introspection, cache-aware optimizations, and fused interval manipulations. These capabilities are particularly useful in static analysis for merging dataflow information across program intervals while maintaining efficient, structured value relationships.",
      "description_length": 559,
      "index": 3539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo",
      "library": "frama-c.kernel",
      "description": "This module implements operations for comparing, hashing, and pretty-printing CIL composite type descriptors (`Compinfo.t`), including deep copy and project membership checks. It provides foundational utilities for managing structural and semantic properties of C `struct` and `union` type definitions during static analysis. These functions support tasks such as type equivalence checking, transformation of composite types, and integration with analysis-specific data mappings.",
      "description_length": 479,
      "index": 3540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Make",
      "library": "frama-c.kernel",
      "description": "This module creates and manages an extensible hook with functions that take no arguments and return no value. It supports registering new functions, applying them in registration order, checking the hook's state, and clearing or counting entries. It is useful for tracking and executing side-effecting actions at specific program points without requiring input or producing output.",
      "description_length": 381,
      "index": 3541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make",
      "library": "frama-c.kernel",
      "description": "This module manages interval-based mappings between integer ranges and abstract values, offering operations to create, slice, and transform these maps using interval arithmetic and lattice operations like join, widen, and narrow. It supports static analysis tasks such as merging memory states, offset-based slicing, and abstract interpretation by enabling precise control over interval precision and value transformations. The data structures involve interval maps (`t`) parameterized over abstract value types (`v`) and integer intervals (`Ival.t`), with patterns for cache-aware updates and project-specific membership checks.",
      "description_length": 629,
      "index": 3542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedDowncast",
      "library": "frama-c.kernel",
      "description": "This module controls the behavior of signed downcast warnings in Frama-C's kernel by managing a boolean option that enables or disables diagnostic messages during static analysis. It provides operations to set, query, and monitor changes to this flag, along with serialization and aliasing capabilities for integration with other components. Typical use cases include adjusting analysis sensitivity to catch potential integer conversion issues or suppressing warnings when such checks are unnecessary.",
      "description_length": 501,
      "index": 3543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint",
      "library": "frama-c.kernel",
      "description": "This module implements native integer operations with support for equality, comparison, hashing, and pretty-printing. It provides core functionality for handling 32/64-bit integers in static analysis plugins, including deep copying, membership testing in projects, and standard set, map, and hash table modules optimized for deterministic processing. Use cases include tracking integer ranges, managing program state constraints, and implementing efficient key-based data structures in Frama-C plugins.",
      "description_length": 502,
      "index": 3544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This hash table implementation specializes in managing mappings from alarm keys to arbitrary values, offering creation, insertion, lookup, and in-place modification operations alongside filtering, folding, and statistics collection. It supports ordered traversal over keys, values, or entries, with sequence-based initialization and memoization capabilities for efficient data handling. Designed for alarm database management, it enables use cases like tracking alarm states, querying alarm-value associations, and aggregating statistics across alarm datasets.",
      "description_length": 560,
      "index": 3545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections",
      "library": "frama-c.kernel",
      "description": "This module creates a composite datatype combining four distinct typed components, supporting standard operations like equality, comparison, hashing, and pretty-printing. It is designed to handle structured data used in static analysis, such as program elements grouped by multiple attributes. The module is useful for representing and manipulating complex analysis results that require grouping four related values into a single unit, with support for deep copying, introspection, and project-specific operations.",
      "description_length": 514,
      "index": 3546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LogicalOperators",
      "library": "frama-c.kernel",
      "description": "This module controls the treatment of logical operators (`&&`, `||`) during parsing by managing a boolean option that determines whether they are preserved as logical expressions or converted into conditional statements. It works with kernel-level state management constructs, including serialization mechanisms and project-based configuration, to maintain and query the option's value. Its use is restricted to specialized analyses requiring precise handling of logical operators, despite incompatibility risks with other plugins.",
      "description_length": 531,
      "index": 3547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Config_dir",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve configuration directories and files by name, ensuring they exist and are accessible. It works with file paths represented as `Frama_c_kernel.Filepath.t` values. Use cases include locating and validating essential configuration resources during kernel initialization or plugin setup.",
      "description_length": 325,
      "index": 3548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Vid",
      "library": "frama-c.kernel",
      "description": "This module manages unique identifier generation for CIL variables. It provides the `next` function to produce a fresh integer identifier each time it is called. Useful for creating distinct variable IDs during CIL code transformations or analysis.",
      "description_length": 248,
      "index": 3549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedOverflow",
      "library": "frama-c.kernel",
      "description": "This module provides state management operations for a boolean parameter controlling unsigned overflow warnings, including functions to set, retrieve, and monitor changes to the flag's state. It works with internal kernel data structures to manipulate the `-warn-unsigned-overflow` option's value, serialization behavior, and event hooks. These capabilities are used to dynamically enable or suppress overflow-related diagnostics during static analysis of C code.",
      "description_length": 463,
      "index": 3550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling C enumeration information, including equality, comparison, hashing, and pretty-printing. It works directly with `enuminfo` structures from Frama-C's CIL intermediate representation, representing C enumeration declarations. Concrete use cases include static analysis plugins that need to analyze, transform, or report on C enumerations, such as checking enum value constraints or tracking enum usage across translation units.",
      "description_length": 468,
      "index": 3551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge",
      "library": "frama-c.kernel",
      "description": "This module defines edges in an interpreted automaton, representing control flow transitions with associated guards and actions derived from CIL expressions or instructions. It provides operations for equality, comparison, hashing, pretty-printing, deep copying, and project membership checks on edges, enabling precise manipulation and analysis of program control flow. Use cases include abstract interpretation for reachable state computation, path analysis, and program transformation where edges model transitions annotated with conditions and effects.",
      "description_length": 556,
      "index": 3552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Functions",
      "library": "frama-c.kernel",
      "description": "This module manages function-related data in the AST, providing direct access to kernel functions through operations like `get`, `find_by_name`, and `iter`. It works with CIL types such as `varinfo`, `kernel_function`, and `fundec`, enabling precise queries and transformations on function definitions and declarations. Use cases include analyzing function parameters via `get_params`, checking function existence with `mem_name`, and iterating over all functions or function definitions.",
      "description_length": 488,
      "index": 3553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with keys based on physical equality of state objects and arbitrary value types, offering operations for insertion, deletion, merging, and ordered traversal. It provides specialized functions for state-aware analysis tasks like merging value flows, tracking state transitions, and filtering program properties through ordered key comparisons. The design optimizes for static analysis scenarios requiring efficient state combination and deterministic processing of mutable project data.",
      "description_length": 521,
      "index": 3554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.SetLattice",
      "library": "frama-c.kernel",
      "description": "This module implements a lattice of sets with operations for union, intersection, inclusion checks, and higher-order traversals like folding and filtering, tailored for abstract memory zone analysis. It works with sets of elements (`O.elt`) and abstracted memory regions, supporting deep copies, hashing, and project-based membership queries. Designed for static analysis tasks such as tracking valid memory states or propagating dataflow constraints across program regions.",
      "description_length": 474,
      "index": 3555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages the resolution of state directories and files within a Frama-C kernel environment. It provides `get_dir` and `get_file` functions to locate or create paths based on string identifiers, returning validated filepaths. These operations are essential for handling plugin-specific state storage and retrieval during static analysis.",
      "description_length": 347,
      "index": 3556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Ty_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table that maps type values to associated data. It supports creating tables, adding and retrieving entries indexed by type values. This structure is useful for managing type-specific metadata in static analysis plugins.",
      "description_length": 263,
      "index": 3557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G",
      "library": "frama-c.kernel",
      "description": "This module supports construction and analysis of directed graphs where nodes represent program states and edges encode labeled dependencies, enabling queries on structural properties like connectivity and degree distribution. It provides functional traversal primitives such as labeled edge iterators, vertex mappers, and accumulators to process predecessor/successor relationships, with applications in static analysis for tracking state transitions and dependency propagation in program verification. The design facilitates transformations like dependency pruning or aggregation while preserving graph semantics for tasks like slicing or impact analysis.",
      "description_length": 657,
      "index": 3558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List",
      "library": "frama-c.kernel",
      "description": "This module implements operations for lists of values of a given type, including equality, comparison, hashing, and pretty-printing. It supports data types that require structural handling, such as those used in Frama-C's internal representations. Concrete use cases include managing collections of typed values with deep copying and project membership checks.",
      "description_length": 360,
      "index": 3559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based memory state manipulation through operations like merging, joining, and widening, alongside memory simulation primitives for writing, copying, and filtering data across bases and offsets. It works with offset-based memory maps, ordered maps, and hash tables to model memory states, supporting static analysis tasks such as precise memory modeling, data flow analysis, and symbolic state transformation in Frama-C's analysis framework.",
      "description_length": 469,
      "index": 3560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Get_orig",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve the original AST element from a visitor behavior state, mapping modified elements back to their original representations. It supports data types such as `varinfo`, `compinfo`, `enumitem`, `stmt`, `fieldinfo`, `kernel_function`, and various logic and type info structures. Use this module when analyzing or transforming C code with Frama-C plugins to track original source elements during AST manipulations.",
      "description_length": 449,
      "index": 3561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Version",
      "library": "frama-c.kernel",
      "description": "This module provides state management for a boolean command-line option that controls version-related behavior, offering functions to set, query, and monitor changes to its value. It operates on a stateful boolean type with support for default values, update hooks, and serialization, integrated with a project configuration system to persist version settings. Typical use cases include enabling/disabling version output in kernel operations and synchronizing version metadata across plugin components during analysis workflows.",
      "description_length": 528,
      "index": 3562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model",
      "library": "frama-c.kernel",
      "description": "This module provides operations for manipulating abstract memory states represented as maps from memory bases to offset maps or slices. It supports static analysis tasks through functions for merging, transforming, and querying memory states (e.g., join, widen, narrow, and inclusion checks), as well as precise updates via base addition or offset map pasting. These capabilities are used for memory state tracking, verification, and handling indeterminate/uninitialized data in abstract interpretation workflows.",
      "description_length": 513,
      "index": 3563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based operations (join, meet, narrow) and set algebra for managing memory zones represented as associations between bases and bit ranges or integer intervals, with specialized handling for top and bottom elements to model over- and under-approximations. It supports transformations, filtering, and inclusion checks over these zones using submodules like Set, Map, and Hashtbl, while enabling caching and integration with shape abstractions for interval analysis. Key applications include merging memory states during static analysis, validating program behavior under varying precision constraints, and querying memory safety properties through precise interval-based approximations.",
      "description_length": 712,
      "index": 3564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Undo",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage project state snapshots, including setting breakpoints, restoring to the last breakpoint, and clearing breakpoints. It works with project states that track internal computations dependent on the AST. Use cases include debugging analysis steps by rolling back to a prior state or managing iterative transformations on the project's data.",
      "description_length": 378,
      "index": 3565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers imperative hash table operations using project-compliant mutable state keys, enabling additions, lookups, in-place filtering, and sequence conversions. It supports ordered traversal and sorting of entries via custom comparators, value-based searches with default or memoized behaviors, and state-aware table initialization from sequences. Designed for scenarios requiring synchronized state management, it is particularly suited to Frama-C plugin development where ordered processing, stateful mutation, and integration with project-compliant data models are critical.",
      "description_length": 587,
      "index": 3566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to configure and manipulate command-line arguments for C preprocessor invocation, supporting operations like appending arguments, defining conditional categories, and tracking state changes through hooks. It works with string lists and structured collections, integrating validation mechanisms and project-specific state management for seamless interaction with Frama-C's analysis workflows. Use cases include dynamically adjusting preprocessing parameters during analysis or enforcing category-based argument constraints for different project configurations.",
      "description_length": 590,
      "index": 3567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product",
      "library": "frama-c.kernel",
      "description": "This module extends a monad with operations for binding and product, enabling composition of effectful computations that depend on or combine multiple monadic values. It provides core functions like `bind`, `product`, and `map`, along with submodules for boolean guards, option and list processing, and custom operators. Concrete use cases include structuring static analysis phases where computations must be sequenced or combined based on intermediate results, such as propagating state through conditional branches or aggregating data from multiple sources.",
      "description_length": 560,
      "index": 3568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName",
      "library": "frama-c.kernel",
      "description": "This module defines operations for named logic types in CIL, including equality, comparison, hashing, and pretty-printing. It supports static analysis tasks such as tracking and transforming logic types during code verification. The module also includes set, map, and hash table implementations for managing collections of these types efficiently.",
      "description_length": 347,
      "index": 3569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps for command-line-settable parameters, supporting insertion, deletion, ordered traversal, and value querying with deterministic key ordering. It manages mappings between typed configuration keys (`Typed_parameter.t`) and arbitrary values or lists, enabling use cases like accumulating command-line option values, transforming kernel configuration states, and generating ordered representations of parameter bindings. The module's design emphasizes safe access patterns, predicate-driven filtering, and integration with Frama-C's internal option-handling infrastructure.",
      "description_length": 616,
      "index": 3570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections",
      "library": "frama-c.kernel",
      "description": "This module implements an array type equipped with collection operations through its associated `Set`, `Map`, and `Hashtbl` submodules. It supports array values of type `T.t array` with equality, comparison, and pretty-printing functions, along with deep copying and project membership checks. It is used in static analysis plugins to manage collections of typed values, such as tracking program states or analysis results indexed by structured keys.",
      "description_length": 450,
      "index": 3571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Function",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for representing and manipulating functions from type `T1.t` to `T2.t`, including equality, comparison, hashing, and pretty-printing operations. It supports deep copying, membership testing over project skeletons, and provides type information via `ty`, `descr`, and `packed_descr`. Concrete use cases include modeling transformations between abstract domains and handling function-typed values in static analysis plugins.",
      "description_length": 456,
      "index": 3572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll",
      "library": "frama-c.kernel",
      "description": "This module implements logic types from CIL's intermediate representation with operations that avoid unrolling complex type structures. It provides standard equality, comparison, hashing, and pretty-printing for logic types, along with deep copying and project membership checks. The associated Set, Map, and Hashtbl submodules offer efficient, ordered, and hashed collections tailored for static analysis tasks such as tracking type dependencies, managing constraints, and implementing analysis algorithms that preserve type identity.",
      "description_length": 535,
      "index": 3573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Get",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve the representative of various AST elements within a visitor's current state, including variables, structures, enums, statements, and function definitions. Each function takes a visitor and an AST element, returning the element's representative in the visitor's context. It is used during AST traversal to access updated or transformed versions of elements according to the visitor's behavior.",
      "description_length": 435,
      "index": 3574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string sets and hierarchical categories to support command-line autocompletion logic, including value comparison, membership checks, and dynamic updates via registered hooks. It works with structured types like validated string parameters and categorized option groups, enabling use cases such as interactive shell autocompletion and CLI tool introspection through customizable help output and default value handling.",
      "description_length": 462,
      "index": 3575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of integer intervals with congruence constraints, supporting efficient union, intersection, difference, and membership checks while preserving structural invariants. It provides ordered traversal, filtering, and transformation operations for intervals defined by min/max bounds and modular congruence (rem/modu), along with utilities for nearest-value queries and sequence conversions. Designed for static analysis scenarios, it enables precise manipulation of integer range abstractions with modular arithmetic properties, such as tracking possible values in program variables under static analysis.",
      "description_length": 636,
      "index": 3576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables with functional transformation capabilities for mappings between addressable memory zones and arbitrary data. It supports key-based operations on `Frama_c_kernel.Base.t` keys, featuring ordered iteration, bulk sequence synchronization, and memory-safe introspection with project membership validation. Designed for program analysis tasks, it enables efficient tracking of memory zone properties, memoization of zone-dependent computations, and deterministic processing of memory state transitions through ordered folding operations.",
      "description_length": 578,
      "index": 3577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Obj_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table where keys are type-indexed and values are polymorphic. It supports operations to create, add, find, check membership, and iterate over entries. Concrete use cases include associating type-specific metadata with values in static analysis tools, such as mapping abstract types to their corresponding analysis results or attributes.",
      "description_length": 380,
      "index": 3578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Unicode",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration setting that controls Unicode handling behavior in the kernel, offering operations to enable/disable the feature, temporarily override its state during function execution, and register callbacks for state changes. It works with boolean values and leverages a datatype module to handle project-specific state persistence, including serialization. Specific use cases include adapting string processing pipelines to Unicode requirements, tracking dependencies on Unicode settings across components, and ensuring consistent state transitions during analysis sessions.",
      "description_length": 607,
      "index": 3579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_not_weak",
      "library": "frama-c.kernel",
      "description": "This module implements a hashconsing table with strong references for a specific data type, ensuring stable equality and consistent hash values across runs. It provides operations for comparing, hashing, and pretty-printing values, along with deep copying and project membership checks. Suitable for managing structured data where referential integrity and exact reproducibility are critical, such as in static analysis state tracking.",
      "description_length": 435,
      "index": 3580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL expressions (`exp`) with identity-based equality via `eid`, including structural comparison through `ExpStructEq`, and provides utilities for deep copying, hashing, pretty-printing, and project membership checks. It supports static analysis tasks such as expression tracking, constraint management, and code transformation by ensuring structural integrity and identity preservation. The associated `Set`, `Map`, and `Hashtbl` modules enable efficient, ordered, and hash-based collections keyed by expressions, used for dependency tracking, dataflow analysis, and metadata association in C program analysis.",
      "description_length": 658,
      "index": 3581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins",
      "library": "frama-c.kernel",
      "description": "This module manages plugin configuration and loading for both core and GUI environments. It provides functions to retrieve plugin paths, list and load plugins individually or in bulk, and handle dynamic module initialization. Uses string lists for paths and performs filesystem operations, supporting use cases like application startup plugin initialization or runtime extension from directories.",
      "description_length": 396,
      "index": 3582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections",
      "library": "frama-c.kernel",
      "description": "This module implements list-based collections with specialized operations for equality, comparison, and pretty-printing. It works with lists of values of type `T.t` and provides structured storage through associated sets, maps, and hash tables. Concrete use cases include managing collections of analysis entities such as variables or expressions in static analysis plugins.",
      "description_length": 374,
      "index": 3583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL lvalue offsets, which represent field or array element positions within C structures. It provides structural equality, comparison, hashing, and pretty-printing for these offsets, enabling precise analysis of C memory layouts. Concrete use cases include static analysis of struct field accesses, memory layout transformations, and tracking array index manipulations in C code.",
      "description_length": 427,
      "index": 3584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Orig_name",
      "library": "frama-c.kernel",
      "description": "This module provides functions to set, query, and monitor changes to a boolean flag that controls original name handling behavior in the kernel. It manages the flag's state alongside metadata, supporting command-line option parsing, project-specific state persistence, and integration with plugin systems through serialization and introspection capabilities.",
      "description_length": 358,
      "index": 3585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyCfg",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that enables or disables control flow graph (CFG) simplification, offering operations to toggle its state, register update callbacks, and persist its value through marshaling. It operates on a boolean type `t` and leverages the `Datatype` module to handle state synchronization and serialization, aligning with Frama-C's plugin development patterns. It is specifically used to dynamically control CFG simplification during static analysis or integrate custom logic with Frama-C's state management system.",
      "description_length": 553,
      "index": 3586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-preserving operations for Hptmaps where values form a lattice, supporting queries (e.g., membership checks, extremal bindings), transformations (e.g., filtering, mapping, merging with custom strategies), and lattice-specific operations like join, meet, and inclusion checks. It enables advanced abstract interpretation tasks through heterogeneous folds, prefix-based manipulations, and shape-driven constructions, targeting scenarios requiring compositional analysis of map-structured data with lattice semantics. Applications include static analysis frameworks where precise merging of map-shaped abstract states or symbolic execution paths is critical.",
      "description_length": 683,
      "index": 3587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Cabs_file",
      "library": "frama-c.kernel",
      "description": "This module provides operations for working with CABS file representations, including equality checks, comparison, hashing, and pretty-printing. It supports data types related to CIL's abstract syntax trees for C programs, enabling deep copies and membership checks for project-related values. Concrete use cases include analyzing or transforming C source files within Frama-C plugins, such as during parsing, rewriting, or inter-procedural analysis.",
      "description_length": 450,
      "index": 3588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Gcc_builtin_templates_loaded",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean state associated with GCC built-in templates in Frama-C's kernel, providing operations to set, get, and clear the state, along with hooks for change and update notifications. It supports custom marshaling for serialization and ensures project-specific state isolation. Concrete use cases include tracking whether GCC built-in types have been fully loaded and processed during static analysis, enabling analysis plugins to synchronize their behavior based on the completion of built-in type registration.",
      "description_length": 533,
      "index": 3589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product",
      "library": "frama-c.kernel",
      "description": "This module extends a minimal monad with support for product operations, enabling the combination of two monadic values into a pair within the same monadic context. It builds on a base monad that provides `return`, `flatten`, `map`, and `bind`, adding `product` to handle parallel composition of effects. Concrete use cases include combining multiple effectful computations that must both succeed, such as reading two files in a row or validating two inputs independently before proceeding.",
      "description_length": 490,
      "index": 3590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for handling lists of optional values, including `iter`, `map`, and `fold_left` functions that propagate `None` when any element computation fails. It works with lists of type `'a list` and functions returning `'b option`, enabling safe chaining of operations that may fail. Use it to process sequences where each step depends on the success of the previous, such as parsing or validation pipelines.",
      "description_length": 439,
      "index": 3591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing syntactic scopes in CIL code structures, including equality, comparison, hashing, and pretty-printing. It provides utilities for deep copying, project membership checks, and handling representants of scope descriptors. The associated `Set`, `Map`, and `Hashtbl` modules enable efficient scope-based data tracking, analysis result memoization, and context-sensitive transformations in static analysis workflows.",
      "description_length": 454,
      "index": 3592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsInitialized",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean option that controls whether assembly contracts enforce initialization checks. It works with a boolean state value and project-specific data tracked via the `Datatype` module, offering functions to toggle the flag, register change hooks, and customize serialization. The primary use case is enabling or disabling initialization guarantees for assembly contracts during static analysis.",
      "description_length": 437,
      "index": 3593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidBool",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration of a boolean option (`-warn-invalid-bool`) through operations that set, retrieve, and monitor its state, along with supporting aliases and serialization. It works with boolean values and structured data via the `Datatype` module, primarily used in Frama-C kernel development to control analysis warnings related to invalid boolean expressions during static analysis.",
      "description_length": 404,
      "index": 3594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL constants, including equality checks, comparison, hashing, and pretty-printing. It supports data types like integers, floating-point numbers, and character literals as represented in CIL's intermediate language. The module is used to analyze and transform C program constants during static analysis, such as tracking constant values across expressions or optimizing constant expressions.",
      "description_length": 439,
      "index": 3595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Memo",
      "library": "frama-c.kernel",
      "description": "This module provides memoization operations for AST elements during visitor transformations, ensuring consistent bindings across project states. It supports data types like `varinfo`, `compinfo`, `stmt`, `fundec`, and other CIL AST structures by mapping them to their transformed counterparts. Concrete use cases include tracking variable mappings during code transformation passes and preserving references to AST nodes across different project versions.",
      "description_length": 455,
      "index": 3596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality for CIL expressions with strict comparison of constants and structural equivalence for expressions within `sizeof`. It provides equality, comparison, hashing, and pretty-printing functions for `Frama_c_kernel.Cil_types.exp`, ensuring that expressions with equivalent structure and size-equivalent operands are treated as indistinguishable. It is used in static analysis and transformation pipelines where canonical representation of expressions is required, such as constant propagation, deduplication, and memoization.",
      "description_length": 559,
      "index": 3597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.EagerLoadSources",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls whether source files are eagerly loaded during analysis, providing operations to toggle its state, observe changes via hooks, and persist settings across projects. It works with internal boolean state and project-specific metadata, integrating with Frama-C's plugin and project systems. Use cases include optimizing analysis startup performance by deferring source parsing or ensuring consistent source availability for plugins requiring early access.",
      "description_length": 514,
      "index": 3598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Machdep",
      "library": "frama-c.kernel",
      "description": "This module manages the `-machdep` command-line option, enabling configuration of machine-dependent settings through value parsing, path resolution for machdep files, and validation against predefined aliases. It operates on strings, file paths, and `LoadState.t` values, integrating with Frama-C's plugin framework to support static analysis tools that require architecture-specific customization. Key use cases include setting up project-specific machdep configurations, handling AST preparation for C files, and extending analysis workflows via dynamic option hooks.",
      "description_length": 569,
      "index": 3599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Share",
      "library": "frama-c.kernel",
      "description": "This module manages the retrieval and validation of directories and files within a predefined site directory. It provides operations to set or check the site directory path and to resolve specific files or subdirectories within it, ensuring they exist and are of the correct type. Concrete use cases include locating plugin-specific resources such as configuration files or shared libraries during analysis.",
      "description_length": 407,
      "index": 3600,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FramaCStdLib",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean configuration flag that controls standard library handling in Frama-C, including setting and retrieving its state, registering change notifications, and defining command-line aliases. It works with primitive boolean values and structured data through a dedicated datatype module, enabling introspection, marshaling, and project-specific state persistence. The flag directly influences whether Frama-C's analysis incorporates built-in standard library definitions or treats them as external code.",
      "description_length": 547,
      "index": 3601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Model_info",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing a hash table-like structure that maps keys to lists of data, enabling project-specific state management, update hooks, and custom marshaling. It supports sorted iteration and folding over the table while handling keys with custom `rehash` logic, avoiding pitfalls of standard hashtables. It is used in AST diffing scenarios to track model correspondence data across project versions, ensuring consistency during analysis or transformation tasks.",
      "description_length": 488,
      "index": 3602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Base",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing abstractions of memory zone bases and their validity. It provides operations for equality testing, comparison, hashing, pretty-printing, deep copying, and checking membership based on project properties. Use cases include tracking addressable memory regions in static analysis, managing memory validity during program transformation, and enabling precise memory state manipulation through sets, maps, and hash tables.",
      "description_length": 466,
      "index": 3603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Debug",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage integer-based debug options, including setting values, defining valid ranges, and observing state changes through hooks, while supporting command-line configuration via aliases and help messages. It works with integer parameters constrained by ranges, project-specific state data requiring serialization and equality checks, and integrates with Frama-C's parameter system for cross-component consistency. These features enable use cases like dynamic verbosity control during analysis, enforcing safe parameter adjustments in development workflows, and tracking debug state transitions across projects.",
      "description_length": 643,
      "index": 3604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedDowncast",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manage a boolean option that controls warnings for unsigned downcast behavior, including setting, querying, and customizing serialization. It operates on a boolean configuration value and interacts with Frama-C's kernel state to enable or disable warnings during static analysis. This is used to configure how the analysis handles unsigned downcast scenarios, such as detecting potential data loss or enforcing stricter type checking during code verification.",
      "description_length": 493,
      "index": 3605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Session_dir",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve session directories and files by name, creating paths if specified. It works with file paths represented as `Frama_c_kernel.Filepath.t` values. Use it to access or create session-specific directories and files during analysis.",
      "description_length": 269,
      "index": 3606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Axiomatics",
      "library": "frama-c.kernel",
      "description": "This module manages project-local state using projectified hashtables that associate string keys with CIL location values, supporting operations like insertion, replacement, iteration, and consistent memoization across sessions. It enables custom marshaling and change hooks for synchronization, facilitating use cases such as tracking logical axioms tied to specific code locations or implementing plugins that react to state modifications with project-specific consistency. The design ensures efficient querying, bulk updates, and event-driven extensions while avoiding rehashing pitfalls in standard hashtables.",
      "description_length": 614,
      "index": 3607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info",
      "library": "frama-c.kernel",
      "description": "This module implements operations for managing logic constructor metadata, including equality checks, comparison, hashing, and pretty-printing. It provides utilities to inspect and manipulate project-specific properties, perform deep copies, and support set, map, and hash table abstractions tailored for logic constructors. These capabilities are used in static analysis plugins to process and reason about CIL logic constructs during program verification tasks.",
      "description_length": 463,
      "index": 3608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with keys represented as arithmetic intervals (`Frama_c_kernel.Ival.t`) and polymorphic values, supporting functional updates, ordered traversal, and interval-aware operations. It provides interval-specific analysis capabilities through functions like merging overlapping intervals, filtering by range constraints, and folding over ordered key sequences, while enabling transformations, equality checks, and custom formatting. These maps are particularly suited for static analysis tasks requiring precise representation of interval-partitioned data, such as tracking variable value ranges or analyzing program behaviors over numeric domains.",
      "description_length": 678,
      "index": 3609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SaveState",
      "library": "frama-c.kernel",
      "description": "This module enables managing save-state configurations by setting and monitoring file paths for analysis state persistence, supporting hooks for state change notifications and custom serialization mechanisms. It operates on a file path type combined with internal state tracking data, facilitating use cases such as saving computed analysis results to disk, integrating with command-line options, and maintaining state consistency across project sessions.",
      "description_length": 455,
      "index": 3610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing identified logical predicates in CIL, including equality, comparison, hashing, and pretty-printing. It provides utilities for deep copying, project-aware membership checks, and maintaining representants for a structured type. Concrete use cases include tracking and comparing logical conditions across CIL code transformations and supporting static analysis plugins that require precise handling of predicate identifiers.",
      "description_length": 465,
      "index": 3611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages integer-keyed hash tables with operations for insertion, deletion, traversal, and memoization of arbitrary data values. It supports change tracking through update hooks, custom marshalling, and project-specific state synchronization via computed markers. Such structures are useful for caching computations tied to integer identifiers while maintaining consistency across state modifications.",
      "description_length": 412,
      "index": 3612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppCommand",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration and validation of custom C preprocessor commands through string-based operations, enabling users to define, retrieve, and sanitize command-line arguments for Frama-C's analysis pipeline. It works with string values representing executable commands, enforcing constraints to ensure safe invocation while supporting project-specific overrides and integration with plugin-defined behaviors. Typical use cases include setting compiler-specific preprocessor paths, validating user-provided command syntax, and dynamically adjusting preprocessing steps during analysis configuration.",
      "description_length": 615,
      "index": 3613,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.List.List",
      "library": "frama-c.kernel",
      "description": "This module extends the standard list type with monadic operations for handling non-deterministic computations. It provides functions like `iter`, `map`, and `fold_left` that chain list-producing functions, enabling branching logic where each step can yield multiple results. Use it to model search spaces, combinatorial problems, or backtracking algorithms directly through list-valued functions.",
      "description_length": 397,
      "index": 3614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AllowDuplication",
      "library": "frama-c.kernel",
      "description": "This module manages the state of a boolean option that controls duplication handling in the Frama-C kernel, offering operations to set, query, and monitor changes to the flag's value. It works with internal state tracking mechanisms and marshaling infrastructure to persist or synchronize the option's value across project sessions. The functionality is used to dynamically enable or disable duplication handling during analysis, particularly when restoring saved states or coordinating between analysis passes.",
      "description_length": 511,
      "index": 3615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.False_ref",
      "library": "frama-c.kernel",
      "description": "This module creates a mutable boolean state reference initialized to `false`, with operations to get, set, and clear the value. It supports project-specific state management with hooks for updates and change notifications, and allows custom marshaling for serialization. Useful for tracking analysis progress or controlling execution flow in static analysis plugins.",
      "description_length": 366,
      "index": 3616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Queue",
      "library": "frama-c.kernel",
      "description": "This module implements a queue data structure parameterized over a base type `T`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports concrete use cases like tracking and comparing sequences of values in static analysis plugins, particularly when managing analysis states or event logs. The module also includes project membership checks and deep copying, enabling safe manipulation of queue-based data across different analysis contexts.",
      "description_length": 488,
      "index": 3617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Log.Register",
      "library": "frama-c.kernel",
      "description": "This module supports structured diagnostic logging with severity levels and categories, offering operations like conditional output control, warning status management, and error handling. It works with types such as `warn_category`, `warn_status`, and plugin-specific logging channels, enabling developers to route messages based on source positions or categories. Typical use cases include filtering debug output, registering custom warning classes, and ensuring consistent error reporting across plugins.",
      "description_length": 506,
      "index": 3618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with rational numbers as keys and arbitrary values, supporting standard imperative operations like insertion, lookup, and iteration, along with bulk updates from sequences and ordered traversal by key. It includes utilities for memoization, table manipulation, and conversion to sequences, designed for efficient key-based computations. Such structures are particularly useful in static analysis tasks requiring precise tracking of rational-numbered program states or symbolic values.",
      "description_length": 519,
      "index": 3619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Queue",
      "library": "frama-c.kernel",
      "description": "Implements a stateful queue for managing elements of type `Data.t`, providing operations to add elements, iterate, fold, and query the queue's state. Designed for use in static analysis plugins where elements must be processed in insertion order. Supports tracking and processing queued items within Frama-C's state management framework.",
      "description_length": 337,
      "index": 3620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.JsonCompilationDatabase",
      "library": "frama-c.kernel",
      "description": "This module manages configuration and state for a JSON compilation database path, offering operations to set, retrieve, and monitor changes to the file path, along with custom marshaling for persistence. It operates on file paths (`Frama_c_kernel.Filepath.t`) and integrates project-specific state tracking and option aliasing. It is used to handle paths for JSON compilation databases during project configuration and ensure consistent option handling across sessions, particularly when interfacing with external tools expecting such databases.",
      "description_length": 545,
      "index": 3621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PointerDowncast",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean flag that enables or disables pointer downcast warnings, providing operations to set its state, observe changes through hooks, and track project-specific configurations. It operates on scalar boolean values and supports use cases like fine-tuning static analysis precision to detect unsafe pointer conversions or synchronizing warning behavior with dependent kernel extensions.",
      "description_length": 407,
      "index": 3622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset",
      "library": "frama-c.kernel",
      "description": "This module offers set-theoretic operations (union, intersection, difference, membership checks) and cache-aware transformations (merge, fold2_join_heterogeneous) for managing collections of kernel functions. It leverages ordered sets, associative maps, and hash tables to enable efficient querying, iteration, and structural manipulation of function sets. Designed for static analysis tasks, it supports use cases like call graph analysis, function interaction tracking, and cache-coherent data flow optimizations.",
      "description_length": 515,
      "index": 3623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL variable information (`varinfo`), including equality, comparison, hashing, and pretty-printing. It provides utilities for deep copying, project membership checks, and handling variable descriptors with support for sets, maps, and hash tables. Concrete use cases include tracking variable properties during static analysis, managing variable relationships in C programs, and implementing efficient data flow analysis in Frama-C plugins.",
      "description_length": 483,
      "index": 3624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCppCommands",
      "library": "frama-c.kernel",
      "description": "This module controls the visibility of C preprocessing commands during analysis via a boolean flag, enabling dynamic toggling of verbose output. It manages internal state variables, project-specific configurations, and event hooks to persist and propagate changes to the option's value. This functionality supports use cases such as debugging preprocessing steps or integrating Frama-C with external tools requiring command-line traceability.",
      "description_length": 442,
      "index": 3625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintShare",
      "library": "frama-c.kernel",
      "description": "This module offers functions to manage a boolean option controlling whether Frama-C outputs its share path, including state modification, comparison, and serialization. It operates on a boolean value and structured state data via the `Datatype` module, enabling command-line configuration and persistent project-specific behavior tracking. Use cases include toggling diagnostic output during analysis or integrating path visibility into custom workflows.",
      "description_length": 454,
      "index": 3626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label",
      "library": "frama-c.kernel",
      "description": "This module defines operations for CIL control-flow labels, including equality, comparison, hashing, and pretty-printing. It supports data structures and functions for managing individual labels and collections of labels, such as sets, maps, and hash tables. Concrete use cases include tracking label propagation in static analysis, managing label-based dependencies, and associating metadata with control-flow points in CIL code.",
      "description_length": 430,
      "index": 3627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Structural_descr.Recursive",
      "library": "frama-c.kernel",
      "description": "This module manages recursive structural descriptors by allowing the creation of placeholder references and their subsequent resolution. It works with the `recursive` type and `structural_descr.t` values, enabling the definition of self-referential type representations. A concrete use case is constructing descriptors for recursive algebraic data types, such as linked lists or trees, where a type refers to itself in its definition.",
      "description_length": 434,
      "index": 3628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost",
      "library": "frama-c.kernel",
      "description": "This module defines operations for comparing, hashing, and copying CIL term-based memory location identifiers (`Term_lhost.t`), and provides utilities for set, map, and hash table manipulations keyed by these identifiers. It supports precise tracking and analysis of term-labeled memory locations in CIL constructs, particularly useful in static analysis plugins for tasks like state tracking and dependency resolution. The module enables ordered map traversal, efficient lookups, and structural data management with concrete operations tailored for program analysis workflows.",
      "description_length": 577,
      "index": 3629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Globals.FileIndex",
      "library": "frama-c.kernel",
      "description": "This module manages global C symbols associated with source files, providing access to variables, functions, and annotations defined at the file level. It supports querying symbols by file path, retrieving lists of files with global symbols, and filtering functions based on declarations. Concrete use cases include analyzing global variable initializations, extracting function definitions for inter-procedural analysis, and handling annotations in specific source files.",
      "description_length": 472,
      "index": 3630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Consolidation",
      "library": "frama-c.kernel",
      "description": "This module consolidates the status of properties based on the status of their hypotheses, handling complex dependencies and logical implications. It works with property sets, emitters, and project skeletons to determine final statuses such as `Valid`, `Invalid`, or `Unknown`, along with their hypothesis dependencies. It is used to determine the verification state of a property in the context of static analysis, particularly when some hypotheses remain unverified or conflicting.",
      "description_length": 483,
      "index": 3631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Make_Hashconsed_Lattice_Set",
      "library": "frama-c.kernel",
      "description": "This structure provides hash-consed lattice sets with operations combining set theory and lattice semantics, including union, intersection, membership checks, and lattice joins/narrows. It works with parameterized elements from module `O`, representing sets as either a collection or a top element, and maintains deterministic hashing for efficient equality checks. Designed for static analysis contexts where precise set manipulation and optimized hash-based comparisons are critical, such as tracking program state abstractions in verification tools.",
      "description_length": 552,
      "index": 3632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural",
      "library": "frama-c.kernel",
      "description": "This module provides graph manipulation and analysis operations for control flow graphs with normalized unnatural loops, focusing on loop restructuring and abstract interpretation tasks. It works with versioned vertices and edges, Weak Topological Orderings (WTO), and vertex tables to support control flow transformations, dataflow analysis, and state tracking during program verification. Specific use cases include loop normalization for static analysis, forward/backward dataflow propagation, and generating DOT representations of CFGs with single-entry loop structures.",
      "description_length": 574,
      "index": 3633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Stmt",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for managing and memoizing statement-level AST differences using project-specific hashtables that map `Stmt.key` to `code_correspondence` values, with support for binding manipulation, change tracking, and iteration. It addresses custom key rehashing requirements to ensure correctness in projectified contexts, while offering utilities for serialization and pretty-printing. The operations are specifically designed for use cases like diff computation and version comparison between ASTs.",
      "description_length": 524,
      "index": 3634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.ReadAnnot",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean configuration flag that controls the `-read-annot` behavior in Frama-C's kernel, including setting its value, registering change observers, handling aliases, and persisting state across projects. It operates on boolean values paired with metadata, using hooks and marshaling mechanisms to synchronize and track modifications. Typical use cases involve enabling or disabling annotation parsing during analysis and ensuring consistent state management across plugin interactions.",
      "description_length": 529,
      "index": 3635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for abstract integer keys (`Frama_c_kernel.Int_val.t`) and arbitrary values, offering imperative operations like insertion, deletion, lookup, and bulk transformations (e.g., `fold`, `iter`, `filter_map_inplace`). It supports ordered traversal, value-based comparisons, and memoization, tailored for static analysis scenarios such as tracking integer value abstractions and managing arithmetic over-approximations in Frama-C's value analysis framework.",
      "description_length": 499,
      "index": 3636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Funspec",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling function specifications in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `funspec` type, representing C function specifications. Use cases include analyzing or transforming function contracts during static analysis, and managing specification data across different projects.",
      "description_length": 357,
      "index": 3637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enumitem",
      "library": "frama-c.kernel",
      "description": "This module enables managing a stateful, project-specific mapping from `enumitem` keys to lists of diff-related data, supporting operations like insertion, replacement, iteration, and transformation. It works with hashtables that associate keys (likely based on the `Datatype` module) with dynamic lists of values, incorporating change hooks for event tracking and customizable pretty-printing for data visualization. It is particularly suited for tracking AST modifications in a project context, where maintaining precise state changes and enabling extensible data inspection are critical.",
      "description_length": 590,
      "index": 3638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lexpr",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with logical expressions in CIL, including equality, comparison, hashing, and deep copying. It provides utilities to check membership of project-specific data within expressions and to pretty-print them in a user-friendly format. The primary data type is `t`, representing logical expressions, used for analyzing and transforming C code with formal methods.",
      "description_length": 400,
      "index": 3639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.File",
      "library": "frama-c.kernel",
      "description": "This module provides operations for manipulating CIL file representations, including equality checks, comparison, hashing, and pretty-printing. It supports data types related to CIL files, such as `Frama_c_kernel.Cil_types.file`, and offers deep copying and project membership testing. Concrete use cases include analyzing or transforming C source code representations and managing file-level data during static analysis.",
      "description_length": 421,
      "index": 3640,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLib",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean option controlling whether the Frama-C kernel prints its library path, including toggling the state, querying its value, and registering callbacks for state changes. It operates on an internal boolean flag and integrates with Frama-C's project state system through custom data type operations, computed status, and serialization mechanisms. The functionality is used to dynamically configure runtime output behavior, enabling scenarios like debugging environment setups or scripting interactions with Frama-C's library paths.",
      "description_length": 577,
      "index": 3641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL code annotations, including equality, comparison, hashing, pretty-printing, and deep copying. It supports data structures like sets, maps, and hash tables for organizing annotations with precise ordering, filtering, and traversal capabilities. Concrete use cases include tracking and analyzing metadata such as preconditions, postconditions, and coverage information in static analysis workflows.",
      "description_length": 444,
      "index": 3642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_topological.Make",
      "library": "frama-c.kernel",
      "description": "This module provides `fold` and `iter` functions to traverse a graph in topological order, handling cycles by visiting each node exactly once. It operates on graphs composed of `Frama_c_kernel.State.t` nodes, structured according to the module `G`. Use it to process interdependent states in a defined sequence, such as analyzing control flow graphs where dependencies must be resolved in order.",
      "description_length": 395,
      "index": 3643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections",
      "library": "frama-c.kernel",
      "description": "This module combines three data types into a triple structure with full support for comparison, hashing, and pretty-printing. It enables precise equality checks, ordered set operations, and deep copying of composite values. Useful for tracking structured program analysis data that requires persistence and immutability across static analysis phases.",
      "description_length": 350,
      "index": 3644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make_pp",
      "library": "frama-c.kernel",
      "description": "This module generates human-readable textual representations of CIL abstract syntax trees and ACSL constructs by formatting structured elements like variables, expressions, statements, function specifications, and annotations. It operates on CIL AST nodes and logic terms using OCaml's Format module to produce output suitable for debugging, logging, or user-facing displays of program analysis data. Key use cases include rendering intermediate representations of C code during static analysis and visualizing formal specifications for verification tasks.",
      "description_length": 556,
      "index": 3645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile",
      "library": "frama-c.kernel",
      "description": "This component enables managing file-specific C preprocessor argument configurations through structured key-value mappings with alias support. It provides operations to modify, validate, and iterate over these settings while tracking changes via hooks, with internal representations supporting serialization and categorization. Useful for scenarios requiring fine-grained control over compilation flags per source file, such as integrating custom analysis tools or adapting preprocessing behavior across different project files.",
      "description_length": 528,
      "index": 3646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a State monad for managing computations that manipulate a shared environment `Env.t`. It provides core monadic operations like `return`, `bind`, and `map`, along with utilities to get and set the environment, and run computations with an initial state. Concrete use cases include tracking analysis state across program elements, such as maintaining variable bindings or analysis flags during static code analysis.",
      "description_length": 436,
      "index": 3647,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidPointer",
      "library": "frama-c.kernel",
      "description": "This module manages the state of a boolean option controlling invalid pointer warnings, providing functions to set, query, and monitor value changes through callbacks, along with alias support and serialization capabilities. It interacts with Frama-C's project and plugin infrastructure to enable use cases such as dynamically adjusting pointer validity checks during analysis, allowing plugins to respond to configuration updates, and preserving warning settings across sessions.",
      "description_length": 480,
      "index": 3648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Kernel_function",
      "library": "frama-c.kernel",
      "description": "This module provides operations for comparing and synchronizing kernel function data during AST differencing, including memoization, bidirectional lookups, and project-specific state management. It operates on kernel function representations and code correspondence mappings, utilizing hash tables with support for custom key rehashing and projectified state transitions. Specific use cases include tracking function evolution across project versions, handling state changes during project reloading, and customizing serialization for analysis continuity.",
      "description_length": 555,
      "index": 3649,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space",
      "library": "frama-c.kernel",
      "description": "This module represents linear spaces over a field, providing structured operations for vectors and matrices tailored to static analysis tasks. It supports vector arithmetic, matrix manipulation, and transformations, with fixed-dimension data structures parameterized by the scalar field. Concrete applications include computing invariants, norms, and linear transformations in verification tools.",
      "description_length": 396,
      "index": 3650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfigJson",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls JSON serialization of runtime settings, offering operations to set, retrieve, and monitor changes to the flag's state. It interacts with project state tracking mechanisms to determine if the configuration has been explicitly computed, enabling conditional execution of JSON output logic. The functionality supports use cases like dynamically enabling or disabling configuration dumps during analysis or integrating with external tools that require structured runtime metadata.",
      "description_length": 539,
      "index": 3651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational",
      "library": "frama-c.kernel",
      "description": "This module implements rational number handling with standard operations including equality, comparison, hashing, and pretty-printing. It provides deep copying, project membership checks, and type metadata for rational values represented as `Q.t`. Concrete use cases include precise numeric computations in static analysis plugins, such as tracking symbolic values, managing numeric constraints, and supporting set and map structures with rational keys.",
      "description_length": 453,
      "index": 3652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Current_loc.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides `let<>` and `let<?>` operators for binding the current location in a scoped manner, mimicking `with_loc` and `with_loc_opt` behavior. It works with `Current_loc.data` and `Current_loc.data option`, enabling precise location tracking in logging and error reporting. These operators simplify syntax when temporarily setting the current location for functions that depend on it.",
      "description_length": 396,
      "index": 3653,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.DoCollapseCallCast",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean option that controls whether implicit type casting is allowed in function call destinations. When enabled, it permits destination variables to have different types than the function's return value, avoiding intermediate temporaries and preserving code structure for analyses like memory allocation tracking, while",
      "description_length": 365,
      "index": 3654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating CIL model information, including equality checks, comparison, hashing, and pretty-printing of `model_info` values. It provides utilities to inspect and transform data related to CIL structures, such as checking project membership and performing deep copies, which are essential for static analysis tasks. The module supports structured data handling through its associated `Set`, `Map`, and `Hashtbl` submodules, enabling efficient set and map operations tailored to CIL model data management in Frama-C plugins.",
      "description_length": 573,
      "index": 3655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Fold_ordered",
      "library": "frama-c.kernel",
      "description": "This module manages ordered execution of hook functions with dependency tracking. It allows registering functions with unique keys, extending hooks with new operations, and applying them in an order that respects dependencies. Use it to sequence analysis extensions in static analysis tools where execution order matters.",
      "description_length": 321,
      "index": 3656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsAutoValidate",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean flag that enables or disables automatic validation of assembly contracts during analysis, providing functions to set, retrieve, and monitor changes to this state. It operates on a typed configuration parameter integrated with Frama-C's project-specific state tracking, supporting serialization and aliasing for compatibility with command-line interfaces and persistent settings. The flag directly controls whether assembly contract validation is triggered implicitly, with hooks available to extend its behavior for custom analysis workflows.",
      "description_length": 572,
      "index": 3657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Indexer.Make",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered collection with efficient random access and logarithmic-time modifications, optimized for GUI tree and list widgets needing fast indexing and updates. It supports operations like adding, removing, and filtering elements, as well as tracking index changes during updates. Concrete use cases include managing dynamic lists in a GUI where elements are frequently inserted, removed, or replaced, and associated views need to reflect these changes efficiently.",
      "description_length": 489,
      "index": 3658,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps for alarm-specific keys, supporting insertion, deletion, querying, and ordered traversal of key-value pairs where keys represent structured alarm data. It enables transformation, filtering, and customizable formatting of alarm states, with utilities for efficient aggregation and project metadata management. Designed for alarm analysis workflows, it facilitates deep copying, ordered iteration, and bulk updates to handle alarm databases in static code analysis contexts.",
      "description_length": 508,
      "index": 3659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Zero_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a stateful integer reference initialized to zero, providing operations to get, set, and clear the value, along with hooks for change and update events. It supports custom marshaling and project-specific state tracking, enabling integration with Frama-C's analysis workflows. Concrete use cases include tracking analysis progress counters or managing stateful configuration options across different analysis phases.",
      "description_length": 446,
      "index": 3660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String",
      "library": "frama-c.kernel",
      "description": "This module implements a string datatype with standard operations including equality, comparison, hashing, and pretty-printing. It supports static analysis tasks requiring precise string manipulation, such as identifier tracking or symbol management, and includes set, map, and hash table submodules for structured data handling. The set and map modules provide ordered collections and keyed lookups tailored for analysis passes needing efficient, deterministic traversal and transformation of string-based data.",
      "description_length": 512,
      "index": 3661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Rel",
      "library": "frama-c.kernel",
      "description": "This module represents integers relative to an absolute base, supporting arithmetic operations like addition, subtraction, and modulus checks. It works with abstract integer types to model differences between absolute values, enabling precise range analysis. Concrete use cases include tracking pointer arithmetic and array bounds in static analysis.",
      "description_length": 350,
      "index": 3662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int",
      "library": "frama-c.kernel",
      "description": "This module implements arithmetic, bitwise, and comparison operations on abstract integers with precise handling of division, overflow, and modular constraints, alongside conversions between numeric types (int, int32, int64, float) and C99-compliant integer semantics. It provides set, map, and hash table structures for managing collections of abstract integers, enabling static analysis tasks like value range tracking, overflow detection, and program state modeling through operations such as bit extraction, exponentiation, and hexadecimal/binary formatting.",
      "description_length": 562,
      "index": 3663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Serializable_undefined",
      "library": "frama-c.kernel",
      "description": "This module implements a serializable undefined type with standard marshalling support, providing equality, comparison, hashing, and pretty-printing operations. It works with arbitrary OCaml values, enabling them to be compared, hashed, and formatted for debugging or persistent storage. Concrete use cases include safely handling undefined values in analyses that require value serialization, such as inter-procedural or distributed analysis states.",
      "description_length": 450,
      "index": 3664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hpath.Names",
      "library": "frama-c.kernel",
      "description": "This module tracks associations between hierarchical paths and string identifiers, allowing clients to add, remove, and query these associations. It maintains an internal mapping used to manage named elements in the context of static analysis. Typical use cases include registering and retrieving named analysis targets or configuration settings tied to specific paths.",
      "description_length": 369,
      "index": 3665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Make_table",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized table structure that maps keys to emitter-specific data with efficient lookup, insertion, and removal. It supports operations like `add`, `find`, `mem`, and `remove`, along with iteration, folding, and sorted traversal over key-value pairs. It is used to manage per-emitter state bindings indexed by keys, such as tracking annotations or property statuses tied to specific emitters.",
      "description_length": 419,
      "index": 3666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset",
      "library": "frama-c.kernel",
      "description": "This module defines operations for comparing, hashing, and printing CIL term offsets, which represent positional information within CIL terms. It supports concrete use cases such as tracking structural dependencies in C code, managing term hierarchies, and enabling precise static analysis in Frama-C plugins. The module also includes Set, Map, and Hashtbl submodules for organizing and querying term offsets efficiently based on their total ordering and structural properties.",
      "description_length": 477,
      "index": 3667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyTrivialLoops",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean kernel option that controls whether trivial loops are simplified during static analysis, including setting, retrieving, and reacting to changes in its state. It works with Frama-C's internal kernel option system, supporting serialization, project-specific state management, and direct manipulation of the option's value. This functionality is used in code analysis and transformation workflows to optimize loop handling during program verification.",
      "description_length": 500,
      "index": 3668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Instr",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL instructions, including equality, comparison, hashing, and pretty-printing. It provides utilities to inspect and copy instruction data, as well as extract source code locations. Use cases include analyzing or transforming C code during static analysis, such as tracking control flow or modifying assignments.",
      "description_length": 360,
      "index": 3669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair",
      "library": "frama-c.kernel",
      "description": "This module defines a product type `t` as a pair of values from two other datatypes `T1` and `T2`, along with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data manipulation by providing deep copy, membership testing for project values, and type descriptors for integration with Frama-C's internal systems. Concrete use cases include representing compound analysis values such as pairs of program states or combined abstract properties.",
      "description_length": 495,
      "index": 3670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling logical real numbers in CIL, including equality, comparison, hashing, and pretty-printing. It provides deep copying, membership checks for project skeletons, and standard type representations. The associated Set, Map, and Hashtbl modules enable precise numerical set manipulations, ordered key-value storage, and hash-based lookups, specifically supporting static analysis tasks like value range tracking and constraint domain management.",
      "description_length": 482,
      "index": 3671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_builtin_used",
      "library": "frama-c.kernel",
      "description": "This module tracks logic functions and predicates used within a project. It provides operations to add, check, and iterate over logic entities associated with a given name. It is used to manage and query logic definitions during static analysis.",
      "description_length": 245,
      "index": 3672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fundec",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific hash table mapping keys to function declaration data, enabling tracking of function definitions across project versions. It supports operations like adding or replacing entries, querying presence or all values for a key, iterating over stored data, and registering hooks for change detection, with specialized handling for project state serialization and comparison. Designed for diff computation scenarios, it ensures proper handling of custom key rehashing and provides structured access to function declaration correspondences between projects.",
      "description_length": 586,
      "index": 3673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph.Node",
      "library": "frama-c.kernel",
      "description": "This module assigns unique identifiers to elements of type `M.key` and generates corresponding Dot graph nodes. It supports creating labeled nodes, records, and applying attributes like rounding or custom styles during node construction. Use it to visualize structured data, such as control flow graphs or abstract syntax trees, by mapping each element to a visual node in a Dot file.",
      "description_length": 384,
      "index": 3674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Make_Lattice_Set",
      "library": "frama-c.kernel",
      "description": "This module combines lattice and set abstractions to support abstract interpretation tasks requiring under-approximation semantics. It provides operations for set-like structures over an underlying lattice, including union, intersection, membership testing, and element-wise transformations, while maintaining lattice properties like join, meet, and narrowing. The design enables efficient analysis of program properties through both set-wise and element-level computations, particularly in domains where tracking possible values with under-approximations is critical.",
      "description_length": 568,
      "index": 3675,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Lval_hashtbl",
      "library": "frama-c.kernel",
      "description": "The module implements a memoized, observable hash table structure that maps CIL lvalues to arbitrary data values, enabling efficient lookups, insertions, and ordered iteration over entries. It supports advanced state management features like serialization, customizable memoization strategies, and hooks to trigger actions on key-value modifications, while internally tracking changes within a project's state. This structure is particularly useful for static analysis tasks requiring precise, incremental updates and dependency tracking, such as value propagation or alias analysis across translation units.",
      "description_length": 608,
      "index": 3676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.C11",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean flag controlling C11 language behavior in the analysis kernel, including setting values, registering change hooks, and defining command-line aliases. It works with a boolean state type enhanced by custom marshaling and introspection capabilities via the Datatype module. The functionality supports use cases like dynamically enabling/disabling C11-specific analysis rules and synchronizing tool behavior with project configuration changes.",
      "description_length": 491,
      "index": 3677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Set",
      "library": "frama-c.kernel",
      "description": "This component offers a suite of operations for managing immutable, ordered collections of normalized filepaths, emphasizing efficient membership queries and ordered traversal. It supports transformations through mapping and folding, subset manipulation via filtering and partitioning, and integration utilities like sequence conversion, hashing, and project-aware membership checks. Designed for scenarios requiring precise file path analysis\u2014such as static code analysis plugins or build systems\u2014it enables ordered processing, dependency resolution, and project-specific filtering while maintaining compatibility with Frama-C's plugin ecosystem.",
      "description_length": 647,
      "index": 3678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Weak",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table for managing values of type `W.t` with custom equality, comparison, and hashing. It supports operations like membership testing, deep copying, and pretty-printing, along with integration with project-based filtering via `mem_project`. The module is used to store and manipulate values that must be compared structurally and displayed in a user-friendly way, such as abstract syntax tree nodes or analysis artifacts.",
      "description_length": 456,
      "index": 3679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement.WTOIndex",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing indices in a weak topological order (WTO) specific to the CIL statement graph. It provides operations for equality checking, comparison, hashing, and pretty-printing these indices, along with utilities for deep copying and checking project membership. These functions support analysis and transformation passes that require tracking or manipulating control-flow structures in C programs.",
      "description_length": 436,
      "index": 3680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type",
      "library": "frama-c.kernel",
      "description": "This module implements logic type handling for CIL-based static analysis, providing equality, comparison, hashing, and pretty-printing operations for `logic_type` values. It supports deep copying, project membership checks, and maintains type descriptors for structural reasoning. Use cases include analyzing and transforming logical expressions in CIL code, managing type constraints during verification, and integrating logic types with custom analysis data structures.",
      "description_length": 471,
      "index": 3681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppGnuLike",
      "library": "frama-c.kernel",
      "description": "The module controls preprocessing behavior via a boolean kernel option, supporting operations to set, retrieve, and track changes to its state, along with hooks for custom marshaling and alias handling. It works with boolean values and project-specific state tracking structures, enabling use cases such as command-line option parsing, help generation, and enforcing GNU-like C preprocessing compliance during static analysis.",
      "description_length": 426,
      "index": 3682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_Three",
      "library": "frama-c.kernel",
      "description": "Implements a ternary cache for memoizing functions that take three arguments of types `H0.t`, `H1.t`, and `H2.t`, producing results of type `R.t`. The cache supports merging computations and resetting state via `clear`. Useful for optimizing repeated expensive computations over triplets of structured values, such as abstract domain elements in static analysis.",
      "description_length": 362,
      "index": 3683,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Sites",
      "library": "frama-c.kernel",
      "description": "This module defines lists of locations for various components such as libraries, plugins, GUI plugins, and shared resources. It works with `Dune_site.Private_.Helpers.Location.t` values, organizing them into separate categories. These lists are used to manage and access specific installation or resource directories within a software environment.",
      "description_length": 347,
      "index": 3684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Stateful",
      "library": "frama-c.kernel",
      "description": "This module enables constructing and transforming CIL expressions, types, and statements in a stateful context, emphasizing arithmetic, bitwise, and logical operations alongside memory manipulations, control flow, and function contract definitions. It operates on CIL abstract syntax tree nodes like expressions (`exp`), lvalues (`lval`), types (`typ`), statements (`stmt`), and initializers (`init`), supporting static analysis, program verification, and code generation tasks. Specific utilities include validity checks, initializer construction, and attribute management to build and refine CIL constructs for Frama-C's analysis pipelines.",
      "description_length": 642,
      "index": 3685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Compinfo",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific hash table mapping C composite type identifiers (`Compinfo.key`) to structural difference metadata (`Compinfo.data`), supporting operations like lookup, insertion, iteration, and change tracking with custom rehashing logic. It enables analysis of structural discrepancies in composite type definitions (e.g., structs/unions) across C projects by providing hooks for reacting to updates and utilities for marshaling and pretty-printing. The design addresses scenarios where precise AST differencing is required, such as comparing type definitions between project versions or merging divergent codebases.",
      "description_length": 641,
      "index": 3686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Make",
      "library": "frama-c.kernel",
      "description": "This module provides a suite of pretty-printing functions for converting CIL (C Intermediate Language) and Frama-C ACSL data structures\u2014such as variables, expressions, statements, logic terms, annotations, and control-flow elements\u2014into human-readable text. It operates on structured types like `instr`, `stmt`, `term_lval`, `allocation`, and `identified_predicate`, using OCaml's `Format.formatter` to handle layout and formatting. The utilities support use cases like generating debug output, displaying analysis results, or producing annotated C code representations with customizable details, such as abbreviated forms or conditional suppression of annotations.",
      "description_length": 665,
      "index": 3687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Comp",
      "library": "frama-c.kernel",
      "description": "This module defines comparison operators (`==, !=, <, >, <=, >=`) as an enumerated type and provides operations to manipulate and reason about these comparisons. It supports inversion and symmetry transformations, enabling logical reasoning over abstract interpretations of program expressions. It is used in static analysis to model and evaluate conditional relationships between abstract values.",
      "description_length": 397,
      "index": 3688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Types",
      "library": "frama-c.kernel",
      "description": "This module provides operations to query and iterate over types and type-related constructs in the AST, including checking existence and retrieving definitions for enums and named types. It works with strings representing type or enum names, type namespaces, and returns structured data such as expressions, types, and globals. Concrete use cases include resolving enum constants and type definitions during logic typing or static analysis tasks.",
      "description_length": 446,
      "index": 3689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing CIL attributes, including equality, comparison, hashing, and pretty-printing. It supports data types such as attribute values, sets, maps, and hash tables, enabling precise manipulation and analysis of C code annotations. Concrete use cases include attribute-based static analysis, semantic tracking during code transformation, and metadata management in Frama-C plugins.",
      "description_length": 415,
      "index": 3690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Abstract",
      "library": "frama-c.kernel",
      "description": "This module provides a way to access an abstract type by name, exposing a type `t` and a value `ty` that represents the abstract type. It works with abstract type values registered in the system, allowing plugins to retrieve and manipulate these types dynamically. Concrete use cases include querying and working with types defined in Frama-C's kernel or plugins, such as analyzing or transforming C types during static analysis.",
      "description_length": 429,
      "index": 3691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Quiet",
      "library": "frama-c.kernel",
      "description": "This component manages a boolean flag that controls quiet mode behavior, offering operations to set, retrieve, reset, and monitor state changes through hooks. It works with a single boolean value, augmented by support for command-line aliases,",
      "description_length": 243,
      "index": 3692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Keep_unused_types",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean option that controls whether unused types are retained during analysis, including setting, querying, and persisting its state across projects. It works with boolean values and associated metadata to handle command-line flags, state marshaling, and comparison logic. Specific use cases include configuring type retention behavior via the `-keep-unused-types` flag and integrating with Frama-C's kernel infrastructure for project-specific type usage tracking.",
      "description_length": 509,
      "index": 3693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_functions",
      "library": "frama-c.kernel",
      "description": "This module manages a mutable, project-aware table of CIL built-in functions, supporting operations to add, replace, query, and iterate over entries with project-specific state tracking. It uses a serialized hashtable where keys are function names and values encapsulate result types, argument lists, and vararg flags, primarily serving compiler integration (GCC/MSVC) and static analysis workflows requiring precise built-in function handling. The design accommodates serialization hooks and avoids pitfalls with custom key hashing, ensuring consistency across project snapshots.",
      "description_length": 580,
      "index": 3694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G",
      "library": "frama-c.kernel",
      "description": "This module provides graph manipulation and traversal operations for control flow graphs where vertices represent program control points and edges encode transitions with associated guards and actions. It supports functional-style iteration over vertices and edges, computes reachability information, and extracts structured control flow properties. These capabilities are used to model program behavior for abstract interpretation tasks such as state reachability analysis and semantic equivalence checking.",
      "description_length": 508,
      "index": 3695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enuminfo",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage and track differences in enum definitions across project versions, including adding, replacing, and querying enuminfo bindings, with support for change hooks, serialization, and sorted iteration. It works with a project-specific hashtable structure mapping keys (`Enuminfo.key`) to data (`Enuminfo.data`), where keys may require custom rehashing logic to preserve consistency during comparisons. It is particularly used for incremental analysis and version comparison tasks where precise tracking of enum definition changes is critical.",
      "description_length": 578,
      "index": 3696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling integer values within Frama-C's kernel, including equality checks, comparison, hashing, and pretty-printing. It provides deep copying and project membership testing for integers, ensuring precise manipulation and analysis. The associated Set, Map, and Hashtbl submodules enable efficient set-theoretic operations, associative mappings, and hash table management using integer keys, tailored for static analysis tasks such as tracking symbolic values and program invariants.",
      "description_length": 517,
      "index": 3697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filesystem.Compressed",
      "library": "frama-c.kernel",
      "description": "This module provides functions to open files for reading or writing with optional compression handling. It works with file paths and input/output channels, automatically decompressing or compressing data based on the file's state and the provided parameters. Concrete use cases include reading from and writing to compressed files transparently, such as processing .gz files without requiring manual compression or decompression steps.",
      "description_length": 435,
      "index": 3698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.Backwards",
      "library": "frama-c.kernel",
      "description": "Implements backwards data flow analysis by computing transfer functions from sink statements across a control flow graph. Operates on statements annotated with domain-specific data in `T.stmtStartData`, requiring initial population of all statements. Useful for analyses like backward constant propagation or liveness where information flows from uses to definitions.",
      "description_length": 367,
      "index": 3699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Validity",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and querying the validity of memory zones, including equality, comparison, hashing, and pretty-printing functions. It works with the `Validity.t` type, which represents the validity status of a memory base. Concrete use cases include checking if a memory zone is valid in a given project context using `mem_project`, and ensuring deep copies of validity states with `copy` for safe manipulation in different analysis phases.",
      "description_length": 468,
      "index": 3700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Initinfo",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling CIL initialization information, including equality, comparison, hashing, and pretty-printing functions. It works with the `initinfo` type, representing how variables are initialized in C code. It supports precise analysis of variable initializations during static analysis, such as tracking which variables are fully or partially initialized.",
      "description_length": 386,
      "index": 3701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages integer references within Frama-C's state system, supporting operations to get, set, and clear integer values. It allows attaching hooks on value changes and provides mechanisms for custom marshaling and project-specific state tracking. It is used to maintain and observe integer state variables across different analysis sessions and projects.",
      "description_length": 376,
      "index": 3702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph.Record",
      "library": "frama-c.kernel",
      "description": "This module provides operations to build complex node layouts in Dot graphs using records. It supports composing records with horizontal and vertical concatenation (`<->` and `<|>`) and allows attaching labels with optional ports and hyperlinks. Concrete use cases include generating structured node representations in control flow graphs or memory models, where nodes require detailed annotations or nested layouts.",
      "description_length": 416,
      "index": 3703,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Builtins",
      "library": "frama-c.kernel",
      "description": "This module manages the registration and extension of built-in logic objects in the analysis environment. It provides `apply` to finalize and add all requested built-in objects, and `extend` to defer the definition of such additions. It works with logic functions, predicates, and axioms used in formal verification tasks like program analysis and proof generation.",
      "description_length": 365,
      "index": 3704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple",
      "library": "frama-c.kernel",
      "description": "This module implements a triple data structure combining three distinct typed components, supporting operations like equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a unique type descriptor, and introspection via a membership predicate over project skeletons. Concrete use cases include representing compound values in static analysis, such as tracking multiple attributes across program points, or bundling related analysis results for efficient manipulation.",
      "description_length": 498,
      "index": 3705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing machine-dependent values, including equality, comparison, hashing, and pretty-printing. It provides data structures and functions for working with sets, maps, and hash tables keyed by machine-dependent types, enabling precise static analysis of architecture-specific behaviors. Concrete use cases include tracking machine states during code analysis, optimizing architecture-specific code transformations, and verifying properties across different target platforms.",
      "description_length": 509,
      "index": 3706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements forward dataflow analysis on interpreted automata by computing abstract states at control points using a user-defined domain. It processes transitions in the automaton\u2019s control flow graph, applying the domain\u2019s transfer function to propagate states from predecessors to successors. Useful for analyzing program behavior by tracking state changes at function entry/exit and statement boundaries, enabling tasks like invariant generation or reachability checks.",
      "description_length": 471,
      "index": 3707,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Toplevel_predicate",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling top-level CIL predicates, including equality, comparison, hashing, and pretty-printing. It works with the `toplevel_predicate` type, representing logical conditions in CIL's abstract syntax. Use cases include analyzing or transforming ACSL annotations during static analysis, such as checking predicate validity or extracting project-specific information.",
      "description_length": 399,
      "index": 3708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath",
      "library": "frama-c.kernel",
      "description": "This module manages symbolic path substitutions using a key-value store where file paths map to string aliases, enabling runtime configuration and dynamic updates through change hooks. It operates on hierarchical path data structures and string-based representations, primarily supporting symbolic execution tracking and analysis workflows that require path normalization or remapping. Use cases include command-line option parsing for path aliases, persistent state management during static analysis, and custom marshaling for distributed or cached symbolic path contexts.",
      "description_length": 573,
      "index": 3709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64",
      "library": "frama-c.kernel",
      "description": "This module implements 64-bit integer values with standard operations including equality, comparison, hashing, and pretty-printing. It supports static analysis tasks that require precise manipulation of 64-bit integer values, such as tracking numeric identifiers or symbolic values. The module also includes standard collection types\u2014sets, maps, and hash tables\u2014optimized for 64-bit integers, enabling efficient lookups, ordered traversals, and transformations tailored to static analysis needs like value range tracking and dependency modeling.",
      "description_length": 545,
      "index": 3710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project_skeleton.Make_setter",
      "library": "frama-c.kernel",
      "description": "This module generates uniquely named project skeletons and updates their names. It operates on strings and project skeleton objects, providing direct construction and mutation operations. Useful for creating and renaming project instances with guaranteed unique identifiers.",
      "description_length": 274,
      "index": 3711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfig",
      "library": "frama-c.kernel",
      "description": "This module manages the internal state and behavior of a boolean configuration option equivalent to Frama-C's `-print-config` command-line flag, enabling programmatic control over its activation and deactivation. It operates on a dedicated boolean type and associated state management structures, supporting features like change notification hooks, alias resolution, and project-specific serialization. Typical use cases include initializing configuration defaults, propagating state changes across plugins, or synchronizing with external configuration systems during analysis workflows.",
      "description_length": 587,
      "index": 3712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Syntactic_search",
      "library": "frama-c.kernel",
      "description": "Performs syntactic searches for variables within specified scopes using original names. It provides `find_in_scope` to locate a variable by name in a given syntactic context, such as function parameters or global declarations. Useful for analyzing or transforming code based on variable usage in specific syntactic regions.",
      "description_length": 323,
      "index": 3713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label",
      "library": "frama-c.kernel",
      "description": "This module implements logic label handling for Frama-C's CIL framework, providing core operations including equality, comparison, hashing, and pretty-printing for `logic_label` values. It supports label management tasks such as deep copying, project membership testing, and representation listing, enabling precise manipulation of logical annotations in C code. The module underpins analysis plugins that require tracking and resolving logic labels in specifications, such as assertion labeling, weakest precondition generation, and proof obligation tracking.",
      "description_length": 560,
      "index": 3714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Funbehavior",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling function behaviors in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `funbehavior` type, representing function specifications and behaviors in C code analysis. Use cases include analyzing or transforming function contracts, managing behavioral specifications during static analysis, and supporting plugin logic that depends on precise function semantics.",
      "description_length": 436,
      "index": 3715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptshape",
      "library": "frama-c.kernel",
      "description": "This module implements operations for managing and analyzing finite maps indexed by memory base keys (`Frama_c_kernel.Base.t`), supporting standard map manipulations like lookup, traversal, filtering, and cardinality checks. It extends to heterogeneous maps with custom join logic, enabling advanced set operations such as inclusion tests, intersections, and symmetric/asymmetric predicate evaluations, alongside cache management for efficiency. These capabilities are tailored for static analysis tasks like merging memory states, validating heap shape properties, and optimizing program verification workflows.",
      "description_length": 612,
      "index": 3716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections",
      "library": "frama-c.kernel",
      "description": "This module defines a paired data structure with deep copy, comparison, and set operations over two component types. It supports precise equality checks, ordered set and map manipulations, and hash table management for composite values. Concrete use cases include tracking dual-state abstractions in static analysis and managing structured key-value relationships with ordered elements.",
      "description_length": 386,
      "index": 3717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Reset",
      "library": "frama-c.kernel",
      "description": "This module provides functions to reset internal tables associated with specific AST element types in a visitor behavior instance. Each function corresponds to a type of AST element, such as `varinfo`, `stmt`, or `fundec`, clearing stored data for that type. It is used when reusing visitor instances across multiple transformations to ensure clean state between uses.",
      "description_length": 368,
      "index": 3718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic type values by allowing instantiation of a monomorphic type from a polymorphic template, such as generating `int list` from `list` using `instantiate`. It supports checking whether a type is an instance of such an instantiation and retrieving the original type used to create the instance. Concrete use cases include building and manipulating typed containers or structured data where type information must be preserved and inspected at runtime.",
      "description_length": 480,
      "index": 3719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingLevel",
      "library": "frama-c.kernel",
      "description": "This module manages integer-valued configuration parameters that control unfolding depth in analysis workflows, supporting operations to increment values, enforce range constraints, and track state changes. It works with an abstract integer type `t` and integrates with project-specific state management to handle dynamic updates, serialization, and alias resolution during analysis. The functionality is particularly used in static code analysis to regulate recursive or iterative unfolding of data structures while ensuring consistency across distributed computations.",
      "description_length": 570,
      "index": 3720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Sid",
      "library": "frama-c.kernel",
      "description": "This module generates unique integer identifiers, typically used to assign fresh identifiers to CIL data structures such as statements or variables. It provides the `next` function, which returns a new integer each time it is called, ensuring uniqueness across invocations. Commonly used during CIL transformation or analysis phases to tag or track elements in the AST.",
      "description_length": 369,
      "index": 3721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Fold",
      "library": "frama-c.kernel",
      "description": "This module performs fold operations over pairs of AST elements in a visitor behavior, applying a function to each registered element pair. It processes specific CIL types such as `varinfo`, `compinfo`, `stmt`, and various logic and type information records, where each fold function takes an accumulator and two versions of an element (old and new). Concrete use cases include aggregating changes between AST versions, computing diffs, or accumulating metadata across transformed AST nodes during analysis or transformation passes.",
      "description_length": 532,
      "index": 3722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepUnusedFunctions",
      "library": "frama-c.kernel",
      "description": "This module manages the behavior of a static analysis option that controls function retention policies by manipulating a string-based state representation and validating C function names against allowed lists. It provides operations to configure, update, and query the option's value, enforce name validity through string list checks, and register callbacks for state changes. The functionality is specifically used to determine which unused functions to retain during analysis while ensuring only syntactically valid function identifiers are accepted.",
      "description_length": 552,
      "index": 3723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float",
      "library": "frama-c.kernel",
      "description": "This module implements a float data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports static analysis tasks that require precise handling of floating-point values, such as tracking numeric ranges and program state modeling. The module also provides set, map, and hash table structures tailored for efficient analysis of floating-point data in Frama-C plugins.",
      "description_length": 413,
      "index": 3724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Normalized",
      "library": "frama-c.kernel",
      "description": "This module provides operations to construct, extend, and compare normalized file paths, handling absolute and relative path conversions. It supports path manipulation with functions like `extend`, `concat`, and `concats`, and offers pretty-printing and string conversion utilities. Use cases include building file paths from components, checking path equality, and formatting paths for output or logging.",
      "description_length": 405,
      "index": 3725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.Version",
      "library": "frama-c.kernel",
      "description": "This module provides access to version-related constants such as the version identifier, codename, combined version string, and individual major and minor version numbers. It works with string and integer data types to expose fixed, pre-defined values that describe the current Frama-C release. Concrete use cases include displaying version information in logs, checking compatibility based on major/minor numbers, and including version details in error messages or user-facing output.",
      "description_length": 485,
      "index": 3726,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLibc",
      "library": "frama-c.kernel",
      "description": "This module provides configuration management for a boolean flag controlling the visibility of C library functions in output. It handles state transitions, hooks for value changes, and serialization of the flag's value, operating on internal boolean state and project-specific context. The functionality is used to dynamically enable or suppress libc-related information during static analysis phases.",
      "description_length": 401,
      "index": 3727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintAsIs",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls whether output is generated without transformation, offering operations to set, query, and monitor changes to the flag's state. It works with boolean values and project-specific state management structures, supporting features like default value tracking, change notification hooks, and custom serialization. The functionality is used to toggle unmodified output behavior in Frama-C's analysis results or logging mechanisms.",
      "description_length": 487,
      "index": 3728,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing control points in an abstracted control flow graph, with operations for equality checking, comparison, hashing, and pretty printing. It supports deep copying of vertices and provides utilities to inspect or filter based on embedded project data. The module also includes set, map, and hash table implementations tailored for managing and analyzing program states during abstract interpretation.",
      "description_length": 443,
      "index": 3729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec",
      "library": "frama-c.kernel",
      "description": "This module directly handles CIL function declarations (`fundec`), offering equality, comparison, hashing, and pretty-printing operations. It supports deep copying, project membership checks, and provides representants for type descriptors. Concrete use cases include static analysis plugins that require precise manipulation of C function definitions, such as tracking function properties across translation units or implementing custom dataflow analyses over specific function sets.",
      "description_length": 484,
      "index": 3730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo",
      "library": "frama-c.kernel",
      "description": "This module implements structural operations for CIL type information, including equality, comparison, hashing, and pretty-printing functions for `typeinfo` values. It provides deep copying, project membership checks, and standard type representations, supporting precise manipulation of CIL type metadata. These capabilities are used in static analysis plugins for tasks such as type-based dataflow analysis, transformation pipelines, and canonical type representation management.",
      "description_length": 481,
      "index": 3731,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Make_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table that maps keys to values with associated type information. It supports operations to create, add, find, iterate over, and fold across bindings, ensuring type consistency during lookups and insertions. The table is designed for scenarios requiring dynamic type registration, such as managing typed metadata in analysis plugins.",
      "description_length": 376,
      "index": 3732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables mapping Frama-C properties to arbitrary values, supporting creation, insertion, lookup, iteration, sequence conversion, and ordered traversal using custom key comparisons. It enables memoization, project-aware property management, and analysis of program elements through in-place updates or functional transformations, with utilities for default value handling and structural operations. The tables are optimized for associating properties with analysis data, such as tracking proof obligations or semantic attributes during static analysis.",
      "description_length": 575,
      "index": 3733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Pure",
      "library": "frama-c.kernel",
      "description": "This module supports constructing and manipulating C and logic types (e.g., integers, floats, pointers, structures) alongside expressions and statements for static analysis. It operates on abstract syntax tree nodes like expressions (`exp`), lvalues (`lval`), and statements (`stmt`), enabling pure functional composition of arithmetic, bitwise, memory, and control-flow operations without explicit location handling. Key use cases include building intermediate representations for formal verification, memory validity checks, and generating typed AST fragments for analysis frameworks like Frama-C.",
      "description_length": 599,
      "index": 3734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepSwitch",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean option that controls whether specific elements are preserved during analysis, using a Datatype-backed boolean value. It provides operations to set, retrieve, and monitor changes to this flag, with support for custom update hooks, marshaling, and project-specific state management. The functionality is particularly used to handle analysis phases where preserving or discarding intermediate results is required, such as maintaining function call contexts or variable states across passes.",
      "description_length": 517,
      "index": 3735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCode",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls code printing behavior, offering operations to toggle its state and bind command-line arguments to its value. It centers on manipulating a simple `bool` type to enable or disable output generation during analysis. The functionality is specifically used to implement the `-print` command-line option, allowing tools to conditionally emit code or intermediate representations based on user input.",
      "description_length": 457,
      "index": 3736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections",
      "library": "frama-c.kernel",
      "description": "This module creates a comparable data type with fully defined equality, comparison, and hashing operations, along with support for deep copying, pretty printing, and project membership checks. It works with structured data types that require precise identity and ordering, such as abstract syntax tree nodes or analysis state elements. It is used to define custom data types in static analysis plugins where consistent ordering, hashing, and set/map integration are essential for tasks like value tracking, dependency resolution, and result memoization.",
      "description_length": 553,
      "index": 3737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling memory locations, including equality, comparison, hashing, and pretty-printing. It provides functions to check membership within projects, create deep copies, and access type descriptors for serialization and representation. Use cases include analyzing and manipulating memory states in static analysis plugins, such as tracking variable addresses or heap allocations.",
      "description_length": 412,
      "index": 3738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Lenv",
      "library": "frama-c.kernel",
      "description": "This module manages a local logic environment by providing operations to add and retrieve logic variables, type variables, logic information, and logic labels using string keys. It works with the `t` type representing the environment and supports data types such as `logic_var`, `logic_type`, `logic_info`, and `logic_label`. Concrete use cases include tracking logic variables during type checking and maintaining scoped definitions in logic expressions.",
      "description_length": 455,
      "index": 3739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.Lib",
      "library": "frama-c.kernel",
      "description": "This module defines paths and directories used by Frama-C for locating libraries and executables. It provides direct access to the prioritized list of directories, a concatenated path string, and the main installation directory. Useful for tools needing to resolve file locations or configure environment paths based on Frama-C's setup.",
      "description_length": 336,
      "index": 3740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Make_ordered",
      "library": "frama-c.kernel",
      "description": "This module implements ordered hooks with dependency management, allowing functions to be registered, extended, and applied in a controlled execution order. It works with abstract hook identifiers and supports dependency constraints between them, ensuring functions are applied from least to most recently added, unless dependencies dictate otherwise. Concrete use cases include managing analysis extensions in static analysis tools where execution order and dependencies between components matter.",
      "description_length": 498,
      "index": 3741,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Symmetric_Binary",
      "library": "frama-c.kernel",
      "description": "This module implements a symmetric binary cache that merges pairs of values using a user-defined function. It operates on two data types: `H.t` for input values and `R.t` for result values, with symmetry ensuring that the order of inputs does not affect the result. It is suitable for scenarios like memoizing pairwise computations where duplicate evaluations must be avoided, such as in hash-consing or equality checking.",
      "description_length": 422,
      "index": 3742,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Formatter",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and manipulating formatter values, including equality checks, comparison, hashing, and pretty-printing. It works with the `formatter` type from `Stdlib.Format` and supports deep copying and project membership queries. Concrete use cases include formatting structured output, comparing and duplicating formatter states, and checking project-specific conditions within formatter values.",
      "description_length": 429,
      "index": 3743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Build_ordered",
      "library": "frama-c.kernel",
      "description": "This module manages ordered execution of callback functions with dependency tracking. It allows registering functions with unique keys, establishing execution order dependencies, and applying all callbacks in a consistent sequence. Useful for analysis extensions that require pre-processing steps to run before dependent analyses in Frama-C plugins.",
      "description_length": 349,
      "index": 3744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Qstack.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a mutable double-linked list-based stack that supports efficient insertion and access at both ends, element reordering (via move_at_top/move_at_end), and positional queries (like idx to locate elements). It operates on elements of type `D.t`, offering operations for traversal, filtering, and in-place transformations while raising exceptions for invalid accesses (e.g., empty stacks or missing elements). It is particularly suited for scenarios requiring dynamic reordering of elements or positional analysis, such as priority-based task queues or history-sensitive state management.",
      "description_length": 607,
      "index": 3745,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make",
      "library": "frama-c.kernel",
      "description": "This module provides functionalities for constructing and manipulating sets of ordered elements, including standard operations like union, intersection, and difference, as well as advanced capabilities such as hashing, deep copying, and project-specific membership validation. The sets are implemented using a map-based structure, allowing interoperability with polymorphic maps, hashtables, and heterogeneous folding mechanisms over combined data collections. It is particularly suited for static analysis applications, enabling efficient merging of dataflow results, management of project-scoped state, and handling of cached representations that require manual context-based invalidation during analysis transitions.",
      "description_length": 719,
      "index": 3746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdep",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to manage a boolean setting that controls the display of machine-dependent information during static analysis. It supports operations to toggle the state, observe changes via hooks, and persist the configuration across sessions, working primarily with boolean values and integrating with the analysis framework's state management. It is used to enable or disable diagnostic outputs related to architecture-specific details, aiding developers in targeting specific hardware behaviors.",
      "description_length": 514,
      "index": 3747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_info.Function",
      "library": "frama-c.kernel",
      "description": "This module provides operations to inspect and analyze CIL functions, including retrieving formal arguments, checking variable roles (formal, local, or static), and determining function properties like whether it is a definition. It works with CIL function and variable data structures, such as `cil_function`, `fundec`, and `varinfo`. Concrete use cases include extracting function signatures, validating parameter usage, and analyzing function scope and linkage.",
      "description_length": 464,
      "index": 3748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_queue",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic queue type with operations for instantiation, type checking, and retrieval of monomorphic queue types. It supports creating queues of any element type, providing standard operations like equality, comparison, hashing, and pretty printing. Concrete use cases include modeling ordered sequences of program elements in static analysis, such as tracking value flows or maintaining collections of abstract states with structural identity.",
      "description_length": 470,
      "index": 3749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table-based management of statement-related data, supporting operations like insertion, modification, iteration, and folding over mappings from `stmt` keys to `Data.t` values. It includes mechanisms for state change tracking, serialization, and memoization, enabling efficient handling of analysis results or transformation states during static analysis",
      "description_length": 377,
      "index": 3750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Default_offsetmap",
      "library": "frama-c.kernel",
      "description": "This module provides a function `default_offsetmap` that constructs a default offset map for a given base, representing abstract memory values bound to variables. It operates on data types including `Base.t` and `Cvalue.V_Offsetmap.t`, within the lattice bounds framework. A concrete use case is initializing memory abstractions for static analysis when variable values are unknown or partially defined.",
      "description_length": 403,
      "index": 3751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Set_project_as_default",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manage a boolean configuration flag controlling whether a project is designated as the default, including setting, retrieving, resetting the flag, and registering hooks for state transitions. It operates on boolean values and integrates with project-specific state data structures via the `Datatype` module, enabling serialization and alias customization. It is used to enforce project-specific state management policies, such as initializing default project settings or dynamically updating the active project during analysis.",
      "description_length": 561,
      "index": 3752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_type_info",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific hash table mapping string keys to `logic_type_info` entries, enabling operations like adding, replacing, querying, and iterating over bindings, along with memoization and custom marshaling. It supports static analysis workflows requiring precise tracking of logic type metadata across project states, with mechanisms to register update hooks and enforce project-specific value handling. The design avoids generic patterns by tightly integrating state management with key-value semantics tailored to string-identified logic types.",
      "description_length": 568,
      "index": 3753,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.List.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for the `list` type, enabling non-deterministic computations through binding and product functions. It includes operators for chaining list-producing functions, applying pure functions over lists, and combining values from multiple lists into tuples. Concrete use cases include generating combinations of input values, modeling branching logic in analysis, and handling multiple possible outcomes in static analysis passes.",
      "description_length": 463,
      "index": 3754,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ival.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of integer intervals with operations like union, intersection, and difference, alongside transformations such as map, filter, and fold that preserve total ordering. It supports precise membership queries, nearest-neighbor lookups, and structural analysis of interval sets, with utilities for iteration, sequence conversion, and integration into static analysis frameworks. Designed for tasks requiring efficient manipulation of numeric ranges, it underpins variable value tracking and constraint propagation in program analysis workflows.",
      "description_length": 574,
      "index": 3755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatHex",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that governs hexadecimal floating-point representation in output formatting, offering operations to set, query, and monitor changes to its state. It interacts with kernel-level option structures and internal boolean flags, supporting features like alias resolution, command-line help generation, and serialization of settings across analysis sessions. Its functionality is primarily used to control precision-preserving numeric output in static analysis workflows and to maintain consistent configuration behavior for developers integrating with the kernel's option system.",
      "description_length": 624,
      "index": 3756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RightShiftNegative",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to configure and monitor a boolean flag that determines whether right-shifting negative integers generates warnings during static analysis. It operates on a boolean state variable, offering functions to toggle its value, register callbacks for state changes, and persist configurations across sessions, while integrating with Frama-C's global state management and command-line parameter system. The functionality is specifically used in scenarios where developers need to enforce or suppress diagnostics for undefined behavior in bitwise operations on signed integers.",
      "description_length": 599,
      "index": 3757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_list",
      "library": "frama-c.kernel",
      "description": "This module provides functions to create and manipulate monomorphic list datatypes by instantiating polymorphic type definitions. It supports operations for equality, comparison, hashing, and pretty-printing through the `Make` submodule, which generates type-safe list modules from element types. Concrete use cases include defining lists of AST nodes or analysis-specific values in Frama-C plugins, ensuring proper memory management and deep copying.",
      "description_length": 451,
      "index": 3758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom",
      "library": "frama-c.kernel",
      "description": "This module enables customizable kernel options with hooks for value change notifications, serialization, and project-specific mutability control, alongside key-value store operations for configuration parameters. It works with a structured `t` type for specification data, string-based values via `As_string`, and categorized key-value mappings through `Category`, supporting use cases like tailored specification persistence, dynamic option state tracking, and organized parameter grouping for analysis workflows.",
      "description_length": 515,
      "index": 3759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_set_ref",
      "library": "frama-c.kernel",
      "description": "This module manages a set of C statements (`stmt`) within Frama-C's kernel, providing operations to add, remove, iterate over, and query statements. It supports tracking changes via hooks and custom serialization, and integrates with project-specific state management. Concrete use cases include static analysis plugins that need to collect and process control flow statements across different project versions.",
      "description_length": 411,
      "index": 3760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_option",
      "library": "frama-c.kernel",
      "description": "This module provides operations to create and manipulate monomorphic instantiations of polymorphic option types, including functions to instantiate, check, and retrieve type parameters. It works with types wrapped in a polymorphic `poly` structure, enabling concrete type operations such as equality, comparison, and pretty-printing. It is used in static analysis plugins to handle optional values with precise type control and deep manipulation.",
      "description_length": 446,
      "index": 3761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit",
      "library": "frama-c.kernel",
      "description": "This module defines a singleton type `t` representing the unit value, equipped with standard operations including equality, comparison, hashing, and pretty-printing. It provides core utilities for managing unit values in static analysis contexts, such as deep copying, project membership checks, and a unique descriptor for type handling. The associated `Set`, `Map`, and `Hashtbl` modules offer specialized collections for unit keys, enabling efficient set operations, ordered mappings, and hash-based lookups tailored to static analysis plugins.",
      "description_length": 547,
      "index": 3762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.Bool",
      "library": "frama-c.kernel",
      "description": "Implements conditional inclusion of elements in non-deterministic computations. Works with `unit list` values representing possible outcomes. Use to filter branches of computation based on boolean conditions.",
      "description_length": 208,
      "index": 3763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Exp_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table for mapping CIL expressions to arbitrary data, supporting efficient lookups, insertion, deletion, and traversal operations. It includes advanced features like custom comparator ordering, memoization with state-aware updates, and change event hooks to integrate with Frama-C's project state management. The structure is particularly suited for analysis tasks requiring persistent tracking of expression-associated metadata, such as value analysis or program transformation passes.",
      "description_length": 525,
      "index": 3764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make",
      "library": "frama-c.kernel",
      "description": "This module computes invariants for linear filters by analyzing the convergence of state matrices through matrix exponentiation and norm checks. It constructs filters from matrices, vectors, and source terms, then calculates upper and lower bounds for each state dimension when iterations reach a fixed point. It is used in static analysis to verify numerical properties of loops modeled as linear recurrence relations.",
      "description_length": 419,
      "index": 3765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ",
      "library": "frama-c.kernel",
      "description": "This module defines operations for comparing, hashing, and printing CIL types with structural equivalence, resolving typedefs and struct keys. It supports deep copies, set and map manipulations, and project membership checks, enabling precise type analysis and transformation in Frama-C plugins. Concrete use cases include type canonicalization, struct hierarchy analysis, and type-based metadata management during static analysis.",
      "description_length": 431,
      "index": 3766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make",
      "library": "frama-c.kernel",
      "description": "Implements a service computation algorithm over a user-defined graph structure with labeled vertices and edges. Provides functions to compute service graphs from a callgraph, manipulate graph elements imperatively, and output graph data for visualization or analysis. Designed for static analysis tasks such as impact propagation and dependency resolution in large-scale software systems.",
      "description_length": 388,
      "index": 3767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filter.F",
      "library": "frama-c.kernel",
      "description": "This module builds a new CIL file from an existing one by filtering and transforming elements based on rules defined in the `Info` submodule. It operates on `Project.t` data structures, applying transformations to generate sliced or modified versions of the original project. A typical use case involves creating a reduced or specialized version of a CIL file for analysis or code generation purposes.",
      "description_length": 401,
      "index": 3768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing a mutable key-value store with string keys and logic information lists as values, supporting versioned state tracking across projects. It enables querying, updating, and serializing logic data, along with change notifications and custom marshaling for state synchronization. Designed for logic analysis workflows, it handles scenarios where logic definitions or results must persist and adapt to evolving project states.",
      "description_length": 463,
      "index": 3769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.Plugins",
      "library": "frama-c.kernel",
      "description": "This module manages dynamic plug-in loading for Frama-C. It provides the list of plug-in directories, a colon-separated path string, and functions to load individual or all plug-ins, respecting GUI mode constraints. It works with file paths and string-based plug-in names, targeting plug-in discovery and initialization workflows.",
      "description_length": 330,
      "index": 3770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.MainFunction",
      "library": "frama-c.kernel",
      "description": "This module manages command-line configuration of a program's entry point, offering operations to validate, set, and retrieve function names while supporting alias resolution and dynamic parameter updates. It works with string identifiers and a structured type `t` to track entry point state, incorporating hooks for serialization, validation, and documentation. It is particularly useful in plugin development for enforcing valid entry point selections during analysis setup or handling user-provided function names with fallback mechanisms.",
      "description_length": 542,
      "index": 3771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CodeOutput",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for managing code output file paths through operations like setting, retrieving, and validating paths, along with change notifications via hooks. It works primarily with `Frama_c_kernel.Filepath.t` for path representation and leverages formatters for structured file output, while supporting state serialization and alias resolution. Its design addresses use cases such as directing generated code to a specified file via the `-ocode` option or tracking project-specific output configurations.",
      "description_length": 528,
      "index": 3772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product",
      "library": "frama-c.kernel",
      "description": "This module combines two monads using a product-based approach, enabling operations like `return`, `bind`, `map`, `flatten`, and `product` on values of type `'a T.t S.t`. It supports concrete use cases such as stateful computations that may fail, processing sequences of fallible operations with shared state, and conditional execution of effects based on boolean flags or optional values. The module also includes specialized submodules for handling lists, options, and boolean conditions within composed monadic contexts.",
      "description_length": 523,
      "index": 3773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Vars",
      "library": "frama-c.kernel",
      "description": "This module manages global variables in the AST, providing direct access to their definitions and initializations through `find`, `get_astinfo`, and iteration in declaration order. It supports operations like `iter` and `fold` for processing all global variables, with variants that respect file order or reverse order. Use cases include analyzing or transforming global variable initializations and tracking variable definitions across the program.",
      "description_length": 449,
      "index": 3774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make",
      "library": "frama-c.kernel",
      "description": "This module offers operations to format and output CIL and ACSL data structures\u2014such as variables, types, logic terms, function specifications, and control-flow elements\u2014to formatters, enabling structured visualization of intermediate representations. It works with typed values from `Cil_types` and ACSL constructs, supporting customizable printing through dynamic extensions to modify behaviors like annotation visibility or brace formatting. Its primary use case involves generating human-readable dumps for debugging, analysis, or tool integration where precise CIL/ACSL rendering is required.",
      "description_length": 597,
      "index": 3775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating project state elements in Frama-C, including equality, comparison, hashing, and pretty-printing. It supports data types that represent internal computation states tied to ASTs, enabling deep copies and project-aware comparisons. It is used to implement deterministic sets, maps, and hash tables for tracking and analyzing Frama-C's internal states across multiple projects.",
      "description_length": 434,
      "index": 3776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Permissive",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean configuration flag that controls the `-permissive` behavior in Frama-C, including setting, retrieving, resetting to default, and checking its status. It works with an internal boolean state and supports integration with Frama-C's state management, project system, and analysis plugins through hooks, custom marshaling, and alias handling. It is used to dynamically adjust analysis strictness or permissiveness during plugin execution.",
      "description_length": 486,
      "index": 3777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure using normalized filepaths as keys, offering standard operations like insertion, removal, and lookup alongside advanced combinators for merging, filtering, and ordered traversal. It supports value types including lists, with utilities for appending to lists and extracting min/max bindings, while ensuring deterministic behavior through filepath comparison and hashing. Designed for scenarios requiring precise file-based data management, such as tracking file metadata or configurations, it enables efficient iteration, transformation, and pretty-printing of key-value associations in ordered sequences.",
      "description_length": 643,
      "index": 3778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter",
      "library": "frama-c.kernel",
      "description": "This module provides functions to access and modify plugin parameters by name, supporting boolean, integer, string, file path, string set, and string list types. It enables retrieving parameter values, checking if they are set, and updating them dynamically during plugin execution. Use cases include toggling analysis features, adjusting numeric thresholds, setting file paths for input/output, and managing lists of strings like include directories or analysis targets.",
      "description_length": 471,
      "index": 3779,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.CardinalEstimate",
      "library": "frama-c.kernel",
      "description": "This module estimates the cardinality of abstract memory states or values, representing the number of possible concrete values an abstract state might concretize to. It provides operations to create and print cardinality estimates, including compact and detailed logarithmic representations. A concrete use case is analyzing the potential size of abstract states during static analysis to guide precision and performance trade-offs.",
      "description_length": 432,
      "index": 3780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.User_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve default directory paths for caching, configuration, and state files used by Frama-C. It operates on unit values and returns file paths as `Frama_c_kernel.Filepath.t` values. Concrete use cases include setting up storage locations for persistent data without relying on external configuration.",
      "description_length": 335,
      "index": 3781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and strict constant comparison for CIL offset types, providing core operations like `equal`, `compare`, `hash`, and `pretty`. It supports precise manipulation of CIL elements such as field offsets in structs or unions, ensuring exact equivalence checks for static analysis tasks. The included `Set`, `Map`, and `Hashtbl` submodules enable efficient, ordered, and type-safe handling of these offsets in contexts like memory layout analysis or dataflow merging.",
      "description_length": 499,
      "index": 3782,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing entities that emit annotations and property statuses during static analysis, supporting equality checks, comparison, hashing, pretty-printing, and project membership tests. It organizes emitter-based data using sets, maps, and hash tables to handle associations and workflows, while also enabling structured output formatting for emitter parameters. Typical use cases include implementing analysis plugins that require tracking or serializing emitter states, or customizing how annotation metadata is displayed and processed in Frama-C's analysis pipelines.",
      "description_length": 602,
      "index": 3783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Varinfo",
      "library": "frama-c.kernel",
      "description": "This module manages variable mappings and project-specific hashtables with custom-rehash keys, enabling operations like lookup (`find_all`), iteration (`to_seq`), and modification hooks (`add_hook_on_change`) for precise data tracking. It operates on `Varinfo.key` and `Varinfo.data` types, facilitating AST differencing tasks such as correlating variables across project versions while ensuring correct state handling through persistence, memoization, and custom marshaling. Use cases include program analysis tools requiring robust variable correspondence management and semantic differencing between project states.",
      "description_length": 618,
      "index": 3784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module implements structural equality for CIL l-values with strict constant comparison, providing equality, comparison, and hash operations tailored for precise static analysis. It supports data structures like sets, maps, and hash tables keyed on l-values, enabling exact structural equivalence checks and deterministic ordering. Concrete use cases include tracking memory accesses, analyzing control-flow dependencies, and managing CIL expressions without redundancy.",
      "description_length": 474,
      "index": 3785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Block",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL block data structures, including equality, comparison, hashing, and pretty-printing functions. It provides utilities to check membership of project-related values, create deep copies, and access type descriptors for block instances. Concrete use cases include analyzing and transforming C code blocks during static analysis, such as tracking control flow or data dependencies within a function body.",
      "description_length": 451,
      "index": 3786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Proxy",
      "library": "frama-c.kernel",
      "description": "This module creates and manages state proxies to control dependencies between groups of states. It supports three dependency kinds\u2014backward, forward, and mutual\u2014and allows adding states to a proxy or retrieving the proxy's state. Concrete use cases include structuring complex state relationships in static analysis plugins to manage dependency resolution efficiently.",
      "description_length": 368,
      "index": 3787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice",
      "library": "frama-c.kernel",
      "description": "This module combines maps and sets into a lattice structure where each key-value binding forms its own lattice, enabling operations like intersection, union, and narrowing across hierarchical domains. It supports static analysis tasks requiring precise merging of states, cardinality-constrained data structures, and ordered traversal through key-value pairs with filtering, folding, and lattice-specific transformations. The design accommodates imperative hash table management and deep-copyable representations for contexts demanding structured state manipulation.",
      "description_length": 566,
      "index": 3788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a structured set interface for managing ordered collections of alarm data, supporting operations like union, intersection, difference, and element insertion/removal with both safe and unsafe access variants. It works with ordered sets to enable range-based queries, transformations, and bidirectional traversal while providing utilities for filtering, partitioning, and converting between lists or sequences. Key capabilities include proximity-based element lookup, project-aware membership testing, and serialization features tailored for alarm state analysis and debugging in static code verification workflows.",
      "description_length": 636,
      "index": 3789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatNormal",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls floating-point normalization behavior, offering operations to set/query its state, register change hooks, and define aliases. It operates on a boolean type (`t = bool`) representing kernel-level configuration flags, enabling analysis tools to adjust floating-point handling during program analysis.",
      "description_length": 363,
      "index": 3790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kinstr_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers a hash table implementation for storing and manipulating key-value pairs where keys are kinstr instances and values conform to the Data.t interface. It provides operations for insertion, lookup, iteration, folding, and removal, alongside mechanisms to track changes via hooks and manage state transitions, specifically tailored for scenarios requiring precise state management within analysis passes, such as memoizing computed results, monitoring modifications to key-value associations, or serializing state data during program transformation tasks.",
      "description_length": 570,
      "index": 3791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SpecialFloat",
      "library": "frama-c.kernel",
      "description": "This module provides operations to configure and validate the `-warn-special-float` kernel option, which governs handling of special floating-point values like NaNs and infinities. It works with string-based parameters and lists to define allowed values, aliases, and serialization logic, while integrating with project state management for persistence. Specific use cases include enabling/disabling warnings during static analysis, validating user-provided option values, and synchronizing option changes with analysis projects.",
      "description_length": 529,
      "index": 3792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Offsetmap",
      "library": "frama-c.kernel",
      "description": "This module supports operations for managing abstract memory representations as bit-level interval mappings to values with flags, enabling interval traversal, value transformations, and lattice operations like join and widen. It works with offsetmaps that track memory slices through precise or imprecise intervals, supporting use cases such as merging memory regions, refining abstract states during static analysis, and querying value consistency under domain-specific constraints. Key functionalities include slicing memory, combining maps, and handling project-specific data while maintaining cache-efficient updates and domain-specific narrowing.",
      "description_length": 651,
      "index": 3793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.FCHashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys of type `H.t` and values of arbitrary type `'a`, supporting creation, insertion, deletion, and lookup operations alongside functional iteration, folding, and in-place filtering. It extends these capabilities with sorted traversal over keys, entries, or values using customizable comparison functions, as well as utilities for safe value retrieval and memoization. These features are particularly suited for applications requiring ordered key-value processing, such as caches with eviction policies tied to key ordering, data analysis pipelines with sorted intermediate results, or managing associations with domain-specific equality constraints.",
      "description_length": 690,
      "index": 3794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits",
      "library": "frama-c.kernel",
      "description": "This module provides bit-level memory location abstractions with operations for union, intersection, inclusion checks, and offset arithmetic (shifting, subtraction) to model low-level C constructs like bitfields and pointer arithmetic. It works with symbolic base-offset pairs and interval types (`Base.t`, `Ival.t`), using set/map/hashtable structures to enable static analysis tasks such as reachability checks, cardinality tracking, and abstract state merging. Key use cases include precise analysis of memory accesses, handling imprecise values via widening/narrowing, and transforming location representations during abstract interpretation.",
      "description_length": 646,
      "index": 3795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll",
      "library": "frama-c.kernel",
      "description": "This module defines a structural type representation for CIL types that compares structs by key without unrolling, supporting precise type identity checks. It provides core operations including equality, comparison, hashing, deep copying, and pretty-printing, all preserving the original structure of C types. It is used in static analysis to accurately model and manipulate C code structures\u2014such as typedefs and structs\u2014without expanding them, ensuring correct handling during transformations and analysis passes.",
      "description_length": 515,
      "index": 3796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditCheck",
      "library": "frama-c.kernel",
      "description": "This module manages file path configuration through operations for tracking, modifying, and serializing audit check paths, supporting use cases like static analysis workflow validation and project-specific state persistence. It works with file path objects (`Filepath.t`) and structured data types via the `Datatype` module, enabling introspection and deep copying. Key applications include handling command-line option parsing, monitoring path state changes during analysis sessions, and ensuring consistent audit trail configurations across project loads/saves.",
      "description_length": 563,
      "index": 3797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Type",
      "library": "frama-c.kernel",
      "description": "This module focuses on constructing and transforming C and logic types into a unified polymorphic representation, handling composite types like pointers, arrays, and structures, as well as qualifiers such as `const` and attributes. It operates on CIL type representations (`Cil_types.typ`, `Cil_types.logic_type`) to produce and manipulate `Type.typ` values, enabling expression building in static analysis workflows where explicit source location annotations are omitted. Key use cases include modeling complex type hierarchies for program verification and simplifying type manipulations in Frama-C's analysis plugins.",
      "description_length": 619,
      "index": 3798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a datatype with equality, comparison, and pretty-printing operations derived from a given module `X`. It defines a type `t` with functions for structural inspection, hashing, and project membership checks, based on `X`'s structure. It is used to build typed representations for analysis values in Frama-C plugins, such as abstract domains or program annotations.",
      "description_length": 382,
      "index": 3799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map",
      "library": "frama-c.kernel",
      "description": "This module enhances a given datatype with set and map operations, requiring valid equality and comparison functions. It introduces modules `Set` and `Map` for managing ordered collections and associative structures, respectively. Use cases include static analysis tasks that require precise set-theoretic or key-indexed data manipulation with guaranteed ordering and uniqueness.",
      "description_length": 379,
      "index": 3800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections",
      "library": "frama-c.kernel",
      "description": "This module defines an optional type `t` based on a parameter module `T`, equipped with standard operations including equality, comparison, hashing, and pretty printing. It provides derived collection modules\u2014`Set`, `Map`, and `Hashtbl`\u2014for working with sets, maps, and hash tables where elements are of the optional type. These structures support precise static analysis tasks such as tracking optional program values, managing analysis states with optional keys, and aggregating results across analysis passes.",
      "description_length": 512,
      "index": 3801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing byte-level memory locations represented as base-offset pairs, supporting set algebra (union, intersection), arithmetic manipulations (offset shifting, differencing), and abstract interpretation techniques like widening/narrowing for over/under-approximation. It operates on bases (`Base.t`) and byte offsets (`Ival.t`), structured through sets, maps, and hash tables to enable static analysis tasks such as modeling memory regions, tracking pointer arithmetic, and analyzing memory access patterns. Specific use cases include handling imprecise (\"top\") values with origin tracking, determining reachability, and verifying containment of local variables within memory regions.",
      "description_length": 720,
      "index": 3802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Symmetric_Binary_Predicate",
      "library": "frama-c.kernel",
      "description": "Implements a cache for symmetric binary predicates, storing results of pairwise comparisons between values of type `H0.t`. Provides `merge` to compute and cache predicate results, and `clear` to reset cached data. Useful for optimizing repeated equality or ordering checks in analysis passes where pairs of values are compared symmetrically.",
      "description_length": 341,
      "index": 3803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make",
      "library": "frama-c.kernel",
      "description": "This module implements persistent maps over hash-consed tree keys using big-endian Patricia trees, enabling efficient insertion, deletion, structural comparison, and deterministic traversal. It supports advanced operations like cache-aware merging with customizable conflict resolution, prefix-based subtree queries, and heterogeneous map comparisons optimized for static analysis tasks. Designed for handling large-scale abstract syntax trees, it provides specialized utilities for static analysis workflows, including memoization, project introspection, and shape-preserving transformations with deep copying semantics.",
      "description_length": 621,
      "index": 3804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Undefined_sequence",
      "library": "frama-c.kernel",
      "description": "Performs semantic checks on sequences in CIL files to detect undefined behaviors. Works with CIL's abstract syntax tree structures, specifically function bodies and statement sequences. Validates that sequence points are properly respected in expressions to ensure well-defined evaluation order.",
      "description_length": 295,
      "index": 3805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Channel",
      "library": "frama-c.kernel",
      "description": "This module handles low-level binary input and output operations for reading from and writing to files. It supports direct manipulation of binary data through functions like `input_char`, `unsafe_really_input`, and `output_value`, and works with structured values via serialization. Concrete use cases include reading and writing binary file formats, implementing custom serialization, and handling compressed output with optional compression.",
      "description_length": 443,
      "index": 3806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_bitwise_sig",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage maps where intervals are associated with values, supporting efficient insertion, lookup, and bitwise operations over ranges. It works with intervals represented as integer ranges and associated values, leveraging implicit inheritance of bindings by sub-intervals. Concrete use cases include tracking memory regions with associated properties, such as permissions or annotations, in static analysis tools.",
      "description_length": 446,
      "index": 3807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Async",
      "library": "frama-c.kernel",
      "description": "This module manages asynchronous tasks and progress reporting through daemons that execute during yield points. It supports registering, unregistering, and controlling the execution of these daemons with optional debouncing and callbacks. Use cases include updating progress indicators during long-running analyses, handling background tasks in GUI/server modes, and temporarily running jobs with attached asynchronous behavior.",
      "description_length": 428,
      "index": 3808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ordered_stmt",
      "library": "frama-c.kernel",
      "description": "This module provides direct mappings between CIL statements and their ordered counterparts, using conversion tables generated per kernel function. It supports efficient lookups between `ordered_stmt` and `stmt` types, along with retrieving connex component numbers for ordered statements in topological order. Concrete use cases include analyzing control flow dependencies and managing statement ordering during static analysis passes.",
      "description_length": 435,
      "index": 3809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Log",
      "library": "frama-c.kernel",
      "description": "This module enables structured logging operations such as event creation with severity levels and source positions, category-based filtering, and dynamic message routing through listeners or channels. It works with log events, formatters, and output streams, supporting delayed or immediate message echoing and buffering control for use cases like kernel/plugin diagnostics and customizable logging workflows.",
      "description_length": 409,
      "index": 3810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cmdline",
      "library": "frama-c.kernel",
      "description": "This module manages command line parsing and stage-specific actions in Frama-C, allowing registration of callbacks for stages like early, extending, extended, exiting, loading, and configuring. It works with functions, stages, and exit codes, enabling plugins to interact with the command line and modify behavior at specific execution points. Concrete use cases include registering actions to run after file loading, handling plugin-specific options, and defining exit hooks for cleanup or logging.",
      "description_length": 499,
      "index": 3811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval",
      "library": "frama-c.kernel",
      "description": "This module implements floating-point interval arithmetic with support for operations like addition, multiplication, sine, cosine, and bitwise transformations, along with lattice operations such as join and widen. It handles intervals representing floating-point ranges parameterized by precision (single/double), including NaN and infinities. Used in abstract interpretation for tasks like constraint propagation, numerical variable refinement, and modeling floating-point memory representations through precision-aware conversions to integer ranges.",
      "description_length": 551,
      "index": 3812,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Result",
      "library": "frama-c.kernel",
      "description": "This module extends OCaml's built-in `result` type with utilities for error handling, value extraction, and transformation, offering functions to create, map, fold, and convert results into types like `option`, `list`, or `seq`. It introduces infix operators for chaining (`let*`, `let+`) and combining (`and*`, `and+`) results in a pipeline-friendly manner, enabling concise error propagation and parallel computation handling. These tools are particularly useful for composing operations that may fail, such as parsing, validation, or I/O workflows, where structured error management and value unwrapping are critical.",
      "description_length": 620,
      "index": 3813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_deps",
      "library": "frama-c.kernel",
      "description": "This module computes dependencies for logic terms and predicates in C code annotations, determining which program locations influence their evaluation. It processes terms, predicates, and code annotations in the context of function or statement contracts, returning zones of influence and sets of variables or labels involved. Key use cases include analyzing ACSL annotations for slicing, identifying control dependencies, and filtering annotations based on type for static analysis tools.",
      "description_length": 489,
      "index": 3814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook",
      "library": "frama-c.kernel",
      "description": "This module implements hook systems for managing and executing collections of functions with support for registration, extension, application, and dependency tracking. It works with abstract hook identifiers and ordered callback sequences, enabling precise control over execution order. Concrete use cases include dynamically extending static analysis phases, injecting program-point-specific transformations, and managing plugin components with pre-processing dependencies in Frama-C.",
      "description_length": 485,
      "index": 3815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals",
      "library": "frama-c.kernel",
      "description": "This module provides direct access to global variables, functions, and file-level symbols in the AST, enabling precise queries and transformations on CIL structures such as `varinfo`, `kernel_function`, and `fundec`. It supports operations like `iter`, `fold`, and syntactic searches to analyze or modify global variable initializations, function definitions, and type-related constructs. Concrete use cases include inter-procedural analysis, annotation handling, and resolving enum constants or type definitions during static analysis.",
      "description_length": 536,
      "index": 3816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Asm_contracts",
      "library": "frama-c.kernel",
      "description": "This module processes GNU extended assembly syntax to infer and generate code contracts. It operates on assembly code structures and annotation tables, translating low-level assembly constraints into higher-level contract specifications. Use cases include enhancing static analysis of assembly code by deriving preconditions, postconditions, and assertions directly from assembly constraints.",
      "description_length": 392,
      "index": 3817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabs_debug",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations for converting CABS abstract syntax tree (AST) components\u2014such as declarations, statements, expressions, types, and attributes\u2014into human-readable textual representations. It works directly with CABS data structures like locations, enumerations, operators, and file-level constructs, using OCaml's `Format.formatter` to structure output. These functions are specifically designed for debugging and logging compiler intermediate representations during analysis or transformation phases.",
      "description_length": 533,
      "index": 3818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_state",
      "library": "frama-c.kernel",
      "description": "This module manages groups of parameters related to analysis configuration and state selection. It provides operations to retrieve selections of parameters that influence analysis, are settable, or are resettable during visitor copies, using `State_selection.t` and `State.Set.t` data structures. Concrete use cases include controlling parameter visibility and mutability in static analysis plugins and managing state during analysis resets.",
      "description_length": 441,
      "index": 3819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing logic functions, types, constructors, and model fields, along with ACSL extensions and metadata in Frama-C's kernel. It works with data structures like `logic_info`, `logic_type_info`, and project-scoped key-value stores to support formal verification tasks such as lemma storage, static analysis, and proof generation. Key use cases include versioned metadata tracking, dependency management, and maintaining consistent logic environments across modules through custom state handling and marshaling.",
      "description_length": 545,
      "index": 3820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Current_loc",
      "library": "frama-c.kernel",
      "description": "This module tracks and manipulates the current source code location during static analysis, providing functions to set, get, and clear location data as pairs of file positions. It supports scoped location changes with `with_loc` and `with_loc_opt`, ensuring temporary modifications revert after function execution, even on exceptions. Concrete use cases include precise error reporting, logging with contextual source locations, and managing location-based analysis state across different projects.",
      "description_length": 498,
      "index": 3821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rmtmps",
      "library": "frama-c.kernel",
      "description": "This module provides functions to analyze and remove unused global variables and labels in CIL-processed code. It works with CIL's global and fundec structures, determining which symbols are roots or part of a complete program, and optionally removing those that are unused. Concrete use cases include optimizing intermediate representations by eliminating dead code and cleaning up automatically generated labels.",
      "description_length": 414,
      "index": 3822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type",
      "library": "frama-c.kernel",
      "description": "This module defines lattice signatures that use the `Bottom` type to represent the bottom element, omitting it from the lattice structure itself. It includes specialized signatures for operations like narrowing, under-approximation, and difference tracking, tailored for static analysis contexts. These lattices are used to model abstract domains where precise handling of bottom is critical, such as value analysis or cardinality-based abstractions.",
      "description_length": 450,
      "index": 3823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath",
      "library": "frama-c.kernel",
      "description": "This module offers normalization, symbolic directory management, and path manipulation operations for abstract filepaths, supporting resolution, relativization, and suffix transformations. It works with abstract path values (`t`) and symbolic directory mappings, organizing them via ordered collections (sets, maps, hashtables) for efficient lookups and project-aware path analysis. It is used in scenarios requiring precise path normalization, such as resolving relative project structures or integrating with plugin ecosystems that depend on consistent path representations.",
      "description_length": 576,
      "index": 3824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder",
      "library": "frama-c.kernel",
      "description": "This module enables the creation of stateful references (e.g., integers, booleans, floats) with project-specific tracking, change hooks, and custom serialization, alongside hashconsing tables for optimizing structural sharing of values during static analysis. It supports advanced state management through dependency-controlled proxies, counters, and single-execution guarantees for closures, primarily serving Frama-C plugins that require precise state dependency handling and cross-project state traversal. The provided data structures and utilities facilitate efficient, typed state manipulation in complex analysis scenarios.",
      "description_length": 629,
      "index": 3825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hpath",
      "library": "frama-c.kernel",
      "description": "This module represents hierarchical paths used in static analysis, supporting operations to construct, manipulate, and convert paths. It works with absolute, relative, and named paths through the `base` type and string identifiers. Concrete use cases include tracking analysis targets and resolving configuration settings tied to specific source code locations.",
      "description_length": 361,
      "index": 3826,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Unmarshal",
      "library": "frama-c.kernel",
      "description": "This module enables unmarshaling values from binary channels with runtime type-guided transformations, supporting structured and primitive types like records, lists, hash tables, and numeric primitives. It enhances standard unmarshaling by applying user-defined transformations during deserialization and performing limited type consistency checks using abstract type representations. It is particularly useful for safely reconstructing complex data structures from serialized formats while adapting values on-the-fly, though correctness depends on manually-provided type metadata matching the actual serialized layout.",
      "description_length": 619,
      "index": 3827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and manipulating datatypes with structural identity, including equality, comparison, hashing, and serialization, while supporting precise type handling for static analysis. It works with generic OCaml values, project-based analysis states, and structured types like integers, floats, strings, and abstract values, extended with optimized collections (sets, maps, hash tables) and functional constructs (tuples, queues, weak hash tables). These components are tailored for modeling program states, managing symbol tables, tracking analysis data with strong identity guarantees, and implementing static analysis plugins requiring deep type manipulation and efficient data structure operations.",
      "description_length": 736,
      "index": 3828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type",
      "library": "frama-c.kernel",
      "description": "This module supports operations for representing and manipulating static ML types, including monomorphic and polymorphic type construction, structural inspection, and equality checks. It works with type values (`Type.t`) and structured data like function types, polymorphic types with up to four parameters, and heterogeneous hash tables (e.g., `String_tbl`, `Ty_tbl`) for mapping typed data. These capabilities are used in static analysis plugins to model type hierarchies, perform type-based data transformations, and analyze complex type-driven behaviors.",
      "description_length": 558,
      "index": 3829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Floating_point",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manipulate floating-point rounding modes, truncate floats to integers, validate properties like finiteness or NaN status, and retrieve format-specific parameters (e.g., min/max values, ULP) for single and double precision. It operates on float values and custom types encoding rounding modes and truncation results, aligning with IEEE 754 semantics. Its functionality supports numerical analysis tasks requiring precise control over floating-point behavior, such as verifying arithmetic compliance or handling edge cases in scientific computing.",
      "description_length": 578,
      "index": 3830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations and lattice combinators for handling values with explicit top and/or bottom elements. It works with wrapped data types that represent lattice states, including booleans, options, lists, and custom structures, enabling precise propagation of undefined (bottom) or over-approximated (top) values. It is used in static analysis to manage partial information, track abstract value domains, and combine lattice elements during symbolic execution.",
      "description_length": 481,
      "index": 3831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows",
      "library": "frama-c.kernel",
      "description": "Implements data flow analyses for forward and backward monotone frameworks over customizable domains. It provides helper functions to handle conditional and switch statements during forward analysis by splitting control flow based on guard expressions. Designed for use with CIL types, particularly statements and expressions, in static analysis tools.",
      "description_length": 352,
      "index": 3832,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Special_hooks",
      "library": "frama-c.kernel",
      "description": "Registers internal hooks for Frama-C's analysis framework, enabling custom behaviors during value analysis and other stages. Works with Frama-C's internal analysis structures and abstract domains. Used to integrate specialized analysis logic directly into the kernel for tasks like built-in function modeling or analysis event interception.",
      "description_length": 340,
      "index": 3833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cfg",
      "library": "frama-c.kernel",
      "description": "This module computes and manipulates control-flow graphs (CFGs) for C functions and files, primarily by populating predecessor and successor relationships between statements. It operates on `Cil_types.fundec` and `Cil_types.file` data structures, modifying statement fields such as `preds`, `succs`, and `sid`. Use cases include rebuilding CFGs after manually constructing functions, transforming control structures for analysis, and cleaning up CFG data before or after processing.",
      "description_length": 482,
      "index": 3834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_parser",
      "library": "frama-c.kernel",
      "description": "This module defines a comprehensive set of lexical tokens used to parse logic expressions and specifications in Frama-C's formal verification system. It includes functions to parse entire specifications, logical expressions, extension specifications, and annotations from annotated C code. These operations are essential for processing ACSL (ANSI/ISO C Specification Language) annotations during static analysis.",
      "description_length": 412,
      "index": 3835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder",
      "library": "frama-c.kernel",
      "description": "This module provides functors for building custom command-line parameters that integrate with the analysis kernel. It supports operations for defining options that manipulate kernel functions, function declarations, and abstract syntax trees. Concrete use cases include adding new command-line flags to control analysis behaviors, such as selecting specific functions or modifying analysis scope.",
      "description_length": 396,
      "index": 3836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag",
      "library": "frama-c.kernel",
      "description": "This module offers tools for pretty-printing and converting structured source elements, such as declarations (e.g., enums, functions) and localizable AST nodes (e.g., expressions, statements) with positional metadata. It supports operations to map between CIL/Frama-C AST components and their localizable representations, extract location or type details, and format code for visualization. These capabilities are particularly useful for tasks like source annotation, error diagnostics with precise location tracking, and generating human-readable code representations.",
      "description_length": 569,
      "index": 3837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Boot",
      "library": "frama-c.kernel",
      "description": "Registers initialization functions and defines the main loop for starting the Frama-C kernel. It runs analyses and sets the toplevel behavior, working with unit functions and callbacks. Used to integrate custom setup logic and control the execution flow of Frama-C during startup.",
      "description_length": 280,
      "index": 3838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Qstack",
      "library": "frama-c.kernel",
      "description": "Implements a mutable double-linked list-based stack with efficient insertion and access at both ends, supporting element reordering (move_at_top/move_at_end) and positional queries (idx). Operates on elements of type D.t with traversal, filtering, and in-place transformations, raising exceptions for invalid accesses. Useful for dynamic priority queues or history-sensitive state tracking where elements must be reordered or located by position.",
      "description_length": 446,
      "index": 3839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filter",
      "library": "frama-c.kernel",
      "description": "This module constructs a new CIL file from an existing one by selectively removing or transforming elements based on filtering rules. It operates on `Project.t` data structures, allowing the creation of sliced or modified project versions. A typical use case is generating a specialized subset of a CIL file for targeted analysis or code transformation tasks.",
      "description_length": 359,
      "index": 3840,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Translate_lightweight",
      "library": "frama-c.kernel",
      "description": "This module provides a code transformation that interprets `__declspec` annotations in source files, specifically handling lightweight specifications. It operates on the abstract syntax tree (AST) of C code, modifying it according to the semantics of these annotations. A concrete use case is enabling the integration of lightweight formal annotations into the analysis pipeline after initial cleanup phases.",
      "description_length": 408,
      "index": 3841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Clone",
      "library": "frama-c.kernel",
      "description": "Clones a kernel function and inserts the copy into the AST adjacent to the original. Operates directly on `kernel_function` data structures. Useful for duplicating functions during analysis or transformation passes, such as when generating stubs or modified versions of existing functions.",
      "description_length": 289,
      "index": 3842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph",
      "library": "frama-c.kernel",
      "description": "This module enables constructing and visualizing graphs using the Dot language through buffered file operations, supporting node and edge definitions with customizable attributes, subgraph clustering, and record-based layouts. It works with abstract graph representations (e.g., maps of node lists) and leverages external layout engines to generate structured visualizations for use cases like control flow analysis or memory model diagrams, where hierarchical or attributed graph rendering is required.",
      "description_length": 503,
      "index": 3843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Json_compilation_database",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve preprocessing flags, directories, and check for the existence of entries in a JSON compilation database for a given file path. It works directly with file paths and string lists to expose configuration data from the database when available. Concrete use cases include determining custom compilation flags per file or verifying if a file is included in the database.",
      "description_length": 408,
      "index": 3844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const",
      "library": "frama-c.kernel",
      "description": "This module offers smart constructors for creating CIL type records (e.g., void, integers, pointers, structs, enums) and utilities for manipulating CIL data structures like variables (`varinfo`), composite types (`compinfo`), and logic entities (`logic_var`, `logic_type`). It includes modules for generating unique identifiers (Vid, Sid, Eid) and supports operations such as variable renaming, composite type construction, and logic variable creation with specific scoping rules. These tools are used in CIL-based analyses and transformations to ensure consistent type representation, manage structured data, and handle fresh identifier assignment during program manipulation.",
      "description_length": 677,
      "index": 3845,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_info",
      "library": "frama-c.kernel",
      "description": "This module provides operations for extracting integer values from constants and expressions, constructing and analyzing function contracts (preconditions, postconditions, behavioral properties), and inspecting CIL types, terms, and scopes. It works with AST elements such as constants, expressions, logic terms, function specifications, CIL variables, and composite types like arrays and pointers. These utilities are used in static analysis tasks like evaluating constant expressions, validating variable lifetimes, composing function contracts, and identifying built-in functions or annotations in C code.",
      "description_length": 608,
      "index": 3846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ghost_cfg",
      "library": "frama-c.kernel",
      "description": "Performs validation of ghost statements in a control flow graph, ensuring they do not alter the normal program flow. Works directly with the code transformation category and control flow structures. Used during analysis to detect malformed ghost code without modifying the original CFG.",
      "description_length": 286,
      "index": 3847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin",
      "library": "frama-c.kernel",
      "description": "This module handles plugin registration and configuration within Frama-C, supporting operations to define plugins with customizable parameters such as booleans, integers, strings, and file paths. It provides direct access to plugin metadata, enables command-line integration, and manages visibility of plugin-specific options like `-<plugin>-share` and `-<plugin>-session`. Concrete use cases include setting up analysis plugins with user-defined settings, managing plugin-specific file paths, and synchronizing plugin state with Frama-C's project model and serialization mechanisms.",
      "description_length": 583,
      "index": 3848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp",
      "library": "frama-c.kernel",
      "description": "This module implements abstract interpretation primitives for static analysis of program values, focusing on precise numeric reasoning. It provides truth value manipulation, comparison operators, and arithmetic operations on abstract integers with support for overflow, modular constraints, and C99 semantics. Concrete use cases include tracking value ranges, modeling pointer arithmetic, and analyzing conditional expressions in program verification.",
      "description_length": 451,
      "index": 3849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.List",
      "library": "frama-c.kernel",
      "description": "This extension of OCaml's list type introduces monadic constructs like `bind`, `return`, and `product` to model non-deterministic computations, allowing the composition of operations that yield multiple possible outcomes. It operates on standard `'a list` values and integrates with boolean logic, optional values, and predicate-based transformations through dedicated submodules, while offering utilities for filtering, partitioning, and sorting elements based on structural or physical equality. The monadic framework is particularly suited for tasks like combinatorial search, exhaustive validation, or processing key-value associations where branching results must be systematically explored or combined.",
      "description_length": 708,
      "index": 3850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parse_env",
      "library": "frama-c.kernel",
      "description": "This module handles source file resolution and working directory management during parsing. It provides operations to open source files with reference scanning control, set and retrieve working directories for file paths. It is used to manage file context and resolve include paths when processing C source files in the Frama-C kernel.",
      "description_length": 335,
      "index": 3851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition",
      "library": "frama-c.kernel",
      "description": "This module provides functors to compose two monads, producing a new monad that wraps values in both the interior and exterior monads. It requires a `swap` function that reorders the monads to satisfy composition laws, ensuring the resulting structure adheres to monadic properties. Concrete use cases include combining effects like stateful computations with failure handling (e.g., composing State and Option monads) while preserving expected behavior under composition.",
      "description_length": 472,
      "index": 3852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project_output",
      "library": "frama-c.kernel",
      "description": "This module offers logging and diagnostic capabilities for the Frama-C kernel, supporting message types like verbose, debug, result, warning, error, and fatal with configurable levels and categories. It manages warning states and statuses via `warn_category` and `warn_status` types, enabling conditional output based on verbosity, terminal-aware formatting, and handling of deprecation notices, unimplemented features, and internal consistency checks.",
      "description_length": 452,
      "index": 3853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph",
      "library": "frama-c.kernel",
      "description": "This module manages a directed graph where nodes represent program states and edges encode labeled dependencies. It provides operations to add, remove, and query dependencies between states, supporting static analysis tasks such as slicing and impact analysis. It also includes functionality to generate and visualize DOT representations of the graph for debugging and reporting purposes.",
      "description_length": 388,
      "index": 3854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder",
      "library": "frama-c.kernel",
      "description": "This module builds dynamic printers that bind pretty-printing functions to objects obtained via `P()`, enabling customizable formatting of CIL and ACSL data structures. It works with CIL AST nodes, logic terms, types, and function specifications, using OCaml's `Format` module to generate readable output. It is used to produce detailed, structured dumps of program analysis data for debugging, visualization, and tooling purposes.",
      "description_length": 431,
      "index": 3855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status",
      "library": "frama-c.kernel",
      "description": "This module manages property statuses in static analysis, enabling tracking of validity under hypotheses, consolidation of statuses like `True` and `False_if_reachable`, and resolution of inconsistencies across emitters. It uses graph-based structures to model dependencies between properties and supports querying local or consolidated statuses, aiding tasks such as program correctness verification and dependency-aware analysis.",
      "description_length": 431,
      "index": 3856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rangemap",
      "library": "frama-c.kernel",
      "description": "This module implements purely applicative maps with keys ordered by a total ordering function, supporting efficient insertion, lookup, and traversal operations. It works with key types that can be ordered and value types that match a provided interface, using balanced binary trees with cached hashes for performance. Concrete use cases include managing symbol tables, tracking variable ranges in static analysis, and handling key-based data aggregation with custom comparison logic.",
      "description_length": 483,
      "index": 3857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache",
      "library": "frama-c.kernel",
      "description": "Implements low-level caches for symmetric binary predicates, storing results of pairwise comparisons between values of a given type. Provides operations to compute and cache predicate results (`merge`) and clear cached data (`clear`). Useful for optimizing repeated symmetric comparisons like equality or ordering checks in analysis passes.",
      "description_length": 340,
      "index": 3858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter_test",
      "library": "frama-c.kernel",
      "description": "This module tests the invariant computation of linear filters by applying them to predefined inputs and verifying the outputs. It works with linear filter structures and their associated data, ensuring correctness of filter transformations. A concrete use case includes validating the behavior of linear filters used in signal processing or static analysis algorithms.",
      "description_length": 368,
      "index": 3859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Descr",
      "library": "frama-c.kernel",
      "description": "This module enables safe reconstruction of structured data from serialized representations by defining type descriptors that enforce type correctness during unmarshalling. It operates on descriptors for primitive types (integers, strings) and composite structures (tuples, records, lists), supporting transformations, dynamic type handling, and channel-based input parsing. Typical applications include deserializing complex data formats like network messages or persistent storage layouts while preventing type confusion errors.",
      "description_length": 529,
      "index": 3860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Destructors",
      "library": "frama-c.kernel",
      "description": "This module identifies local variables annotated with the `__fc_destructor` attribute and inserts calls to their associated destructor functions upon exiting the variable's scope. It operates on C code during a specific transformation phase, ensuring proper cleanup of resources tied to these variables. Use cases include automatic memory deallocation or resource management for variables with well-defined lifetimes in C programs.",
      "description_length": 431,
      "index": 3861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage sets of C statements, including adding, removing, iterating, and querying statements. It supports custom serialization, change tracking via hooks, and integration with project state management. Used in static analysis plugins to collect and process control flow statements across project versions.",
      "description_length": 339,
      "index": 3862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Sanitizer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to construct strings by appending alphanumeric characters and underscores, automatically sanitizing input by removing invalid characters and normalizing separators. It manages a `buffer` type that accumulates characters, ensuring no leading, trailing, or consecutive underscores are present. Useful for generating valid identifiers or slugs from arbitrary strings.",
      "description_length": 395,
      "index": 3863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inline_stmt_contracts",
      "library": "frama-c.kernel",
      "description": "Transforms statement contracts by converting `requires` and `ensures` clauses into `assert` statements after cleanup. Works with C code structures and contract annotations. Useful for integrating contract conditions directly into code for verification or analysis passes that require explicit assertions.",
      "description_length": 304,
      "index": 3864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_api",
      "library": "frama-c.kernel",
      "description": "This module defines customizable pretty-printing configurations and line directive styles for abstract syntax trees (ASTs), supporting precise code formatting and source line tracking. It works with CIL (C Intermediate Language) statements, blocks, and function bodies, enabling tailored output for different contexts like code analysis or transformation tools. Concrete use cases include generating human-readable CIL dumps with accurate line numbers, controlling code wrapping for readability, and ensuring compatibility with C parsers when emitting intermediate code.",
      "description_length": 570,
      "index": 3865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff",
      "library": "frama-c.kernel",
      "description": "This module enables structural and semantic comparison of abstract syntax trees (ASTs) across project versions by tracking differences in variables, types, enums, statements, and ACSL annotations. It provides operations to compute and analyze AST divergences, including equivalence checks for predicates and extension-specific comparison logic, while managing version-specific state through custom hashtables. Typical use cases involve identifying codebase changes, verifying semantic consistency between project revisions, and supporting refactoring tasks through precise differencing of CIL-based ASTs.",
      "description_length": 604,
      "index": 3866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Fc_float",
      "library": "frama-c.kernel",
      "description": "This module offers arithmetic operations, IEEE comparisons, value classification (e.g., NaN, infinity), and mathematical functions like exponentials, logarithms, and trigonometric computations on floating-point values. It operates on a type `t` equivalent to OCaml's native `float`, supporting configurable rounding modes and precision settings to handle precision-specific behaviors such as next/previous value transitions. These features are critical for numerical analysis and formal verification tasks requiring strict IEEE 754 compliance and controlled rounding.",
      "description_length": 567,
      "index": 3867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dump_config",
      "library": "frama-c.kernel",
      "description": "This module provides functions to serialize the Frama-C configuration into JSON format. It outputs either a JSON object directly or prints it to standard output. The primary use case is inspecting or exporting the current analysis configuration for debugging or integration purposes.",
      "description_length": 283,
      "index": 3868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Origin",
      "library": "frama-c.kernel",
      "description": "This module enables tracking and classification of imprecise value origins (e.g., from misaligned memory accesses or unsupported arithmetic) in static analysis, using operations like merging, registration with base sets, and origin tagging at analysis locations. It manages data structures representing origin histories and associated metadata, supporting diagnostics through warning generation when new origins emerge. Key use cases include resolving garbled mixes during Eva analysis and auditing propagation of imprecise address values.",
      "description_length": 539,
      "index": 3869,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Widen_type",
      "library": "frama-c.kernel",
      "description": "This module defines and manipulates widening hints used during the Value Analysis phase to guide the abstract interpreter in refining variable approximations. It provides operations to create, combine, and query sets of hints for numeric, floating-point, and variable-specific widening behaviors at specific program points. These hints influence how the analysis merges abstract values during fixpoint computations, improving precision in specific contexts such as loops or conditionals.",
      "description_length": 487,
      "index": 3870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Intervals",
      "library": "frama-c.kernel",
      "description": "This module provides interval arithmetic operations with lattice semantics, supporting union, intersection, difference, and lattice-specific joins/meets for merging and analyzing integer ranges. It works with interval sets represented as `Int_Intervals.t`, integrating with integer types (`Int.t`), base intervals (`Int_Base.t`), and CIL types (`Cil_types.typ`), while enabling conversions from existing interval representations like `Ival.t`. Its features are particularly useful in static analysis for merging value ranges, projecting intervals to lists or singletons, and handling type-aware interval computations with error resilience during traversal.",
      "description_length": 656,
      "index": 3871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_selection",
      "library": "frama-c.kernel",
      "description": "This module supports constructing, combining, and querying sets of states with dependency-aware inclusion and exclusion operations, along with efficient traversal in arbitrary or topologically ordered sequences based on state dependencies. It works with state selections that track relationships between states, enabling precise manipulation and analysis of interdependent states. Specific use cases include static analysis tasks like program slicing and impact analysis, where managing dependencies and ensuring correct processing order are critical.",
      "description_length": 551,
      "index": 3872,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Annotations",
      "library": "frama-c.kernel",
      "description": "This module enables querying, modifying, and traversing annotations in Frama-C's AST, including function contracts (preconditions, postconditions), behaviors, and global invariants. It operates on CIL types like `kernel_function`, `stmt`, and `global_annotation`, with emitter-aware operations to manage ACSL clauses (e.g., `requires`, `assigns`) and structured iteration via `iter_*`/`fold_*` patterns. Key use cases include static analysis, contract refinement, and verification tasks requiring precise manipulation of code annotations or function specifications.",
      "description_length": 565,
      "index": 3873,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Alarms",
      "library": "frama-c.kernel",
      "description": "This module provides alarm types representing runtime errors in C code, such as division by zero, memory violations, and pointer issues, alongside collections like sets and maps to manage these alarms efficiently. It supports operations for registering, filtering, and converting alarms into annotations, working with data structures such as kernel functions, code annotations, and abstract syntax tree nodes. These capabilities are used in static analysis workflows to track safety violations, generate diagnostic predicates, and maintain alarm status during program analysis.",
      "description_length": 577,
      "index": 3874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Nat",
      "library": "frama-c.kernel",
      "description": "This module encodes Peano arithmetic directly in the OCaml type system, enabling values to carry their size as both a value and a type-level natural number. It supports operations like zero, one, succ, prev, and conversions to and from integers, ensuring precise size tracking for use in dimension-safe vector and matrix operations. Concrete use cases include enforcing correct array indexing and dimension consistency in linear algebra structures.",
      "description_length": 448,
      "index": 3875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Intervals_sig",
      "library": "frama-c.kernel",
      "description": "This module represents sets of integer intervals with a lattice structure, automatically merging consecutive intervals. It provides operations for interval arithmetic, comparison, and set manipulation, such as union, intersection, and inclusion checks. It is used in static analysis to track ranges of possible values for integer variables.",
      "description_length": 340,
      "index": 3876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Messages",
      "library": "frama-c.kernel",
      "description": "This module manages stored messages across sessions, providing operations to iterate, fold, and dump messages in emission order. It tracks message counts (errors, warnings, total) and allows resetting message flags to re-print previously shown messages. Use cases include replaying analysis logs, auditing message history, and integrating with external logging systems via global hooks.",
      "description_length": 386,
      "index": 3877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_attributes",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing attribute lists, including adding, removing, filtering, and classifying attributes based on semantic properties such as type qualifiers, storage modifiers, and array-specific annotations. It works with `attribute` and `attributes` types from `Cil_types`, organizing them in sorted lists and maintaining metadata in a global registry for attribute classification and behavior. These functions support static analysis tasks like handling C type system constructs, separating qualifiers, and processing Frama-C internal annotations for program transformation and verification.",
      "description_length": 618,
      "index": 3878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unicode",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific Unicode string representations for set operations, such as inset, empty set, top, bottom, and union. It works with Unicode strings to support proper rendering of mathematical symbols. These functions are used when displaying abstract values or set-based analyses in a readable, symbol-rich format.",
      "description_length": 349,
      "index": 3879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Allocates",
      "library": "frama-c.kernel",
      "description": "This module adds `allocates \\nothing` clauses to functions and loops in CIL code. It operates on kernel functions and automatically ensures they have allocation safety guarantees unless already specified. Use it to enforce memory allocation constraints during static analysis.",
      "description_length": 276,
      "index": 3880,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Win_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific directory paths used by the Frama-C kernel, such as cache, configuration, and state directories. It works with string values representing environment variables and paths, returning them as typed filepaths. These functions are used to locate Frama-C's internal directories during execution, particularly in contexts like plugin initialization or resource management.",
      "description_length": 417,
      "index": 3881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Infer_assigns",
      "library": "frama-c.kernel",
      "description": "This module generates possible assignment targets from a C function prototype. It provides the `from_prototype` function, which takes a kernel function and returns a list of `from` expressions representing potential assignments. It is used in static analysis to infer which memory locations a function may modify based on its prototype.",
      "description_length": 336,
      "index": 3882,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins",
      "library": "frama-c.kernel",
      "description": "This module manages built-in C functions and templates during CIL processing, providing operations to register, query, and manipulate function metadata with support for compiler-specific variants (GCC, MSVC). It works with `varinfo`, `builtin_template`, and compiler types to handle function prototypes, attributes, and specialization, enabling static analysis tasks such as resolving built-in references and tracking unused or special functions. Concrete use cases include initializing Frama-C's libc built-ins, registering custom built-ins with machine-dependent types, and tracking GCC template loading state for analysis synchronization.",
      "description_length": 641,
      "index": 3883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Bitvector",
      "library": "frama-c.kernel",
      "description": "The module provides functions for creating and manipulating fixed-size bitvectors, including bitwise operations (AND, OR, XOR, NOT, equality), multi-operand computations, concatenation, and iteration over set bits. It operates on bitvectors (type `t`) using integer indices and bit widths to manage specific segments, with utilities for resizing and pretty-printing. This functionality is tailored for low-level tasks requiring precise bit-level control, such as binary analysis or hardware modeling.",
      "description_length": 500,
      "index": 3884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Markdown",
      "library": "frama-c.kernel",
      "description": "This module supports programmatic creation of Markdown content with inline elements (emphasis, links, code) and block-level components (lists, headers, tables, code blocks), structured through types like `inline`, `block_element`, and `pandoc_markdown`. It enables metadata embedding, file content inclusion, hierarchical document structuring, and identifier management, with utilities for precise layout control and cross-referencing. Typical use cases include automated technical documentation generation, report formatting, and building complex Markdown artifacts requiring programmatic precision.",
      "description_length": 600,
      "index": 3885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabshelper",
      "library": "frama-c.kernel",
      "description": "This module provides functions for managing Cabs location identifiers, retrieving source code locations from program elements, and handling attributes and behaviors during static analysis. It works with Cabs data structures such as `cabsloc`, `definition`, `statement`, and `spec_elem`, and supports operations like comment association, digit conversion, and inline/static specifier checks. Concrete use cases include tracking source code annotations, constructing function behaviors with pre/post conditions, and processing inline assembly templates.",
      "description_length": 551,
      "index": 3886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Pretty_utils",
      "library": "frama-c.kernel",
      "description": "This module provides advanced pretty-printing operations for structuring text with customizable layout controls, handling lists, arrays, options, pairs, and custom iterable structures. It supports alignment of collections, margin-constrained output, and text width tracking through a dedicated *marger* type, enabling precise formatting for scenarios like code generation or report layout. Key capabilities include conditional printing, delimiter customization, and bounded text representation with alignment options.",
      "description_length": 517,
      "index": 3887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2",
      "library": "frama-c.kernel",
      "description": "This module implements data flow analyses for propagating domain-specific information across a program's control flow graph, supporting both forwards and backwards analysis strategies. It works with statements annotated with user-defined data, stored and manipulated using statement-indexed hash tables, and provides mechanisms to compute transfer functions across the control flow. Concrete use cases include constant propagation, liveness analysis, and backward constant tracking, where data is initialized at statements and propagated through function control structures.",
      "description_length": 574,
      "index": 3888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Task",
      "library": "frama-c.kernel",
      "description": "This module enables composing asynchronous workflows with sequencing combinators (`>>=`, `>>>`), cancellation handling, and system process execution via `command`, while managing concurrency through thread pools and synchronization primitives like mutexes. It operates on task, status, server, and pool types to support orchestrating error-resilient pipelines, monitoring background execution with progress tracking, and integrating GUI-driven idle handling via server event callbacks. Use cases include launching I/O-captured processes, coordinating shared task templates, and managing cancellable, synchronized computations in interactive applications.",
      "description_length": 654,
      "index": 3889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing",
      "library": "frama-c.kernel",
      "description": "This module provides logic type-checking and environment management for ACSL annotations, focusing on resolving variables and types within scoped logic environments (`Lenv.t`), handling built-in labels, and performing arithmetic and structural type coercions. It supports operations like adding logic variables and `\\result` to environments, verifying expressions in pre/post-state contexts, and managing custom ACSL extensions through typing handlers. Key applications include type-checking logic expressions during static analysis and maintaining environments for verifying C code properties such as preconditions, postconditions, and invariants.",
      "description_length": 648,
      "index": 3890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Macos_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve OS-specific directory paths such as user home, cache, configuration, and state directories. It works with string-based environment variables and file paths, returning them as `Filepath.t` values. Concrete use cases include locating user-specific storage locations or setting up application directories on macOS systems.",
      "description_length": 362,
      "index": 3891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Command",
      "library": "frama-c.kernel",
      "description": "This module handles file operations, system command execution, and timing measurements. It provides functions for reading and writing files, interacting with system processes asynchronously or synchronously, and measuring execution time using system clocks. Concrete use cases include copying file contents, running external commands with captured output, and profiling code performance with precise timing.",
      "description_length": 407,
      "index": 3892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_descriptive_printer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to print CIL expressions and l-values using descriptive names instead of temporary variable names. It works with CIL's intermediate representation of C code, specifically expressions and l-values. Use this module to generate more readable output for end users, such as in error messages or analysis reports.",
      "description_length": 338,
      "index": 3893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alpha",
      "library": "frama-c.kernel",
      "description": "This module manages alpha conversion during renaming, primarily by generating unique names with numeric suffixes and tracking used prefixes in a table. It provides functions to create new names based on existing ones, register existing names to avoid conflicts, split names into prefix and infix components, and undo prior renaming operations. Use cases include variable renaming in static analysis to ensure uniqueness while preserving readability, particularly during transformations that require introducing fresh identifiers.",
      "description_length": 529,
      "index": 3894,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_Base",
      "library": "frama-c.kernel",
      "description": "This module provides arithmetic operations, comparisons, hashing, and utilities for handling abstract values (like `Top`) on arbitrary-precision integers. It works with big integers extended with a `Top` element to represent unknown or undefined values, supporting conversions between `Integer.t` and `Int_Base.t`. It is used in abstract interpretation to model imprecise integer values and enable project-specific queries requiring value projection or injection.",
      "description_length": 463,
      "index": 3895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inline",
      "library": "frama-c.kernel",
      "description": "This module provides functions to inline logic function and predicate applications within terms and predicates during analysis. It operates on CIL types such as `term`, `predicate`, and `logic_info`, applying inlining based on a user-defined condition. Use cases include simplifying logical expressions by expanding definitions, optimizing or transforming code during static analysis, and eliminating recursion or complex logic for verification purposes.",
      "description_length": 454,
      "index": 3896,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parray",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent array structure with efficient indexing, supporting operations like initialization with a given size and function, element access, and in-place updates. It provides folding and mapping functions for transforming and aggregating elements, along with pretty-printing capabilities for debugging or logging. Use cases include managing state arrays in symbolic execution or storing indexed data during static analysis passes.",
      "description_length": 456,
      "index": 3897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Tr_offset",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates sets of bit-level offsets, supporting operations like trimming offset ranges based on memory validity. It works with integer values and intervals, using constructors like `Interval`, `Set`, and `Overlap` to capture precise or approximate valid offset regions. It is used to model memory access validity in static analysis, particularly when determining which offset ranges are safe to access given a base pointer's validity.",
      "description_length": 463,
      "index": 3898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unfold_loops",
      "library": "frama-c.kernel",
      "description": "Performs syntactic loop unfolding during the after-cleanup phase using the code transformation hook mechanism. Applies to C code by transforming loops into their expanded form based on a specified unfolding factor. Useful for optimizing or analyzing loop behavior in generated C code without altering program semantics.",
      "description_length": 319,
      "index": 3899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval",
      "library": "frama-c.kernel",
      "description": "This module provides operations for integer intervals with congruence constraints, combining bounded ranges and modular arithmetic. It supports set operations (union, intersection, difference), lattice operations (widening, inclusion checks), and arithmetic/bitwise manipulations (negation, division, bit operations) on intervals defined by optional min/max bounds and congruence parameters (rem, modu). These tools are used in static analysis to track variable ranges, modular properties (e.g., loop counters, bitfields), and cardinality constraints, leveraging collections like sets, maps, and hashtables for efficient representation and querying.",
      "description_length": 649,
      "index": 3900,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rich_text",
      "library": "frama-c.kernel",
      "description": "This module enables buffer-based creation and manipulation of structured text with embedded formatting tags, supporting operations like substring extraction, tag queries, and callback-driven traversal of tagged elements. It works with mutable text buffers and tagged content representations to facilitate tasks such as generating code listings with syntax highlighting, producing indented logs, or assembling dynamic text with mixed styling. Key features include layout-preserving pretty-printing, whitespace trimming, and customizable string conversion with margin controls for structured output formatting.",
      "description_length": 608,
      "index": 3901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cilconfig",
      "library": "frama-c.kernel",
      "description": "This module handles loading, saving, and managing hierarchical configuration data from files, using a variant type to represent integers, booleans, floats, strings, and lists. It provides functions to set and retrieve configuration values by key, with specialized accessors for each data type. It is used to persist and read user settings in Frama-C's GUI, such as interface preferences or analysis parameters.",
      "description_length": 410,
      "index": 3902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter",
      "library": "frama-c.kernel",
      "description": "This module supports creating and managing entities that generate annotations and property statuses during static analysis, with customizable parameters for emitter behavior. It works with structured data through standard collection modules (sets, maps, hashtables) and provides predefined emitters for different analysis contexts (user-facing, kernel-level, orphaned). Used in analysis plugins and metadata handling to track property states and emit verification results.",
      "description_length": 472,
      "index": 3903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ghost_accesses",
      "library": "frama-c.kernel",
      "description": "Performs static checks to ensure memory accesses respect the `\\ghost` qualifier's constraints, verifying that only ghost code can declare or modify ghost memory. Works with the abstract syntax tree and semantic annotations of a C-like language. Validates correctness during static analysis phases without modifying code structure.",
      "description_length": 330,
      "index": 3904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base",
      "library": "frama-c.kernel",
      "description": "This module provides operations for modeling abstract memory zones and their validity, including checks for alignment, offset validity, and memory access permissions (read/write/global/local). It works with memory base abstractions (`Base.t`), sets and maps for efficient region management, and heterogeneous data structures (`Hptshape`) to track relationships between memory entities. Specific use cases include static analysis of C programs to verify memory safety, track variable origins, and enforce validity constraints during abstract interpretation.",
      "description_length": 556,
      "index": 3905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Utf8_logic",
      "library": "frama-c.kernel",
      "description": "This module provides UTF-8 string constants for logical symbols (quantifiers, connectives, set operations) and mathematical symbols (\u2124, \u211d, \u03c0, \u221e), alongside a function to encode Unicode code points into UTF-8 strings. It operates on Unicode scalar values and produces UTF-8 byte sequences, primarily serving formal verification workflows where symbolic representations are required for logic expressions, theorem proving, or generating human-readable outputs with precise mathematical notation.",
      "description_length": 493,
      "index": 3906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Exn_flow",
      "library": "frama-c.kernel",
      "description": "Handles exception flow analysis in the AST by tracking which exceptions each kernel function may throw. It provides functions to retrieve exception sets for functions, compute exception flow information, and transform functions to return union types that represent both normal results and exceptions. This supports precise analysis of exception propagation and error handling in C code.",
      "description_length": 386,
      "index": 3907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Precise_locs",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage precise memory offsets and locations for modeling memory accesses in complex l-values (e.g., nested arrays, pointer dereferences) with higher accuracy than standard abstract domains. It introduces transient data structures like `precise_offset` and `precise_location` to track detailed memory regions, enabling tasks such as validity checks, substitution, and conversion between imprecise representations. These structures are particularly useful in static analysis scenarios requiring fine-grained precision for semi-imprecise expressions, though their lack of lattice structure limits their use to temporary modeling during analysis.",
      "description_length": 675,
      "index": 3908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Json",
      "library": "frama-c.kernel",
      "description": "This module enables constructing, parsing, and serializing JSON values by converting OCaml primitives (booleans, integers, strings) and composite types (lists, options) into JSON structures like objects and arrays, with utilities to filter null fields and merge nested values using customizable semantics. It operates on an abstract JSON type and facilitates input/output through strings, files, or channels, offering pretty-printing, memory-efficient caching for file operations, and transformations like folding over arrays or extracting nested fields. Typical applications include configuration management, data interchange between systems, and hierarchical data processing where structured JSON manipulation is required.",
      "description_length": 724,
      "index": 3909,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project_skeleton",
      "library": "frama-c.kernel",
      "description": "This module defines a project skeleton with a unique identifier, mutable name, and unique name. It provides a dummy instance and a submodule for generating uniquely named project skeletons, directly supporting project creation and renaming operations. Concrete use cases include managing distinct project instances during static analysis where unique identification and name tracking are required.",
      "description_length": 397,
      "index": 3910,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing maps that associate bases with memory maps, where each memory map is structured according to the `Offsetmap` module. It supports querying, updating, and iterating over these base-to-memory-map associations. Concrete use cases include tracking memory states in static analysis tools, particularly when reasoning about pointer values and their associated memory offsets.",
      "description_length": 412,
      "index": 3911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dyncall",
      "library": "frama-c.kernel",
      "description": "This module handles dynamic call analysis in C code, providing functions to retrieve and print dynamic call information. It works with CIL statements and kernel functions, specifically tracking dynamic calls during WP analysis. Use cases include inspecting dynamic dispatch sites and generating call lists for specific functions.",
      "description_length": 329,
      "index": 3912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast",
      "library": "frama-c.kernel",
      "description": "This module provides direct access to the CIL AST used by Frama-C, allowing retrieval, modification, and state tracking of the AST through functions like `get`, `mark_as_changed`, and `mark_as_grown`. It works with `Frama_c_kernel.Cil_types.file`, representing the typed C abstract syntax tree, and supports use cases such as AST transformation, incremental analysis, and plugin-specific AST updates. The module also enables registration of hooks for post-computation and update actions, facilitating integration with analysis passes and GUI components.",
      "description_length": 553,
      "index": 3913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_topological",
      "library": "frama-c.kernel",
      "description": "This module implements topological traversal of state graphs, providing `fold` and `iter` functions that process nodes in dependency order while handling cycles. It operates on graphs composed of `Frama_c_kernel.State.t` nodes, organized according to a user-defined graph structure `G`. It is suitable for analyzing control flow or dependency graphs where states must be processed in an order that respects their interdependencies.",
      "description_length": 431,
      "index": 3914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Escape",
      "library": "frama-c.kernel",
      "description": "This module provides functions to escape characters and strings according to C lexical rules. It supports both regular strings and wide character representations, with types `wchar` as `int64` and `wstring` as a list of `wchar`. These functions are useful for generating valid C string literals and handling wide character encoding in C code analysis.",
      "description_length": 351,
      "index": 3915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap",
      "library": "frama-c.kernel",
      "description": "This module implements interval maps with bitwise semantics, allowing creation, querying, and combination of intervals that map to values. It supports operations like `join` to merge overlapping intervals and inclusion checks to determine interval coverage. It is used in static analysis to track and combine dataflow information across program segments efficiently.",
      "description_length": 366,
      "index": 3916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations",
      "library": "frama-c.kernel",
      "description": "This module offers abstractions for memory locations at byte and bit levels, enabling static analysis tasks like union, intersection, inclusion checks, and offset arithmetic on types such as `Location_Bytes.t`, `Location_Bits.t`, and `Zone.t`. It supports precise modeling of pointer arithmetic, memory regions, and bitfields through lattice-based transformations, alignment checks, and cardinality validation. Key applications include analyzing memory safety properties, handling imprecise values via widening/narrowing, and enumerating valid memory bits for variables or access patterns.",
      "description_length": 589,
      "index": 3917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap",
      "library": "frama-c.kernel",
      "description": "This module implements efficient maps from hash-consed trees to values using big-endian Patricia trees. It supports operations for inserting, looking up, and traversing key-value pairs where keys are structured as hash-consed trees. Concrete use cases include managing symbol tables and optimizing key-based data structures in formal verification tools.",
      "description_length": 353,
      "index": 3918,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig",
      "library": "frama-c.kernel",
      "description": "This module defines abstract interfaces for managing command-line options using sets, lists, maps, and multi-maps with string-based keys and values. It supports parsing and handling various data types\u2014such as booleans, integers, floats, strings, file paths, and directories\u2014to enable structured configuration of analysis tools via the command line. Specific use cases include customizing tool behavior through command-line arguments, handling hierarchical option data, and building complex option sets for static analysis workflows using a builder pattern.",
      "description_length": 556,
      "index": 3919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder",
      "library": "frama-c.kernel",
      "description": "This module builds and transforms C and logic expressions and types using polymorphic representations, handling composite types, qualifiers, and expressions such as arithmetic, memory, and control-flow operations. It operates on CIL AST nodes including types, expressions, lvalues, and statements, enabling static analysis tasks like modeling program behavior, verifying properties, and generating typed intermediate representations. Concrete use cases include constructing ACSL annotations, manipulating pointer and array expressions, and building verification conditions in Frama-C plugins.",
      "description_length": 592,
      "index": 3920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_lattice_with_isotropy",
      "library": "frama-c.kernel",
      "description": "This module defines a lattice structure for offset maps with isotropy, supporting operations like meet, join, and widening. It works with data types representing memory offsets and their associated values, enabling precise static analysis of memory accesses. Concrete use cases include tracking pointer arithmetic and array bounds in program analysis.",
      "description_length": 351,
      "index": 3921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Extlib",
      "library": "frama-c.kernel",
      "description": "This module offers utilities for list manipulation with tail-recursive operations like slicing and safe indexing, string processing for tasks like prefix removal and sanitization, and file system interactions including temporary directory management and cleanup. It works with lists, optional values, strings, file paths, and process exit hooks, enabling use cases such as error-resilient list transformations, case-insensitive string comparisons, and system resource handling. Additional features include function composition, alternative comparison operators for basic types, and utilities for managing temporary files and directories.",
      "description_length": 637,
      "index": 3922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filecheck",
      "library": "frama-c.kernel",
      "description": "Performs consistency checks on CIL abstract syntax trees, ensuring structural integrity and detecting anomalies in the current project's AST or a provided one. Supports extending check functionality through customizable checkers that integrate with the existing validation pipeline. Useful for verifying correctness after transformations or during development when AST modifications are frequent.",
      "description_length": 396,
      "index": 3923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep",
      "library": "frama-c.kernel",
      "description": "This module manages machine-dependent configurations and properties, providing structured access to architecture-specific details like type sizes, alignment requirements, endianness, and compiler-specific flags. It supports operations to serialize and deserialize machine descriptions using YAML, and to generate C preprocessor macros and headers that reflect the target architecture's characteristics. Concrete use cases include configuring static analysis for specific platforms, generating platform-adapted preprocessor definitions, and validating code behavior across different machine environments.",
      "description_length": 603,
      "index": 3924,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_parse_string",
      "library": "frama-c.kernel",
      "description": "This module provides functions to parse logic expressions, terms, and predicates from strings within a specified function context. It supports parsing code annotations, term lvalues, terms, and predicates, using optional location and environment parameters. It is used to construct logic entities directly from string representations during static analysis or plugin development.",
      "description_length": 379,
      "index": 3925,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad",
      "library": "frama-c.kernel",
      "description": "This module provides tools to define and extend monads using minimal interfaces like `bind` or `map`, supporting both basic and product-aware monads. It works with parametric types representing effectful computations, such as `option`, `list`, or custom analysis contexts, and generates derived operations like `flatten`, `map`, and `product`. Use it to implement analysis passes that sequence effectful operations\u2014such as handling conditional control flow, combining results from multiple computations, or chaining transformations with error propagation\u2014while ensuring correctness under monadic laws.",
      "description_length": 601,
      "index": 3926,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Bit_utils",
      "library": "frama-c.kernel",
      "description": "This module provides functions for bit-level type analysis and memory layout computations, including determining sizes of types in bits or bytes, checking type signs, and resolving symbolic offsets within structured types. It operates on CIL types, lvals, and varinfos, supporting precise queries about memory layouts and type compatibility. Concrete use cases include analyzing bitfields, resolving array or pointer element sizes, and mapping numeric bit offsets to symbolic CIL offsets for structured type traversal.",
      "description_length": 518,
      "index": 3927,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_customize",
      "library": "frama-c.kernel",
      "description": "This module configures command-line parameters for plugins, allowing fine-grained control over option behavior such as stage assignment, serialization, and visibility. It supports boolean, string, and function name parameters, enabling features like negative options, unset actions, and function name mangling. Concrete use cases include restricting parameter scope, customizing help messages, and ensuring valid function references in command-line arguments.",
      "description_length": 459,
      "index": 3928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Description",
      "library": "frama-c.kernel",
      "description": "This module provides functions to format and print source code elements and properties, including statements, instructions, predicates, and regions, with optional contextual information like locations or labels. It handles data types such as `stmt`, `kinstr`, `identified_predicate`, `funbehavior`, and `Property.t`, often integrating with CIL types. Concrete use cases include generating human-readable output for analysis results, exporting property data to CSV, and displaying localized or simplified property representations in user interfaces or reports.",
      "description_length": 559,
      "index": 3929,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel",
      "library": "frama-c.kernel",
      "description": "This module provides facilities for structured diagnostic logging, warning management, and kernel configuration in Frama-C's analysis pipeline. It operates on categorized diagnostic messages, severity levels, and typed configuration flags (boolean, integer, string) to control behaviors like static analysis checks, code transformation phases, and plugin-specific settings. Key use cases include suppressing redundant warnings during C code parsing, enabling debug output for specific analysis stages (e.g., type inference or constant folding), and persisting project-specific analysis configurations through command-line integration and session state management.",
      "description_length": 663,
      "index": 3930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabs",
      "library": "frama-c.kernel",
      "description": "This module represents the untyped C Abstract Syntax Tree (AST) with constructs for expressions, statements, and declarations. It includes data types for C language elements such as type specifiers, structure and union definitions, enumeration items, and attributes, along with source code location tracking using file positions. It is used for parsing and manipulating C code during static analysis tasks such as those performed by Frama-C plugins.",
      "description_length": 449,
      "index": 3931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project",
      "library": "frama-c.kernel",
      "description": "This component provides operations for managing concurrent projects that encapsulate AST-dependent internal states, enabling creation, naming, persistence via save/load, and undo/redo functionality through state snapshots. It supports use cases like deterministic analysis workflows, plugin-specific state isolation, and multi-project verification scenarios requiring rollback capabilities or cross-project data separation.",
      "description_length": 423,
      "index": 3932,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Errorloc",
      "library": "frama-c.kernel",
      "description": "This module tracks and manipulates source code location information during parsing, providing functions to set and retrieve the current file, line, and working directory. It supports error reporting with contextual location details, including line numbers, file names, and source code snippets with underlined positions. Use cases include handling preprocessor-generated line markers, printing precise error messages with context, and managing location state during lexing and parsing operations.",
      "description_length": 496,
      "index": 3933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior",
      "library": "frama-c.kernel",
      "description": "This module manages visitor behaviors for AST transformations, providing strategies for in-place modification, copying, and refreshing of mutable structures with control over identifier freshness. It works with project states and AST elements like variables, statements, and function definitions, enabling precise tracking and updating of element representations during analysis or transformation passes. Concrete use cases include rewriting code while maintaining correct references, copying and renaming variables in a new context, and resetting visitor state between transformation stages.",
      "description_length": 592,
      "index": 3934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cprint",
      "library": "frama-c.kernel",
      "description": "This module offers functions to convert and format elements of the Cabs AST into human-readable strings, utilizing OCaml's `Format` module. It handles components such as declarations, expressions, statements, and structural elements like enumerations and attributes, with configurable output options for details like comments and counters. The functionality is useful for generating code representations, debugging AST structures, or producing analysis reports with customized formatting.",
      "description_length": 488,
      "index": 3935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Vector",
      "library": "frama-c.kernel",
      "description": "This module implements extensible arrays with dynamic resizing, supporting operations such as adding elements, indexed access, iteration, mapping, and conversion to and from OCaml arrays. It works with polymorphic vectors of type `'a t`, allowing element manipulation with bounds-checked getters and setters, and provides control over internal capacity for performance optimization. Concrete use cases include building dynamic collections of values efficiently, such as collecting analysis results during static code analysis, or maintaining resizable buffers for incremental data processing.",
      "description_length": 592,
      "index": 3936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Statuses_by_call",
      "library": "frama-c.kernel",
      "description": "This module manages specialized statuses of function preconditions at specific call sites. It provides functions to create, retrieve, and replace precondition copies tied to individual call statements, supporting both direct and indirect function calls. Use cases include tracking the validity of preconditions per call instance, enabling precise analysis of function call contracts in static analysis workflows.",
      "description_length": 412,
      "index": 3937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_types_debug",
      "library": "frama-c.kernel",
      "description": "This module includes pretty-printing utilities for converting a wide range of data types\u2014including primitive values, collections, and complex CIL structures like AST nodes, logic terms, and analysis artifacts\u2014into customizable human-readable formats. It operates on CIL's abstract syntax trees, semantic types, and formal logic constructs, using formatters to produce structured output. These tools are primarily used for debugging static analysis workflows, visualizing program representations, and logging intermediate states during verification tasks.",
      "description_length": 554,
      "index": 3938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto",
      "library": "frama-c.kernel",
      "description": "This module computes weak topological orderings (WTOs) for graphs using the Bourdoncle algorithm, organizing nodes into hierarchically ordered components. It provides operations to partition graphs, extract heads of partitions, flatten partitions into lists, and fold over partition heads. It is used to determine efficient evaluation orders for fixed-point computations in program analysis, particularly when working with control flow graphs.",
      "description_length": 443,
      "index": 3939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph",
      "library": "frama-c.kernel",
      "description": "Implements service computation algorithms over custom graph structures with labeled vertices and edges. Provides imperative manipulation of graph elements and supports visualization through DOT format output or Frama-C GUI display. Used for static analysis tasks like impact propagation and dependency resolution in software systems.",
      "description_length": 333,
      "index": 3940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata",
      "library": "frama-c.kernel",
      "description": "This module provides operations to construct and analyze control flow graphs as automata with vertices representing control points and edges encoding CIL-derived guards and actions. It supports abstract interpretation tasks like reachability analysis, invariant generation, and semantic equivalence checking through forward/backward dataflow analyses, leveraging weak topological orderings for efficient traversal. Applications include modeling program behavior under operational semantics and computing reachable states via structured loop analysis or visualization tools.",
      "description_length": 573,
      "index": 3941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for analyzing, transforming, and generating CIL's intermediate representation of C programs, focusing on function and type manipulation, expression construction, and AST traversal. It operates on core CIL data structures such as functions, variables (`varinfo`), types (`typ`), expressions (`exp`), statements (`stmt`), and logic terms, enabling tasks like type checking, constant folding, and control flow analysis. Specific use cases include C-to-CIL translation, static analysis passes, code optimization, and formal verification workflows that require precise control over program structure and semantics.",
      "description_length": 640,
      "index": 3942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_builtin",
      "library": "frama-c.kernel",
      "description": "This module manages the registration and initialization of logic builtins within a project's environment. It provides operations to globally register builtins for all projects or add them specifically to the current project. Use cases include extending the logic environment with custom builtins during plugin development or initializing standard logic functions for analysis.",
      "description_length": 376,
      "index": 3943,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations such as `bind` (with reversed argument order), `map`, `fold`, and `iter` to handle optional values, alongside utilities like `to_list` and `to_seq` for converting options into collections. It enables safe composition of computations that may fail, with submodules supporting boolean logic, list integration, and operator chaining, making it ideal for error propagation, optional data transformations, and building robust functional pipelines.",
      "description_length": 482,
      "index": 3944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement",
      "library": "frama-c.kernel",
      "description": "This module represents weak topological orderings (WTOs) of CIL statements and provides operations to compute and manipulate these orderings. It includes functions to retrieve the WTO of a kernel function, obtain the WTO index of a statement, and compute differences between indices or statements, indicating components left and entered in the control-flow graph. It is used for analyzing control flow dependencies and managing fixpoint computations in C program analysis.",
      "description_length": 472,
      "index": 3945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_types",
      "library": "frama-c.kernel",
      "description": "This module defines core data types representing CIL elements\u2014such as operators, integer and floating-point types, control flow constructs, and program-wide entities like functions and globals\u2014alongside equality functions for structural comparison. It also introduces the `syntactic_scope` type to model visibility contexts in C programs, including global, block-local, and translation unit scopes, enabling precise symbol resolution and analysis in static code transformations.",
      "description_length": 478,
      "index": 3946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Temp_files",
      "library": "frama-c.kernel",
      "description": "This module creates and manages temporary files and directories that are automatically deleted upon program exit, unless explicitly preserved. It works with file paths and accepts parameters for file naming, keeping files based on a boolean flag or debug setting. Concrete use cases include generating temporary C files during analysis or creating scratch directories for intermediate results, ensuring cleanup unless debugging requires preservation.",
      "description_length": 450,
      "index": 3947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer",
      "library": "frama-c.kernel",
      "description": "This module formats CIL AST elements\u2014including variables, expressions, statements, function definitions, annotations, logic predicates, and loop-specific constructs\u2014into human-readable text using OCaml's `Format` module. It supports configurable output via options like skipping annotations, forcing braces, or dynamically extending printers, enabling use cases such as debugging, generating readable code representations, or integrating with analysis workflows.",
      "description_length": 462,
      "index": 3948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_float",
      "library": "frama-c.kernel",
      "description": "This module offers numerical operations on typed floating-point values represented via a GADT indexed by format types (single/double/long precision), supporting arithmetic, comparisons, mathematical functions (sqrt, exp, trigonometric variants), and format-preserving conversions with controlled rounding. It enables precise manipulation of floating-point properties like extremal values, NaN/infinity checks, and bit-level representations, catering to formal verification tasks requiring strict alignment with C's floating-point semantics and numerical analysis workflows.",
      "description_length": 573,
      "index": 3949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_const",
      "library": "frama-c.kernel",
      "description": "This component enables the creation and manipulation of logic annotations, predicates, and terms with unique identifiers, supporting formal verification tasks like function specifications and ACSL extension development. It operates on logic types such as predicates, terms, labels, and offsets, offering operations for constructing logical expressions (e.g., quantifiers, implications), type abstractions (sets, function arrows), and predefined ACSL predicates (e.g., `\\valid`, `\\separated`). Key use cases include generating fresh identifiers for labels in proof obligations, transforming logic terms via coercion or casting, and building complex annotations for static analysis.",
      "description_length": 680,
      "index": 3950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Frontc",
      "library": "frama-c.kernel",
      "description": "This module provides functions for parsing C files and applying syntactic transformations to the abstract syntax tree (AST). It operates on C source files, producing both Cabs and CIL representations of the code. The `parse` function reads a file and returns a thunk to generate a CIL file alongside the Cabs AST, while `add_syntactic_transformation` allows modifying the Cabs AST of newly parsed files. Use cases include integrating custom AST rewriters for static analysis or code transformation tools that target C source code.",
      "description_length": 530,
      "index": 3951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Clexer",
      "library": "frama-c.kernel",
      "description": "This module provides functions for lexing C source code, including initializing and finalizing the lexer, managing lexical contexts, and adding type or variable names. It works with lexical buffers and C tokens, and supports operations like recognizing logic formulae in comments and checking if a string is a C keyword. Concrete use cases include parsing C code with custom type and variable definitions, handling nested lexical scopes, and extracting source locations during lexing.",
      "description_length": 484,
      "index": 3952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Substitute_const_globals",
      "library": "frama-c.kernel",
      "description": "Substitutes global variables marked with the `const` attribute with their initializer values during CIL processing. Operates on CIL structures, specifically global declarations and expressions. Useful for optimizing code by eliminating unnecessary global variables and enabling further constant propagation.",
      "description_length": 307,
      "index": 3953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear",
      "library": "frama-c.kernel",
      "description": "This module defines operations for linear spaces over a field, including vector addition, scalar multiplication, and matrix transformations. It works with fixed-dimension vectors and matrices parameterized by a scalar field type. Used to compute linear invariants and perform static analysis in verification tasks.",
      "description_length": 314,
      "index": 3954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field",
      "library": "frama-c.kernel",
      "description": "This module defines a signature for mathematical fields, supporting operations such as addition, multiplication, inversion, and comparisons. It works with abstract data types that represent field elements, including numeric types used to model floating-point computations. Concrete use cases include implementing algebraic structures like rationals or reals, and providing a foundation for precise numerical analysis in static program verification.",
      "description_length": 448,
      "index": 3955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unix_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific directory paths used by the Frama-C kernel, such as home, cache, configuration, and state directories. It works with string lists and environment variables to determine these paths, returning them as `Filepath.t` values. Concrete use cases include locating user-specific storage directories and resolving default paths for Frama-C's internal data.",
      "description_length": 399,
      "index": 3956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Populate_spec",
      "library": "frama-c.kernel",
      "description": "This module generates missing function specifications for C code analysis, supporting clauses like `Requires`, `Assigns`, and `Terminates`. It works with CIL types such as `kernel_function`, `identified_predicate`, and `assigns`, and allows customizing generation modes via options. Use it to automatically infer preconditions, postconditions, and termination guarantees during static analysis.",
      "description_length": 394,
      "index": 3957,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset",
      "library": "frama-c.kernel",
      "description": "This module provides operations for creating, manipulating, and querying sets of ordered elements, including union, intersection, difference, and membership checks. It works with any ordered type that satisfies the `S_Basic_Compare` or `S` module type, allowing for customizable comparison logic. Concrete use cases include tracking collections of program variables, managing analysis states, and efficiently handling disjoint or overlapping element groups in static analysis tasks.",
      "description_length": 482,
      "index": 3958,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cabs2cil",
      "library": "frama-c.kernel",
      "description": "This module provides functions for translating C code into CIL, focusing on AST transformation and normalization. It handles operations like resolving implicit prototypes, managing type compatibility under C99 rules, tracking side-effects, and converting control structures, while working with CIL representations of expressions, statements, variables, and types. It supports static analysis tools by ensuring accurate semantic preservation during translation, particularly for edge cases like dropped expressions or address-of operations.",
      "description_length": 539,
      "index": 3959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise",
      "library": "frama-c.kernel",
      "description": "Implements a lattice structure for bitwise maps over memory zones with operations like join, meet, and inclusion checks. Works with abstract domains such as `LOffset.t`, `Zone.t`, and `Base.t`, supporting interval-based map manipulations including merging, filtering, and folding. Used for static analysis tasks like tracking memory access patterns and verifying pointer arithmetic.",
      "description_length": 382,
      "index": 3960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue",
      "library": "frama-c.kernel",
      "description": "This module provides abstract interpretation capabilities for analyzing C program memory and values, supporting operations like lattice manipulations, bit-level transformations, and memory state merging. It works with abstract memory representations including byte-indexed locations, scalar values, offset maps, and tagged uninitialized states, organized through bases, intervals, and flags. Concrete use cases include tracking pointer aliasing, refining value ranges, detecting undefined behavior, and managing memory state approximations during static analysis.",
      "description_length": 563,
      "index": 3961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor",
      "library": "frama-c.kernel",
      "description": "This module enables traversal and transformation of CIL-based AST elements (e.g., functions, expressions, annotations) using project-aware visitors that support in-place modification or deep copying with optional identifier refreshing. It operates on CIL structures like code annotations, logical predicates, and behavioral specifications while maintaining consistency with global project state through dedicated copying logic. Key applications include formal annotation manipulation, project-preserving AST refactoring, and ACSL extension handling during static analysis workflows.",
      "description_length": 582,
      "index": 3962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type",
      "library": "frama-c.kernel",
      "description": "This module defines lattice structures and operations used for abstract interpretation in Frama-C, including join semi-lattices, bounded lattices, and lattices with top, bottom, and narrowing operators. It supports data types such as abstract values, sets, and products, with functions for over- and under-approximations, intersection, difference, and cardinality checks. Concrete use cases include implementing abstract domains for static analysis, such as intervals, bitsets, or symbolic ranges, where precise join, meet, or widening operations are required to converge analysis results.",
      "description_length": 589,
      "index": 3963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rgmap",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps from ranges to values, supporting efficient insertion and lookup of overlapping ranges. It provides operations to add entries with optional overlap handling, find the tightest matching entry for a given range, retrieve all overlapping entries, and iterate over stored entries in order of increasing width. It is specifically used for attaching metadata to ranges of buffer offsets, such as tagging AST nodes in a source code viewer.",
      "description_length": 472,
      "index": 3964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_utils",
      "library": "frama-c.kernel",
      "description": "This module facilitates analysis and transformation of logic types, terms, and annotations in formal specifications, with operations for type coercion, predicate evaluation, and structural equality checks. It works with logic expressions, predicates, terms, and annotations, including CIL-derived types and function behaviors. Specific use cases include verifying ACSL specification properties, merging logical clauses, expanding type definitions, and normalizing terms for formal verification tasks like static analysis or proof generation.",
      "description_length": 541,
      "index": 3965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config",
      "library": "frama-c.kernel",
      "description": "This module exposes system configuration details and environment settings for Frama-C, including version metadata, shared directories, library paths, plug-in loading mechanisms, preprocessor options, and user-specific storage locations. It works with strings, integers, and file path types to support concrete tasks like version checks, resource resolution, plug-in initialization, and preprocessor command configuration. Use cases include initializing analysis tools with correct paths, validating compatibility based on version numbers, and configuring preprocessor arguments for different architectures.",
      "description_length": 606,
      "index": 3966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machine",
      "library": "frama-c.kernel",
      "description": "This module offers operations to query machine-specific configuration details such as C type sizes, alignment requirements, and fixed-size integer type names. It works with data structures including C types, system limits, and Machdep objects to support tasks like analyzing platform-specific code behavior and initializing compiler builtins. Specific use cases include determining struct padding, handling architecture-dependent constants, and configuring logic for target platforms.",
      "description_length": 484,
      "index": 3967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter",
      "library": "frama-c.kernel",
      "description": "This module defines command-line-configurable parameters with typed accessors for boolean, integer, float, and string values, including constraints like ranges or allowed values. It provides operations to query, set, and compare parameter values, retrieve their current state as strings, and manage collections of parameters using sets, maps, and hash tables. Concrete use cases include parsing and validating command-line options, enforcing value constraints, and maintaining configuration state across Frama-C kernel components.",
      "description_length": 530,
      "index": 3968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Compression",
      "library": "frama-c.kernel",
      "description": "This module enables reading from and writing to gzip-compressed streams using abstract `in_channel` and `out_channel` types, supporting byte-level and block-based I/O operations. It provides serialization capabilities through functions like `output_value` and low-level access via `unsafe_really_input`, while allowing interoperability with standard channels. It is particularly suited for scenarios requiring efficient handling of compressed data without full decompression, such as incremental processing or space-constrained storage.",
      "description_length": 536,
      "index": 3969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic",
      "library": "frama-c.kernel",
      "description": "This module enables runtime registration and retrieval of typed values associated with plugins, supporting dynamic configuration and extension. It operates on abstract values of any type through type descriptors, allowing plugins to expose and modify parameters like boolean flags, numeric thresholds, file paths, or string collections. Use cases include dynamically loading analysis modules, toggling plugin features, and configuring analysis targets or include paths at runtime.",
      "description_length": 480,
      "index": 3970,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Acsl_extension",
      "library": "frama-c.kernel",
      "description": "This module enables registration of custom ACSL extensions for Frama-C, supporting operations like parsing, typing, and printing of new annotation constructs. It works with logic expressions, typing contexts, CIL annotations, and module import declarations to integrate domain-specific extensions into static analysis workflows. Concrete use cases include adding new contract clauses, global and code annotations, and custom module import mechanisms for formal verification plugins.",
      "description_length": 482,
      "index": 3971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Integer",
      "library": "frama-c.kernel",
      "description": "This module offers precise arithmetic, bitwise, and comparison operations on arbitrary-precision integers (modeled as `Z.t`), emphasizing C99-compliant division, truncation, and modular arithmetic. It supports conversions between arbitrary-precision integers and fixed-size types (e.g., `int`, `int64`), along with utilities for bit manipulation, population count, and range calculations. Designed for formal verification and static analysis, it addresses edge cases like negative operands and provides specialized formatting for debugging and analysis workflows.",
      "description_length": 563,
      "index": 3972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabsvisit",
      "library": "frama-c.kernel",
      "description": "This module enables traversal and transformation of CABS (C Abstract Syntax) structures by defining visitors for specific elements such as types, expressions, statements, and declarations. It supports operations like rewriting variable names, modifying type specifiers, and transforming function definitions and blocks. Concrete use cases include implementing custom static analysis passes, performing code refactoring, and injecting instrumentation logic into C source code.",
      "description_length": 475,
      "index": 3973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Loop",
      "library": "frama-c.kernel",
      "description": "This module analyzes control flow loops in CIL-processed code, determining whether loops are \"natural\" based on structured control flow criteria. It provides functions to classify individual loops, retrieve collections of natural or non-natural loops within a function, and identify back-edges leading to natural loops. Concrete use cases include static analysis passes that require structured loop detection for optimization or verification purposes.",
      "description_length": 451,
      "index": 3974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function",
      "library": "frama-c.kernel",
      "description": "The module provides introspection and traversal operations for kernel functions and their associated CIL entities, including statements, variables, and blocks. It enables analysis of function metadata (e.g., return type, scope, attributes), syntactic relationships (e.g., enclosing loops, labeled statements), and static analysis tasks like resolving call targets or managing function sets via Hptset. These capabilities are used in static code analysis, call graph construction, and program transformation workflows.",
      "description_length": 517,
      "index": 3975,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_to_c",
      "library": "frama-c.kernel",
      "description": "This module converts logic-level constructs into their C-level counterparts, handling terms, lvalues, types, variables, and offsets. It provides direct mappings such as converting logic types to C types, logic variables to C variable info, and translating terms into expressions or lvalues. Use cases include bridging between logical specifications and C code during analysis or transformation tasks, such as extracting C expressions from logical terms or resolving lvalues for memory model operations.",
      "description_length": 502,
      "index": 3976,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Stmts_graph",
      "library": "frama-c.kernel",
      "description": "This module provides functions to analyze control flow relationships between statements in a function, including reachability checks, cycle detection, and edge traversal. It operates on statements (`stmt`) and blocks (`block`) within a function's control flow graph, returning structured information such as reachable statements, last statements in a block, and in/out edges of a statement or block. Concrete use cases include determining if one statement can reach another during execution, identifying loops and their structure, and extracting control flow boundaries for analysis or transformation passes.",
      "description_length": 608,
      "index": 3977,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Oneret",
      "library": "frama-c.kernel",
      "description": "This module ensures a function has a single return statement by replacing additional returns with gotos, encapsulating local variables to prevent bypassing their initialization. It operates on CIL fundec structures, using annotations and behaviors to track and modify control flow. Use this when transforming function control structures for analysis or code generation where single-exit is required.",
      "description_length": 399,
      "index": 3978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cparser",
      "library": "frama-c.kernel",
      "description": "This module defines a token type representing lexical elements of the C language, including keywords, operators, literals, and annotations, each associated with source location or metadata. It provides parsing functions `interpret` and `file` that convert a stream of tokens into a list of annotated C abstract syntax tree nodes. It is used to parse C source code into an intermediate representation suitable for static analysis and transformation.",
      "description_length": 448,
      "index": 3979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Finite",
      "library": "frama-c.kernel",
      "description": "This module encodes finite sets within the OCaml type system, providing operations to manipulate elements within a finite domain. It supports data types representing finite elements and their positions, with functions to navigate, convert, and iterate over these elements. Concrete use cases include managing bounded indices, safely accessing elements in fixed-size collections, and enforcing cardinal constraints at the type level.",
      "description_length": 432,
      "index": 3980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice",
      "library": "frama-c.kernel",
      "description": "This module implements map structures where keys are associated with lattice-ordered values, enabling operations like join, meet, and widening over mapped values. It supports data types including key-value maps, set-valued maps, and their lattice extensions with cardinality tracking. Concrete use cases include abstract interpretation domains for program analysis, where value approximations and fixpoint computations over maps are required.",
      "description_length": 442,
      "index": 3981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lexerhack",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manipulate lexer context and identifier/type registration during parsing. It works with string identifiers and type definitions, allowing dynamic updates to the parsing environment. Concrete use cases include extending the lexer with custom identifiers, managing type definitions in a C-like language parser, and handling context switches during lexical analysis.",
      "description_length": 397,
      "index": 3982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig",
      "library": "frama-c.kernel",
      "description": "This module defines signatures for high-performance, persistent maps with support for caching strategies. It includes operations for creating, querying, and transforming maps, with explicit handling of cache persistence via `PersistentCache` and `TemporaryCache`. The module is used to manage state efficiently in static analysis tools, particularly when dealing with large, immutable data structures that require selective memoization.",
      "description_length": 436,
      "index": 3983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_sig",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with floating-point numbers across different precisions (single, double, long double, and real). It includes rounding modes and precision specifications for arithmetic computations. Concrete use cases include numerical analysis, scientific computing, and low-level control of floating-point behavior in formal verification tasks.",
      "description_length": 372,
      "index": 3984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Fval",
      "library": "frama-c.kernel",
      "description": "This module supports interval arithmetic and abstract interpretation for floating-point values, offering operations like lattice joins, narrowing/widening, and backward constraint propagation. It manipulates intervals (`t` type) representing finite/infinite ranges with configurable precision (single/double) and special values (NaN, \u00b1\u221e), while handling edge cases like zero representations. Designed for static analysis tasks such as program verification and symbolic execution, it enables precision-preserving conversions, trigonometric operations, and refinement of value ranges during constraint solving.",
      "description_length": 608,
      "index": 3985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inout_type",
      "library": "frama-c.kernel",
      "description": "This module defines a data type representing input/output specifications for program analysis, with fields tracking zones for inputs and outputs under various conditions. It provides operations for comparison, hashing, pretty-printing, mapping over zones, and combining specifications using a join operation. Use cases include analyzing function contracts and tracking data flow in static analysis plugins.",
      "description_length": 406,
      "index": 3986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_preprocess",
      "library": "frama-c.kernel",
      "description": "Performs macro expansion in annotations by preprocessing source files with a given directive. It takes a file path, a preprocessing function, and a suffix, then returns the path to the preprocessed output file. This is used to handle C and C++ annotation preprocessing correctly, ensuring proper macro expansion before analysis.",
      "description_length": 328,
      "index": 3987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data",
      "library": "frama-c.kernel",
      "description": "This module organizes location data for libraries, plugins, and resources using structured lists of location values. It provides direct access to categorized directories and supports plugin discovery, loading, and path resolution. Concrete use cases include initializing plugins from specified directories and managing resource locations during application startup.",
      "description_length": 365,
      "index": 3988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories, grouping values of a specific type for use in states. It supports creating, renaming, and querying categories, as well as defining how elements are accessed and manipulated. Use cases include organizing parameter values for analysis configurations and tracking dependencies between states and parameter sets.",
      "description_length": 350,
      "index": 3989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_print",
      "library": "frama-c.kernel",
      "description": "This module provides functions to pretty-print various components of a parsed logic tree, including constants, types, quantifiers, expressions, type annotations, typedefs, declarations, specifications, code annotations, assigns, and variants. It operates on data structures defined in `Frama_c_kernel.Logic_ptree`, such as `constant`, `logic_type`, `lexpr`, and related types. These functions are used to generate human-readable output for logic expressions and annotations, typically for debugging or display purposes.",
      "description_length": 519,
      "index": 3990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_sig",
      "library": "frama-c.kernel",
      "description": "This module defines a signature for efficient maps from intervals to arbitrary values, supporting operations to add, remove, and query intervals with associated data. It works with interval-based keys, typically representing memory offsets or address ranges, and supports precise merging and splitting of intervals. Concrete use cases include tracking memory regions in static analysis, managing sparse address spaces, and handling overlapping or adjacent intervals in program verification tasks.",
      "description_length": 496,
      "index": 3991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property",
      "library": "frama-c.kernel",
      "description": "This module provides construction, comparison, and metadata management for ACSL properties, focusing on *identified properties* derived from function behaviors, specifications, and annotations. It operates on structured representations like sets, maps, and hash tables to handle property equality, hashing, and contextual analysis, with deep integration into Frama-C's internal CIL-based ACSL constructs. Key use cases include static analysis of program properties such as termination, disjointness, and behavioral contracts, enabling precise tracking and manipulation of specification elements like assigns, ensures, and global invariants across program points.",
      "description_length": 662,
      "index": 3992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Mergecil",
      "library": "frama-c.kernel",
      "description": "Merges a list of CIL files into a single CIL file, using a specified string parameter that likely indicates an output configuration or identifier. Operates directly on CIL file structures, which represent parsed C programs. Useful for combining multiple translation units into a unified analysis target.",
      "description_length": 303,
      "index": 3993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad",
      "library": "frama-c.kernel",
      "description": "This module implements a State monad for managing computations that manipulate a shared environment `Env.t`. It provides core monadic operations like `return`, `bind`, and `map`, along with utilities to get and set the environment, and run computations with an initial state. Concrete use cases include tracking analysis state across program elements, such as maintaining variable bindings or analysis flags during static code analysis.",
      "description_length": 436,
      "index": 3994,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Indexer",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered collection with efficient random access and logarithmic-time modifications, optimized for GUI tree and list widgets needing fast indexing and updates. It supports operations like adding, removing, and filtering elements, as well as tracking index changes during updates. Concrete use cases include managing dynamic lists in a GUI where elements are frequently inserted, removed, or replaced, and associated views need to reflect these changes efficiently.",
      "description_length": 489,
      "index": 3995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter",
      "library": "frama-c.kernel",
      "description": "This module computes invariants for linear filters by analyzing the convergence of state matrices through matrix exponentiation and norm checks. It constructs filters from matrices, vectors, and source terms, then calculates upper and lower bounds for each state dimension when iterations reach a fixed point. It is used in static analysis to verify numerical properties of loops modeled as linear recurrence relations.",
      "description_length": 419,
      "index": 3996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_val",
      "library": "frama-c.kernel",
      "description": "This module manipulates integer abstractions using lattice structures to model sets of integers through ranges, intervals, and congruence constraints. It supports arithmetic operations (addition, multiplication, division), bitwise manipulations (AND/OR/XOR), and lattice-specific transformations like widening/narrowing for static analysis tasks. Key applications include tracking integer ranges in program variables, analyzing modular arithmetic behavior, and detecting potential overflows or underflows in code.",
      "description_length": 513,
      "index": 3997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational",
      "library": "frama-c.kernel",
      "description": "This module supports precise arithmetic, comparison, and conversion operations for rational numbers, including specialized functions for computing powers of two, logarithms, and bounded square roots. It provides optimized ordered and hashed data structures\u2014sets, maps, and hash tables\u2014for efficient manipulation of rational values. These capabilities are tailored for symbolic computation and static analysis tasks requiring exact numerical representations and robust handling of arithmetic edge cases.",
      "description_length": 502,
      "index": 3998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.FCHashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with keys of type `H.t` and values of arbitrary type `'a`, supporting creation, insertion, deletion, and lookup operations alongside functional iteration, folding, and in-place filtering. It extends these capabilities with sorted traversal over keys, entries, or values using customizable comparison functions, as well as utilities for safe value retrieval and memoization. These features are particularly suited for applications requiring ordered key-value processing, such as caches with eviction policies tied to key ordering, data analysis pipelines with sorted intermediate results, or managing associations with domain-specific equality constraints.",
      "description_length": 690,
      "index": 3999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dominators",
      "library": "frama-c.kernel",
      "description": "This module computes dominators and postdominators for statements within a function, enabling precise control flow analysis. It provides operations to retrieve immediate dominators, common ancestors, and dominance relationships between statements, along with utilities to print dominance graphs in DOT format. It works directly with `kernel_function` and `stmt` types from the CIL layer, targeting use cases such as optimizing code analysis, identifying control dependencies, and visualizing function control flow.",
      "description_length": 514,
      "index": 4000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_printer",
      "library": "frama-c.kernel",
      "description": "This module offers utilities for pretty-printing CIL abstract syntax trees, logic annotations, and memory-related constructs using OCaml's formatting engine. It operates on CIL AST nodes like expressions, statements, function definitions, and ACSL elements such as predicates, specifications, and allocation clauses, primarily for internal debugging and logging within the Frama-C kernel. Designed for pre-annotation-processing stages, it supports specialized formatting of termination kinds, global declarations, and behavioral contracts while explicitly excluding plugin-facing correctness guarantees.",
      "description_length": 603,
      "index": 4001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype",
      "library": "frama-c.kernel",
      "description": "This module provides structural manipulation and analysis operations for CIL data types used in static analysis, focusing on precise equality checks, hashing, and collection management. It works with CIL entities like variables, functions, logical terms, types, and annotations, along with associated metadata and scopes. These tools support tasks such as tracking program elements, transforming code structures, and comparing logical expressions during static analysis.",
      "description_length": 470,
      "index": 4002,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_lexer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to lexically analyze logic annotations in source code, converting input into tokens, strings, and parsed logic expressions, annotations, and specifications. It operates on lexing buffers and produces parsed structures like `lexpr`, `annot`, and `spec` types. Concrete use cases include parsing ACSL annotations during static analysis and handling extended specification files in Frama-C plugins.",
      "description_length": 426,
      "index": 4003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap",
      "library": "frama-c.kernel",
      "description": "Implements maps from bases to memory maps, where memory maps are defined by the `Offsetmap` module. It supports operations to add, query, and manipulate memory regions associated with specific bases. Useful for tracking memory offsets and their properties in static analysis, particularly in the context of C program verification.",
      "description_length": 330,
      "index": 4004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.File",
      "library": "frama-c.kernel",
      "description": "This component manages preprocessing and abstract syntax tree (AST) initialization for C source files, offering configuration of preprocessing steps, registration of file-specific behaviors, and transformation controls for AST manipulation. It operates on data structures representing source files, CIL ASTs, and project contexts, enabling use cases like custom code transformation pipelines and project initialization workflows. Key capabilities include configurable pretty-printing of machine dependencies and structured AST output, with support for format customization and default output destinations.",
      "description_length": 605,
      "index": 4005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval_sig",
      "library": "frama-c.kernel",
      "description": "This module defines operations for representing and manipulating intervals of floating-point numbers, including functions to compute interval bounds, check for inclusion, and perform arithmetic operations with precision control. It works with abstract data types representing intervals and floating-point precisions. Concrete use cases include static analysis of floating-point computations in program verification and ensuring numerical stability in safety-critical systems.",
      "description_length": 475,
      "index": 4006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel",
      "library": "frama-c.kernel",
      "description": "This module provides foundational operations for static analysis, abstract interpretation, and program transformation, focusing on tasks like value range analysis, memory modeling, control flow manipulation, and formal verification. It operates on CIL/CABS abstract syntax trees (ASTs), control flow graphs, memory abstractions, and logic annotations, supporting use cases such as contract inference, program verification, and error tracking. Key functionalities include AST parsing/printing, data flow analysis, lattice-based semantic modeling, and infrastructure for plugins and formal methods tools.",
      "description_length": 602,
      "index": 4007,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4266,
    "meaningful_modules": 4008,
    "filtered_empty_modules": 258,
    "retention_rate": 0.939521800281294
  },
  "statistics": {
    "max_description_length": 785,
    "min_description_length": 100,
    "avg_description_length": 463.50523952095807,
    "embedding_file_size_mb": 58.06399440765381
  }
}