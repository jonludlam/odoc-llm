{
  "package": "frama-c",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 4791,
  "creation_timestamp": "2025-07-16T03:36:44.107009",
  "modules": [
    {
      "module_path": "Studia.Options.Filepath_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality checking, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type, which represents string-based values in the Frama-C kernel. Concrete use cases include managing and comparing file path configurations in static analysis tools, where precise string representation and deep copying are required.",
      "description_length": 438,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type and operations for handling string-based representations of kernel function sets in Frama-C plugins. It provides equality, comparison, hashing, and pretty-printing functions for values of this type, along with deep copying and membership testing over project skeletons. It is used to manage and manipulate sets of kernel functions as strings within Frama-C's plugin architecture.",
      "description_length": 411,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating string-based values in a Frama-C kernel context. It includes standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to handle string parameters in Frama-C analyses that require structured data representation and comparison.",
      "description_length": 395,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling sets of strings as a standard string parameter, supporting operations like equality, comparison, hashing, and pretty-printing. It provides deep copying, membership checking over project skeletons, and integrates with Frama-C's type and descriptor system for structured data representation. It is used to manage string sets in a way that ensures structural consistency and efficient manipulation within Frama-C's analysis framework.",
      "description_length": 476,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for managing string-based representations of kernel function multiple maps, including equality, comparison, hashing, and pretty-printing. It supports values of type `As_string.Datatype.t` and provides functionality for checking membership in projects, deep copying, and structural inspection via descriptors. Concrete use cases include tracking and manipulating sets of function declarations with string keys in static analysis contexts.",
      "description_length": 485,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing string-based values, along with deep copying and membership checks over project skeletons. It works with strings and structured descriptors, supporting concrete use cases like tracking and comparing string parameters in memory analysis. The type enables precise equality checks, ordered comparisons, and structured representation for analysis tasks.",
      "description_length": 441,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to manage string representations of lists, including deep copying and membership testing within projects. Use cases include parsing and serializing string lists in a memory-safe manner, and integrating with Frama-C's internal type and descriptor system for analysis plugins.",
      "description_length": 456,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling multiple string values with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks over project skeletons, ensuring no shared state between copies. Concrete use cases include managing collections of string-based identifiers or annotations in static analysis contexts.",
      "description_length": 370,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_list.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating string-based values in a structured context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over project skeletons. It is used to handle string representations of memory zones in static analysis tasks, such as tracking and comparing memory states across different analysis passes.",
      "description_length": 436,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing string-based values, along with deep copying and membership testing within a project context. It works with strings and project skeletons, supporting concrete use cases like tracking and comparing string identifiers in static analysis contexts. The type supports standard operations needed for use in maps and sets, ensuring value integrity during comparisons and copies.",
      "description_length": 463,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Fundec_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating a collection of strings, specifically used to track function declarations in the context of memory analysis. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying, along with support for checking membership based on project skeletons. The type is used to handle sets of function names in a way that ensures consistent representation and efficient manipulation during static analysis.",
      "description_length": 516,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports working with string-based representations and descriptors for structured data, enabling deep copying and membership checks over project skeletons. Concrete use cases include managing string sets in static analysis contexts where structural equality and efficient traversal are required.",
      "description_length": 431,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing and manipulating file paths as strings, including equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's kernel by providing type descriptors, project membership checks, and deep copying. Concrete use cases include tracking and comparing file paths in memory analysis and generating user-readable output for debugging.",
      "description_length": 419,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based values. It supports deep copying and membership checks over project skeletons, ensuring no shared references. Used to manage string parameters in static analysis contexts where unique identification and structural comparison are required.",
      "description_length": 381,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.As_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with operations for representing, comparing, and printing string-based values in a memory analysis context. It supports deep copying, equality checks, hashing, and pretty-printing, along with project membership queries for Frama-C analysis. The type is used to handle string parameters in a structured way, particularly for tracking and analyzing memory states in C code.",
      "description_length": 403,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Fundec_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-valued configuration options with constraints, supporting validation, aliasing, and serialization. It provides a central data type for handling strings with associated rules, such as allowed values or naming conventions, and includes operations for setting, retrieving, and tracking changes to these values. The module enables use cases like parsing command-line arguments, enforcing function name formats during memory analysis, and persisting project configurations. Submodules extend this functionality by offering structured collections of strings, with support for membership checks, comparison, and pretty-printing in analysis contexts.",
      "description_length": 669,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter configurations, supporting operations to define, enable, and modify categories with specific accessors and dependencies. It works with category types and state lists from the Frama_c_kernel module. Use cases include setting up configurable analysis options and controlling category behavior in static analysis contexts.",
      "description_length": 364,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Debug.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in memory analysis computations. It supports deep copying and membership checks over project skeletons, ensuring structural integrity and uniqueness through its descriptor and representants. Use cases include tracking and comparing memory states in static analysis tools.",
      "description_length": 401,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module handles string-based command-line parameters with validation, alias resolution, and function name checks, while synchronizing global state for configuration and analysis tools. It supports operations like restricting values to predefined sets, testing membership in kernel function sets, and serializing string representations with consistency across project states. Child modules extend this functionality to manage kernel function sets as strings, providing equality, comparison, and pretty-printing for Frama-C plugins. Examples include validating function identifiers, enforcing string constraints in static analysis, and maintaining synchronized string sets across tool sessions.",
      "description_length": 696,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter classification, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types and state lists, allowing precise control over parameter interpretations. Concrete use cases include setting up default and global categories for memory analysis parameters.",
      "description_length": 367,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks and deep copying, ensuring no shared state between original and copied values. The type is integrated with Frama-C's project management system, allowing for project-specific filtering and introspection.",
      "description_length": 379,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter configurations, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types that represent different configuration states, such as `@none`, `@default`, and `@all`, and allows dynamic setup of category behavior. Concrete use cases include enabling or disabling groups of parameters based on analysis needs, and defining default or global behaviors for parameter handling.",
      "description_length": 499,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Bool.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a boolean-like data type with standard comparison, equality, and hashing operations. It supports integration with Frama-C's type system by providing type descriptors, representants, and project-aware membership checks. The type is used to model binary states in memory analysis, enabling precise tracking of value changes during program execution.",
      "description_length": 367,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Int.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin development. It includes support for deep copying values, checking membership within projects, and provides descriptors for type representation. Concrete use cases include managing and manipulating abstract values in static analysis plugins, such as tracking integer ranges or memory states.",
      "description_length": 436,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for organizing and selecting sets of parameters, particularly in the context of memory zone computations. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each controlling how parameters are interpreted and activated. Use cases include configuring analysis settings where different categories determine which memory zones are considered under varying conditions.",
      "description_length": 460,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string command-line parameters with validation, alias registration, and state tracking across projects, using a map-based structure that enforces single-value bindings. It supports predefined allowed values, custom marshaling, and integration with analysis workflows, particularly in Frama-C plugin development. The core data type enables equality checks, comparison, hashing, and pretty-printing for string values, while ensuring deep copying and no shared references. Submodules enhance handling of string parameters in static analysis contexts requiring unique identification and structural comparison.",
      "description_length": 625,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter configurations, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types and state lists, allowing precise control over category behavior in different contexts. Concrete use cases include setting up default and global categories for analysis parameters, enabling all categories with specific interpretations, and defining dependencies between categories and states.",
      "description_length": 486,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter customization in a kernel function analysis context. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, each associated with specific states and accessors. These categories control how function parameters are interpreted and grouped in static analysis configurations.",
      "description_length": 370,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing multiple string-to-value mappings, supporting operations like equality checking, comparison, hashing, and pretty-printing. It works with strings as keys and abstract values encapsulated in the `Datatype.t` type, enabling precise tracking and manipulation of memory zone statements. Concrete use cases include managing and comparing sets of string-indexed memory states in static analysis tools.",
      "description_length": 443,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Action.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in memory analysis and transformation tasks. It supports deep copying and membership testing within project skeletons, enabling precise manipulation of analysis states. Concrete use cases include tracking and comparing abstract memory values during static analysis and code transformation passes.",
      "description_length": 416,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values within a specific domain, including equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's kernel by providing type and descriptor information, as well as deep copying and project membership checks. Concrete use cases include tracking and comparing function declarations and their associated memory states in static analysis.",
      "description_length": 464,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values through a list of representatives, a descriptor, and a packed descriptor for type representation. The type is used to store and manipulate values with project-specific metadata, enabling deep copies and membership checks over project skeletons.",
      "description_length": 393,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing file paths in a normalized, platform-independent manner, supporting operations like concatenation, parent directory resolution, and extension manipulation. It provides functions for equality checking, comparison, hashing, and pretty-printing to facilitate use in maps and sets. Concrete use cases include tracking source file locations in static analysis and managing paths for generated output files.",
      "description_length": 450,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.False.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype implementation with operations for equality, comparison, hashing, and pretty-printing. It supports structured values through a list of representatives and a descriptor, enabling deep copying and membership checks over projections. It is used to represent and manipulate complex data within static analysis plugins, particularly for tracking memory states and evaluating expressions.",
      "description_length": 413,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string command-line options with validation, aliases, and state integration, operating on string data and global parameters. It supports sets of strings with equality, comparison, and membership checks over project skeletons, enabling use cases like CLI parsing with allowed values or dynamic configuration with extensible state updates. Child modules enhance handling of structured string sets, integrating with type systems for analysis frameworks. Example uses include validating function names against external constraints and maintaining synchronized string state across project components.",
      "description_length": 615,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages named categories for a string set, where each category defines how parameters are accessed and interpreted in different states. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with support for dependency tracking and state-based behavior. Concrete use cases include configuring parameter handling in static analysis tools, where categories control how memory states are computed and interpreted.",
      "description_length": 472,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Empty_string.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom abstract data type `t` representing computations over memory zones where empty strings are significant. It provides standard operations like equality, comparison, hashing, and pretty-printing for this type, along with deep copying and project membership checks. Concrete use cases include tracking memory states in static analysis where empty string values must be explicitly preserved and compared.",
      "description_length": 428,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of non-empty strings, with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks and set manipulations, specifically tailored for use in static analysis contexts where string sets denote memory zone statements. The type is integrated with Frama-C's project management system, enabling deep copies and project-aware membership queries.",
      "description_length": 441,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use with a map structure that disallows multibindings. It works directly with `Datatype.t` values, providing deep copy functionality and project membership checks over a `Project_skeleton.t` context. Concrete use cases include managing and manipulating structured data representations in static analysis contexts, such as tracking memory states or symbolic expressions.",
      "description_length": 485,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for parameter customization in a kernel function map. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each associated with specific accessors and dependencies. These categories control how function parameters are interpreted and enabled across different analysis states.",
      "description_length": 369,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages command-line options with string values, supporting value assignment, alias resolution, validation against allowed string lists, and serialization control. It operates on string data and global parameter state, using string lists to enforce validation rules and track acceptable values. The child module enhances this functionality by providing data types for comparing, hashing, and pretty-printing string-based values, enabling precise equality checks, ordered comparisons, and structured representation for analysis tasks. Together, they support use cases like parsing and validating project-specific parameters, tracking function names against predefined rules, and maintaining state across multiple option interactions.",
      "description_length": 744,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Enum.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for a fixed set of values with structural equality, supporting operations like comparison, hashing, pretty-printing, and deep copying. It works with a variant type `t` representing a finite set of possible values, along with associated metadata such as type information, descriptors, and representants. Concrete use cases include managing enumerated options in analysis configurations and enabling value inspection or serialization in static analysis tasks.",
      "description_length": 488,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom data type for handling lists of file paths, providing operations for equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's type system by defining a unique type descriptor, representants, and memory projection capabilities. Concrete use cases include tracking and manipulating collections of file paths during static analysis, such as managing input files or output artifacts per project.",
      "description_length": 454,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter collections with support for named categories, default and special `@all` categories, and dynamic enabling of categories based on states and accessors. It operates on `Category.t` values, which represent named categories tied to parameter collections, and interacts with Frama-C's state and parameter systems. Concrete use cases include defining and controlling behavior for analysis parameters in static analysis plugins, such as enabling or disabling groups of parameters based on analysis context.",
      "description_length": 545,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for a collection of file paths, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies to categories. Concrete use cases include configuring analysis scopes by enabling or disabling groups of file paths based on specific criteria or command-line options.",
      "description_length": 434,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based parameters with dynamic validation, alias resolution, and lifecycle hooks for state changes, supporting both direct manipulation and command-line integration. It defines a core data type for representing string values with operations for comparison, hashing, pretty printing, deep copying, and project membership checks, constrained by allowed sets or function name checks. Use it to implement configurable option parsing, persistent project settings with tracked modifications, and safe function reference handling in kernel mappings. Its submodules extend these capabilities to structured data representation and analysis in Frama-C kernel contexts.",
      "description_length": 684,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a string-keyed map for managing collections of `Datatype.t` values with standard map operations like insertion, lookup, and iteration. It provides efficient associative storage where keys are strings and values conform to the `Datatype.t` interface, supporting equality, comparison, and hashing. Concrete use cases include tracking variable bindings, symbol tables, or configuration settings where string-identified data must be stored and retrieved reliably.",
      "description_length": 482,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for a parameter map, where each category is associated with a name, an accessor, and optional dependencies. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with support for custom interpretations and state dependencies. Concrete use cases include organizing and controlling parameter behavior in static analysis configurations, such as enabling or disabling specific analysis modes across different program regions.",
      "description_length": 515,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string parameters with validation against constrained value sets or function name rules, supporting dynamic configuration through hooks, default handling, and state persistence. It operates on global string variables with customizable marshaling and aliasing, enabling command-line argument parsing, DSL consistency enforcement, and interactive configuration systems where parameter changes trigger updates or validation workflows. The child module introduces a data type for handling sets of strings with operations for equality, comparison, hashing, and pretty-printing, supporting structured data representations and deep copying. Together, they allow defining, manipulating, and validating string-based configurations while providing efficient set operations for static analysis and project skeleton management.",
      "description_length": 835,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Custom.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's analysis framework. It supports deep copying and provides descriptors for integration with Frama-C's type system, enabling the use of custom types in analyses that require memory zone computations. Concrete use cases include representing and manipulating abstract values in static analysis plugins, such as tracking memory states or symbolic expressions.",
      "description_length": 495,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_set.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-valued configuration options with dynamic state tracking, supporting operations like setting values, enforcing constraints, and validating inputs against rules. It works with string data and string lists, integrating with command-line interfaces and kernel state for use cases such as parameter validation and persistent configuration. The child module enhances this functionality by providing structured handling of string-based values with support for comparison, hashing, pretty-printing, and analysis in memory contexts like Frama-C. Together, they enable advanced string parameter management, including structured state changes, alias handling, and interoperability with external systems through custom serialization.",
      "description_length": 749,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages command-line parameters with string values, supporting operations like validation, aliasing, and visibility control in help documentation. It handles both single strings and string lists, with hooks for tracking value changes and integration for memory zone statements tied to string settings. The child module extends functionality by providing data structures for managing multiple string values with equality checks, comparison, and deep copying, useful for static analysis tasks like tracking identifiers. Together, they enable building complex CLI interfaces with validated, dynamic string configurations and robust handling of string collections.",
      "description_length": 672,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for representing file paths in a memory analysis context. It supports operations for equality checking, comparison, hashing, and pretty-printing file path values. It is used to track and manipulate file paths during static analysis, particularly when reasoning about memory writes and their origins.",
      "description_length": 330,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module handles string-based command-line parameters with validation, alias resolution, and dynamic updates through hooks, operating on strings and string lists while enforcing value constraints and supporting custom marshaling. It integrates with the Frama-C kernel state to manage project-specific options, such as validating function names or predefined string values. The child module extends this functionality by providing structured representations of function maps with support for equality checks, deep copies, and pretty-printing, enabling precise tracking and manipulation of function declarations keyed by strings. Together, they enable robust configuration and analysis of string-based data in static analysis workflows.",
      "description_length": 737,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based command-line options with strict validation against predefined values, handling function name arguments and enforcing constraints through a global parameter state. It supports operations to track state changes via hooks and processes valid inputs using string lists, enabling use cases like CLI parsing where options must resolve to specific values or act as executable functions. The child module enhances this by defining a data type for string lists with equality, comparison, and serialization, allowing structured manipulation and deep copying of list representations. Together, they enable precise parsing, validation, and transformation of string inputs in contexts such as Frama-C plugin configuration and analysis.",
      "description_length": 756,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.WithOutput.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype with operations for structural comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating memory zone statements. It supports deep copying, equality checks, and project-based membership queries, enabling precise analysis of memory-related computations. Concrete use cases include tracking memory modifications and validating memory access patterns in static analysis.",
      "description_length": 437,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based command-line parameters with validation, state tracking, and alias resolution, operating on string data within a global parameter state. It supports value constraints, function name validation, and unvalidated string retrieval, while its child module enhances string handling with comparison, hashing, pretty-printing, and membership testing in project contexts. The combined functionality enables tasks like parsing configuration options, enforcing input domains, and synchronizing state across distributed components. Use cases include static analysis identifier tracking, parameter validation against predefined domains, and managing string state in project skeletons.",
      "description_length": 704,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_multiple_map.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a polymorphic type `t` with operations for structural comparison, hashing, and pretty-printing, tailored for use with multi-map data structures that allow multiple bindings per key. It supports deep copying and membership testing over project skeletons, ensuring no shared references in copied values. Concrete use cases include managing and manipulating complex data representations in static analysis tasks, such as tracking memory states with multiple associated values per key.",
      "description_length": 501,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Float.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing optional floating-point values with operations for equality, comparison, hashing, and pretty printing. It supports integration with Frama-C's type system by providing type descriptors, representants, and project management functions. Concrete use cases include handling optional float parameters in static analysis plugins and managing numeric configurations with potential absence.",
      "description_length": 431,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values within a kernel function set. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over projections. The type supports structural inspection through a packed descriptor and a list of representants, enabling use in analysis and transformation passes that require precise type handling.",
      "description_length": 455,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Zero.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a custom abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides structural inspection capabilities through a descriptor and supports deep copying and membership checks over embedded project skeletons. Concrete use cases include representing and manipulating symbolic memory states in static analysis plugins.",
      "description_length": 380,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-valued options with change tracking, aliasing, and custom marshaling, enforcing valid input through constraints and function name checks. It supports configuration systems that require strict validation, default tracking, and state transitions for string parameters. A key child module extends this functionality to file paths, enabling robust manipulation, comparison, and integration with analysis tools through type descriptors and project membership checks. Together, they enable use cases ranging from dynamic configuration management to precise file path tracking in memory analysis.",
      "description_length": 616,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based command-line parameters with support for value assignment, validation, alias resolution, and state transitions, operating on string values and parameterized string types. It includes a child module for handling lists of file paths with equality, comparison, and pretty printing, working with the `Datatype.t` type for deep copying and precise representation. You can use it to enforce input constraints, track project-specific state changes, or manage file path configurations in static analysis tools. The combination allows dynamic validation, serialization, and structured handling of both plain strings and complex string-derived types.",
      "description_length": 673,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Fundec_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type and associated operations for representing and manipulating sets of function declarations in the context of memory analysis. It provides standard set operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to track and analyze which functions write to specific memory zones during static analysis.",
      "description_length": 416,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for handling lists of strings with operations for equality, comparison, hashing, and pretty-printing. It supports set-like manipulations and membership testing, particularly for analyzing memory-related properties in static analysis contexts. It is used to represent and manipulate collections of string identifiers tied to memory zones in program analysis.",
      "description_length": 389,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a data type for representing sets of values with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering using a predicate. Concrete use cases include managing collections of values in analyses where uniqueness, structural comparison, and traversal are required.",
      "description_length": 370,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Verbose.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis computations involving memory zones. It supports deep copying, membership testing within projects, and provides representants for structural descriptors. Use cases include tracking and comparing data structures during abstract interpretation or memory state analysis.",
      "description_length": 416,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module implements a list-based data structure for representing and manipulating collections of values with support for equality, comparison, and hashing operations. It provides functions to check membership based on project conditions, perform deep copies, and format values for display. It is used to manage lists of representants in a way that preserves structural integrity and supports precise memory analysis.",
      "description_length": 419,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for parameter collections, using the `Frama_c_kernel.Parameter_category.t` type. It provides operations to create, modify, and enable categories with specific accessors and dependencies, such as `none`, `default`, and `all`. Use cases include configuring analysis parameters in Frama-C plugins, where categories control how different parts of the codebase are processed based on user-defined rules.",
      "description_length": 441,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filled_string_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for a string-based configuration system, where each category defines how certain named options are interpreted and enabled. It provides operations to create, modify, and enable categories, including special categories like `@none`, `@default`, and `@all`, with support for dependencies and accessors. Concrete use cases include defining option groups that control analysis behaviors in a static analysis tool, where categories determine which memory zones are considered under specific configurations.",
      "description_length": 532,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list.As_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string-based command-line parameters with support for default values, aliases, and input validation, while integrating with Frama-C's kernel for state management and marshaling. It provides data types for handling strings and string lists, along with operations for setting, retrieving, and monitoring values, including serialization and deep copying. Submodules extend functionality to structured manipulation of string representations, offering equality checks, comparison, hashing, and pretty-printing, particularly for tracking memory states in static analysis. Example uses include validating function names in parameters and synchronizing string-based memory zone representations across analysis passes.",
      "description_length": 729,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a datatype for handling string-based values in a memory analysis context, providing operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks over project skeletons, ensuring structural integrity during analysis. Concrete use cases include representing and manipulating string values within Frama-C's abstract interpretation frameworks.",
      "description_length": 412,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module manages categories for parameter classification, providing operations to define, modify, and enable category behaviors. It works with category types tied to parameter accessors and state lists, supporting concrete use cases like enabling or disabling groups of parameters based on runtime conditions. Functions include setting default categories, creating named categories with dependencies, and controlling the behavior of the `@all` category.",
      "description_length": 456,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.True.Datatype",
      "library": "frama-c-studia.core",
      "description": "This module defines a concrete implementation of a datatype with support for equality, comparison, hashing, and pretty-printing operations. It works with values of type `Datatype.t`, providing deep copying, membership checks over project skeletons, and structural representation capabilities. It is used to model and manipulate abstract memory zone statements with precise identity and structural control.",
      "description_length": 405,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Fundec_set.Category",
      "library": "frama-c-studia.core",
      "description": "This module defines and manages categories for a parameter system, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with category types tied to parameter states, including special categories like `@none`, `@default`, and `@all`. Concrete use cases include configuring analysis parameters in static verification tools, where categories control how different memory zones are interpreted and tracked during analysis.",
      "description_length": 479,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_multiple_map",
      "library": "frama-c-studia.core",
      "description": "This module organizes a multibinding map where each key links to multiple values, supporting modification, state change hooks, and aliasing, with traversal and immutability features. It integrates category management for grouping and conditional activation of key sets, string parameter handling with validation and CLI visibility, and polymorphic data structures for deep copying and structural comparison. You can define parameter groups that activate based on analysis state, track string identifiers with change hooks, or manage memory states with multiple values per key. Core types include multibinding maps, categories, string collections, and polymorphic values, enabling structured, dynamic configuration in static analysis workflows.",
      "description_length": 743,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_set",
      "library": "frama-c-studia.core",
      "description": "This module manages mutable sets with tracked changes, supporting element addition, removal, membership checks, and iteration, while integrating pre- and post-modification hooks, serialization, and state computation flags. It works with a set type derived from a base element type and includes alias management with visibility and deprecation controls. The first child module extends this with string-valued configuration handling, enabling constraint enforcement, input validation, and command-line integration for dynamic parameter management. The second child module provides core set operations including equality, comparison, and deep copying, while the third enables category-based parameter classification with support for enabling conditions and dependency management. Together, they support use cases such as reactive configuration tracking, structured state changes, and runtime classification of parameter sets with customizable behavior and persistence.",
      "description_length": 965,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Session",
      "library": "frama-c-studia.core",
      "description": "This module manages file paths for a session directory, providing operations to retrieve or create directories and files within it. It works with string identifiers and file paths represented as `Frama_c_kernel.Filepath.t`. Concrete use cases include storing and accessing session-specific data such as intermediate results or configuration files during analysis.",
      "description_length": 363,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String",
      "library": "frama-c-studia.core",
      "description": "This module manages string command-line options with support for change hooks, default values, and serialization, while integrating with project state and help systems. It provides data types and operations for handling string-based values in memory analysis, including equality checks, comparison, hashing, and pretty-printing, ensuring structural integrity during analysis. It allows setting dynamically updated analysis targets, validating function names, and enforcing input constraints against predefined patterns. Use cases include bridging user configuration with internal project state and manipulating string values within Frama-C's abstract interpretation frameworks.",
      "description_length": 677,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_user_dir",
      "library": "frama-c-studia.core",
      "description": "This module provides functions to retrieve or create directories and files within a user directory structure. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations to ensure the existence of a directory or file, optionally creating parent paths. Concrete use cases include setting up user-specific storage locations for analysis results or configuration files during static code analysis.",
      "description_length": 426,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Make_site_dir",
      "library": "frama-c-studia.core",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` operations to resolve subdirectories and files within the site, ensuring correct type and existence. Use it when building or navigating a hierarchical file structure rooted in a known parent directory.",
      "description_length": 320,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_user_dir_opt",
      "library": "frama-c-studia.core",
      "description": "This module constructs and manages a user directory option from an existing user directory configuration. It provides operations to retrieve or set a directory path, check if a directory is set, and obtain file paths relative to the user directory, all returning absolute paths as `Frama_c_kernel.Filepath.t`. It is used to handle configurable directories with optional path creation, such as for storing user-specific data or logs.",
      "description_length": 432,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_map",
      "library": "frama-c-studia.core",
      "description": "This module manages a map of values keyed by filepaths, supporting modification tracking, resettable defaults, and update hooks, with integration into Frama-C's state management for persistent storage and computation tracing. It works with normalized file path representations to enable platform-independent path manipulation, comparison, and pretty-printing, while supporting use cases like tracking file-specific configuration or analysis results with fine-grained change detection. The module organizes parameters into selectable categories that control interpretation and activation, particularly in memory zone computations, and includes a system for managing string and file path options with validation, change tracking, and custom marshaling. Together, these features enable dynamic configuration, precise file path handling, and robust state management across analysis sessions.",
      "description_length": 887,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Empty_string",
      "library": "frama-c-studia.core",
      "description": "This module manages string command-line parameters with dynamic validation, alias resolution, and state synchronization, operating on string values and structured containers with support for change tracking, serialization, and option migration. It defines a core abstract type `t` for computations over memory zones where empty strings are significant, offering equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. You can use it to enforce runtime constraints on plugin parameters, track memory states in static analysis, and persist configuration changes across sessions. Example uses include validating user-provided paths, synchronizing plugin state with Frama-C's project system, and handling deprecated option names with automatic value migration.",
      "description_length": 807,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_multiple_map",
      "library": "frama-c-studia.core",
      "description": "This module manages string-indexed mappings of value lists with support for change tracking, default values, and state persistence, while integrating alias handling, custom serialization, and category-based organization. It provides data types for keys with multiple associated values, operations to set, retrieve, and observe changes, and utilities for command-line option parsing and memory state tracking. The category submodule enables grouping and conditional activation of parameters, the datatype submodule supports comparison and serialization of mapped values, and the command-line submodule handles string option validation and alias resolution. Example uses include tracking function names against allowed lists, managing analysis configurations with dynamic categories, and persisting and comparing memory zone states across tool invocations.",
      "description_length": 854,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Share",
      "library": "frama-c-studia.core",
      "description": "This module manages the configuration and retrieval of a specific directory used for shared resources, providing operations to set, check, and access this directory. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports locating subdirectories or files within the shared directory. Concrete use cases include initializing the shared directory path, verifying its configuration status, and safely retrieving specific files or subdirectories by name.",
      "description_length": 475,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Debug",
      "library": "frama-c-studia.core",
      "description": "This module manages a mutable integer parameter with constrained modification, tracking, and serialization, supporting use cases like computation state tracking and CLI integration. It provides data types for representing bounded integer states with metadata, alongside operations for observation, copying, and structural comparison. Child modules extend this with concrete types for memory analysis, enabling deep copying, equality checks, and pretty-printing over structured data. Together, they facilitate debugging and analysis of memory zones and project states with strong integrity guarantees.",
      "description_length": 600,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Config_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages file paths for a plugin's configuration directory, providing operations to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to represent file paths and ensures the existence of necessary paths based on the `create_path` flag. Concrete use cases include setting up and accessing plugin-specific configuration files and directories during static analysis.",
      "description_length": 418,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_map",
      "library": "frama-c-studia.core",
      "description": "This module manages string-keyed maps with parametric values, supporting atomic updates, change hooks, and default resolution, built on the Frama-C kernel's `String_map`. It integrates category management for organizing parameter configurations with dependencies, a specialized map for `Datatype.t` values offering standard associative operations, and a system for handling command-line parameters with validation and alias resolution. Main data types include `V.t` for polymorphic values, category state lists, and string-based parameters with constraints. Examples include tracking memory state changes, managing analysis configurations with category hierarchies, validating command-line inputs, and maintaining symbol tables with efficient lookups and updates.",
      "description_length": 763,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Custom",
      "library": "frama-c-studia.core",
      "description": "This module enables the definition and manipulation of custom data types with full support for equality, comparison, hashing, and pretty-printing, tailored for integration into Frama-C's analysis framework. It provides operations for deep copying and type descriptors that allow custom types to participate in memory zone computations and abstract value tracking. With this module, developers can represent complex analysis artifacts such as symbolic expressions and memory states, and manipulate them within static analysis plugins. Submodules extend this functionality with specialized types and operations that build on the core infrastructure for seamless integration and enhanced analysis capabilities.",
      "description_length": 707,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Value_string",
      "library": "frama-c-studia.core",
      "description": "This module implements a string-based data type with operations for comparison, hashing, pretty printing, and deep copying. It supports conversions to and from regular strings, along with project-aware membership checks and structural representation via descriptors. It is used to model and manipulate string values within a memory analysis framework, particularly for tracking and comparing string literals in program memory.",
      "description_length": 426,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Zero",
      "library": "frama-c-studia.core",
      "description": "This component provides utilities for managing mutable integer parameters with dynamic constraints, change tracking, and alias handling, supporting operations like range validation, value serialization, and integration with global state variables. It enables use cases such as validated command-line interface configuration and maintains observability through state change hooks and customizable serialization. The child module defines an abstract data type `t` with structural inspection, deep copying, and membership checks, supporting symbolic memory state manipulation in static analysis plugins. Together, they allow building and managing complex, validated integer-based configurations with observable and extensible state behavior.",
      "description_length": 738,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Verbose",
      "library": "frama-c-studia.core",
      "description": "This module manages an integer verbosity parameter with bounded adjustments, notifications, and CLI integration, enabling runtime control of logging and debugging contexts. It supports direct operations like value setting, incrementing, and state tracking, while its child module provides structured data types for static analysis, particularly in memory zone computations. Together, they allow dynamic configuration of analysis tools where verbosity adapts to structural changes in data representations. Example uses include context-sensitive debug output and CLI-driven analysis tools with fine-grained output control.",
      "description_length": 620,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Cache_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages a specific cache directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of the cache directory. Concrete use cases include storing and accessing cached analysis results or temporary files during static code analysis.",
      "description_length": 419,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.WithOutput",
      "library": "frama-c-studia.core",
      "description": "This module manages boolean options with dynamic value tracking, serialization, and conditional output control, working with `Frama_c_kernel.Typed_parameter.t` values to support state transitions and dependency-driven output rendering. It enables configuration of analysis settings with runtime changes, generation of context-aware command-line interfaces, and control of result visibility based on inter-option dependencies. A child module introduces a data type for memory zone statements with structural comparison, deep copying, and project-based queries, supporting precise memory analysis. Together, they facilitate advanced option management alongside detailed memory computation tracking and validation.",
      "description_length": 711,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.True",
      "library": "frama-c-studia.core",
      "description": "This module manages boolean options with state tracking, enabling operations to set values (`on`/`off`), register callbacks for state changes, and integrate with command-line interfaces via aliases, help messages, and visibility controls. It relies on typed parameters for internal state management and supports project-specific context handling, while a child module provides concrete implementations for a datatype with equality, comparison, hashing, and pretty-printing, used to model abstract memory zones with structural control. Together, they support configuring program behavior through CLI flags and dynamically reacting to option updates during analysis, while enabling precise manipulation of memory-related abstractions. Example uses include enabling analysis passes via command-line flags and tracking memory state changes across project skeletons.",
      "description_length": 861,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Enum",
      "library": "frama-c-studia.core",
      "description": "This module enables the definition and manipulation of enumerated types with a finite set of values, supporting operations such as comparison, hashing, pretty-printing, and serialization. It centers around a variant type `t` that represents possible states or options, and includes utilities for managing aliases, tracking changes, and integrating with configuration systems. Submodules extend this functionality to support structured metadata, typed option handling, and analysis-specific configurations. Example uses include modeling command-line flags, analysis modes, or state transitions in static analysis workflows.",
      "description_length": 622,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Float",
      "library": "frama-c-studia.core",
      "description": "This module manages floating-point parameters with support for optional values, customizable defaults, and configurable ranges, combining direct operations like validation, serialization, and change-tracking hooks with advanced handling of optional floats through its child module. Main data types include float-based parameters with metadata and optional float representations, enabling precise numerical configuration, enforcement of bounds, and integration with Frama-C's type system. Operations span equality checks, comparison, hashing, pretty printing, and project-aware management for use in static analysis plugins and numeric configuration systems. Example uses include tracking changes to floating-point settings in a GUI and handling absent or variable float parameters in analysis tools.",
      "description_length": 799,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Value_int",
      "library": "frama-c-studia.core",
      "description": "This module defines operations for handling integer values within a memory analysis framework, including equality checks, comparison, hashing, and pretty-printing. It supports conversions to and from strings, deep copying, and membership testing over project skeletons. Concrete use cases include representing and manipulating integer memory states during static analysis, such as tracking variable values or evaluating expressions.",
      "description_length": 432,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filled_string_set",
      "library": "frama-c-studia.core",
      "description": "This module manages configurable string sets with validation, serialization, and hook support, enabling dynamic configuration for static analysis tools. It provides data types for sets of non-empty strings and parameterized string values, with operations for membership, comparison, and project-aware manipulation, while supporting CLI aliases, help messages, and state persistence. The module allows defining categories that control how named options are interpreted, enabling structured configuration groups with dependencies and special handling for `@none`, `@default`, and `@all`. Example uses include tracking memory zone statements, enforcing DSL consistency, and managing analysis behavior through command-line options and interactive configuration updates.",
      "description_length": 765,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_map",
      "library": "frama-c-studia.core",
      "description": "This module manages a parameterized map with unique key-value associations, combining modification tracking, command-line integration, and customizable value handling. It supports string parameters with validation and structured data representations using `Datatype.t`, while categories organize behavior with named accessors and dependencies. Direct operations allow map manipulation, value marshaling, and state computation, with submodules enabling advanced control over static analysis configurations and project-specific parameter handling. Examples include defining CLI options with aliases, tracking memory states, and enabling analysis modes conditionally across program regions.",
      "description_length": 687,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_multiple_map",
      "library": "frama-c-studia.core",
      "description": "This module manages mappings from kernel functions to lists of values, supporting insertion, update, query, and change hooks for reactive state tracking. It integrates custom marshaling and equality checks to handle dynamic function-value relationships across program transformations, particularly in memory zone analysis. The module works with categories that control parameter interpretation, structured values with metadata for deep copies and comparisons, and string-based parameters with validation and dynamic updates. These components together enable precise, configurable tracking of function-related data in static analysis workflows.",
      "description_length": 643,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Filepath",
      "library": "frama-c-studia.core",
      "description": "This module manages file path options with support for dynamic updates, command-line integration, and state persistence. It defines a core file path data type with comparison, hashing, and pretty-printing operations, enabling precise tracking and validation during analysis. Submodules enhance this foundation by structuring file path representation in memory analysis, particularly for tracing write origins and resolving aliases. Together, they support interactive tools and configuration systems where file paths must be dynamically adjusted, validated, and synchronized across sessions.",
      "description_length": 590,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Bool",
      "library": "frama-c-studia.core",
      "description": "This component manages boolean state with customizable lifecycle hooks, default values, and serialization, while defining a boolean-like data type with comparison, equality, and hashing for use in memory analysis. It supports operations such as value toggling, callback registration on state changes, and CLI integration via aliases and documentation, all tied to Frama-C kernel parameters. The data type enables precise tracking of binary states in program execution, with project-aware membership checks and type descriptors for integration with Frama-C's analysis infrastructure. Example uses include persistent configuration flags and state transitions in static analysis workflows.",
      "description_length": 686,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Filepath_list",
      "library": "frama-c-studia.core",
      "description": "This module manages a mutable list of filepaths with dynamic updates, supporting element addition, concatenation, iteration, and emptiness checks. It includes a custom data type for file path lists with equality, comparison, and pretty-printing, along with category management for organizing file paths into named groups like `@none`, `@default`, and `@all`. It also integrates string-based command-line parameters with alias resolution and validation, enabling structured configuration workflows. Use cases include tracking input files during static analysis, configuring analysis scopes via categories, and managing validated file path inputs in project settings.",
      "description_length": 665,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.String_list",
      "library": "frama-c-studia.core",
      "description": "This module manages string lists with dynamic updates, change tracking, and serialization, supporting operations like appending, folding, and comparing elements. It enables callbacks for state transitions and works closely with submodules that handle configuration categories, validated command-line options, and memory-related string sets. The core module directly supports list transformations and synchronization, while child modules introduce structured validation, function argument handling, and set-like semantics for memory zones. Examples include managing analysis options in Frama-C, parsing CLI inputs with constraints, and representing memory identifiers in static analysis.",
      "description_length": 686,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Make_list",
      "library": "frama-c-studia.core",
      "description": "This module manages list-valued options with change tracking, enabling callbacks to react to modifications in dynamic configurations. It supports operations like appending, iteration, and folding over lists, while integrating visibility and deprecation metadata for aliases. The module works with collections of values that support equality, comparison, and hashing, allowing precise membership checks and structural integrity in memory analysis. It also handles string-based command-line parameters with validation, default values, and serialization, making it suitable for coordinating interdependent state changes across analysis components.",
      "description_length": 644,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_set",
      "library": "frama-c-studia.core",
      "description": "This module manages configurable sets of kernel functions with support for value manipulation, project-specific state, and command-line integration, centered around the `Frama_c_kernel.Cil_datatype.Kf.Set.t` data structure. It provides operations for defining, modifying, and enabling categories to classify parameters, handling string-based command-line inputs with validation and alias resolution, and defining data types with equality, comparison, and serialization for kernel function sets. You can use it to enforce constraints on function identifiers, manage synchronized string sets across analysis sessions, or define categories for memory analysis parameters with dependencies and accessors. The module supports deep copying, membership testing, and structured inspection of kernel function sets, enabling precise control in analysis and transformation passes.",
      "description_length": 869,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.False",
      "library": "frama-c-studia.core",
      "description": "This module manages boolean parameters with dynamic state tracking, allowing configuration through `on`/`off` functions, change hooks, and serialization logic. It centers around `Typed_parameter.t` boolean values and integrates with a custom `Datatype` for project state management, supporting features like analysis flags with visibility and deprecation controls. The child module provides a structured datatype implementation with equality, comparison, and pretty-printing, enabling complex data representation for static analysis tasks. Together, they allow configuring and manipulating analysis settings while maintaining synchronized, persistent state across plugin components.",
      "description_length": 682,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.State_dir",
      "library": "frama-c-studia.core",
      "description": "This module manages a specific directory path used for storing state data, providing operations to retrieve, set, and check the existence of the directory. It works with string identifiers and file paths represented by `Frama_c_kernel.Filepath.t`. Concrete use cases include handling plugin-specific storage directories for persistent data during analysis sessions.",
      "description_length": 365,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Int",
      "library": "frama-c-studia.core",
      "description": "This module manages integer parameters with range constraints, supporting value setting, incrementing, and alias handling, while integrating change hooks and custom marshaling for dynamic state updates. It defines a core type `t` with equality, comparison, and pretty-printing operations, along with deep copying and project membership checks, enabling robust manipulation of integer values in static analysis plugins. You can enforce numeric bounds in configurations, track value changes across project states, or serialize data with custom logic, using operations like `set`, `incr`, and `pp` for clarity and control. Submodules enhance these capabilities by providing type descriptors and abstract value management, useful for tracking integer ranges or memory states in kernel modules.",
      "description_length": 789,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Fundec_set",
      "library": "frama-c-studia.core",
      "description": "This module manages collections of CIL function declarations with support for standard set operations, change tracking, and serialization, making it ideal for static analysis tools that need to monitor and manipulate function sets during memory model analysis. It provides a core data type for representing function sets, along with operations for adding, comparing, and iterating over elements, while integrating visibility controls and update hooks to manage state across analyses. Child modules extend this foundation with configuration handling for string parameters, enhanced set functionality for structured collections, and category-based parameter systems that control analysis behavior. Together, these components enable tasks like enforcing naming conventions, synchronizing memory zone tracking, and configuring analysis scopes through structured and validated parameters.",
      "description_length": 883,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.String_set",
      "library": "frama-c-studia.core",
      "description": "This module manages string sets with advanced tracking, configuration, and serialization features, built around a core data type for efficient membership checks, comparisons, and project-aware manipulation. It supports global state updates through command-line options, validation, and category-based parameter interpretation, enabling dynamic configuration and analysis tasks. Users can define callbacks for state changes, register named categories with custom behavior, and perform operations like adding strings, filtering by project state, or checking against allowed values. Example workflows include synchronizing string collections across analysis phases, validating function names at runtime, or managing memory zone configurations with category-specific rules.",
      "description_length": 769,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia.Options.Action",
      "library": "frama-c-studia.core",
      "description": "This module manages boolean state through a shared parameter interface, supporting dynamic updates with change hooks, alias registration, and serialization control. It exposes global or module-level boolean flags via `Frama_c_kernel.Typed_parameter.t`, allowing configuration through command-line options or project-specific logic, with actions like `on` and `off` to toggle values while tracking dependencies and defaults. The child module enhances this system by defining a data type with equality, comparison, and pretty-printing operations, enabling precise manipulation of analysis states such as abstract memory values during static analysis. Together, they support tasks like synchronizing state across modules, managing analysis configurations, and transforming code based on dynamic conditions.",
      "description_length": 803,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options.Kernel_function_map",
      "library": "frama-c-studia.core",
      "description": "This module organizes kernel functions as keys in a structured map, enabling associations with arbitrary values while supporting operations like setting, retrieving, and observing changes. It includes data types for representing function keys, categorized parameters, and string-based values with validation, offering operations for comparison, hashing, pretty-printing, and deep copying. The module facilitates tracking function declarations, managing deprecated aliases, and integrating with analysis systems through customizable categories and dynamic parameter handling. Use it to implement configuration state tracking, safe function reference management, or command-line configurable settings with persistent storage.",
      "description_length": 723,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Writes",
      "library": "frama-c-studia.core",
      "description": "This module identifies statements that modify a specified memory zone, categorizing each modification as direct assignment, direct function call, indirect function call, global initialization, or formal parameter initialization. It operates on memory zones and Frama-C statements, leveraging CIL types to analyze and track modifications. Concrete use cases include static analysis of variable assignments and tracking side effects in function calls within C programs.",
      "description_length": 467,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Reads",
      "library": "frama-c-studia.core",
      "description": "This module computes statements that read a specified memory zone, distinguishing between direct reads and indirect reads through function calls. It operates on memory zones and statement data from the Frama-C CIL types. Use it to analyze data dependencies or track where memory values are accessed in program code.",
      "description_length": 315,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Studia.Options",
      "library": "frama-c-studia.core",
      "description": "This module orchestrates configuration, diagnostics, and state management for Frama-C plugins through a structured blend of typed parameters, file paths, and category-based controls. It centers on data types like `warn_category`, `Cmdline.Group.t`, and typed parameters (strings, floats, enums, booleans, integers, filepaths), enabling command-line integration, dynamic validation, change tracking, and conditional logging. Operations span setting and serializing values, managing multibinding maps and kernel function sets, organizing parameters into activation groups, and directing diagnostics through category filters. You can configure analysis behavior via CLI flags, track memory states with typed maps, manage session and cache directories, or enforce constraints on function names and numeric ranges across analysis sessions.",
      "description_length": 834,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Studia",
      "library": "frama-c-studia.core",
      "description": "This module analyzes memory access patterns in C programs by identifying statements that modify or read specific memory zones, categorizing the nature of each access. It provides data types for memory zones, Frama-C statements, and CIL-based analysis structures, supporting operations such as tracking direct and indirect assignments, function call side effects, and initialization sources. You can use it to trace variable updates, analyze data dependencies, or detect global and parameter initialization across functions. Additional support for plugin configuration enables command-line control of analysis parameters, dynamic validation, and structured diagnostics for memory-related analyses.",
      "description_length": 696,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From.Callwise",
      "library": "frama-c-from.core",
      "description": "This module provides operations to iterate over and query assignment statements associated with control points in the analysis. It works with control point (`kinstr`) and assignment (`Assigns.t`) data types from the Frama-C kernel and Eva plugin. Concrete use cases include inspecting or modifying assignments at specific control points during static analysis.",
      "description_length": 360,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From",
      "library": "frama-c-from.core",
      "description": "This module analyzes function call dependencies and memory assignments in C code, enabling precise tracking of memory effects and side effects across function calls. It offers operations to compute memory zones, analyze call sites, and retrieve effects for kernel functions, working directly with data types like `kinstr` and `Assigns.t`. The child module extends this by allowing iteration over assignment statements at control points, supporting inspection and modification of assignments during static analysis. Together, they enable detailed memory dependency analysis, visualization of call-wise memory behavior, and fine-grained manipulation of assignments in the Eva plugin.",
      "description_length": 681,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G.E",
      "library": "frama-c-alias.core",
      "description": "This module defines directed edges with labels, supporting creation, comparison, and access to source and destination vertices. It operates on edge values of type `t`, vertices of type `vertex`, and labels of type `label`. It is used to represent and manipulate labeled directed edges in a graph, such as constructing edges between nodes with specific labels or comparing edges for ordering.",
      "description_length": 391,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G.V",
      "library": "frama-c-alias.core",
      "description": "This module defines vertices for a graph structure, where each vertex is an integer with a label. It provides operations to create vertices from labels, retrieve labels from vertices, and compare, hash, and check equality of vertices. These operations support building and manipulating graph structures that rely on labeled vertices.",
      "description_length": 333,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.Statement",
      "library": "frama-c-alias.core",
      "description": "This module provides functions to analyze aliasing relationships between variables and lvalues at the level of individual statements. It supports queries such as determining which variables or lvalues point to a given lvalue, listing alias sets, identifying new aliases introduced by a statement, and checking if two lvalues are aliased. These operations are used in static analysis to track memory references and data dependencies within C code.",
      "description_length": 446,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.G",
      "library": "frama-c-alias.core",
      "description": "This module provides tools to analyze and manipulate graph structures by combining core graph properties with labeled vertices and directed edges. It supports operations to inspect graph characteristics like directedness, vertex and edge counts, and degree statistics, while integrating vertex and edge definitions that allow creation, comparison, and labeling. Vertices are represented as integers with associated labels, and edges are directed with explicit source and destination vertices and labels. For example, you can count the number of vertices in a graph, create a labeled edge between two labeled vertices, or determine whether the graph is cyclic based on its structure.",
      "description_length": 682,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.EdgeLabel",
      "library": "frama-c-alias.core",
      "description": "This module defines and manipulates edge labels used to represent pointer and field access relationships in memory graphs. It supports operations to check label types (`is_pointer`, `is_field`), compare labels, and pretty-print them for debugging. Concrete use cases include tracking memory references in static analysis and visualizing data dependencies in C code.",
      "description_length": 365,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.API.Function",
      "library": "frama-c-alias.core",
      "description": "This module provides functions to analyze aliasing relationships between variables and lvalues within a function. It computes points-to sets, alias sets, and checks whether two lvalues are aliased at the end of a function. These operations are used to track memory references and overlaps in static analysis of C code.",
      "description_length": 318,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Alias.API.Abstract_state",
      "library": "frama-c-alias.core",
      "description": "This module provides operations to query and analyze an abstract alias state, including retrieving points-to graphs, variable sets, and lvalue aliases. It supports concrete use cases such as identifying all variables that may be pointed to by a given lvalue, finding all lvalues that are aliases of a given lvalue, and extracting alias sets in various forms. Functions also allow pretty-printing, dot output, and inclusion testing between abstract states.",
      "description_length": 455,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Alias.Analysis",
      "library": "frama-c-alias.core",
      "description": "Performs alias analysis on the program's memory model to determine which variables reference the same memory locations. Works with abstract representations of program variables and memory states. Used during static analysis to detect pointer equivalences and optimize memory operations.",
      "description_length": 286,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Alias.API",
      "library": "frama-c-alias.core",
      "description": "This module tracks aliasing relationships between lvalues in C functions using a graph-based representation where vertices represent equivalence classes of aliased variables. It provides operations to fold over statements and vertices for analyzing aliasing effects, manipulate abstract states for interprocedural analysis, and simulate function calls to update aliasing information. You can determine which variables may alias a given lvalue at a specific program point, compute points-to sets, analyze memory references within functions, and inspect graph properties such as vertex count and cyclicity. The module supports labeled edges for pointer and field access tracking, and allows queries on alias sets, lvalue overlaps, and directed graph structures.",
      "description_length": 759,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Alias",
      "library": "frama-c-alias.core",
      "description": "This module performs alias analysis using a graph-based representation to track which variables reference the same memory locations. It provides data types for lvalues, equivalence classes, and labeled edges to model pointer and field accesses. Operations include folding over statements, manipulating abstract states, and querying alias relationships or points-to sets. You can analyze memory references within functions, determine variable aliasing at specific program points, or inspect graph properties like cyclicity and vertex count.",
      "description_length": 539,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sparecode.Register",
      "library": "frama-c-sparecode.core",
      "description": "Works with Frama-C projects to remove unused code elements. Provides `get` to strip functions of unused parts based on annotations or slicing, and `rm_unused_globals` to eliminate unused global variables and types from a project. Useful for reducing project size before analysis or improving clarity in code reviews by eliminating dead code.",
      "description_length": 341,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sparecode",
      "library": "frama-c-sparecode.core",
      "description": "This module analyzes Frama-C projects to detect and remove unused code elements. It offers `get` to strip functions of unused parts using annotations or slicing, and `rm_unused_globals` to eliminate unused global variables and types. These operations help reduce project size and improve code clarity by removing dead code before analysis or during reviews. For example, `get` can clean up function bodies based on slicing criteria, while `rm_unused_globals` simplifies the global scope by removing unreferenced declarations.",
      "description_length": 525,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map.Make",
      "library": "mthread",
      "description": "This module implements a map structure keyed by pointers, where values are of a specified data type. It provides standard map operations including comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate pointer-indexed data in a type-safe manner, particularly in analysis or transformation passes requiring precise memory modeling.",
      "description_length": 411,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map.Key",
      "library": "mthread",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports working with project-specific values through membership testing and deep copying. Use cases include managing and comparing map keys in contexts requiring precise memory modeling, such as static analysis of pointer-based data structures.",
      "description_length": 398,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl.Key",
      "library": "mthread",
      "description": "This module defines a key type for a hash table that stores values with operations for equality, comparison, hashing, and pretty-printing. It supports data types that include project-specific identifiers, enabling checks for membership within projects and deep copying to avoid shared references. Concrete use cases include managing and comparing keys in a thread-aware memory model where project-specific data must be uniquely identified and manipulated.",
      "description_length": 455,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl.Make",
      "library": "mthread",
      "description": "This module implements a typed hash table where keys are pointers and values are of a specified `Data` module type. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate pointer-indexed data in a thread-aware memory model, particularly in static analysis plugins.",
      "description_length": 395,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map.Key",
      "library": "mthread",
      "description": "This module defines the key type used in maps associating CFG nodes with other data in the multithreaded CFG context. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with functions for deep copying and checking project membership. The keys are used to uniquely identify CFG nodes in map structures during analysis.",
      "description_length": 381,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl.Make",
      "library": "mthread",
      "description": "This module implements a hash table specialized for multithreaded control flow graph nodes, where values are of a provided `Data` type. It includes standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate node-specific data in a multithreaded analysis context, ensuring structural integrity and type-specific behavior.",
      "description_length": 431,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Debug.Datatype",
      "library": "mthread",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with metadata such as a name, type representation, and descriptor. It supports deep copying and membership testing for project values within the data structure. Concrete use cases include managing and manipulating structured debug data in Frama-C's MThread plugin, particularly for analysis and visualization tasks.",
      "description_length": 429,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype for handling string-based command-line parameters representing thread sets in a multi-threading configuration. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include parsing and manipulating thread sets specified via the `-mt-only-threads` command-line option in a static analysis tool.",
      "description_length": 433,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Hashtbl",
      "library": "mthread",
      "description": "This module provides a thread-safe hash table for pointer keys with imperative operations for insertion, deletion, and lookup, along with ordered iteration and value-based comparisons. It supports bulk sequence processing, optional values, and memoization, making it suitable for concurrent programs like Frama-C's memory model. The key module defines operations for project-specific identifiers, enabling deep copying and membership checks, while the typed hash table module manages pointer-indexed data with standard operations and project awareness. Examples include tracking memory states in static analysis plugins and ensuring unique key handling across projects.",
      "description_length": 669,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Verbose.Datatype",
      "library": "mthread",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with metadata such as a name, type information, and structural descriptors. It supports deep copying, membership testing over project values, and provides representants for the type. Concrete use cases include managing and manipulating values that carry project-specific information in a type-safe and persistent manner.",
      "description_length": 434,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl.Key",
      "library": "mthread",
      "description": "This module defines the key type for a hash table that stores multithreaded control flow graph nodes. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hash table structure when analyzing or transforming multithreaded CFGs in Frama-C plugins.",
      "description_length": 402,
      "index": 143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Map",
      "library": "mthread",
      "description": "This module provides an ordered, immutable map structure with keys of type `Pointer.t` and polymorphic values, supporting efficient associative operations like insertion, lookup, and removal, with safe `_opt` variants for partial functions. It includes submodules that define key operations and type-specific map implementations, enabling precise memory modeling and project-aware analysis. Main data types include the map itself and its key type, with operations for comparison, hashing, traversal, and transformation. Examples include tracking memory metadata with ordered keys, performing type-safe pointer-indexed data analysis, and converting maps to sequences for deterministic processing pipelines.",
      "description_length": 705,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype for handling string-based interrupt configurations in command-line interfaces. It supports operations like equality checks, comparison, hashing, and pretty-printing for string values. It is used to represent and manipulate interrupt handler settings passed as command-line arguments.",
      "description_length": 314,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype for handling string-based collection parameters in command-line options, specifically for the `-mt-extract` behavior. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to represent and manipulate sets of string values in a structured and type-safe manner.",
      "description_length": 396,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer.Set",
      "library": "mthread",
      "description": "This module supports standard set operations on memory pointers, including union, intersection, and difference, along with ordered traversal and querying capabilities like cardinality, extremal element retrieval, and membership checks. It works with sets of memory pointers ordered via a comparator, enabling transformations such as mapping, filtering, and partitioning, as well as conversions to and from lists and sequences. These operations are useful for analyzing memory regions in concurrent programs, such as tracking disjoint pointer accesses or managing thread-local storage in static analysis tasks.",
      "description_length": 609,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map.Make",
      "library": "mthread",
      "description": "This module implements a map keyed by multithread control flow graph nodes, with values parameterized by the `Data` module. It provides standard map operations including comparison, equality, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to associate node-specific data with multithread CFG nodes, enabling analysis and transformation passes that track per-node state.",
      "description_length": 424,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Precise.ZoneMap.LOffset",
      "library": "mthread",
      "description": "This module provides operations for managing interval-bound abstract values with lattice semantics, supporting precise merging, customizable folding over overlapping intervals, and membership queries. It works with interval-based maps that associate abstract values to integer ranges, incorporating descriptors for typing, structural checks for uniformity, and cache-aware optimizations. These capabilities are particularly useful in static analysis for tracking value ranges and merging abstract states with interval-specific precision.",
      "description_length": 537,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.As_string.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for representing thread-skipping configurations as strings, supporting operations like equality checks, comparison, hashing, and pretty-printing. It provides utilities for deep copying values, checking membership based on project predicates, and describing the type with a unique name and descriptor. Concrete use cases include parsing and managing command-line options that specify which threads to skip during analysis.",
      "description_length": 453,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Session",
      "library": "mthread",
      "description": "This module manages a session directory for a plugin, providing direct access to directory and file paths within that session. It allows setting, retrieving, and checking the existence of a session directory, as well as obtaining specific files or subdirectories with optional path creation. Concrete use cases include storing and accessing plugin-specific data such as logs, caches, or configuration files during analysis.",
      "description_length": 423,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.PrintCallstacks.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to callstack printing behavior. It supports equality checks, comparison, hashing, pretty-printing, deep copying, and project membership testing. The type is used to manage and query callstack-related options in a structured and persistent manner.",
      "description_length": 343,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Verbose",
      "library": "mthread",
      "description": "This module manages integer-valued verbosity settings within bounded ranges, supporting dynamic adjustments, pre- and post-update hooks, and integration with state serialization systems. It defines a tracked integer type that enables command-line configuration, value monitoring, and custom marshaling, making it suitable for thread-related logging control and runtime configuration updates. The child module enhances this functionality by introducing a data type `t` with equality, comparison, and pretty-printing operations, along with metadata such as names and structural descriptors. Together, they enable type-safe manipulation of verbosity values with project-specific context, supporting use cases like persistent state synchronization and distributed component configuration.",
      "description_length": 784,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ToDisk.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating project-related data structures in memory. It supports equality checks, comparison, hashing, and pretty-printing, along with deep copying and membership testing for project skeletons. The type is used to manage and persist project configurations when handling the `-mt-projects-on-disk` option.",
      "description_length": 376,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.WriteWriteRaces.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to write-write race analysis in a concurrent setting. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Use cases include tracking and analyzing memory writes in multi-threaded programs to detect conflicting accesses.",
      "description_length": 383,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.IgnoreNull.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling values related to the `-mt-ignore-null` option in Frama-C's Mthread plugin. It supports representants, descriptors, and project membership checks, enabling precise analysis of program states involving null pointers. Concrete use cases include tracking and comparing analysis results across different projects and configurations.",
      "description_length": 454,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.Category",
      "library": "mthread",
      "description": "This module manages categories for the `OnlyThreads` collection, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types that include elements of type `elt` and are structured using `Parameter_category.t`. Concrete use cases include setting up command-line parameter categories, enabling all parameters by default with specific interpretations, and defining dependencies between categories.",
      "description_length": 474,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepWhiteNodes.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing and manipulating values related to the `-mt-non-shared-accesses` option in a static analysis context. It supports equality, comparison, hashing, and pretty-printing of these values, ensuring deep copying and providing introspection via type descriptors. Use cases include managing analysis configurations and tracking project-specific properties through the `mem_project` function.",
      "description_length": 446,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.State_dir",
      "library": "mthread",
      "description": "This module manages a specific state directory for a plugin, providing operations to retrieve, set, and check the existence of the directory path. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional directory creation when accessing files or subdirectories. Concrete use cases include storing and retrieving plugin-specific state files, ensuring the correct directory structure is available during analysis.",
      "description_length": 442,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use with the `-mt-extract` command line option. It supports deep copying and membership checking over project values, enabling precise manipulation and analysis of model extraction data. The type is used to represent and process command-line-specified data structures during static analysis.",
      "description_length": 408,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.StopAfter.Datatype",
      "library": "mthread",
      "description": "This module defines a concrete data type for representing stopping conditions after a given analysis step in a multi-threaded context. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, as well as inspection via project membership. The type is used to manage and query stopping criteria tied to specific project states, enabling precise control over analysis termination.",
      "description_length": 422,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.As_string",
      "library": "mthread",
      "description": "This module manages string-based command-line parameters with validation, state tracking, and support for structured collections. It provides data types and operations to define allowed values, extract literals or function names, and enforce constraints, while integrating submodules that handle specific behaviors like `-mt-extract` through typed sets with equality, comparison, and membership checks. Users can create restricted input parsers, manage dynamic aliases, or build configurable workflows with serialization control and hook registration. Example uses include validating command-line flags against predefined options and tracking project-specific string sets during execution.",
      "description_length": 689,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.Datatype",
      "library": "mthread",
      "description": "This module defines a data type and operations for handling sets of thread-skipping behaviors as command-line parameters. It supports equality checks, comparison, hashing, and pretty-printing for values of type `t`, along with deep copying and membership testing over project skeletons. It is used to represent and manipulate thread exclusion rules in a type-safe manner during static analysis.",
      "description_length": 394,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling command-line parameters related to thread analysis. It supports values that may contain project-specific information, enabling checks and deep copies to ensure independent data representations. Use cases include managing and comparing thread-related configuration options in a type-safe manner during static analysis.",
      "description_length": 456,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Cache_dir",
      "library": "mthread",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and includes functions to set, get, and check the existence of the cache directory. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured file path hierarchy.",
      "description_length": 407,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.PopTopFunctionForCallbacks.Datatype",
      "library": "mthread",
      "description": "This module defines a data type and operations for managing values with support for equality, comparison, hashing, and pretty printing. It provides functions for deep copying, checking project membership, and accessing type representations, descriptors, and names. This module is used to handle structured data values in a way that ensures uniqueness and supports efficient querying and transformation.",
      "description_length": 402,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.AccessesByZoneNode.LOffset",
      "library": "mthread",
      "description": "This module provides interval-based operations for merging, comparing, and checking inclusion of memory access ranges, using abstract values and node-specific data structures (`AccessesByZoneNode.v`). It manages offset maps that bind integer intervals to values, supporting lattice-based analysis through merging, folding with caching, and interval fusion. These tools are applied in static analysis to track thread memory accesses and perform abstract interpretation with project filtering and deep copies.",
      "description_length": 507,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Share",
      "library": "mthread",
      "description": "This module manages the plugin's `share` directory configuration by setting, retrieving, and validating directory paths. It provides operations to set a directory path, check if a path is set, and resolve specific files or subdirectories within the share directory. It ensures correct file or directory existence and type when accessing shared resources.",
      "description_length": 354,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling interrupt-related configurations in command-line parameters. It supports structured values through a descriptor system, enabling deep copying and membership checks over project skeletons. Use cases include managing and comparing interrupt handler settings during static analysis of multi-threaded programs.",
      "description_length": 445,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Precise.ZoneMap",
      "library": "mthread",
      "description": "This module manages interval-bound abstract values with lattice semantics, enabling precise merging, customizable folding over overlapping intervals, and membership queries. It supports maps that associate integer ranges with abstract values, integrating descriptors for typing, structural checks, and cache-aware optimizations. Operations allow merging abstract states with interval-specific precision, querying value membership, and folding over overlapping intervals with custom logic. It is particularly effective in static analysis for tracking and merging value ranges across program states.",
      "description_length": 597,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.KeepProjects.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for managing project retention policies with three states: all, last, or none. It provides operations for equality checks, comparison, hashing, and pretty-printing, as well as functions to filter and copy project data. The type supports deep inspection via representants and descriptors, and it integrates with project skeletons for policy evaluation.",
      "description_length": 383,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ConcatDotFilesTo.Datatype",
      "library": "mthread",
      "description": "This module defines a data type for handling file concatenation targets in the context of the `-mt-concat-dot-files-to` option. It supports operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. The type is used to represent and manipulate file output configurations during analysis, ensuring correct handling of merged dot file outputs.",
      "description_length": 418,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowTime.Datatype",
      "library": "mthread",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating values related to the `-mt-time` option. It includes support for deep copying and project membership checks, ensuring values can be inspected and transformed independently. The type is used to manage and distinguish time-related configurations within the analysis framework.",
      "description_length": 428,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.Category",
      "library": "mthread",
      "description": "This module manages categories for a thread-skipping option, providing functions to define, enable, and modify category behaviors. It works with category types and state lists, allowing specific thread execution contexts to be controlled through named categories. Concrete use cases include enabling all threads under a specific category or setting default thread exclusion rules via command-line parameters.",
      "description_length": 408,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.FullCfg.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating values under the `-mt-full-cfg` option. It includes support for deep copying, membership testing within project skeletons, and provides a list of representative values. The type is used to model and manage analysis configurations in the context of Frama-C's kernel, enabling precise control over full CFG (Control Flow Graph) handling during static analysis.",
      "description_length": 518,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Global.ZoneMap",
      "library": "mthread",
      "description": "This module organizes memory states as hierarchical maps linking zones to value sets, enabling lattice operations like join and inclusion checks alongside map manipulations such as binding updates and interval folding. It supports abstract interpretation tasks, including merging overlapping memory regions and tracking heap abstractions through structured zone mappings. Submodules refine these operations with specialized logic for interval management, zone merging, and value set transformations. For example, it can fold over memory intervals to aggregate values, update zone bindings to refine memory models, or check inclusion to determine state subsumption.",
      "description_length": 664,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Hashtbl",
      "library": "mthread",
      "description": "This module provides thread-safe hash tables mapping control flow graph nodes to arbitrary values, supporting imperative operations like insertion, lookup, and ordered iteration with customizable key comparators. It enables deterministic traversal and bulk manipulation of entries, with specialized functions for working with sequences of nodes and integrating with static analysis frameworks. The child modules define key and value types with standard operations\u2014such as equality, hashing, and pretty-printing\u2014for use in multithreaded CFG analysis, supporting deep copying and project membership checks. Examples include tracking node-specific data across threads and performing deterministic analysis passes on graph-based intermediate representations.",
      "description_length": 754,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.DumpSharedVarsValues.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values tied to a specific option in a static analysis tool. It supports deep copying, equality checks, hashing, and pretty-printing, making it suitable for use in analysis configurations and state tracking. The type is integrated with project-based filtering via `mem_project`, enabling conditional checks on embedded project data.",
      "description_length": 425,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.Category",
      "library": "mthread",
      "description": "This module manages categories for interrupt handler options, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types that associate string names with elements and accessors, and supports setting default behaviors and enabling all categories with specific interpretations. Concrete use cases include configuring interrupt handling behavior through command-line parameters and managing dependencies between interrupt-related states.",
      "description_length": 515,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode.Map",
      "library": "mthread",
      "description": "This module manages maps associating multithreaded CFG nodes with arbitrary data, supporting insertion, lookup, traversal, and transformation. It provides key operations like `add_to_list` for aggregating values, filtering by node properties, and merging or splitting maps based on analysis needs. The key module defines identity, comparison, and project membership for CFG node keys, while the data module enables parameterized value storage with support for deep copying and structural checks. Together, they facilitate tracking and transforming node-specific metadata across CFGs in concurrent analysis scenarios.",
      "description_length": 616,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ModerateWarnings.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports structured values that may contain embedded project data, enabling checks via `mem_project` and deep copying with `copy`. Use cases include managing and comparing structured configurations or descriptors in static analysis contexts.",
      "description_length": 363,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads.As_string",
      "library": "mthread",
      "description": "This module handles string-based command-line options with strict validation, allowing values to be checked against literals or functions, and supports state manipulation and change tracking. It works with string parameters, validation rules, and sets of allowed values to enforce input correctness, such as restricting thread-related flags to predefined identifiers or custom validation logic. The child module enhances this by defining a string-based data type for thread-skipping configurations, supporting equality, comparison, and membership checks, along with deep copying and type description. Together, they enable parsing, validating, and managing command-line flags that control thread behavior with precise and customizable constraints.",
      "description_length": 747,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.ThreadPresence.KeySet",
      "library": "mthread",
      "description": "This module provides ordered set operations on thread presence keys, supporting standard set functions (union, intersection, difference, membership) alongside ordered iterations (descending traversal, nearest element search) and transformations (filtering, mapping, partitioning). It works with a set type `t` containing ordered elements of type `elt`, offering efficient membership checks, subset relations, and conversions to/from lists and sequences. Specific use cases include managing thread access control in synchronized zones, tracking active threads in ordered contexts, and implementing priority-based thread scheduling mechanisms.",
      "description_length": 641,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.MutexPresence.KeySet",
      "library": "mthread",
      "description": "This module implements an immutable set abstraction for managing ordered mutex presence keys, supporting standard operations like union, intersection, difference, and predicate-based transformations while maintaining total ordering. It provides ordered traversal, element proximity queries, and conversions to/from lists/sequences, with elements adhering to a strict comparison ordering. Designed for Frama-C plugin development, it facilitates concurrency analysis tasks like tracking mutex access patterns, verifying thread safety properties, and managing project-specific key sets with efficient membership checks and structural operations.",
      "description_length": 642,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.KeepGreenNodes.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating values related to the `-mt-non-concurrent-accesses` analysis behavior. It supports structured data handling with deep copying, membership testing within projects, and type-safe descriptors for integration with Frama-C's kernel. Use cases include managing analysis-specific configurations and values during static analysis, ensuring correct value representation and project-specific filtering.",
      "description_length": 552,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.SetStmtIdAccess.O",
      "library": "mthread",
      "description": "This module offers functional set operations and utilities for managing immutable collections of statement identifiers tied to shared variable accesses in concurrent programs. It supports efficient membership queries, set algebra, and transformations while providing integration hooks for Frama-C's analysis kernel, such as hashing, pretty-printing, and deep-copying. The structure is specifically designed for tracking and analyzing multi-threaded synchronization points where shared variables are accessed, including handling dummy accesses that enforce algorithmic convergence.",
      "description_length": 580,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads.As_string",
      "library": "mthread",
      "description": "This module manages command-line options that accept string values, with support for validation, dynamic state updates, and integration with C-style function name checks. It defines core operations for handling string parameters, including alias resolution, value serialization, and change hooks, while its child module specializes in thread set configurations with operations like membership checks and pretty-printing. Examples include restricting thread-related options to valid sets or enforcing naming rules for identifiers through predefined value checks. The module works with a global parameter state, enabling consistent access and updates across different parts of a program.",
      "description_length": 685,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.Enabled.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values that may contain project-specific data, enabling checks for project membership and deep copying to avoid shared state. Concrete uses include managing and comparing complex configurations or state values in analysis tools.",
      "description_length": 370,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers.As_string",
      "library": "mthread",
      "description": "This module manages string-based command-line parameters with support for validation, alias resolution, and custom serialization, operating on string and string list values. It provides operations for dynamic configuration handling in CLI tools, including runtime option updates and structured parsing. The child module enhances this functionality by defining a datatype for interrupt configurations, supporting equality checks, comparison, hashing, and pretty-printing of string values. Together, they enable precise manipulation and representation of command-line settings such as interrupt handlers and configurable options.",
      "description_length": 627,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels.Category",
      "library": "mthread",
      "description": "This module manages categories for a collection of elements, where each category is associated with an accessor and a list of dependencies. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, allowing fine-grained control over how elements are interpreted or activated in the context of command-line parameters. Use cases include configuring model extraction behavior through named categories that determine which elements are selected or how they are processed.",
      "description_length": 519,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDiskPrefix.Datatype",
      "library": "mthread",
      "description": "This module defines a data type `t` and associated operations for managing project representations on disk, specifically for handling the `-mt-projects-on-disk-prefix` option. It includes functions for equality, comparison, hashing, pretty printing, membership testing over projects, and deep copying, all tailored to values of type `t`. The module is used to manipulate and query structured project data with semantic-preserving operations.",
      "description_length": 441,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Debug",
      "library": "mthread",
      "description": "This module manages bounded integer values with support for change tracking, range enforcement, and update hooks, integrating metadata such as defaults, command-line visibility, and serialization settings. It defines a core data type `t` with operations for comparison, hashing, and pretty-printing, along with support for aliases and state synchronization. The module enables tasks like configuring constrained system parameters or implementing dynamic variables with validation and notification, while its child module enhances structured debug data manipulation, particularly in Frama-C's MThread plugin for analysis and visualization. Together, they support deep copying, membership testing, and metadata-aware operations on integer parameters within a unified framework.",
      "description_length": 775,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.SetNodeIdAccess.O",
      "library": "mthread",
      "description": "This module provides a set-based data structure for managing node identifiers in Frama-C's static analysis framework, supporting standard operations like union, intersection, difference, and element manipulation, alongside iteration, filtering, and subset checks. It includes utilities for comparison, hashing, pretty-printing, and deep copying, specifically designed for handling node IDs in analysis tasks and integrating with Frama-C's plugin system through type descriptors and project-specific infrastructure.",
      "description_length": 514,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types.Pointer",
      "library": "mthread",
      "description": "This module represents memory pointers with a core type `t` and operations for equality, comparison, hashing, and pretty printing, along with utilities for project membership checks, deep copying, and collection management. It supports advanced pointer analysis through three submodules: a thread-safe hash table for concurrent pointer-keyed storage and memoization, an ordered immutable map for precise pointer-indexed data association, and a comparator-based set module for efficient memory region manipulation. These components enable tasks like tracking memory states across projects, modeling pointer relationships in static analysis, and managing thread-local or disjoint pointer accesses in concurrent programs. Examples include analyzing aliasing, maintaining typed pointer metadata, and performing deterministic set transformations in analysis plugins.",
      "description_length": 861,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowReturnEdges.Datatype",
      "library": "mthread",
      "description": "This module defines a datatype for representing and manipulating values related to the behavior of the `-mt-return-edges` option in Mthread. It includes standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. The module is used to handle configuration values that control how return edges are displayed in interprocedural analyses.",
      "description_length": 410,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread.Config_dir",
      "library": "mthread",
      "description": "This module manages the creation, retrieval, and configuration of plugin-specific directories and files within a Frama-C environment. It provides direct operations to obtain directory and file paths, with optional path creation, and allows setting and querying a user directory. Concrete use cases include handling plugin configuration storage, ensuring proper file structure for analysis outputs, and managing per-user settings directories during static analysis runs.",
      "description_length": 469,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByZone.LOffset",
      "library": "mthread",
      "description": "This module supports interval-based management of mutex bindings through operations on integer intervals mapped to values, incorporating lattice functions like `join` and `find` for abstract interpretation. It works with offset maps that track concurrency-related state in static analysis, enabling efficient interval merging, cache-aware queries, and deep copying to model memory-bound mutex behavior in Frama-C's concurrent program analysis.",
      "description_length": 443,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.CheckProtections.Datatype",
      "library": "mthread",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating values related to the `-mt-shared-accesses-synchronization` option in a concurrent analysis context. It includes functions for deep copying, membership testing within projects, and standard type descriptors for integration with the Frama-C kernel. The data type is used to model synchronization behaviors in multi-threaded code analysis, enabling precise tracking and checking of shared memory accesses.",
      "description_length": 563,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.WriteWriteRaces",
      "library": "mthread",
      "description": "This module manages a boolean option that controls write-write race detection in multi-threaded programs, offering operations to toggle its state, register change hooks, and handle serialization. It works with a boolean state and project-specific tracking data, enabling configuration via command-line flags and monitoring of state changes across projects. The child module defines a data type for representing and manipulating values related to race analysis, supporting equality, comparison, hashing, pretty-printing, deep copying, and project membership checks. Together, they enable precise tracking and analysis of memory writes to detect conflicting accesses in concurrent programs.",
      "description_length": 688,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.PrintCallstacks",
      "library": "mthread",
      "description": "This module manages a shared boolean flag that controls call stack printing behavior, allowing dynamic toggling via `on`/`off` actions and integration with command-line interfaces. It supports default settings, project-specific configuration, and serialization of the flag\u2019s state. A core data type represents callstack printing options with operations for equality, comparison, pretty-printing, and deep copying, enabling structured manipulation and querying. Submodules extend this functionality to handle project membership testing and persistent configuration of callstack visibility settings.",
      "description_length": 597,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.SetNodeIdAccess",
      "library": "mthread",
      "description": "This module implements lattice operations for analyzing sets of node IDs with access permissions, combining set-theoretic manipulations and functional transformations to support dataflow tracking and permission validation in concurrent systems. It provides core data structures for managing node identifiers with operations such as union, intersection, difference, and element queries, along with utilities for comparison, hashing, and pretty-printing. The design supports multithreaded control flow analysis through join, meet, and projection operations that integrate thread-local states and enable precise cardinality-aware analyses. Specific use cases include tracking accessed nodes across threads and validating access permissions during static analysis in Frama-C.",
      "description_length": 771,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_outputs.Eva_results",
      "library": "mthread",
      "description": "Handles the display of analysis results by printing formatted output to the console. Works with `Mthread.Mt_thread.analysis_state` to visualize the outcome of value analysis. Useful for debugging and reporting the final state of thread analysis in a human-readable form.",
      "description_length": 270,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.MutexPresence",
      "library": "mthread",
      "description": "This module represents and manipulates presence information for mutex keys, supporting lookup, insertion, and merging of presence flags to track whether a mutex is present in a given context. It works with a key type and a presence flag type, enabling analysis of thread access patterns and mutex usage in concurrent code. A child module provides an immutable ordered set abstraction for mutex keys, supporting union, intersection, difference, and ordered traversal, with efficient membership checks and transformations. These capabilities enable tasks like tracking mutex access patterns, verifying thread safety, and managing key sets with precise structural operations.",
      "description_length": 672,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.Enabled",
      "library": "mthread",
      "description": "This module manages a boolean flag that controls threading behavior in the kernel, allowing users to set, get, and track changes to the flag's state using primitive boolean values. It integrates with project management and parameter systems to persist and synchronize threading settings across sessions, enabling optimizations and parallel execution coordination in static analysis workflows. The child module enhances this functionality by introducing a structured data type with equality, comparison, and pretty printing, supporting project-aware values and deep copying for safe state management. Together, they enable precise control over threading options and structured configuration handling in analysis tools.",
      "description_length": 717,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer-Access",
      "library": "mthread",
      "description": "This module defines a data type `t` representing access information in a static analysis context, along with operations for equality, comparison, hashing, and pretty printing. It includes standard functions for deep copying, membership testing within projects, and provides type descriptors for integration with analysis frameworks. It is used to manage and manipulate access values in a way that supports precise static analysis of C code.",
      "description_length": 440,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.Presence",
      "library": "mthread",
      "description": "This module represents and manipulates presence information for keys, supporting operations to find, add, and combine presence flags. It works with a key type and a presence flag type, maintaining a mapping from keys to their presence states. Use cases include tracking which keys are present in a given context and merging presence information from different sources.",
      "description_length": 368,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Trie.Make",
      "library": "mthread",
      "description": "This module implements a trie-based map structure using reversed key lists for efficient hierarchical operations. It supports standard map manipulations like insertion, lookup, and folding, along with prefix-based sub-map traversal and decomposition, which are optimized for scenarios requiring key prefix analysis or hierarchical data processing. The reversed key storage minimizes overhead during iterative operations and prefix matching.",
      "description_length": 440,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.KeepGreenNodes",
      "library": "mthread",
      "description": "This module manages a boolean configuration flag that governs handling of non-concurrent memory accesses in multi-threaded analysis, providing operations to toggle its state, observe value changes, and persist settings. It integrates with Frama-C's project management system, supporting use cases like enabling precise concurrency verification or optimizing analysis performance by relaxing thread-safety checks. The child module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing values related to the `-mt-non-concurrent-accesses` behavior. Together, they enable structured configuration management with type-safe descriptors, deep copying, and project-specific filtering during static analysis.",
      "description_length": 764,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.Priority",
      "library": "mthread",
      "description": "This module defines operations for managing thread priority values, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership within projects, create deep copies, and handle type representations for analysis purposes. Concrete use cases include comparing and storing thread priorities in data structures like hash tables or analyzing priority values across different project contexts.",
      "description_length": 430,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.RW",
      "library": "mthread",
      "description": "This module defines operations for handling read and write access types in a multithreaded analysis context. It provides functions to check if an operation is a read, pretty-print operation names and locations, and manage project membership tests. The module works with a list of representants of type `RW.t`, which describe access kinds, and supports comparisons, hashing, and deep copying for analysis tasks like tracking memory accesses or detecting data races.",
      "description_length": 464,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDiskPrefix",
      "library": "mthread",
      "description": "This module manages a configurable disk prefix path option, providing operations to set, validate, and persist string values while integrating with command-line interfaces. It defines a core data type `t` to represent projects on disk, supporting operations like equality checks, comparison, and pretty printing for structured data manipulation. Submodules enable semantic-preserving transformations and membership testing over project collections, facilitating use cases such as validated path management and project layout customization. It combines direct string and list operations with rich data modeling to enforce constraints and support serialization.",
      "description_length": 659,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_outputs.Html",
      "library": "mthread",
      "description": "Generates HTML-formatted summaries of thread analysis results. Works with `Mthread.Mt_thread.analysis_state` to produce human-readable output, typically for reporting or visualization purposes. Useful for displaying thread dependencies, execution flow, or analysis metrics in a structured format.",
      "description_length": 296,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.NodeValueState",
      "library": "mthread",
      "description": "This module defines a type `t` representing the state of a node's value in a concurrent context, along with helper functions to determine presence of threads and mutexes. It includes a dummy value for initialization and functions that check presence based on thread or mutex state transitions. It is used to track and analyze synchronization states in concurrent memory models.",
      "description_length": 377,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.OnlyThreads",
      "library": "mthread",
      "description": "This module manages thread-specific string sets for a command-line parameter, offering operations to add, check membership, iterate, and fold over collections. It uses a custom string set data structure, supports alias registration, custom marshaling, and state tracking, enabling use cases like filtering thread contexts or persisting thread configurations. A child module handles named categories such as `@none`, `@default`, and `@all`, allowing setup and modification of parameter categories with dependencies. Another child module defines a data type with equality, comparison, and pretty-printing for thread analysis options, while a third manages string command-line parameters with validation, dynamic updates, and thread set operations like membership checks and value serialization.",
      "description_length": 792,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cfg_types.NodeIdAccess",
      "library": "mthread",
      "description": "This module defines a data type representing node identifiers in a multithreaded control flow graph, combining read/write status, node, and thread information. It provides standard operations including equality, comparison, hashing, and pretty-printing for this type, along with functions for deep copying and checking project membership. Use cases include analysis and transformation passes that require tracking node accesses across threads in a multithreaded program.",
      "description_length": 470,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.DumpSharedVarsValues",
      "library": "mthread",
      "description": "This module manages an integer state constrained between 0 and 2, with support for value mutation, boundary enforcement, and pre/post-update hooks. It includes a data type for representing option values with comparison, copying, and pretty-printing operations, integrated with project-based filtering through `mem_project`. The combined functionality enables tracking bounded values in concurrent settings, validating configurations dynamically, and customizing serialization and command-line behavior. Specific uses include managing analysis options with strict numeric constraints and embedding project-specific conditions in static analysis tools.",
      "description_length": 650,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ModerateWarnings",
      "library": "mthread",
      "description": "This module manages a hidden boolean flag to control moderate warnings, allowing dynamic toggling and integration with parameter systems for use in static analysis tools. It supports structured data through a child module that provides standard operations like equality, comparison, and pretty-printing, enabling the management of complex configurations. The combined functionality facilitates interactive adjustment of warning levels and structured value manipulation, such as checking project membership or performing deep copies. Together, they enable cohesive handling of both simple flags and rich, structured data across different execution contexts.",
      "description_length": 656,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.LatticeMutexes",
      "library": "mthread",
      "description": "This module defines a lattice structure for mutexes, providing operations such as join, inclusion checks, and equality comparisons over mutex access states. It works with the `mutexes_by_access` type, representing sets of mutexes with access information in a lattice context. Concrete use cases include static analysis of concurrent programs to track and merge mutex usage across different execution paths.",
      "description_length": 406,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.SkipThreads",
      "library": "mthread",
      "description": "This module manages thread exclusion configurations through a string set interface, supporting operations like membership checks, iterative updates, and state change hooks, often used to process `-mt-skip-threads` command-line arguments. It integrates with submodules that define type-safe thread-skipping sets, category-based thread control, and validated string parameters, enabling precise manipulation and enforcement of thread execution rules. You can define thread exclusion sets with aliases, enable or disable categories of threads, and validate command-line inputs against strict constraints. The combined functionality allows parsing, modifying, and applying thread-skip policies with strong typing, deep copying, and customizable validation.",
      "description_length": 752,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.AccessesByZoneNode",
      "library": "mthread",
      "description": "This module organizes memory access analysis around control-flow nodes, using lattice operations to merge and query access states structured by zones, bases, and intervals. It supports precise tracking of memory accesses across program points through operations like `fold_join_zone` and `map2`, enabling static analysis tasks such as concurrency verification and dataflow optimization. The interval submodule enhances this by managing offset maps with inclusion checks and fusion, allowing efficient handling of memory ranges and abstract interpretation with node-specific values. Together, they enable analyses that combine hierarchical memory state transitions with interval-based queries and lattice joins over control-flow graphs.",
      "description_length": 735,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_types.Event",
      "library": "mthread",
      "description": "This module defines operations for comparing, hashing, and pretty-printing event values. It works directly with the `event` type, providing concrete functionality for checking equality between events, generating hash values, and formatting events as human-readable strings. These capabilities are useful in contexts like logging event occurrences, tracking execution traces, or displaying event data in debugging tools.",
      "description_length": 419,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.EventsSet",
      "library": "mthread",
      "description": "This component offers functional set operations for managing event collections in multi-threaded analysis, including union, intersection, difference, and transformations like filtering and mapping. It operates on sets of specialized event elements, supporting conversions to sequences and lists, with functions for iteration, partitioning, and extracting thread-related data. These tools are particularly useful for tracking synchronization points, merging event streams across threads, and analyzing concurrency dependencies in program analysis workflows.",
      "description_length": 556,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByZone",
      "library": "mthread",
      "description": "This module organizes mutexes into a lattice of access zones, enabling precise concurrency control through operations like comparison, inclusion checks, and merging of mutex groups. It manipulates mappings between memory regions\u2014such as zones, bases, and intervals\u2014and mutexes, supporting transformations like filtering, folding, and hash-consed updates for efficient analysis. The interval-based submodule enhances this by managing mutex bindings over integer intervals, incorporating lattice operations such as `join` and `find` to model concurrency state in static analysis. Together, they enable cache-aware traversal, deep copying of mutex configurations, and abstract interpretation of memory-locked regions in concurrent programs.",
      "description_length": 737,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.MThread",
      "library": "mthread",
      "description": "This module organizes diagnostic and logging functionality through hierarchical categories and dynamic configuration, enabling fine-grained control over message verbosity, warning statuses, and runtime diagnostics in concurrent or plugin-driven contexts. It supports formatted message handling, source tracking, and integration with command-line interfaces, while its child modules manage structured file paths, verbosity settings, session directories, cache storage, and plugin-specific state. Data types include tracked integers for bounded configuration values and path representations for directory and file operations, with operations for dynamic updates, persistence, and type-safe manipulation. Examples include suppressing warnings during static analysis, directing log output to specific files, and synchronizing debug settings across distributed components.",
      "description_length": 867,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.AccessesByZone",
      "library": "mthread",
      "description": "This module organizes variable accesses by memory zones using mappings from `Zone.t` to access data, supporting operations like merging (via join), inclusion checks, and filtering to model concurrent memory interactions. It employs a lattice structure with bottom/top elements to enable abstract interpretation for thread analysis, particularly tracking shared variable accesses across zones. The child modules extend this foundation with specialized access tracking, such as per-zone merging strategies and structured offset-based access maps using `LOffset.t`. Together, they allow precise modeling of memory interactions, such as determining which variables are accessed in overlapping zones or aggregating access patterns across threads.",
      "description_length": 741,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cil.Stack",
      "library": "mthread",
      "description": "This module implements a stack data structure with operations for equality, comparison, hashing, and deep copying. It provides functions to check membership based on project values, pretty-print stack contents, and model stack elements representing shared variable accesses in CIL statements. It is used to track and analyze call stacks involving shared memory accesses in concurrent C programs.",
      "description_length": 395,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowTime",
      "library": "mthread",
      "description": "This module manages a boolean flag that controls the visibility of time information in a multi-threaded system, enabling operations to toggle the state, register change listeners, and persist values across sessions. It works with boolean primitives and integrates project-specific state management through hooks and serialization interfaces, supporting debugging of concurrency issues tied to timing data. A custom data type from its child module represents and manipulates `-mt-time` option values with support for equality, comparison, hashing, and pretty-printing, allowing independent inspection and transformation. Together, these components enable precise control and analysis of time-related configurations in concurrent program evaluation.",
      "description_length": 747,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cil.StackElt",
      "library": "mthread",
      "description": "This module defines operations for manipulating stack elements in a CIL-based analysis context, including equality, comparison, hashing, and pretty-printing. It provides utilities to inspect and traverse project-specific data embedded within stack elements, supporting deep copying and membership checks over project skeletons. The module is used to manage and analyze thread-related stack data structures in static analysis tools built on the Frama-C platform.",
      "description_length": 461,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.StopAfter",
      "library": "mthread",
      "description": "This module manages a command-line parameter that enforces bounded integer values, providing operations to increment, clamp, and persist values within specified min and max limits. It integrates a child module representing stopping conditions tied to analysis steps, enabling precise control over termination in multi-threaded analysis. Main data types include the bounded integer parameter and the stopping condition type, both supporting comparison, inspection, and state management. Examples include limiting thread execution counts or setting time-based thresholds, with the stopping condition allowing fine-grained control over analysis termination based on project state.",
      "description_length": 677,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Trie.S",
      "library": "mthread",
      "description": "This module implements a persistent map with efficient lookups, insertions, and deletions over a fixed key type. It supports operations like `add`, `find`, `remove`, and `mem` for managing key-value associations, along with higher-order functions such as `map`, `fold`, and `iter` for transforming and traversing the map. It is suitable for use cases requiring efficient dictionary-like structures, such as symbol table management or caching with ordered keys.",
      "description_length": 460,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.KeepProjects",
      "library": "mthread",
      "description": "This module manages project retention policies through a string-based option with three valid values: \"all\", \"last\", or \"none\". It provides operations to set, query, and monitor changes to the policy, with support for aliases, custom marshaling, and state tracking, integrating with Frama-C's project system to control analysis retention during multi-project workflows. The core type represents policy states with support for equality, comparison, filtering, and pretty-printing, while submodules enable deep inspection and policy evaluation within project skeletons. Example uses include configuring analysis persistence across sessions and dynamically adjusting retention behavior based on project structure.",
      "description_length": 710,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ExtractModels",
      "library": "mthread",
      "description": "This module handles command-line options that store string sets, managing state, aliases, and customizable serialization through `Set.t` structures. It supports parsing, membership checks, and hierarchical option states, with child modules enabling typed set operations, value validation, and category-based element control. Specific functionality includes defining restricted input parsers, enabling dynamic alias resolution, and configuring extraction behavior via named categories like `@default` or `@all`. The integration of typed sets, structured collections, and category management allows for precise manipulation of command-line-specified data during static analysis and configurable workflow execution.",
      "description_length": 712,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.Trace",
      "library": "mthread",
      "description": "This module represents execution traces as mappings from program stacks to events and memory states at specific statements. It supports operations to add events or memory states to traces, query events at specific program points, and extract or combine subtraces. Use cases include analyzing program executions by tracking events and memory changes at statement boundaries, and validating trace properties such as absence of deep calls or presence of specific events.",
      "description_length": 467,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.ConcatDotFilesTo",
      "library": "mthread",
      "description": "This module manages file path configurations for concatenating dot files, offering operations to set, retrieve, and modify paths along with change hooks and serialization support. It centers on `Frama_c_kernel.Filepath.t` for path representation and uses unit values to check emptiness via `is_empty`, enabling output configuration and path validation. The child module enhances this by defining a data type for concatenation targets with equality, comparison, and pretty printing, facilitating precise manipulation of output destinations during analysis. Together, they support use cases like directing merged dot file outputs and integrating with persistent storage systems.",
      "description_length": 676,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types.MutexesByAccess",
      "library": "mthread",
      "description": "This module represents mutexes categorized by access status, providing operations to compare, display, and combine them. It supports data types including mutex identifiers and access states, with functions for equality checks, hashing, joining, and pretty-printing. Concrete use cases include tracking and merging sets of accessed mutexes during static analysis to ensure thread safety.",
      "description_length": 386,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ShowReturnEdges",
      "library": "mthread",
      "description": "This module manages a boolean configuration setting that controls the inclusion of return edges in interprocedural analysis, particularly for static analysis of concurrent programs. It supports operations to set, retrieve, and persist the state, with provisions for project-specific overrides and notifications on change. The associated datatype enables value manipulation, comparison, and pretty-printing, facilitating precise control over how return edges are represented and handled during analysis. Example usage includes enabling return edges for flow-sensitive analysis or disabling them to reduce complexity in specific projects.",
      "description_length": 636,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.KeepWhiteNodes",
      "library": "mthread",
      "description": "This module manages a boolean flag that controls thread safety analysis for non-shared memory accesses in concurrent programs, integrating with Frama-C's state and option-handling systems for dynamic updates and serialization. It defines a data type for representing option values with support for equality, comparison, hashing, and pretty-printing, enabling precise configuration management and introspection. The module allows registering aliases, customizing analysis behavior across different project contexts, and tracking memory properties through project-specific functions. Together with its submodules, it provides a cohesive interface for configuring, manipulating, and querying analysis settings related to thread-unsafe memory operations.",
      "description_length": 750,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types.ThreadPresence",
      "library": "mthread",
      "description": "This module represents thread presence using a key-value structure, where each key corresponds to a thread and the value indicates its presence status. It supports operations to add, find, and combine presence flags, as well as extract sets of present threads, enabling efficient tracking of active threads in analysis contexts. The child module extends this by providing ordered set operations on thread presence keys, supporting union, intersection, ordered traversal, and transformations, with efficient membership checks and subset relations. These capabilities enable use cases like managing thread access control, tracking active threads in ordered contexts, and implementing priority-based scheduling.",
      "description_length": 708,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgConcur",
      "library": "mthread",
      "description": "This module defines operations for managing concurrent access information in a control flow graph. It provides functions to combine access data, add read/write accesses to memory zones, and check properties like whether a variable must be in the graph or if there are any concurrent accesses. The primary data type is `t`, representing concurrent access configurations, used to track and analyze memory accesses across threads in static analysis.",
      "description_length": 446,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer",
      "library": "mthread",
      "description": "Handles concurrent memory access analysis by tracking and formatting memory zones accessed by threads. It provides functions to compute and display overlapping memory accesses, identify all zones accessed, and analyze concurrency across threads using structured data like lists of thread states and zone maps. Useful for detecting race conditions and ensuring memory safety in concurrent programs.",
      "description_length": 397,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.ToDisk",
      "library": "mthread",
      "description": "This module manages a boolean configuration flag that determines whether project data persists to disk, providing operations to toggle its state, observe changes through lifecycle hooks, and customize serialization. It works with a boolean value enriched with metadata for tracking changes and resolving aliases, ensuring consistency during analysis sessions. The child module enhances this functionality by defining in-memory data structures for project configurations, supporting operations like equality checks, deep copying, and pretty-printing. Together, they enable dynamic switching of storage strategies while maintaining integrity through validation and logging.",
      "description_length": 671,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.PopTopFunctionForCallbacks",
      "library": "mthread",
      "description": "This module manages a global boolean setting that controls callback inlining behavior in multi-threaded contexts, offering functions to set, retrieve, and observe changes to the flag's state. It extends the boolean value with metadata for persistence, defaulting, and project-specific serialization, enabling fine-grained control over optimization settings. The child module enhances this functionality by providing structured data management with support for equality, comparison, and type introspection, allowing values to be copied, queried, and transformed efficiently. Together, they enable dynamic configuration of inlining behavior while ensuring data consistency and efficient manipulation of related state.",
      "description_length": 715,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer-Set-O",
      "library": "mthread",
      "description": "This module provides set operations for managing collections of `Access.t` elements, supporting standard manipulations like union, intersection, difference, and subset checks, alongside element selection, filtering, and iteration. It works with a concrete set type (`Set.O.t`) and includes utilities for conversion from lists, equality testing, hashing, and project-specific predicates (e.g., `mem_project`), as well as deep copying and integration with Frama-C's analysis framework. These capabilities are particularly useful for static analysis tasks requiring precise tracking and transformation of access states in program verification.",
      "description_length": 640,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.SetStmtIdAccess",
      "library": "mthread",
      "description": "This module implements a lattice-based abstract domain for tracking sets of statement IDs with access information in concurrent static analysis. It provides core operations like union, intersection, inclusion, and lattice primitives (join, meet, top/bottom), working with values that indicate whether accesses are dummy. The associated submodule enhances these capabilities with functional set utilities, efficient membership checks, and integration with Frama-C's analysis kernel, enabling precise reasoning about shared variable accesses across threads, including synchronization points and dummy accesses that ensure algorithm convergence. Example uses include tracking which statements access a shared variable, determining if all accesses are dummy, or combining access sets from different threads.",
      "description_length": 803,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.RecomputeReason",
      "library": "mthread",
      "description": "This module defines a type `t` representing reasons for re-computation in a multi-threaded context. It provides a `compare` function for ordering these reasons and a `pretty` function for formatted output. Concrete use cases include tracking why a thread's computation needs to restart, such as due to invalidation or dependency changes.",
      "description_length": 337,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Precise",
      "library": "mthread",
      "description": "This module analyzes shared variable accesses across threads in C programs, tracking concurrent memory zones and their interactions through precise static analysis. It identifies data races by integrating thread state transitions with control flow graph annotations, using zone maps and memory region lists to represent shared state. The child module enhances this by managing interval-bound abstract values with lattice operations, enabling precise merging and querying of value ranges during analysis. Together, they support advanced static reasoning about thread interactions, such as detecting overlapping memory accesses and verifying concurrency constraints with interval-specific precision.",
      "description_length": 697,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_options.InterruptHandlers",
      "library": "mthread",
      "description": "This module manages command-line options for interrupt handlers, combining direct operations to set, retrieve, and serialize values with project-specific defaults and alias handling. It supports thread-safe manipulation of kernel_function collections, allowing concurrent addition, iteration, and membership checks, while child modules define structured data types for configuration values, category management with named sets like `@none` and `@all`, and string-based parameter handling with validation and custom serialization. Users can configure interrupt behavior through command-line flags, manage dependencies between interrupt states, and maintain consistent handler settings across multi-threaded executions. Specific examples include enabling all interrupt categories via `@all`, defining custom handler sets with aliases, and safely modifying handler collections during runtime in concurrent environments.",
      "description_length": 916,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.IgnoreNull",
      "library": "mthread",
      "description": "This module manages a global boolean flag that controls null value handling in multi-threaded analysis workflows, offering thread-safe operations to set, observe, and serialize the flag's state. It supports dynamic enablement or suppression of null pointer behavior across concurrent threads or analysis phases, with direct APIs for toggling the flag (`on`, `off`), querying its state (`get`), and integrating with analysis lifecycle events. The child module defines a data type with rich structural operations\u2014equality, comparison, hashing, and pretty-printing\u2014tailored for representing and analyzing values tied to the `-mt-ignore-null` option, particularly in Frama-C's Mthread plugin. Together, they enable precise tracking, comparison, and persistence of null-handling behavior across different analysis contexts, such as comparing results between projects or configurations involving null pointers.",
      "description_length": 904,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.FullCfg",
      "library": "mthread",
      "description": "This module manages a boolean configuration that enables or disables full CFG analysis in Frama-C, directly affecting static analysis precision for thread interactions and control flow. It allows setting, retrieving, and tracking the state through direct calls (`on`/`off`), command-line flags, default values, and aliases, with support for serialization to maintain consistency across sessions. The child module defines a data type with operations for equality, comparison, and pretty-printing, used to represent and manipulate configuration values in the analysis context. Together, they provide precise control over CFG handling, enabling users to model and manage analysis settings with deep copying, membership testing, and value enumeration.",
      "description_length": 747,
      "index": 249,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer-ZoneMap-LOffset",
      "library": "mthread",
      "description": "This module provides operations for managing abstract values represented as intervals and zone maps, focusing on memory regions with offset tracking. It works with `ZoneMap.LOffset.t` for modeling memory zones and offset maps that associate integer intervals with arbitrary values, supporting efficient queries, joins, and structural analysis. These tools are suited for scenarios like static analysis of memory accesses or constraint propagation in program verification.",
      "description_length": 471,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types.StmtIdAccess",
      "library": "mthread",
      "description": "This module defines a type for representing full variable access operations, capturing whether the access is a read or write, the statement involved, and the thread performing the operation. It provides standard comparison, hashing, and pretty-printing for this type, along with utilities for deep copying and checking project membership. It is used to track and distinguish variable accesses in a multi-threaded analysis context.",
      "description_length": 430,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Global",
      "library": "mthread",
      "description": "This module coordinates global shared variables in concurrent analysis by tracking thread-accessed zones and computing cross-thread access patterns to detect concurrency issues. It structures memory states as hierarchical maps that link zones to value sets, supporting lattice operations, binding updates, and interval manipulations for abstract interpretation. Users can fold over memory intervals to aggregate values, update zone bindings to refine analysis, or check inclusion relations to identify subsumed states. Submodules enhance these capabilities with specialized logic for interval management, zone merging, and value set transformations, enabling precise modeling of heap abstractions and thread interactions.",
      "description_length": 721,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_memory.Types",
      "library": "mthread",
      "description": "This module provides data structures and operations for managing memory states in multithreaded analysis, centered around types like `pointer`, `state`, `value`, and `functions_states`. It enables merging state mappings, iterating over memory access requests, and retrieving function-specific memory states, while its child modules enhance pointer analysis with thread-safe storage, ordered maps, and comparator-based sets. These tools support tasks such as tracking memory across threads, modeling pointer relationships, and performing deterministic set operations during static analysis. Examples include analyzing aliasing, maintaining typed pointer metadata, and managing thread-local memory regions in concurrent programs.",
      "description_length": 727,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer-ZoneMap",
      "library": "mthread",
      "description": "This module provides lattice-based operations such as join, inclusion checks, and predicate-driven membership analysis on a domain of zone maps, which associate memory regions (represented as base pointers and offset intervals) with abstract values. It supports manipulation of these maps through union-preserving merges, overlap-aware filtering, and project-specific constraint evaluation, enabling use cases like static analysis of memory state in concurrent programs or tracking aliased memory regions with interval arithmetic. The structure includes utilities for comparing, hashing, and serializing zone maps while maintaining lattice properties.",
      "description_length": 651,
      "index": 254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.Context",
      "library": "mthread",
      "description": "This module defines a context type used to track analysis state across multi-threaded control flow graphs. It provides an empty context value for initialization and a pretty-printing function to format context instances for debugging or logging. The context is used during static analysis to manage thread-local and shared state information.",
      "description_length": 341,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars.Computer-Set",
      "library": "mthread",
      "description": "This module provides lattice-based abstract domain operations (join, meet, narrow, top/bottom elements) for static analysis alongside functional set manipulations (union, intersection, filter, fold) and element-wise transformations. It works with a parameterized set type `Set.t` whose elements are of type `Set.O.elt`, supporting both concrete set representations and a symbolic top element for abstract interpretation. Designed for scenarios like static analysis frameworks (e.g., Frama-C), it enables immutable, higher-order functional processing of sets while maintaining lattice semantics for domain-specific reasoning.",
      "description_length": 624,
      "index": 256,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Mthread.Mt_thread.OrderedThreads",
      "library": "mthread",
      "description": "This module analyzes thread creation relationships and provides operations to traverse threads based on their creation order. It builds data structures like a family tree of threads and a creation map to represent parent-child thread relationships. These structures enable ordered iteration and folding over threads following the partial order of their creation events.",
      "description_length": 369,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types.CfgNode",
      "library": "mthread",
      "description": "This module represents control flow graph nodes with multithreaded analysis capabilities, offering equality, memory management, and accessors for node kinds, statements, and successors. It supports thread-sensitive traversal and variable access tracking using specialized sets, maps, and hash tables, enabling race detection and thread-aware analysis through depth-first iterators with customizable hooks. Child modules provide thread-safe hash tables for node-value mappings with ordered iteration, deterministic traversal, and sequence operations, along with maps that support aggregation, filtering, and merging of node-associated data. Examples include tracking per-node analysis state across threads, performing deterministic passes on CFGs, and transforming metadata during concurrent static analysis.",
      "description_length": 807,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread.ThreadState",
      "library": "mthread",
      "description": "This module provides operations to inspect and compare thread state information, including checking if a thread is the main thread, retrieving its name, and determining creation relationships between threads. It works with the `thread_state` type, representing individual threads in a concurrent program. Concrete use cases include analyzing thread creation hierarchies, tracking recompute reasons for threads, and printing thread names or detailed debugging information during static analysis.",
      "description_length": 494,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options.CheckProtections",
      "library": "mthread",
      "description": "This module manages a boolean configuration flag that controls synchronization of shared memory accesses, providing state tracking, dynamic updates via hooks, and marshaling support. It centers around a custom data type that encapsulates the flag's value, default status, and computed state, with operations to set, retrieve, and observe changes, used to enforce memory access protections in concurrent analyses. The child module enhances this by defining rich data manipulation capabilities, including equality, comparison, and pretty-printing, enabling precise modeling of synchronization behavior in multi-threaded code. Together, they allow Frama-C plugins to configure and monitor runtime concurrency checks with fine-grained control and introspection.",
      "description_length": 757,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Trie",
      "library": "mthread",
      "description": "This module provides a thread-safe trie structure for concurrent key-value storage with support for arbitrary key and value types. It enables efficient prefix-based queries and hierarchical operations through its core API and submodules, which include reversed-key list storage for optimized traversal and decomposition, as well as a persistent map interface for ordered key handling with standard transformations. Users can perform insertions, lookups, and deletions while maintaining consistency under concurrent access, making it ideal for auto-complete systems or shared routing tables. Specific operations include prefix-based sub-map extraction, folding over hierarchical data, and persistent modifications with `add`, `find`, and `map` functions.",
      "description_length": 753,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes_types",
      "library": "mthread",
      "description": "This module organizes mutex access control through structured data types like `mutexes_by_access`, enabling precise tracking of read and write permissions across threads. It supports operations such as joining access states, comparing mutex sets, and mapping mutexes to memory regions, with submodules refining these capabilities through lattice structures, zone-based groupings, and interval-bound mutexes. Specific uses include static analysis tasks like merging concurrent access paths, filtering locked memory intervals, and abstractly interpreting thread-protected resources. The combination of direct access-state manipulation and advanced submodules enables both low-level concurrency control and high-level static reasoning over shared resources.",
      "description_length": 754,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_analysis_fixpoint",
      "library": "mthread",
      "description": "This module implements fixed-point analysis for thread state in concurrent programs. It provides operations to mark shared nodes, record thread analysis completion, and determine when analysis reaches a stable state. These functions operate on thread analysis states to track data flow and synchronization effects in multithreaded code.",
      "description_length": 336,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg",
      "library": "mthread",
      "description": "This module constructs and manipulates control flow graphs (CFGs) for thread analysis, providing operations to generate a CFG from thread state, remove unnecessary nodes based on variable access kinds, and visualize CFGs using DOT format. It works with CFG data structures that model thread execution paths and memory accesses, organized by nodes and edges representing program statements and transitions. Use cases include analyzing memory accesses per thread, optimizing CFGs by eliminating non-concurrent nodes, and generating graphical representations of CFGs for debugging or reporting.",
      "description_length": 591,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_types",
      "library": "mthread",
      "description": "This module defines core types for modeling thread-related events and access modes in concurrent programs, including operations for mutex interactions, memory accesses, and thread lifecycle management. It works with data structures like events, threads, mutexes, and memory slices, enabling analysis tasks such as tracking execution traces, managing synchronization primitives, and verifying thread safety. Submodules provide set operations for mutex keys and thread presence, presence tracking for generic keys, and utilities for comparing, hashing, and printing events. Specific capabilities include modeling access patterns, merging presence information across contexts, and analyzing synchronization dependencies through structured trace data.",
      "description_length": 747,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_ids",
      "library": "mthread",
      "description": "This module manages identifiers for threads, mutexes, and queues in a multi-threaded memory model. It provides functions to read, write, and replace integer values associated with these identifiers in a given memory state, as well as pretty-printing and conversion utilities. Concrete use cases include tracking and modifying thread-local storage, synchronizing access via mutex IDs, and managing message queues by ID.",
      "description_length": 418,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_outputs",
      "library": "mthread",
      "description": "This module provides utilities for visualizing thread analysis results through console and HTML output. It operates on `Mthread.Mt_thread.analysis_state` to display the final state of value analysis, showing thread dependencies, execution flow, and analysis metrics. You can print structured summaries to the console or generate HTML reports for detailed inspection of thread behavior and analysis outcomes.",
      "description_length": 407,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars_types",
      "library": "mthread",
      "description": "This module hierarchy models variable accesses in concurrent programs using abstract domains and structured data types. It organizes accesses by memory zones and tracks access patterns across threads using lattice operations such as join and meet, with support for inclusion checks and filtering. Key data types include mappings from memory zones to access data, sets of statement IDs with access information, and structured representations of variable accesses capturing read/write operations, statements, and threads. Example uses include aggregating access patterns across threads, determining overlapping zone accesses, checking if all accesses are dummy, and tracking which statements access shared variables.",
      "description_length": 714,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_thread",
      "library": "mthread",
      "description": "This module coordinates thread management and analysis by handling state transitions, execution path recomputation, and scheduling prioritization in concurrent programs. It integrates data structures for thread call stacks, mutex dependencies, and message queues with submodules that define thread priorities, re-computation reasons, creation relationships, and thread state inspection. Operations include comparing and printing priority values, tracking recompute causes like dependency changes, traversing thread families, and inspecting thread properties such as names and creation order. Use cases include verifying concurrency correctness, analyzing scheduling strategies, and debugging multi-threaded programs through structured iteration and logging.",
      "description_length": 757,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_options",
      "library": "mthread",
      "description": "This module orchestrates fine-grained control over logging, diagnostics, and analysis configuration in multi-threaded static analysis tools, centered around structured data such as log categories, warning levels, and control flow graphs. It provides boolean flags, bounded integers, string sets, and path configurations with operations to set, query, serialize, and track changes, often integrating with command-line interfaces and Frama-C's project system. Child modules enrich this functionality with typed data representations, supporting equality, comparison, pretty-printing, and deep copying, enabling use cases like suppressing null-pointer warnings, configuring thread exclusion sets, managing CFG analysis precision, and customizing callstack visibility. Together, they facilitate dynamic, project-aware configuration of analysis tools with type-safe, persistent, and thread-aware state management.",
      "description_length": 907,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_cil",
      "library": "mthread",
      "description": "This module analyzes thread synchronization in CIL code by tracking shared memory accesses and synchronization primitives across call stacks. It combines stack management with element inspection to model thread behavior, using data structures that support equality, comparison, and pretty-printing. You can identify synchronization calls, inspect stack elements for shared variable accesses, and generate error messages based on precise source positions. The module enables deep analysis of multithreaded control flow by integrating stack operations with CIL-specific traversal and data inspection utilities.",
      "description_length": 608,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_main",
      "library": "mthread",
      "description": "Registers and applies analysis hooks for thread state data during and after Mthread analysis. Works with `Mthread.Mt_thread.analysis_state` to enable custom post-processing or reporting logic. Useful for integrating analysis tools or logging thread behavior after execution.",
      "description_length": 274,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_mutexes",
      "library": "mthread",
      "description": "This module implements pretty-printing and analysis functions for mutex-based protection states in a concurrent analysis context. It handles structured data including mutex sets, thread identifiers, and location zones, with operations to format and verify protection statuses for shared variable accesses. Concrete use cases include displaying synchronization requirements between thread pairs and checking if memory zones are properly protected across thread interactions.",
      "description_length": 473,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_memory",
      "library": "mthread",
      "description": "This module provides core operations for manipulating abstract memory states, including merging, reading, and writing memory slices, pointers, and zones, with utilities for converting memory values to strings or integers and formatting memory for display. It centers around key types like `pointer`, `state`, and `value`, enabling precise modeling of memory behavior in concurrent analysis, such as tracking thread-local regions, handling pointer aliasing, and extracting C strings from memory. Its submodules enhance pointer and state management with thread-safe storage, ordered maps, and comparator-based sets, supporting deterministic set operations and efficient iteration over memory accesses. Example uses include static analysis of multithreaded programs, abstract interpretation of memory effects, and generating human-readable memory dumps during debugging.",
      "description_length": 867,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_interferences",
      "library": "mthread",
      "description": "Tracks and updates the last analysis state for threads in a concurrent program. It works with thread analysis data structures to store and retrieve the most recent state information. This is used to compare current and previous analysis results for detecting changes or stabilizing fixed-point computations during thread interference analysis.",
      "description_length": 343,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_analysis_hooks",
      "library": "mthread",
      "description": "This module defines hooks for analyzing multi-threaded C code during static analysis. It provides functions to initialize the main thread state, register built-in functions, and intercept function calls and their results during analysis. It works with thread and memory states to track concurrency-related behavior, such as thread creation, synchronization, and shared memory access. Use cases include enforcing thread safety policies and detecting race conditions during value analysis.",
      "description_length": 487,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_shared_vars",
      "library": "mthread",
      "description": "This module coordinates multithreaded analysis by tracking shared variable accesses across threads, identifying race conditions, and modeling memory zones with precise abstract values. It provides core data types like `Access.t` for access information, `ZoneMap.LOffset.t` for memory regions with offsets, and set and lattice structures for managing and merging access states. Operations include registering and analyzing concurrent accesses, computing overlapping memory zones, and applying interval-based abstract interpretation to refine value ranges during static analysis. Users can detect data races, verify concurrency constraints, and perform precise memory state transformations using structured thread states, zone maps, and lattice-preserving operations.",
      "description_length": 765,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread.Mt_lib",
      "library": "mthread",
      "description": "This module defines types and functions for polymorphic pretty-printing, including customizable format handlers and printers. It supports operations like escaping non-UTF-8 characters, sanitizing filenames, and comparing values by their internal tags. Use cases include formatting complex data structures, cleaning user-provided filenames, and implementing generic comparison logic for inductive types.",
      "description_length": 402,
      "index": 278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mthread.Mt_cfg_types",
      "library": "mthread",
      "description": "This module provides core data structures for modeling concurrency in static analysis, including types to represent control flow nodes, variable accesses, and synchronization states across threads. It defines key abstractions such as node identifiers with thread and access metadata, memory access lattices, and analysis contexts that track thread-local and shared state. Operations include lattice joins for merging access sets, presence checks for threads and mutexes, and interval-based memory tracking to support precise dataflow analysis. Example uses include detecting race conditions, validating access permissions, and performing thread-sensitive transformations on control flow graphs using node-specific state and deterministic traversal.",
      "description_length": 748,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread",
      "library": "mthread",
      "description": "This module enables comprehensive static analysis of concurrent programs by modeling thread behavior, synchronization, and memory access patterns through structured data and abstract domains. It provides key data types such as thread states, mutexes, memory zones, and access lattices, along with operations for fixed-point analysis, control flow graph manipulation, and race condition detection. Users can perform tasks like tracking shared variable accesses across threads, visualizing analysis results in HTML or console formats, and managing thread-safe data structures such as tries and mutex-controlled memory regions. Specific examples include analyzing synchronization dependencies in CIL code, optimizing CFGs by removing non-concurrent nodes, and enforcing thread safety through access pattern verification and abstract interpretation of memory effects.",
      "description_length": 863,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inout",
      "library": "frama-c-inout.core",
      "description": "This module analyzes C code elements to determine memory zones accessed or modified during execution. It provides functions to compute input and output memory zones for statements, expressions, and kernel functions, distinguishing between local and external accesses. It is used to track data dependencies and side effects in program analysis tasks.",
      "description_length": 349,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Verbose.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, along with support for deep copying and membership testing within projects. It works with a structured type `t` that includes a name, type information, descriptors, and representants. Concrete use cases include managing and manipulating abstract data representations in security slicing analyses, ensuring values can be uniquely identified, compared, and safely duplicated.",
      "description_length": 473,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Debug.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values used in security slicing. It supports structured data with descriptors, equality, comparison, hashing, and pretty-printing, enabling precise handling of security-related parameters. Use cases include tracking and analyzing data flow in security-critical code sections, particularly for debugging and verification purposes.",
      "description_length": 423,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Slicing.Datatype",
      "library": "frama-c-security_slicing.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating abstract data structures used in security slicing analysis. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, along with utilities to inspect and filter project-related data within slicing parameters. The module works with structured descriptors, project skeletons, and lists of data type representatives, enabling precise tracking and transformation of security-sensitive data during static analysis.",
      "description_length": 546,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Cache_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages a cache directory path for a plugin, providing operations to set, retrieve, and check the directory status, as well as obtain file and directory paths within it. It works with `Frama_c_kernel.Filepath.t` to represent filesystem paths and supports conditional path creation. Concrete use cases include storing and accessing cached analysis results or temporary files in a structured directory specific to the plugin.",
      "description_length": 435,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Config_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages file and directory paths for a plugin's configuration, providing operations to retrieve, set, and check the existence of a user-specific directory. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, supporting optional path creation. Concrete use cases include initializing plugin-specific storage locations and accessing configuration files during analysis.",
      "description_length": 399,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Verbose",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages an integer verbosity level with dynamic registration, supporting pre/post-update hooks, command-line integration, and range constraints, while its child module enhances it with structured value handling. The core functionality centers on an internal integer state enriched with metadata for bounds, defaults, and serialization, alongside a structured type `t` for representing named, typed values with comparison, copying, and membership operations. You can set verbosity levels with constraints, register callbacks for updates, and integrate with command-line flags, while also manipulating structured data representations for security slicing analyses. Together, they enable fine-grained logging control and robust handling of abstract data values within projects.",
      "description_length": 786,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Session",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages session-specific directories and files within a security slicing context. It provides operations to retrieve or create directories and files, set and query a user directory path, and check if a user directory has been set. Concrete use cases include organizing per-session data storage, managing configuration files, or handling temporary files specific to a security analysis session.",
      "description_length": 405,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Debug",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages integer configuration parameters for dynamic debugging in program analysis tools, providing operations for bounded value manipulation, update hooks, and command-line integration. It maintains a centralized registry of state variables constrained by min/max ranges, enabling use cases like adjusting debug verbosity and enforcing valid configuration ranges during security analysis. The child module enhances this functionality by introducing structured data types with comparison, hashing, and pretty-printing capabilities, specifically supporting precise handling of security-related parameters. Together, they allow developers to track data flow, register callbacks for parameter changes, and ensure robust configuration management in security-critical contexts.",
      "description_length": 784,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.State_dir",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages a plugin-specific state directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the state directory structure. Concrete use cases include storing and retrieving plugin-generated files or configuration data in a structured, predictable location.",
      "description_length": 411,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Share",
      "library": "frama-c-security_slicing.core",
      "description": "This module manages the configuration and retrieval of a specific directory used for sharing files in the security slicing plugin. It provides functions to set, check, and retrieve the directory path, as well as to locate specific files or subdirectories within it. Use cases include loading plugin-specific resources or configuration files from a predefined structure.",
      "description_length": 369,
      "index": 291,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters.Slicing",
      "library": "frama-c-security_slicing.core",
      "description": "This module represents and manipulates abstract data structures for security slicing analysis. It defines the core data type `t` with operations for equality, comparison, hashing, pretty-printing, and deep copying, while supporting inspection and filtering of project-related data through structured descriptors and project skeletons. Submodules extend its capabilities to handle data type representatives and transform security-sensitive elements during static analysis. Example uses include tracking data flows and extracting slices based on security policies.",
      "description_length": 562,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing.Components",
      "library": "frama-c-security_slicing.core",
      "description": "This module provides operations to analyze and retrieve code components related to security slicing. It works with statements (`stmt`) and kernel functions (`Kernel_function`) from the Frama-C CIL framework. Functions identify direct, indirect backward, and forward components of code, and perform impact analysis to trace effects of changes in code on security slices.",
      "description_length": 369,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing.Security_slicing_parameters",
      "library": "frama-c-security_slicing.core",
      "description": "This module orchestrates security slicing workflows through structured diagnostics, configurable state management, and path handling. It combines logging, warning control, and command-line configuration with submodules that manage cache and state directories, session-specific files, verbosity levels, and integer parameters, all working with typed paths and structured data. You can customize error reporting, control output verbosity with range constraints and update hooks, and manage plugin-specific directories for caching, configuration, and session data. Submodules enable precise handling of filesystem paths, dynamic parameters, and abstract data structures essential for security analysis tasks like tracking data flows and extracting slices.",
      "description_length": 752,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing",
      "library": "frama-c-security_slicing.core",
      "description": "This module enables security slicing by analyzing code components and orchestrating workflows with structured diagnostics and state management. It operates on statements and kernel functions to identify backward, forward, and direct code impacts, supporting precise tracing of security-related changes. It provides configurable logging, path handling, and cache management, allowing customization of error reporting, verbosity control, and session-specific data storage. Examples include tracking data flows through code changes, extracting security slices with impact analysis, and managing plugin directories for caching and configuration.",
      "description_length": 641,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiSource",
      "library": "frama-c-wp.gui",
      "description": "This module manages source code selections in a GUI context, supporting operations to set and retrieve selected elements such as functions, properties, or calls. It works with structured source code representations including kernel functions, properties, and call data. Concrete use cases include tracking user selections in a graphical interface for static analysis tools, enabling context-sensitive actions based on the selected source element.",
      "description_length": 446,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp_gui.GuiTactic",
      "library": "frama-c-wp.gui",
      "description": "This module defines types for callbacks used in GUI-driven tactic automation. It works with proof strategies and heuristics from the Wp module, specifically handling user-triggered tactic application. Concrete use cases include integrating interactive proof assistant features into a graphical interface, where users can trigger automated tactic execution with customizable depth, width, and heuristic selection.",
      "description_length": 412,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiNavigator",
      "library": "frama-c-wp.gui",
      "description": "Creates a navigator interface within the Frama-C GUI, integrating with the main window's extension points. It initializes and manages the navigation components for interacting with analysis results. Useful for building custom navigation tools in Frama-C plugins.",
      "description_length": 262,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiPanel",
      "library": "frama-c-wp.gui",
      "description": "This module manages dynamic updates and event handling for a graphical interface panel. It provides functions to trigger and subscribe to update and reload events, as well as to register configuration actions and execute proof tasks with specific prover settings. It works with GUI extension points, prover configurations, and source selections to support interactive verification workflows.",
      "description_length": 391,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui.GuiProver",
      "library": "frama-c-wp.gui",
      "description": "Defines status icons for prover outcomes and provides a filtering function for VCS provers. Uses Frama_c_gui.Widget.icon values like no_status, ok_status, and ko_status to represent visual states in a GUI. The filter function selects provers based on their status, enabling dynamic display or processing of prover results in a verification interface.",
      "description_length": 350,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp_gui",
      "library": "frama-c-wp.gui",
      "description": "This module provides a graphical interface for managing source code selections, tactic automation, and dynamic updates in a verification tool. It supports structured interaction with source elements, customizable tactic execution, and real-time GUI synchronization through events and status indicators. Key features include tracking user selections, integrating proof strategies, handling prover status icons, and managing navigation components. Examples include triggering proof tasks with specific configurations, filtering provers by outcome, and building custom analysis panels with live updates.",
      "description_length": 600,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report_eva_info.Eva_info",
      "library": "markdown_report_eva_info",
      "description": "This module populates the functions required by `Md_gen.Eva_info` to generate Markdown reports specific to Eva analysis. It operates on data structures related to Eva's abstract domains, such as intervals, congruences, and value approximations. It is used to produce human-readable summaries of Eva's results directly within Frama-C's Markdown output.",
      "description_length": 351,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report_eva_info",
      "library": "markdown_report_eva_info",
      "description": "This module implements Eva-specific Markdown report generation by translating abstract domain data\u2014like intervals, congruences, and value approximations\u2014into structured, human-readable output. It defines functions that format and summarize Eva analysis results directly into Frama-C's Markdown reports. For example, it can render interval bounds or congruence relations in a readable table format, making analysis outcomes accessible to users without requiring inspection of raw abstract values.",
      "description_length": 495,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps over expressions in the Eva AST, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types involving Frama-C projects, enabling checks and transformations on expression keys with functions like `mem_project` and `copy`. Concrete use cases include managing expression-specific metadata during analysis configuration and tracking expression identities across program points.",
      "description_length": 464,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type for keys used in a hash table that maps offsets to values during the Eva analysis. It supports operations like equality checking, comparison, hashing, and pretty-printing for these keys, which are essential for managing and querying analysis results. The keys include project-specific information, enabling filtering based on project context and ensuring deep copies to avoid shared state.",
      "description_length": 421,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map indexed by `Offset` values with data of type `Data.t`. It provides standard map operations including comparison, equality, hashing, pretty printing, and deep copying, along with type descriptors for integration with Frama-C's kernel. It is used to represent and manipulate mappings tied to specific program offsets, such as associating analysis results with precise locations in the AST.",
      "description_length": 413,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map indexed by lvalues, where the values are of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with project-aware membership checks and deep copying. It is used to track and manipulate lvalue-associated data during static analysis, such as abstract values or annotations tied to specific memory locations.",
      "description_length": 405,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for lvalues annotated with data values, supporting operations like equality, comparison, hashing, and pretty-printing. It works with lvalues from the Eva AST and user-defined data types provided via the `Data` parameter. It is used to track and manipulate lvalue-to-data mappings during static analysis, such as associating memory locations with their computed values.",
      "description_length": 416,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with deep copying, project membership checks, and type descriptors for integration with Frama-C's kernel. Use cases include storing and retrieving analysis-specific data indexed by lvalue hosts during static analysis.",
      "description_length": 420,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map indexed by constants, where the values are of a specified data type. It supports standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate mappings from constants to typed values in a way that supports analysis configuration and result representation.",
      "description_length": 400,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines the key type used in maps over Lhost values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with functions for deep copying, membership testing over projects, and type descriptors for integration with Frama-C's kernel. Concrete use cases include tracking and comparing Lhost identifiers during Eva analysis configuration and result processing.",
      "description_length": 442,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for use in a hash table that stores Eva AST constants. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, which are essential for efficient lookup and management of constant values during analysis. The keys include metadata such as type, name, and descriptors, and support deep copying and project membership checks for use in analysis configurations and result tracking.",
      "description_length": 455,
      "index": 312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table indexed by offsets, where values are of a specified data type. It supports standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to represent and manipulate mappings from offsets to values in a structured and type-safe manner.",
      "description_length": 356,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a map data structure keyed by `Lhost` values, where the associated data type is specified by the `Data` parameter. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate mappings from l-values to custom data during static analysis, such as tracking memory states or analysis metadata.",
      "description_length": 444,
      "index": 314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps that store Eva AST constants, providing essential operations like equality, comparison, hashing, and pretty-printing. It supports structured data types with descriptors and representants, enabling precise handling of typed values in analyses. Use cases include managing and comparing symbolic constants during static analysis, particularly for tracking and resolving expressions in program points.",
      "description_length": 437,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports efficient lookups, insertions, and traversals over keys of type `Eva.Eva_ast.Constant.t`. This structure is used to map abstract values to analysis-specific constants during Eva's value analysis.",
      "description_length": 376,
      "index": 316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a hash table key type for Eva's abstract syntax tree lvalues, providing equality, comparison, hashing, and pretty-printing operations. It supports efficient key-based lookups and storage in hash tables, specifically for lvalue identifiers during analysis. Use cases include tracking memory locations and expression values uniquely across program points.",
      "description_length": 373,
      "index": 317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a hash table key type for Eva's abstract syntax tree expressions, providing standard operations like equality, comparison, and hashing. It supports data types involving project-specific values, enabling efficient lookups and storage in hash tables. Concrete use cases include tracking expression properties across analysis passes and caching evaluation results keyed by AST nodes.",
      "description_length": 400,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps that represent lvalues in the Eva analysis. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, which are essential for managing and querying lvalue-based data during analysis. The keys include support for project membership checks and deep copying, enabling precise and isolated manipulation of analysis states tied to specific program points.",
      "description_length": 436,
      "index": 319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for use in a hash table that maps lhost values to other data within the Eva analysis framework. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, as well as deep copying and project membership checks. It is used to uniquely identify and manage lhost-based keys in data structures that require stable and efficient lookups during static analysis.",
      "description_length": 435,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table indexed by Eva expressions, where values are of a specified `Data` module type. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is typically used to map expressions to analysis-specific metadata or results, such as abstract values or annotations, during static analysis.",
      "description_length": 416,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map indexed by expressions, where the values are of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to associate expression keys with analysis data, enabling precise tracking and manipulation of expression-related values during static analysis.",
      "description_length": 409,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a key type for maps in the Eva AST, providing equality, comparison, hashing, and pretty-printing operations. It supports structured data keys with project membership checks and deep copying, ensuring unique identification and safe manipulation of map entries. Use cases include managing and querying symbolic offsets in Eva's abstract syntax tree during analysis configuration and result interpretation.",
      "description_length": 423,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Set",
      "library": "frama-c-eva.core",
      "description": "This module enables efficient management and querying of collections of abstract syntax tree offsets through ordered set operations, supporting transformations like mapping and filtering, structural queries for element proximity, and conversions to ordered sequences or lists. It works with sets of `Eva.Eva_ast.Offset.t` elements, leveraging their ordered nature for tasks like tracking analysis-relevant program points or aggregating offsets during constraint propagation. Specific capabilities include project-specific membership checks, reverse-order traversal, and deep copying, which facilitate precise static analysis of memory states and value dependencies.",
      "description_length": 665,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Set",
      "library": "frama-c-eva.core",
      "description": "This module supports manipulation of sets of lvalues (represented as `Lhost.t` elements) through standard functional set operations like union, intersection, and difference, along with transformations such as filtering, mapping, and partitioning. It provides efficient membership checks, ordered iteration, and conversions to/from lists and sequences, leveraging the inherent ordering of elements for optimized search operations. These capabilities are particularly useful in static analysis scenarios for tracking memory locations, managing analysis results, or performing set-based computations over program entities like variables or expressions.",
      "description_length": 649,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Set",
      "library": "frama-c-eva.core",
      "description": "This module offers operations for creating, transforming, and querying ordered sets of expressions (`Exp.t`), including union, intersection, filtering, and mapping. It supports efficient membership checks, ordered iteration, and conversions to lists or sequences, leveraging comparison and hashing functions for set integrity. These capabilities are used when analyzing or manipulating abstract syntax trees to track expression relationships, manage data flow dependencies, or implement domain-specific constraints during static analysis.",
      "description_length": 538,
      "index": 326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides a specialized hash table for efficient key-value storage and manipulation, where keys are program variable identifiers (`Lhost.t`) and values are analysis-specific data (`Data.t`). It supports imperative operations like insertion, lookup, and removal, as well as functional transformations including ordered traversal, value filtering, and comparison-driven iteration, enabling tasks like state tracking and memory mapping during static analysis. The key module defines operations for lhost-based keys, including equality, hashing, and pretty-printing, while the value module extends these capabilities with deep copying, type descriptors, and project membership checks. Together, they facilitate structured data management in analysis plugins, such as Eva, where stable and efficient lookups are critical.",
      "description_length": 827,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Map.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with values of type `Eva.Callstack.Map.key`, which are used to uniquely identify and manage entries in a map, particularly in the context of analysis state tracking. The module also includes functionality for checking membership based on project predicates and performing deep copies of key values.",
      "description_length": 461,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Map",
      "library": "frama-c-eva.core",
      "description": "This module manages key-value associations where keys represent offsets in an abstract syntax tree, supporting ordered traversal, merging with conflict resolution, and min/max extraction. It provides direct operations for map manipulation and conversion to lists or sequences, while its submodules define specialized key types and typed maps for structured analysis data. The key module enables precise identification and manipulation of AST-associated entries, and the typed map module stores analysis results like memory states or expression values at specific program points. Together, they facilitate configuration, aggregation, and querying of static analysis metadata across program locations.",
      "description_length": 699,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Hashtbl.Key",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type for keys used in a hash table that tracks call stack information during static analysis. It provides standard operations such as equality checking, comparison, hashing, and pretty printing for these keys, along with deep copying and project membership testing. These keys are used to uniquely identify and manage call stack states within the analysis framework.",
      "description_length": 393,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Set",
      "library": "frama-c-eva.core",
      "description": "This module offers a functional set interface for managing collections of lvalues (memory locations) in Eva's abstract syntax tree, supporting operations like union, intersection, filtering, and ordered traversal. It works with immutable sets of `Eva.Eva_ast.Lval.t` values, leveraging comparison logic tied to Frama-C's kernel structures for static analysis tasks such as tracking memory state during program analysis. Specific use cases include analyzing variable references in dataflow analysis, managing aliased memory locations, and transforming sets of lvalues during abstract interpretation steps.",
      "description_length": 604,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides imperative hash tables for mapping lvalues from the Eva AST to arbitrary values, supporting efficient lookups, in-place updates, and ordered iteration. It includes operations for filtering, memoization, and sequence-based modifications, making it suitable for tracking dynamic analysis state such as variable bindings or memory footprints. The child modules specialize these capabilities by defining key operations for lvalues and enabling annotated data storage with customizable equality, comparison, and printing. For example, it can associate memory locations with computed values during static analysis or maintain evolving state across program points.",
      "description_length": 678,
      "index": 332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides imperative hash tables optimized for keys representing abstract memory offsets, enabling in-place updates, ordered traversal, and safe value retrieval through customizable comparisons. It supports key-value mappings where keys carry project-specific context and values can be arbitrary data, facilitating precise tracking of memory locations or expression values during static analysis. The module includes operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks, ensuring structured and type-safe manipulation of offset-based mappings. Example uses include maintaining analysis state across program points or aggregating expression evaluations tied to specific memory offsets.",
      "description_length": 763,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Set",
      "library": "frama-c-eva.core",
      "description": "This module implements set operations for constants in Eva's abstract syntax tree, enabling manipulation (union, intersection, filtering), ordered iteration, and transformations (mapping, partitioning) over collections of `Eva.Eva_ast.Constant.t` values. It provides utilities for converting between sets and sequences, identifying nearest elements relative to a value, and pretty-printing, which are particularly useful during static analysis for tasks like tracking constant expressions, optimizing redundant computations, or verifying value constraints at program points.",
      "description_length": 574,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns.Memory.LOffset",
      "library": "frama-c-eva.core",
      "description": "This module offers functions to manipulate and analyze intervals representing memory offsets, including lattice operations such as `join` and `meet`, equality checks, and interval-based value mappings. It operates on two primary",
      "description_length": 228,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lhost.Map",
      "library": "frama-c-eva.core",
      "description": "This module manages ordered maps keyed by `Lhost` values, supporting functional updates, ordered traversal, and transformations like filtering and merging. It provides operations for converting maps to and from lists, applying predicates, and managing relationships between program elements and analysis data such as variable scopes or memory states. The key module defines `Lhost` comparison, hashing, and printing, enabling structured identity tracking and comparison during analysis. The data module supports parameterized value types, allowing maps to store and manipulate custom analysis metadata tied to l-values.",
      "description_length": 619,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module provides imperative hash tables for mapping Eva AST constants to arbitrary values, supporting efficient lookups, in-place updates, and bulk operations. It enables ordered traversal, comparison, and initialization from sequences, with keys that include metadata like type and name, and values specialized through a dedicated sub-module for `Data.t`. Examples include caching analysis results for specific constants, mapping abstract values during Eva's value analysis, and maintaining structured state across analysis passes. The module integrates key operations for both direct use and composition with submodules handling specific data types.",
      "description_length": 655,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant.Map",
      "library": "frama-c-eva.core",
      "description": "This module organizes mappings from constants to typed values, supporting operations like comparison, equality, and hashing, with deep copying and project-aware membership checks. Its key module specializes in handling Eva AST constants, offering structured representations with descriptors and operations for symbolic analysis. Together, they enable precise tracking and resolution of expressions during static analysis, such as managing typed values at program points or comparing symbolic constants across analysis states. Specific uses include configuring analysis parameters and representing results with typed, persistent maps.",
      "description_length": 633,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This component provides imperative hash tables tailored for static analysis tasks involving Eva abstract syntax tree expressions as keys, enabling efficient insertion, lookup, and traversal while preserving key order. It supports mapping expressions to arbitrary metadata, such as computed values or memory locations, with operations for transformation and structured comparison integrated with Frama-C's type system. The key module defines equality, hashing, and comparison for expression-based keys, while the data module extends this with typed storage, pretty-printing, and project-aware operations. Examples include memoizing expression evaluations, associating lvalues with memory locations, and caching analysis results across passes.",
      "description_length": 741,
      "index": 339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Map.Make",
      "library": "frama-c-eva.core",
      "description": "This module creates a map data structure specialized for values of a given type, supporting operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module parameter, organizing them into a map keyed by callstack information. It is used to track and compare analysis data across different program points, enabling precise memory and value analysis in the Eva engine.",
      "description_length": 428,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval.Map",
      "library": "frama-c-eva.core",
      "description": "This module manages associative structures keyed on program memory locations, enabling efficient insertion, deletion, and functional combination of maps for static analysis tasks. It supports operations like conditional updates, ordered iteration, and filtering, with customizable pretty-printing for structured inspection. Submodules provide specialized map instances with project-aware equality, hashing, and deep copying, while also defining key types with comparison and membership checks for precise analysis state manipulation. Examples include tracking variable properties across program points or aggregating abstract values tied to memory locations.",
      "description_length": 658,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Exp.Map",
      "library": "frama-c-eva.core",
      "description": "This module implements an ordered map structure for associating expressions with generic values, supporting insertion, deletion, merging with custom logic, ordered traversal, and efficient retrieval of extremal bindings. It enables tracking expression-centric data during program analysis, such as aggregating evaluation results or maintaining context-sensitive mappings, with operations for filtering, transforming, and iterating over subsets of expressions. The key module defines expression types with equality, comparison, and project-aware operations, enabling identity tracking and metadata management across program points. The indexed map module associates these expression keys with arbitrary data types, providing deep copying, project-aware membership checks, and standard map operations for precise manipulation of analysis data during static evaluation.",
      "description_length": 866,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Hashtbl.Make",
      "library": "frama-c-eva.core",
      "description": "This module implements a hash table indexed by callstacks, where values are of a given data type. It supports operations for equality checking, comparison, hashing, pretty-printing, and deep copying of the hash table, as well as checking membership based on project skeletons. It is used to store and query analysis data specific to different callstacks during Eva's execution.",
      "description_length": 377,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Offset",
      "library": "frama-c-eva.core",
      "description": "This module defines an abstract data type `t` representing offsets in the abstract syntax tree, with operations for equality, comparison, hashing, and pretty printing, enabling precise tracking of positions such as field offsets or array indices. It supports direct manipulation of offset values through deep copying, structural inspection, and project-specific membership testing, facilitating static analysis of memory states and value dependencies. Submodules extend this foundation with ordered sets for efficient offset collections, maps for key-value associations with conflict resolution and typed storage, and imperative hash tables for in-place updates and safe value retrieval. These components together enable structured analysis of program points, constraint propagation, and aggregation of analysis metadata across projects.",
      "description_length": 837,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.MakeDepsOf",
      "library": "frama-c-eva.core",
      "description": "This module computes memory dependencies and zones for expressions and lvalues based on a given location function. It operates on the Eva abstract syntax tree, using types like `exp_node`, `lhost`, and `offset` to determine dependencies for specific program elements. Concrete use cases include tracking which memory zones influence the value of an expression or determining the dependencies of pointer dereferences and lvalue accesses during static analysis.",
      "description_length": 459,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Hashtbl",
      "library": "frama-c-eva.core",
      "description": "This module manages efficient mappings from program callstacks to arbitrary values, enabling operations like insertion, lookup, in-place updates, and ordered traversal. It supports polymorphic values and provides deterministic processing of callstack-associated data, such as tracking memory states or aggregating analysis results across execution paths. The key module defines callstack identifiers with equality, comparison, hashing, and pretty-printing, while the value module implements hash tables indexed by these keys, supporting deep copying, membership checks, and project-specific analysis. Example uses include memoizing abstract interpretation results and maintaining per-callstack state during Eva's execution.",
      "description_length": 723,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Callstack.Call",
      "library": "frama-c-eva.core",
      "description": "This module defines a data type representing call sites in the analysis, supporting operations for equality, comparison, hashing, and pretty-printing. It includes functions for deep copying values, checking membership based on project information, and managing type descriptors for serialization and representation. It is used to track and manipulate call contexts during static analysis, enabling precise handling of function calls and their associated states.",
      "description_length": 461,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Lval",
      "library": "frama-c-eva.core",
      "description": "This module represents and manipulates lvalues from the Eva abstract syntax tree, offering core operations for comparison, hashing, copying, and pretty-printing. It includes set, map, and hash table utilities tailored for static analysis tasks such as tracking memory state, managing aliased locations, and associating values with program variables. The set module supports functional manipulation of lvalue collections with union and filtering, while the hash table and map modules provide efficient, ordered, and annotated storage for evolving analysis state. Examples include tracking variable references during dataflow analysis, memoizing computed values, and aggregating abstract memory properties across program points.",
      "description_length": 726,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Build",
      "library": "frama-c-eva.core",
      "description": "This module constructs expressions and lvalues for the Eva analysis, providing functions to create constants, perform arithmetic and comparison operations, and build memory accesses, variable references, and type casts. It operates on abstract syntax tree nodes representing expressions and lvalues, using types from the Eva AST. Concrete use cases include building symbolic expressions for analysis configuration, constructing constraints, and representing program values during abstract interpretation.",
      "description_length": 504,
      "index": 349,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.DepsOfInput",
      "library": "frama-c-eva.core",
      "description": "This module defines the dependencies of an input in the Eva analysis by specifying how to enumerate valid memory bits for a given location. It operates on abstract locations and access information, producing zones that represent valid memory regions. A concrete use case is determining which parts of a memory location are relevant for analysis when evaluating expressions or tracking value flows.",
      "description_length": 397,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Constant",
      "library": "frama-c-eva.core",
      "description": "This module organizes constants used in Eva analysis, defining their structure, equality, comparison, and pretty-printing, along with utilities for project membership and deep copying. It supports manipulation of constant sets through operations like union, intersection, and mapping, enables efficient constant-to-value lookups via hash tables, and provides typed mappings for symbolic analysis. You can track constant expressions, optimize redundant computations, cache analysis results, compare symbolic values across states, and manage typed values at program points. These capabilities integrate with submodules to support both imperative and functional workflows in static analysis tasks.",
      "description_length": 694,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack.Map",
      "library": "frama-c-eva.core",
      "description": "This module implements associative maps with callstack keys and polymorphic values, enabling efficient lookups, ordered traversals, and structural transformations. It supports key-based updates, ordered iteration, and conversion to sequences or lists, optimized for static analysis tasks like tracking expression values or memory states across callstack contexts. The key module provides operations for equality, comparison, and pretty-printing on callstack keys, while the value module specializes maps for specific data types, enabling precise analysis and comparison of program states. Examples include associating memory states with callstacks, merging analysis results across contexts, and filtering entries based on project-specific predicates.",
      "description_length": 750,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Exp",
      "library": "frama-c-eva.core",
      "description": "This module represents expressions in the Eva syntax tree with a core type `t`, supporting equality, comparison, hashing, and pretty printing, along with introspection and serialization through type information and descriptors. Its submodules provide ordered sets for expression relationships and data flow analysis, imperative hash tables for memoization and metadata association, and ordered maps for context-sensitive data tracking during static analysis. Operations include deep copying, filtering, mapping, and efficient membership checks, enabling tasks like constraint solving, lvalue-to-location mapping, and analysis result caching. Specific use cases include managing expression dependencies, aggregating evaluation results, and maintaining ordered, project-aware mappings between expressions and analysis data.",
      "description_length": 821,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_perf.StatByCallstack",
      "library": "frama-c-eva.core",
      "description": "Tracks performance statistics for each analyzed callstack during the Eva analysis. It provides operations to retrieve statistics for specific callstacks, iterate over all callstack statistics, and register hooks to monitor changes in statistics. This module is used to analyze the computational cost of different call paths and optimize the Eva analysis efficiency.",
      "description_length": 365,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Lhost",
      "library": "frama-c-eva.core",
      "description": "This module represents l-values with a data type `t` that supports equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and project-specific data handling. It integrates standard collection interfaces\u2014`Set`, `Map`, and `Hashtbl`\u2014to manage sets, mappings, and hash tables of l-values, enabling efficient membership checks, ordered traversal, and functional transformations like filtering and merging. These collections are used to track memory locations, manage analysis state, and perform set-based computations in static analysis. Submodules enhance these capabilities with specialized operations for lvalue sets, key-value storage with project-aware data, and ordered maps supporting custom metadata tied to program elements.",
      "description_length": 764,
      "index": 355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.PreciseDepsOf",
      "library": "frama-c-eva.core",
      "description": "This module computes memory dependencies and zones for expressions and lvalues based on precise locations. It provides functions to determine the memory zone of an expression or lvalue, as well as their indirect dependencies, using a given location mapping function. These operations are used during analysis to track how expressions and lvalues interact with memory, enabling precise tracking of data dependencies in the program.",
      "description_length": 430,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.DepsOf",
      "library": "frama-c-eva.core",
      "description": "This module computes memory dependencies and zones for expressions and lvalues in the AST based on a provided location function. It operates on `exp_node` and `lhost * offset` tagged structures, producing memory zones and dependency sets. It is used during analysis to determine which memory locations affect the value of expressions or lvalues, particularly when handling pointers and structured data.",
      "description_length": 402,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns.Memory",
      "library": "frama-c-eva.core",
      "description": "This module manages memory states through interval-based representations, combining direct operations for merging regions, filtering bases, and handling top/bottom states with submodules that provide lattice operations, interval equality checks, and value mappings over offsets. It supports static analysis tasks like tracking memory evolution, merging divergent paths in abstract interpretation, and optimizing cache-aware verification by leveraging precise location tracking and interval arithmetic. Key data types include intervals, bases, and `precise_location`, while operations enable joining memory states, filtering by address ranges, and mapping values across offset intervals. Example uses include merging memory snapshots from different execution paths and analyzing memory access patterns in low-level code.",
      "description_length": 819,
      "index": 358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_ast.Fold",
      "library": "frama-c-eva.core",
      "description": "This module provides functions to traverse and accumulate values over expressions and lvalues in the Eva abstract syntax tree. It works with `exp_node` and `lhost * offset` tagged structures, using a folder type to maintain state during traversal. Concrete use cases include analyzing expression structure, collecting variables, or computing properties across AST nodes during static analysis.",
      "description_length": 393,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Assigns.DepsOrUnassigned",
      "library": "frama-c-eva.core",
      "description": "This module tracks whether memory locations have been assigned and their dependency information during analysis. It provides operations to compare assignment states, check if a location may be unassigned, and convert the state to a memory zone representation. It is used to determine the initialization status of variables and their dependencies in the program's memory model.",
      "description_length": 376,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast.Rewrite",
      "library": "frama-c-eva.core",
      "description": "This module provides functions to transform abstract syntax tree (AST) nodes used in Eva's analysis, including expressions, lvalues, variable information, and offsets. It supports rewriting operations through customizable visitors and rewriters, enabling precise modifications to AST elements during static analysis. Concrete use cases include adjusting expressions for value tracking, modifying lvalue references for memory analysis, and transforming variable metadata to align with analysis requirements.",
      "description_length": 506,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Logic_inout",
      "library": "frama-c-eva.core",
      "description": "This module evaluates logic dependencies and memory zones for predicates and assigns clauses in the context of static analysis. It processes `predicate`, `assigns`, and lvalue terms using `Cvalue.Model.t` states and returns memory zones or validation results, handling both under- and over-approximations. It is used by the Inout and From plugins to verify function contracts and analyze memory effects during analysis setup.",
      "description_length": 425,
      "index": 362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eva_perf",
      "library": "frama-c-eva.core",
      "description": "This module tracks performance metrics for functions and callstacks during analysis, measuring time and call counts to identify bottlenecks. It provides data types for function identifiers and timing statistics, supporting operations to retrieve self and total durations, and to register hooks for monitoring changes. The callstack submodule enables inspecting computational costs across different call paths, allowing iteration over all callstack statistics or querying specific ones. Together, they enable precise performance profiling of analysis runs, such as finding the most expensive functions or tracing time consumption through call relationships.",
      "description_length": 656,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_annotations",
      "library": "frama-c-eva.core",
      "description": "This module registers local annotations to guide the Eva analysis, such as slevel limits, loop unrolling, value partitioning, and state splitting or merging based on expressions or predicates. It operates on CIL statements and terms, allowing precise control over analysis precision and behavior at specific program points. Use cases include improving analysis accuracy on critical code sections, limiting state explosion, or enforcing specific memory allocation strategies.",
      "description_length": 474,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Cvalue_callbacks",
      "library": "frama-c-eva.core",
      "description": "This module allows registering hooks to execute custom logic during the Eva analysis at the start and end of function calls, providing access to the cvalue domain's state. It works with analysis states, function call contexts, and structured results capturing pre- and post-call states. Concrete use cases include inspecting or modifying cvalue states before and after function executions, tracking call-specific data, and handling builtins or specifications differently from standard function bodies.",
      "description_length": 501,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Analysis",
      "library": "frama-c-eva.core",
      "description": "This module controls the execution and lifecycle of the analysis, managing computation states and hooks. It provides functions to trigger analysis, check completion, and register callbacks for state changes. It works with functions and computation states to track progress and handle events during analysis. Use it to start analysis, monitor status, or react to state transitions such as completion or abortion.",
      "description_length": 411,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Eva_ast",
      "library": "frama-c-eva.core",
      "description": "The Eva AST module centers on the manipulation and semantic analysis of abstract syntax trees for static analysis tasks, handling expressions, lvalues, and constants in both Eva's internal tagged format and CIL representations. It supports structural transformations, normalization, and dependency tracking through core data types like `exp_node`, `lhost`, `offset`, and `t` for constants, enabling semantic checks, bitfield detection, and AST rewriting. Child modules extend this foundation with specialized utilities: offset modules manage positional data for memory analysis, expression and lvalue modules provide construction, comparison, and collection interfaces for tracking variables and memory states, and transformation modules enable AST rewriting and traversal for dependency analysis. Use cases include building symbolic expressions, tracking memory zones, aggregating analysis metadata, and rewriting lvalues for precise dataflow computation.",
      "description_length": 956,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Deps",
      "library": "frama-c-eva.core",
      "description": "This module provides operations for managing memory dependencies in program expressions by tracking sets of memory zones, including direct and indirect accesses. It supports set-like manipulations such as union, intersection, and inclusion checks through a structured data type that enables comparison and transformation of dependency regions. These features are essential for analyzing memory interactions during static analysis, such as determining the memory locations affected by expression evaluations.",
      "description_length": 507,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Results",
      "library": "frama-c-eva.core",
      "description": "This module enables querying and evaluating static analysis results through location-based inspections (e.g., at program points) and callstack-aware computations, with support for converting outcomes into OCaml primitives or abstract domains. It operates on CIL-derived data like statements, expressions, and memory models, facilitating tasks such as expression value recovery, memory dependency checks, and taint analysis. Specific applications include analyzing function call relationships, extracting runtime approximations of variables, and validating memory state properties like initialization or reachability.",
      "description_length": 616,
      "index": 369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Eval",
      "library": "frama-c-eva.core",
      "description": "The module evaluates expressions and statements during static analysis, handling value propagation and memory state updates. It operates on abstract syntax trees and program states, using domains like `Cvalue` to represent computed values. Concrete use cases include resolving variable values at specific program points and tracking memory locations for lvalues during analysis.",
      "description_length": 378,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Assigns",
      "library": "frama-c-eva.core",
      "description": "This module tracks dependencies and memory modifications for function return values and memory zones, integrating memory state management and assignment tracking into a unified framework for static analysis. It supports operations to compare, hash, and pretty-print dependency data, along with deep copying, joining, and checking presence of specific projects, while its submodules handle interval-based memory representations and assignment state analysis. Key data types include intervals, bases, precise locations, and assignment statuses, enabling tasks such as merging memory snapshots from divergent execution paths, analyzing memory access patterns, and determining variable initialization status. Example uses include tracking memory evolution during abstract interpretation, optimizing cache-aware verification, and verifying correctness of low-level memory operations.",
      "description_length": 878,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Parameters",
      "library": "frama-c-eva.core",
      "description": "This module configures the analysis by enabling abstract domains, associating builtins with function calls, and applying value partitioning to global variables. It operates on analysis parameters through functions that modify how functions and global variables are interpreted during abstract interpretation. Concrete use cases include optimizing analysis precision by selecting specific domains, overriding function behavior with builtins, and refining global variable handling through partitioning.",
      "description_length": 500,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Export",
      "library": "frama-c-eva.core",
      "description": "This module generates logical predicates that characterize the possible values of C variables or expressions at specific program points. It provides functions to export these predicates for individual variables, statements, or entire code sections, using an emitter to track and manage the generated assertions. These predicates can be used for formal verification, debugging analysis results, or guiding further static analysis steps.",
      "description_length": 435,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Statistics",
      "library": "frama-c-eva.core",
      "description": "This module tracks and manages statistics collected during Eva's analysis, such as iteration counts, memory execution hits and misses, and widening or unrolling limits. It supports per-statement, per-function, and global statistics, enabling precise monitoring of analysis behavior at different granularities. Use cases include optimizing analysis performance by identifying frequently executed code paths or tuning widening thresholds based on observed iteration counts per statement.",
      "description_length": 485,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva.Unit_tests",
      "library": "frama-c-eva.core",
      "description": "This module implements programmatic tests for Eva's analysis, focusing on verifying the semantics of sign values. It directly exercises Eva's analysis engine to validate correctness of inferred results. Use cases include regression testing and validation of analysis behavior on specific code patterns.",
      "description_length": 302,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Builtins",
      "library": "frama-c-eva.core",
      "description": "This module registers OCaml implementations of C standard functions optimized for the cvalue domain, replacing their C counterparts during analysis. It defines types for representing builtins, their caching behavior, and result structures that capture memory states and return values. Use cases include modeling functions like `memcpy` or `strlen` with precise, efficient logic that integrates directly into value analysis without requiring full C function interpretation.",
      "description_length": 472,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva.Callstack",
      "library": "frama-c-eva.core",
      "description": "The module enables structured manipulation and traversal of callstacks, tracking function calls, statement locations, and thread contexts during static analysis. It supports stack operations like `push`, `pop`, `top_kf`, and `top_callsite`, along with lexicographic comparison to model execution paths and manage context-sensitive value tracking. Child modules provide mappings from callstacks to arbitrary values, efficient associative maps with callstack keys, and data types for representing and manipulating call sites with equality, comparison, and serialization. These components together enable tasks like memoizing analysis results, tracking memory states, comparing program paths, and maintaining per-callstack state during Eva's execution.",
      "description_length": 749,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva",
      "library": "frama-c-eva.core",
      "description": "This module performs static analysis by evaluating expressions and tracking memory states using abstract domains like `Cvalue`. It processes program syntax trees to compute values, memory zones, and dependencies at each program point, supporting configurable analysis through domains, builtins, and annotations. Users can inspect results, verify memory effects, and control precision via slevel limits, loop unrolling, and value partitioning. Example uses include recovering variable values, analyzing function call impacts, and validating memory properties like initialization or taint.",
      "description_length": 587,
      "index": 378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string parameters in a server plugin context, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and project skeletons, enabling deep copies and membership checks over project data. Concrete use cases include managing server configuration options and plugin parameters with structured string values.",
      "description_length": 406,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type and operations for handling string-based representations of kernel functions in a server plugin context. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate function declarations and prototypes as string values within the server's parameter system.",
      "description_length": 410,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string-based parameters in a server plugin context, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and project skeletons to manage parameter state across different contexts. Concrete use cases include storing and comparing configuration settings, validating parameter values against project-specific constraints, and generating user-readable output for debugging or logging.",
      "description_length": 486,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based parameters in a server plugin context. It supports operations like equality checking, comparison, hashing, and pretty-printing for string values, along with deep copying and project membership testing. It is used to represent and manipulate string configuration options that must be stored, compared, and displayed within the server framework.",
      "description_length": 400,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based file paths in server parameters, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports values of type `t` that represent file paths as strings, with functions to check membership in projects, perform deep copies, and maintain descriptors for type handling. Concrete use cases include managing and validating file path inputs in server configurations, ensuring correct serialization and comparison within analysis plugins.",
      "description_length": 523,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling string-based kernel function sets in server parameters, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and project skeletons to manage parameter representations and project membership tests. Concrete use cases include storing and manipulating server plugin options that require string identifiers and project-specific configurations.",
      "description_length": 439,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a string-based parameter type that supports equality, comparison, hashing, and pretty-printing operations. It works with string values represented as `As_string.Datatype.t` and provides deep copying, membership testing, and project-specific queries. Concrete use cases include managing server configuration options, command-line arguments, and persistent state values that require string serialization.",
      "description_length": 422,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality checking, comparison, hashing, and pretty printing. It provides a deep copy function, checks for project membership, and includes standard type representations for integration with the Frama-C kernel. Use cases include managing and comparing file path configurations within server plugins and options.",
      "description_length": 413,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type and operations for handling string-based parameters associated with kernel functions in a server plugin context. It supports equality checks, comparison, hashing, pretty printing, and deep copying of values, along with project membership testing. The type is used to represent and manipulate configuration or state data tied to specific kernel functions, enabling distinct handling of function declarations and prototypes.",
      "description_length": 454,
      "index": 387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values as strings within a server plugin context. It includes standard utilities such as equality checks, comparison, hashing, and pretty printing, along with support for project membership testing and deep copying. It is used to handle string-based parameters that must be uniquely named, compared, and persisted across server configurations.",
      "description_length": 437,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for handling string-based parameters in a server plugin context. It supports equality checks, comparison, hashing, and pretty-printing for string values, along with deep copying and project membership testing. It is used to represent and manipulate string configuration options that may have multiple values.",
      "description_length": 356,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for handling sets of strings as a single string parameter, supporting operations like equality, comparison, hashing, and pretty-printing. It works with string sets represented as a custom type `t`, alongside project-aware membership checks and deep copying. Concrete use cases include managing server plugin options that require string set parameters with precise semantic and structural handling.",
      "description_length": 429,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string parameters in a server plugin context, providing standard operations like equality, comparison, hashing, and pretty printing. It works with string values represented as `As_string.Datatype.t` and supports deep copying, membership testing within projects, and type descriptors for integration with the Frama-C kernel. Concrete use cases include managing configuration strings, command-line options, or persistent state values within server plugins.",
      "description_length": 498,
      "index": 391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_list.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string lists as string values in a server plugin context. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage configuration or parameter values that are represented as strings within analysis tools or plugins.",
      "description_length": 371,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set.As_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling string-based server parameters with operations for equality, comparison, hashing, and pretty-printing. It supports values of type `As_string.Datatype.t`, providing deep copying, membership testing within projects, and standard type representations. Concrete use cases include managing and validating string configuration options in server plugins, ensuring consistent handling across different parameter sets.",
      "description_length": 453,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for string sets in a server plugin context. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, with support for dependencies and access control. Use cases include organizing plugin parameters into logical groups and controlling their activation behavior.",
      "description_length": 354,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for a server plugin system, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types that encapsulate accessors and dependencies on global state. Concrete use cases include setting up configurable parameter groups with custom access logic and enabling global parameter behavior in positive or negative contexts.",
      "description_length": 432,
      "index": 395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a structured datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C kernel plugins. It supports deep copying, membership testing within projects, and provides descriptors for type representation and structural inspection. Concrete use cases include managing and manipulating abstract values in static analysis plugins, such as tracking function behaviors or analyzing control flow graphs.",
      "description_length": 462,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string command-line options with validation, alias handling, and state tracking, operating on string parameters within a map-based configuration system. It defines a string-based parameter type that supports equality, comparison, hashing, and pretty-printing, working with values as `As_string.Datatype.t` for deep copying, membership testing, and project-specific queries. It enables use cases like server configuration parsing, dynamic parameter updates via hooks, and strict value validation for CLI tools. The combined functionality ensures consistent handling of string identities and function-name references while supporting serialization and persistent state management.",
      "description_length": 698,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.Datatype",
      "library": "frama-c-server.core",
      "description": "Implements a map from file paths to values, using efficient trie-based storage optimized for hierarchical path lookups. Provides operations to add, retrieve, and traverse entries keyed by file paths, with support for prefix matching and path component iteration. Useful for managing per-file configuration or analysis data in a scalable way.",
      "description_length": 341,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module provides utilities to manage string-valued server parameters, including validation, constraints, and serialization, with support for hooks during value updates. It defines core operations on string parameters, such as equality, comparison, and pretty-printing, centered around the `t` datatype for consistent handling across configurations. Submodules enable structured validation against predefined rules or functions, while supporting use cases like CLI parsing, plugin configuration, and deprecated alias management. Together, the module and its children allow robust definition, validation, and transformation of server string parameters in a type-safe manner.",
      "description_length": 676,
      "index": 399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based server configuration parameters with support for validation, alias resolution, and persistent state tracking. It works with string values constrained by allowed sets or function name patterns, offering operations to register change handlers and control serialization. The file path submodule enhances this functionality by providing typed handling of file paths with equality, comparison, and pretty-printing, enabling robust validation and management of file-based configuration inputs. Together, they support tasks like enforcing valid function identifiers, tracking runtime configuration changes, and ensuring correct file path handling in analysis plugins.",
      "description_length": 693,
      "index": 400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type for representing file paths within a server configuration system. It supports operations for equality checking, comparison, hashing, and pretty-printing file path values. The type is used to store and manipulate file paths in a structured way, ensuring deep copies and proper project-specific membership checks.",
      "description_length": 352,
      "index": 401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category elements and state lists, allowing the association of accessors and dependencies with each category. Concrete use cases include setting up plugin parameter groups, enabling global behavior through `@all`, and redirecting default category behavior dynamically.",
      "description_length": 451,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.WithOutput.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in server plugin configurations. It supports structured values through a descriptor and representants, enabling type-safe manipulation and introspection. Use cases include managing and serializing server-side parameter states with precise identity and structural checks.",
      "description_length": 400,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for organizing and controlling plugin options in a server configuration. It provides operations to define named categories, set default behaviors, and enable or disable groups of parameters using accessors and state lists. Concrete use cases include grouping related configuration options and defining fallback or global settings for plugins.",
      "description_length": 383,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for a parameter map, where each category is associated with a name, an accessor, and optional dependencies. It supports creating, enabling, and modifying categories such as `@none`, `@default`, and `@all`, with specific behaviors for handling default and all-inclusive cases. Use cases include defining and controlling parameter groups in a server plugin configuration, where categories dictate how parameters are interpreted and activated.",
      "description_length": 471,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter collections, supporting operations to define, retrieve, and configure category values such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.Parameter_category.t` and related state and accessor types to control parameter behavior in server plugins. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific accessors, or mapping `@all` to a custom category.",
      "description_length": 468,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set.Datatype",
      "library": "frama-c-server.core",
      "description": "Implements a set-like structure for managing a collection of unique `Datatype.t` values with operations for membership testing, comparison, and pretty printing. It supports efficient set manipulations such as union, intersection, and difference, along with deep copying and project-aware filtering. This structure is used to represent and manipulate sets of analysis parameters or plugin configurations in a server context.",
      "description_length": 423,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-valued command-line parameters with support for multibindings, parsing, validation, alias resolution, and state serialization over associative structures mapping keys to string lists. It provides hooks for tracking value changes and resolving function names, enabling dynamic configuration in server plugins and constraint enforcement in CLI tools. The child module enhances this functionality by defining a data type for string-based parameters with equality, comparison, hashing, and pretty printing, particularly useful for managing configuration state across project contexts. Together, they support tasks like validating parameters against project-specific rules, storing and comparing configuration settings, and generating readable logs or debug output.",
      "description_length": 787,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based command-line parameters with constrained values, enabling the definition of allowed options, input validation, and dynamic behaviors such as state change hooks. It supports main data types like parameter descriptors that encapsulate validation logic, aliases, and serialization rules, along with a specialized string set type for handling multiple values as a single parameter. The string set submodule provides equality, comparison, and project-aware membership checks, making it suitable for managing structured options like plugin settings. Example uses include configuring Frama-C plugins with strict value validation or custom parsing workflows for function names and identifiers.",
      "description_length": 718,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing kernel functions within a server plugin. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, each controlling how function parameters are interpreted and activated. Use cases include setting up configurable behavior for function parameters based on category membership, enabling or disabling groups of functions, and defining default or fallback categories for parameter handling.",
      "description_length": 497,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based server parameters with validation, serialization, and dynamic value handling. It supports operations on string values and lists of allowed values, enabling configuration via command-line arguments, project-specific settings, and input validation through predefined options or function name checks. The child module enhances this functionality by providing data structures for representing these parameters with support for equality, comparison, hashing, pretty-printing, deep copying, and project membership testing. Together, they allow for robust handling of server configuration scenarios, such as tracking parameter state, enforcing valid inputs, and customizing how values are stored or displayed.",
      "description_length": 735,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Int.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling integer values within a server plugin context, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports integration with Frama-C's kernel structures by defining a type descriptor, name, and representation list, enabling proper handling of projects and deep copies. Concrete use cases include managing and comparing integer-based configuration parameters or runtime values in a server plugin.",
      "description_length": 480,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.As_string",
      "library": "frama-c-server.core",
      "description": "This module handles string command-line parameters with validation rules, value constraints, and custom marshaling, enabling safe mapping of inputs to function names or predefined options. It supports operations such as defining allowed value sets, extracting validated identifiers, and transparently handling plain strings, while its child module extends this functionality to file path lists with equality, comparison, and pretty printing support. Use cases include restricting configuration inputs and managing file-based project settings in server plugins. The combined interface provides both low-level string validation and high-level path manipulation capabilities.",
      "description_length": 672,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Float.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a float parameter type with support for equality, comparison, hashing, and pretty printing. It works with `Datatype.t` values representing optional decimal points converted to OCaml floats. Used to handle numeric server configuration options that require precise decimal input and output formatting.",
      "description_length": 319,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Empty_string.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for handling empty strings within a server plugin context, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports the `Datatype.t` structure and is used to represent and manipulate values that correspond to empty string parameters. Concrete use cases include managing configuration options and plugin settings where empty strings are valid inputs.",
      "description_length": 425,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a list-based datatype for representing and manipulating collections of values in a server plugin context. It provides standard operations such as equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to manage structured configuration data or option lists where each element must support consistent comparison and serialization behaviors.",
      "description_length": 432,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list.Category",
      "library": "frama-c-server.core",
      "description": "This module defines and manages parameter categories for organizing server plugin options. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, using accessors and dependency lists. Use cases include grouping related parameters under named categories and controlling default and global behavior in server configurations.",
      "description_length": 371,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-valued server parameters with support for validation, constraint enforcement, and function name resolution. It defines core operations for handling string parameters, including equality, comparison, hashing, and pretty printing, while working with values represented as `t` for use in server plugins. Submodules provide integration with the Frama-C kernel, support for deep copying, and membership testing within projects. Example uses include managing configuration options, validating command-line inputs, and linking parameter values to executable logic through function resolution.",
      "description_length": 612,
      "index": 418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-valued server parameters with configurable validation rules, enabling restrictions to predefined lists, function name validation, or arbitrary string acceptance. It provides data types and operations for representing, comparing, and manipulating these values, including support for equality checks, hashing, and pretty printing within a server plugin context. With validation logic enforced dynamically during updates, it facilitates use cases such as server configuration with restricted options, command-line argument parsing, and tracking project-specific state through aliases and hooks. It integrates utilities for unique naming, persistence, and deep copying to handle string parameters across different server environments.",
      "description_length": 757,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set.As_string",
      "library": "frama-c-server.core",
      "description": "This module handles string-based command-line parameters with validation, alias support, and dynamic state tracking through hooks and custom serialization. It works with strings and string lists, allowing controlled modification and validation of values, such as enforcing allowed function names or managing server settings with runtime updates. The child module extends this functionality by defining a data type for string-based kernel function sets, supporting operations like equality checks, comparison, and pretty printing, particularly for managing server plugin options and project-specific configurations. Together, they enable structured handling of string parameters from definition to runtime manipulation and persistence.",
      "description_length": 734,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type and associated operations for representing and manipulating kernel functions with multiple map parameters, supporting both defined functions and pure prototypes. It provides standard comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Concrete use cases include managing function parameter configurations and enforcing type constraints during static analysis.",
      "description_length": 446,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Polling.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically for representing and managing polling-related parameters in a server context. It supports structured values with descriptors and provides deep copying, membership testing, and project-based queries. Concrete use cases include storing and comparing polling intervals, checking parameter validity, and serializing or displaying polling configurations.",
      "description_length": 473,
      "index": 422,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing server plugin parameters, using string-based identifiers and accessors tied to parameter states. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, enabling dynamic behavior based on category activation. Concrete use cases include categorizing command-line options and managing default or global parameter behaviors in server plugins.",
      "description_length": 452,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for representing sets of strings with operations for comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering using a custom predicate. The type is used to manage string collections in a way that ensures structural integrity and efficient manipulation within Frama-C's plugin system.",
      "description_length": 377,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Doc.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines operations for handling datatype representations, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` and provides structured access to descriptors, names, and representants for documentation generation. Concrete use cases include comparing and serializing datatypes for server plugin configurations and generating human-readable documentation from structured data.",
      "description_length": 431,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Verbose.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty-printing. It supports structured values through a descriptor and provides deep copying, membership testing over projects, and representant enumeration. Concrete use cases include managing verbose output settings in a server plugin with project-specific configurations.",
      "description_length": 377,
      "index": 426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Bool.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a boolean datatype with standard operations including equality, comparison, hashing, and pretty printing. It provides a structured representation for boolean values within a server plugin context, supporting deep copying and project membership checks. Concrete use cases include managing server configuration options and plugin parameters that require boolean state representation.",
      "description_length": 401,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating kernel function map entries. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to manage function declarations and prototypes within Frama-C's kernel, supporting precise type handling and structural comparisons.",
      "description_length": 397,
      "index": 428,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Server.Server_parameters.Make_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a parameter type for a server configuration where each parameter is a unique key-value map without multibindings. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage structured configuration data with strict identity and immutability constraints.",
      "description_length": 384,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Enum.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations to check membership in projects, perform deep copies, and provides a list of all possible values along with their string representations. It is used to represent and manipulate closed enumerations within the server plugin system, ensuring consistent handling of finite variant types across analyses.",
      "description_length": 438,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Zero.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a specific data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugin development. It includes functions for deep copying values, checking membership within a project context, and provides descriptors for type representation and structural comparison. Concrete use cases include managing and manipulating analysis parameters within Frama-C plugins, where precise type handling and project-specific filtering are required.",
      "description_length": 499,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-valued server parameters with support for validation, aliases, change hooks, and customizable serialization, operating on global state to enforce constraints. It provides data types and operations for handling string parameters in server plugins, including equality checks, comparison, hashing, and pretty printing, while enabling deep copies and membership checks over project data. Use cases include enforcing configuration policies, managing plugin parameters, and integrating with command-line interfaces through structured string values. Submodules extend functionality for specific contexts like project skeletons and dynamic parameter updates.",
      "description_length": 677,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based server parameters with support for validation, dynamic updates, and alias handling. It provides data types for representing string values and lists of allowed entries, along with operations for checking membership, comparing values, and registering change handlers. Child modules extend this functionality with utilities for deep copying, equality checks, and pretty-printing, enabling robust handling of multi-value configuration options. Example uses include enforcing valid command-line arguments, restricting configuration settings to predefined choices, and tracking changes to server parameters with custom serialization.",
      "description_length": 660,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list.Datatype",
      "library": "frama-c-server.core",
      "description": "Implements a datatype for handling lists of file paths in a server plugin context. Provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Designed for use in configuration and plugin systems where file path lists must be manipulated and compared efficiently.",
      "description_length": 344,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type for representing string-based server parameters, including operations for equality, comparison, hashing, and pretty-printing. It works with strings and supports deep copying, project membership checks, and integration with Frama-C's type and descriptor system. It is used to manage and manipulate string configuration values within server plugins, ensuring consistency and proper handling across different contexts.",
      "description_length": 456,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a map where keys are strings and values are lists of `Datatype.t`, supporting operations like insertion, lookup, and iteration over string-indexed collections of lists. It provides functions to manipulate and query these associations, including merging, filtering, and pretty-printing. Concrete use cases include managing server configuration parameters with multiple values per key, such as command-line options or plugin settings.",
      "description_length": 455,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.AutoLog.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type and operations for managing log-related values in a server plugin, including equality, comparison, hashing, and pretty-printing. It supports structured data manipulation with deep copying, membership testing, and descriptors for type representation. Concrete use cases include tracking and comparing log configurations, ensuring type consistency in log monitoring, and enabling safe data duplication for plugin operations.",
      "description_length": 454,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module implements a string map data structure with operations for key-value associations, including insertion, lookup, and iteration. It works with string keys and polymorphic values, supporting efficient membership checks and ordered traversal. Concrete use cases include managing configuration settings, caching parsed values, and tracking named entities during static analysis.",
      "description_length": 385,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, handling creation, modification, and activation of named categories with associated accessors and dependencies. It operates on category and state types, enabling fine-grained control over plugin behavior through category settings. Concrete use cases include defining the '@none', '@default', and '@all' categories, enabling global parameter behavior, and associating categories with specific plugin states and accessors.",
      "description_length": 481,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.False.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type `t` with standard operations including equality, comparison, hashing, and pretty printing. It provides a unique name, a descriptor, and a list of representative values for the type, supporting deep copying and project membership checks. It is used to represent and manipulate structured data within a server plugin context, particularly for handling configuration or state values that must be compared, stored, or displayed.",
      "description_length": 465,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Debug.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating structured debug parameters in a server context. It supports values of type `t` with functions for equality, comparison, hashing, pretty-printing, and deep copying, along with descriptors for type and structural representation. It is used to handle debug configurations with project-specific filtering via `mem_project`, ensuring safe and consistent manipulation of server plugin options.",
      "description_length": 482,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Record.S",
      "library": "frama-c-server.core",
      "description": "This module defines a record data structure with typed fields, supporting dynamic field registration and type-safe access. It provides operations to create, query, and modify records, along with JSON serialization and deserialization. Use it to model structured data with optional and required fields, such as configuration objects or database rows.",
      "description_length": 349,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Action.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in server plugin parameters. It includes functions for deep copying values, checking membership within a project context, and provides representants along with a packed descriptor for structural manipulation. It is used to manage and manipulate typed server configuration data in a safe and consistent way.",
      "description_length": 436,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a data type for representing filled string sets with operations for equality, comparison, hashing, and pretty printing. It supports set-like operations and is used to manage collections of strings where each string is a unique element in the set. Concrete use cases include tracking sets of identifiers, options, or parameters in static analysis plugins where membership and immutability are important.",
      "description_length": 422,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter customization in a server plugin context, allowing the definition and manipulation of named categories such as `@none`, `@default`, and `@all`. It provides operations to create categories with accessors and dependencies, set default interpretations, and enable or alias the `@all` category. Concrete use cases include organizing and controlling the visibility or behavior of function-related parameters in static analysis tools.",
      "description_length": 473,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a set-like structure for handling function declarations (`Fundec`) within the server plugin system. It provides standard set operations such as equality, comparison, hashing, and pretty printing, specifically tailored for `Fundec` values. It is used to manage and manipulate collections of function declarations in a type-safe and efficient manner, particularly during analysis or transformation tasks in the Frama-C environment.",
      "description_length": 449,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module manages command-line string parameters with validation, supporting predefined function names or literals, and integrates submodules for handling kernel function associations and project-specific string data. It provides data types for constrained string values, operations for validation, comparison, and transformation, along with hooks for handling value changes. The submodule enhances this by enabling project membership checks and structured manipulation of kernel-related parameters. Example uses include validating server configuration options against known functions or restricting identifiers to a defined set of strings via CLI.",
      "description_length": 650,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for parameter collections, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with `Category.t`, which wraps `Parameter_category.t`, and interacts with `State.t` lists and accessors. Concrete use cases include setting default category behavior, enabling `@all` with specific interpretations, and creating custom categories with dependencies and accessors.",
      "description_length": 456,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for server plugins, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and accessors tied to server states and parameters, enabling precise control over plugin behavior. Concrete use cases include setting default parameter interpretations, enabling global categories with specific accessors, and defining dependencies for custom categories.",
      "description_length": 467,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list.As_string",
      "library": "frama-c-server.core",
      "description": "This module handles string lists as string values in a server plugin context, offering standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Its main data types represent string collections used for configuration or parameter values in analysis tools. Specific operations allow for manipulating and querying these string-based configurations directly. Submodules extend this functionality to specialized string list handling, enhancing usage in plugin-driven environments.",
      "description_length": 550,
      "index": 450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.String_list.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete implementation of a string list data type with operations for equality, comparison, hashing, and pretty printing. It supports manipulation of lists of strings as a structured data type, ensuring deep copying and project membership checks. Use cases include managing collections of string-based configuration parameters or options within a server plugin context.",
      "description_length": 392,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.As_string",
      "library": "frama-c-server.core",
      "description": "This module provides utilities for managing string-based configuration parameters with validation, alias handling, and serialization customization, particularly in server plugin contexts. It supports operations on string values and allowed value lists, enabling tasks like validating inputs against restricted sets, retrieving values based on function name rules, and tracking state changes via hooks. The child module enhances this functionality by defining a structured representation for kernel function strings, offering equality, comparison, hashing, and pretty printing capabilities. Together, they allow precise manipulation and enforcement of string-based function declarations and configuration parameters.",
      "description_length": 715,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a polymorphic map-like data structure that supports multiple bindings per key, with operations for equality, comparison, hashing, and pretty-printing. It works with values of type `Datatype.t` and provides deep copying, membership testing within projects, and structural descriptors for type representation. Concrete use cases include managing server configuration parameters with multiple values per key, such as command-line options or plugin settings.",
      "description_length": 474,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages parameter categories for organizing and controlling plugin behavior in a server configuration. It provides operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`, each associated with specific states and accessors. These categories are used to group and control the activation of server parameters dynamically during execution.",
      "description_length": 384,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.True.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in server plugin parameters. It supports structured values through a descriptor and representants, enabling introspection and serialization. Use cases include managing configuration values with rich structure, such as parsed command-line options or plugin settings with nested data.",
      "description_length": 412,
      "index": 455,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Custom.Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use as a server parameter. It includes a unique name, a type descriptor, and functions to handle project membership and deep copying of values. Concrete use cases include defining structured configuration options for plugins, such as analysis settings or custom command-line parameters.",
      "description_length": 409,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map.Category",
      "library": "frama-c-server.core",
      "description": "This module manages categories for grouping and organizing kernel functions within a server plugin context. It provides operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`, each controlling how function parameters are interpreted and activated. Use cases include structuring plugin options and controlling function visibility or behavior based on category settings.",
      "description_length": 405,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Record",
      "library": "frama-c-server.core",
      "description": "This module enables the creation of structured record types with named fields, combining dynamic field registration and type-safe access. It centers around a ghost type `r` used to define a signature containing required and optional fields, each associated with a specific data encoding. Once published, the resulting data module provides operations to construct, inspect, and manipulate records of type `r record`, supporting JSON serialization and deserialization. For example, you can define a configuration record with required strings and optional integers, then serialize it to JSON or validate it against a schema.",
      "description_length": 621,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jstring",
      "library": "frama-c-server.core",
      "description": "This module handles JSON string encoding and decoding. It defines conversions between JSON values and string representations using `of_json` and `to_json`. It is used to serialize and deserialize string data during API communication.",
      "description_length": 233,
      "index": 459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filled_string_set",
      "library": "frama-c-server.core",
      "description": "This module manages structured string sets as server options with support for modification, membership checks, and dynamic updates through hooks. It provides a core type for representing string sets with constraints, along with operations for handling categories, validation, and function resolution, enabling use cases such as managing configuration parameters and command-line inputs. Submodules handle string-valued parameters with validation, define parameter categories for plugin control, and implement the underlying filled string set data structure used for immutable set-like collections. Together, they support structured configuration, predicate-based constraints, and integration with server state and plugin systems.",
      "description_length": 729,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_list",
      "library": "frama-c-server.core",
      "description": "This module manages list-valued server parameters with dynamic state, supporting operations like prepend, append, and alias management over a list type `t = E.t list`. It integrates serialization, value comparison, and state change hooks, enabling persistent storage and real-time updates for configuration options. Child modules enhance this by adding string-specific validation, structured list manipulation with consistent comparison, and category-based organization of plugin options. Examples include managing command-line arguments with allowed value lists, grouping parameters under categories like `@default`, and synchronizing server configuration state across projects.",
      "description_length": 679,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Joption",
      "library": "frama-c-server.core",
      "description": "This module defines an option type `t` based on the parameter module `A`, and provides JSON serialization and deserialization functions `of_json` and `to_json`. It works with JSON data structures, enabling handling of optional values in data encoding contexts. A concrete use case is decoding and encoding API payloads where certain fields may be absent.",
      "description_length": 354,
      "index": 462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_project.ProjectInfo",
      "library": "frama-c-server.core",
      "description": "Handles serialization and deserialization of project data using JSON. Works directly with `Frama_c_kernel.Project.t` and JSON structures. Used to convert project information to and from JSON format for transmission or storage.",
      "description_length": 226,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jalpha",
      "library": "frama-c-server.core",
      "description": "This module handles conversion between JSON values and string representations of Jalpha data. It provides `of_json` to parse JSON into a Jalpha string and `to_json` to serialize a Jalpha string back into JSON. These operations support direct data interchange in server-side processing of Jalpha-encoded payloads.",
      "description_length": 312,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.PrinterTag",
      "library": "frama-c-server.core",
      "description": "This module provides pretty-printing functions that serialize CIL and ACSL abstract syntax tree nodes into human-readable text, primarily for debugging or analysis output. It operates on Frama-C kernel data structures including AST elements like variables, expressions, statements, function specifications, and annotations, as well as logic constructs such as predicates and behaviors. The formatters support customizable output through directives that control annotation visibility, brace placement, and structural formatting, making them suitable for generating precise code representations in tools like static analyzers or program verifiers.",
      "description_length": 645,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Zero",
      "library": "frama-c-server.core",
      "description": "This module manages integer parameters with support for range constraints, dynamic defaults, and state tracking, enabling configuration and synchronization across Frama-C components. It provides core operations to set, get, and modify values, along with hooks for state changes and command-line integration. The child module enhances this functionality by defining a structured data type with comparison, copying, and project-aware membership checks, facilitating precise handling of analysis parameters. Together, they allow developers to build robust, state-consistent plugin configurations with customizable serialization and type-safe manipulation.",
      "description_length": 652,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Position",
      "library": "frama-c-server.core",
      "description": "This module handles file position data using a JSON record format with fields for file, directory, base name, and line number. It provides conversion functions between JSON and the position type, enabling seamless serialization and deserialization. Use this module to track and exchange source code location information in JSON format, such as when communicating positions between tools or storing them in configuration files.",
      "description_length": 426,
      "index": 467,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.False",
      "library": "frama-c-server.core",
      "description": "This module manages a boolean flag with support for setting, retrieving, and monitoring state changes, integrating command-line options and serialization. It defines a data type `t` with operations for equality, comparison, hashing, and pretty printing, enabling structured representation and manipulation of configuration values. The module supports aliases, change hooks, and project membership checks, allowing plugins to toggle analysis features or server behaviors dynamically. Example uses include tracking enabled/disabled states for analyses or persisting and restoring plugin configurations.",
      "description_length": 600,
      "index": 468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Empty_string",
      "library": "frama-c-server.core",
      "description": "This module manages string-based configuration options in server plugins, combining direct operations for value setting, retrieval, and validation with support for typed parameters and string lists. It enforces rules like allowed values and function name validation, and synchronizes state across different plugin components. The child module enhances this by defining a dedicated type for empty strings, supporting standard operations and integration with the `Datatype.t` framework. Together, they enable precise handling of empty string parameters in plugin configurations and command-line interfaces.",
      "description_length": 604,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Session",
      "library": "frama-c-server.core",
      "description": "This module manages a session directory for a server plugin, providing operations to retrieve or create directories and files within that session space. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and creation of session-specific resources. Concrete use cases include storing temporary session data, caching analysis results, or managing per-session configuration files.",
      "description_length": 422,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Share",
      "library": "frama-c-server.core",
      "description": "This module manages the plugin's `share` directory configuration by setting, retrieving, and validating directory paths. It provides operations to set the directory, check if it is set, and resolve specific files or subdirectories within it. Use cases include locating plugin-specific resources like configuration files or shared libraries during analysis.",
      "description_length": 356,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Debug",
      "library": "frama-c-server.core",
      "description": "This module manages integer-based debug settings with dynamic constraints, supporting operations like incrementing, clamping to bounds, and registering change callbacks, while enabling command-line integration and custom serialization. It defines a core data type `t` with rich manipulation capabilities\u2014equality, comparison, hashing, and pretty-printing\u2014and includes descriptors for type-safe configuration handling. A child module extends this with structured debug parameters for server contexts, adding project-specific filtering and deep copying. Together, they enable interactive runtime debugging, safe configuration of server plugins, and persistent, validated parameter management across sessions.",
      "description_length": 706,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_ast.Kinstr",
      "library": "frama-c-server.core",
      "description": "This module defines operations for converting kinstr values to and from JSON format, using a specific jtype for serialization. It works directly with Frama_c_kernel.Cil_types.kinstr, a type representing kernel instructions. This enables persisting or transmitting kernel instruction data in JSON form, such as for storage, communication, or analysis tools that consume structured data.",
      "description_length": 385,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_map",
      "library": "frama-c-server.core",
      "description": "This module manages mappings between kernel functions and structured values, supporting operations to set, retrieve, and monitor associations with custom marshaling, equality checks, and category tagging. It enables precise handling of function declarations and prototypes, with deep copying, comparison, and project membership checks, while integrating string-based configuration parameters that support validation, aliases, and serialization. The category system allows grouping functions under tags like `@none`, `@default`, and `@all`, controlling visibility and behavior in server plugins. Example uses include configuring plugin options based on function names, tracking runtime state changes, and combining static declarations with computed values.",
      "description_length": 755,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_main.LogEvent",
      "library": "frama-c-server.core",
      "description": "Handles conversion of log events to and from JSON format. Works with Frama_c_kernel.Log.event values. Used to serialize and deserialize log data for transmission or storage.",
      "description_length": 173,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Tag",
      "library": "frama-c-server.core",
      "description": "This module represents tags used to identify and manipulate abstract syntax tree (AST) nodes in a server environment. It provides functions to convert tags to and from JSON, retrieve a unique memoized identifier for a tag, and resolve a tag from its identifier string. Concrete use cases include serializing AST node metadata for transmission and reconstructing AST scopes from string identifiers during deserialization.",
      "description_length": 420,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.True",
      "library": "frama-c-server.core",
      "description": "This module manages a boolean parameter with support for state transitions, command-line configuration, and persistent storage, enabling dynamic feature toggling and kernel-level flag manipulation. It defines a boolean type enriched with metadata like defaults, aliases, and serialization logic, allowing consistent state management across sessions. The child module enhances this by providing structured value handling with equality, comparison, and pretty-printing operations, supporting complex configuration introspection and serialization. Together, they facilitate managing server plugin parameters with both simple and nested data structures through a unified interface.",
      "description_length": 677,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module manages a map associating kernel functions and pure prototypes with lists of values, supporting dynamic configuration and dependency tracking. It provides operations to set, retrieve, and monitor associations, with hooks for state tracking, defaults, and project-specific logic. Submodules handle parameter categories, string validation, and kernel function representation with comparison, hashing, and pretty-printing. Use it to configure server plugins with typed parameters, enforce constraints, and manage function metadata across projects.",
      "description_length": 556,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States.TableState-Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a synchronized state type for managing tabular data between server and client. It includes operations for equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It works directly with `Datatype.t` and `Project_skeleton.t`, supporting structured data representation and inspection in analysis tools. Use cases include tracking and synchronizing analysis results across different phases or components of a static analysis framework.",
      "description_length": 512,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.WithOutput",
      "library": "frama-c-server.core",
      "description": "This module manages boolean server options with change tracking and project-specific state, enabling conditional output control based on runtime dependencies. It supports structured data through a concrete type with equality, comparison, and pretty-printing, allowing type-safe manipulation of configuration values. Operations include value serialization, dependency resolution, and state-aware output suppression, useful for dynamically enabling or disabling server plugin outputs when specific project states are reached. Submodules enhance this by providing descriptors and representants for structured value handling in plugin configurations.",
      "description_length": 646,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Verbose",
      "library": "frama-c-server.core",
      "description": "This module manages integer parameters with configurable bounds, metadata, and runtime modification, enabling dynamic adjustments through command-line interfaces and runtime hooks. It supports structured value representations with equality, comparison, and enumeration operations, allowing deep copying and membership testing across projects. You can use it to control logging verbosity or enforce resource limits in server plugins, with support for serialization, default values, and alias mappings. Submodule functionality extends these capabilities to structured configurations, enabling project-specific settings with consistent validation and state tracking.",
      "description_length": 663,
      "index": 481,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Package.IdMap",
      "library": "frama-c-server.core",
      "description": "This module provides functional map operations for key-value associations using ordered `Server.Package.ident` keys, supporting efficient insertion, lookup, and transformation with ordered traversal capabilities. It works with map structures that preserve key ordering, enabling bulk updates from sequences, merging of maps, and ordered iteration for tasks like dependency resolution or configuration aggregation. Specific utilities include filtering, partitioning, and bidirectional conversion to lists or sequences, making it suitable for scenarios requiring structured data manipulation with predictable key ordering.",
      "description_length": 620,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Value_int",
      "library": "frama-c-server.core",
      "description": "This module defines operations for handling integer values within a server plugin context, including conversions to and from strings, equality checks, comparison, hashing, and pretty printing. It works specifically with the `int` type and provides functions for deep copying, membership testing in projects, and representing values for serialization. Concrete use cases include parsing and validating integer configuration options, comparing and hashing integer values for data structures, and displaying them in user-facing logs or error messages.",
      "description_length": 548,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module manages a string-indexed map of value lists with support for hooks, aliases, and custom serialization, enabling structured handling of multi-value configurations. It provides operations to manipulate entries, track state changes, and define default or project-scoped behaviors, particularly for server plugins and command-line interfaces. Submodules organize parameters into categories, enforce validation rules, and handle string-based values with typed constraints, supporting use cases like option parsing and persistent parameter management. Together, they enable dynamic configuration with scoped overrides, validated inputs, and structured traversal of string-keyed list data.",
      "description_length": 694,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Action",
      "library": "frama-c-server.core",
      "description": "This module manages boolean server parameters with operations to set, retrieve, and monitor their state through hooks, serialization, and command-line integration, while its child module defines a concrete data type with support for equality, comparison, hashing, and pretty-printing, tailored for server plugin parameters. It enables safe and consistent manipulation of typed server configuration data, including deep copying, membership checks, and structural manipulation via representants and a packed descriptor. You can use it to implement feature toggles, dynamic configuration updates, and deprecation handling for server-side options. Example use cases include tracking parameter changes at runtime, serializing server state, and integrating configuration with command-line interfaces.",
      "description_length": 794,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Polling",
      "library": "frama-c-server.core",
      "description": "This module manages a stateful integer parameter for idle wait durations in milliseconds, with support for bounds checking, change hooks, and dynamic updates within a project context. It includes a custom data type for structured polling parameters, enabling equality checks, comparison, serialization, and pretty-printing, along with operations for alias management and command-line integration. Users can define, modify, and query polling intervals while ensuring valid duration ranges and tracking changes across server plugins. Example uses include configuring polling intervals for dynamic server components and persisting or displaying current and default parameter values.",
      "description_length": 679,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jint",
      "library": "frama-c-server.core",
      "description": "This module defines conversions between JSON values and integer data, providing `of_json` and `to_json` functions for encoding and decoding integers in JSON format. It operates on the basic `int` type and the `json` type from the `Server.Data` module. Concrete use cases include serializing integer values for API responses and parsing integer inputs from JSON payloads.",
      "description_length": 370,
      "index": 487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath_list",
      "library": "frama-c-server.core",
      "description": "This module manages a mutable list of filepaths within a server configuration, enabling dynamic updates, transformations, and integration with plugin systems for state and option handling. It supports core operations such as iteration, filtering, and project membership checks, while its submodules extend functionality with parameter categories, validated string inputs, and enhanced file path list manipulation including equality, comparison, and pretty printing. Users can define configurable groups of options, enforce input constraints, and manage runtime-modifiable file paths with robust validation and serialization. Example uses include processing command-line arguments, maintaining analysis paths in plugins, and synchronizing configuration state across server sessions.",
      "description_length": 781,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Bool",
      "library": "frama-c-server.core",
      "description": "This module manages boolean parameters in a server context, enabling dynamic updates through `on`/`off` operations, change tracking via hooks, and default state handling. It works with boolean values and parameter references, supporting use cases like feature toggles and configuration flags with serialization and command-line integration. The child module enhances this by defining a structured boolean datatype with equality, comparison, and pretty printing, enabling deep copying and project membership checks. Together, they allow configuring, modifying, and inspecting boolean states across server plugins, such as enabling a debug mode or toggling a feature flag with callback-based synchronization.",
      "description_length": 706,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jany",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON values and a polymorphic variant type representing package data. It provides functions to encode and decode JSON values to the `t` type, ensuring compatibility with the package's type system. Useful for serializing and deserializing package metadata during network transmission or storage operations.",
      "description_length": 332,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Info",
      "library": "frama-c-server.core",
      "description": "This module defines metadata for data type registration, including the associated package, type name, and description in Markdown. It works with data structures representing packages, strings, and formatted text. Used to document and identify data types within a server context, such as for API introspection or data schema registration.",
      "description_length": 337,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Value_string",
      "library": "frama-c-server.core",
      "description": "This module implements a string-based parameter type with operations for comparison, hashing, pretty-printing, and project membership checking. It supports parsing from and converting to regular strings, ensuring strict validity through typed representations. It is used to manage server configuration values that must be uniquely named, compared, and persisted across projects.",
      "description_length": 378,
      "index": 492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Int",
      "library": "frama-c-server.core",
      "description": "This module manages integer-valued server plugin options with configurable bounds, supporting operations like setting, retrieving, and incrementing values, along with change notifications and command-line interaction. It includes a core datatype with equality, comparison, and pretty printing, integrated with Frama-C's kernel for project handling and deep copies. Users can define bounded integer parameters that persist across sessions, respond to updates via hooks, and interact with command-line interfaces. Example uses include configuring plugin thresholds, tracking runtime counters, or managing numeric settings that require validation and serialization.",
      "description_length": 662,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States.TableState",
      "library": "frama-c-server.core",
      "description": "Implements a synchronized hash table for managing key-value pairs between server and client states. Provides operations to register callbacks for changes to the table and individual entries. Suitable for tracking dynamic collections of analysis results or configuration settings that require cross-component updates.",
      "description_length": 316,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package.Derived",
      "library": "frama-c-server.core",
      "description": "This module provides operations to manipulate and derive identifiers for server packages, including transformations like signaling, getting, setting, and decoding identifiers. It works with `Server.Package.ident` to support concrete workflows such as reloading package data, defining dependency order, and handling data serialization. These functions are used directly in package management tasks such as state synchronization, dependency resolution, and configuration decoding.",
      "description_length": 478,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Identified",
      "library": "frama-c-server.core",
      "description": "This module implements a projectified index for types with unique identifiers, supporting operations to register, retrieve, and remove indexed values. It works with an arbitrary type `A.t` and associates each value with an integer identifier, enabling efficient lookups by ID. Concrete use cases include managing uniquely identifiable entities like user sessions, document revisions, or database records within a server context.",
      "description_length": 428,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Tagged",
      "library": "frama-c-server.core",
      "description": "This module implements a projectified index for types with unique identifiers, supporting operations to register, retrieve, and remove items by string keys. It works with a data type `t` based on module `A`, and provides serialization to and from JSON using `to_json` and `of_json`. Use cases include managing uniquely identifiable data entities such as configuration items or indexed resources.",
      "description_length": 395,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jfile",
      "library": "frama-c-server.core",
      "description": "Handles JSON serialization and deserialization for file path data. Works with `Frama_c_kernel.Filepath.t` and JSON values. Used to convert file paths to and from JSON representations for communication between the server and clients.",
      "description_length": 232,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Fundec_set",
      "library": "frama-c-server.core",
      "description": "This module manages sets of CIL function declarations with support for modification, membership checks, iteration, and state persistence via marshaling, centered around the `Fundec.Set.t` type. It integrates with server plugins through submodules that handle parameter categories, string-valued parameters with validation, and set-like structures for function declarations. These components enable tasks like enforcing analysis rules via command-line options, configuring parameter groups with custom logic, and maintaining function sets across kernel operations. Together, they provide a cohesive system for managing function data and server configuration state in Frama-C plugins.",
      "description_length": 682,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String",
      "library": "frama-c-server.core",
      "description": "This module manages string-based configuration parameters for server plugins, enabling operations like setting, retrieving, and validating values, along with defining change hooks, aliases, and serialization. It provides a core data type for string parameters with support for equality, comparison, hashing, and pretty-printing, while integrating with Frama-C's type system and command-line parsing for dynamic updates. Users can define configurable string options, track changes via callbacks, and ensure consistent serialization across plugin states. Submodules enhance this functionality with structured representations and deep-copying mechanisms for robust parameter manipulation.",
      "description_length": 685,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Filepath",
      "library": "frama-c-server.core",
      "description": "This module manages server plugin configurations for file paths using a structured data type that supports equality, comparison, hashing, and pretty-printing. It enables setting, retrieving, and validating paths with support for empty values and alias handling, integrating seamlessly with Frama-C's state management. Operations include parsing command-line options, maintaining default paths, and synchronizing configuration changes with project state in server environments. The structured type ensures deep copies and project-specific membership checks during path manipulation.",
      "description_length": 581,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_user_dir_opt",
      "library": "frama-c-server.core",
      "description": "This module constructs and manages a user directory option within a server plugin context, using a parent directory and a named subdirectory. It provides functions to retrieve or create directories and files within this structure, validating existence and permissions when needed. Concrete use cases include setting up plugin-specific storage paths or handling user-configured directories for analysis tools.",
      "description_length": 408,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States.State-Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a synchronized state datatype with operations for equality, comparison, hashing, and pretty-printing. It works with a specific abstract type `t` representing server-client shared states, along with associated project skeletons. It supports deep copying, membership testing within projects, and provides representants and descriptors for type handling.",
      "description_length": 371,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Request.Input",
      "library": "frama-c-server.core",
      "description": "Handles parsing and validating incoming JSON requests into structured data types. Works with `Server.Request.json` and produces validated `t` values. Used to convert raw JSON payloads into typed representations for further processing.",
      "description_length": 234,
      "index": 504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_ast.Information",
      "library": "frama-c-server.core",
      "description": "Registers and manages metadata for AST marker information printers, including labels, titles, and optional descriptions. It supports conditional activation via an enable function and provides formatted output for localization. Use this module to define custom AST annotations that clients can dynamically reload when the AST changes.",
      "description_length": 333,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Functions",
      "library": "frama-c-server.core",
      "description": "This module provides operations to iterate over, index, and store kernel functions using a stateful array structure. It works with `Frama_c_kernel.Cil_types.kernel_function` values, enabling direct access via string keys. Concrete use cases include managing collections of kernel functions during static analysis and associating them with unique identifiers for efficient lookup and traversal.",
      "description_length": 393,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States.Value-Datatype",
      "library": "frama-c-server.core",
      "description": "This module defines a synchronized value type equipped with standard operations including equality, comparison, hashing, and pretty printing. It works with a specific datatype `Datatype.t` and provides functionality for deep copying values, checking membership within projects, and describing the type structure. Concrete use cases include managing and comparing analysis states in a server-client setup, ensuring consistent value representation across different contexts.",
      "description_length": 472,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Index",
      "library": "frama-c-server.core",
      "description": "This module extends a data type with indexed access to value identifiers, supporting operations to convert values to and from JSON, retrieve identifiers, and look up or remove indexed items. It works with a concrete type `t` and an associated `tag` type representing identifiers. Use this module when managing a collection of uniquely identifiable data items that need efficient retrieval and JSON serialization.",
      "description_length": 412,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Kernel_function_set",
      "library": "frama-c-server.core",
      "description": "This module organizes and manipulates sets of kernel functions using aliases and categories, supporting dynamic updates through hooks and custom serialization. It operates on sets of functions with standard set operations, alias resolution, and category-based grouping, while child modules provide structured data types for deep copying and structural inspection, category management for parameter interpretation, and string-based parameter handling with validation. It enables tracking and transforming function sets during static analysis, configuring function behavior based on categories, and managing server plugin options with runtime-modifiable, validated string parameters. Example uses include defining analysis scopes, enabling/disabling function groups, and synchronizing command-line settings with internal plugin state.",
      "description_length": 832,
      "index": 509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Config_dir",
      "library": "frama-c-server.core",
      "description": "This module manages the configuration directory for a server plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include setting up plugin-specific storage locations, accessing configuration files, or ensuring directory structures exist before writing plugin data.",
      "description_length": 417,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Tag",
      "library": "frama-c-server.core",
      "description": "Handles serialization and deserialization of package tag information using JSON. Converts between JSON values and the `tagInfo` type, ensuring data consistency during transmission. Useful for persisting or transmitting package metadata such as version tags and dependencies.",
      "description_length": 274,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jtriple",
      "library": "frama-c-server.core",
      "description": "Encodes and decodes JSON data for a triple type composed of three distinct modules. Converts between JSON representations and tuples of types A, B, and C. Useful for handling structured JSON payloads where each component of the triple corresponds to a specific data type.",
      "description_length": 271,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Junit",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON and a unit type representation for JUnit test data. Works with `Server.Data.json` and `Server.Data.Junit.t`, which is a unit type. Used to serialize and deserialize JUnit test results to and from JSON in the server's data encoding layer.",
      "description_length": 269,
      "index": 513,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Custom",
      "library": "frama-c-server.core",
      "description": "This module enables server plugins to define and manage custom parameter types with support for dynamic updates, value restrictions, and state tracking. It operates on custom types aliased as `t`, string lists for aliases, and parameter objects with validation rules, offering operations for equality, comparison, hashing, and pretty-printing. Submodules provide structured configuration capabilities, such as analysis settings or command-line parameters, with functions for deep copying, project membership checks, and type-safe value manipulation. Example uses include enforcing allowed value sets, handling deprecated aliases, and maintaining plugin-specific state across parameter changes.",
      "description_length": 693,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_map",
      "library": "frama-c-server.core",
      "description": "This module implements a parameter map with unique key-value associations, supporting operations to add, query, and traverse bindings while enforcing single-value constraints. It works with key and value types defined by modules `K` and `V`, offering metadata features like alias management, equality checks, serialization, and update callbacks to handle dynamic configuration changes. The string parameter submodule supports validated command-line options with state tracking, while the category submodule enables grouping and controlling parameters through named categories with dependencies. Together, they provide a structured way to manage server plugin settings, handle dynamic configuration updates, and persist state across sessions.",
      "description_length": 741,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Stmt",
      "library": "frama-c-server.core",
      "description": "This module defines operations for handling statement markers in the AST, specifically converting between JSON representations and the CIL statement type. It works with the `stmt` type from the Frama-C kernel and JSON data structures. Concrete use cases include serializing and deserializing AST statements for communication between analysis tools and external systems.",
      "description_length": 369,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Float",
      "library": "frama-c-server.core",
      "description": "This module handles float parameters with optional decimal points, converting them to OCaml floats for precise numeric representation. It supports core operations like equality, comparison, hashing, and pretty printing, enabling robust handling of server configuration options that require exact decimal input and output. Submodules extend this functionality to structured data types, allowing integration with systems expecting validated and formatted numeric values. For example, it can parse a string like \"31.0\" into a float value, compare it with another float, and print it in a human-readable format.",
      "description_length": 607,
      "index": 517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.States.Value",
      "library": "frama-c-server.core",
      "description": "This module manages synchronized values between server and client, providing operations to retrieve the current value and register callbacks for change and update events. It works with a specific data type `data` and its associated `Datatype.t` for structured updates. Concrete use cases include tracking shared state such as configuration settings or session data that must be consistent across distributed components.",
      "description_length": 419,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Map",
      "library": "frama-c-server.core",
      "description": "This module implements a map structure for key-value storage and retrieval, supporting operations to add, find, and remove entries. It works with a defined key type and arbitrary value types. Concrete use cases include managing configuration settings, routing tables, or session data indexed by unique keys.",
      "description_length": 307,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.S",
      "library": "frama-c-server.core",
      "description": "Defines a data type `t` and associated functions for converting values to and from JSON using a specific `jtype` schema. Works directly with `Server.Data.json` values and the `t` type it introduces. Used to encode and decode structured data for transmission or storage, ensuring compatibility with a predefined JSON schema.",
      "description_length": 323,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Enum",
      "library": "frama-c-server.core",
      "description": "This module manages enumerations as finite variant types with structural equality, enabling strict value constraints for server plugin options. It supports setting, retrieving, and monitoring values, along with command-line parsing, default assignment, and Frama-C integration. The child module enhances these capabilities with comparison, hashing, pretty-printing, and project-based membership checks, while providing exhaustive value lists and string conversions. Together, they enable robust state management, typed configuration, and consistent handling of closed enumerations across analyses.",
      "description_length": 597,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.AutoLog",
      "library": "frama-c-server.core",
      "description": "This module manages automatic logging behavior in a server monitor system, centering on a boolean parameter that can be toggled, tracked, and persisted across sessions. It integrates with a command-line interface, notifies on state changes, and defines structured data operations through its child module, which supports comparison, deep copying, and type-safe manipulation of log configurations. Use cases include dynamically enabling or disabling log monitoring at runtime, comparing log settings for consistency, and safely duplicating configuration data for plugin operations. The combined interface allows both high-level control and low-level data management for logging systems.",
      "description_length": 685,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jtext",
      "library": "frama-c-server.core",
      "description": "Handles rich text encoding and decoding using JSON. Converts between JSON values and rich text structures for storage or transmission. Useful when serializing document content with formatting metadata.",
      "description_length": 201,
      "index": 523,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Filepath_map",
      "library": "frama-c-server.core",
      "description": "This module manages a hierarchical map associating file paths with arbitrary values, supporting atomic updates, change notifications, and synchronization for project-scoped state. It uses a trie-based structure for efficient path-based lookups, enabling operations like insertion, iteration, and prefix matching, while handling aliased keys and metadata such as deprecation. The module supports custom marshaling and dynamic reloading, making it suitable for server plugin configurations and file-scoped option management. It integrates with configuration parameter handling, allowing validation, category-based grouping, and tracking of runtime changes across file-based and string-valued settings.",
      "description_length": 699,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Doc",
      "library": "frama-c-server.core",
      "description": "This module manages server plugin configuration options using `Frama_c_kernel.Filepath.t`, enabling value setting and retrieval, project-specific state tracking, and command-line interface integration through help printing and marshaling. It supports validation workflows, such as checking empty file paths, and facilitates dynamic behavior via hooks for value changes and alias handling. The child module enhances this functionality by providing operations for handling datatype representations, including equality, comparison, hashing, and pretty-printing, which are essential for comparing and serializing datatypes in configuration workflows. Together, they enable persistent configuration management, CLI-driven option parsing, and structured documentation generation from server plugin data.",
      "description_length": 797,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jfloat",
      "library": "frama-c-server.core",
      "description": "Handles conversion between float values and JSON representations. Works directly with `float` and `json` types. Used to serialize and deserialize floating-point numbers when communicating with clients or storing data in JSON format.",
      "description_length": 232,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jbool",
      "library": "frama-c-server.core",
      "description": "This module encodes and decodes boolean values to and from JSON. It provides `of_json` and `to_json` functions for converting between JSON representations and OCaml boolean values. Use this module when handling boolean data in JSON format, such as parsing API requests or serializing responses.",
      "description_length": 294,
      "index": 527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Jpair",
      "library": "frama-c-server.core",
      "description": "Encodes and decodes JSON data for pairs of values, converting between a JSON object and a tuple of two values. Works with any two data types that have their own JSON encodings. Useful for handling structured JSON responses where two related values are transmitted together, such as key-value pairs or coordinate points.",
      "description_length": 319,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Lval",
      "library": "frama-c-server.core",
      "description": "This module represents and manipulates l-value markers in the AST, specifically tracking memory locations and their associated program points. It provides operations to convert markers to and from JSON, check membership, and retrieve l-value data. Use cases include analyzing memory accesses and tracking variable assignments during static analysis.",
      "description_length": 349,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_list",
      "library": "frama-c-server.core",
      "description": "This module provides a structured way to manage and manipulate string lists as configuration or parameter values in a server plugin environment. It supports core operations like equality checks, comparison, hashing, and pretty-printing, while also enabling deep copying and project membership validation. Submodules extend this functionality to handle parameter categories, allowing configuration of behaviors for special values like `@none`, `@default`, and `@all`, and providing specialized handling for string list-based options in plugin-driven analysis tools. Example uses include defining default parameter sets, enabling all parameters with specific accessors, or mapping `@all` to a custom category for dynamic configuration.",
      "description_length": 733,
      "index": 530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_map",
      "library": "frama-c-server.core",
      "description": "This module organizes string-keyed data structures with rich metadata, supporting atomic updates, change tracking, and introspection for managing server configurations and plugin parameters. It provides core operations for mapping strings to values, validating and serializing parameters, and defining categories that control behavior, with data types that include maps, parameter sets, and category descriptors. You can use it to enforce constraints on server state, manage dynamic configurations with validation, and structure plugin parameters with visibility and deprecation controls. Submodules extend this functionality for string-specific handling, general polymorphic maps, and categorized parameter management.",
      "description_length": 719,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.State_dir",
      "library": "frama-c-server.core",
      "description": "This module manages the state directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include storing and accessing plugin-specific state files, such as caches or logs, in a controlled directory structure.",
      "description_length": 369,
      "index": 532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_ast.Marker",
      "library": "frama-c-server.core",
      "description": "This module serializes and deserializes marker data to and from JSON, using a unique tag system. It provides functions to convert between JSON representations and marker objects, and to retrieve markers by their memoized unique identifier. Typical use cases include persisting marker information across sessions and resolving markers from their string identifiers during analysis.",
      "description_length": 380,
      "index": 533,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.Static",
      "library": "frama-c-server.core",
      "description": "This module implements an indexer for mapping integer identifiers to keys from module `M`, with JSON serialization and deserialization capabilities. It supports lookups by integer ID, removal, and clearing of indexed entries, all operating on a global index table. Concrete use cases include managing static project-agnostic identifiers for configuration items or shared resources.",
      "description_length": 381,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jmarkdown",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON and a specific markdown text type used for documentation or structured text representation. Works directly with `Frama_c_kernel.Markdown.text` and JSON values. Used to serialize and deserialize markdown content for transmission or storage in JSON format.",
      "description_length": 286,
      "index": 535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Cache_dir",
      "library": "frama-c-server.core",
      "description": "This module manages the cache directory for a plugin, providing functions to retrieve or create directories and files within the cache. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports conditional path creation. Use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 359,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_multiple_map",
      "library": "frama-c-server.core",
      "description": "This module manages parameter maps with multibindings, allowing multiple values per key using types defined by `K` and `V`. It supports dynamic updates, change hooks, alias resolution, and custom serialization, enabling use cases like server plugin configurations and project-specific immutability enforcement. The string parameter submodule provides a concrete implementation for command-line arguments with parsing, validation, and pretty printing, while the category submodule introduces named groupings like `@default` and `@all` for organizing parameter sets. Together, these components allow structured, typed, and extensible configuration management with support for constraints, logging, and hierarchical state persistence.",
      "description_length": 731,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Request.Output",
      "library": "frama-c-server.core",
      "description": "Handles the conversion of request responses into structured JSON format for transmission. Works with the `t` type and `Server.Request.json` to serialize data. Used to ensure responses conform to the expected JSON schema defined in the package.",
      "description_length": 243,
      "index": 538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Data.TaggedType",
      "library": "frama-c-server.core",
      "description": "This module defines a data type `t` that represents values tagged with unique integer identifiers. It provides the `id` function to retrieve the identifier from a value. Useful for tracking or comparing data elements in systems requiring stable, unique keys.",
      "description_length": 258,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jlist",
      "library": "frama-c-server.core",
      "description": "Handles JSON encoding and decoding for lists of values, converting between JSON representations and OCaml lists. Works directly with `Server.Data.json` and `A.t` list types. Useful for serializing and deserializing list-based data structures in network communication or storage systems.",
      "description_length": 286,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.String_set",
      "library": "frama-c-server.core",
      "description": "This module manages dynamic sets of strings for server configuration, supporting membership testing, iteration, and state manipulation through hooks and serialization. It works with `Frama_c_kernel.Datatype.String.Set.t` to handle mutable string collections, offering utilities for alias resolution, project-specific state tracking, and integration with Frama-C's typed parameter system. The module organizes parameters into categories such as `@none`, `@default`, and `@all`, enforces value constraints through validation-aware command-line parameters, and provides a structured string set type with comparison, hashing, and project-filtered membership checks. Use cases include maintaining server option values, defining parameter groups with dependencies, and persisting configuration state across sessions with custom update logic.",
      "description_length": 835,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Jarray",
      "library": "frama-c-server.core",
      "description": "Handles conversion between JSON arrays and OCaml arrays of a specified type. Works with `Server.Data.json` values and `A.t array` types. Converts JSON arrays to OCaml arrays using `of_json` and serializes OCaml arrays back to JSON using `to_json`. Useful for encoding and decoding array-based data structures during API request/response handling.",
      "description_length": 346,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.Enum",
      "library": "frama-c-server.core",
      "description": "This module implements an enum factory for creating tagged data types with bidirectional JSON encoding. It works with hashable values and string-based tags, supporting operations to register tags, associate values, and define prefix-based dynamic tags. Concrete use cases include defining fixed sets of labeled values with custom serialization, such as status codes, command types, or configuration options.",
      "description_length": 407,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast.Decl",
      "library": "frama-c-server.core",
      "description": "This module handles the conversion of abstract syntax tree (AST) declarations to and from JSON format. It provides functions to serialize declarations with a unique tag and retrieve them later using a memoized index. Use cases include persisting AST data for analysis tools and reconstructing declarations from stored JSON representations.",
      "description_length": 339,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.States.State",
      "library": "frama-c-server.core",
      "description": "This module defines operations for managing and synchronizing a shared state between server and client. It provides functions to set and retrieve the current state, as well as register hooks that trigger on state changes or updates. The state is represented by the `data` type, and the `Datatype` submodule encapsulates the structure and operations of the actual data being synchronized. Use cases include tracking connection status, shared configuration, or any application-specific state that must remain consistent across distributed components.",
      "description_length": 548,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data.IdentifiedType",
      "library": "frama-c-server.core",
      "description": "Represents data types annotated with unique integer identifiers. Provides a function to extract the identifier from a value. Useful for tracking or indexing instances of data types in systems like databases or network protocols.",
      "description_length": 228,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters.Make_set",
      "library": "frama-c-server.core",
      "description": "This module manages mutable sets of configuration elements with support for change tracking, aliasing, visibility rules, and deprecation, operating on `E.Set.t` collections. It enables dynamic configuration tasks like maintaining feature flags, access control lists, and versioned settings with audit trails, while integrating serialization and string representations for UI and persistence needs. Child modules extend this functionality with structured validation and transformation of string parameters, category-based organization of plugin settings, and efficient set operations over custom datatypes. Together, they support complex server configuration workflows, including CLI parsing, plugin parameter grouping, and analysis set manipulation with type-safe and project-aware filtering.",
      "description_length": 792,
      "index": 547,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Server.Server_parameters.Make_site_dir",
      "library": "frama-c-server.core",
      "description": "Builds and queries a site directory structure. Provides `get_dir` and `get_file` to retrieve subdirectories and files by name, ensuring correct type and existence. Useful for managing plugin-specific directories and resources within a server environment.",
      "description_length": 254,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package.Scope",
      "library": "frama-c-server.core",
      "description": "Manages identifier scoping for package plugins, handling reservation, declaration, and resolution of identifiers. Works with string identifiers and plugin-specific data structures. Used during package loading to ensure unique identifier allocation and proper visibility across modules.",
      "description_length": 285,
      "index": 549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Server_parameters.Make_user_dir",
      "library": "frama-c-server.core",
      "description": "This module constructs a user directory structure based on an existing parent directory and a target directory name. It provides `get_dir` and `get_file` functions to retrieve or create subdirectories and files within the user directory, with an optional flag to control path creation behavior. It operates on string identifiers and returns paths as `Frama_c_kernel.Filepath.t` values, ensuring correct handling of file and directory access under the constructed hierarchy.",
      "description_length": 473,
      "index": 550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_properties",
      "library": "frama-c-server.core",
      "description": "Manages the status of kernel properties, providing a function to reload the entire property status table. Works with internal data structures representing kernel properties and their current states. Useful for synchronizing property status after configuration changes or system updates.",
      "description_length": 286,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Jbuffer",
      "library": "frama-c-server.core",
      "description": "This module implements rich text buffers with support for structured output formatting and JSON serialization. It provides operations to create and manipulate buffers with indentation and margin settings, format values into JSON representations, and manage structured tags during formatting. Concrete use cases include generating JSON-encoded diagnostic messages, pretty-printing structured data, and building complex JSON outputs incrementally with proper formatting.",
      "description_length": 468,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Main",
      "library": "frama-c-server.core",
      "description": "This module enables handling JSON-RPC-style requests (`GET`, `SET`, `EXEC`) with support for dynamic request registration, asynchronous task scheduling, and lifecycle management via start/stop controls. It operates on a server's internal state to track activity and manage event callbacks, while interacting with JSON-encoded RPC payloads and signal handlers. It is suited for implementing network servers requiring concurrent request processing, background task execution, and responsive lifecycle events.",
      "description_length": 506,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Request",
      "library": "frama-c-server.core",
      "description": "This module provides an API for registering and managing server requests with typed inputs and outputs, supporting operations like GET, SET, and EXEC. It handles client-server communication through JSON structures, signals, and dictionaries, enabling debounced notifications and structured request/response cycles. The first child module parses and validates incoming JSON into typed request values, converting raw payloads for further processing. The second serializes responses into structured JSON, ensuring conformance to predefined schemas before transmission.",
      "description_length": 565,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_doc",
      "library": "frama-c-server.core",
      "description": "This module organizes and publishes server documentation pages grouped by chapters like protocol, kernel, or plugins. It provides functions to define pages, generate markdown content, and dump documentation to files with optional metadata. Use cases include generating structured documentation for APIs, plugins, or internal systems with cross-references and indexed sections.",
      "description_length": 376,
      "index": 555,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_project",
      "library": "frama-c-server.core",
      "description": "This module provides utilities for converting project data to and from JSON format, centered around the `Frama_c_kernel.Project.t` type. It enables serialization of project state for storage or transmission and deserialization to reconstruct projects from JSON. Operations include converting a project to a JSON object, writing it to a file, and reading and parsing JSON data back into a project. Example uses include saving analysis results to disk or sharing project data between tools via JSON.",
      "description_length": 497,
      "index": 556,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.Kernel_main",
      "library": "frama-c-server.core",
      "description": "This module provides serialization and deserialization of log events using JSON format, centered around the `Frama_c_kernel.Log.event` type. It enables conversion of log data to JSON strings for transmission or storage, and parsing of JSON strings back into structured log events. Example operations include converting a log event to a JSON string for sending over a network or reconstructing log events from stored JSON data for analysis.",
      "description_length": 439,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Server_parameters",
      "library": "frama-c-server.core",
      "description": "This module orchestrates server configuration through typed parameters, structured logging, and plugin extensibility, combining core utilities with child modules that handle specific data types and operations. It centers on server parameters like strings, integers, floats, enums, booleans, and file paths, each managed with validation, dynamic updates, and command-line integration, while supporting advanced constructs like function sets, parameter maps, and categorized options. Child modules refine this functionality with typed collections\u2014such as string sets, function declarations, and path-based configurations\u2014enabling use cases like runtime debug control, plugin option parsing, session state synchronization, and analysis scope management. Together, they form a cohesive system for building, modifying, and persisting server configurations with type safety, structured introspection, and project-aware state tracking.",
      "description_length": 928,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Data",
      "library": "frama-c-server.core",
      "description": "This module enables bidirectional JSON encoding for custom data types, supporting primitive and structured formats with robust error handling. It provides core operations for serializing and parsing booleans, integers, floats, strings, options, lists, arrays, records, enums, and maps, while submodules handle specialized use cases like JUnit test results, file paths, rich text, and package metadata. You can define type-safe records with optional fields, encode them to JSON for API responses, or decode structured payloads with precise error reporting. Additional submodules manage indexed collections, unique identifiers, and tagged data, enabling efficient storage, lookup, and transmission of complex data structures.",
      "description_length": 723,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Package",
      "library": "frama-c-server.core",
      "description": "This module orchestrates a plugin-driven package system with robust type handling, enabling type recursion checks, identifier derivation, and structured documentation in formats like Markdown. It directly supports operations on algebraic data types, records, enums, and identifier mappings, facilitating tasks such as API registration and human-readable name resolution. Submodules provide ordered map operations over `ident` keys for dependency tracking, efficient configuration aggregation, and ordered traversal, while others manage identifier lifecycle tasks like encoding, decoding, and scoping during package loading. Together, they enable workflows like generating self-referential documentation, converting type metadata into tables, and maintaining consistent identifier state across plugins.",
      "description_length": 801,
      "index": 560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server.States",
      "library": "frama-c-server.core",
      "description": "This module synchronizes values and states between server and client by registering signals, states, and arrays with callbacks and metadata. It supports structured data types like tables, hashtables, and individual values, each with operations for equality, comparison, hashing, and pretty printing, and works with project skeletons for membership testing and deep copying. You can use it to track analysis results, manage shared configuration, or synchronize dynamic collections like tables backed by hashtables. Submodules provide specialized handling for tabular data, key-value stores, and atomic values, enabling consistent state propagation and cross-component updates in distributed static analysis workflows.",
      "description_length": 716,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Server.Kernel_ast",
      "library": "frama-c-server.core",
      "description": "The module defines core AST components like positions, declarations, statements, l-values, and kernel instructions, along with operations for manipulating these structures in server-side analysis and compilation tasks. Submodules handle JSON serialization of AST elements, pretty-printing for debugging, tag management for node identification, and metadata registration for custom annotations. Specific capabilities include converting kernel instructions to JSON, pretty-printing CIL and ACSL nodes with customizable formatting, and tracking source code positions with structured file data. Additional functionality supports efficient kernel function storage, statement and l-value manipulation, and persistent marker handling across analysis sessions.",
      "description_length": 752,
      "index": 562,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Server",
      "library": "frama-c-server.core",
      "description": "This module builds a structured server environment for managing analysis workflows, configuration, and communication. It centers on typed data handling, JSON serialization, and dynamic state synchronization across components. Key data types include kernel properties, log events, project states, and richly structured values like ASTs, configuration parameters, and RPC requests. Operations enable reloading property states, formatting diagnostic output, handling JSON-RPC interactions, synchronizing client-server state, and persisting data via JSON. Example uses include serving analysis results over JSON-RPC, logging events in structured format, generating API documentation, and synchronizing configuration changes across distributed analysis components.",
      "description_length": 759,
      "index": 563,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.Subst",
      "library": "qed",
      "description": "Implements term substitution with support for variable binding, term rewriting, and scoped filtering. Operates on logic expressions (`term`) and variable sets (`Vars.t`), maintaining a pool of bound variables. Useful for implementing capture-avoiding substitution in lambda calculus or formal logic systems.",
      "description_length": 307,
      "index": 564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.Tau",
      "library": "qed",
      "description": "Implements structural equality, comparison, and pretty-printing for logic expressions. It operates directly on the `tau` type, providing hash computation, deep equality checks, and human-readable formatting. Useful for theorem proving tasks where expression identity and visualization are critical.",
      "description_length": 298,
      "index": 565,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export.Make.Env",
      "library": "qed",
      "description": "This module manages a binding environment for terms during code export, tracking variable usage and providing fresh variable names. It supports defining and unfolding term bindings, checking shared or shareable terms, and iterating over bound variables. Concrete use cases include managing variable capture and substitution when generating code from formal proofs.",
      "description_length": 364,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export.Make.TauMap",
      "library": "qed",
      "description": "This module implements ordered key-value maps for elements with keys of type `T.tau`, supporting efficient insertion, deletion, and lookup operations alongside ordered traversal (e.g., ascending/descending iteration, range queries). It provides functional transformations (e.g., `map`, `filter`), structural manipulations (e.g., `merge`, `split`), and bulk sequence-based updates (e.g., `of_seq`, `add_seq`), making it suitable for applications requiring sorted data aggregation, incremental map construction, or ordered collection processing.",
      "description_length": 543,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.STset",
      "library": "qed",
      "description": "This module offers an immutable set structure for logic terms ordered by structural comparison, supporting standard operations like union, intersection, and ordered traversal while enabling efficient extremum retrieval. It works with `term` elements and `Stdlib.Seq.t` sequences, emphasizing conversions between sets and ordered sequences for bulk processing or iterative analysis. Designed for scenarios requiring predictable ordering (e.g., formal proof term management), it prioritizes structural consistency over merge efficiency.",
      "description_length": 534,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore.Make.Env",
      "library": "qed",
      "description": "This module manages a term-sharing environment for an exportation engine, providing operations to track used identifiers, generate fresh names, define and unfold terms, and determine shareable expressions. It works with a term type `T.term` and maintains internal state for name sanitization and term sharing. Concrete use cases include managing variable bindings during translation to Why-3 or Alt-Ergo, ensuring unique naming, and optimizing term representation through sharing.",
      "description_length": 480,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make.Map",
      "library": "qed",
      "description": "This module provides operations for constructing, transforming, and combining key-value associations using balanced trees, supporting efficient insertion, lookup, and ordered traversal. It works with polymorphic maps (`Map.t`) where keys are compared using a parameterized type's equality and ordering, and values can be arbitrary. Typical use cases include merging hierarchical data structures, aggregating statistics with key collision handling, and maintaining sorted key-value sequences for deterministic iteration.",
      "description_length": 519,
      "index": 570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.STmap",
      "library": "qed",
      "description": "This module implements ordered maps with keys as logic terms, supporting structural ordering and operations like ordered traversal, merging, and bulk transformations using sequences. It provides efficient key-based manipulations (insertion, lookup, filtering) and ordered iteration, with use cases in symbolic computation or theorem proving where structured key ordering and precise map combination are required. The design prioritizes correctness over performance for complex operations, handling optional values and physical equality checks during transformations.",
      "description_length": 566,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Term",
      "library": "qed",
      "description": "Implements logic expression manipulation with hashing, equality checks, and comparison. Provides pretty-printing for terms and debugging output. Used to represent and operate on symbolic logic structures in theorem proving or formal verification workflows.",
      "description_length": 256,
      "index": 572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make.Vars",
      "library": "qed",
      "description": "This module provides operations for managing sets of logic variables, supporting standard set manipulations such as union, intersection, difference, membership checks, and transformations with filtering. It operates on the abstract type `Vars.t`, representing a collection of `var` elements (with `Vars.elt` as the element type), and includes utilities for partitioning, size computation, and dependency analysis. These capabilities are particularly useful for tasks like tracking free variables in logical expressions, analyzing variable overlaps during proof construction, or optimizing variable substitutions in term rewriting systems.",
      "description_length": 638,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make.Set",
      "library": "qed",
      "description": "This module supports standard set operations including creation, insertion, membership testing, and algebraic operations like union and intersection. It works with a set type `Set.t` containing elements of type `Set.elt`, offering functions for traversal, filtering, and transformation through mapping or list conversion. Typical applications include managing collections of unique elements, performing set-based computations, and applying element-wise transformations while maintaining set invariants.",
      "description_length": 502,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_why3.Make.Env",
      "library": "qed",
      "description": "This module manages a stateful environment for generating and tracking unique, sanitized identifiers during the export of terms to Why-3. It supports operations to create, copy, and reset the environment, check identifier usage, generate fresh names, and register or iterate over defined terms. It is used to ensure consistent naming and avoid collisions when translating terms with binders or shared subterms.",
      "description_length": 410,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Vmap",
      "library": "qed",
      "description": "This structure implements a polymorphic map for variable-indexed data, supporting key-value manipulation, transformation via higher-order functions, and set-theoretic operations. It operates on key-value collections where keys are logical variables, enabling efficient merging, differencing, and relational analysis between maps with customizable conflict resolution. Typical applications include managing variable bindings in logical expressions, combining symbolic environments, and analyzing overlaps or dependencies in variable-centric data.",
      "description_length": 545,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Tmap",
      "library": "qed",
      "description": "This module implements ordered associative containers mapping logic terms to values, supporting efficient insertion, lookup, and deletion alongside advanced operations like merging, differencing, and custom key-wise combination. The underlying `Tmap.t` structures leverage term-based ordering for high-performance comparisons and transformations, particularly beneficial in symbolic computation tasks such as theorem proving or logical expression manipulation where terms serve as primary keys.",
      "description_length": 494,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Tset",
      "library": "qed",
      "description": "This module offers non-structural set operations for logic terms, including membership checks, union, intersection, difference, and predicate-based partitioning, alongside utilities for size computation, element transformation, and list extraction. It operates on a set type optimized for machine-level comparison and merging efficiency, using logic expressions as elements. Designed for scenarios requiring high-performance manipulation of symbolic representations, such as formal verification or automated reasoning workflows where structural equivalence is decoupled from computational speed.",
      "description_length": 595,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term.Make.Var",
      "library": "qed",
      "description": "This module manages logic variables with operations for hashing, equality checks, comparison, and pretty-printing. It works with the `Var.t` type, representing variables in logic expressions. Concrete use cases include variable manipulation in theorem proving, term rewriting, and logical reasoning tasks.",
      "description_length": 305,
      "index": 579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Listset.Make",
      "library": "qed",
      "description": "This module implements list-backed set operations including union, intersection, difference, and factorization of element relationships between sets. It works with a list-based set type `t` containing elements of type `elt`, supporting transformations like filtering, folding, and partitioning. The factorize function uniquely decomposes two sets into their distinct left/right components and shared intersection, while multi-set union/intersection functions aggregate collections of sets for data consolidation tasks.",
      "description_length": 518,
      "index": 580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Pool.Type",
      "library": "qed",
      "description": "This module defines a core type `t` with operations for equality checking and comparison. It includes a dummy value for `t`, a function to test equality between two values, and a function to compare them. These primitives support use cases like managing unique identifiers or comparing abstract values in data structures.",
      "description_length": 321,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listset.Elt",
      "library": "qed",
      "description": "This module defines the element type and operations for a set-like structure implemented over lists. It provides equality and comparison functions required for membership testing and ordering elements. Concrete use cases include managing collections of unique values where order does not matter, such as tracking identifiers or filtering duplicates in list-based data processing.",
      "description_length": 379,
      "index": 582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Kind.MakeTau",
      "library": "qed",
      "description": "This module implements hash, equality, comparison, and pretty-printing operations for a datatype combining logic types from modules F and A. It supports concrete operations like generating unique name hints, formatting values for debugging, and comparing or hashing structured logic data. Use this when working directly with logic expressions that require canonical string representations, structural equality checks, or formatter integration.",
      "description_length": 443,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-ADT",
      "library": "qed",
      "description": "This module defines an algebraic data type for terms in a logical system, supporting structural equality, comparison, and hashing. It provides operations to pretty-print terms using OCaml's format system and to generate base names for fresh name generation. These capabilities are used directly in implementing term manipulation, substitution, and normalization routines within a theorem proving or logic processing system.",
      "description_length": 423,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export.Make",
      "library": "qed",
      "description": "This module implements an export engine for transforming and serializing formal proof structures, enabling the mapping of type variables and function symbols, management of export environments, and definition of triggers and type definitions for code generation. It coordinates with a binding environment module to track term variables and avoid capture during code generation, and with an ordered map module to efficiently manage and traverse key-value structures with typed keys. Main data types include export environments, type definitions, and ordered maps supporting operations like insertion, deletion, and ordered traversal. You can use it to generate target-language code from logical terms, manage variable bindings during export, or process sorted collections with functional transformations.",
      "description_length": 803,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore.Make",
      "library": "qed",
      "description": "This module generates exportation logic for Why-3 and Alt-Ergo by processing triggers, type definitions, and symbolic variables, mapping internal representations to target formats. It works with terms, functions, and types to support translation of proof obligations and declarations during formal verification. The term-sharing environment submodule tracks identifiers, generates fresh names, defines and unfolds terms, and identifies shareable expressions using the `T.term` type. Together, they enable efficient, correct translation with optimized term representation and proper name management.",
      "description_length": 598,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Field",
      "library": "qed",
      "description": "This module defines operations for record fields, including hashing, equality checking, comparison, and pretty-printing. It works with a concrete type `t` representing fields and includes a function to retrieve the sort of a field. Use cases include managing and comparing fields in record types, particularly during debugging and serialization.",
      "description_length": 345,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergemap.Key",
      "library": "qed",
      "description": "This module defines the interface for keys used in a merging map structure. It requires implementations for hashing, equality checking, and comparison operations on a type `t`. These functions enable efficient key-based data management in associative containers like hash tables or balanced trees.",
      "description_length": 297,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Fun",
      "library": "qed",
      "description": "This module defines operations for manipulating function terms, including hashing, equality checking, comparison, and pretty-printing. It works with the abstract type `t` representing function terms, along with related types like `Qed.Logic.sort` and `Qed.Logic.category`. Concrete use cases include term normalization, type checking, and debugging symbolic expressions in a theorem proving context.",
      "description_length": 399,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listmap.Key",
      "library": "qed",
      "description": "This module defines the key operations for comparing and equating elements used as keys in list-association maps. It works with the abstract type `t` representing keys, providing `equal` and `compare` functions for equality checks and ordering. Concrete use cases include enabling key-based lookups, insertions, and merges in list-association structures.",
      "description_length": 354,
      "index": 590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Idxmap.Make",
      "library": "qed",
      "description": "The module provides associative map operations for key-based data manipulation, including insertion, lookup, and removal, along with higher-order functions for mapping, filtering, and folding over key-value pairs. It supports set-theoretic operations like union and intersection, working with maps indexed by keys of type `K.t` and arbitrary value types. This is suited for scenarios requiring precise key management, such as environment tracking or structured data merging.",
      "description_length": 474,
      "index": 591,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Collection.Map",
      "library": "qed",
      "description": "This module provides key-centric data manipulation capabilities for associative collections, supporting insertion, lookup, filtering, and bidirectional traversal over key-value pairs with optional ordering guarantees. It operates on map structures that associate keys of any ordered type with values of arbitrary type, offering domain extraction to retrieve key sets and enabling value transformations that preserve or modify key associations. The interface is particularly suited for scenarios requiring precise key management, such as environment tracking in compilers, configuration merging, or implementing finite-state systems where key presence and value coalescing determine system behavior.",
      "description_length": 698,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxmap.IndexedKey",
      "library": "qed",
      "description": "This module defines a key type for maps where each key is associated with a unique integer identifier. It supports operations to create, compare, and retrieve keys based on their integer identity. It is used to manage key-value associations in indexed maps where fast lookups and identity-based equality are required.",
      "description_length": 317,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Cache.Unary",
      "library": "qed",
      "description": "Implements a unary cache that stores and retrieves values based on a single key type. It supports cache creation with a specified size, clearing all entries, and computing or retrieving cached values. This module is useful for optimizing repeated computations where a single input type maps to a computed result.",
      "description_length": 312,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset.IndexedElements",
      "library": "qed",
      "description": "Handles element indexing and set membership operations using unique integer identifiers. Works with a set type where each element has a distinct `int` identifier, supporting efficient addition, lookup, and removal by index. Useful for managing dynamic collections of objects with stable IDs, such as tracking active connections or cached resources.",
      "description_length": 348,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listmap.Make",
      "library": "qed",
      "description": "This module implements a polymorphic map using a list-association structure with key-based operations like insertion, lookup, and transformation, relying on a user-defined key module for ordering and equality. It supports advanced set-like interactions between maps, including union, intersection, difference, and custom merging strategies that combine values from overlapping keys. Typical applications include managing ordered key-value collections, merging hierarchical data, or performing algebraic operations on dictionaries where key relationships drive aggregation logic.",
      "description_length": 578,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Make",
      "library": "qed",
      "description": "This module derives hash, equality, and comparison operations for a type `t` based on module `A`, enabling its use as keys in associative structures. It forms the basis for creating sets and maps with `A.t` elements, supporting efficient lookups, insertions, and ordered traversals through its submodules. The first submodule implements balanced tree-based maps with polymorphic keys and arbitrary values, allowing operations like merge, fold, and ordered iteration. The second submodule provides set functionality with standard algebraic operations, membership testing, and transformations, ideal for managing unique elements and performing set-based computations.",
      "description_length": 665,
      "index": 597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export_why3.Make",
      "library": "qed",
      "description": "This module implements a specialized export engine for translating formal proofs into Why-3 format, operating on proof terms, triggers, and type definitions using the `T` module for term and type representation. It coordinates with its child module to manage a stateful environment that generates and tracks unique, sanitized identifiers, ensuring consistent naming and avoiding collisions during translation. Main data types include proof terms and types from `T`, along with environment state structures that track identifier usage and definitions. Users can generate Why-3 input files from internal proof structures, create fresh identifiers, register defined terms, and iterate over tracked definitions during export.",
      "description_length": 721,
      "index": 598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Term-Var",
      "library": "qed",
      "description": "This module represents logical term variables with operations to access their properties, including their sort, name, and string representation. It supports comparisons, hashing, and pretty-printing for use in theorem proving and formal verification tasks. Concrete use cases include variable management in logical expressions and debugging output generation.",
      "description_length": 359,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition.Make",
      "library": "qed",
      "description": "This module implements union-find-based partition structures with operations to merge elements, check equivalence, and retrieve members of equivalence classes. It works with elements of type `E.t` and sets of elements using `S.t`. Concrete use cases include grouping elements into disjoint sets, tracking connected components in graphs, and efficiently managing dynamic equivalences.",
      "description_length": 383,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-STmap",
      "library": "qed",
      "description": "This module implements maps over structurally ordered `term` keys, supporting insertion, deletion, ordered traversal, and merging operations that preserve key ordering. It provides efficient ordered access patterns (e.g., `min_binding`, `find_first`) and transformations via folds, filters, and sequence-based construction, while prioritizing structural consistency over high-performance random access. Use cases include maintaining term-indexed data with guaranteed order preservation during iteration, merging hierarchical term structures, and batch processing of ordered key-value sequences.",
      "description_length": 594,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pool.Make",
      "library": "qed",
      "description": "Implements a variable management system with unique identifier assignment, equality checks, and pretty-printing for variables parameterized over a type. Maintains a pool of variables with operations to add, create fresh variables with scoped names, and generate alpha-equivalent copies. Useful for managing symbolic variables in formal verification or compiler intermediate representations.",
      "description_length": 390,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Term.Make",
      "library": "qed",
      "description": "This module enables the construction and manipulation of logical terms with binders, arithmetic expressions, and symbolic data structures, supporting operations like term traversal, type inference, and simplification. It provides core data types including terms (`term`, `lc_term`), variables (`var`, `Vars.t`), types (`tau`, `sort`), and structured collections (`Tset`, `Tmap`, `STset`), along with operations for constants, records, and quantifiers. Submodules handle term substitution, structural equality, ordered sets and maps, variable sets, and polymorphic maps, enabling capture-avoiding substitution, efficient term comparison, ordered traversal, and variable binding management. Example uses include theorem proving, symbolic manipulation, and formal verification tasks such as tracking free variables, simplifying logical expressions, and managing structured term environments.",
      "description_length": 888,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset.S",
      "library": "qed",
      "description": "This module provides operations for managing sets of indexed elements through functional transformations, including membership checks, insertion, deletion, union, intersection, and difference operations, along with predicates for set comparison and element filtering. It works with an immutable set structure (`t`) and its element type (`elt`), implemented using Patricia trees for efficient access and memory safety. It is particularly suited for scenarios requiring deterministic manipulation of dynamic sets with guaranteed immutability, such as symbolic computation or persistent data management.",
      "description_length": 600,
      "index": 604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Pretty.Make",
      "library": "qed",
      "description": "This module implements a pretty-printing environment for terms and types, supporting operations to track variable bindings, generate fresh names, and print terms with proper scoping. It works with terms and types from the `T` module, maintaining an environment that maps variables to their printed representations. Concrete use cases include formatting lambda terms with bound variables, pretty-printing type annotations, and generating human-readable output for expressions during proof display or debugging.",
      "description_length": 509,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Engine.Env",
      "library": "qed",
      "description": "Maintains a context for term definitions and variable management, supporting operations to create, copy, and clear environments. It tracks used variable names, generates fresh names, and stores term bindings with support for sharing and unfolding. Used during term manipulation to ensure unique naming and manage indexed variables.",
      "description_length": 331,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition.Elt",
      "library": "qed",
      "description": "This module represents elements of a partition, supporting equality and comparison operations. It works with the abstract type `t` from the parent `Qed.Partition` module, enabling direct manipulation of partition elements. Concrete use cases include managing disjoint sets with efficient union and find operations.",
      "description_length": 314,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Term-Tset",
      "library": "qed",
      "description": "This module provides set operations like union, intersection, and difference, along with transformation functions for filtering and mapping over term collections. It operates on `Tset.t` structures, which use machine-dependent comparison to enable fast membership checks and efficient merges, supporting tasks like partitioning and cardinality analysis in non-structural term processing scenarios.",
      "description_length": 397,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition.Set",
      "library": "qed",
      "description": "This module implements union-find-based partition sets with operations for creating single-element sets, iterating over elements, and computing unions and intersections. It works with abstract element types to manage disjoint sets efficiently. Use it to track dynamic connectivity or equivalence classes in algorithms like Kruskal\u2019s or path compression problems.",
      "description_length": 362,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergeset.Make",
      "library": "qed",
      "description": "This module provides functional set operations for merging, transforming, and querying immutable collections of ordered elements. It works with list-based map structures (`t`) where elements (`elt`) are comparable and support sorted traversal, enabling efficient membership checks, union/intersection/difference calculations, and partitioning. Specific use cases include declarative data aggregation, version-controlled state merging, and algorithms requiring ordered set manipulation without side effects.",
      "description_length": 506,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Tau",
      "library": "qed",
      "description": "This module defines operations for working with type terms, including hashing, equality checking, comparison, and pretty-printing. It supports data types representing type expressions, providing functions to generate string representations for debugging and fresh name generation. Concrete use cases include managing type variables during type inference and facilitating type-level computations in a theorem prover or type checker.",
      "description_length": 431,
      "index": 611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Term-Vars",
      "library": "qed",
      "description": "This module supports manipulation of variable sets through operations like union, intersection, difference, and subset checks, along with functional transformations such as mapping, filtering, and partitioning. It operates on a set-like structure (`t`) containing elements of type `var`, enabling efficient querying and processing. These capabilities are particularly useful in logical reasoning tasks requiring precise variable management, such as formal verification or symbolic computation systems.",
      "description_length": 501,
      "index": 612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Partition.Map",
      "library": "qed",
      "description": "Implements union-find with path compression and rank-based merging to efficiently manage disjoint sets. It uses a map-based structure to associate each key with a representative element and track set membership. This module is ideal for dynamic connectivity problems, such as tracking connected components in a graph during incremental edge additions.",
      "description_length": 351,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Vmap",
      "library": "qed",
      "description": "This module provides associative map operations for variable-indexed polymorphic data, supporting key-based insertion, lookup, deletion, and transformations with higher-order functions like fold, filter, and custom merge combinators. It works with finite maps (`Vmap.t`) that bind variables (`var`) to arbitrary values, enabling precise manipulation of key-value pairs through callbacks and comparison logic. Such structures are useful for managing dynamic variable environments, symbolic substitutions, or constraint propagation in logical reasoning systems.",
      "description_length": 559,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Term",
      "library": "qed",
      "description": "This module implements operations for comparing, hashing, and pretty-printing terms. It provides `equal`, `compare`, and `hash` for structural equality and ordering, along with `pretty` for formatted output and `debug` for string-based debugging. These functions support efficient term manipulation in contexts like theorem proving or symbolic computation.",
      "description_length": 356,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.T",
      "library": "qed",
      "description": "This module defines a collection type that supports efficient membership testing, insertion, and union operations. It works with elements that have hash, equality, and comparison functions defined, such as integers or custom comparable types. It is suitable for use cases like tracking unique elements in a dataset or performing set arithmetic with predictable performance.",
      "description_length": 373,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term",
      "library": "qed",
      "description": "This module provides operations for constructing and manipulating logical terms, arithmetic expressions, and symbolic representations in a typed logical framework. It works with terms, variables, abstract data types, and structures like records and binders (lambda, quantifiers), supporting use cases such as theorem proving, term rewriting, and symbolic logic systems. Key functionalities include constant-time term construction, decision procedures for equality/ordering, binder management, and term analysis for sharing or structural properties, often leveraging auxiliary types like functions, fields, and type representations.",
      "description_length": 631,
      "index": 617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Idxmap.S",
      "library": "qed",
      "description": "This module supports key-indexed value management with operations including insertion, lookup, deletion, and traversal, along with advanced merging and differencing of maps using custom combination logic. It works with polymorphic map structures where keys are indexed, enabling key-aware transformations, filtering, and folding operations. Typical applications involve handling associative data with dynamic key ranges, such as symbol table management or hierarchical data merging.",
      "description_length": 482,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergeset.Elt",
      "library": "qed",
      "description": "This module defines the element type and core operations for a merging set structure. It includes equality, comparison, and hashing functions required to manage elements within the set. It is used to represent and manipulate collections of unique elements where merging behavior is defined by the provided type and functions.",
      "description_length": 325,
      "index": 619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Collection.S",
      "library": "qed",
      "description": "This module defines a collection interface with hash, equality, and comparison operations for a type `t`, alongside associated `Map` and `Set` submodules that implement keyed collections and ordered unique elements, respectively. It works directly with the abstract type `t`, supporting structured data like strings, integers, or custom algebraic types. Concrete use cases include building dictionaries or sets with custom key types, such as mapping configuration keys to values or tracking unique identifiers in a system.",
      "description_length": 522,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Data",
      "library": "qed",
      "description": "This module defines an abstract data type `t` with operations for hashing, equality checking, comparison, and pretty-printing. It supports structured data manipulation by providing concrete functions to uniquely identify, compare, and display values. Use cases include managing symbolic expressions, handling unique identifiers, and facilitating debugging through readable string representations.",
      "description_length": 396,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-STset",
      "library": "qed",
      "description": "This module provides structural set operations for ordered collections of terms, supporting standard manipulations like union, intersection, and difference alongside transformations such as `map`, `filter`, and ordered iteration. It works with abstract sets (`t`) of ordered elements (`elt`), enabling efficient membership checks and comparisons using monotonic predicates, while prioritizing structural consistency over performance. Specific use cases include processing hierarchically ordered data and scenarios requiring non-linear merges or sequence-based construction from iterables.",
      "description_length": 588,
      "index": 622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Cache.S",
      "library": "qed",
      "description": "Implements hash and equality operations for a type `t`. Provides `hash` for generating integer hashes and `equal` for comparing values of type `t`. Useful in scenarios requiring hashed containers or equality checks, such as hash tables or set implementations.",
      "description_length": 259,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Function",
      "library": "qed",
      "description": "This module defines operations for working with logical functions, including comparing, hashing, and pretty-printing them. It provides access to a function's category, parameter sorts, and result sort, enabling precise type and structure inspection. Use it when analyzing or manipulating logical expressions, such as during theorem proving or symbolic computation.",
      "description_length": 364,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset.Make",
      "library": "qed",
      "description": "This implementation provides creation, modification, and comparison operations for sets of uniquely indexed elements, including union, intersection, difference, and membership checks. It operates on an abstract set type `t` containing elements of a custom `elt` type, structured internally as a Patricia trie for efficient access and storage. These capabilities are particularly useful in scenarios requiring high-performance set operations, such as data analysis pipelines or algorithms managing sparse, hierarchical, or large-scale datasets.",
      "description_length": 543,
      "index": 625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Variable",
      "library": "qed",
      "description": "This module represents bound variables in a logical context, providing operations to access their base names and associated sorts. It supports comparisons, hashing, and pretty-printing for use in theorem proving and formal verification tasks. Concrete use cases include managing variable bindings in proof terms and logical expressions.",
      "description_length": 336,
      "index": 626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Term-Field",
      "library": "qed",
      "description": "This module defines operations for comparing, hashing, and pretty-printing field values, along with retrieving their associated logic sort. It works directly with the abstract type `Field.t`, representing logical fields in a formal system. Concrete use cases include normalizing field representations for theorem proving, debugging logic expressions, and ensuring consistent field comparisons in proof automation.",
      "description_length": 413,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Cache.Binary",
      "library": "qed",
      "description": "Implements a binary caching mechanism that stores computed values in a fixed-size cache, using a binary tree structure for efficient retrieval. Works with values of type `'a` and organizes them using a binary strategy defined in the nested module `A`. Useful for optimizing repeated computations where intermediate results can be stored and reused, such as in dynamic programming or recursive algorithms with overlapping subproblems.",
      "description_length": 433,
      "index": 628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Cache.Cache",
      "library": "qed",
      "description": "Implements a bounded-size cache with LRU eviction policy, supporting cache creation, value computation with caching, and explicit cache clearing. Works with arbitrary value types through a polymorphic cache structure. Useful for optimizing repeated computations like memoizing expensive functions or storing transient results in a limited memory footprint.",
      "description_length": 356,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Subst",
      "library": "qed",
      "description": "This module implements term substitution management, providing operations to create and manipulate substitution environments. It supports binding terms to variables, applying substitutions to terms, and filtering which terms can be modified, working with terms, variables, and pools of variables. Concrete use cases include managing variable bindings during term rewriting and controlling substitutions in logical inference or proof construction.",
      "description_length": 446,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic.Term-Tmap",
      "library": "qed",
      "description": "This module offers operations for term-indexed maps with efficient merging and key-based transformations, supporting polymorphic values associated with `term` keys. It provides structural manipulation functions like union/intersection alongside customizable value combination and comparison operations optimized for performance over structural equality. Such maps are particularly useful in symbolic computation or theorem proving scenarios where fast term-keyed data aggregation and transformation are required without reliance on structural identity.",
      "description_length": 552,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.S-Set",
      "library": "qed",
      "description": "This module enables functional, immutable set manipulation with operations like union, intersection, and difference, alongside sorted traversal variants for ordered processing. It works with `Set.t` structures over elements of type `t`, supporting use cases such as membership testing, unique element management, and transformations via list conversion or element-wise mapping. Quantification and filtering operations allow for set analysis and refinement, while intersection checks and algebraic operations facilitate set comparisons and compositions.",
      "description_length": 552,
      "index": 632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Logic.Symbol",
      "library": "qed",
      "description": "This module implements symbols that support ordering, hashing, and pretty-printing. It provides `compare`, `equal`, and `hash` for use in sets, maps, and hash tables, along with `pretty` for formatted output and `debug` for string-based debugging. These operations make it suitable for managing symbolic identifiers in formal verification or compiler components where structured symbol handling is required.",
      "description_length": 407,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection.Set",
      "library": "qed",
      "description": "This set abstraction supports creation through element insertion and list conversion, transformation via mapping and set algebra, and querying with membership tests and subset relations. It operates on a polymorphic collection of unique elements, providing efficient boolean operations and ordered traversal. Typical applications include deduplication, data filtering, and structured set computations requiring union, intersection, or difference operations.",
      "description_length": 457,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Term",
      "library": "qed",
      "description": "This module provides a framework for building and transforming logical expressions with support for binders, arithmetic, and symbolic structures. It centers around terms, variables, types, and collections like sets and maps, enabling operations such as substitution, equality checking, type inference, and simplification. Users can perform tasks like tracking free variables, manipulating logical formulas, and managing environments for theorem proving or symbolic computation. Specific applications include simplifying expressions, comparing terms efficiently, and handling variable bindings in formal verification workflows.",
      "description_length": 626,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export",
      "library": "qed",
      "description": "This module provides tools for converting engine modes, sanitizing identifiers, and extracting data from links, working directly with engine configurations, string values, and structured references. It includes an export engine that transforms and serializes proof structures by mapping type variables and functions, managing environments to avoid variable capture, and leveraging ordered maps for efficient key-based operations. You can use it to generate code from logical terms, safely bind variables during export, or process sorted data with insertions and traversals. Specific tasks include sanitizing names for external output, inspecting link components, and serializing structured environments with typed keys.",
      "description_length": 719,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Logic",
      "library": "qed",
      "description": "This module provides core constructs for first-order logic, including binders, sorts, and a ternary maybe type, along with interfaces for symbols, data, fields, functions, and variables. It supports building and manipulating logical formulas, defining function signatures, and modeling structured data for theorem proving or formal verification. The module's submodules offer term manipulation with structural equality, record field operations, function term handling, variable management, ordered term maps and sets, type term operations, and substitution environments. Specific capabilities include term normalization, symbolic computation, type checking, and efficient term-indexed data aggregation with structural consistency.",
      "description_length": 730,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pool",
      "library": "qed",
      "description": "This module manages resource allocation with fixed-size buffers while supporting structured handling of abstract values and symbolic variables. It provides a core type `t` for equality and comparison operations, along with a variable system that assigns unique identifiers and supports scoped naming and alpha-equivalence. Users can create and manage pools of resources, acquire and release them efficiently, and work with typed variables in contexts like formal verification or compiler IRs. Specific operations include acquiring a resource from the pool, creating fresh variables with scoped names, and comparing or equating abstract values.",
      "description_length": 643,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Pretty",
      "library": "qed",
      "description": "The module provides a pretty-printing environment for terms and types, managing variable bindings and fresh name generation to ensure correct scoping. It supports operations for formatting lambda terms, printing type annotations, and producing readable output for expressions, using an environment that maps variables to their printed forms. Key data types include environments and variable mappings, while core operations handle term formatting and name management. Example uses include displaying bound variables in lambda expressions and generating debug output for typed terms.",
      "description_length": 581,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Intmap",
      "library": "qed",
      "description": "This library implements integer-keyed maps using Patricia Trees, offering operations for creation, modification, and traversal with support",
      "description_length": 139,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Collection",
      "library": "qed",
      "description": "This module orchestrates the manipulation of associative and unique-element collections through customizable merging, transformation, and traversal operations. It centers on maps and sets with support for key-centric manipulations, value transformations, and set algebra, leveraging derived or custom hash, equality, and comparison operations for key types. Users can reconcile configuration changes by merging maps with conflict resolution strategies, track unique identifiers using set algebra, or build data pipelines with ordered traversal and bidirectional mapping. Submodules enable environment tracking in compilers via key management, efficient lookups using balanced trees, and set-based computations over structured or custom types.",
      "description_length": 742,
      "index": 641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Export_why3",
      "library": "qed",
      "description": "This module translates formal proofs into Why-3 format, handling proof terms, triggers, and type definitions using the `T` module. It maintains a stateful environment to generate and track unique identifiers, ensuring consistent naming and avoiding collisions. Key operations include exporting proof structures to Why-3 files, creating fresh identifiers, registering terms, and iterating over definitions. For example, users can convert internal proof terms into Why-3 input or manage identifier state during export.",
      "description_length": 516,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Hcons",
      "library": "qed",
      "description": "This module provides hash-combining functions for constructing hash values for pairs, triples, lists, arrays, and options. It includes equality and comparison operations for lists and arrays, as well as folding utilities that combine elements into a single result. These operations are used to implement efficient hash-consing for structured data like abstract syntax trees or term representations.",
      "description_length": 398,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxmap",
      "library": "qed",
      "description": "This module implements a key-indexed map structure that enables efficient lookups, insertions, and deletions using integer identifiers, while maintaining fast iteration in index order. It provides core operations for managing key-value associations, including insertion, removal, and lookup by both key and index, along with higher-order functions for mapping, filtering, and folding over indexed data. Child modules extend this functionality with set-theoretic operations, key identity management, and advanced merging strategies, supporting use cases like environment tracking, symbol table management, and structured data merging. For example, it can track dynamic entities by stable IDs, merge configuration maps with custom logic, or iterate over values in index-ascending order.",
      "description_length": 784,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Partition",
      "library": "qed",
      "description": "This module provides union-find data structures for managing dynamic equivalence relations, enabling efficient merging of disjoint sets, finding canonical representatives, and checking element equivalence. It supports operations through both direct APIs and submodules that handle elements, sets, and map-based representations, working with abstract types like `t`, `E.t`, and `S.t`. You can use it to track connected components in graphs, implement Kruskal\u2019s algorithm, or manage equivalence classes in constraint systems with path compression and rank-based merging. Specific operations include merging sets, finding the representative of an element, iterating over members, and computing intersections or unions efficiently.",
      "description_length": 727,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Engine",
      "library": "qed",
      "description": "The module provides core abstractions for logical operations, function calls, and evaluation modes, forming the foundation for theorem proving and formal verification tasks. It defines key data types such as operators, calling conventions, and type modes, enabling precise expression parsing and semantic interpretation. Alongside its child module for context management, it supports environment operations like variable binding, fresh name generation, and term unfolding. This combination allows users to build and manipulate logical expressions, apply term rewriting rules, and maintain type correctness within a structured evaluation context.",
      "description_length": 645,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listmap",
      "library": "qed",
      "description": "This module implements a list-based associative structure that maps ordered keys to values, enabling efficient lookups, insertions, and deletions through direct operations and comparison logic provided by a key module. It supports polymorphic map manipulation with functions for transforming, merging, and querying key-value pairs, while submodules define essential key behaviors and algebraic map operations like union and intersection. You can use it to manage lightweight symbol tables, merge configuration layers with custom strategies, or perform ordered dictionary computations. The structure is ideal for scenarios where key ordering drives data aggregation and persistence is not required.",
      "description_length": 697,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergeset",
      "library": "qed",
      "description": "This module implements a set structure for efficiently merging ordered collections using customizable conflict resolution strategies. It supports key operations like union, intersection, and difference, while maintaining immutability and sorted traversal, making it suitable for tasks like merging versioned state or prioritized logs. The core type `t` is a list-based map that ensures element uniqueness and order, with elements (`elt`) equipped with comparison, equality, and hashing functions. Submodules extend functionality with declarative set transformations and element-level operations, enabling precise control over merging behavior and set manipulation.",
      "description_length": 664,
      "index": 648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Qed.Bvars",
      "library": "qed",
      "description": "This module represents sets of bound variables using bitwise operations, enabling efficient manipulation and querying of variable footprints. It supports operations like union, containment checks, and determining if variables are closed or within specific ranges. Useful for tracking variable binding depths in lambda calculus or formal verification contexts.",
      "description_length": 359,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Idxset",
      "library": "qed",
      "description": "This module manages sets of elements associated with integer indices using Patricia trees, enabling efficient storage and retrieval for sparse data structures. It supports adding, removing, and checking membership of elements by index, as well as functional transformations like union, intersection, and difference on immutable sets. The API includes types `t` for the set and `elt` for elements, allowing operations such as filtering, iteration, and comparison tailored for dynamic, indexed collections. Use cases include tracking active connections, managing cached resources, and implementing high-performance data analysis pipelines with indexed elements.",
      "description_length": 659,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Mergemap",
      "library": "qed",
      "description": "The module organizes key management and map merging into a cohesive system for handling layered, ordered key-value data with conflict resolution. It centers on a merging map type that combines multiple maps through a user-defined merge function, while its key interface handles ordering, equality, and hashing for efficient lookups and inserts. You can use it to build versioned key-value stores or hierarchical configurations where overlapping keys are resolved programmatically. Submodules provide the necessary key operations, enabling the parent module to maintain consistent, ordered views across merged data layers.",
      "description_length": 621,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Export_whycore",
      "library": "qed",
      "description": "This module translates formal verification artifacts between internal representations and target formats for Why-3 and Alt-Ergo. It processes terms, types, and functions, managing name binding and term sharing through environments that track identifiers and generate fresh names. Using the `T.term` type, it supports operations like term unfolding, sharing detection, and declaration translation. Example usage includes converting proof obligations with optimized term representation and handling symbolic variables during export.",
      "description_length": 530,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Listset",
      "library": "qed",
      "description": "This module implements a list-backed set structure with efficient membership testing and mutation operations, supporting any ordered element type. It provides core data types `t` and `elt`, with operations for union, intersection, difference, and factorization, enabling tasks like dependency tracking and duplicate filtering. The child modules extend these capabilities with multi-set aggregation and element comparison logic, allowing decomposition of overlapping sets and consolidation of list-based collections. Specific uses include managing unique identifiers, analyzing set relationships, and processing sequences with deduplication.",
      "description_length": 640,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Plib",
      "library": "qed",
      "description": "This library offers tools for structured text generation and transformation, focusing on advanced string formatting, custom error message construction, and declarative pretty-printing of complex data. It operates on strings, lists, and user-defined types through combinators for expression layout, associative operator formatting, and indexed traversal patterns. Common applications include rendering nested expressions with custom separators, transforming text via regex-based substitution, and building diagnostic messages with contextual formatting.",
      "description_length": 552,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Cache",
      "library": "qed",
      "description": "This module provides memoization caches for unary and binary functions, enabling efficient result reuse through key-based storage and retrieval. It supports creating caches with customizable size and eviction policies, using hash and equality operations defined for keys, and includes specialized submodules for unary and binary caching with tree-based and LRU strategies. You can optimize recursive computations like Fibonacci or dynamic programming by caching intermediate results, or use the LRU cache to limit memory usage while memoizing expensive functions. The module also includes utilities for cache clearing, hash generation, and equality comparison, making it suitable for both simple and complex caching scenarios.",
      "description_length": 726,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Kind",
      "library": "qed",
      "description": "This module provides core operations for analyzing and transforming logic types, including extracting type degrees, merging sorts, mapping type parameters, and custom formatting. It works with structured logic data from child modules to enable canonical representations, structural comparison, and debugging-friendly output. Use it to implement type analysis passes, manipulate logic expressions with precise type control, or generate readable type visualizations in compilers and proof systems. Key operations include type merging, parameter mapping, and formatted pretty-printing integrated with logic expressions from dependent modules.",
      "description_length": 639,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed.Intset",
      "library": "qed",
      "description": "This implementation provides functional operations for integer sets using Patricia Trees, supporting creation (empty, singleton), membership testing, modification (add, remove), and set operations (union, intersection, difference, subset checks). It includes traversal functions for folding, filtering, and partitioning, with specialized utilities like `partition` for splitting sets based on predicates and `intersect` for overlap detection, enabling efficient handling of large integer ranges in applications like data structure merging or combinatorial algorithms.",
      "description_length": 567,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Qed",
      "library": "qed",
      "description": "This module suite provides a comprehensive framework for symbolic computation, formal verification, and structured data manipulation. It centers on logical expressions, type systems, and efficient data structures like maps, sets, and union-find, with support for binders, substitutions, and type inference. Users can build and transform terms, manage variable bindings, serialize proof structures, and perform operations like simplification, normalization, and equivalence checking. Examples include exporting formal proofs to Why-3, optimizing term representations with hash-consing, managing scoped variables during code generation, and merging configuration maps with custom conflict resolution.",
      "description_length": 698,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Project_name.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a data type for representing and manipulating project names within a GUI plug-in, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with structured data types involving `Project_skeleton.t` and provides functions to copy values deeply and check membership based on project properties. Concrete use cases include managing project identifiers in GUI components and ensuring consistent handling of project data across interface elements.",
      "description_length": 499,
      "index": 659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Undo.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a data type for representing values that can be stored and manipulated in the context of an undo operation within a GUI plug-in. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, ensuring values can be uniquely identified, compared, and displayed. It is used to manage state changes that need to be tracked and potentially reverted using the `-undo` option.",
      "description_length": 412,
      "index": 660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Debug.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a data type for representing and manipulating debug-related values within a GUI plug-in. It supports operations such as equality checking, comparison, hashing, pretty printing, deep copying, and project membership testing. The type `t` is used to describe structured debug data, enabling inspection and transformation of project-specific values.",
      "description_length": 365,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Verbose.Datatype",
      "library": "frama-c.gui",
      "description": "This module defines a concrete data type for representing verbose GUI parameters, including operations for equality, comparison, hashing, and pretty-printing. It supports structured values with deep copying, project membership checks, and type descriptors for integration with Frama-C's plugin system. Use cases include managing and persisting GUI state, validating parameter values, and enabling extensible configuration options within the Frama-C GUI plug-in.",
      "description_length": 461,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Cache_dir",
      "library": "frama-c.gui",
      "description": "This module manages the cache directory for a plug-in, providing functions to retrieve or create directories and files within the cache, using `Frama_c_kernel.Filepath.t` as the file path representation. It allows setting and querying a user-specific directory path without automatically creating it, ensuring paths adhere to the plug-in's cache structure. Concrete use cases include storing temporary analysis results or persistent user-specific data tied to the plug-in's execution.",
      "description_length": 484,
      "index": 663,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Pretty_source.Locs",
      "library": "frama-c.gui",
      "description": "Manages state for tracking and manipulating source code locations during pretty printing in a Gtk TextBuffer. It provides functions to initialize and reset location tracking, ensuring accurate positioning of elements in the displayed source. Useful when rendering annotated or highlighted code regions that require precise text layout.",
      "description_length": 335,
      "index": 664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Session",
      "library": "frama-c.gui",
      "description": "This module manages session-specific directories and files for a GUI plug-in, providing functions to retrieve or create paths with optional directory creation. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring valid access to session resources. Use cases include initializing session storage, accessing session files, and ensuring directory structures exist before operations.",
      "description_length": 404,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Property_navigator.Rte",
      "library": "frama-c.gui",
      "description": "This module implements a property navigator extension for the GUI that specifically handles RTE (Runtime Exception) status tracking and updates. It works with `status_accessor` values, which pair string identifiers with functions to get and set RTE status for kernel functions. It is used to register and manage RTE status accessors, enabling the GUI to display and modify RTE analysis results for functions in the CIL kernel.",
      "description_length": 426,
      "index": 666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.MAKE_CUSTOM_LIST",
      "library": "frama-c.gui",
      "description": "This module defines a functor for constructing custom Gtk lists with specialized data handling. It works with arrays and custom data types through a provided module `A`, supporting operations like index validation and view column creation. Concrete use cases include building structured GUI lists where each row contains typed data from module `A` and displays it using custom renderers.",
      "description_length": 387,
      "index": 667,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Debug",
      "library": "frama-c.gui",
      "description": "This module manages integer-based debug parameters with support for range constraints, increment operations, and value change hooks, integrating with both GUI and command-line interfaces. It provides a core managed integer type with metadata for min/max limits and serialization, enabling dynamic configuration of debug levels and persistent tracking of diagnostic settings. The child module extends this functionality by defining structured debug data for GUI plug-ins, supporting operations like comparison, pretty printing, and project membership testing. Together, they allow inspection, transformation, and interactive manipulation of debug values within a project context.",
      "description_length": 678,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.State_dir",
      "library": "frama-c.gui",
      "description": "This module manages file paths for a plug-in's state directory, providing functions to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to represent file paths and ensures proper handling of user-specific state storage. Use cases include persisting plug-in configuration or temporary files in a structured directory.",
      "description_length": 361,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Project_name",
      "library": "frama-c.gui",
      "description": "This module manages a string-based GUI option for handling project names with support for setting and retrieving values, registering change hooks, and controlling persistence. It enforces validation through configurable allowed values and provides utilities to extract function names or raw input strings. The child module defines a structured data type for project names with operations like equality checks, comparison, hashing, and pretty-printing, supporting deep copying and membership checks based on project properties. Together, they enable dynamic project name management with user-defined constraints, consistent GUI handling, and state tracking across interface elements.",
      "description_length": 682,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Design.Feedback",
      "library": "frama-c.gui",
      "description": "Declares and applies visual markers in the source code editor's left margin to indicate property status feedback. It works with source buffers and statements from the CIL types module, using theme-dependent icons. Used to highlight specific lines in the code with status indicators, such as during static analysis reporting.",
      "description_length": 324,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.Icon",
      "library": "frama-c.gui",
      "description": "This module manages icon resources for a GUI application, providing functions to register custom icons and retrieve them by identifier. It works with `kind` types representing built-in and custom icons, and returns `GdkPixbuf.pixbuf` images. Use it to load standard icons like fold/unfold indicators or associate named custom icons with image files for display.",
      "description_length": 361,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Config_dir",
      "library": "frama-c.gui",
      "description": "This module provides functions to retrieve directory and file paths, ensuring they exist based on the provided `create_path` flag. It works with string identifiers and returns paths as `Frama_c_kernel.Filepath.t` values. Concrete use cases include locating plugin-specific configuration directories and files during GUI initialization or resource loading.",
      "description_length": 355,
      "index": 673,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper.Configuration",
      "library": "frama-c.gui",
      "description": "This module enables management of typed GUI configuration parameters through a key-value store, supporting operations to register, retrieve, and persist settings like window dimensions, layout ratios, and visual flags. It works with scalar types (integers, floats, booleans) and structured values (strings, lists, enumerated types), organized by configuration keys with built-in default handling. Typical use cases include defining adaptive UI layouts, storing user preferences, and ensuring consistent visual scaling across different display contexts.",
      "description_length": 552,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_printers.LinkPrinter",
      "library": "frama-c.gui",
      "description": "This module formats varinfos and types with reactive link tags (`link:vidN` and `link:typN`) for GUI display. It specializes in wrapping identifiers and types in annotated format tags that enable interactivity in the GUI. Use this when rendering clickable or interactive variable and type references in GUI elements.",
      "description_length": 316,
      "index": 675,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Share",
      "library": "frama-c.gui",
      "description": "This module manages the configuration and retrieval of shared directories and files within a plug-in's site structure. It provides operations to set and query the site directory path, check if the path is defined, and resolve specific directories or files within the site. Typical use cases include locating plug-in resources like configuration files or shared libraries during GUI initialization or runtime.",
      "description_length": 408,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Verbose",
      "library": "frama-c.gui",
      "description": "This module manages a numeric verbosity parameter with integer values, enforcing minimum and maximum bounds and triggering change hooks in response to modifications. It integrates with project lifecycle events and command-line interfaces, enabling synchronized state persistence and dynamic logging control in GUI-driven analyses. The child module defines a structured data type for verbosity parameters, supporting equality checks, comparison, hashing, and pretty-printing, while enabling deep copying, type introspection, and compatibility with Frama-C's plugin system. Together, they allow applications to configure, track, and persist verbosity settings with strong validation and seamless GUI integration.",
      "description_length": 710,
      "index": 677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters.Undo",
      "library": "frama-c.gui",
      "description": "This module controls the undo functionality as a boolean setting, allowing dynamic activation or deactivation through command-line flags or GUI interactions, while synchronizing with project state updates. It provides operations to toggle the setting, register change handlers, and maintain consistency during state transitions. The child module introduces a data type for values involved in undo operations, supporting equality, comparison, hashing, and pretty-printing to enable tracking, identification, and reversion of state changes. Together, they allow users to capture, manage, and revert analysis states with precise control over undo behavior.",
      "description_length": 653,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wbox",
      "library": "frama-c.gui",
      "description": "This module implements box layout management for GUI widgets, supporting horizontal and vertical packing with expansion policies. It works with `box` and `widget` types, allowing precise control over alignment and spacing. Concrete use cases include constructing toolbars, sidebars, scrollable areas, and split-pane interfaces.",
      "description_length": 327,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_parameters",
      "library": "frama-c.gui",
      "description": "This module organizes GUI-related parameters and state management for plug-ins, coordinating cache, session, and configuration directories with structured data types for debug settings, verbosity, and undo controls. It provides core operations for path resolution, directory creation, and value validation, using `Frama_c_kernel.Filepath.t` for safe file handling and supporting user-specific, session-specific, and shared storage. Key data types include managed integers for debug and verbosity parameters with range constraints and hooks, and structured strings for project names with validation and persistence. Users can configure debug levels via GUI sliders, persist plug-in state across sessions, control analysis undo behavior, and manage project-specific directories with guaranteed path integrity.",
      "description_length": 807,
      "index": 680,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Book_manager",
      "library": "frama-c.gui",
      "description": "Manages a collection of source code tabs within a GUI application using a notebook interface. It supports adding, removing, and navigating between tabs, each containing a `source_view` widget for displaying or editing code. Operations include inserting tabs at specific positions, switching between views, and enabling popup menus or scrollable content.",
      "description_length": 353,
      "index": 681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Gtk_form",
      "library": "frama-c.gui",
      "description": "This module provides functions to create and manage GUI widgets for plugin options in a deprecated framework, including checkboxes, menus, spinners, labels, and buttons. It works with boolean, integer, and string values, synchronizing them with UI elements using a `demon` type to track changes. Concrete use cases include building configuration panels for plugins with automatic value updates and user interaction handling through callbacks.",
      "description_length": 442,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wutil",
      "library": "frama-c.gui",
      "description": "This module handles GUI utility operations, including event management, widget styling, and runtime configuration. It provides functions for manipulating widget properties like font, visibility, and tooltips, along with utilities for event throttling and deferred execution. Key use cases include adjusting UI element appearance, managing pane ratios in layouts, and issuing warnings or console output during GUI interactions.",
      "description_length": 426,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Filetree",
      "library": "frama-c.gui",
      "description": "This module manages a hierarchical tree view displaying analysis units and global declarations, supporting dynamic column updates. It operates on file paths and CIL global entities, organizing them into a structured UI component. Concrete use cases include populating and updating a graphical file tree in the Frama-C GUI with functions, variables, and annotations.",
      "description_length": 365,
      "index": 684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Analyses_manager",
      "library": "frama-c.gui",
      "description": "Handles the initialization and management of analysis modules within the Frama-C GUI environment. Works with internal analysis configurations and GUI components to set up and launch specific static analysis plugins. Used to ensure analyses are properly registered and available when loading Frama-C in graphical mode.",
      "description_length": 317,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gtk_helper",
      "library": "frama-c.gui",
      "description": "This module simplifies GTK UI development by offering tools for widget creation, layout structuring, and interaction handling, working directly with GTK widgets, text buffers, and configuration state. It includes a functor for building type-safe Gtk lists with custom rendering, an icon manager for loading and retrieving pixbuf images by identifier, and a configuration system for managing and persisting typed UI settings such as window sizes and layout ratios. You can use it to build structured configuration panels with synchronized model data, display custom icons in UI elements, and manage scalable layouts that adapt to user preferences or display changes. Specific capabilities include creating validated list views from custom data types, redirecting runtime output to text buffers, and applying tooltips or timeouts to interactive components.",
      "description_length": 854,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Property_navigator",
      "library": "frama-c.gui",
      "description": "This module extends the GUI to track and update RTE (Runtime Exception) status for kernel functions using `status_accessor` values, which link string identifiers to get/set functions. It allows registration and management of RTE status accessors, enabling the GUI to display and modify analysis results. For example, users can view RTE statuses for specific CIL functions or update them interactively through the GUI.",
      "description_length": 417,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.History",
      "library": "frama-c.gui",
      "description": "This module manages a navigation history stack for source code elements, supporting operations to move backward and forward through visited positions, push new elements onto the history, and refresh the current display. It works with `history_elt` values, which represent either global CIL elements or localizable source positions. Use cases include tracking user navigation through a codebase, restoring previous views, and synchronizing the GUI display with the current history state.",
      "description_length": 486,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.GSourceView",
      "library": "frama-c.gui",
      "description": "This module integrates GtkSourceView widgets and related components for building source code editing interfaces. It provides functions to create and configure source buffers with syntax highlighting, completion providers, and undo management, along with view settings like indentation, line numbers, and margins. Concrete use cases include embedding a customizable code editor in a GUI application, enabling auto-completion, syntax highlighting, and bracket matching for specific programming languages.",
      "description_length": 502,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Pretty_source",
      "library": "frama-c.gui",
      "description": "This module formats and displays C source code in a GTK text buffer, highlighting and locating elements like statements, variables, and functions with precise offsets. It supports interactive features such as folding and unfolding preconditions at call sites and mapping between source locations and internal data like kernel functions or variable info. The child module manages state for tracking and manipulating source code locations during pretty printing, providing functions to initialize and reset location tracking for accurate positioning of elements in the displayed source. Use it to build GUI tools for code analysis, visualize code structure, or enable user interaction with specific code elements through annotated or highlighted regions.",
      "description_length": 752,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Source_viewer",
      "library": "frama-c.gui",
      "description": "This module creates and manages a source viewer widget for displaying Frama-C's pretty-printed AST. It provides functions to build the viewer with optional naming and packing, and to retrieve the underlying source buffer. Concrete use cases include embedding the viewer in GUI components and accessing the AST display buffer for updates or analysis.",
      "description_length": 349,
      "index": 691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Warning_manager",
      "library": "frama-c.gui",
      "description": "Manages warnings in a graphical interface by providing functions to create a warning display widget, append individual warning messages, and clear all warnings. It works with GUI widgets and log events to integrate warning handling directly into the user interface. Concrete use cases include displaying analysis warnings from a static code checker in a dedicated GUI panel.",
      "description_length": 374,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Widget",
      "library": "frama-c.gui",
      "description": "This module creates and manages GUI widgets for labels, buttons, groups, and selectors. It supports labeled text with alignment, style, and color options, and provides icon handling with shared and custom images. Use it to build interactive analysis controls and visual elements in static analysis tools.",
      "description_length": 304,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Help_manager",
      "library": "frama-c.gui",
      "description": "Manages contextual help content and navigation within the Frama-C GUI. Registers and displays help pages, sections, and anchors in response to user actions or tool events. Useful for integrating plugin-specific documentation and interactive guidance directly into the interface.",
      "description_length": 278,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Menu_manager",
      "library": "frama-c.gui",
      "description": "This module manages the creation and behavior of menu and toolbar entries in a GUI application. It defines types for specifying locations (`where`) and callbacks (`callback_state`) to handle user interactions, along with entries that combine these elements. It is used to build interface components like menu bars, toolbars, and context-sensitive buttons with associated actions and visibility rules.",
      "description_length": 400,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wfile",
      "library": "frama-c.gui",
      "description": "This module provides functions to create and manage file choosers for selecting files or directories in a GUI application. It works with the `filekind` type to distinguish between file and directory selection. Concrete use cases include opening dialog windows to let users pick configuration files, source code directories, or output destinations for saved data.",
      "description_length": 362,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Project_manager",
      "library": "frama-c.gui",
      "description": "Manages project switching within the GUI by handling user interactions and state transitions. Works with project configuration data and GUI components to enable seamless navigation between projects. Useful for developers who need to toggle between different analysis projects without restarting the application.",
      "description_length": 311,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.File_manager",
      "library": "frama-c.gui",
      "description": "Manages file operations for GUI components, including opening, saving, and tracking file states. Works with file paths, buffers, and GUI widgets. Used to handle user interactions with files in the editor interface.",
      "description_length": 214,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wutil_once",
      "library": "frama-c.gui",
      "description": "This module provides a function `once` that ensures a given function is executed only once during program execution, caching and returning the same result on subsequent calls. It works with any function type `'a -> 'b`, transparently wrapping it to enforce single execution. Use it to lazily initialize expensive resources or ensure idempotent behavior without external state tracking.",
      "description_length": 385,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Gui_printers",
      "library": "frama-c.gui",
      "description": "This module enables pretty-printing of C types and linking of identifiers within a GUI context, using annotated format tags to create reactive elements. It directly supports rendering clickable type references and resolving links to variables, types, or source locations, working with CIL types, varinfos, and location data. The child module specializes in wrapping identifiers and types in `link:vidN` and `link:typN` tags, making them interactive in GUI displays. Use this combination to build dynamic, clickable code representations in source analysis tools.",
      "description_length": 561,
      "index": 700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Design",
      "library": "frama-c.gui",
      "description": "This module enables customization of the GUI through extension registration and reactive buffers tied to global variables, which update based on user interactions like selections and highlighting. It supports dynamic UI components and custom analysis views that respond to changes in the program model. A child module handles visual markers in the source editor, using theme-dependent icons to highlight lines based on statement properties, such as analysis results. These markers integrate with source buffers and CIL types to provide inline feedback during inspections.",
      "description_length": 571,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Source_manager",
      "library": "frama-c.gui",
      "description": "This module manages a multi-tab source code viewer widget with support for loading files, selecting tabs by filename or title, and handling user clicks on source code. It works with file paths and source views, providing precise navigation to specific lines and interactive callbacks for user actions. Concrete use cases include displaying and interacting with C source files in a graphical interface, such as showing clicked code locations or switching between multiple open files.",
      "description_length": 482,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Launcher",
      "library": "frama-c.gui",
      "description": "This module displays a configuration dialog for launching Frama-C with custom parameters. It works with GUI components and event handlers to capture user input and trigger analysis runs. A concrete use case is allowing users to set analysis options and start Frama-C directly from a graphical interface without using the command line.",
      "description_length": 334,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui.Wpalette",
      "library": "frama-c.gui",
      "description": "This module implements a graphical sidebar palette for organizing and accessing tools within the Frama-C interface. It manages the display and interaction with tool buttons, allowing users to select and activate specific analysis or transformation plugins. The palette is designed to work with GUI event handlers and tool metadata, providing a structured way to present and manage available functionalities.",
      "description_length": 407,
      "index": 704,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_gui.Wpane",
      "library": "frama-c.gui",
      "description": "This module manages GUI panels with support for tabbed interfaces, dynamic widget arrays, and dialog windows. It works with field types like compact, single-line, and multiline panels that control layout behavior. Concrete use cases include building configurable dialog boxes with resizable fields and organizing UI components into structured, expandable regions.",
      "description_length": 363,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_gui",
      "library": "frama-c.gui",
      "description": "This module provides a comprehensive framework for building and managing a sophisticated GUI environment tailored for static code analysis. It centers around core data types like `widget`, `box`, `source_view`, `history_elt`, and `filekind`, enabling structured layout management, source code navigation, and interactive analysis tools. Users can construct custom interfaces with tabbed code viewers, dynamic configuration panels, and hierarchical tree displays, while managing state, RTE statuses, and project-specific settings. Specific applications include embedding syntax-highlighted code editors, creating analysis plugin UIs with synchronized controls, and implementing navigation history with precise source location tracking.",
      "description_length": 734,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of parameter values, along with descriptors for type representation and project membership testing. It works with string values and is used to manage and manipulate WP plugin options that are exposed via the command line.",
      "description_length": 419,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based tactic parameters in the WP plugin, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with a concrete type `t` representing string parameters, supporting deep copying, membership checks over projects, and structured descriptors for serialization. Use cases include parsing and managing command-line string arguments within WP's tactic framework.",
      "description_length": 448,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, and pretty-printing string values, along with deep copying and project membership testing. It is used to represent and manipulate string configuration options that can be passed via the command line or stored in project settings.",
      "description_length": 394,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl.Key",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for keys used in a hash table, including operations for equality, comparison, hashing, and pretty printing. It supports working with key values that may contain project-specific data, providing deep copying and membership checks within projects. Concrete use cases include managing and querying keys in a hash table structure where keys need to be compared, hashed, or displayed, and ensuring correct handling of project-related metadata.",
      "description_length": 470,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Vmap",
      "library": "frama-c-wp.core",
      "description": "This module provides polymorphic map operations for managing key-value associations where keys are logical variables from a formal system. It supports key-based insertion, deletion, and transformation alongside higher-order traversal functions, enabling precise manipulation of variable mappings in logical contexts. The structure is particularly useful for tasks like merging symbolic environments, resolving variable collisions in theorem proving, or tracking value changes across different logical states.",
      "description_length": 508,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.STmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a polymorphic map structure with structural ordering constraints, designed for managing collections of logic terms from the Qed framework. It supports key-based operations like insertion, deletion, and combination (union/merge), along with ordered traversal (iter, fold), transformation (map, filter), and sequence integration (to_seq, of_seq), all operating on maps where keys maintain a strict structural hierarchy. The implementation is particularly suited for symbolic computation tasks requiring ordered term-based indexing, such as proof state management or structured data analysis where key ordering dictates logical precedence.",
      "description_length": 659,
      "index": 712,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, and pretty-printing string values, along with deep copying and project membership testing. It is used to represent and manipulate string parameters in a way that supports both user interaction and internal processing within the WP plugin's parameter system.",
      "description_length": 421,
      "index": 713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based configuration parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a custom type `t` representing string parameters, along with lists of such values, type descriptors, and project-related predicates. Concrete use cases include managing and comparing command-line configuration settings, deep copying parameter values, and checking project membership within parameter values.",
      "description_length": 508,
      "index": 714,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a standard string parameter type with operations for equality, comparison, hashing, and pretty-printing. It supports working with string-based configuration values, including deep copying and membership checks over project skeletons. It is used to represent and manipulate string parameters within the WP plugin's configuration system.",
      "description_length": 355,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a plugin system. It supports operations like equality checks, comparison, hashing, and pretty-printing for string values, along with deep copying and project membership testing. It is used to represent and manipulate string configuration options that are passed through the command line interface of the plugin.",
      "description_length": 399,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing string-based prover parameters with operations for equality, comparison, hashing, and pretty-printing. It supports working with command-line string parameters, providing deep copying, membership checks over project skeletons, and structured representations for serialization. Concrete use cases include parsing and managing prover configurations in the WP plugin, such as handling user-defined string inputs for theorem provers.",
      "description_length": 477,
      "index": 717,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Report.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a concrete type `t` that represents parameter values, along with lists of such values, and includes functions for deep copying and project membership testing. It is used to manage and manipulate string parameters passed to the WP plugin during analysis, ensuring proper handling of project-specific values.",
      "description_length": 505,
      "index": 718,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wpo.S.Map.Key",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for keys used in a map structure, providing essential operations including equality, comparison, hashing, and pretty-printing. It supports working with representants, descriptors, and project membership checks, enabling precise key manipulation and introspection. Concrete use cases include managing unique identifiers in a map, comparing and hashing keys for efficient lookups, and serializing or displaying key values in a user-friendly format.",
      "description_length": 478,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a context, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a concrete type `t` representing parameter values, along with associated descriptors, packed representations, and project membership queries. It is used to manage and manipulate string parameters in a type-safe and consistent way, particularly for configuration and command-line interface purposes.",
      "description_length": 497,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, and pretty-printing string values, along with deep copying and project membership testing. It is used to represent and manipulate string configuration options that are part of the WP plugin's interface.",
      "description_length": 366,
      "index": 721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters within a collection, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a concrete type `t` that represents string parameters, along with standard types like `formatter`, `int`, and `bool`. It is used to manage and manipulate string configuration options in a structured and type-safe way, particularly in command-line interfaces or parameter handling systems.",
      "description_length": 490,
      "index": 722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.QED.Term",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates low-level logic terms within the WP plug-in's formal verification system. It provides operations for hashing, equality checking, comparison, and pretty-printing of logic terms, which are used to express program properties and assertions. These functions support tasks such as term normalization, proof checking, and debugging logical expressions during verification.",
      "description_length": 405,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Tau",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for manipulating logical terms and types within a formal verification context. It provides equality, comparison, hashing, and pretty-printing functions for the `tau` type, which represents logical expressions or types in the underlying proof system. These functions support tasks like term normalization, debugging, and fresh name generation during proof construction.",
      "description_length": 399,
      "index": 724,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a string-based parameter type with operations for equality, comparison, hashing, and pretty-printing. It supports command-line string parameters with deep copying, membership testing, and project-specific queries. Concrete uses include handling user-defined string inputs in static analysis tools and managing configuration values with structured descriptors.",
      "description_length": 379,
      "index": 725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and managing sets of analyzed values in static analysis plugins, where deep copying and project-aware membership checks are required. The module also includes type descriptors and representants for integration with Frama-C's internal type system and structural comparison mechanisms.",
      "description_length": 510,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters in the WP plugin. It supports operations like equality checks, comparison, hashing, and pretty-printing for values of this type, along with deep copying and project membership testing. It is used to represent and manipulate string parameters in a way that integrates with Frama-C's kernel and project system.",
      "description_length": 390,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Tmap",
      "library": "frama-c-wp.core",
      "description": "This module implements polymorphic maps with keys from a logical term hierarchy, supporting efficient insertion, lookup, and set-theoretic operations like union and intersection. It includes functions for key-driven merging, comparison, and transformation\u2014such as `merge`, `diffq`, and `subset`\u2014that enable precise manipulation of term-indexed data, particularly useful in logical environments where fast key comparisons and merges are critical for tasks like symbolic reasoning or context management. The design emphasizes customizable term-based logic for applications requiring high-performance term indexing and structured data combination.",
      "description_length": 644,
      "index": 728,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.QED.Tset",
      "library": "frama-c-wp.core",
      "description": "This module offers a high-performance set implementation for managing collections of non-structural logic terms, where elements are compared using machine-dependent identifiers rather than structural equality. It supports standard set operations like union, intersection, and difference, along with transformations such as filtering, mapping, and partitioning, optimized for efficient merging and iteration. The structure is particularly suited for formal verification tasks requiring fast manipulation of term-based sets in automated reasoning workflows.",
      "description_length": 555,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Map.Make",
      "library": "frama-c-wp.core",
      "description": "This module creates a specialized map structure for a given data type, enabling operations like lookup, comparison, and pretty-printing. It supports maps where keys are of type `Data.t` and values follow the structure defined by the `Wp.Wpo.S.Map` signature. Concrete use cases include managing and manipulating collections of analysis results or configuration settings with strong typing and structural integrity.",
      "description_length": 414,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in the WP plugin. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of parameter values, along with descriptors for type representation and project membership testing. It works directly with string values and project skeletons to support configuration and analysis workflows in static code analysis.",
      "description_length": 429,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Subst",
      "library": "frama-c-wp.core",
      "description": "This module manages substitutions for terms in a logical language, supporting operations to create, copy, and extend substitution environments. It works with terms, variables, and predicates defined in the underlying logic, allowing fresh variable generation, term lookup, and selective filtering. Concrete use cases include implementing term rewriting, variable binding, and substitution-based reasoning in formal proofs.",
      "description_length": 422,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for handling string-based command-line parameters within a plugin system, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a custom type `t` that represents parameter values, along with standard types like `formatter`, `int`, and `bool`. Concrete use cases include managing and comparing string configuration options, checking project membership conditions, and generating user-friendly output for diagnostics or logging.",
      "description_length": 504,
      "index": 733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.Var",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical variables in the context of the WP plug-in's low-level logic language. It provides operations to compare, hash, and pretty-print variables, along with extracting their base names and associated logic sorts. Concrete use cases include variable management during theorem proving and debugging logic expressions.",
      "description_length": 356,
      "index": 734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED.STset",
      "library": "frama-c-wp.core",
      "description": "This module implements immutable sets for logically ordered terms, enabling efficient structural manipulation through operations like ordered traversal, set algebra (union, intersection, difference), and predicate-based transformations. It operates on sets of terms with externally defined total ordering, supporting use cases that require maintaining structural consistency during iterative refinement, ordered enumeration, or sequence-driven set construction. Key applications include logical term management with ordered traversal guarantees and set operations requiring structural equivalence checks.",
      "description_length": 604,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.As_string.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in a referential collection. It supports operations like equality checking, comparison, hashing, and pretty-printing for string values, along with deep copying and project membership testing. It is used to manage and manipulate string parameters within the WP plugin's configuration system.",
      "description_length": 371,
      "index": 736,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.QED.Vars",
      "library": "frama-c-wp.core",
      "description": "This module offers set-theoretic operations for managing collections of logical variables, supporting membership checks, union, intersection, and difference computations. It operates on immutable sets of variables (`var`), enabling functional transformations through folding, filtering, and mapping while preserving structural equality and ordering constraints. These operations are particularly useful in formal verification tasks requiring precise tracking and manipulation of variable dependencies, such as symbolic reasoning or static analysis in program proofs.",
      "description_length": 566,
      "index": 737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Set",
      "library": "frama-c-wp.core",
      "description": "This module implements ordered set operations for managing collections of elements with a fixed total ordering, supporting set algebra (union, intersection, difference), element manipulation (insertion, removal, membership checks), and ordered traversals (iteration, folding, mapping). It works with sets containing elements of a specific type that adheres to a predefined comparison function, maintaining internal ordering for efficient structural queries and range-based operations. Typical use cases include static analysis tasks requiring ordered collections of program entities, such as tracking verification conditions, managing proof obligations with ordered dependencies, or implementing domain-specific set transformations in Frama-C's verification pipelines.",
      "description_length": 768,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.As_string",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for managing string-based configuration parameters, supporting value setting and retrieval, alias handling, validation, and serialization customization. It works with strings and string lists, offering hooks for state tracking and extensible configuration patterns, while its child module defines a standard string parameter type with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checks, and is used to represent and manipulate string parameters within the WP plugin's configuration system. Examples include defining validated plugin settings like timeout values or function name restrictions, with change notifications for dynamic updates.",
      "description_length": 730,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BoundForallUnfolding.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling bound forall unfolding in the WP plugin. It supports deep copying, membership checks over project skeletons, and provides representants along with type and descriptor information. It is used to manage and manipulate logical parameters in the context of formal verification tasks within Frama-C.",
      "description_length": 432,
      "index": 740,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Ground.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports working with structural descriptors, project membership checks, and deep copying, all tailored for handling Frama-C project-specific data. Use cases include managing and manipulating analysis parameters within the WP plugin, such as storing, comparing, and serializing configuration values tied to Frama-C's project model.",
      "description_length": 451,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoDepth.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate depth-related parameters in the WP plugin. It supports structured data handling through a descriptor and provides deep copying, membership testing over project skeletons, and packed representation for serialization or storage. Concrete use cases include managing and comparing analysis depth configurations during static analysis in Frama-C.",
      "description_length": 491,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ProofTrace.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating proof trace elements within the WP plugin. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying of proof trace values, along with utilities to inspect and filter based on project membership. The type `t` is used to model proof trace data, supporting precise analysis and transformation of verification results.",
      "description_length": 422,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Hashtbl",
      "library": "frama-c-wp.core",
      "description": "This module provides a hash table implementation optimized for program point keys from a control-flow graph, supporting imperative operations like insertion, lookup, and in-place updates alongside functional transformations with folding and iteration. It handles mappings between nodes and arbitrary values, enabling efficient bulk initialization from sequences and incremental modifications during analysis or optimization passes. Typical applications include tracking dataflow values, managing trace metadata, or aggregating statistics across program points in compiler pipelines.",
      "description_length": 582,
      "index": 744,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyForall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for structural manipulation and comparison, including equality, hashing, and pretty-printing. It supports representant tracking, project membership checks, and deep copying, working with a type that includes embedded project skeletons. It is used to manage and reason about structured values within the WP plugin's simplification logic.",
      "description_length": 383,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Detect.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of representants, descriptors, and project values, enabling precise type handling and structural analysis. Concrete use cases include managing type-specific data during symbolic execution and verifying properties of structured values in static analysis.",
      "description_length": 461,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Reduce.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's reduction framework. It supports structured data manipulation with deep copying, membership testing within projects, and type representation via descriptors. Concrete use cases include managing and comparing symbolic states or expressions during program analysis, particularly in contexts requiring persistence or project-specific filtering.",
      "description_length": 481,
      "index": 747,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.CachePrint.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values within the WP plugin's caching and printing system. It includes functions for checking membership in projects, deep copying, and exposing structural descriptors for serialization or introspection. Concrete use cases include managing cached computation results tied to specific analysis projects and enabling structured value representation in user-facing outputs.",
      "description_length": 520,
      "index": 748,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Model.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with types like `t` for categories and `elt` for category elements, using accessors to bind them to states. Concrete use cases include setting default parameter behaviors, enabling all parameters under a category, and defining dependencies for category activation.",
      "description_length": 443,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ExternArrays.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values within the WP plugin, specifically tailored for handling arrays with external elements. It provides operations for equality checks, comparison, hashing, deep copying, and pretty-printing, along with utilities for inspecting and querying project-related data embedded in values. It is used to manage and reason about array structures that interface with Frama-C's kernel, enabling precise value representation and transformation in static analysis contexts.",
      "description_length": 538,
      "index": 750,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wpo.S.Map",
      "library": "frama-c-wp.core",
      "description": "This module implements ordered maps with keys of type `Wp.Wpo.S.t` and parametric values, supporting safe and ordered manipulation through insertion, deletion, merging, and predicate-based queries. It provides transformations like mapping and filtering, ordered traversal via folding and splitting, and sequence conversions, leveraging key ordering for positional operations such as min/max extraction. The module includes a key data type with equality, comparison, and pretty-printing, enabling precise introspection and efficient lookups, while a specialized submodule offers typed map operations for structured data like analysis results or configurations. Examples include managing dynamic key-value associations with safe updates, performing ordered traversals over ranges, and serializing map contents with custom formatting.",
      "description_length": 831,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating values used in command-line parameters within the WP plugin. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for inspecting and filtering based on project data. It is used to handle configuration values that must be passed and compared reliably across different parts of the plugin's analysis pipeline.",
      "description_length": 443,
      "index": 752,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Library.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating datatype representations, including equality checks, comparison, hashing, and pretty-printing. It works with a polymorphic type `t` and structured descriptors from the Frama-C kernel, supporting deep copying and project membership queries. Concrete use cases include handling command-line parameters with rich type information and ensuring consistent value representation across different contexts.",
      "description_length": 459,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Parasite.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in the WP plugin's parameter system. It includes functionality for checking membership of project-related values and performing deep copies, ensuring no shared references between original and copied instances. The type is used to represent and manipulate structured data within the plugin's analysis framework.",
      "description_length": 444,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string command-line parameters with validation, state tracking, and alias handling, supporting use cases like CLI argument parsing and configuration validation. It provides a core type `t` for representing string parameters with operations for comparison, hashing, and serialization, along with hooks for pre/post-change actions and controlled mutation. Submodules extend this functionality to specific domains such as WP's tactic framework, enabling structured parsing, deep copying, and project-based membership checks. Examples include validating string inputs against regex patterns, tracking parameter changes in a plugin system, and serializing parameter states for logging or replay.",
      "description_length": 710,
      "index": 755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.TimeExtra.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and user-friendly value display. Concrete use cases include managing and comparing complex parameter values in static analysis tasks within Frama-C.",
      "description_length": 453,
      "index": 756,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type for representing parameter datatypes in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It works with structured descriptors, project skeletons, and lists of representants to manage type information and values. Concrete use cases include defining and manipulating parameter types for command-line options and ensuring deep copying and project membership checks within the WP plugin's configuration system.",
      "description_length": 490,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusAll.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating status values within the WP plugin. It supports working with project-specific data through a `Project_skeleton.t` predicate and provides deep copying to ensure no shared references. Concrete use cases include managing and comparing analysis statuses, tracking project states, and facilitating serialization via a packed descriptor.",
      "description_length": 491,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptMode.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in script mode parameters of the WP plugin. It supports structured data representation with descriptors, packed descriptors, and a list of representants, enabling type-safe manipulation and introspection. Concrete use cases include managing and validating parameter values during script execution, ensuring deep copies and project membership checks for robust state handling.",
      "description_length": 509,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadassumes.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with a descriptor, a list of representatives, and project membership checks. Use it to manage typed, project-associated values in static analysis workflows.",
      "description_length": 312,
      "index": 760,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.Vars",
      "library": "frama-c-wp.core",
      "description": "This module offers functional set operations for managing collections of logical variables, including membership checks, union, intersection, difference, and transformations like filtering or mapping. It works with immutable sets represented by `Wp.Lang.F.Vars.t`, where elements are logical variables (`Wp.Lang.F.var`) used in formal verification contexts. These operations are particularly useful for symbolic reasoning tasks, such as tracking variable dependencies or manipulating proof states in theorem proving workflows.",
      "description_length": 526,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyIsCint.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type handling and introspection. Concrete use cases include managing and comparing symbolic execution parameters and ensuring type consistency during plugin operations.",
      "description_length": 449,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FinalizeScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in finalizing scripts within the WP plugin. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type manipulation and analysis. Concrete use cases include managing script-specific data structures during finalization phases, ensuring deep copies and project-specific filtering.",
      "description_length": 481,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S.Hashtbl",
      "library": "frama-c-wp.core",
      "description": "This module provides hash tables mapping structured keys to arbitrary values, with operations for insertion, deletion, lookup, and ordered traversal by keys, entries, or values. It supports key-value transformations, memoization, and conversions to and from sequences, enabling deterministic processing and caching of analysis data. The key module defines equality, comparison, and hashing for keys, including support for project-specific metadata, while the value module specializes handling for `Data.t` values with deep copying and project-aware comparisons. Together, they enable efficient, structured management of static analysis results and typed key-value associations within Frama-C plugins.",
      "description_length": 700,
      "index": 764,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.OldReportJson.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate structured data in the WP plugin's JSON reporting system. It includes functions for checking membership of project-related values, deep copying to avoid shared state, and descriptors for type representation. Concrete use cases include serializing analysis results to JSON, comparing and storing datatype instances in hash tables, and ensuring consistent handling of project-specific data across the plugin's interface.",
      "description_length": 568,
      "index": 765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Probes.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Concrete use cases include managing and comparing parameter values in the WP plugin's analysis framework, where deep copying and project membership checks are required.",
      "description_length": 502,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages named categories for organizing tactics within a command-line interface, using accessors to associate categories with states. It supports operations to define, retrieve, and modify categories such as '@none', '@default', and '@all', enabling dynamic configuration of tactic behavior. Concrete use cases include enabling or disabling groups of tactics via command-line flags and setting default or global tactic categories for consistent behavior.",
      "description_length": 466,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in a WP plugin, providing operations to define, enable, and manipulate parameter categories. It works with types like `elt`, `t`, and `Frama_c_kernel.State.t`, primarily handling collections of parameters grouped by category. Concrete use cases include setting default categories, enabling all parameters under a category, and defining relationships between categories like `@none`, `@default`, and `@all`.",
      "description_length": 465,
      "index": 768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.Subst",
      "library": "frama-c-wp.core",
      "description": "Implements term substitution within a logical context, supporting operations to add, find, and transform terms. Works with logical terms and substitution environments (`sigma`). Used to manipulate and traverse logical expressions during theorem proving or symbolic analysis.",
      "description_length": 274,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types that encapsulate a name, an accessor, and a list of dependencies on other state parameters. Concrete use cases include setting up configurable parameter groups that control behavior in the WP plugin, such as enabling or disabling sets of options based on user input or internal logic.",
      "description_length": 485,
      "index": 770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use as a command-line parameter in the WP plugin. It includes a unique name, a descriptor, and a packed representation for the type, supporting deep copying and membership checks over project skeletons. It is used to represent and manipulate parameter values with strong identity and structural consistency in the plugin's configuration system.",
      "description_length": 461,
      "index": 771,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.BackTrack.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's backtracking mechanism. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient state management during analysis. Concrete use cases include tracking and comparing analysis states, persisting data across backtracking points, and ensuring deep copies to prevent unintended sharing.",
      "description_length": 489,
      "index": 772,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wp.Wp_parameters.Clean.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating parameter specifications within the WP plugin. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to manage and persist parameter data structures with support for serialization and user-friendly display.",
      "description_length": 373,
      "index": 773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-valued command-line options with support for allowed values, validation, and update hooks, operating on `type t = string` and integrating with the state system for serialization and dynamic configuration. It provides operations for defining constraints, triggering actions on changes, and maintaining default values, while its child module enhances string parameter handling with equality, comparison, and pretty-printing capabilities. Examples include configuring analysis settings with restricted inputs, such as selecting a specific mode or target from a predefined list, and dynamically validating function names during runtime. Together, the module and its submodule enable robust, type-safe manipulation of string parameters within the WP plugin's configuration system.",
      "description_length": 802,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RTE.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values within the WP plugin, including operations for equality, comparison, hashing, and pretty printing. It supports structured data handling with functions like `mem_project` to check for embedded project values and `copy` for deep cloning. Use cases include managing and comparing complex state representations during program analysis.",
      "description_length": 413,
      "index": 775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Pmap",
      "library": "frama-c-wp.core",
      "description": "This module implements polymorphic maps with logical predicates as keys, supporting operations like insertion, lookup, and traversal alongside advanced transformations such as merging, filtering, and key-aware folding. It works with arbitrary value types and provides combinators for conditional updates, difference detection, and custom key-based logic, enabling efficient management of dynamic associations between logical expressions and metadata. Such capabilities are particularly useful in symbolic reasoning tasks like theorem proving or program verification, where predicate-driven state tracking is essential.",
      "description_length": 618,
      "index": 776,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadlocalinit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Use cases include managing and comparing parameter configurations within the WP plugin's analysis framework.",
      "description_length": 438,
      "index": 777,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic type `t` and standard operations for handling command-line parameters with rich type information, including equality, comparison, hashing, and pretty printing. It provides descriptors for type representation, supports deep copying, and includes utilities for checking membership within project skeletons. Concrete use cases include parsing and managing typed command-line arguments in the WP plugin, ensuring type-safe and structured parameter handling.",
      "description_length": 487,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptOnStdout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling script output representations. It supports structured data manipulation with deep copying, membership checks over project skeletons, and type descriptors for integration with the Frama-C kernel. Concrete use cases include managing and comparing script execution results within the WP plugin's analysis framework.",
      "description_length": 438,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Init.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It includes functionality for deep copying values, checking membership based on project properties, and provides representants along with type and descriptor information. It is used to manage and manipulate structured parameter data within the WP plugin's analysis framework.",
      "description_length": 446,
      "index": 780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.As_string",
      "library": "frama-c-wp.core",
      "description": "This module handles string-based command-line parameters in a plugin system, offering core operations like equality, comparison, hashing, and pretty-printing for string values. It supports deep copying and project membership testing, enabling robust manipulation of string configuration options. Submodules extend this functionality to structured data, allowing operations like parsing, validation, and transformation of string inputs into complex types. For example, it can represent plugin configuration flags, validate user-provided strings against expected formats, and integrate with larger data structures for plugin-specific settings.",
      "description_length": 641,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.As_string",
      "library": "frama-c-wp.core",
      "description": "This module configures and validates string-based command-line parameters, supporting defined values, aliases, and state change callbacks. It works with string values and lists to enforce constraints, enabling robust command-line interfaces with controlled modification, defaults, and extensible parsing. The child module enhances this functionality by providing operations for equality, comparison, and pretty-printing, along with deep copying and membership testing for string configuration options. Together, they allow defining a parameter like `\"output-format\"` with allowed values `\"json\"` and `\"text\"`, and triggering a callback when the value changes.",
      "description_length": 659,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Generate.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and deep copying, ensuring values can be uniquely identified and manipulated safely. Concrete use cases include managing and comparing symbolic representations of program states or configurations within the WP plugin's analysis framework.",
      "description_length": 478,
      "index": 783,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DynCall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic type `t` with operations for type representation, comparison, and memory management. It supports dynamic type handling with functions like `equal`, `compare`, `hash`, and `pretty` for value manipulation and inspection. Use cases include managing dynamically typed values in the WP plugin, ensuring type-safe operations and deep copying for state persistence.",
      "description_length": 392,
      "index": 784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.Parameter_category.t` and related accessors to associate names, dependencies, and states with each category. Concrete use cases include setting up default parameter behavior, enabling all parameters under a specific interpretation, and defining how `@all` behaves in different contexts.",
      "description_length": 486,
      "index": 785,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitMax.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and project membership checks for integration with Frama-C's project system. Use cases include managing and comparing symbolic execution parameters and ensuring deep copying for state isolation during analysis.",
      "description_length": 457,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusMaybe.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It includes utilities for deep copying values, checking membership within projects, and managing type descriptors for serialization and introspection. Concrete use cases include handling configurable parameters with optional status tracking in WP's verification process.",
      "description_length": 439,
      "index": 787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options in the WP plugin, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types that associate names with parameter accessors and dependency lists of states. Concrete use cases include setting up configurable parameter groups and controlling default or global behavior of parameters through category activation or equivalence.",
      "description_length": 462,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Procs.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating procedural parameters in the WP plugin. It includes operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. The module works with a structured type `t` that encapsulates parameter descriptors, names, and representations, supporting precise handling of parameter data within the WP analysis framework.",
      "description_length": 442,
      "index": 789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Properties.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with `elt` elements and `t` category types, using accessors and state lists to control parameter behavior. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific semantics, and defining dependencies for category activation.",
      "description_length": 457,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CounterExamples.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing counterexamples in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with structured data involving project skeletons and provides deep copying to ensure no shared state. Concrete use cases include managing and analyzing counterexample data during formal verification tasks in Frama-C.",
      "description_length": 394,
      "index": 791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Map",
      "library": "frama-c-wp.core",
      "description": "This module provides a functional map implementation for associating data with program points represented by `Wp.CfgCompiler.Node.t` keys, supporting operations like insertion, lookup, filtering, and set-theoretic combinations. It emphasizes immutability and composability, enabling transformations and comparisons of node-indexed data through key-aware merging, difference computation, and parallel iteration. It is particularly useful in static analysis or program verification tasks where per-node state tracking (e.g., invariants, data flow values) requires efficient, persistent map manipulations.",
      "description_length": 602,
      "index": 792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitConj.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's splitting and conjunction handling. It supports structured data representation with a list of representatives, a type descriptor, and a packed descriptor for efficient storage and comparison. Concrete use cases include managing logical assertions and proof obligations that require deep copying, project membership checks, and user-readable output formatting.",
      "description_length": 512,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeMargin.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data manipulation with deep copying, membership testing over project skeletons, and provides type and descriptor information. Concrete use cases include representing and managing time margin configurations in a way that supports persistence, comparison, and user-facing output formatting.",
      "description_length": 430,
      "index": 794,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.F.Pset",
      "library": "frama-c-wp.core",
      "description": "This module implements an immutable set structure for logical predicates, supporting set algebra operations like union, intersection, and difference, along with functional transformations such as mapping, filtering, and folding. It operates on elements of type `Wp.Lang.F.pred` and provides utilities for partitioning, size computation, and list conversion, enabling efficient manipulation of logical term collections. Typical use cases include formal verification tasks requiring persistent storage of propositional logic elements, such as managing proof contexts or analyzing program invariants.",
      "description_length": 597,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InteractiveTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling interactive timeout parameters in the WP plugin. It supports structured values that may contain embedded project data, enabling checks for project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing timeout configurations during interactive proof sessions.",
      "description_length": 444,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Heap.Set",
      "library": "frama-c-wp.core",
      "description": "This module offers operations for managing collections of elements through standard set operations like union, intersection, and filtering, alongside transformations such as mapping and folding. It works with sets containing elements of a specified type, supporting both structural equality checks and ordered traversal. These capabilities are useful in static analysis tasks requiring precise tracking and manipulation of element groups, such as aggregating memory regions or validating relationships between data structures.",
      "description_length": 526,
      "index": 797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CheckMemoryContext.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in memory context checks within the WP plugin. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Use cases include managing and validating memory state representations during program analysis, ensuring deep copies and project-specific membership checks.",
      "description_length": 500,
      "index": 798,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Cache.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in caching within the WP plugin. It supports structured data management through a descriptor and provides deep copying and project membership checks. Concrete use cases include storing and retrieving parameterized values in a cache, ensuring efficient comparisons and memory isolation through deep copies.",
      "description_length": 439,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type for representing and manipulating parameter datatypes used in command-line options. It provides operations for equality checking, comparison, hashing, pretty-printing, deep copying, and project membership testing. Use cases include defining and handling structured command-line parameters with rich type information and descriptors.",
      "description_length": 373,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.MemoryContext.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing memory contexts in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It works with structured data involving project skeletons and provides utilities to check membership, create deep copies, and inspect values through descriptors. Concrete use cases include managing and comparing memory states during symbolic execution and verifying properties of program analyses within Frama-C.",
      "description_length": 472,
      "index": 801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.As_string",
      "library": "frama-c-wp.core",
      "description": "This module handles string-based command-line parameters with utilities for validation, transformation, and change tracking, operating on `type t = string` and integrating with plugin systems for state management. It supports operations such as equality checks, comparison, hashing, and pretty-printing, along with deep copying and project membership testing through its child module. It enables use cases like enforcing allowed string values, synchronizing configuration changes across plugins, and representing function names in a type-safe manner. The combination of direct value manipulation and project-aware operations ensures consistent handling of string parameters in both standalone and extensible contexts.",
      "description_length": 717,
      "index": 802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages named categories for grouping and controlling function timeout parameters, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with `elt` values representing timeout settings and uses `Parameter_category.t` to structure category behavior. Concrete use cases include configuring timeout policies for function analysis, enabling global defaults, or activating all categories with specific interpretations.",
      "description_length": 486,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters related to provers, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with parameter categories and state lists, using accessors to bind categories to specific behaviors. Concrete use cases include setting default prover categories, enabling all provers with specific interpretations, and defining dependencies for category activation.",
      "description_length": 456,
      "index": 804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Havoc.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating values used in the WP plugin's havoc analysis. It provides operations for equality testing, comparison, hashing, pretty-printing, and deep copying, as well as utilities for checking membership of project values and structural representation. It is used to handle specific analysis parameters such as symbolic values or constraints during formal verification tasks.",
      "description_length": 430,
      "index": 805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string command-line parameters with support for validation, alias resolution, and state tracking, ensuring strict input constraints and compatibility with analysis frameworks. It defines a core type `t` for representing parameter values, with operations for comparison, hashing, pretty printing, and deep copying, alongside functions for checking membership in project-specific contexts. Submodules extend this functionality to handle lists of string parameters and integrate with the WP plugin's analysis pipeline. Example uses include validating function names against a whitelist, enforcing allowed option values, and tracking parameter state across different analysis stages.",
      "description_length": 699,
      "index": 806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Steps.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating step parameters within the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with structured data involving project skeletons and provides deep copying to ensure no shared references. Concrete use cases include managing and persisting step configurations, validating project-specific data, and enabling modular reasoning over WP parameters.",
      "description_length": 462,
      "index": 807,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitSwitch.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptors, and representants, enabling type-safe manipulation and introspection. Concrete use cases include managing and persisting parameter configurations, checking project membership, and ensuring deep copies of parameter values for analysis tasks.",
      "description_length": 492,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusTrue.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a specific data type used within the WP plugin for Frama-C, providing operations for equality checks, comparison, hashing, and pretty printing of values. It includes functions for deep copying and checking membership based on project-related predicates. This type is used to represent and manipulate internal WP plugin data tied to analysis statuses, enabling precise handling of verification results across different program states.",
      "description_length": 453,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusFalse.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling status-related values within the WP plugin. It supports structured data management through deep copying, membership testing in projects, and type representation with descriptors. Concrete use cases include tracking and comparing analysis statuses, enabling precise project-specific value checks, and facilitating serialization via hashing and pretty-printing.",
      "description_length": 485,
      "index": 810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing command-line parameter types in the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of parameter type representations, descriptors, and project membership checks. Concrete use cases include managing and validating WP plugin command-line options and ensuring deep copying of parameter values.",
      "description_length": 411,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with validation, dynamic constraints, and state tracking, operating on enriched string parameters with metadata such as allowed values and default states. It supports alias resolution, custom serialization, and value change hooks, enabling dynamic option handling and persistent configuration in CLI interfaces. The child module enhances this functionality with equality checks, comparison, hashing, and pretty printing for parameter values, along with type descriptors and project membership testing. Together, they enable workflows like static code analysis and project-specific parameter behavior with direct manipulation of string parameters and their associated metadata.",
      "description_length": 733,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Interactive.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation through a descriptor, packed descriptor, and a list of representatives, enabling introspection and serialization. Use cases include managing and manipulating complex data structures within the WP plugin, such as storing and retrieving typed values in a project-aware context.",
      "description_length": 435,
      "index": 813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ReportName.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate report names in the WP plugin. It includes functions for deep copying values, checking membership based on project properties, and provides a list of representative values for the type. The module is used to handle report name data in a structured and type-safe manner during WP analysis.",
      "description_length": 438,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports values that may contain project-specific data, allowing checks for the presence of projects satisfying certain predicates and enabling deep copying to avoid shared state. Concrete use cases include managing and comparing timeout-related parameters within the WP plugin's analysis framework.",
      "description_length": 473,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AliasInit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and project membership checks via `mem_project`. Concrete use cases include managing and comparing complex parameter values in static analysis workflows, ensuring deep copies and proper type handling.",
      "description_length": 447,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string command-line parameters with validation, state tracking, and serialization, supporting operations to define allowed values, validate inputs, and register callbacks for value changes. It introduces the core type `t` for representing parameter values, alongside standard operations for comparison, hashing, and pretty printing via `formatter`. Submodules extend functionality for use cases like CLI option parsing with strict validation, dynamic configuration updates with state transitions, and handling aliases or structured collections of permitted values. Examples include validating project membership strings, tracking configuration changes with callbacks, and serializing parameter states for persistence or diagnostics.",
      "description_length": 752,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTimeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's smoke timeout configuration. It includes functions for deep copying values, checking membership within projects, and provides representants along with type and descriptor information. Concrete use cases include managing timeout settings during verification tasks and ensuring consistent handling of configuration data across analysis sessions.",
      "description_length": 496,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Literals.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating values within the WP plugin's parameter system. It supports operations for equality checking, comparison, hashing, and pretty-printing, as well as deep copying and project membership testing. It is used to handle parameter values that are stored and compared during WP's analysis of C code.",
      "description_length": 356,
      "index": 819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Volatile.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation through descriptors, packed types, and project membership checks. Use cases include managing volatile parameter values with deep copying, comparing and hashing typed values, and inspecting or formatting data for debugging or user output.",
      "description_length": 400,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with parameter collections and state lists, using accessors to bind categories to specific behaviors. Concrete use cases include enabling or disabling groups of parameters collectively, setting default interpretations, and defining how the `@all` category interacts with positive or negative command-line flags.",
      "description_length": 492,
      "index": 821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Verbose.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use within the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and deep copying to ensure no shared state. Use cases include managing and comparing verbose parameter configurations during static analysis tasks in Frama-C.",
      "description_length": 418,
      "index": 822,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadloop.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's smoke deadloop analysis. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives for introspection and type manipulation. The type is designed for deep copying, project membership checks, and integration with Frama-C's project system, enabling use cases like analysis state tracking and configuration management.",
      "description_length": 514,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Tmap",
      "library": "frama-c-wp.core",
      "description": "This module implements associative containers mapping logic terms to arbitrary values, supporting insertion, transformation, and set-theoretic operations with custom merge strategies. It handles key-based comparisons, subset checks, and iterative modifications over polymorphic maps, enabling precise manipulation of term-indexed data. Typical applications include symbolic reasoning systems and formal verification tools requiring structured association between logical expressions and domain-specific metadata.",
      "description_length": 512,
      "index": 824,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.PrecondWeakening.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling precondition weakening configurations. It supports deep copying and membership checks over project skeletons, ensuring structural integrity and uniqueness through its descriptor and representants. It is used to manage and manipulate analysis parameters within the WP plugin's logical framework.",
      "description_length": 419,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ExtEqual.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, intended for use in the WP plugin's parameter system. It supports deep copying and checks for the presence of project-related values using predicate functions. The type is used to manage and manipulate parameter values with strong identity and structural properties in the WP plugin's analysis workflows.",
      "description_length": 408,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with category elements and accessors tied to plugin states, allowing configuration of how parameters are interpreted in different contexts. Concrete use cases include setting default parameter behavior, enabling all parameters under a specific interpretation, and defining custom categories with dependencies.",
      "description_length": 488,
      "index": 827,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based command-line parameters with support for value constraints, validation, and dynamic state handling. It operates on string data augmented with metadata such as allowed value lists, validation predicates, and serialization rules, enabling use cases like configuration options that require strict value checking, alias resolution, or project-scoped state persistence. The child module enhances this functionality by providing core operations for representing, comparing, and manipulating these string values, including deep copying, pretty-printing, and project membership testing. Together, they allow developers to define configurable options that can be validated, modified, and persisted across different contexts, such as WP plugin settings or command-line flags with custom validation logic.",
      "description_length": 827,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTests.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's smoke testing framework. It supports structured data representation with a list of representative values, a type descriptor, and a packed descriptor for runtime inspection. The type is designed for deep copying and project-aware membership checks, enabling use cases like test case validation and project state analysis within the WP plugin ecosystem.",
      "description_length": 500,
      "index": 829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.UnfoldAssigns.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter handling. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type manipulation and analysis. Concrete use cases include managing and comparing symbolic execution states and parameter configurations during static analysis.",
      "description_length": 456,
      "index": 830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use as a command-line parameter in the WP plugin. It supports deep copying, membership testing within projects, and provides descriptors for type representation and serialization. Concrete use cases include managing and manipulating parameter values during WP plugin execution, such as storing and comparing analysis configurations or result data.",
      "description_length": 477,
      "index": 831,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Report.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages named categories for organizing command-line parameters in the WP plugin. It provides operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`, each controlling how parameters are interpreted and enabled. Functions allow setting accessors, dependencies, and behaviors for these categories, specifically tailored for use with parameter collections in the WP plugin interface.",
      "description_length": 434,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcode.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's smoke deadcode analysis. It supports deep copying and membership checks over project skeletons, ensuring structural integrity and uniqueness through its descriptor and representants. Concrete use cases include managing analysis states and comparing configurations during deadcode detection.",
      "description_length": 437,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitBranch.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's split branch functionality. It supports values that may contain project-specific data, allowing checks on embedded projects via `mem_project` and enabling deep copies to avoid shared state. Concrete use cases include managing and comparing split branch configurations during program analysis.",
      "description_length": 445,
      "index": 834,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ReportJson.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in JSON-based reporting within the WP plugin. It supports structured data representation with descriptors, packed representations, and project membership checks, enabling efficient data manipulation and serialization. Concrete use cases include storing and comparing analysis results, generating human-readable output, and ensuring deep copies for safe data handling.",
      "description_length": 501,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.QED",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates the construction and manipulation of logical terms, integrating arithmetic and boolean expressions, logical connectives, quantifiers, and term rewriting rules. It supports variable binding, substitution, type inference, and term analysis, enabling formal verification tasks like theorem proving and logical expression optimization. Data structures such as polymorphic maps and sets manage term-indexed data with structural or identifier-based ordering, supporting operations like union, intersection, and ordered traversal. Specific capabilities include term hashing and pretty-printing for debugging, substitution environments for rewriting, and typed variable handling for logical state management.",
      "description_length": 725,
      "index": 836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Dump.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type and associated operations for representing and manipulating structured data within the WP plugin. It includes functions for equality checks, comparison, hashing, pretty-printing, and deep copying, as well as utilities for inspecting and traversing project-related data. The module is used to manage and persist complex data structures during static analysis, ensuring consistency and efficient handling of analysis results.",
      "description_length": 455,
      "index": 837,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.CalleePreCond.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating callee precondition parameters in the WP plugin. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, as well as querying over project-specific data. The type is used to manage and reason about preconditions during verification tasks involving function calls.",
      "description_length": 378,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyType.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for structural manipulation and comparison, including equality, hashing, and pretty-printing. It supports working with representants of a descriptor, deep copying values, and checking membership within projects using predicate functions. Concrete use cases include managing and comparing complex data structures in static analysis, such as abstract values or symbolic expressions.",
      "description_length": 428,
      "index": 839,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Let.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling deep copying and project-specific queries. Concrete use cases include managing and manipulating parameterized data structures within the WP plugin, such as storing and comparing symbolic execution states or configuration settings.",
      "description_length": 516,
      "index": 840,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StrategyEngine.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's strategy engine. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and project-based queries. Concrete use cases include managing and comparing strategy engine configurations, validating project inclusions, and serializing data for analysis or user output.",
      "description_length": 480,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Prune.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's pruning functionality. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling efficient data manipulation and analysis. Concrete use cases include managing and comparing intermediate values during program analysis, particularly for pruning redundant or unreachable states.",
      "description_length": 492,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TerminatesVariantHyp.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with type information, descriptors, and deep copying, enabling robust handling of variant termination hypotheses. Concrete use cases include managing and manipulating typed data within the WP plugin's internal logic, such as storing and comparing analysis parameters or hypothesis states.",
      "description_length": 501,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Vmap",
      "library": "frama-c-wp.core",
      "description": "This module provides polymorphic map operations for variable-keyed collections, supporting key-based transformations, merges with custom conflict resolution, and structural comparisons. It works with maps (`Vmap.t`) that associate values with logical variables (`Wp.Lang.F.var`), enabling precise manipulation of key-value pairs through operations like `merge`, `diffq`, and `subset`. These capabilities are particularly useful in formal verification contexts for tracking variable bindings, reconciling overlapping logical contexts, or analyzing symbolic constraints with custom equivalence rules.",
      "description_length": 598,
      "index": 844,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-valued command-line parameters with validation, default states, and dynamic value handling, supporting controlled input formats and runtime evaluation. It defines a core string parameter type with operations for equality, comparison, hashing, and pretty-printing, while enabling deep copying, membership testing, and project-specific queries. Use cases include handling user-defined strings in static analysis tools, managing configuration values with structured descriptors, and integrating with plugin systems via change-tracking hooks. It supports alias resolution, custom serialization, and controlled value sets for configuration options.",
      "description_length": 670,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing command-line parameters in the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a polymorphic type `t` that encapsulates parameter values, along with descriptors and representants for type inspection and serialization. Concrete use cases include managing and comparing WP-specific analysis options, persisting configurations, and ensuring deep copying of parameter states.",
      "description_length": 483,
      "index": 846,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgCompiler.Node.Set",
      "library": "frama-c-wp.core",
      "description": "This module provides set operations for managing collections of program points in a control flow graph, supporting membership tests, union, intersection, difference, and subset comparisons. It includes utilities for iterating, folding, filtering, and transforming sets of nodes, along with predicates to analyze relationships between them. These operations are used to process execution traces, partition code paths, and compute structural properties like reachability or coverage in static analysis workflows.",
      "description_length": 510,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with `Parameter_category.t` structures and supports adding named categories with accessors and dependencies. Concrete use cases include setting up and modifying parameter behavior interpretations in the WP plugin's command-line interface.",
      "description_length": 422,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling command-line parameters in the WP plugin. It provides descriptors, representants, and utilities for deep copying and project membership checks. Concrete use cases include managing and comparing parameter values during plugin execution and configuration.",
      "description_length": 383,
      "index": 849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DryFinalizeScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports values that may contain project-specific data, allowing checks for the presence of projects satisfying a predicate and enabling deep copies to avoid shared state. Concrete use cases include managing and comparing script parameters during the dry-run and finalization phases of WP analysis.",
      "description_length": 472,
      "index": 850,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.WeakIntModel.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured representations through descriptors, packed descriptors, and a list of representatives, enabling type inspection and serialization. The module is used to manage and manipulate abstract data values within the WP plugin, particularly for tracking and copying state across projects.",
      "description_length": 422,
      "index": 851,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Print.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and user-friendly output formatting. Concrete use cases include managing and comparing complex parameter configurations during static analysis tasks in Frama-C.",
      "description_length": 465,
      "index": 852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and comparing datatype values used in command-line parameters, including equality, comparison, hashing, and pretty-printing. It works with the abstract type `t` and lists of representants, supporting deep copying and membership checks over project skeletons. Concrete use cases include handling parameter values with structured equality and comparison logic, and ensuring deep copies for safe manipulation in command-line interfaces.",
      "description_length": 477,
      "index": 853,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Simpl.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports values that may contain project-specific data, allowing checks for the presence of project elements via `mem_project` and enabling deep copies to avoid shared state. Concrete use cases include managing and comparing symbolic representations in verification tasks, such as tracking function contracts or proof obligations tied to specific analysis projects.",
      "description_length": 539,
      "index": 854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt.As_string",
      "library": "frama-c-wp.core",
      "description": "This module handles string-valued command-line parameters with support for validation, alias resolution, and stateful updates. It defines a core type `t` for string data, along with operations for comparison, hashing, and pretty-printing, while maintaining metadata such as allowed values, defaults, and modification hooks. Submodules provide context-aware handling of parameters, enabling type-safe manipulation and integration with larger configuration systems. Examples include enforcing valid function names from CLI input, tracking parameter changes in runtime state, and mapping command-line options to predefined configuration values.",
      "description_length": 641,
      "index": 855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RunAllProvers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating prover configurations in the WP plugin. It supports operations for comparing, hashing, and pretty-printing these configurations, as well as checking project membership and performing deep copies. It is used to manage and track different prover settings within the analysis framework.",
      "description_length": 349,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoWidth.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling type-safe manipulation and introspection. Concrete use cases include managing and validating parameter values during plugin execution, such as checking project membership and performing deep copies of parameter states.",
      "description_length": 510,
      "index": 857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-valued command-line parameters with validation, dynamic updates, and customizable serialization, working with a core type `t` that supports equality, comparison, hashing, and pretty-printing. It allows restricting values through allowed lists or validation functions, making it suitable for plugin configuration and other scenarios requiring strict parameter control. The module supports alias resolution, state change notifications, and marshaling for integration with command-line interfaces or persistent state systems. Child modules enhance this functionality by providing structured operations on the underlying string parameter type.",
      "description_length": 666,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyLandMask.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for representing and manipulating values used in the simplification of land mask parameters. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Use cases include managing configuration or state values that require structural comparison and persistence across analysis sessions.",
      "description_length": 393,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors.As_string",
      "library": "frama-c-wp.core",
      "description": "This module configures and validates string-based command-line parameters with support for value constraints, alias resolution, and change tracking, operating on string values and constrained string sets. It provides utilities to enforce valid function name formats, register transformation hooks, and serialize parameter states, while its child module introduces a datatype for handling string parameters with operations for comparison, hashing, pretty-printing, and project membership testing. Together, they enable dynamic validation in plugin systems or CLI tools requiring strict input sanitization, such as verifying function name formats or tracking parameter state changes. Example uses include defining valid identifier patterns, applying string transformations before execution, and comparing or copying parameter values during workflow execution.",
      "description_length": 857,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating parameter data types, including equality checks, comparison, hashing, and pretty printing. It works with a polymorphic type `t` representing parameter values, along with descriptors, packed representations, and project-aware data. Concrete use cases include handling command-line parameters with type-safe values, comparing and copying parameter states, and checking project membership within parameter data.",
      "description_length": 469,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheEnv.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient caching and environment management. Concrete use cases include managing typed values in a symbolic execution context and ensuring deep copying and project-specific queries within the WP analysis framework.",
      "description_length": 488,
      "index": 862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Filter.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values within the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with a custom type `t` that encapsulates values involving project-specific data, allowing deep copies and membership checks over project skeletons. Concrete use cases include managing and filtering WP-specific data structures during static analysis, such as tracking and comparing symbolic states or constraints.",
      "description_length": 511,
      "index": 863,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages named categories for organizing command-line parameters, supporting operations to create, modify, and retrieve categories with specific accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to define and control parameter behavior. Concrete use cases include defining the `@none`, `@default`, and `@all` categories, enabling all parameters with a specific interpretation, or setting a category as the default or equivalent to `@all`.",
      "description_length": 508,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Memlimit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for values that may contain embedded project skeletons. It supports deep copying and membership testing for project-related data through the `mem_project` function. Concrete use cases include managing and comparing memory limit configurations that reference project states in the WP plugin.",
      "description_length": 416,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages categories for command-line parameters in the WP plugin, providing operations to define, enable, and modify parameter categories such as `@none`, `@default`, and `@all`. It works with parameter collections and state lists, using accessors to associate values with categories. Concrete use cases include setting default parameter behavior, enabling all parameters under a specific interpretation, and defining dependencies between categories and states.",
      "description_length": 472,
      "index": 866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating prover-related values with operations for equality, comparison, hashing, and pretty-printing. It works with a concrete type `t` that includes a name, descriptor, and representants, supporting deep copying and membership checks over project skeletons. It is used to manage and validate prover configurations through command-line parameters.",
      "description_length": 405,
      "index": 867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Timeout.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing timeout configurations within the WP plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with a concrete type `t` that encapsulates timeout-related values, including project-specific settings. Use cases include managing and comparing different timeout policies, serializing and deserializing timeout states, and ensuring deep copies of timeout configurations for safe manipulation across different analysis contexts.",
      "description_length": 516,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line configuration, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with parameter collections, using accessors to bind categories to states and dependencies. Concrete use cases include setting default parameter behavior, enabling all parameters under a specific interpretation, and aliasing the `@all` category to another category.",
      "description_length": 451,
      "index": 869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma.Heap.Map",
      "library": "frama-c-wp.core",
      "description": "This module implements associative maps with keys representing heap chunks, supporting key-based access, value transformations, and ordered/unordered traversal. It provides algebraic operations like union, intersection, and difference with customizable merging strategies, along with equality and subset checks using key-aware higher-order functions. These maps are particularly suited for symbolic heap analysis tasks requiring precise key integrity management and combinatorial set operations on heap-structured data.",
      "description_length": 519,
      "index": 870,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVal.Eva.State",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory states during static analysis, providing operations to construct and combine states from program elements like statements and kernel functions. It supports data types such as `t` for abstract states, derived from CIL constructs like `kinstr`, `stmt`, and `kernel_function`. Use cases include computing initial states for analysis steps, merging states from different control-flow paths using `join`, and pretty-printing states for debugging or reporting.",
      "description_length": 493,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.Category",
      "library": "frama-c-wp.core",
      "description": "This module manages parameter categories for command-line flags, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with types representing parameter elements and category structures, supporting dependencies and accessors for state manipulation. Concrete use cases include configuring flag behavior across different analysis modes and enabling/disabling groups of flags collectively.",
      "description_length": 452,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports values of type `t` that can be deeply copied, checked for project membership, and represented in a user-friendly format. Concrete use cases include managing and comparing parameter configurations within the WP plugin's analysis framework.",
      "description_length": 421,
      "index": 873,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Prenex.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating abstract values within the WP plugin, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a structured type `t` that includes descriptors, names, and representations, enabling precise handling of project-specific data. Concrete use cases include managing and comparing symbolic expressions, tracking project elements through predicates, and ensuring deep copies for mutation-free transformations.",
      "description_length": 503,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for managing command-line parameters related to sets in the context of the WP plugin. It provides operations for equality checks, comparison, hashing, deep copying, and pretty-printing of parameter values, along with utilities to inspect and filter based on project data. The type `t` represents the parameter values, and functions like `mem_project` allow checking presence of specific project elements within a value.",
      "description_length": 451,
      "index": 875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Core.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with descriptors and representants for structural manipulation. It supports deep copying and project membership checks, enabling precise handling of parameter data within the WP plugin. Concrete use cases include managing and comparing parameter configurations during static analysis and ensuring correct data representation across different analysis phases.",
      "description_length": 472,
      "index": 876,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate command-line parameters in the context of the Why3 flags system. It supports values that may contain project-specific data, allowing checks for membership and deep copying to avoid shared state. Concrete use cases include managing and comparing parameter values during command-line processing and ensuring consistent representation across different parts of the plugin's configuration.",
      "description_length": 535,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F.Tset",
      "library": "frama-c-wp.core",
      "description": "This module implements a functional set structure for logic terms, offering operations like union, intersection, difference, and membership checks alongside transformations via mapping and filtering. It enforces set semantics (uniqueness, orderlessness) for collections of terms, enabling use cases such as partitioning based on logical predicates, computing intersections during symbolic reasoning, or iterating over normalized term representations in formal verification workflows.",
      "description_length": 483,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages and validates string command-line parameters, supporting value setting, update hooks, alias handling, and serialization. It defines a core type `t` for string parameters with operations for comparison, hashing, and pretty printing, along with lists and type descriptors for structured handling. Submodules extend this functionality to support plugin configuration workflows, including deep copying, project membership checks, and value comparison. Example uses include managing CLI state, enforcing parameter constraints, and serializing configuration settings for plugins.",
      "description_length": 593,
      "index": 879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Library.As_string",
      "library": "frama-c-wp.core",
      "description": "This module handles string-based command-line parameters for the WP plugin, offering core operations like equality checks, comparison, hashing, and pretty printing. It includes descriptors for type representation and supports project membership testing and deep copying of string values. With this module, users can manage and manipulate WP plugin options exposed through the command line, enabling tasks like parameter validation, serialization, and integration with other plugin systems.",
      "description_length": 489,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and manipulating a specific datatype used in command-line parameters of the WP plugin. It provides functions for equality checks, comparison, hashing, deep copying, and pretty-printing values of type `t`, along with utilities to inspect and query project-related data. Use cases include handling parameter values during command-line parsing and maintaining distinct, comparable representations of parameter settings.",
      "description_length": 460,
      "index": 881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Debug.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically used to represent and manipulate structured debug information within the WP plugin. It includes functions for checking membership in projects, deep copying values, and exposing type descriptors for integration with Frama-C's kernel. Concrete use cases include managing and comparing symbolic representations of program states during verification and debugging tasks.",
      "description_length": 483,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheDir.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in caching directories within the WP plugin. It supports structured data representation with descriptors, packed types, and project membership checks, enabling efficient storage and retrieval of typed values. Concrete use cases include managing cached computation results tied to specific projects and ensuring deep copies to prevent shared state.",
      "description_length": 481,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Status.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing status values within the WP plugin, including operations for equality, comparison, hashing, and pretty-printing. It supports structured data handling with functions to check membership in projects, create deep copies, and describe values through type descriptors. Concrete use cases include managing and comparing analysis statuses, tracking project-specific state, and serializing status information for reporting or storage.",
      "description_length": 475,
      "index": 884,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.TruncPropIdFileName.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling truncated property identifiers and file names within the WP plugin. It supports structured data representation with a unique name, type descriptor, and project membership checks, ensuring deep copying and user-friendly output. Use cases include managing and distinguishing between property identifiers in formal verification tasks where precise naming and structural integrity are critical.",
      "description_length": 525,
      "index": 885,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitCNF.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type for representing and manipulating CNF (Conjunctive Normal Form) splitting parameters in the WP plugin. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for inspecting and filtering project-related data. It is used to manage and reason about different configurations or states during the splitting of logical formulas in the context of program verification.",
      "description_length": 466,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InitWithForall.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed types, and project membership checks, enabling deep copies and project-specific queries. Concrete use cases include managing and comparing symbolic execution parameters and ensuring type consistency during plugin operations.",
      "description_length": 450,
      "index": 887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FilterInit.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter filtering system. It includes functionality for checking membership within project structures and performing deep copies of values. Concrete use cases include managing and comparing parameter configurations during the initialization phase of the WP plugin's analysis.",
      "description_length": 430,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WP.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the WP plugin's parameter system. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling deep copies and efficient value comparisons. Concrete use cases include managing and manipulating parameterized data structures within the WP plugin's analysis framework.",
      "description_length": 450,
      "index": 889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrepareScripts.Datatype",
      "library": "frama-c-wp.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the WP plugin's parameter system. It supports structured data representation with a descriptor, a list of representatives, and project membership checks, enabling robust type handling and introspection. Concrete use cases include managing and validating parameterized data structures during script preparation and analysis in the WP plugin.",
      "description_length": 477,
      "index": 890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers.As_string",
      "library": "frama-c-wp.core",
      "description": "This module manages string-valued command-line parameters with support for validation, aliases, and value change hooks, operating on a data type that enables equality checks, comparison, and structured serialization. It allows configuration of command-line interfaces with customizable validation rules and function name resolution, while supporting deep copying and membership checks over project skeletons. Use cases include dynamic configuration management for theorem provers and building parameter-driven workflows with state tracking. The module combines direct manipulation of string parameters with structured representations for extensible and maintainable command-line interfaces.",
      "description_length": 690,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitSwitch",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean state switches with support for toggling values, update callbacks, and command-line integration via aliases and documentation. It handles parameterized boolean states alongside metadata for persistence, serialization, and immutability tracking, making it suitable for feature flags and configurable analysis options that require runtime and cross-session consistency. The module includes a data type with operations for equality, comparison, hashing, and pretty-printing, enabling structured, type-safe manipulation of parameter configurations, project membership checks, and deep copies for analysis. Use cases include managing plugin settings that respond to user inputs and automated systems while ensuring controlled state evolution through hooks and lifecycle management.",
      "description_length": 804,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VCS.Pmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a persistent map structure keyed by prover identifiers, offering functional operations like insertion, removal, and value updates, along with combinators for merging and combining maps. It supports ordered traversal, filtering, and transformations over key-value pairs, with utilities for bulk updates from sequences and conversion to ordered lists. Designed for tracking proof results across different provers, it enables efficient aggregation, comparison, and ordered processing of verification outcomes in static analysis workflows.",
      "description_length": 558,
      "index": 893,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Plang.Env",
      "library": "frama-c-wp.core",
      "description": "Manages variable binding and naming contexts for term pretty-printing, ensuring unique identifier generation and tracking of used names. It supports operations to define, unfold, and share terms, with utilities to check name usage and create fresh names using a provided sanitizer function. This module is used to maintain environment state when generating human-readable representations of formal logic terms.",
      "description_length": 410,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Timeout",
      "library": "frama-c-wp.core",
      "description": "This module manages numeric timeout parameters with support for setting, retrieving, and validating integer values, including range constraints and event hooks for state changes. It integrates with project-specific state systems for persistence and serialization, enabling use cases like CLI setup with custom aliases and validation. The child module enhances this functionality by defining a structured type `t` for timeout configurations, supporting comparisons, hashing, and pretty printing. Together, they enable robust handling of timeout policies, including safe copying, serialization, and triggering actions on value changes.",
      "description_length": 633,
      "index": 895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVal.Value-State",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory states for static analysis, providing operations to compute and combine memory values at different program points. It works with control-flow elements like statements, kernel functions, and instructions to model memory abstractions. Concrete use cases include tracking memory effects of function calls, merging memory states at branch joins, and printing abstract memory representations for debugging or reporting.",
      "description_length": 453,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing frames and call contexts to model function calls and memory environments, compiling CIL terms into logical expressions, and analyzing terms and memory regions for verification. It operates on memory states (sigma), environments (env), frames encapsulating function call data, and logical representations of C constructs. These capabilities support formal verification tasks like validating ACSL contracts, modeling memory effects of function calls, and checking memory assignments through logical analysis.",
      "description_length": 551,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DefaultStrategies",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters as string lists, supporting operations to set, retrieve, and transform values with state tracking, aliases, and serialization. It provides list manipulations such as appending, iteration, and folding, enabling dynamic configuration of project-specific parameters and runtime adjustments. The first child module defines a strongly-typed command-line parameter with identity, comparison, and deep copying, used to represent values in the WP plugin with structural consistency. The second child module enhances string-based parameters with validation, constraints, and metadata, allowing strict value checking and persistence across contexts like plugin settings or command-line flags. The third child module organizes parameters into named categories, supporting creation, modification, and dependency tracking with built-in accessors for common interpretations such as `@none`, `@default`, and `@all`.",
      "description_length": 944,
      "index": 898,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Steps",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter with configurable bounds, providing operations to retrieve, set, increment, and validate its value within limits. It integrates with Frama-C's plugin system for command-line configuration, default initialization, and observable updates through hooks. The associated data type supports equality, comparison, hashing, and pretty-printing, enabling structured manipulation of step parameters within the WP plugin. It facilitates use cases such as tuning analysis thresholds, managing step configurations, and validating project-specific data with deep copying for safe persistence and modular reasoning.",
      "description_length": 641,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitBranch",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared mutable boolean state with pre/post-update hooks, enabling dynamic configuration of branch-splitting behavior in the WP plugin through runtime toggles via CLI or config files. It defines a value type supporting equality, comparison, hashing, and pretty-printing, with embedded project data and deep copy capabilities to avoid shared state. Operations include setting, retrieving, and monitoring state changes, while submodules handle configuration comparisons and project-specific checks during analysis. Example uses include serializing split branch settings and conditionally applying analysis rules based on current configuration.",
      "description_length": 662,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BoundForallUnfolding",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter constrained within a bounded range, supporting operations like setting values, incrementing, and defining valid intervals. It maintains an internal state that enforces range constraints, integrates with command-line configuration, and supports persistent storage, making it suitable for bounded numeric parameters in configuration systems. Its child module extends this functionality by providing structured data operations for logical parameters in formal verification, enabling equality checks, comparisons, and pretty-printing tailored to bound forall unfolding in the WP plugin. Together, they allow precise control and manipulation of bounded integers both in application logic and verification contexts.",
      "description_length": 750,
      "index": 901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.C",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates relocatable logical conditions, primarily used to track and adjust the context in which symbolic equations are valid. It provides operations to create, compare, retrieve, and relocate these conditions using sigma sequences and domains. Concrete use cases include managing equation validity across different symbolic states during program analysis.",
      "description_length": 386,
      "index": 902,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Memory.LogicAssigns",
      "library": "frama-c-wp.core",
      "description": "Implements memory state transitions for assigns clauses by tracking heap modifications across execution paths. Computes the memory footprint of regions and applies assignments to relate pre- and post-state heaps. Used during weakest precondition calculations to model memory effects of assignments.",
      "description_length": 298,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CheckMemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module provides a structured data type with rich operations for equality, comparison, hashing, and pretty printing, designed specifically for representing and validating memory states in the context of program analysis. It includes a descriptor, packed descriptor, and a list of representatives to enable type-safe introspection and deep copy operations. Submodules extend its functionality to support project-specific memory membership checks and structured state manipulation. Example uses include verifying memory context consistency during analysis passes and ensuring correct handling of structured data representations.",
      "description_length": 630,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DynCall",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared mutable boolean state with metadata, supporting dynamic configuration through operations like state manipulation, alias management, and persistence control. It provides direct access to boolean parameters with functions for default initialization, command-line interaction, and project-specific tracking, while its child module enhances type handling with polymorphic operations including comparison, hashing, and pretty-printing. Together, they enable use cases such as toggling plugin behaviors, persisting settings across sessions, and synchronizing state changes with external systems, all with type-safe value manipulation and deep copying.",
      "description_length": 674,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.Data",
      "library": "frama-c-wp.core",
      "description": "This module defines the data type and operations for managing model-specific information within the WP plug-in. It includes functions for compiling data based on a key and provides a named identifier for the data context. It is used to register and retrieve model data during static analysis tasks.",
      "description_length": 298,
      "index": 906,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Drivers",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters for file path collections, supporting operations like addition, iteration, and combination with prefixing or appending, while integrating with state and project systems. It works with file path lists and parameter categories to control visibility and enablement, allowing structured handling of input files or analysis configurations. Child modules extend functionality to string parameters with validation, and to WP-specific options with type-safe descriptors and serialization. Examples include defining default parameter categories, validating string inputs, and persisting WP analysis settings across projects.",
      "description_length": 659,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Session",
      "library": "frama-c-wp.core",
      "description": "This module manages the plugin's session directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access to session-specific storage. Concrete use cases include storing temporary analysis results or user-specific configuration files during plugin execution.",
      "description_length": 375,
      "index": 908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Letify.Defs",
      "library": "frama-c-wp.core",
      "description": "This module manages definitions for logical variables within a predicate context. It supports operations to extract definitions from predicates, merge definition sets, and track the domain of defined variables. Concrete use cases include simplifying logical expressions by eliminating redundant variables and supporting transformation passes in a theorem proving pipeline.",
      "description_length": 372,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemLoader.Make",
      "library": "frama-c-wp.core",
      "description": "This module implements a loader for compound values in memory, handling operations like loading, storing, copying, and initializing structured data. It works with memory locations (`M.loc`), C objects, and logical terms representing memory states. Concrete use cases include modeling memory operations for structured types in program verification, such as struct assignments, array initialization, and field access in compound data.",
      "description_length": 432,
      "index": 910,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Memory.Compiler",
      "library": "frama-c-wp.core",
      "description": "This module coordinates compilation processes across memory models, offering functions to translate and optimize code representations. It operates on memory states, compilation contexts, and abstract syntax trees. Concrete use cases include instruction lowering, memory layout generation, and compiler pass orchestration for embedded systems verification.",
      "description_length": 355,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemDebug.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling and verification operations for formal analysis of C programs, focusing on precise manipulation of memory states and logical constraints. It works with abstract memory locations (`loc`), memory models (`sigma`), C-type objects (`c_object`), and logical formulas (`pred`, `term`), supporting tasks like offset computation, value storage/loading, memory validity checks, and dependency tracking. Specific use cases include generating equations for memory transformations, validating heap states during verification, and managing scope-bound variable allocations in formal proofs.",
      "description_length": 614,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Value",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing, merging, and inspecting layout values, which represent structured data regions in memory. It supports concrete operations such as equality checking, ordering via a custom function, deep merging of values, and extracting pointed content. These functions are used to analyze and manipulate memory layouts in static analysis tasks, such as determining value equivalence or combining overlapping memory regions.",
      "description_length": 453,
      "index": 913,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.VarUsage",
      "library": "frama-c-wp.core",
      "description": "This module tracks and manages variable usage within memory contexts, focusing on initialization and access patterns. It provides functions to iterate over variable declarations, determine their parameter roles, and assess their usage in kernel functions. Concrete use cases include analyzing function parameter lifetimes and validating variable initialization states during static analysis.",
      "description_length": 391,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemLoader.Model",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for modeling memory locations and manipulating atomic values through pointer arithmetic, memory storage, and equality checks. It works with memory models (`sigma`), atomic types (integers, floats, pointers), and terms representing stored values, while interacting with C objects and memory footprints. These functions are used to simulate low-level memory operations, such as storing initialized values at specific locations and generating predicates for memory state verification.",
      "description_length": 513,
      "index": 915,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.StmtSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "This module models program statement semantics through control flow graph (CFG) construction and environment transformation operations. It manipulates CFG nodes, logical proof goals, and program state transitions to handle control flow merges, function calls (direct and kernel), memory state updates, and specification enforcement. Designed for program analysis tasks requiring precise modeling of returns, assignments, assumptions, and initialization sequences within a formal verification context.",
      "description_length": 500,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportName",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based configuration parameters with validation, change tracking, and command-line integration, operating on strings and string lists to enforce constraints and synchronize state with external systems. It defines a core data type for report names, supporting equality, comparison, hashing, and pretty-printing, along with operations for deep copying, membership checks, and generating representative values. You can use it to configure and validate report names in the WP plugin, ensure inputs match allowed patterns, and track changes across sessions. Submodules enhance type safety and structured manipulation, while the main API enables seamless integration with kernel events and persistent state management.",
      "description_length": 738,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TruncPropIdFileName",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter with optional values, enforcing valid numeric ranges and supporting operations to set, retrieve, and increment the value. It integrates state change hooks and CLI customization to control truncation behavior in proposition ID file names during analysis workflows. The child module defines a structured data type for truncated property identifiers, enabling equality checks, comparison, and pretty-printing, which ensures precise naming and integrity in formal verification tasks. Together, they support configuring and tracking ID truncation with strong type guarantees and user-facing controls.",
      "description_length": 636,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Auto.Range",
      "library": "frama-c-wp.core",
      "description": "Manages integer range computations for program analysis. It calculates and tracks ranges of values that variables can take, using a region type `rg` derived from condition sequences. Exposes mappings of variable bounds and intervals for precise static analysis of loop iterations and array indices.",
      "description_length": 298,
      "index": 919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Alias",
      "library": "frama-c-wp.core",
      "description": "This module manages layout aliases through operations like `use`, `merge`, and `alias`, enabling the creation and manipulation of layout mappings. It works with the `Wp.Layout.alias` type, representing structured layout relationships. Concrete use cases include defining layout hierarchies, resolving layout references, and combining layout configurations in WP's region analysis.",
      "description_length": 380,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByRef",
      "library": "frama-c-wp.core",
      "description": "This module manages string set parameters for command-line interfaces, supporting state tracking, validation, and dynamic updates through hooks. It operates on string sets and integrates with global collections and project state, enabling use cases like configuring plugin behavior with restricted inputs or persistent session state. Submodules enhance functionality by adding support for parameter categories, structured value comparison, and advanced string option handling with validation and default management. Examples include defining analysis modes with allowed values, grouping parameters under configurable categories, and performing deep equality checks on parameter values.",
      "description_length": 685,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling and verification functions, including pointer arithmetic, layout queries (e.g., base offsets, block lengths), and state transformations for tracking memory updates. It operates on memory locations (`loc`), states, and segments, generating logical predicates to enforce validity, separation, and initialization constraints. These capabilities support formal verification tasks like proving memory safety, analyzing pointer manipulations, and ensuring program correctness through symbolic reasoning.",
      "description_length": 534,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.F",
      "library": "frama-c-wp.core",
      "description": "This module forms a comprehensive framework for constructing and manipulating logical and arithmetic expressions, centered around terms, predicates, variables, and environments. It enables foundational operations like weakest precondition calculation, proof generation, and term transformation, with support for variable binding, logical connectives, and type-aware rewriting. Submodules extend this core functionality with specialized data structures: functional sets for variables and predicates track logical elements with set algebra, while polymorphic maps index terms and variables to associate metadata, support custom merging, and enable context-sensitive transformations. Together, these components facilitate advanced symbolic reasoning tasks such as theorem proving, program verification, and logical state management through precise, efficient manipulation of formal expressions and their relationships.",
      "description_length": 915,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3Flags",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameter lists composed of strings, offering operations to modify values, track changes, register update hooks, and serialize state. It introduces the core type `t` for parameter values, with support for comparison, hashing, and pretty printing, while submodules handle validation, category management, and structured value manipulation. Functionality includes defining allowed values, validating inputs, registering callbacks, and managing named categories like `@none`, `@default`, and `@all` to control flag behavior across analysis modes. Examples include validating project membership strings, synchronizing configuration changes with state transitions, and serializing parameter states for diagnostics or persistence.",
      "description_length": 757,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitCNF",
      "library": "frama-c-wp.core",
      "description": "This module manages integer parameters with stateful tracking, allowing configuration through command-line interfaces and project settings while enforcing bounds and supporting serialization. It provides core operations for setting values, defining ranges, and triggering hooks on changes, with associated metadata such as defaults and aliases. The child module extends this functionality to CNF splitting parameters, enabling precise manipulation and inspection of logical formula configurations during program verification. Together, they support tasks like configuring analysis plugins, tracking parameter changes, and managing complex state transitions in verification workflows.",
      "description_length": 683,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InCtxt",
      "library": "frama-c-wp.core",
      "description": "This module manages string sets as command-line parameters, supporting dynamic updates, state tracking, and integration with configuration systems. It provides core operations for manipulating sets, such as membership checks and iteration, while enabling marshaling, alias customization, and hook-based state synchronization. The module works with parameter categories to group and control related options, defines types for command-line values with comparison and serialization support, and handles string parameters with validation and context-aware updates. Examples include configuring plugin settings, enforcing valid CLI inputs, and dynamically updating analysis configurations during execution.",
      "description_length": 701,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgInit.Make",
      "library": "frama-c-wp.core",
      "description": "Implements initialization logic for global variables and kernel functions in the context of the WP plugin. It processes global initializers and updates the environment and properties accordingly. Useful for analyzing and verifying programs with complex global state.",
      "description_length": 266,
      "index": 927,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyForall",
      "library": "frama-c-wp.core",
      "description": "This module controls a boolean parameter that enables or disables simplification of universal quantifiers, with support for dynamic configuration across projects through default handlers and change notifications. It provides operations to set, get, and observe the parameter's state, along with serialization and alias management. The associated datatype module enables structural manipulation, comparison, and pretty-printing of values embedded with project skeletons, supporting deep copying and representant tracking. Together, they facilitate context-sensitive simplification of quantified expressions in WP analysis, allowing precise control over simplification behavior per project or analysis phase.",
      "description_length": 706,
      "index": 928,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.VCS.Pset",
      "library": "frama-c-wp.core",
      "description": "This module manages collections of provers through operations like insertion, deletion, union, intersection, and membership checks, while supporting ordered traversal, filtering, and mapping over persistent sets. It works with sets of provers (`elt`) maintained under a total ordering, enabling efficient queries (e.g., `find_first`, `find_last`) and bulk modifications via conversions to and from sequences. Use cases include analyzing prover relationships, maintaining indexed collections for verification tasks, and processing sets with ordered dependencies or hierarchical constraints.",
      "description_length": 589,
      "index": 929,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.Generator",
      "library": "frama-c-wp.core",
      "description": "This module manages a contextual mapping from keys to data, providing operations to check existence, retrieve, update, and remove entries. It works with key and data types defined by the parameter modules K and D. Useful for maintaining transient model-specific state that depends on the current analysis context.",
      "description_length": 313,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Subst",
      "library": "frama-c-wp.core",
      "description": "This module implements substitution operations over logical terms and predicates, allowing the replacement of variables with terms within expressions. It provides functions to apply substitutions, construct substitution environments, and query their domain and codomain variables. Use cases include simplifying expressions by replacing variables with known values or transforming logical formulas during proof manipulation.",
      "description_length": 423,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadlocalinit",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter that controls smoke analysis and dead local initialization in static analysis, allowing users to enable or disable detection of uninitialized variables or redundant local usage. It supports setting, getting, and monitoring boolean state with hooks, default values, command-line integration, and serialization. The child module enhances this system by providing structured data representations with equality, comparison, and pretty-printing for WP plugin parameters. Together, they enable type-safe configuration management and introspection in analysis workflows, such as tracking parameter changes or serializing analysis settings.",
      "description_length": 672,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RTE",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean configuration parameters with support for state tracking, default values, and command-line integration, enabling runtime flag control and plugin setting synchronization. It provides operations to set, retrieve, and toggle boolean states with change hooks and customizable serialization. The child module extends this functionality by defining abstract value manipulation primitives, allowing structured data handling, comparison, and deep cloning, which are used to manage and analyze complex state representations. Together, they support fine-grained configuration and data processing in plugin-driven environments.",
      "description_length": 644,
      "index": 933,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.AutoWidth",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter with configurable bounds, supporting operations like `incr`, `set_range`, and `get_range`, while integrating with the plugin infrastructure for serialization, CLI handling, and dynamic configuration. It defines a structured data type with equality, comparison, and pretty-printing support, enabling type-safe manipulation and introspection of parameter values. Use cases include runtime adjustments of settings like output width, enforcing valid ranges, and managing parameter state during plugin execution. Submodule functionality extends the core by providing descriptors and representatives for structured data validation and deep copying.",
      "description_length": 683,
      "index": 934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.Registry-E",
      "library": "frama-c-wp.core",
      "description": "Registers and manages model data associated with keys in the WP plug-in. It provides operations to add, retrieve, and compare entries using a specified key type and data type. This module is used to maintain and query a collection of models in the context of the WP plug-in.",
      "description_length": 274,
      "index": 935,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wp.WpContext.MODEL",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for working with model types in the context of the WP plug-in. It provides functions to retrieve identifiers, descriptions, and hash values for models, as well as comparison and equality checks. These operations are used to manage and distinguish between different models during verification tasks.",
      "description_length": 329,
      "index": 936,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyLandMask",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean state for a simplification toggle, integrating with project lifecycle events and command-line interfaces to control geospatial processing behavior. It provides operations to set and track state changes, serialize values, and associate metadata, with support for deep copying, equality checks, and persistent storage. The child module enhances this functionality by enabling structured value manipulation, including comparison, hashing, and pretty-printing, making it suitable for configuration management and analysis workflows. Example uses include optimizing land mask processing by enabling simplification during spatial analysis or persisting state across sessions.",
      "description_length": 697,
      "index": 937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.State_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages the state directory for the plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the state directory structure. Concrete use cases include storing and retrieving plugin-specific files or configurations during analysis.",
      "description_length": 384,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.S",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates proof obligations with core operations for equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copies. Its submodules organize these obligations into ordered sets and maps for structured queries, range operations, and typed associations, and into hash tables for efficient caching and lookup with structured keys. You can track individual obligations, group them in ordered collections for dependency management, or map them to analysis results with typed keys. Hash table support enables memoization and deterministic processing of large-scale verification data.",
      "description_length": 662,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Report",
      "library": "frama-c-wp.core",
      "description": "This module manages collections of command-line parameters, particularly file paths, with support for dynamic updates, serialization, and project state tracking. It provides core data types like `t` for parameter values and operations for comparison, hashing, and pretty printing, while integrating with analysis frameworks like Frama-C's kernel and the WP plugin. Submodules extend this functionality to handle string parameter validation, define parameter type representations, and organize parameters into named categories such as `@none` and `@all`. Examples include validating function names against a whitelist, managing WP plugin options, and configuring parameter behaviors across analysis stages.",
      "description_length": 705,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice.Choice",
      "library": "frama-c-wp.core",
      "description": "Implements tactical choices for proof strategies, providing `tactical` and `strategy` functions to select and prioritize proof steps. Works with `Wp.Tactical.tactical` and `Wp.Strategy.strategy` types, enabling dynamic decision-making in proof automation. Used to define branching logic in proof search, such as selecting between multiple valid proof paths based on priority or context.",
      "description_length": 386,
      "index": 941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusFalse",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared boolean state with imperative setters (`on`/`off`) and change tracking, supporting feature toggles and status flags with metadata like defaults, serialization controls, and CLI integration. It provides atomic manipulation and synchronization across components, while its child module defines a structured data type for status values with equality, comparison, and pretty-printing, enabling precise project-specific checks and serialization. Together, they allow runtime configuration of analysis modes, tracking of status changes, and structured representation of boolean states within projects. Example uses include enabling/disabling output settings via CLI flags or persisting user preferences with custom serialization.",
      "description_length": 752,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Lvalue",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing and printing logical values (`lvalue`) used to represent memory locations in program analysis. It includes functions for equality checking, ordering, and pretty-printing to facilitate debugging and formal verification tasks. Concrete use cases involve analyzing pointer expressions and memory references in C code within the WP plugin.",
      "description_length": 380,
      "index": 943,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Probes",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with operations to set, retrieve, and monitor its value through hooks and aliases, while integrating structured data handling from its child module. The child module introduces a rich data type equipped with equality, comparison, hashing, and pretty-printing operations, along with descriptors and representatives for type-safe introspection and manipulation. Together, they enable precise parameter tracking and structured value management within the WP plugin's analysis framework. For example, users can define a boolean probe that logs changes via hooks and compare its state using the structured data facilities provided by the child module.",
      "description_length": 686,
      "index": 944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Ground",
      "library": "frama-c-wp.core",
      "description": "This module manages environments for term and predicate transformations, supporting operations like applying substitutions, branching logical contexts, and propagating constraints forward and backward. It works with environments (`env`) and symbolic expressions from `Wp.Lang.F`, including terms and predicates. Concrete use cases include simplifying logical formulas, managing variable bindings during proof search, and splitting proof obligations based on conditional branches.",
      "description_length": 479,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StatusAll",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean status flag with support for dynamic updates, change tracking, and integration with Frama-C's project state system for serialization and lifecycle management. It defines a core data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing status values within the WP plugin. The module enables use cases such as enabling or disabling analysis features at runtime, persisting plugin configuration, and managing project-specific states with deep copying to avoid shared references. It also provides a packed descriptor for serialization and supports working with `Project_skeleton.t` predicates to track and compare analysis statuses across different projects.",
      "description_length": 734,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.StaticGenerator",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manage a static, projectified context for model-independent data storage and retrieval. It supports associative operations like `mem`, `get`, `set`, `find`, and `remove` over keys and data abstracted through the `K` and `D` modules. It is used to maintain transient, non-serialized contextual information during analysis, such as caching or intermediate results.",
      "description_length": 397,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InHeap",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters as string sets with support for dynamic updates, membership checks, and serialization, centered around a global string set type. It integrates with command-line interfaces for handling multi-value options like include/exclude lists, with child modules adding category management, value validation, and project-aware filtering. Operations include adding elements, checking membership, iterating over values, and custom marshaling, with concrete uses in plugin configuration and state persistence. Submodules enhance this by enabling category-based grouping, value constraints, and project-specific inspections via functions like `mem_project`.",
      "description_length": 686,
      "index": 948,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Sigma.Heap",
      "library": "frama-c-wp.core",
      "description": "This module manages uniform sets and maps of heap chunks, supporting hashing, equality, and comparison operations for memory region tracking and dynamic allocation analysis. It provides direct operations on heap chunks while submodules implement set algebra and key-based maps with customizable merging, enabling precise static analysis of heap-structured data. The set submodule offers union, intersection, and filtering over typed elements for tasks like aggregating memory regions, while the map submodule provides key-aware transformations, ordered traversal, and algebraic operations for symbolic heap analysis. Example uses include verifying memory safety and analyzing pointer relationships through structured set and map combinators.",
      "description_length": 741,
      "index": 949,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Properties",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters as string lists and collections, supporting operations to set and retrieve values, track defaults, and execute hooks on changes. It provides data types for parameter representations, including structured descriptors and category types, with operations for comparison, hashing, and pretty-printing, enabling deep copying and project membership checks. Submodules extend functionality to handle string-based parameters with parsing and validation, manage parameter categories with activation rules, and define concrete datatypes for plugins like WP. Examples include synchronizing plugin configurations with the Frama-C kernel, validating user input against expected formats, and dynamically managing parameter states through category dependencies.",
      "description_length": 790,
      "index": 950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.S",
      "library": "frama-c-wp.core",
      "description": "This module works with the `t` type representing a model registration context. It provides operations to retrieve a unique identifier (`id`), compute a hash (`hash`), test equality (`equal`), and compare values (`compare`). These functions are used to manage and distinguish between different model registration contexts within the WP plug-in.",
      "description_length": 343,
      "index": 951,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout.Range",
      "library": "frama-c-wp.core",
      "description": "This module manages range-based regions within a layout, providing operations to check if a range overlaps or includes specific positions. It works with range structures that represent intervals, typically used for tracking regions in memory or code analysis. Concrete use cases include determining whether a given memory address falls within a specified range or merging overlapping ranges during static analysis.",
      "description_length": 414,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WP",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean plugin parameter with support for value setting, retrieval, change hooks, and serialization, integrating directly with Frama-C's project and kernel systems. It enables dynamic configuration through CLI flags, persistence of parameter states, and callback triggering during analysis. The child module enhances this functionality by providing structured data representations with equality, comparison, and pretty-printing operations, supporting complex parameterized data manipulation. Together, they allow precise control and extension of parameter behavior, such as defining custom data descriptors that influence boolean state computation or analysis output formatting.",
      "description_length": 700,
      "index": 953,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SplitConj",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter that controls splitting behavior for logical expressions, with operations to toggle its state and notify consumers of changes, integrated into Frama-C's project system for serialization and configuration. It defines a structured data type for representing conjunctions with metadata, supporting equality checks, comparison, and pretty-printing, which is used to manage proof obligations and logical assertions in the WP plugin. The design enables dynamic splitting of conjunctive conditions during verification, with support for deep copying, project membership checks, and CLI-driven configuration. Use cases include adjusting splitting strategies interactively and tracking logical conditions across analysis phases.",
      "description_length": 758,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.P",
      "library": "frama-c-wp.core",
      "description": "This module represents relocatable logical predicates associated with control flow nodes. It supports creating and relocating predicates using sigma mappings, extracting underlying conditions, and querying node dependencies. Use cases include tracking path-specific assertions during symbolic execution and generating verification conditions tied to specific control flow locations.",
      "description_length": 382,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CachePrint",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean configuration flag that controls caching behavior, allowing state modification via `on`/`off` actions, value querying, and serialization, directly impacting caching decisions in the analysis pipeline. It integrates with command-line interfaces through help documentation and option aliases, and supports reactive updates to dependent systems via change hooks. The child module defines a data type with operations for equality, comparison, hashing, and pretty-printing, used to represent and manipulate values in the WP plugin's caching and printing system. Together, they enable structured caching control and value representation, supporting use cases such as managing cached computation results and producing user-facing output tied to specific analysis projects.",
      "description_length": 795,
      "index": 956,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Prenex",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with operations to set, toggle, and monitor state changes, while supporting command-line visibility, serialization, and integration with state systems. It defines a structured type `t` for abstract values, enabling precise data handling through descriptors, names, and representations. Operations include equality checks, comparison, hashing, and pretty-printing, facilitating tasks like managing symbolic expressions and tracking project elements. Use cases include configuring plugin behavior via command-line interfaces and ensuring consistent state across sessions through deep copies and mutation-free transformations.",
      "description_length": 662,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpPropId.PropId",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing and comparing property identifiers, including equality, comparison, hashing, and pretty-printing. It works with the `prop_id` type, which represents properties in different computational contexts such as loop establishment and preservation. Concrete use cases include tracking and distinguishing properties during verification, supporting deep copies, and checking project membership via custom predicates.",
      "description_length": 450,
      "index": 958,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.SCOPE",
      "library": "frama-c-wp.core",
      "description": "This module manages scope identifiers within the WP plug-in's model registration system. It provides operations to retrieve a scope's unique string identifier, compute its hash, and compare or check equality between scopes. These functions support precise handling of distinct modeling contexts during verification tasks.",
      "description_length": 321,
      "index": 959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptOnStdout",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter that controls whether script execution output is directed to standard output, offering functions to modify, query, and track changes to this flag. It supports default values, pre/post-update hooks, command-line integration, and serialization customization, enabling dynamic control over output during plugin execution. The associated data type provides equality, comparison, hashing, and pretty-printing operations, facilitating structured manipulation and analysis of script output representations. Use cases include managing execution results within the WP plugin, enabling deep copies, membership checks, and integration with the Frama-C kernel via type descriptors.",
      "description_length": 709,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ExternArrays",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with shared state across Frama-C, supporting operations to set, retrieve, and query values with change hooks and custom marshaling. It integrates with the project system for persistent configuration, enabling runtime toggling of analysis features and external array handling modes. The child module extends this functionality by defining abstract value types for arrays with external elements, providing equality, comparison, and pretty-printing operations. Together, they support precise static analysis and transformation of array structures interfacing with Frama-C's kernel.",
      "description_length": 617,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Model",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters as mutable string collections with support for aliases, serialization, and state tracking. It provides operations for appending, iterating, and folding over parameter lists, while integrating submodules that handle parameter categories, validation, and type-safe data manipulation. With category management, enriched string parameters, and polymorphic type operations, it enables workflows like dynamic option handling, static analysis, and project-specific configuration. Examples include defining default parameter behaviors, validating and transforming string values with metadata, and comparing or serializing parameter states across projects.",
      "description_length": 691,
      "index": 962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.BackTrack",
      "library": "frama-c-wp.core",
      "description": "This module manages backtrackable integer parameters with range constraints, supporting dynamic adjustments, persistence control, and change notifications. It integrates structured data types from its submodules that enable state comparison, hashing, and project membership checks, enhancing backtracking precision in formal verification workflows. You can configure analysis settings with bounded integers, track state changes across backtracking points, and ensure data consistency using deep copies and marshaling. The combined interface allows fine-grained control over parameter behavior while maintaining auditability and cross-session integrity.",
      "description_length": 652,
      "index": 963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.CodeSemantics",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for evaluating C expressions, manipulating pointers and abstract memory values, and constructing logical constraints to model memory behavior. It operates on abstract memory states (sigma) to perform value conversions, equality checks, function pointer resolution, and to express conditions like zero-initialization, value ranges, and variable equivalence. These capabilities enable static analysis tasks such as verifying program properties, tracking initialization status, and accurately modeling memory during C code compilation.",
      "description_length": 564,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels.T",
      "library": "frama-c-wp.core",
      "description": "Implements structural comparison and equality for normalized C-labels. Works directly with the `t` type representing logic labels. Useful for ensuring consistent label handling in analysis and transformation passes involving C code.",
      "description_length": 232,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Status",
      "library": "frama-c-wp.core",
      "description": "This component manages boolean parameters with project-scoped persistence, allowing state toggling, change observation via hooks, and value serialization for storage or transmission. It supports command-line integration through configurable aliases and dynamic help generation, enabling use cases such as feature activation toggles and interactive mode switching in plugin workflows. The core data type represents status values with support for equality checks, comparison, hashing, and pretty-printing, while also enabling structured operations like project membership checks, deep copying, and type-based descriptions. Together, these capabilities facilitate managing and comparing analysis statuses, tracking state across projects, and serializing status data for reporting or auditing purposes.",
      "description_length": 798,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeExtra",
      "library": "frama-c-wp.core",
      "description": "This module combines integer parameter management with range constraints and state tracking with a data type for structured, comparable values used in static analysis workflows. It supports operations like incrementing, setting bounds, and custom hooks for update logic, while its child module enables equality checks, comparison, and pretty-printing for complex parameter values. Examples include enforcing valid time durations in analysis tools and integrating configurable parameters with command-line interfaces. Together, they provide a robust system for managing, comparing, and persisting structured configuration data in Frama-C plugins.",
      "description_length": 645,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AutoDepth",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer state with range constraints, enabling safe adjustments, boundary enforcement, and change notifications via hooks. It supports depth-related parameters through a structured data type that allows comparison, copying, and serialization, facilitating use in static analysis configurations. Operations include value modification within bounds, equality checks, and structured traversal over project skeletons. Concrete applications include interactive CLI configuration and dynamic reconfiguration of analysis depth in Frama-C plugins.",
      "description_length": 562,
      "index": 968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.MemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters that control memory context behavior, enabling dynamic configuration of analysis features and persistence of settings across sessions. It provides a stateful memory context type with support for project-specific configuration, command-line flags, and alias management, along with operations to set values, observe changes, and define serialization rules. The child module enhances this by defining data structures and utilities for representing and manipulating memory contexts, including equality checks, deep copies, and pretty-printing. Together, they support tasks like inspecting memory states during symbolic execution, managing analysis configurations, and verifying program properties in Frama-C.",
      "description_length": 743,
      "index": 969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadloop",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter that controls deadloop detection behavior, supporting state changes, serialization, and integration with Frama-C's project system. It provides operations to set and monitor the state, notify on value changes, and manage aliases, enabling dynamic control of deadloop checks during verification workflows. The custom data type defined in the child module supports equality, comparison, and pretty-printing, facilitating structured representation and introspection for analysis state tracking. Together, they allow precise control and extension of deadloop detection mechanisms within Frama-C's WP plugin.",
      "description_length": 642,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FilterInit",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean state with bidirectional toggling (`on`/`off`) and change-tracking hooks, serving as a runtime switch for conditional logic in analysis pipelines. It integrates with configuration systems through command-line flags, value marshaling, and aliased identifiers, enabling flexible state management. The child module enhances this system with a custom data type supporting equality, comparison, and deep copying, tailored for parameter filtering in the WP plugin. Together, they allow initializing, modifying, and observing filter states while ensuring consistency across configuration and runtime contexts.",
      "description_length": 632,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Havoc",
      "library": "frama-c-wp.core",
      "description": "This interface manages a boolean parameter with metadata, offering operations to toggle states, track changes, and define aliases, enabling dynamic control over analysis behaviors such as symbolic execution or heuristic checks. It supports manipulation of boolean values through standard operations like equality, comparison, and hashing, while also providing deep copying and pretty-printing for clarity and integration. The module includes utilities for checking membership and structural representation, facilitating precise handling of symbolic values and constraints in formal verification. Specific uses include enabling or disabling analysis modes and execution paths during program verification.",
      "description_length": 703,
      "index": 972,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.StaticGeneratorID",
      "library": "frama-c-wp.core",
      "description": "This module implements a key-value store with project-specific identifiers, using types and operations defined in the `K` and `D` modules. It supports checking existence, retrieving, setting, and removing entries, along with clearing all stored data. Useful for managing transient, project-level metadata during analysis without serialization or model dependencies.",
      "description_length": 365,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.LogicAssigns-M",
      "library": "frama-c-wp.core",
      "description": "This module specializes in low-level memory modeling and verification for C programs, translating C constructs into memory locations and manipulating them through pointers, fields, arrays, and automata binders. It operates on memory locations (`loc`), memory states (`sigma`), memory segments, and logical formulas to validate heap states, pointer validity, and memory dependencies, with use cases including initialization checks, allocation framing, and dependency analysis for precise memory partitioning and validation.",
      "description_length": 522,
      "index": 974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.DryFinalizeScripts",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean state flag to control dry-run or finalization behavior in script execution, offering toggling, change handlers, and CLI integration. It centers on a simple boolean core, with accessors and modifiers that enable conditional execution flows and state persistence across projects. The child module enhances this system by defining a rich data type for script parameters, supporting equality checks, deep copies, and project-aware comparisons during analysis phases. Together, they allow workflows where parameterized scripts can be safely previewed or finalized, with fine-grained control and consistent state management.",
      "description_length": 648,
      "index": 975,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacChoice.Contrapose",
      "library": "frama-c-wp.core",
      "description": "This module implements the contrapositive tactical for proof strategies, enabling the transformation of goals by negating both the hypothesis and conclusion. It operates on logical propositions within the tactical framework, specifically handling selections of proof steps in a strategy. Concrete use cases include automating proof by contradiction in logical reasoning tasks.",
      "description_length": 376,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CodeSemantics.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for evaluating and comparing abstract memory values, expressions, and locations, including equality checks, zero-checks, and function pointer handling, while also supporting term compilation into logical constraints. It operates on memory states (sigma), variables, and logical terms to enable formal verification of C code behavior, memory initialization analysis, and value range validation. Specific patterns address variable state comparisons, memory initialization, and constraint propagation across abstract memory models.",
      "description_length": 560,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicAssigns.Make",
      "library": "frama-c-wp.core",
      "description": "Implements memory domain analysis and assignment logic for reasoning about memory regions and their transformations. It operates on memory locations and regions, producing predicates that relate initial and final memory states after assignments. Useful for verifying memory safety properties in programs with pointers and mutable data structures.",
      "description_length": 346,
      "index": 978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.Registry",
      "library": "frama-c-wp.core",
      "description": "This module manages a registry of named data entries with support for safe insertion, retrieval, and memoization. It operates on keys and data defined by the `E` submodule, ensuring protection against redefinition and circular dependencies. Concrete use cases include caching computed values, registering named configurations, and managing stateful data entries with controlled updates.",
      "description_length": 386,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Clean",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with support for setting, retrieval, and change monitoring through hooks, default values, and command-line integration. It maintains an internal state that can be serialized, aliased, and tied to project-specific contexts, enabling runtime feature toggling and configuration within analysis systems. The child module enhances this functionality by defining a data type for parameter specifications, supporting equality, comparison, hashing, pretty-printing, deep copying, and project membership testing. Together, they allow operations like defining a parameter, printing its state, checking its presence in a project, and persisting its configuration across sessions.",
      "description_length": 708,
      "index": 980,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgCompiler.T",
      "library": "frama-c-wp.core",
      "description": "This module manages relocatable terms paired with sigma mappings, enabling term creation, retrieval, and relocation within a control flow graph. It supports operations to bundle terms with their generating sigma sequences, extract terms, and adjust terms based on new sigma mappings. Concrete use cases include tracking and transforming logical expressions across CFG nodes during verification or compilation passes.",
      "description_length": 416,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Ctypes.C_object",
      "library": "frama-c-wp.core",
      "description": "This module defines a concrete type `t` representing C objects in the WP plugin, along with operations for equality, comparison, hashing, and pretty printing. It provides access to type information via `ty`, `descr`, and `packed_descr`, and supports deep copying, membership testing in projects, and introspection through `reprs`. It is used to manipulate and reason about C data structures within the WP framework, particularly during symbolic execution and proof tasks.",
      "description_length": 471,
      "index": 982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc.Separated",
      "library": "frama-c-wp.core",
      "description": "This module implements tacticals for generating and managing fresh variables in separation logic proofs. It provides functions to introduce and track separated heap components during symbolic execution. Concrete use cases include automating memory model reasoning in program verification tasks.",
      "description_length": 294,
      "index": 983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.Compiler-L",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to compile CIL constructs into abstract memory representations, manipulate environments and memory states during verification, and enforce memory safety constraints through lemma compilation. It works with memory frames, logical variables, regions, and formulas to model program states, leveraging environments (`L.env`), memory states (`Sigma.sigma`), and logical terms (`Lang.F.*`). These capabilities support formal verification tasks like validating function call contexts, checking memory assignments, and proving pre/post-conditions in program analysis.",
      "description_length": 591,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Memlimit",
      "library": "frama-c-wp.core",
      "description": "This module manages memory constraints using integer parameters with configurable bounds, providing operations to set, adjust, and validate values within a defined range. It integrates with command-line interfaces for configuration and tracks state changes for persistence, supporting use cases like resource management and plugin configuration. The module includes a data type for representing bounded values with support for comparison, hashing, and pretty printing, along with deep copying and membership testing via the `mem_project` function. This structure enables concrete operations such as comparing memory limit settings across project states or validating parameter updates in the WP plugin.",
      "description_length": 702,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Let",
      "library": "frama-c-wp.core",
      "description": "This module organizes core operations for structured data manipulation, focusing on equality, comparison, hashing, and pretty-printing, particularly for parameterized values. Its main data types include descriptors and packed types that support deep copying and project-specific queries. The child module extends this by enabling fine-grained control over symbolic execution states and configuration settings within the WP plugin. Together, they allow developers to store, compare, and transform complex data structures while ensuring consistency across different project contexts.",
      "description_length": 581,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Warning.Set",
      "library": "frama-c-wp.core",
      "description": "Implements a functional ordered set structure for managing collections of contextual errors, supporting operations like union, intersection, difference, and element queries alongside transformations such as map, filter, and fold. Built around immutable sets of `Wp.Warning.t` elements with total ordering, it enables efficient iteration, subset manipulation, and conversions to lists or sequences for sorted processing. This is particularly useful in static analysis workflows for merging disjoint warning sets, deduplicating results, or generating prioritized error reports.",
      "description_length": 575,
      "index": 987,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.Raw",
      "library": "frama-c-wp.core",
      "description": "This module tracks variable usage by reporting all variable accesses as by-value. It operates on `varinfo` structures from CIL types, providing functions to iterate over variables and extract parameter information. Use it to analyze function parameters and variable interactions in C code, particularly for memory context tracking in static analysis.",
      "description_length": 350,
      "index": 988,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Definitions.Trigger",
      "library": "frama-c-wp.core",
      "description": "This module converts logical terms and predicates into trigger annotations used for guiding proof search. It provides functions to extract variables from triggers, ensuring they reference the correct logical variables. These operations are essential for defining how automated provers instantiate quantified formulas.",
      "description_length": 317,
      "index": 989,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Init",
      "library": "frama-c-wp.core",
      "description": "This module enables the definition and management of boolean parameters with rich metadata, supporting dynamic value setting, change hooks, and serialization. It introduces a parameter type with default values, command-line aliases, project-specific state tracking, and visibility controls, facilitating configuration in plugin environments. The child module enhances this system by providing structured data operations for parameter values, including equality checks, comparison, and pretty-printing, tailored for use in the WP plugin's analysis framework. Together, they allow for robust handling of feature toggles, CLI-driven flags, and persistent settings with side-effect management.",
      "description_length": 689,
      "index": 990,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.Key",
      "library": "frama-c-wp.core",
      "description": "This module defines a key type for contextual identifiers in the WP plugin's model registration system. It supports comparison and pretty-printing operations, enabling structured handling of unique context keys. Concrete use cases include managing distinct model contexts during verification tasks.",
      "description_length": 298,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.TerminatesVariantHyp",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean state that controls termination variant hypotheses in formal verification, allowing the enablement or disablement of termination checks for loops and functions during static analysis. It provides operations to set, retrieve, and monitor changes to the flag, with support for command-line visibility, serialization, and update notifications. The child module enhances this functionality by defining a structured data type with equality, comparison, and pretty-printing operations, tailored for use in the WP plugin's parameter system. Together, they enable precise control and manipulation of termination hypotheses, such as storing analysis states, comparing parameters, and customizing data representation during verification workflows.",
      "description_length": 767,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.Eva",
      "library": "frama-c-wp.core",
      "description": "This module bridges WP and EVA by mapping memory values to abstract values during static analysis, handling operations like field access, array indexing, and base address computation. It works with abstract values (`t`) and analysis states (`state`), tracking memory domains and offsets as constraints, and supports modeling pointer arithmetic, struct field accesses, and string literals. The child module extends this by representing abstract memory states, offering operations to build, merge, and inspect states derived from CIL elements such as `kinstr`, `stmt`, and `kernel_function`. Together, they enable precise symbolic execution by combining state construction, constraint tracking, and domain-specific value abstraction.",
      "description_length": 731,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.AliasInit",
      "library": "frama-c-wp.core",
      "description": "This module implements a parameter system for boolean options with support for state toggling, update hooks, and alias resolution, integrating serialization and default value handling. It defines core operations to set, retrieve, and monitor boolean states, while its Datatype submodule provides structured representations with comparison, hashing, and pretty-printing capabilities for use in static analysis and configuration workflows. The module enables tracking and persisting feature toggle changes in command-line interfaces and project-specific contexts, with concrete support for deep copies, project membership checks, and custom marshaling behavior. Submodules enhance parameter management by allowing structured value comparison and descriptor-based data handling in WP plugin workflows.",
      "description_length": 798,
      "index": 994,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Clabels.LabelMap",
      "library": "frama-c-wp.core",
      "description": "This module implements finite maps with normalized C-labels (`Wp.Clabels.c_label`) as ordered keys and polymorphic values, supporting standard operations like insertion, deletion, ordered traversal, and structural manipulation (e.g., merging, filtering, and bulk updates via sequences). It emphasizes ordered key queries (e.g., `find_first`, `find_last`) and transformations preserving structural equality, making it suitable for managing logic label associations in formal verification workflows where ordered traversal and efficient merging are critical.",
      "description_length": 556,
      "index": 995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal.State",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory states in a program analysis context. It provides operations to compute memory states from instructions, statements, or functions, and supports joining states to merge analysis results. It works with CIL types such as `kinstr`, `stmt`, and `kernel_function`, and is used to model memory values at different program points for static analysis tasks.",
      "description_length": 387,
      "index": 996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StatusMaybe",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean state within the WP plugin, offering operations to set, retrieve, and observe changes through hooks, with support for serialization, defaults, and aliases. Its `Datatype` submodule provides atomic toggle operations using unit-based `on` and `off` functions, enabling precise state manipulation. The polymorphic type `t` allows for structured value handling with equality checks, comparison, and pretty-printing, supporting deep copies and project membership tests. Together, they facilitate feature flags, dynamic configuration, and event-driven updates in plugin workflows with strong introspection and serialization capabilities.",
      "description_length": 659,
      "index": 997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Ctypes.AinfoComparable",
      "library": "frama-c-wp.core",
      "description": "This module defines comparison, equality, and hashing operations for the `arrayinfo` type from the `Wp.Ctypes` module. It enables use of `arrayinfo` values in ordered collections like sets and maps, as well as detecting duplicates or canonicalizing array representations. Concrete use cases include comparing array metadata for optimization passes and ensuring uniqueness of array type descriptors in analysis pipelines.",
      "description_length": 420,
      "index": 998,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgCompiler.E",
      "library": "frama-c-wp.core",
      "description": "This module represents relocatable effects as predicates depending on two states, providing operations to create, retrieve, and relocate these effects using sigma sequences. It works with `Wp.Lang.F.pred` for logical predicates and `Wp.Sigma.sigma` sequences to define memory states and their transformations. Concrete use cases include tracking memory effects across program transitions and relocating effects when modifying or analyzing control flow graphs.",
      "description_length": 459,
      "index": 999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ExtEqual",
      "library": "frama-c-wp.core",
      "description": "This module manages a configurable boolean parameter with operations to set, toggle, and track changes, supporting integration into plugin workflows and synchronization with external systems. It maintains persistent state across projects and interfaces, enabling use cases like dynamic configuration and event-driven updates. The associated data type provides equality, comparison, hashing, and pretty printing capabilities, with support for deep copying and predicate-based checks on project values. Together, they facilitate structured manipulation of boolean settings with strong identity and structural guarantees in analysis workflows.",
      "description_length": 640,
      "index": 1000,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.ADT",
      "library": "frama-c-wp.core",
      "description": "This module defines and manipulates algebraic data types (ADTs) used in the logic language of the WP plug-in. It provides operations for hashing, comparing, and pretty-printing ADT values, along with utilities for generating fresh names and debugging. Concrete use cases include representing and manipulating logical terms and predicates in the Qed-based language.",
      "description_length": 364,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Filter",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with rich metadata, supporting operations like toggling, value hooks, command-line integration, and serialization. It works with a custom boolean type enhanced for project-specific tracking, aliasing, and comparison, enabling conditional filter activation and persistent configuration. The child module extends this by defining abstract values with equality, comparison, and pretty-printing, supporting deep copies and membership checks over project skeletons. Together, they enable advanced filtering logic with synchronized, persistent state management across analysis contexts.",
      "description_length": 620,
      "index": 1002,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout.Offset",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for working with memory offsets within structured data, such as structs and unions, in the context of the WP plug-in. It supports construction and manipulation of offset values through functions like `field`, `index`, and `typeof_chain`, and provides utilities to compute sizes, ranges, and field positions using a cache for efficient layout queries. Concrete use cases include analyzing memory layout of C types and resolving field positions during symbolic execution or verification tasks.",
      "description_length": 522,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice.Absurd",
      "library": "frama-c-wp.core",
      "description": "Implements the absurd tactical for discharging goals by contradiction. Works with logical propositions and proof states represented in the WP intermediate format. Useful for automatically closing branches in proof scripts where a contradiction is present.",
      "description_length": 255,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Cache_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages the cache directory for the plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations like setting a custom cache directory or checking if one exists. Concrete use cases include storing temporary analysis results or persistent plugin state in a structured way.",
      "description_length": 397,
      "index": 1005,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVal.Value",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory values and provides operations to manipulate and query their structure. It supports construction of values from literals, variables, and memory accesses, along with extracting base addresses, domains, and offsets. Concrete use cases include modeling memory state during symbolic execution and reasoning about pointer arithmetic and field access in C code.",
      "description_length": 394,
      "index": 1006,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides symbolic manipulation of memory locations (variables, pointers, fields, arrays) with operations for address arithmetic, value loading/storing, initialization checks, and memory validity assertions. It operates on memory segments, program states (sigma), and logical terms to formalize memory behavior in Hoare logic, generating predicates for validity, allocation, and separation. Key use cases include verifying pointer arithmetic safety, managing variable lifetimes via scope/alloc primitives, and integrating symbolic memory states into formal verification workflows for C programs.",
      "description_length": 606,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Interactive",
      "library": "frama-c-wp.core",
      "description": "This module provides a robust framework for managing interactive string-based parameters with dynamic validation, state tracking, and alias resolution, integrating seamlessly with command-line interfaces and project systems. It defines a core data type `t` that supports equality, comparison, hashing, and structured serialization through descriptors and representatives, enabling rich introspection and type-safe value storage. Operations allow for safe value assignment, constraint enforcement, and runtime configuration with guaranteed integrity, such as validating user inputs against predefined sets or tracking parameter changes via update hooks. Specific use cases include building configurable plugins with persistent, typed settings and bridging interactive user input with internal state in a project-aware environment.",
      "description_length": 829,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheEnv",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with change tracking, default values, and command-line integration, while supporting marshaled state persistence across sessions. It maintains a shared environment cache with global on/off toggles, enabling dynamic control of caching policies during analysis workflows. The core data type includes operations for structured representation, comparison, and project-specific queries, facilitating efficient caching and typed value management in symbolic execution contexts. Use cases include runtime configuration via command-line flags, persistent state management, and deep-copying values within WP analysis workflows.",
      "description_length": 657,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Auto",
      "library": "frama-c-wp.core",
      "description": "This module handles command-line parameters with rich type information, offering polymorphic data structures and operations for parsing, comparing, and pretty-printing. It supports string-based parameters with validation, aliases, and state change callbacks, enabling structured interfaces with constrained values like `\"json\"` or `\"text\"`. Categories manage parameter groups with behaviors such as `@default` or `@all`, allowing dependencies and bulk state changes. Use cases include defining type-safe arguments in the WP plugin, enforcing parameter constraints, and organizing parameters into logical, modifiable groups.",
      "description_length": 623,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SplitMax",
      "library": "frama-c-wp.core",
      "description": "This module manages a bounded integer parameter representing a maximum split limit, with support for dynamic range configuration, value adjustments, and state persistence across projects. It includes operations for incrementing the value within constraints, tracking modifications, and integrating with command-line interfaces, along with hooks for user feedback and default handling. A companion data type supports structured parameter representation with equality, comparison, and pretty printing, enabling deep copying and project membership checks for symbolic execution workflows. Together, they allow precise control and customization of split thresholds in analysis tools, such as WP plugin configurations, while ensuring consistency and isolation across different project states.",
      "description_length": 787,
      "index": 1011,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Library",
      "library": "frama-c-wp.core",
      "description": "This library manages command-line parameters representing ordered file path lists, supporting dynamic configuration through element addition, emptiness checks, and transformations with `append_before`/`append_after`. It integrates with Frama-C's project system for state management, serialization, and hook execution on parameter changes, enabling synchronization with analysis workflows. The library's core operations handle polymorphic data types with equality, comparison, and pretty-printing, while submodules manage parameter categories like `@none` and `@all`, and provide string-based command-line parameter handling for the WP plugin, including validation and serialization. Examples include enabling parameter groups, customizing type representations, and managing WP-specific options through the command line.",
      "description_length": 819,
      "index": 1012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Cache",
      "library": "frama-c-wp.core",
      "description": "This module manages a string-typed configuration parameter with caching, validation, and serialization features, enabling controlled updates and change monitoring through hooks. It allows defining valid value sets, associating validation functions, and managing aliases, while providing command-line visibility and integration. The core data type supports equality, comparison, hashing, and pretty-printing, with deep copying and structured descriptors for efficient cache storage and project membership checks. Example uses include dynamic configuration parameters that require validation, persistent state tracking with custom serialization, and CLI-managed cached values with alias support.",
      "description_length": 693,
      "index": 1013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Provers",
      "library": "frama-c-wp.core",
      "description": "This module handles string list command-line parameters for prover configurations, supporting operations like appending, filtering, and folding, along with aliases and state tracking via update hooks. It integrates with submodules that manage parameter categories, define prover value types with equality and comparison, and handle string parameters with validation and hooks. Together, they enable configuring prover backends, defining category behaviors like `@default` or `@all`, and validating configurations through typed, serializable parameters. Examples include dynamically adjusting prover arguments, enabling prover sets based on categories, and building extensible command-line interfaces with structured validation.",
      "description_length": 727,
      "index": 1014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify.Split",
      "library": "frama-c-wp.core",
      "description": "Tracks occurrence counts of logical predicates to identify frequently used literals for case splitting. It provides functions to initialize an occurrence counter, add predicates, and retrieve a list of predicates with their frequencies. This supports optimizing proof strategies by prioritizing common literals.",
      "description_length": 311,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CounterExamples",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter to control counterexample generation, enabling dynamic toggling during formal verification workflows. It provides operations to enable or disable the feature, monitor state changes, and integrate with command-line interfaces, centered around the boolean type `t`. The child module defines a structured data type for counterexamples, supporting equality, comparison, hashing, and pretty printing, with deep copying to avoid shared state. Together, they allow workflows where counterexample generation is conditionally enabled and the resulting data is analyzed, manipulated, or displayed in tools like the WP plugin for Frama-C.",
      "description_length": 667,
      "index": 1016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Simpl",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with rich metadata, including defaults, visibility, and serialization, while supporting dynamic reconfiguration and state persistence through callbacks and aliases. It provides core operations to set, toggle, and query boolean states, along with a derived data type that enables equality checks, comparisons, and deep copies, particularly for symbolic representations in verification tasks. You can use it to configure switchable analysis modes or output settings in plugins, where project-specific conditions affect visibility or behavior. The combined interface allows seamless integration of parameter logic with structured data handling, ensuring robust state management across different verification contexts.",
      "description_length": 753,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.FinalizeScripts",
      "library": "frama-c-wp.core",
      "description": "This module manages a global boolean flag to control script finalization behavior, with operations to set, get, and query its state, along with support for update hooks, aliases, and serialization. It integrates with a child module that defines a rich data type for structured script data, supporting equality, comparison, hashing, and project membership checks. Together, they enable dynamic configuration of finalization logic and precise manipulation of script data during finalization phases. Example uses include conditionally disabling finalization globally, registering callbacks to react to flag changes, and using structured data descriptors to filter or copy script-specific state.",
      "description_length": 691,
      "index": 1018,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Volatile",
      "library": "frama-c-wp.core",
      "description": "This module manages volatile boolean states with dynamic value manipulation, change notifications, and lifecycle control, supporting runtime toggleable settings like feature switches. It introduces a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing, enabling structured data representation and inspection. It allows managing shared boolean flags, synchronizing state across components, and serializing or formatting values for debugging and user output. Example uses include implementing analysis modes in Frama-C plugins and handling typed volatile parameters with deep copying and comparison.",
      "description_length": 642,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Dump",
      "library": "frama-c-wp.core",
      "description": "This module manages a mutable boolean reference with configuration and observation capabilities, allowing operations like set, get, reset, and toggle. It supports custom marshaling, alias management, and hook registration, enabling runtime feature control and state synchronization across plugin workflows. The child module enhances this functionality by providing structured data handling, including equality checks, comparison, pretty-printing, and deep copying, which are used to manage complex analysis data. Together, they allow fine-grained control over boolean switches\u2014such as enabling diagnostics or analysis passes\u2014while ensuring structured, persistent storage and traversal of related data.",
      "description_length": 701,
      "index": 1020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.Compiler-M",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling operations for symbolic verification, enabling pointer arithmetic, array indexing, and struct field traversal to translate C constructs into abstract memory representations. It manipulates memory states (`sigma`), segments, and variables to enforce memory safety through initialization checks, validity scoping, and segment separation constraints. These capabilities support verification workflows by generating logical formulas for memory validity and tracking state updates during program analysis.",
      "description_length": 537,
      "index": 1021,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cvalues.Logic",
      "library": "frama-c-wp.core",
      "description": "This module offers functions to manipulate logic values representing memory states, enabling arithmetic operations, memory location transformations, and region/field management. It operates on structured types like `logic`, `region`, and `segment`, integrating terms from formal memory models and static analysis frameworks. These tools are used to construct and reason about logical expressions for memory validity, separation, and inclusion during program verification.",
      "description_length": 471,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InitWithForall",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean configuration parameters with lifecycle hooks and state tracking, supporting serialization, default values, and project-specific persistence through custom marshaling. It enables fine-grained control over boolean options like feature toggles, with operations for setting, querying, and validating values during their lifecycle. The child module enhances this system by defining a structured data type with equality, comparison, and pretty-printing operations, facilitating the representation of complex parameter states within the WP plugin. Together, they support use cases such as managing symbolic execution settings, ensuring type consistency, and performing project-specific queries with deep copies and packed type handling.",
      "description_length": 758,
      "index": 1023,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTests",
      "library": "frama-c-wp.core",
      "description": "This module provides a structured data type for representing test values with support for equality, comparison, hashing, and pretty-printing, specifically designed for smoke testing in the WP plugin. It includes operations for deep copying, project-aware membership checks, and runtime type inspection through a packed descriptor. The type's built-in list of representative values facilitates test case validation and project state analysis. Submodules extend this functionality with additional utilities for test execution and result reporting.",
      "description_length": 545,
      "index": 1024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.N",
      "library": "frama-c-wp.core",
      "description": "This module defines arithmetic operations, comparisons, and logical operators for constructing terms and predicates in a formal logic language. It provides concrete functions for addition, subtraction, multiplication, division, modulus, equality, and ordering, along with implication, conjunction, disjunction, and negation for building logical expressions. These operations are used to represent and manipulate formal proofs and conditions within the WP plug-in's verification framework.",
      "description_length": 488,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Config_dir",
      "library": "frama-c-wp.core",
      "description": "This module manages the configuration directory for the plugin, providing operations to retrieve, set, and check the existence of a specific directory path. It works with `Frama_c_kernel.Filepath.t` to represent file and directory paths, and supports creating paths when accessing files or directories. Concrete use cases include initializing plugin-specific storage locations and ensuring consistent access to configuration files.",
      "description_length": 431,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.InteractiveTimeout",
      "library": "frama-c-wp.core",
      "description": "This module manages an integer parameter with bounded adjustments, synchronization with configuration systems, and customizable serialization, enabling safe, interactive tuning of time-sensitive thresholds in formal verification workflows. It supports operations for setting, clamping, and persisting values, along with command-line integration and default handling, allowing precise control over dynamic analysis settings. The child module introduces a structured data type with equality, comparison, and deep-copying capabilities, specifically for interactive timeout parameters in the WP plugin, facilitating robust configuration management during proof sessions. Together, they enable use cases such as tracking timeout changes across projects, enforcing consistency, and serializing configurations for reproducible analyses.",
      "description_length": 829,
      "index": 1027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.Compiler-C",
      "library": "frama-c-wp.core",
      "description": "This module enables type-safe evaluation and symbolic manipulation of C expressions within a memory state (`sigma`), handling conversions, comparisons, and function pointers through operations on C locations, values, and results. It formalizes memory and variable properties using logical predicates to verify conditions like zero-initialized ranges, invariant memory regions, and state transitions, leveraging `Wp.Lang.F.term` for symbolic representation. Key use cases include static analysis tasks such as proving memory safety, validating variable behavior across execution paths, and compiling C constructs into formal terms for verification.",
      "description_length": 647,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.LogicAssigns-L",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for managing memory frames and call contexts, translating CIL constructs into abstract memory models, and verifying memory assignment constraints through lemmas and region analysis. It works with data structures like frames, environments, logic variables, and memory regions, alongside formal verification primitives such as predicates and sigma types. These capabilities are applied in formal verification workflows to ensure memory safety, handle pre/post-state transitions during function calls, and validate region-based assignment conditions in program logic.",
      "description_length": 596,
      "index": 1029,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Wp.Wp_parameters.Detect",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with state tracking, default values, and command-line integration, using a dedicated type `t` that supports persistence, aliasing, and shared state via `on`/`off` toggles. It allows custom pre/post-update hooks and serialization, enabling use cases like configuring detection behaviors from the command line and persisting settings across sessions. The child module enhances it with abstract value manipulation, offering equality checks, comparison, hashing, and pretty-printing for structured analysis in symbolic execution and static verification. Together, they support fine-grained control over detection logic and precise handling of complex data structures in analysis workflows.",
      "description_length": 724,
      "index": 1030,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemBytes.LOADER",
      "library": "frama-c-wp.core",
      "description": "This module facilitates memory modeling and pointer manipulation by providing functions to load and store typed values (integers, floats, pointers, atomic objects) into symbolic memory states. It handles operations like memory footprint computation, region management, and pointer arithmetic, supporting use cases in symbolic execution for program analysis and verification. The module works with memory chunks and terms to represent and update memory states during symbolic reasoning.",
      "description_length": 485,
      "index": 1031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.IData",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing model registration data, including parsing and compiling model keys into structured data. It works with string keys and model data types, supporting concrete tasks like extracting base names and compiling model identifiers into usable forms. It is used during model registration and resolution in the WP plugin's internal context management.",
      "description_length": 385,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang.Field",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical fields in the context of the WP plug-in's logic language. It provides operations for comparing, hashing, and pretty-printing fields, along with converting them to logic sorts. Concrete use cases include managing field identifiers during symbolic reasoning and generating human-readable representations for debugging and output.",
      "description_length": 374,
      "index": 1033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Literals",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean flag state with support for dynamic updates, change tracking, and serialization, integrating context-aware value handling and alias management. It defines a boolean type with default states and project-specific membership testing, enabling use cases such as feature toggles and CLI-driven configuration. The `on` and `off` operations directly toggle flag states, while child module functionality extends value manipulation with equality checks, deep copying, and pretty-printing for analysis in C code processing. Together, they support robust parameter handling and runtime configuration within the plugin's environment.",
      "description_length": 649,
      "index": 1034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.TimeMargin",
      "library": "frama-c-wp.core",
      "description": "This module manages string-based parameter configurations with validation, serialization, and change tracking, supporting use cases like enforcing constraints on time margin adjustments. It provides core operations for defining allowed values, customizing CLI behavior, and attaching hooks to monitor modifications, while integrating with a broader parameter system and project state. The primary data type enables structured manipulation of configurations with equality, comparison, and pretty printing, supporting deep copies and membership checks over project skeletons. Together, the module and its submodules allow building, validating, and persisting time margin policies with fine-grained control over their representation and behavior.",
      "description_length": 743,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.StrategyEngine",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean strategy options with support for state tracking, hooks, and serialization, integrating directly with Frama-C's state system for dynamic analysis control. It provides data types for representing strategy configurations and operations to set, retrieve, and monitor changes, along with submodules that enable structured data manipulation, comparison, and project-based queries. You can toggle analysis modes, persist configurations across sessions, and trigger actions when options change, while submodules support deep copies, descriptors, and structured output for strategy states. Use cases include command-line configuration, runtime strategy switching, and WP plugin-specific data validation and serialization.",
      "description_length": 741,
      "index": 1036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.StatusTrue",
      "library": "frama-c-wp.core",
      "description": "This module manages a shared boolean state with support for change tracking, value persistence, and update hooks, integrating directly with project-scoped configuration and user interface elements. It provides core operations to set and observe values, synchronize state with external systems, and control visibility in command-line interfaces, centered around the boolean data type. The child module enhances this functionality by defining a structured data type for analysis statuses within the WP plugin, offering utilities for comparison, copying, and pretty printing to support precise verification result handling. Together, they enable use cases like feature toggling, plugin status monitoring, and synchronized state updates across sessions and program analyses.",
      "description_length": 770,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Tactical.Fmap",
      "library": "frama-c-wp.core",
      "description": "This module implements a map structure for tactical fields, supporting operations to create, retrieve, and update values associated with typed fields. It works with arbitrary typed values through the `'a Wp.Tactical.field` type, enabling field-specific access. Concrete use cases include managing per-tactical configuration or state in proof automation.",
      "description_length": 353,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Data",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing layout regions, including equality checks, comparison, and pretty-printing of region identifiers. It works with the abstract type `t` representing layout regions, primarily used for tracking and comparing memory regions in the analysis. Concrete use cases include ensuring consistent region identity during static analysis and formatting region names for diagnostic output.",
      "description_length": 417,
      "index": 1039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Generate",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with state tracking, enabling explicit toggling and state queries, while integrating with a project-specific state system for CLI configuration and help documentation. It provides a dedicated boolean type alongside operations for equality, comparison, hashing, and pretty-printing, supporting structured data representation with descriptors and deep copying. Submodules enhance this functionality by enabling safe manipulation and unique identification of complex values, particularly for symbolic representations of program states. Example uses include parameterizing tool behavior via CLI options and synchronizing state changes across components in an analysis framework.",
      "description_length": 713,
      "index": 1040,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyIsCint",
      "library": "frama-c-wp.core",
      "description": "This component manages boolean options within the WP plugin framework, offering state manipulation through explicit `on`/`off` toggles and implicit value tracking. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type handling and introspection. Main data types include boolean values with metadata and structured parameter types, with operations for comparison, hashing, serialization, and project-level consistency. Examples include managing feature flags, symbolic execution parameters, and analysis settings that require runtime modification and persistent configuration.",
      "description_length": 649,
      "index": 1041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Ground",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean configuration flags with support for state toggling, persistent serialization, and project-specific tracking. It provides operations for defining, modifying, and querying boolean values with default preservation, command-line integration, and alias resolution. The core data type `t` enables structural comparisons, hashing, and pretty-printing, while supporting project membership checks and deep copying for Frama-C analysis parameters. Use it to control runtime switches like feature flags or analysis settings in the WP plugin, with submodules handling structured configuration data tied to Frama-C projects.",
      "description_length": 640,
      "index": 1042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc.Havoc",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in tactical that introduces non-deterministic state changes during proof execution. It operates on logical states and proof goals, enabling controlled disruption to simulate unpredictable behavior. Useful for testing proof robustness or modeling systems with uncertain transitions.",
      "description_length": 300,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ByValue",
      "library": "frama-c-wp.core",
      "description": "This module manages a global string set as a command-line parameter, supporting element addition, membership checks, iteration, and state queries. It works with `ByValue.t` values to enable tracking CLI configuration changes, customizing value marshaling, and handling dynamic sets of strings in plugin settings. The module integrates with submodules that manage parameter categories, validate string parameters, and define operations for specific command-line datatypes, enabling use cases like setting default behaviors, enforcing input formats, and maintaining comparable parameter representations. Together, these components support structured configuration management, dynamic value handling, and context-aware parameter interpretation in command-line tools.",
      "description_length": 763,
      "index": 1044,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ProofTrace",
      "library": "frama-c-wp.core",
      "description": "This module manages proof trace generation through a global boolean setting, allowing clients to enable or disable tracing, register hooks for state changes, and define aliases. It coordinates with the plugin's state system to ensure configuration updates are persistent and visible across components. The core type `t` from its child module models individual proof trace elements, supporting operations like comparison, hashing, and pretty-printing, enabling detailed inspection and transformation of verification results. Use cases include debugging proofs interactively by enabling trace output or automating trace logging for critical verification steps in batch workflows.",
      "description_length": 677,
      "index": 1045,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Memory.CodeSemantics-M",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling operations for formal verification of C programs, including memory state manipulation (load, store, validity checks), location arithmetic (pointer comparisons, array indexing), and scope management (frame setup, segment separation). It operates on memory states (`sigma`), locations (`M.loc`), segments (`M.segment`), and C types (`c_object`), while integrating logical predicates (`F.pred`) to enforce memory safety and data layout constraints. Key use cases involve verifying pointer arithmetic, initialization correctness, and memory partitioning in low-level code.",
      "description_length": 605,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc.Validity",
      "library": "frama-c-wp.core",
      "description": "This module ensures the validity of havoc operations during proof generation by verifying that all modified variables meet necessary preconditions. It operates on logical contexts and variable sets, leveraging selection strategies to determine which variables to havoc. Concrete use cases include validating memory state transformations in program verification and ensuring soundness of automated reasoning steps in safety-critical code analysis.",
      "description_length": 446,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.DISK",
      "library": "frama-c-wp.core",
      "description": "This module computes file paths for proof goals based on a property ID, model, and prover. It relies on the `Wp.WpPropId`, `Wp.WpContext`, and `Wp.VCS` modules to retrieve identifiers and configuration data. A typical use case involves generating unique file names for storing proof obligations on disk during static analysis.",
      "description_length": 326,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.WeakIntModel",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with explicit state transitions, runtime queries, and customizable serialization, integrating seamlessly into a larger state management system for persistent and CLI-driven configurations. It provides a polymorphic data type `t` with equality, comparison, and pretty-printing operations, along with descriptors for structured representation and type inspection. You can use it to toggle analysis features via the command line, persist state across sessions, or inspect and copy abstract data values within the WP plugin. Submodules enhance its capabilities with advanced data manipulation and type tracking features.",
      "description_length": 655,
      "index": 1049,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.LogicCompiler.Make",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for constructing and analyzing symbolic execution frames, compiling logic expressions, and managing environments with logic variables, labels, and substitution structures. It works with types like `frame`, `call`, `sigma`, and `env` to handle formal verification tasks such as function call modeling, region analysis, and lemma conversion, particularly in contexts requiring memory modeling and logic-to-code integration. Specific use cases include translating logical predicates into program annotations, evaluating terms against CIL types, and orchestrating verification workflows with scoped variable bindings.",
      "description_length": 645,
      "index": 1050,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Sigma.Make",
      "library": "frama-c-wp.core",
      "description": "This module extends a memory model with a new chunk type, enabling uniform handling of individual chunks through operations like `chunk`, `singleton`, `mem`, `get`, and `value`. It works with chunk types defined in a parameter module and integrates them into a shared sigma structure. Concrete use cases include modeling memory regions with custom chunk representations and querying their presence or values within a sigma context.",
      "description_length": 431,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Chunk",
      "library": "frama-c-wp.core",
      "description": "This module manages sets of integer ranges, called chunks, with operations to create empty or singleton sets, check membership, and combine sets through union or disjoint checks. It supports efficient manipulation of non-overlapping integer intervals, using a custom `chunks` data type. Concrete use cases include tracking memory regions or line numbers in source code where disjointed ranges must be merged or validated.",
      "description_length": 421,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CacheDir",
      "library": "frama-c-wp.core",
      "description": "This module manages a string-based cache directory configuration with validated paths, change hooks, and metadata handling, supporting dynamic updates and project-specific path resolution. It defines a structured data type with equality, comparison, and serialization operations for typed caching, enabling efficient storage of project-scoped values like computation results. You can register callbacks for path changes, validate function names against constraints, and use packed descriptors to ensure data integrity across plugin workflows. Submodules enhance this by providing typed representations and deep copy mechanisms to prevent shared state in cached entries.",
      "description_length": 669,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.ReportJson",
      "library": "frama-c-wp.core",
      "description": "This module manages configuration and state for file path options, integrating serialization, alias resolution, and deprecation handling with JSON-based reporting. It defines structured data types with equality, comparison, and pretty-printing operations, supporting analysis results and human-readable output. Operations include checking unset paths, registering update callbacks, and maintaining backward compatibility through flag aliases. The module enables storing and comparing structured data, generating JSON reports, and ensuring safe data handling with deep copies and project membership checks.",
      "description_length": 605,
      "index": 1054,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.Fun",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates logical functions in the Wp plugin's low-level logic language. It provides operations for comparing, hashing, and pretty-printing functions, as well as inspecting their properties such as parameter types, result type, and logical category. These functions are used during debugging and formal verification tasks involving logic terms.",
      "description_length": 373,
      "index": 1055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.Model",
      "library": "frama-c-wp.core",
      "description": "This module provides memory modeling operations for symbolic reasoning and formal verification of memory properties in program analysis. It works with memory locations (`loc`), memory states (`sigma`), C-types, and logical formulas (`pred`, `term`), supporting tasks like translating C constructs (pointers, arrays) into abstract locations, managing heap partitions, and validating memory operations through comparisons, initialization checks, and separation proofs. Specific use cases include verifying pointer arithmetic safety, analyzing memory block validity, and modeling heap state transitions during program execution.",
      "description_length": 625,
      "index": 1056,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.OldReportJson",
      "library": "frama-c-wp.core",
      "description": "This module combines configuration parameter management with structured data manipulation to support the definition, validation, and serialization of plugin settings and analysis results. It provides data types for representing project-specific values with operations for comparison, hashing, and pretty-printing, alongside APIs for defining parameters with validation rules, allowed values, and change hooks. The module enables use cases such as registering configurable options that integrate with command-line interfaces, validating input against predefined constraints, and serializing structured data to JSON for reporting. Submodules enhance this functionality by ensuring type-safe data manipulation and consistent state handling across the plugin interface.",
      "description_length": 765,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.GOAL",
      "library": "frama-c-wp.core",
      "description": "This module manages goal structures within a verification context, providing operations to create goals from sequents, compute proof-related data, and retrieve goal descriptions. It works with data types like `Wp.Wpo.GOAL.t` for goals, `Wp.Conditions.sequent` for logical sequents, and `Wp.Lang.F.pred` for predicates. Concrete use cases include constructing verification goals, computing proof terms, extracting goal metadata, and tracking proof computation times.",
      "description_length": 465,
      "index": 1058,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Sigma.Chunk",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to inspect and manipulate chunk values, including equality checks, comparison, and pretty-printing. It works with the chunk type `t`, which represents memory chunks in the WP plug-in, and includes functions to access properties like type, name, and initialization status. Concrete use cases include filtering memory chunks based on initialization, sorting chunks for symbol compilation, and generating variable names from chunks.",
      "description_length": 461,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.GeneratorID",
      "library": "frama-c-wp.core",
      "description": "This module implements a model-specific, projectified storage system with key-value semantics. It supports operations to check existence (`mem`), retrieve (`get`, `find`), assign (`set`), and remove (`remove`, `clear`) values associated with keys. Designed for contextual data management where model dependencies dictate data isolation and persistence.",
      "description_length": 352,
      "index": 1060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.Entries",
      "library": "frama-c-wp.core",
      "description": "This module manages a collection of registered model entries, indexed by keys and associated data. It supports operations to add, retrieve, and iterate over entries using the key type and data type defined in the enclosing context. Concrete use cases include maintaining a registry of analysis models or configuration settings keyed by identifier.",
      "description_length": 347,
      "index": 1061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgWP.VCgen",
      "library": "frama-c-wp.core",
      "description": "This module supports the generation and manipulation of verification conditions by handling control-flow constructs (loops, conditionals, function calls), managing preconditions and postconditions, and integrating axioms, hypotheses, and lemmas into a logical framework. It operates on structured representations of program states, including logical environments (`t_env`), logical propositions (`t_prop`), and CIL/Wp-specific intermediate forms, enabling tasks like proving software correctness through automated logical formula translation and analysis.",
      "description_length": 555,
      "index": 1062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Parasite",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with state toggling, value tracking via hooks, and serialization, centered around the `t` type. It handles project-specific configurations, aliased options, visibility controls, and deprecation handling, with support for synchronizing plugin settings, managing legacy transitions, and persisting state in workflows. A child module defines a data type with equality, comparison, hashing, and pretty printing operations, tailored for the WP plugin's parameter system. It supports membership checks, deep copying without shared references, and structured data manipulation within the plugin's analysis framework.",
      "description_length": 648,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofEngine.Node",
      "library": "frama-c-wp.core",
      "description": "Handles node identity and comparison operations within an interactive proof engine. Works with proof nodes, providing hash, equality, ordering, and pretty-printing functions. Used to manage and track proof steps during interactive theorem proving sessions.",
      "description_length": 256,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.MINDEX",
      "library": "frama-c-wp.core",
      "description": "This module implements a mutable map-like structure for associating model keys with polymorphic values, supporting precise insertion, lookup, and in-place modification operations alongside bulk updates via sequences. It provides administrative controls for managing storage lifecycle and performance metrics, optimized for handling dynamic model-specific data in the WP plugin. Typical applications include maintaining transient model state, batch registration of key-value pairs, and efficient iterative transformations during static analysis workflows.",
      "description_length": 554,
      "index": 1065,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpContext.Index",
      "library": "frama-c-wp.core",
      "description": "This module manages a model-specific registry of keys and associated data, providing operations to define, retrieve, and manipulate entries with protections against redefinition and circular dependencies. It supports key-based lookups, memoization, and callbacks for notification on updates, ensuring data integrity during registration. Concrete use cases include tracking analysis results for program elements, caching computed values during verification, and managing dependencies between logical entities in a proof context.",
      "description_length": 527,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Usage",
      "library": "frama-c-wp.core",
      "description": "This module manages layout usage information for regions in the WP plugin. It provides operations to merge usage data, check if a region is shifted or aliased, and format usage information for debugging. It works directly with the `Wp.Layout.usage` type to track and analyze memory region properties during verification.",
      "description_length": 320,
      "index": 1067,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.ScriptMode",
      "library": "frama-c-wp.core",
      "description": "This module manages string parameters with validation, comparison, and change tracking, integrating with Frama-C's state system for project-aware serialization and function name checks. It supports command-line features like aliases and help messages, while its child module enhances script mode parameters with structured data types that support equality, comparison, and introspection. Together, they enable robust configuration of analysis settings, deep state copying, and type-safe parameter handling across WP plugin sessions. Example uses include validating user input, tracking parameter changes, and ensuring consistent project state during analysis.",
      "description_length": 659,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.RunAllProvers",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter that controls whether all provers are executed, offering operations to toggle its state, track project-specific values, and trigger callbacks on changes. It works with a boolean type augmented with metadata for serialization, default values, and contextual persistence, enabling dynamic control over prover runs based on analysis needs or user strategies. The child module defines and manipulates prover configurations, supporting comparison, hashing, pretty-printing, project membership checks, and deep copies. Together, they allow fine-grained, context-aware control over prover execution and configuration management within the analysis framework.",
      "description_length": 691,
      "index": 1069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Core",
      "library": "frama-c-wp.core",
      "description": "This module introduces a boolean parameter type with robust state management, value change hooks, and serialization capabilities, tightly integrated with Frama-C's project and kernel systems for handling plugin settings. It supports dynamic configuration through command-line interfaces and persistent storage, enabling feature toggling via unit-triggered state updates and ensuring cross-session consistency. The child module enhances this functionality by defining a structured data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with support for deep copying and project membership checks. Together, they enable precise manipulation and comparison of parameter configurations during static analysis, ensuring correct data representation across analysis phases and facilitating advanced use cases like configuration diffing and synchronization.",
      "description_length": 886,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Matrix",
      "library": "frama-c-wp.core",
      "description": "This module provides functions for matrix layout calculations, including computing greatest common divisors, formatting integer lists, determining sizes, and merging integer lists. It operates on integer values and lists, with specific use cases in arranging and computing dimensions for regions in a layout. These functions support precise spatial computations and formatting for region-based data structures.",
      "description_length": 410,
      "index": 1071,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Wp.Layout.Deref",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for comparing and printing region dereference values. It supports equality checks, ordering, and pretty-printing of `t` type instances. Useful for analyzing memory regions in static analysis tasks.",
      "description_length": 228,
      "index": 1072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext.Static",
      "library": "frama-c-wp.core",
      "description": "This module manages a static, project-independent context for storing and retrieving data associated with keys, using the types `key` and `data` from the parameter module `E`. It supports operations like `define`, `update`, `get`, and `find` for key-value manipulation, with protections against redefinition and circular dependencies. Concrete use cases include caching computed values, registering named entities, and managing configuration or state data across different analysis phases.",
      "description_length": 489,
      "index": 1073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Behaviors",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line parameters that store collections of strings, supporting operations like appending, checking emptiness, and applying transformations. It integrates with parameter categories to organize behavior under named groups like `@default` or `@all`, and defines a core data type `t` for comparing, hashing, and pretty-printing parameter values. It also includes validation mechanisms for string-based parameters with constraints, alias resolution, and change tracking, enabling use cases such as accumulating include paths, validating function names, and maintaining stateful parameter configurations with dynamic updates and custom marshaling.",
      "description_length": 668,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels.LabelSet",
      "library": "frama-c-wp.core",
      "description": "This module provides standard set operations (union, intersection, difference) and transformations (map, filter, fold) for sets of normalized C-labels, maintaining structural equality and ordering. It supports ordered iteration, membership queries, and conversions between lists and sequences. Typical applications include managing label sets during C code analysis, such as aggregating labels across program paths or partitioning them based on verification requirements.",
      "description_length": 471,
      "index": 1075,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Print",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with support for dynamic toggling, persistent configuration, and project-specific state, integrating directly with command-line interfaces. It defines operations to set, retrieve, and monitor changes to boolean values, enabling runtime adjustments and serialization for saved settings. The child module enhances this system by providing structured data representations with comparison, hashing, and pretty-printing capabilities, tailored for parameter management in static analysis workflows. Together, they support tasks like tracking print flags, comparing analysis configurations, and generating user-readable output in Frama-C's WP plugin.",
      "description_length": 683,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Prune",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter with support for CLI integration, state persistence, and dynamic configuration updates, making it suitable for controlling behavior like pruning in workflows or enforcing data retention policies. It includes a custom boolean type with alias handling, change hooks, and serialization, allowing for runtime configuration switches and feature toggles with audit-tracked changes. The child module enhances this functionality by defining a data type with equality, comparison, and pretty-printing operations, tailored for structured data manipulation during program analysis. Together, they support use cases such as pruning redundant states, comparing intermediate analysis values, and propagating configuration changes across systems.",
      "description_length": 771,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Verbose",
      "library": "frama-c-wp.core",
      "description": "This module manages verbosity levels as bounded integers, enabling controlled adjustments through increment, set, and get operations, while integrating with command-line interfaces for dynamic configuration and supporting serialization for persistence. It includes a structured data type with equality, comparison, and pretty-printing operations, designed for representing verbose parameter states in static analysis tools like Frama-C. The module facilitates monitoring verbosity changes via hooks and ensures state isolation through deep copying, making it suitable for plugin systems requiring fine-grained diagnostic output control. Example uses include configuring analysis tool output detail dynamically and persisting verbosity settings across sessions.",
      "description_length": 760,
      "index": 1078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrepareScripts",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean configuration option with support for state modification via set/get functions, value change hooks, and CLI integration, using a boolean type `t` that handles defaults, serialization, and alias management. It allows runtime feature control through `on` and `off` functions, enabling conditional behavior in workflows. The child module enhances this system by defining a structured data type with equality, comparison, and introspection capabilities, used to represent and validate parameters in the WP plugin. Together, they support flexible configuration and robust parameter handling during script preparation and analysis.",
      "description_length": 655,
      "index": 1079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCalculus.Make",
      "library": "frama-c-wp.core",
      "description": "Implements symbolic computation over logical propositions using a configurable calculus engine. Operates on Wp's internal logical syntax trees and constraint sets, enabling precise manipulation of verification conditions. Useful for building custom proof strategies that require direct access to the underlying logical structure of programs.",
      "description_length": 341,
      "index": 1080,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Sigma.ChunkType",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for managing chunk types in a verification context, including equality, comparison, and pretty-printing functions. It works with a chunk type `t` that represents memory regions, each associated with a data type `F.tau` and metadata like initialization status and scope. Concrete use cases include filtering memory initialization chunks, sorting function parameters in generated ACSL code, and generating fresh variable names based on chunk basenames.",
      "description_length": 481,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Debug",
      "library": "frama-c-wp.core",
      "description": "This module manages integer parameters with dynamic state control, supporting operations like setting values, defining ranges, incrementing, and registering change hooks, all integrated with Frama_c_kernel for project-scoped state. It defines a structured data type with equality, comparison, and pretty printing for representing debug information in the WP plugin, enabling tasks like symbolic state comparison during verification. You can use it to configure debug settings interactively, track changes across sessions, or integrate with command-line interfaces. Submodules enhance this by supporting deep copies, type descriptors, and project membership checks for robust state manipulation.",
      "description_length": 694,
      "index": 1082,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.Reduce",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean state transitions with operations to set, track, and persist flags, supporting use cases like toggling reduction strategies or feature controls during analysis. It integrates with CLI tools and serialization layers, enabling configuration-driven workflows with change monitoring and dependency handling. The child module enhances this functionality by defining rich data types for structured manipulation, comparison, and project-specific filtering of symbolic states and expressions. Together, they support deep analysis tasks such as state persistence, strategy selection, and project-aware reduction pipelines.",
      "description_length": 641,
      "index": 1083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SimplifyType",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters with operations to set, retrieve, and toggle shared state values, while supporting alias registration, serialization control, command-line configuration, and dynamic state adjustments via hook-driven updates. It defines a core data type for representants of a descriptor, with structural manipulation, deep copying, equality, hashing, and pretty-printing, enabling precise comparison and management of complex data structures in static analysis. Submodule functionality extends to predicate-based membership checks within projects and persistence tracking through boolean value changes. Example uses include configuring analysis modes, tracking symbolic expressions, and synchronizing abstract value states across analysis phases.",
      "description_length": 769,
      "index": 1084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Cluster",
      "library": "frama-c-wp.core",
      "description": "This module manages memory layout clusters for static analysis, providing operations to manipulate and query structured memory regions. It supports dereferencing lazy pointers, shifting cluster positions, merging overlapping clusters, and reshaping clusters based on equality constraints. Use cases include tracking memory accesses in pointer analysis and organizing memory regions for verification condition generation.",
      "description_length": 420,
      "index": 1085,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Memory.Compiler-A",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for analyzing memory regions and their effects on program state. It provides functions to compute the memory footprint of a region and to relate memory states before and after assignments. These operations are used to verify memory safety and track changes to specific memory locations during program execution.",
      "description_length": 342,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory.LogicSemantics",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for compiling ACSL expressions into formal logic representations and verifying memory-related properties, working with memory frames, logical terms, and regions. It manipulates environments (`sigma`, `env`) and location types to translate CIL constructs into verifiable predicates, handle function call semantics, and validate memory assignments with support for complex data structures. Specific use cases include program verification tasks like proving memory safety, evaluating ACSL lemmas, and generating logical constraints for static analysis.",
      "description_length": 581,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcall",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean option to control smoke deadcall analysis, with functions to enable or disable the feature, track changes via hooks, and handle default values, aliases, and serialization. It integrates with Frama-C's state management, allowing configuration through project settings or command-line flags, and supports deep copying, comparison, and pretty-printing of parameter values. The `t` type enables precise control and representation of analysis states within the WP plugin's framework. Example uses include toggling deadcall analysis during static verification and persisting configuration across analysis sessions.",
      "description_length": 638,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.PrecondWeakening",
      "library": "frama-c-wp.core",
      "description": "This module manages boolean parameters and state for precondition weakening in formal verification, enabling dynamic configuration of analysis strategies through flags, project state marshaling, and lifecycle management. It defines a core data type with equality, comparison, and pretty-printing operations, supporting deep copies and membership checks over project skeletons to ensure structural integrity. Operations allow toggling flags, resolving aliases, tracking state changes, and integrating dynamic updates during proof computation. It is used to adjust precondition strength interactively and manage logical analysis parameters within the WP plugin.",
      "description_length": 659,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Why3ExtraConfig",
      "library": "frama-c-wp.core",
      "description": "This module manages command-line option lists with support for dynamic configuration, including value updates, alias definitions, and serialization. It operates on `string list` structures, providing element-wise iteration, folding, and list composition through prepend/append operations, while allowing pre/post-hook registration for configuration changes. The value module handles reliable comparison and copying of parameter values, the category module organizes parameters into states like `@none` and `@all`, and the string parameter module enforces constraints, tracks project membership, and supports plugin workflows through structured type descriptors and update hooks. Example uses include configuring analysis tools with interdependent parameters, setting default behaviors, and serializing CLI state for plugins.",
      "description_length": 824,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler.Node",
      "library": "frama-c-wp.core",
      "description": "This module represents program points in a control-flow graph, enabling the creation, comparison, and printing of nodes that track execution states during static analysis. It supports direct manipulation of node values and integrates with submodules that provide imperative hash tables, functional maps, and sets for managing node-associated data, enabling efficient lookups, transformations, and aggregations. Use it to model control flow paths, associate analysis metadata with program locations, or compute reachability and coverage properties across traces.",
      "description_length": 561,
      "index": 1091,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Warning.Map",
      "library": "frama-c-wp.core",
      "description": "This module manages key-value mappings with ordered `Wp.Warning.t` keys, supporting insertion, deletion, lookup, and merging operations. It offers transformations for filtering and mapping, along with conversions to lists and sequences, enabling efficient handling of contextual error data. These capabilities are particularly useful for aggregating warnings from static analysis or combining error contexts during formal verification workflows.",
      "description_length": 445,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.UnfoldAssigns",
      "library": "frama-c-wp.core",
      "description": "This module manages integer-typed configuration parameters with mutable state, tracking changes and enforcing constraints like valid ranges through update hooks. It supports command-line integration, marshaling for storage or communication, and includes operations for programmatic adjustment and validation. A child module enhances parameter handling with structured data types that support equality, comparison, and project membership checks, enabling precise manipulation during static analysis. Together, they facilitate robust configuration management, symbolic state tracking, and type-safe parameter transformations across sessions.",
      "description_length": 639,
      "index": 1093,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemVar.Static",
      "library": "frama-c-wp.core",
      "description": "This module tracks variable usage based solely on static CIL information. It provides functions to extract parameter information from variable declarations, iterate over variables with optional kernel function filtering, and initialize state for analysis. It is used to analyze static variable properties in C code without dynamic context.",
      "description_length": 339,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeTimeout",
      "library": "frama-c-wp.core",
      "description": "This module manages timeout values as integers with configurable bounds, providing operations to set, retrieve, and monitor changes while enforcing range constraints. It integrates with state management systems to support project-specific tracking, serialization, and synchronization, making it suitable for use in WP plugin configurations and command-line interface interactions. The module includes a data type with support for equality, comparison, hashing, and pretty-printing, along with functions for deep copying, project membership checks, and descriptor management. Use cases include enforcing timeout limits during verification tasks, propagating configuration changes through hooks, and maintaining consistent timeout behavior across analysis sessions and user-facing tools.",
      "description_length": 785,
      "index": 1095,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadassumes",
      "library": "frama-c-wp.core",
      "description": "This module manages a boolean parameter controlling analysis behavior, with imperative operations to toggle, retrieve, and query its state, supporting project-specific values and configuration persistence. It provides structured data representation through a concrete type with equality, comparison, and pretty-printing, enabling typed value management in static analysis workflows. You can use it to track analysis settings across projects, serialize configurations, and associate values with project membership. The API combines direct state manipulation with rich data operations for flexible integration into analysis tooling.",
      "description_length": 630,
      "index": 1096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Lang.For_export",
      "library": "frama-c-wp.core",
      "description": "This module handles term rebuilding and manages built-in function representations for a logic language. It works with terms, functions, and maps from the `Wp.Lang.F` module, supporting operations like equality and ordering. Concrete use cases include integrating custom equality and comparison functions into the logic engine and transforming terms during proof processing.",
      "description_length": 373,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo.VC_Annot",
      "library": "frama-c-wp.core",
      "description": "This module evaluates and resolves verification conditions with associated metadata, including axioms, goals, tags, warnings, dependencies, and source information. It supports checking whether a condition is trivially valid and determining if a condition matches a given property identifier. Concrete use cases include filtering and processing verification goals during static analysis and managing dependencies between properties in proof tasks.",
      "description_length": 446,
      "index": 1098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Procs",
      "library": "frama-c-wp.core",
      "description": "This component manages integer parameters with support for value modification, range constraints, and change notifications, while its child module defines a structured type `t` for procedural parameter descriptors, including operations for comparison, copying, and project membership testing. Main data types include parameter descriptors and internal state representations that enable precise handling of configuration data within the WP analysis framework. It supports use cases like configuring plugins via command-line interfaces, persisting parameter states, and synchronizing updates with kernel-level structures. Specific operations allow defining parameters with constraints, observing value changes, and ensuring consistency across different project contexts.",
      "description_length": 768,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Tactics",
      "library": "frama-c-wp.core",
      "description": "This module handles command-line parameters as string lists, offering operations for value management, list manipulation, and integration with project state. It centers on string collections enhanced with validation, aliases, and hooks for change tracking, supporting structured data persistence and dynamic configuration. Submodules extend this with named tactic categories for CLI organization, typed parameter definitions, and domain-specific extensions like tactic frameworks and serialization. Examples include validating and logging parameter changes, grouping tactics under categories like '@default', and defining rich command-line options with type-aware descriptors.",
      "description_length": 676,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Compound",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manipulate structured layouts by reshaping and embedding values within offset-based regions. It works with layout and offset data types, supporting transformations that maintain spatial relationships. Concrete use cases include adjusting layout boundaries while preserving internal structure and inserting values into specific offset positions.",
      "description_length": 379,
      "index": 1101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.Share",
      "library": "frama-c-wp.core",
      "description": "This module manages the plugin's share directory and provides operations to locate specific files or subdirectories within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring they exist and are of the expected type. Concrete use cases include retrieving configuration files or resource directories stored under the plugin's share directory.",
      "description_length": 370,
      "index": 1102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_parameters.CalleePreCond",
      "library": "frama-c-wp.core",
      "description": "This module provides a core data type for representing callee precondition parameters, enabling operations like equality, comparison, hashing, and pretty printing. It supports deep copying and querying over project-specific data to facilitate reasoning about function call preconditions during verification. Submodules extend this functionality to handle specific aspects of precondition analysis, such as constraint generation and evaluation. Together, they allow developers to inspect, manipulate, and verify preconditions in the context of function calls within the WP plugin.",
      "description_length": 579,
      "index": 1103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Overlay",
      "library": "frama-c-wp.core",
      "description": "This module manages overlay structures used to represent and manipulate layered layouts, particularly for pretty-printing and merging regions in a structured format. It provides operations to merge overlays using a custom merger function, format overlays with titles, and check if a value occurs exactly once within an overlay. Concrete use cases include rendering complex document layouts and managing hierarchical region compositions in a type-safe manner.",
      "description_length": 458,
      "index": 1104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.FctTimeout",
      "library": "frama-c-wp.core",
      "description": "This module manages timeout configurations for kernel functions using a structured key-value system with support for aliases, comparisons, and integration with Frama-C's project state. It enables setting and retrieving timeout values through direct API calls, command-line interface support, and persistent serialization, while interacting with kernel-level functions via hooks and categorized parameter groups. Child modules handle string-based parameters with validation and state tracking, named categories for organizing timeout policies, and custom data types with project-aware operations for deep copying and comparison. Examples include defining function-specific timeouts, configuring global defaults, and dynamically adjusting thresholds during proof sessions using typed, serializable parameter representations.",
      "description_length": 822,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Layout.Root",
      "library": "frama-c-wp.core",
      "description": "This module manages layout root structures used to organize and manipulate hierarchical regions in the WP plug-in. It provides operations to construct, merge, and inspect layout roots, including checking if they are indexed or framed. Concrete use cases include structuring proof obligations and managing region hierarchies during static analysis.",
      "description_length": 347,
      "index": 1106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters.SmokeDeadcode",
      "library": "frama-c-wp.core",
      "description": "This module provides state-modifying operations to toggle a boolean flag that controls smoke deadcode analysis, supporting change hooks, CLI integration, and project-specific state persistence through marshaling. It operates on a boolean option type, enabling configuration via direct assignment (`on`/`off`), default value handling, and dependency tracking, while a custom data type in its child module enables equality checks, comparison, and deep copying over project skeletons. Together, they support dynamic analysis control during plugin execution, user-facing CLI flags, and consistent state management across sessions, with concrete applications in managing and comparing analysis configurations within the WP plugin.",
      "description_length": 725,
      "index": 1107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemLoader",
      "library": "frama-c-wp.core",
      "description": "This module organizes memory models for program analysis by clustering memory definitions and enabling structured data handling through its child modules. It provides the `cluster` function for grouping memory definitions and the `Make` functor for building custom loaders, while the first child module handles loading and manipulation of compound values like structs and arrays. The second child module focuses on atomic memory operations, including pointer arithmetic and value storage, enabling precise modeling of low-level memory states. Together, they support tasks like memory layout organization, structured data initialization, and formal verification of memory operations in low-level code.",
      "description_length": 700,
      "index": 1108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacRewrite",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical and strategy for rewriting goals using built-in range operations, supporting directional application from either left or right. Operates on proof goals and selections within the WP tactical framework, enabling targeted transformation of logical expressions. Useful for automating symmetry-based or range-specific proof steps in program verification tasks.",
      "description_length": 377,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacSplit",
      "library": "frama-c-wp.core",
      "description": "This module implements a split tactical for breaking proof goals into subgoals, typically used in automated theorem proving. It operates on logical formulas and proof states, enabling case analysis and disjunction splitting. Concrete use cases include decomposing complex conditions into manageable branches during proof search.",
      "description_length": 328,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicCompiler",
      "library": "frama-c-wp.core",
      "description": "This module compiles logical expressions into verification conditions, transforming abstract syntax trees by handling negation and implication based on polarity, and generates proof obligations from program annotations during static analysis. It works with symbolic execution frames, logic variables, and environments to model function calls, manage substitutions, and integrate logic with code, particularly for memory modeling and region analysis. Key data types include `frame`, `call`, `sigma`, and `env`, supporting operations like lemma conversion, term evaluation against CIL types, and scoped variable binding. It orchestrates verification workflows while enabling direct compilation of logic formulas into SMT-friendly forms.",
      "description_length": 734,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Rformat",
      "library": "frama-c-wp.core",
      "description": "This module provides functions for formatting and printing time values with customizable output, including support for time ranges. It works with float arrays representing time intervals and a command type for structuring formatted output. Concrete use cases include logging execution times in human-readable formats and generating structured reports with time-stamped sections.",
      "description_length": 378,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemDebug",
      "library": "frama-c-wp.core",
      "description": "This module combines pretty-printing utilities with formal memory modeling capabilities to support detailed analysis and debugging of memory operations in C programs. It provides data types like `loc`, `sigma`, and `pred`, along with operations for memory manipulation, logical constraint generation, and structured debug output. You can visualize memory states, generate symbolic expressions, and validate heap transformations during formal verification. Submodules extend these capabilities with specialized functions for offset computation, value tracking, and scope management in logical proofs.",
      "description_length": 599,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cint",
      "library": "frama-c-wp.core",
      "description": "This module offers arithmetic and bitwise operations on integer types, including conversions between C and logical integers, modular arithmetic, and bit-level manipulations like shifts and masks. It operates on terms representing integer expressions and C integer types, with behavior influenced by arithmetic models (natural or machine). Its utilities simplify integer formulas, optimize bit-pattern conditions, and verify properties like non-negativity in formal verification contexts.",
      "description_length": 487,
      "index": 1114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofScript",
      "library": "frama-c-wp.core",
      "description": "The module enables constructing, serializing, and evaluating proof scripts through operations like tactic composition, prover configuration, and JSON encoding/decoding, working with structured data such as provers, tactics, and intermediate proof states. It specifically supports automating formal verification workflows by handling prover result aggregation and strategy persistence via JSON representations.",
      "description_length": 409,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.RefUsage",
      "library": "frama-c-wp.core",
      "description": "This module tracks how variables are accessed in memory, providing precise usage information such as whether a variable is used by reference, by value, or as an array. It offers operations to query and iterate over variable access patterns, check if a variable is marked as nullable, and print or dump access details for debugging. Concrete use cases include analyzing pointer usage in C functions and validating memory access safety during static analysis.",
      "description_length": 457,
      "index": 1116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CodeSemantics",
      "library": "frama-c-wp.core",
      "description": "This module evaluates and compares abstract memory values, expressions, and locations to support formal verification of C code behavior. It defines operations for checking equality, zero values, and function pointers, along with compiling terms into logical constraints over memory states (sigma), variables, and logical terms. It enables analyses such as memory initialization, variable state comparison, and constraint propagation across abstract memory models. For example, it can validate value ranges, track memory initialization status, and compare program states to detect behavioral differences.",
      "description_length": 603,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cvalues",
      "library": "frama-c-wp.core",
      "description": "This module provides tools to convert memory constructs into logical predicates and terms, verify C values and types, and transform logic and value representations in memory models. It supports data types like `Wp.Memory.equation`, `Wp.Lang.F.pred`, `Wp.Lang.F.term`, `value`, `logic`, and `region`, enabling operations such as comparison, type checking, and logic manipulation with polarity awareness. The child module extends these capabilities with arithmetic operations, memory location transformations, and region/field management, facilitating the construction and analysis of logical expressions for memory validity, separation, and inclusion. Together, they enable tasks like modeling arrays and structures, enforcing pointer/array bounds, and tracking memory initialization and volatile accesses during formal verification.",
      "description_length": 832,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Sigma",
      "library": "frama-c-wp.core",
      "description": "This module organizes uniform handling of heap chunks through core operations like `chunk`, `singleton`, `mem`, and `value`, while its submodules implement set algebra, key-based maps, and chunk property inspections. It supports precise memory modeling with typed chunks, enabling union, intersection, filtering, and ordered traversal over memory regions, and provides utilities for equality checks, comparison, and pretty-printing of chunks and their metadata. Concrete uses include static analysis of memory safety, symbolic heap manipulation, and generation of ACSL code from function parameters and chunk basenames.",
      "description_length": 619,
      "index": 1119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgInfos",
      "library": "frama-c-wp.core",
      "description": "This module analyzes control flow graphs and function behaviors, providing access to properties like unreachable code, termination dependencies, and call relationships. It works with kernel functions, control flow automata, and statement-level annotations to determine characteristics such as whether a function is a true entry point, if it is recursive, or if a statement is unreachable. Concrete use cases include verifying function call clusters, detecting doomed properties, and checking if a function body terminates trivially.",
      "description_length": 532,
      "index": 1120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.MemMemory",
      "library": "frama-c-wp.core",
      "description": "This module defines operations for modeling memory states, including allocation, initialization, and memory comparison. It works with memory types represented as `t_malloc`, `t_init`, and `t_mem`, and provides functions like `f_eqmem` for equality checks and `f_memcpy` for memory copying. Use cases include verifying memory safety properties and handling memory operations in program analysis.",
      "description_length": 394,
      "index": 1121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Mstate",
      "library": "frama-c-wp.core",
      "description": "This module manages memory states and symbolic values in a verification context, providing operations to create, update, and query memory states using terms and symbolic expressions. It works with data types such as `state`, `mval`, `term`, and `update`, supporting precise manipulation of memory models during program analysis. Concrete use cases include tracking memory modifications across program paths and evaluating symbolic expressions in a given state.",
      "description_length": 460,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Warning",
      "library": "frama-c-wp.core",
      "description": "This module manages warnings with structured severity levels, source tagging, and contextual handling, enabling precise creation, emission, and aggregation of warnings tied to source code positions. It provides core operations to construct and manipulate warnings, suppress non-critical issues, and collect proof obligations with location metadata during static analysis. The first child module offers ordered sets of warnings, supporting union, intersection, and sorted iteration, ideal for merging and deduplicating warning results. The second extends this with ordered key-value mappings, enabling efficient aggregation and transformation of warning data keyed by contextual identifiers.",
      "description_length": 690,
      "index": 1123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cache",
      "library": "frama-c-wp.core",
      "description": "This module manages caching behavior for proof results with operations to set and retrieve cache modes, track cache statistics, and control result persistence. It works with proof results from the VCS module, using digests and runners to identify and retrieve cached outcomes. Concrete use cases include replaying or rebuilding proofs under specific cache policies and cleaning up outdated or excessive cache entries.",
      "description_length": 417,
      "index": 1124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.ProverSearch",
      "library": "frama-c-wp.core",
      "description": "This module implements proof search strategies for verifying program correctness, providing operations to navigate and manipulate proof trees. It works with proof trees, nodes, and sequents to apply heuristics, backtrack through proof paths, and select proof goals based on strategies. Concrete use cases include selecting the next proof branch to explore, applying a sequence of tactics to a specific node, and searching for applicable proof rules using custom heuristics.",
      "description_length": 473,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemBytes",
      "library": "frama-c-wp.core",
      "description": "This module models memory states and manipulates pointers in formal verification tasks, supporting operations like pointer arithmetic, memory partitioning, and typed value handling. It works with memory locations, C types, and logical predicates to validate pointers, analyze heap states, and enforce memory safety during static analysis. The child module extends this by enabling symbolic memory updates, region management, and footprint computation through typed loads and stores of integers, floats, and pointers. Together, they support tasks like verifying memory transformations, checking initialization, and ensuring separation of memory regions in C program analysis.",
      "description_length": 674,
      "index": 1126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacUnfold",
      "library": "frama-c-wp.core",
      "description": "This module implements a built-in unfold tactical that expands function definitions in proof terms. It operates on logical functions and terms from the Wp.Lang module, supporting automated reasoning during proof search. The `unfold` function applies a given function definition to a list of arguments, while `tactical` and `strategy` integrate unfolding into proof automation with customizable selection and priority.",
      "description_length": 417,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Factory",
      "library": "frama-c-wp.core",
      "description": "This module defines memory and variable models for configuring the WP plugin's behavior, including heap types like Hoare, ZeroAlias, and Region, and variable types like Raw, Var, and Ref. It provides functions to configure drivers, instantiate models, and parse command-line setups to customize memory and variable handling. Concrete use cases include selecting memory models for verification tasks and setting up drivers for specific analysis backends.",
      "description_length": 453,
      "index": 1128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.NormAtLabels",
      "library": "frama-c-wp.core",
      "description": "This module manages label mappings for C statements and functions, providing operations to create and manipulate label environments for preconditions, postconditions, and assignments. It supports transformations of terms, annotations, and assigns clauses based on these mappings, specifically tailored for use with Frama-C's kernel functions and statements. Concrete use cases include normalizing logic labels in function contracts, loop invariants, and assertion annotations during static analysis.",
      "description_length": 499,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProverWhy3",
      "library": "frama-c-wp.core",
      "description": "Handles specialized equality and proof obligations in program verification. It provides functions to introduce custom equality constraints and invoke Why3-based provers with resource limits. Used to discharge verification conditions with tailored equality reasoning, such as proving equivalence of structured data or custom logic constructs.",
      "description_length": 341,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacChoice",
      "library": "frama-c-wp.core",
      "description": "This module provides tacticals for managing proof strategies through choice, contraposition, and absurdity. It supports branching logic with `tactical` and `strategy` functions, transforms goals using contrapositive reasoning, and discharges contradictions automatically. Examples include selecting between proof paths based on priority, automating proof by contradiction, and closing proof branches where a contradiction is derived.",
      "description_length": 433,
      "index": 1131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgGenerator",
      "library": "frama-c-wp.core",
      "description": "Implements functions to build and manipulate control flow graphs for program analysis tasks. It operates on abstract syntax trees and generates structured control flow representations. Useful for static analysis tools that require precise control flow information for verification or optimization purposes.",
      "description_length": 306,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCompiler",
      "library": "frama-c-wp.core",
      "description": "This module builds and analyzes control-flow graphs with explicit memory modeling, using nodes, branches, loops, and path constraints to represent program execution. It supports symbolic state transformations and memory effect tracking through combinators like concatenation and implication, enabling verification tasks such as condition generation and state transition analysis. Submodules handle relocatable conditions, predicates, terms, and effects, allowing these elements to be created, relocated, and queried across symbolic states using sigma sequences and mappings. Together, they enable precise modeling of program behavior across control flow paths, supporting tasks like verification condition generation and symbolic execution.",
      "description_length": 740,
      "index": 1133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Filtering",
      "library": "frama-c-wp.core",
      "description": "Performs predicate filtering by removing parts of logical expressions that do not satisfy a given condition. Replaces filtered sections with true or false based on the specified polarity, working directly with sequents and first-order logic predicates. Used to simplify verification conditions during proof processing by eliminating irrelevant hypotheses or goals.",
      "description_length": 364,
      "index": 1134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Repr",
      "library": "frama-c-wp.core",
      "description": "This module defines algebraic data types for representing terms, predicates, and logical operations in a formal verification context. It includes constructors for constants, variables, arithmetic operations, logical connectives, and higher-order functions, enabling precise modeling of program logic. Use cases include building and manipulating formal expressions for static analysis and theorem proving.",
      "description_length": 404,
      "index": 1135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProofStrategy",
      "library": "frama-c-wp.core",
      "description": "This module defines and manages proof strategies and their alternatives for verifying program properties. It provides operations to retrieve, name, and apply strategies, as well as extract prover configurations and tactics for use in the proof engine. Concrete use cases include selecting and executing automated proof strategies based on hints, checking locations and names of strategies, and formatting strategy and alternative representations for debugging or logging.",
      "description_length": 471,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVal",
      "library": "frama-c-wp.core",
      "description": "This module represents abstract memory values and provides operations to construct, update, and query memory states with precise value abstractions for symbolic execution. It tracks constraints and bindings for program variables, supporting operations such as pointer arithmetic, field access, array indexing, and base address computation, working with memory locations, states, and segments. The child modules extend this functionality by enabling state transformations, merging memory states at control-flow joins, generating logical predicates for verification, and mapping memory values to abstract domains during static analysis. Together, they support modeling heap and stack behavior in C programs, enabling tasks like proving memory safety, analyzing pointer manipulations, and generating symbolic representations for debugging or formal reasoning.",
      "description_length": 856,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Cstring",
      "library": "frama-c-wp.core",
      "description": "This module handles string literals and wide string literals, providing operations to access their properties and values within the WP plug-in's formal logic. It defines functions to retrieve the length, character values, and unique identifiers for string constants, as well as a cluster for string definitions. Concrete use cases include modeling string behavior in program verification and generating logical constraints for string manipulation in C code.",
      "description_length": 457,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Register",
      "library": "frama-c-wp.core",
      "description": "Processes command-line arguments to execute WP proofs using specified provers and options. It operates on a bag of WPO (Weakest Precondition Obligations) and supports optional parameters like the list of provers and whether to enable TIP (Tracing Information for Provers). This module is used during the invocation of the WP plugin to launch proof sessions directly from the command line.",
      "description_length": 388,
      "index": 1139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemZeroAlias",
      "library": "frama-c-wp.core",
      "description": "This module supports memory modeling and verification operations for analyzing C programs, focusing on pointer arithmetic, memory state transitions, and safety checks. It works with abstract memory locations (`loc`), memory states (`sigma`), and segments to handle tasks like initialization validation, allocation scoping, and logical formula generation for memory safety. Key applications include tracking variable dependencies, verifying pointer validity, and managing memory representations in formal proofs.",
      "description_length": 511,
      "index": 1140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.LogicBuiltins",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for registering and managing logic constructs, including built-in functions, types, and constructors, alongside driver-specific configurations and library dependencies. It works with logic terms, strings, and file paths to enable customizable verification workflows, supporting tasks like defining sanitization rules, overriding logic definitions, and configuring driver behavior for formal verification systems.",
      "description_length": 444,
      "index": 1141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Matrix",
      "library": "frama-c-wp.core",
      "description": "This module represents and manipulates matrices in the context of the WP plug-in, supporting operations such as matrix creation from dimensions, comparison, and pretty-printing. It works with matrices that have size and index variables, terms, and constraints, integrating with the F module for type and term representation. Concrete use cases include modeling array bounds, managing matrix dimensions in formal verification, and generating identifiers based on matrix structure.",
      "description_length": 479,
      "index": 1142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacCut",
      "library": "frama-c-wp.core",
      "description": "This module implements a tactical for applying cut operations in proof strategies, supporting two modes: CASES and MODUS. It works with proof goals and selections, enabling the splitting of a goal into subgoals or the application of modus ponens. Concrete use cases include structuring proofs by case analysis or forward reasoning steps within the WP plugin's tactic system.",
      "description_length": 374,
      "index": 1143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cmath",
      "library": "frama-c-wp.core",
      "description": "This module defines conversions between integers, real numbers, and booleans, along with mathematical functions such as absolute value, square root, and integer-to-real conversion. It operates on terms and unary operations from the Wp.Lang.F module, and provides specific functions like `f_real_of_int`, `f_iabs`, `f_rabs`, and `f_sqrt`. These are used to model mathematical expressions and type conversions within the WP plug-in's logic.",
      "description_length": 438,
      "index": 1144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProverTask",
      "library": "frama-c-wp.core",
      "description": "Handles task scheduling and execution for automated theorem proving, supporting parallel processing and result monitoring. Works with tasks, thread pools, and system processes to manage proof obligations. Used to spawn and coordinate proof attempts across multiple backends, retaining the first successful result while optionally monitoring progress.",
      "description_length": 350,
      "index": 1145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Layout",
      "library": "frama-c-wp.core",
      "description": "This module provides utilities for analyzing and transforming memory regions, offsets, and structured data layouts in C programs, working directly with CIL expressions and integer ranges to model arrays, structs, and pointers. It supports operations such as merging overlapping regions, comparing and printing memory locations, computing field offsets, and tracking layout aliases and usage. Child modules enhance this functionality with specialized tools for matrix calculations, range set manipulation, cluster management, and overlay composition, enabling tasks like symbolic execution, pointer analysis, and structured document rendering. Specific applications include verifying memory accesses, resolving field positions in structs, merging memory regions during static analysis, and formatting complex layouts for diagnostics.",
      "description_length": 832,
      "index": 1146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacHavoc",
      "library": "frama-c-wp.core",
      "description": "This module combines functionalities for managing fresh variables, introducing non-deterministic state changes, and validating havoc operations during separation logic proofs. It supports symbolic execution by tracking heap components, modifying logical states unpredictably, and ensuring variable modifications adhere to preconditions. Key data types include logical contexts, variable sets, and proof goals, with operations for variable introduction, state disruption, and precondition validation. Examples include automating memory model reasoning, simulating uncertain system transitions, and verifying soundness of state transformations in safety-critical code.",
      "description_length": 666,
      "index": 1147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Ptip",
      "library": "frama-c-wp.core",
      "description": "Handles visibility and structuring of proof terms within a focused proof session. It provides operations to fold, name, and share proof components, working with targets composed of parts and optional terms. Used to manage proof navigation, step selection, and visibility state in interactive theorem proving interfaces.",
      "description_length": 319,
      "index": 1148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacArray",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in array tactical that provides automatic tactic registration for array operations. It works with arrays and integrates selection strategies to prioritize tactic application based on given parameters. Useful for automating proof steps involving array manipulations, such as indexing, updates, and bounds reasoning.",
      "description_length": 333,
      "index": 1149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Generator",
      "library": "frama-c-wp.core",
      "description": "Generates proof obligations from program models using configurable drivers and setup parameters. It operates on abstract syntax trees and model configurations, producing generators that can be used to create and manage proof obligations. Concrete use cases include automating the generation of verification conditions for static analysis tools and supporting custom proof workflows in program verification pipelines.",
      "description_length": 416,
      "index": 1150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Prover",
      "library": "frama-c-wp.core",
      "description": "This module handles the execution and management of proof tasks for verification conditions (VCs) in the WP plugin. It provides functions to simplify, prove, and spawn proof tasks with customizable configurations, progress tracking, and result handling. Concrete use cases include automating proof attempts for VCs using specific provers, managing asynchronous proof processes, and integrating proof results into the analysis workflow.",
      "description_length": 435,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemoryContext",
      "library": "frama-c-wp.core",
      "description": "This module manages memory contexts for kernel functions, providing operations to define and manipulate parameter passing modes and memory partitions. It works with variables, kernel functions, and partition structures to track how memory is accessed or modified. Concrete use cases include setting memory parameters for function analysis, computing memory partitions for specific functions, and adding or warning about memory behaviors in function contracts.",
      "description_length": 459,
      "index": 1152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicUsage",
      "library": "frama-c-wp.core",
      "description": "This module manages logic lemmas and axiomatic sections, providing operations to retrieve, iterate, and fold over lemmas, as well as associate them with types, logic functions, and proof contexts. It works with data types such as `logic_lemma`, `axiomatic`, and `logic_section`, extracting and organizing logical components from the kernel. Concrete use cases include querying lemmas by name, determining the section of a logic element, and printing lemma profiles or full dumps for debugging and analysis.",
      "description_length": 506,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wpo",
      "library": "frama-c-wp.core",
      "description": "This module organizes and processes verification goals through structured data types like sequents, conditions, and goals, enabling operations such as validity checks, metadata retrieval, and proof term computation. It supports context-aware file path generation for storing proof obligations and integrates with submodules for managing goal hierarchies, evaluating conditions, and organizing obligations in typed collections. You can construct goals from logical sequents, track their proof status across analysis runs, and generate unique storage paths based on model and prover configurations. Submodules enhance this functionality with ordered sets and hash tables for efficient querying, caching, and dependency tracking in large-scale verification tasks.",
      "description_length": 760,
      "index": 1154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Pcond",
      "library": "frama-c-wp.core",
      "description": "This module provides functions for printing and dumping logical sequents and condition bundles in a human-readable format, supporting detailed formatting options like goal annotations and clause labeling. It works with data structures representing logical conditions, including sequents, bundles, and predicate sequences, alongside environment and pool types for managing variable allocations. Concrete use cases include debugging logical proofs, exporting verification conditions, and generating formatted output for theorem proving tasks.",
      "description_length": 540,
      "index": 1155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpContext",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates the registration and lifecycle management of verification models, organizing them within memory partitions and directories using abstract structures like indices, registries, and static entries. It supports global and function-specific context scopes, enabling precise handling of model dependencies and transient state through key-based mappings, projectified storage, and memoized registries. Concrete operations include compiling model keys into structured data, managing key-value associations with existence checks and updates, and distinguishing contexts via identifiers, hashes, and comparisons. It facilitates tasks such as caching intermediate results, resolving model dependencies, and maintaining isolated, model-specific state across static analysis workflows.",
      "description_length": 797,
      "index": 1156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Auto",
      "library": "frama-c-wp.core",
      "description": "This module coordinates automated theorem proving strategies by combining goal-directed tactics like splitting, lemma application, and contradiction handling, built around the `selection` and `strategy` types. It integrates logical predicate manipulation from `Wp.Lang.F` to structure proof steps that refine verification goals through case analysis and prioritized tactic application. The child module enhances this process by computing integer ranges over program variables, using condition-derived regions to track bounds and intervals for precise static analysis of loops and array accesses. Together, they enable automated reasoning about both logical proof structure and program behavior, supporting verification tasks through combined symbolic and numerical analysis.",
      "description_length": 774,
      "index": 1157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Lang",
      "library": "frama-c-wp.core",
      "description": "This module provides the foundational infrastructure for constructing and manipulating logic terms, predicates, and C-to-logic translations, centered around core data types like logic terms, types (`tau`), substitutions (`sigma`), and contexts (`gamma`). It supports algebraic data type manipulation, arithmetic and logical operations, and field and function representations, enabling formalization of C program semantics and generation of proof obligations. Operations include term transformation, weakest precondition calculation, and context-sensitive rewriting, with support for variable binding, type polymorphism, and structured environments. Submodules enhance these capabilities with specialized constructs such as functional sets, polymorphic maps, and built-in function handling, facilitating advanced symbolic reasoning and verification tasks.",
      "description_length": 854,
      "index": 1158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.CfgInit",
      "library": "frama-c-wp.core",
      "description": "This module handles the initialization of global variables and kernel functions within the WP plugin, ensuring proper setup for program analysis. It processes global initializers, updates the environment, and adjusts properties to reflect initialized states. Key operations include environment modification and property propagation based on initializer values. For example, it enables tracking of global variable states during verification and ensures kernel functions are correctly initialized before analysis proceeds.",
      "description_length": 520,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacModMask",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to manipulate and combine tacticals using bit mask representations of module sets. It works with `Wp.Tactical.tactical` values, applying masks to control which modules are affected by specific tactics. Concrete use cases include selectively enabling or disabling tactic application across different analysis modules in static verification workflows.",
      "description_length": 381,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Why3Provers",
      "library": "frama-c-wp.core",
      "description": "This module supports querying and managing prover configurations through operations that inspect metadata (e.g., version, capabilities) and adjust global settings (e.g., concurrency limits). It works directly with prover configuration records and a `model` type alias for concrete syntax terms, enabling use cases like verifying prover availability, enabling counterexample support, or formatting model outputs for analysis tools.",
      "description_length": 430,
      "index": 1161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Script",
      "library": "frama-c-wp.core",
      "description": "This module processes script inputs by reading and parsing tokens from a file, supporting operations like skipping whitespace, consuming specific tokens, and extracting identifiers. It works with input streams and token types, including identifiers, keywords, and proof-related constructs. Concrete use cases include parsing proof scripts, validating keyword sequences, and extracting lists of identifiers for further processing.",
      "description_length": 429,
      "index": 1162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Stats",
      "library": "frama-c-wp.core",
      "description": "This module aggregates and processes statistical data from theorem proving operations, including per-prover performance metrics and overall proof session outcomes. It supports operations to combine statistics, format output for reports, and derive proof results from aggregated data. Concrete use cases include generating performance summaries for proof sessions, evaluating prover efficiency, and integrating statistical insights into proof automation strategies.",
      "description_length": 464,
      "index": 1163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpReport",
      "library": "frama-c-wp.core",
      "description": "This module collects and exports verification statistics for functions, including total, valid, failed, and percentage of valid verification conditions. It works with function statistics data structures and supports output formatting for provers like wp, ergo, coq, z3, and simplify. Concrete use cases include generating reports in custom formats and exporting statistical results to JSON for external analysis or dashboard integration.",
      "description_length": 437,
      "index": 1164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.LogicSemantics",
      "library": "frama-c-wp.core",
      "description": "This module models function calls and memory environments using frames and logical contexts, translating CIL terms into logical expressions for formal verification. It operates on memory states (sigma), environments (env), and frames that capture function call data, enabling analysis of memory regions and logical representations of C constructs. Key tasks include validating ACSL contracts, modeling memory effects of function calls, and verifying memory assignments through logical analysis. Example uses include checking preconditions before function execution and analyzing memory impacts of pointer manipulations.",
      "description_length": 619,
      "index": 1165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpPropId",
      "library": "frama-c-wp.core",
      "description": "This module handles property identifiers across various computational contexts, such as loop establishment and preservation, enabling tracking and distinction of properties during verification. It provides the `prop_id` type along with operations for equality, comparison, hashing, and pretty-printing, supporting tasks like deep copying and project membership checks. Submodules extend these capabilities to specific verification scenarios, allowing precise property management and context-dependent analysis. Example uses include verifying loop invariants and ensuring property consistency across program transformations.",
      "description_length": 623,
      "index": 1166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Context",
      "library": "frama-c-wp.core",
      "description": "This module manages contextual values with dynamic scoping, allowing creation, binding, and modification of named values within a thread-local context. It supports operations like setting and getting values, temporary binding with `bind`, scoped updates with `update`, and stack-like context management with `push` and `pop`. Concrete use cases include managing configuration flags, temporary state during analysis, and scoped overrides in the WP plugin's evaluation process.",
      "description_length": 475,
      "index": 1167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacNormalForm",
      "library": "frama-c-wp.core",
      "description": "This module provides a tactical and strategy for normalizing terms in the context of the WP plug-in. It operates on logical expressions and proof goals, transforming them into a standard form to simplify verification. Use cases include automating proof steps in program verification and normalizing expressions during tactic application.",
      "description_length": 337,
      "index": 1168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacInstance",
      "library": "frama-c-wp.core",
      "description": "This module implements instance-based tacticals for building and applying proof strategies. It operates on selections, bindings, and logical predicates to generate new proof goals or lemmas, supporting concrete operations like filtering terms, computing instance complexity, and limiting instance cardinality. It is used to automate structured proof steps such as introducing specific lemma instances or asserting intermediate properties with selected terms.",
      "description_length": 458,
      "index": 1169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacShift",
      "library": "frama-c-wp.core",
      "description": "This module implements a shift tactical for reordering proof goals, providing a `tactical` for shifting selected goals and a `strategy` function to apply the shift with optional priority. It operates on proof goals and selections within the WP plug-in's tactical framework. Use it to prioritize or defer specific proof obligations during interactive verification sessions.",
      "description_length": 372,
      "index": 1170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacBitwised",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in tactical for bitwise equality reasoning, providing a `tactical` value for use in proof strategies. It supports bitwise comparisons over integer expressions with a configurable number of bits. The `strategy` function creates a selection-based tactic that applies bitwise equality reasoning at a specified priority level.",
      "description_length": 341,
      "index": 1171,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Wp.Plang",
      "library": "frama-c-wp.core",
      "description": "This module coordinates term and predicate allocation within a logical context, handling variable binding and domain-specific memory pools to support the construction and manipulation of logical expressions. It works with terms, predicates, and variable sets from `Wp.Lang.F`, incorporating custom formatting for integers and rationals to assist in proof generation and symbolic execution. The child module manages naming environments for pretty-printing, providing fresh name generation, identifier tracking, and term unfolding to maintain clarity during expression rendering. Together, they enable structured term manipulation alongside precise, readable output formatting.",
      "description_length": 675,
      "index": 1172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacBittest",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical and strategy for performing bit-test range analysis. Works with bitvector and integer range data types to automate proofs involving bitwise operations and value ranges. Useful for verifying properties of low-level arithmetic and bit manipulation code.",
      "description_length": 273,
      "index": 1173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemVar",
      "library": "frama-c-wp.core",
      "description": "This module manages memory variables and their symbolic representations for static analysis, combining variable tracking, memory operations, and CIL-based analysis into a unified framework. It defines core data types like `varinfo`, memory segments, and program states, supporting operations for variable initialization, access pattern analysis, and symbolic memory manipulation including address arithmetic and validity checks. You can analyze function parameters, track variable lifetimes, verify pointer safety, and generate logical predicates for memory correctness in C programs. Submodules enhance this by providing by-value access tracking, kernel-specific usage analysis, symbolic memory operations, and static CIL-based variable extraction.",
      "description_length": 749,
      "index": 1174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cfloat",
      "library": "frama-c-wp.core",
      "description": "This module models arithmetic operations, comparisons, and conversions involving 32-bit and 64-bit floating-point numbers, leveraging types like `f32`, `f64`, and `Wp.Ctypes.c_float` to formalize behavior under configurable floating-point models. It enables verification workflows by handling literal representations (e.g., `acsl_lit`), mapping logical functions to float operations (e.g., `float_of_int`), and capturing model-specific parameters like rounding modes or precision deltas for program analysis.",
      "description_length": 508,
      "index": 1175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Wp_parameters",
      "library": "frama-c-wp.core",
      "description": "This module provides configuration, logging, and diagnostic facilities for the WP plugin, managing structured data such as boolean flags, numeric parameters, string lists, and file paths. It supports fine-grained control over analysis behavior through typed, serializable parameters with change tracking, command-line integration, and project-scoped persistence. Core data types include booleans with state hooks, bounded integers with range enforcement, string sets with validation, and file path collections with dynamic updates, all supporting equality, comparison, and pretty-printing. Examples include configuring timeout policies, toggling analysis features like deadcode detection, managing prover execution, and serializing session-specific settings such as cache directories and verbosity levels. Submodules enhance these capabilities with category-based parameter grouping, structured validation, and type-safe introspection, enabling robust configuration workflows and modular analysis tuning.",
      "description_length": 1004,
      "index": 1176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacLemma",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to register, name, and retrieve lemmas for use in proof tactics. It works with lemma values wrapped in a named type and supports dynamic lemma resolution through the `find` and `search` functions. Concrete use cases include defining reusable proof lemmas and invoking them within custom proof strategies using the `tactical` and `strategy` functions.",
      "description_length": 382,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Memory",
      "library": "frama-c-wp.core",
      "description": "This module defines the foundational data types and operations for modeling memory states, transformations, and constraints in C and ACSL analysis. Core constructs include memory equations, access permissions, memory values (addresses, l-values, chunks), and memory states (`sigma`, `loc`, `segment`), which are manipulated through operations like load, store, pointer arithmetic, and validity checks. These abstractions enable precise tracking of memory updates, scope transitions, and logical assertions during static analysis, supporting tasks such as weakest precondition computation, memory footprint analysis, and function call context validation. Submodules extend this foundation to handle expression evaluation, compilation of CIL and ACSL constructs, symbolic reasoning, and formal verification of memory safety, initialization, and pointer validity across execution paths and heap regions.",
      "description_length": 900,
      "index": 1178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemEmpty",
      "library": "frama-c-wp.core",
      "description": "This module supports configuring memory models, manipulating abstract memory locations (pointers, variables, heap segments), and verifying memory states through operations like allocation, validity checks, and scope management. It operates on memory states (`sigma`), symbolic locations (`loc`), segments, and C-type representations, enabling tasks such as symbolic execution, pointer analysis, and formal verification of memory safety in C programs. Key functionalities include handling pointer arithmetic, segment inclusion/separation checks, and modeling memory transitions during program analysis.",
      "description_length": 601,
      "index": 1179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_eva",
      "library": "frama-c-wp.core",
      "description": "Performs value analysis computations and tracks the state of evaluated values during program execution. Works with CIL types, specifically kinstr and Cvalue.Model.t structures. Enables querying whether a value has been computed and retrieving its associated state at specific program points.",
      "description_length": 291,
      "index": 1180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VCS",
      "library": "frama-c-wp.core",
      "description": "This component manages prover configurations, evaluates proof results with verdicts like `Valid` or `Timeout`, and compares prover outcomes using data structures such as `Pset` and `Pmap` for tracking states. It supports operations for ordered traversal, filtering, and merging of prover data, enabling aggregation and analysis of verification outcomes across multiple provers. The persistent map and set modules allow functional updates, bulk modifications from sequences, and efficient queries like `find_first` or `find_last`, maintaining total ordering for hierarchical processing. Specific use cases include proof obligation analysis, result status tracking, and determining optimal prover strategies in safety-critical systems.",
      "description_length": 733,
      "index": 1181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Definitions",
      "library": "frama-c-wp.core",
      "description": "This module organizes logical definitions and clusters, enabling the creation, manipulation, and querying of lemmas, function definitions, and type information. It supports formal verification tasks by managing inductive definitions and logical groupings, with operations to define, print, and retrieve symbols. Child modules enhance this functionality by converting logical terms into trigger annotations, guiding proof search through variable extraction and correct referencing. Together, they facilitate precise interaction with Frama-C's logic environment, such as annotating quantified formulas for automated prover instantiation.",
      "description_length": 635,
      "index": 1182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgAnnot",
      "library": "frama-c-wp.core",
      "description": "This module normalizes annotations by renaming and reorganizing labels to support goal-based reasoning in the CfgCalculus. It processes function behaviors, loop contracts, and code assertions, extracting preconditions, postconditions, assigns clauses, and termination conditions as structured data. Concrete use cases include extracting ensures clauses for proof obligations, retrieving loop invariants for verification, and generating unreachable statement properties for analysis.",
      "description_length": 482,
      "index": 1183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.MemTyped",
      "library": "frama-c-wp.core",
      "description": "The module provides symbolic memory modeling and verification capabilities, focusing on operations for pointer arithmetic, memory state transitions, and validity checks. It manipulates abstract memory locations (`loc`), memory states (`sigma`), and segments to support formal reasoning about C-type memory layouts, including field access, array indexing, and allocation constraints. This enables use cases like proving memory safety properties, verifying initialization guarantees, and validating frame conditions in static analysis workflows.",
      "description_length": 543,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpReached",
      "library": "frama-c-wp.core",
      "description": "This module analyzes control flow reachability for smoke testing in C code, providing functions to determine if statements, annotations, or predicates are dead or unreachable. It works with CIL types such as statements, code annotations, and predicates, along with kernel functions and proposition IDs. Concrete use cases include identifying untested or unreachable assignments, returns, and function calls during static analysis.",
      "description_length": 430,
      "index": 1185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.ProofEngine",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates interactive theorem proving workflows by managing hierarchical proof structures and enabling operations to query and update proof statuses, navigate tree hierarchies, and persist proof scripts. It manipulates proof obligations, trees, and nodes with attached metadata such as tactics and validation results, while supporting node identity, comparison, and pretty-printing for tracking and managing proof steps. You can use it to perform incremental proof development, script-driven automation, and real-time status tracking during interactive sessions, with precise handling of node relationships and tree navigation. Submodules enable fine-grained control over node identity and ordering, enhancing the engine's ability to manage complex proof hierarchies.",
      "description_length": 782,
      "index": 1186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Footprint",
      "library": "frama-c-wp.core",
      "description": "This module provides operations for analyzing and manipulating term footprints in a width-first manner. It works with terms from `Wp.Lang.F` and strings, supporting concrete tasks like iterating over terms, generating head footprints, matching patterns, and locating or retrieving specific term occurrences. Use cases include identifying structural similarities between terms and navigating term hierarchies based on footprint characteristics.",
      "description_length": 443,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgWP",
      "library": "frama-c-wp.core",
      "description": "This module calculates weakest preconditions over control flow graphs to support program correctness analysis. It provides operations for traversing CFG nodes, computing preconditions for paths, and generating verification conditions that incorporate loop invariants, function contracts, and logical hypotheses. The core functionality works with structured program states, logical propositions, and control-flow constructs to enable automated reasoning about software correctness. It integrates with submodules that manage logical environments, translate program paths into verification conditions, and apply axioms or lemmas during analysis.",
      "description_length": 642,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCompound",
      "library": "frama-c-wp.core",
      "description": "This module implements a compound tactical that combines multiple proof strategies for automated tactic application. It operates on proof goals using selection mechanisms and strategy prioritization to guide the proof search process. Use it to define complex proof automation that applies different tactics based on goal characteristics.",
      "description_length": 337,
      "index": 1189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpTarget",
      "library": "frama-c-wp.core",
      "description": "This module identifies and processes kernel functions subject to verification based on command-line options, including function behavior and property filters. It operates on kernel functions and their callees, managing sets of these functions to determine verification targets. Concrete use cases include computing verification targets for specific functions, iterating over all selected functions, and retrieving function call dependencies for analysis.",
      "description_length": 454,
      "index": 1190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.AssignsCompleteness",
      "library": "frama-c-wp.core",
      "description": "This module checks the precision of assigns specifications for functions to ensure they are sufficient for memory model hypothesis computation. It provides operations to compute completeness, verify if a function's assigns are complete, and issue warnings for incomplete specifications. Use cases include validating function contracts during static analysis to avoid imprecise memory modeling.",
      "description_length": 393,
      "index": 1191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Tactical",
      "library": "frama-c-wp.core",
      "description": "This module combines logical clause manipulation and tactical configuration with a structured map for managing typed tactical fields. It supports constructing and analyzing proofs through operations on sequents and logical terms, while the child module enables storing and retrieving typed values like tactic parameters or state. You can automate proof steps conditionally, customize tactic behavior dynamically, and extend tactic libraries with structured field-based data. Example tasks include configuring a tactic's behavior via UI components and tracking per-tactical state during iterative proof automation.",
      "description_length": 613,
      "index": 1192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacBitrange",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical and strategy for handling bit range operations in proof automation. Works with bitvector and integer types to simplify reasoning over bitwise constraints. Useful for verifying low-level arithmetic and bit manipulation in programs.",
      "description_length": 252,
      "index": 1193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Passive",
      "library": "frama-c-wp.core",
      "description": "This module manages passive forms, which represent symbolic constraints and variable relationships in formal verification tasks. It supports operations like union, binding, and joining of variables, along with applying and extracting predicates based on these relationships. Use cases include tracking variable equivalences and constraints during proof generation or symbolic execution.",
      "description_length": 386,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacOverflow",
      "library": "frama-c-wp.core",
      "description": "Implements a tactic that handles integer overflow checks in proofs. Works with integer arithmetic expressions and overflow conditions. Useful for verifying safety properties in low-level code where overflow behavior must be explicitly managed.",
      "description_length": 243,
      "index": 1195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.ProverScript",
      "library": "frama-c-wp.core",
      "description": "This module orchestrates proof exploration and prover execution within the WP plug-in. It provides operations to spawn and manage proof tasks, control search depth and strategy, and handle results through callbacks for progress, success, and detailed outcomes. It works directly with proof trees, nodes, and prover configurations to automate and customize proof attempts in program verification workflows.",
      "description_length": 405,
      "index": 1196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Letify",
      "library": "frama-c-wp.core",
      "description": "This module manages substitutions and definitions for logical variables in the context of the WP plug-in, enabling the binding of variables to definitions and the integration of these definitions into logical predicates. It supports refining function contracts with let-bound variables and simplifying proof obligations through variable substitution. The core operations manipulate definitions, substitutions, environments, and occurrence counters, working with logical terms and predicates from `Wp.Lang.F`. For example, it can eliminate redundant variables in logical expressions, apply substitutions to simplify formulas, manage branching contexts during proof search, or prioritize case splits based on predicate frequency.",
      "description_length": 727,
      "index": 1197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacClear",
      "library": "frama-c-wp.core",
      "description": "Implements a tactical for clearing hypotheses within a specified range in proof scripts. Works with proof contexts containing bound variables and hypotheses. Useful for automating hypothesis management in interactive theorem proving.",
      "description_length": 233,
      "index": 1198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacFilter",
      "library": "frama-c-wp.core",
      "description": "This module implements a built-in filtering tactic that allows conditional application of proof strategies based on goal properties. It provides a tactical that wraps filtering logic and a function to create parameterized strategies with optional priority and anti-filtering behavior. Concrete use cases include selectively applying simplification or decision procedures only to goals matching specific criteria, such as arithmetic constraints or term structure.",
      "description_length": 462,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Strategy",
      "library": "frama-c-wp.core",
      "description": "This module implements selection and occurrence-checking operations for terms and predicates within a logical sequent, using functions like `occurs_x`, `occurs_y`, and `select_e`. It defines strategy structures that combine tactics, selections, and arguments, supporting registration and lookup of named strategies. Concrete use cases include guiding proof search by selecting subterms or predicates and constructing parameterized tactics for automated reasoning.",
      "description_length": 463,
      "index": 1200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Cleaning",
      "library": "frama-c-wp.core",
      "description": "This module tracks and transforms logical expressions related to memory model operations. It works with predicates and terms from the Wp.Lang.F module, applying filters and annotations to represent memory states and constraints. Concrete use cases include modeling memory effects in function contracts and simplifying logical obligations during proof generation.",
      "description_length": 362,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Driver",
      "library": "frama-c-wp.core",
      "description": "Implements operations for initializing and managing proof drivers used in the WP plugin. It provides functions to load and configure drivers based on current WP settings, ensuring they are correctly set up for use with the logic builtins. This module is used when setting up the environment for proof generation and verification tasks.",
      "description_length": 335,
      "index": 1202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCompute",
      "library": "frama-c-wp.core",
      "description": "This module provides a built-in compute tactical and strategy for automated reasoning in the WP plugin. It supports operations for tactic application and selection strategies, working with logical goals and proof states. Concrete use cases include automating proof steps during interactive verification and guiding proof search based on configurable priorities.",
      "description_length": 361,
      "index": 1203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacRange",
      "library": "frama-c-wp.core",
      "description": "This module defines a tactical for specifying and applying range-based strategies in the WP plug-in. It provides fields `vmin` and `vmax` to set integer bounds and a `strategy` function to create a strategy with a selection and priority. It is used to control the application of tactics within specified numeric ranges, such as limiting proof attempts or value iterations.",
      "description_length": 372,
      "index": 1204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Pcfg",
      "library": "frama-c-wp.core",
      "description": "This module manages a program control flow graph representation, providing operations to register conditions, track value states at specific program points, and navigate predecessor and successor labels. It works with terms, memory locations, and control flow labels to model program execution paths and data dependencies. Concrete use cases include analyzing variable visibility, tracking memory updates across control flow edges, and identifying branching points in the program logic.",
      "description_length": 486,
      "index": 1205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.LogicAssigns",
      "library": "frama-c-wp.core",
      "description": "This module analyzes memory domains and assignment logic to reason about memory regions and their transformations across program states. It provides data types for memory locations, regions, and predicates that capture the effects of assignments on memory, enabling precise tracking of initial and final memory states. Operations include evaluating memory transformations and generating logical constraints that relate pointer manipulations and mutable data structure updates. For example, it can verify memory safety properties by modeling how assignments affect heap regions and ensuring no dangling pointers or memory leaks occur.",
      "description_length": 633,
      "index": 1206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.TacInduction",
      "library": "frama-c-wp.core",
      "description": "Implements a built-in range tactical that automatically registers with the WP plugin. It provides a `tactical` value of type `Wp.Tactical.tactical`, enabling proof strategies that operate on ranges of values or intervals. This supports automated reasoning over bounded domains, such as numeric ranges or enumerated types, within the WP framework.",
      "description_length": 346,
      "index": 1207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.VC",
      "library": "frama-c-wp.core",
      "description": "This module provides operations to generate, query, and manage formal proof obligations for program verification, focusing on structured access to metadata, validity checks, and prover integration. It primarily handles verification conditions (VCs) represented as `Wp.VC.t`, associated properties (`Frama_c_kernel.Property.t`), and prover contexts, enabling tasks like validity assessment, proof generation, and result tracking. Key use cases include validating software correctness properties through automated theorem proving, managing proof tasks in a scheduler for asynchronous verification, and analyzing C code safety via Frama-C's WP plugin.",
      "description_length": 648,
      "index": 1208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.WpTac",
      "library": "frama-c-wp.core",
      "description": "This module provides term manipulation operations for converting and analyzing logical expressions in the context of tacticals. It includes functions to transform terms into conjunctive (CNF) or disjunctive (DNF) normal forms, check if a term is in CNF or DNF, and apply logical equivalences such as `iff`, `xor`, and `ite` during term rewriting. These operations are used to simplify and normalize logical conditions during proof automation and symbolic reasoning tasks.",
      "description_length": 471,
      "index": 1209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.ProofSession",
      "library": "frama-c-wp.core",
      "description": "Manages proof scripts for verification tasks, handling their creation, storage, and removal based on the current mode. Works with proof obligations (`Wpo.t`) and file paths, supporting operations like loading, saving, and marking proof files. Used to control proof session behavior, such as batch processing or initialization, and to interact with proof scripts in JSON format.",
      "description_length": 377,
      "index": 1210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgDump",
      "library": "frama-c-wp.core",
      "description": "This module enables constructing and manipulating logical propositions (`t_prop`) and environment states (`t_env`) within control flow graphs and CIL-based logic structures. It supports tasks like generating proof obligations, defining preconditions and postconditions, and verifying loop termination and function behavior through operations on statements, expressions, and kernel functions. These capabilities facilitate formal verification processes such as weakest precondition generation and ensuring code correctness against functional dependencies and verification conditions.",
      "description_length": 582,
      "index": 1211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacCongruence",
      "library": "frama-c-wp.core",
      "description": "This module provides a built-in tactical and strategy for handling product and division comparisons in proof automation. It works with logical expressions involving multiplication and division, enabling automated reasoning about arithmetic equivalences. Concrete use cases include simplifying and solving goals involving multiplicative relationships in formal verification tasks.",
      "description_length": 379,
      "index": 1212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Ctypes",
      "library": "frama-c-wp.core",
      "description": "This module represents C objects and their type information within the WP framework, enabling manipulation and introspection during symbolic execution and proof tasks. It defines core operations for equality, comparison, hashing, and pretty printing, and supports deep copying, type metadata access, and project membership checks. Submodule functionality extends these capabilities to array metadata, enabling comparison and canonicalization of array type descriptors for optimization and analysis. Examples include detecting duplicate array types, comparing C structures for equivalence, and pretty printing complex C data during debugging or proof generation.",
      "description_length": 661,
      "index": 1213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.CfgCalculus",
      "library": "frama-c-wp.core",
      "description": "This module performs symbolic evaluation and constraint generation over control-flow graphs, translating program paths into logical formulas for static analysis. It supports operations on control-flow graphs and function behaviors, enabling the computation of preconditions, postconditions, and assertion verification through verification conditions. The child module extends this by enabling symbolic computation on logical propositions, allowing manipulation of Wp's internal syntax trees and constraint sets. Together, they provide a foundation for building custom proof strategies and analyzing program logic with precise control over both structural and logical representations.",
      "description_length": 683,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.StmtSemantics",
      "library": "frama-c-wp.core",
      "description": "This module provides precise modeling of program statement semantics through control flow graph manipulation and environment transformations. It supports operations on CFG nodes, logical proof goals, and program state transitions to handle control flow merges, function calls, memory updates, and specification enforcement. Key data types include CFG structures, program states, and proof obligations, enabling formal verification tasks such as tracking initialization sequences, managing assumptions, and verifying return and assignment behavior. Example uses include analyzing function call effects, enforcing memory safety, and validating control flow integrity in program verification.",
      "description_length": 689,
      "index": 1215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Clabels",
      "library": "frama-c-wp.core",
      "description": "This module represents normalized C-labels with structural equality and comparison, providing constants like `here` and `loopentry` for labeling C program structures. It supports conversions between C statements and labels, along with context-aware operations such as `loop_current` for tracking iterative contexts, enabling precise verification tasks like loop invariant checks. The associated `LabelMap` and `LabelSet` modules offer ordered maps and sets over labels, supporting efficient insertion, traversal, and transformation for managing label associations and aggregations during symbolic execution. These structures maintain compatibility with standard comparison and equality, facilitating ordered queries and structural manipulations in formal verification workflows.",
      "description_length": 778,
      "index": 1216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.Conditions",
      "library": "frama-c-wp.core",
      "description": "The module supports constructing, transforming, and simplifying logical proof structures through operations like quantifier introduction, conjunction-based combination of proof sequences, and step-level modifications with metadata. It works with formal verification artifacts such as `sequent` (representing proof tasks), `step` (atomic proof actions), and `bundle` (structured logical conditions), alongside memory states and predicates. These tools enable use cases like optimizing proof strategies via simplifier pipelines, analyzing variable dependencies in sequents, and restructuring proof tasks through assumption insertion or domain-specific transformations.",
      "description_length": 666,
      "index": 1217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp.WpRTE",
      "library": "frama-c-wp.core",
      "description": "Implements run-time exception (RTE) handling logic, providing functions to generate missing annotations for specified functions and models, check if annotations are needed, and process all selected functions in bulk. Operates on `Wp.WpContext.model` and `Frama_c_kernel.Kernel_function.t` types. Used to automate the insertion of safety checks and assertions during static analysis to prevent undefined behavior in C code.",
      "description_length": 422,
      "index": 1218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.Wp_error",
      "library": "frama-c-wp.core",
      "description": "This module defines error-handling functions for unsupported or unimplemented features within the API, allowing formatted error messages with optional model-specific context. It works with string lists, format strings, and custom data types like `logic_label` and `assigns` to produce diagnostic output. Concrete use cases include signaling incomplete implementations and unsupported operations during static analysis.",
      "description_length": 418,
      "index": 1219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Wp.TacSequence",
      "library": "frama-c-wp.core",
      "description": "Implements a sequence tactical that applies a list of tactics in order, each to the full set of proof goals. Works with lists of tacticals and the standard proof goal structures used in the WP plugin. Useful for composing multi-step proof strategies where each tactic must run to completion before the next begins.",
      "description_length": 314,
      "index": 1220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Wp",
      "library": "frama-c-wp.core",
      "description": "This module provides a comprehensive framework for formal verification of C programs, centered around memory modeling, logical reasoning, and proof automation. It supports structured memory operations through types like `sigma`, `loc`, and `chunk`, enabling precise analysis of pointers, arrays, and memory states. Logical expressions are compiled into verification conditions and manipulated using tactics for rewriting, splitting, normalization, and constraint generation, facilitating automated proof strategies. Users can perform tasks such as verifying memory safety, proving program correctness, analyzing control flow, and generating proof obligations with support for arithmetic, bitwise, and symbolic reasoning.",
      "description_length": 720,
      "index": 1221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl.Make",
      "library": "frama-c-impact.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing with project functions, and integrates structural descriptions for type representation. Concrete use cases include managing collections of project-specific data with efficient lookups and ensuring type-safe serialization within analysis plugins.",
      "description_length": 454,
      "index": 1222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Map.Make",
      "library": "frama-c-impact.core",
      "description": "This module creates a map structure specialized for a given data type, enabling operations like equality checks, comparison, hashing, and pretty printing. It supports maps where keys are tied to a specific value type and provides deep copy functionality to avoid shared references. Concrete use cases include managing and comparing structured analysis data in static analysis tools, where precise type handling and value representation are critical.",
      "description_length": 449,
      "index": 1223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Annot.As_string.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a datatype for handling string-based command-line annotations with operations for equality, comparison, hashing, and pretty-printing. It supports working with representable values through a list of representants and provides deep copying and project membership checks. Concrete use cases include managing and validating string parameters in Frama-C's option parsing system, particularly for annotations tied to project analysis.",
      "description_length": 448,
      "index": 1224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl.Key",
      "library": "frama-c-impact.core",
      "description": "This module defines a key type for a hash table that supports operations such as equality checking, comparison, hashing, and pretty printing on keys. It works with a specific key type that may contain embedded project data, enabling filtering via project membership tests. The module is used to manage and manipulate keys in a hash table structure, particularly when tracking dependencies or mappings tied to specific project elements in static analysis contexts.",
      "description_length": 463,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.As_string.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a datatype for handling string parameters in a command-line interface, where each value represents a string that skips certain options. It provides standard operations like equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copying. Use cases include parsing and managing command-line arguments that involve string-based options with skipping behavior.",
      "description_length": 433,
      "index": 1226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Map.Key",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports working with a structured descriptor and includes functions for checking membership based on project properties and performing deep copies. Concrete use cases include managing and comparing unique key values in a map, filtering keys based on project metadata, and ensuring proper serialization and representation.",
      "description_length": 475,
      "index": 1227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Skip.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, working with a custom type `t` that represents command-line parameters. It includes functions for checking membership based on project properties, deep copying values, and exposing type and descriptor information. Concrete use cases include managing and comparing parameter values in a command-line interface, ensuring correct type behavior during parsing and execution.",
      "description_length": 473,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Set",
      "library": "frama-c-impact.core",
      "description": "This module implements ordered set operations for elements representing analysis reasons, using a balanced tree structure to ensure efficient membership checks, ordered traversal, and transformation. It supports set algebra (union, intersection, difference), sequence conversion (forward/reverse iteration, bulk insertion), and specialized queries for nearest elements or project-specific membership. Typical use cases include tracking dependencies in program analysis, grouping related reasons, and efficiently maintaining sorted collections during iterative transformations.",
      "description_length": 576,
      "index": 1229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Map",
      "library": "frama-c-impact.core",
      "description": "This module organizes a family of components for building and manipulating maps with rich key behavior, integrating key definition, comparison, and structured value handling into a unified framework. It centers around map and key data types with operations for equality, comparison, hashing, and pretty printing, while supporting deep copying to prevent reference sharing. You can create maps keyed by custom types, compare and serialize them, or filter entries based on key metadata, enabling precise management of structured data in analysis tools. Submodules refine key and map implementations, extending functionality for specific use cases involving type-safe lookups, structured descriptors, and project-based filtering.",
      "description_length": 726,
      "index": 1230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.As_string",
      "library": "frama-c-impact.core",
      "description": "This module manages string-based command-line parameters with validation, update hooks, and state tracking across global contexts. It defines a core type for string parameters that supports operations like equality, comparison, hashing, and pretty printing, while also enabling project membership checks and deep copying. Child modules extend this functionality to handle string options with skipping behavior, allowing for dynamic CLI configurations that enforce allowed values and maintain synchronized state across different execution contexts. Examples include validating user input against predefined string sets, persisting parameter changes between sessions, and conditionally skipping options based on project membership.",
      "description_length": 729,
      "index": 1231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.Reason.Hashtbl",
      "library": "frama-c-impact.core",
      "description": "This module provides hash tables keyed by structured reason values, supporting insertion, lookup, in-place updates, and ordered traversal, with utilities for memoization, sequence conversion, and safe value access using defaults. Its first child module specializes these tables for `Data.t` values, adding deep copying, equality, and project-aware membership checks, enabling efficient management of type-safe, structured data collections. The second child module defines a rich key type with embedded project context, supporting key-based filtering and comparison, ideal for tracking dependencies and mappings in static analysis workflows. Together, they form a system for high-performance, structured key-value storage with deep integration into project-specific type systems and analysis pipelines.",
      "description_length": 801,
      "index": 1232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Slicing.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` and associated operations for representing and manipulating abstract data values in the context of program slicing. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying, as well as utilities for inspecting and querying project-specific data embedded within the structures. These capabilities support precise dataflow analysis and transformation tasks in static analysis workflows.",
      "description_length": 461,
      "index": 1233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Debug.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use with Frama-C's kernel structures. It includes descriptors and representants for structural inspection, and supports deep copying and project membership checks. Concrete use cases include managing and comparing complex datatype instances within Frama-C's analysis framework.",
      "description_length": 405,
      "index": 1234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Verbose.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` with operations for type representation, comparison, hashing, and pretty-printing, tailored for use with Frama-C's kernel structures. It provides a type `t Frama_c_kernel.Type.t`, a descriptor, and a packed descriptor for runtime type information, along with utilities for deep copying, project membership checks, and structural equality. Concrete use cases include managing and querying complex datatype representations in Frama-C plugins, especially during static analysis where type identity and structure are critical.",
      "description_length": 565,
      "index": 1235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Reason.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a polymorphic type `t` and associated operations for representing and manipulating abstract data values with support for equality, comparison, hashing, and pretty-printing. It includes functions for checking membership within project structures, deep copying values, and working with type descriptors and representations. Concrete use cases include building and analyzing semantic graphs for impact analysis in static code analysis workflows.",
      "description_length": 462,
      "index": 1236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Print.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type with operations for representing, comparing, and printing structured values used in static analysis output. It supports concrete data manipulation including deep copying, equality checks, hashing, and pretty-printing, tailored for use in Frama-C's analysis reporting. The type is integrated with Frama-C's kernel structures to enable project-aware filtering and structured serialization.",
      "description_length": 419,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip.Category",
      "library": "frama-c-impact.core",
      "description": "This module manages categories for command-line parameter collections, providing operations to define, enable, and modify categories such as '@none', '@default', and '@all'. It works with parameter categories and state lists to control how variables are skipped during analysis. Use cases include configuring default skipping behavior, enabling all parameters with specific interpretations, and creating custom categories with dependencies.",
      "description_length": 440,
      "index": 1238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.Category",
      "library": "frama-c-impact.core",
      "description": "This module manages categories for command-line parameter collections, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with parameter categories using the `elt` type from `Impact.Options.Annot` and the `Parameter_category.t` structure. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a specific interpretation, and defining dependencies for category activation.",
      "description_length": 474,
      "index": 1239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.As_string",
      "library": "frama-c-impact.core",
      "description": "This module manages string command-line options with support for validation, hooks, and custom serialization, operating on string values with constraints. It integrates with project state systems to handle dynamic behavior, enabling tasks like validating input against predefined values or triggering actions on state changes. The child module enhances this functionality by providing structured handling of string annotations with equality, comparison, and pretty-printing, supporting deep copies and project membership checks. Together, they enable robust, extensible management of string parameters in complex analysis workflows.",
      "description_length": 632,
      "index": 1240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Upward.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in static analysis within the Frama-C framework. It supports deep copying and provides functionality to check membership based on project properties, enabling precise impact analysis across codebases. The type is used to represent and manipulate analysis states that propagate upward through function calls.",
      "description_length": 441,
      "index": 1241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot.Datatype",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling annotated data structures in the context of Frama-C's kernel. It includes functions for checking membership within projects, creating deep copies, and working with type descriptors and representations. The module is used to manage and manipulate annotated values in static analysis tools built on the Frama-C platform.",
      "description_length": 457,
      "index": 1242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Skip",
      "library": "frama-c-impact.core",
      "description": "This module organizes command-line parameters with support for dynamic configuration, validation, and state synchronization across contexts. It defines core data types for parameters, including string-based options with skipping behavior, and provides operations for equality, comparison, hashing, and type inspection. Child modules extend this with project-specific membership checks, deep copying, and category management to control skipping behavior during analysis. Examples include validating input against allowed values, persisting parameter state between sessions, and defining custom parameter categories to manage default or global behavior.",
      "description_length": 651,
      "index": 1243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Pdg_aux.NS",
      "library": "frama-c-impact.core",
      "description": "This module implements a specialized set abstraction for managing associations between nodes and zones, where each node is uniquely represented with its merged zone values. It supports set-theoretic operations like union and intersection alongside zone-aware folding, ensuring nodes are always paired with non-empty, maximally merged zones. The structure is particularly useful in static analysis contexts where tracking aggregated zone information per node is critical, such as merging control-flow or data dependencies.",
      "description_length": 521,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Cache_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 389,
      "index": 1245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph.Reason",
      "library": "frama-c-impact.core",
      "description": "This module represents relationships between nodes in a graph using a triple structure composed of two nodes and a reason type, supporting equality, comparison, hashing, and pretty-printing. It enables operations like checking project membership, deep copying, and managing collections of triples through sets, maps, and hash tables, facilitating precise analysis and transformation in program analysis workflows. The set submodule provides ordered set operations over reason elements with efficient membership checks and traversal, while the map submodule supports structured key-value mappings with custom key behavior and deep copying. Hash tables keyed by reason values allow for memoization, in-place updates, and safe value access, with specialized variants for project-aware data management and key-based filtering in static analysis tasks.",
      "description_length": 847,
      "index": 1246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Slicing",
      "library": "frama-c-impact.core",
      "description": "This module manages a global boolean state that controls slicing behavior, allowing users to enable or disable slicing from impacted statements during static analysis. It supports dynamic configuration through hooks, aliases, and customizable serialization, integrating directly with Frama-C's state system. The child module defines a polymorphic type `t` with operations for manipulation, comparison, and project-specific data inspection, enabling precise dataflow analysis. Together, they support advanced slicing workflows, such as conditionally applying slicing rules or analyzing data dependencies across program versions.",
      "description_length": 627,
      "index": 1247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Share",
      "library": "frama-c-impact.core",
      "description": "This module manages the configuration and retrieval of the plugin's site directory, providing functions to set, get, and check the directory path. It works with file paths represented as `Frama_c_kernel.Filepath.t` and ensures correct resolution of subdirectories and files within the site. Concrete use cases include locating plugin-specific resources like configuration files or shared libraries stored in the site directory.",
      "description_length": 427,
      "index": 1248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Print",
      "library": "frama-c-impact.core",
      "description": "This module controls dynamic printing of impacted statements through a toggleable boolean flag, integrated with command-line configuration and serialization for persistent state management. It defines a structured data type for representing analysis values with operations for comparison, deep copying, hashing, and pretty-printing, enabling precise and customizable output. The module supports conditional logging during analysis, interactive verbose output, and structured reporting aligned with Frama-C's kernel for project-aware filtering and serialization. Submodule functionality extends data manipulation and type integration, enhancing output fidelity in analysis tools.",
      "description_length": 678,
      "index": 1249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.DatatypeReason",
      "library": "frama-c-impact.core",
      "description": "This module defines a data type and operations for handling reasoning elements in a graph structure, specifically supporting equality, comparison, hashing, and pretty-printing. It works with a custom type `t` representing reasons, along with lists of such reasons and project-based filtering through `mem_project`. Concrete use cases include managing and analyzing dependencies or causality links in a static analysis context, where deep copies and structural comparisons of reason graphs are needed.",
      "description_length": 500,
      "index": 1250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Debug",
      "library": "frama-c-impact.core",
      "description": "This module manages configurable integer parameters with bounded ranges, supporting dynamic updates via callbacks, command-line interaction, and integration with state management systems. It provides core operations for range validation, incremental adjustments, and visibility-controlled marshaling, while its child module extends functionality with a polymorphic type `t` that enables equality checks, comparison, hashing, and pretty-printing, particularly for Frama-C kernel structures. Together, they support use cases such as runtime configuration tuning, interactive debugging tools, and managing complex datatype instances within analysis frameworks. Specific features include deep copying, project membership checks, and structural inspection for robust state and value tracking.",
      "description_length": 787,
      "index": 1251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Config_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages the plugin's configuration directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the user-specific directory. Concrete use cases include storing plugin-specific settings, caching analysis results, or managing per-user configuration files without relying on global or temporary paths.",
      "description_length": 452,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Upward",
      "library": "frama-c-impact.core",
      "description": "This module manages boolean options with support for setting, retrieving, and monitoring value changes through hooks, integrating with command-line interfaces and maintaining default values for tools like Frama-C. It defines a boolean type `t` that supports project-specific state management and tracks changes across function calls for impact analysis. The child module extends this by providing equality, comparison, and pretty-printing operations tailored for static analysis, enabling precise propagation of analysis states upward through codebases. Together, they allow configuring analysis tools dynamically while tracking and inspecting state changes across projects.",
      "description_length": 674,
      "index": 1253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Reason",
      "library": "frama-c-impact.core",
      "description": "This module manages boolean state with change hooks and serialization, controlling node inclusion and explanation details in impact graphs through mutable flags. It provides `on` and `off` operations to toggle state programmatically, integrates with CLI for external control, and tracks changes to influence graph construction. Submodules extend its functionality by defining a polymorphic type `t` for abstract data representation, supporting equality, comparison, and pretty-printing, enabling semantic graph analysis. Together, they facilitate dynamic filtering and detailed reasoning during static analysis, such as including or excluding specific nodes or explanation paths based on active flags.",
      "description_length": 701,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Annot",
      "library": "frama-c-impact.core",
      "description": "This module manages command-line options with impact annotations, supporting value assignment, update hooks, alias resolution, and serialization controls, while integrating set-like operations for kernel function collections. It provides structured types for annotated options and parameter categories, enabling stateful parameter handling in developer tools and build systems with impact tracking and project-specific configuration. Child modules enhance this functionality by managing parameter categories, validating string options with hooks, and defining annotated data structures with equality, comparison, and project membership checks. Specific uses include enabling all parameters under a category, validating input values dynamically, and serializing annotated data for static analysis workflows.",
      "description_length": 806,
      "index": 1255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Reason_graph.ReasonType",
      "library": "frama-c-impact.core",
      "description": "This module defines and manipulates a specific data type `t` representing reason types in a graph structure. It provides operations for equality checks, comparison, hashing, pretty printing, deep copying, and project membership testing within the context of a static analysis framework. The type is used to represent and reason about different categories of analysis results, such as warnings or dependencies, in a structured and type-safe manner.",
      "description_length": 447,
      "index": 1256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Options.Verbose",
      "library": "frama-c-impact.core",
      "description": "This module manages verbosity levels using integers with constrained manipulation, allowing operations like increment, bounding, and synchronization of states. It integrates with Frama-C's state system for dynamic logging control, command-line configuration, and serialization of settings. The polymorphic type `t` supports rich type operations including comparison, hashing, and pretty-printing, tailored for Frama-C kernel structures. It enables deep copying, project membership checks, and structural equality, facilitating precise type representation and querying in static analysis plugins.",
      "description_length": 595,
      "index": 1257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.State_dir",
      "library": "frama-c-impact.core",
      "description": "This module manages a specific state directory for a plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the state directory structure. Use cases include storing and retrieving plugin-specific data files or configuration in a structured manner.",
      "description_length": 392,
      "index": 1258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options.Session",
      "library": "frama-c-impact.core",
      "description": "This module manages the creation, retrieval, and configuration of session directories and files within a plugin's environment. It provides direct access to directory and file paths via `get_dir`, `get_file`, and `get`, with optional path creation, and allows setting a custom session directory with `set`. It is used to handle persistent storage locations for plugin-specific data during analysis sessions.",
      "description_length": 406,
      "index": 1259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Pdg_aux",
      "library": "frama-c-impact.core",
      "description": "This module provides functions to analyze and retrieve input and output nodes in a program dependency graph (PDG) for specific function calls, working with PDG nodes, function call statements, and namespaces to map data dependencies between caller and callee functions. Its child module implements a specialized set abstraction for managing associations between nodes and zones, supporting set-theoretic operations and zone-aware folding to ensure nodes are paired with maximally merged zones. Together, they enable precise tracking of data and control-flow dependencies by combining high-level PDG analysis with low-level zone-based set manipulations. Examples include identifying which nodes in a caller define inputs for a callee and determining which nodes in a callee produce outputs used by the caller, using zone-aware sets to aggregate and merge dependency information.",
      "description_length": 877,
      "index": 1260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Compute_impact",
      "library": "frama-c-impact.core",
      "description": "This module computes the impact of statements or nodes within a function, determining which parts of the code are affected by changes. It operates on control flow nodes and statements, producing mappings of impacted nodes or statements along with optional reason graphs. Concrete use cases include analyzing the effect of modifying specific code elements, such as tracking how a change in one statement propagates through the function's control flow graph.",
      "description_length": 456,
      "index": 1261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Impact.Reason_graph",
      "library": "frama-c-impact.core",
      "description": "This module represents and manipulates graph structures that model relationships between program elements using typed edges, enabling analysis of intra- and inter-procedural effects. It provides core data types such as `t` for reason nodes, triples for structured relationships, and supporting collections like sets, maps, and hash tables for efficient querying and transformation. Operations include equality, comparison, deep copying, and project-based filtering via `mem_project`, supporting tasks like impact analysis, slicing, and dependency tracking in static analysis. Submodules extend functionality with ordered sets for efficient membership checks, key-value maps for structured data association, and hash tables for memoization and in-place updates keyed by reason values.",
      "description_length": 783,
      "index": 1262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Options",
      "library": "frama-c-impact.core",
      "description": "This module orchestrates logging, diagnostics, and configuration management for Frama-C plugins and the kernel, integrating structured data types like logging levels, verbosity controls, and categorized warnings with dynamic state handling. It supports command-line option parsing, impact tracking, and stateful parameter management through submodules that handle file paths, integer ranges, boolean flags, and cache directories. Specific capabilities include conditional debugging via toggleable flags, persistent storage of analysis results in session directories, and validation of command-line inputs with dynamic hooks. Together, the module and its children enable customizable output behaviors, interactive analysis tools, and robust state synchronization across plugin and kernel contexts.",
      "description_length": 796,
      "index": 1263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact.Register",
      "library": "frama-c-impact.core",
      "description": "This module computes impact analysis results based on program annotations or specific statements and PDG nodes. It processes CIL statements and PDG node sets to determine impact propagation, supporting slicing and filtering based on analysis parameters. Use cases include identifying affected code regions after a change, analyzing dependencies from specific nodes, and generating sliced output for targeted program analysis.",
      "description_length": 425,
      "index": 1264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact",
      "library": "frama-c-impact.core",
      "description": "This module analyzes program dependencies and impact propagation across function calls and control flow structures, combining PDG traversal, zone-aware set operations, and graph-based reasoning. It provides core data types like PDG nodes, control flow statements, and reason graphs, with operations to map inputs and outputs between callers and callees, compute impacted code regions, and manipulate structured relationships using typed edges and collections. Examples include tracking how a function's modification affects downstream nodes, merging data dependencies with zone-aware sets, and slicing code based on annotated statements or PDG elements. It also integrates logging, configuration, and session management to support dynamic analysis and plugin interaction.",
      "description_length": 771,
      "index": 1265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact_gui.Register_gui",
      "library": "frama-c-impact.gui",
      "description": "This module extends the graphical user interface to integrate functionality specific to the impact plugin. It enhances existing GUI components with additional controls and visualizations tailored for plugin operations. Concrete use cases include displaying impact analysis results and enabling user interaction with plugin-specific features directly through the interface.",
      "description_length": 372,
      "index": 1266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impact_gui",
      "library": "frama-c-impact.gui",
      "description": "The module integrates impact analysis tools into the graphical interface, adding specialized controls and visual displays. It introduces data types for impact visualization, user interaction handlers, and plugin-specific GUI components. Operations include rendering analysis results, capturing user input for plugin functions, and updating interface elements based on impact data. For example, it enables displaying heatmaps of impact metrics and adjusting analysis parameters through sliders and buttons.",
      "description_length": 505,
      "index": 1267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread_gui.Mt_gui",
      "library": "mthread_gui",
      "description": "This module provides a function to register a hook that updates the GUI when a thread is selected in the menu. It works with the `ui` type representing the main window extension points and the `thread_state` type from the `Mthread` module. A concrete use case is synchronizing the display of thread-specific data in the interface when users switch between threads.",
      "description_length": 364,
      "index": 1268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mthread_gui",
      "library": "mthread_gui",
      "description": "This module integrates GUI updates with thread selection by registering hooks that respond to user interaction. It operates on the `ui` type to modify interface elements and uses `thread_state` to reflect the current thread's data. It enables synchronizing visual components with thread state changes, such as displaying thread-specific information when a user selects a different thread in the menu.",
      "description_length": 400,
      "index": 1269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options.Enabled.Datatype",
      "library": "frama-c-variadic.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating variadic function-related abstract syntax tree (AST) constructs during translation. It includes equality, comparison, hashing, and pretty-printing functions, along with utilities for project membership checks and deep copying. The module is used to handle semantic transformations of variadic functions and related builtins in the AST, ensuring correct representation and traversal during analysis.",
      "description_length": 494,
      "index": 1270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options.Strict.Datatype",
      "library": "frama-c-variadic.core",
      "description": "This module defines a concrete data type `t` for representing strict integral type descriptors in a variadic context, ensuring type-safe handling of LibC function arguments. It provides operations for equality, comparison, hashing, pretty printing, deep copying, and checking membership of project values, all specific to this type descriptor. Use cases include managing and validating integral type representations during variadic function calls in static analysis tools.",
      "description_length": 472,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options.Strict",
      "library": "frama-c-variadic.core",
      "description": "This module manages boolean state for strict mode enforcement in variadic function handling, allowing toggling, monitoring, and persistence of strict behavior to prevent unsafe integral casts. It works with primitive booleans enhanced by hooks and metadata, ensuring type safety during LibC calls. A concrete type `t` represents strict integral type descriptors, supporting equality, comparison, copying, and validation for use in static analysis tools. Together, these features enable precise control and verification of integral type handling in variadic contexts.",
      "description_length": 566,
      "index": 1272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Variadic.Options.Enabled",
      "library": "frama-c-variadic.core",
      "description": "This module manages a boolean state to enable or disable translation of variadic constructs in the AST, with hooks that trigger transformations when the state changes. It provides operations to set, get, and monitor the state, integrating with Frama-C's parameter system to control translation dynamically during analysis. The child module defines a data type `t` to represent variadic function constructs, offering utilities for comparison, copying, and project membership checks during AST manipulation. Together, they enable semantic translation of variadic functions and builtins like `va_arg` by coordinating state changes with AST traversal and transformation logic.",
      "description_length": 672,
      "index": 1273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Variadic.Options",
      "library": "frama-c-variadic.core",
      "description": "This module coordinates boolean state management for variadic function handling, enabling strict mode enforcement and AST translation control through interdependent state toggles with metadata-aware hooks. It defines two core data types: one representing strict integral type descriptors (`t`) for type-safe LibC interactions, and another capturing variadic function constructs (`t`) for AST manipulation with comparison, copying, and project membership checks. Operations include setting, getting, and monitoring state changes, which trigger validation routines and AST transformations during static analysis. For example, toggling strict mode validates integral casts while translating `va_arg` expressions into semantically equivalent constructs.",
      "description_length": 749,
      "index": 1274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Variadic",
      "library": "frama-c-variadic.core",
      "description": "This module manages boolean state for variadic function handling, coordinating strict mode enforcement and AST translation with metadata-aware hooks. It provides two core data types: one for strict integral type descriptors used in type-safe LibC interactions, and another for representing variadic function constructs in AST manipulation, supporting comparison, copying, and project membership checks. Key operations include setting and monitoring state toggles that trigger validation and AST transformations during static analysis. For instance, enabling strict mode validates integral casts and rewrites `va_arg` expressions into equivalent semantic constructs.",
      "description_length": 665,
      "index": 1275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Security_slicing_gui.Register_gui",
      "library": "frama-c-security_slicing.gui",
      "description": "This module extends the graphical user interface to integrate security-related controls and visualizations. It works with GUI components and security-specific data representations to enable user interaction with security features. Concrete use cases include displaying security status indicators and handling user input for security policy configurations.",
      "description_length": 355,
      "index": 1276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Security_slicing_gui",
      "library": "frama-c-security_slicing.gui",
      "description": "This module enhances the graphical interface with security-focused elements, allowing users to interact with and visualize security policies and statuses. It introduces data types for representing security configurations and events, along with operations to render and update these states dynamically. Users can configure access rules, view real-time security alerts, and manage encryption settings directly through the interface.",
      "description_length": 430,
      "index": 1277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for values of type `Data.t`, where `Data` may represent either a predicate or a term with structural or physical equality, respectively. It provides standard operations including equality checking, comparison, hashing, pretty printing, deep copying, and project-aware membership testing. Concrete use cases include managing collections of logical terms or predicates in analysis plugins where structural or identity-based equality is required.",
      "description_length": 491,
      "index": 1278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines keys for a map that can represent either predicates or terms, with structural equality for predicates and physical equality for terms. It provides standard operations including comparison, hashing, pretty printing, and deep copying, along with utilities to check membership based on project properties. It is used to manage and manipulate heterogeneous collections of logical terms and predicates in analysis contexts.",
      "description_length": 438,
      "index": 1279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for string-based parameter representations. It supports deep copying and membership checks over project skeletons, ensuring value integrity and isolation. Concrete use cases include managing and comparing string parameters in E-ACSL's widening output configuration.",
      "description_length": 391,
      "index": 1280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps used in logic function or predicate profiles, providing standard operations like equality, comparison, hashing, and pretty printing. It works with the `LFProf.Map.key` type, which represents logic function or predicate identifiers with associated metadata. Concrete use cases include managing and comparing keys in maps that track logic function profiles during static analysis.",
      "description_length": 418,
      "index": 1281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a map structure, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports working with values of type `E_ACSL.Analyses_datatype.Ival_datatype.Map.key`, which represent keys in a map, and includes functions for deep copying, checking membership based on project properties, and retrieving type information. Concrete use cases include managing and manipulating symbolic analysis keys in map-based data structures during static analysis.",
      "description_length": 520,
      "index": 1282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options in E-ACSL, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with string values as option parameters, enabling deep copying, membership testing over projects, and structured representation. Concrete use cases include parsing and managing E-ACSL configuration options that are specified as strings during analysis.",
      "description_length": 453,
      "index": 1283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for values of a given data type, supporting operations like equality, comparison, hashing, and pretty-printing. It works with terms that rely on physical equality, ensuring deep copying and project-aware membership checks. Concrete use cases include managing and querying collections of terms with structural identity, such as tracking project-specific values in static analysis.",
      "description_length": 427,
      "index": 1284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in hash tables, specifically tailored to handle values that are either predicates or terms. It provides standard operations including equality, comparison, hashing, and pretty-printing, which are essential for managing keys in a hash table. The module also supports deep copying and project membership checks, enabling precise manipulation and querying of key values within analysis contexts.",
      "description_length": 431,
      "index": 1285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map datatype where keys are integers and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It provides a deep copy function, a membership check for project skeletons, and standard map operations tailored for analysis values. Concrete use cases include managing and manipulating integer-indexed collections of analysis-specific data during static analysis in Frama-C.",
      "description_length": 457,
      "index": 1286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table data structure specialized for a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing analysis values across different projects, ensuring deep copies and project-specific membership checks. The structure is built around `Data.t` values, integrating with Frama-C's type and descriptor system for analysis purposes.",
      "description_length": 466,
      "index": 1287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table specialized for values with identity and profile information, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a parameterized data type `Data.t` and provides a structured representation for analysis purposes. Use it to manage and manipulate profiled terms in a logic context, such as tracking free variables and their intervals during static analysis.",
      "description_length": 432,
      "index": 1288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map datatype where keys are logic variables representing function parameters and values are intervals determined by function call arguments. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to track and analyze value ranges of function parameters across different call sites in static analysis.",
      "description_length": 440,
      "index": 1289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table datatype specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports logic function profiles by managing their storage and retrieval with deep copying, membership checks, and project-based filtering. Use cases include tracking and analyzing logic function instances with associated profiles during static analysis.",
      "description_length": 430,
      "index": 1290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options with operations for comparison, hashing, and pretty-printing. It supports values of type `t` representing string parameters, providing deep copy, equality checks, and project membership tests. Concrete use cases include managing and validating E-ACSL configuration options that require string inputs, such as file paths or identifier names.",
      "description_length": 418,
      "index": 1291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table-based data structure where keys are logic variables representing function parameters and values are intervals determined by function call arguments. It provides operations for equality checking, comparison, hashing, deep copying, and pretty-printing of these interval mappings, along with a mechanism to check membership based on project-specific predicates. The structure is used to represent and manipulate function parameter profiles during static analysis, enabling precise interval tracking across different call sites.",
      "description_length": 560,
      "index": 1292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type for handling string-based parameters in the context of option parsing and logging. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to represent and manipulate string values in a structured and type-safe way within the E-ACSL framework.",
      "description_length": 377,
      "index": 1293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a hash table that maps logic variables to intervals based on function call arguments. It provides standard operations such as equality, comparison, hashing, and pretty printing for these keys, ensuring they can be efficiently stored and retrieved. The keys are used to represent function parameters at callsites in a value analysis context.",
      "description_length": 381,
      "index": 1294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map where keys are either predicates or terms, with values parameterized by the `Data` module. It provides standard map operations like equality, comparison, hashing, and pretty-printing, while ensuring structural equality for predicates and physical equality for terms. It is used to manage analysis data associated with logical expressions in static analysis, where term identity must be preserved across operations.",
      "description_length": 443,
      "index": 1295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a specialized hashtbl implementation that relies on physical equality. It provides standard operations including equality checking, comparison, hashing, and pretty printing, along with utilities for deep copying and checking project membership. The type is specifically designed to support term identifiers in a way that enforces physical equality constraints required by the E-ACSL plugin.",
      "description_length": 432,
      "index": 1296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps used in analysis data structures, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with a specific key type that includes project membership checks and deep copying. Concrete use cases include managing and comparing keys in maps that store analysis-specific data during static analysis.",
      "description_length": 384,
      "index": 1297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Instrument.As_string.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a datatype for handling string-based command-line options with operations for comparison, hashing, pretty-printing, and deep copying. It supports values of type `t` that represent string parameters, along with standard utilities for checking membership in projects and structural equality. Concrete use cases include parsing and managing E-ACSL instrumentation options from the command line.",
      "description_length": 411,
      "index": 1298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a hash table, specifically tailored for number-type analyses in the context of the Frama-C kernel. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking membership based on project projections. The key type is used to uniquely identify and manipulate entries in a hash table that stores number-type analysis data.",
      "description_length": 446,
      "index": 1299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for maps that uses number-type identifiers, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with lists of key representatives, deep copying, and checking membership based on project properties. Concrete use cases include managing and comparing numeric type keys in static analysis contexts, such as tracking or querying specific analysis data associated with numeric types.",
      "description_length": 463,
      "index": 1300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for a map that associates logic variables with interval data based on function call arguments. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. The key type is used to represent and manipulate function parameter logic variables in the context of static analysis profiles.",
      "description_length": 402,
      "index": 1301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map where keys are number types and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate structured analysis data tied to numeric type keys in a deterministic and type-safe manner.",
      "description_length": 384,
      "index": 1302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in hash tables, specifically tailored to handle terms with variable profiles in the context of logic functions or predicates. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. These features support efficient storage and retrieval of analyzed terms with associated variable intervals in static analysis plugins.",
      "description_length": 447,
      "index": 1303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking and comparing sets of analyzed values in static analysis plugins. The module also includes functionality for deep copying and checking project membership within stored values.",
      "description_length": 401,
      "index": 1304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the key type used in a hash table for uniquely identifying and comparing logic function or predicate profiles. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, which are essential for managing and retrieving profile data efficiently. The module also supports deep copying and project membership checks, enabling safe manipulation and analysis of logic function keys within the Frama-C framework.",
      "description_length": 475,
      "index": 1305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a hash table data structure specialized for a given `Data` module, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing analysis values in a Frama-C plugin, where each hash table instance holds a list of representative values and can check membership based on project-specific criteria. The module also enables deep copying and integrates with Frama-C's type and descriptor system for runtime inspection and serialization.",
      "description_length": 531,
      "index": 1306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map structure parameterized by a `Data` module, where each map value is associated with a unique name and supports standard operations like equality, comparison, hashing, and pretty-printing. It works with the `At_data.Map.t` type, specialized by the provided `Data` module, and includes functions for checking membership based on project conditions, deep copying, and generating representants. Concrete use cases include managing analysis-specific metadata across different Frama-C projects, where each map entry corresponds to a project and its associated data.",
      "description_length": 588,
      "index": 1307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in hashtables, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports structured keys with deep copying, project membership checks, and type descriptors for integration with analysis frameworks. Concrete use cases include managing symbolic analysis states and tracking project-specific data in static analysis plugins.",
      "description_length": 406,
      "index": 1308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a map datatype for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty printing. It supports operations tailored for analysis data structures, such as deep copying, membership checking over project skeletons, and type representation for integration with Frama-C's kernel. Concrete use cases include managing and manipulating logic function or predicate profiles with structured, typed arguments in static analysis tools.",
      "description_length": 493,
      "index": 1309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl.Key",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a key type for use in a hashtbl, providing essential operations including equality, comparison, hashing, and pretty printing. It supports data types that can be stored in a Frama-C project-aware context, with deep copying and membership checks over project skeletons. Concrete use cases include managing analysis-specific keys in a hashtbl for Frama-C plugins, ensuring proper handling of project-based data.",
      "description_length": 428,
      "index": 1310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements an ordered map structure with polymorphic values, using keys based on an interval type to support insertion, lookup, and ordered traversal. It provides operations for merging, filtering, and transforming bindings while preserving key order, along with sequence conversions and bidirectional iteration, making it suitable for static analysis and abstract interpretation tasks. The key module defines the interval-based key type with comparison, hashing, and pretty printing, supporting symbolic analysis keys and deep copying, while the integer-key submodule offers a specialized map for integer keys with analysis-specific operations. Examples include managing symbolic memory states with interval keys and tracking analysis metadata using integer indices.",
      "description_length": 779,
      "index": 1311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Valid.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides structural inspection through `descr`, `packed_descr`, and `reprs`, and supports deep copying and project membership checks via `mem_project`. It is used to represent and manipulate structured values within the E-ACSL options system, particularly for logging and configuration purposes.",
      "description_length": 415,
      "index": 1312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Temporal_validity.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with a descriptor, packed descriptor, and list of representatives, enabling deep copying and membership checks over project values. It is used to manage and manipulate temporal validity options in the E-ACSL plugin, ensuring correct handling of project-specific data throughout analysis phases.",
      "description_length": 450,
      "index": 1313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages and validates string-based command-line parameters, supporting value assignment, alias resolution, and state tracking. It provides core operations for enforcing constraints like allowed values and function name validity, while enabling serialization and project-specific configuration. The child module introduces a structured data type for string parameters with support for comparison, hashing, pretty printing, and deep copying, enhancing type-safe manipulation within the framework. Together, they enable precise parsing, validation, and dynamic handling of user-provided string options in a project-aware context.",
      "description_length": 638,
      "index": 1314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Assert_print_data.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling structured data representations. It supports interactions with project skeletons through membership checks and provides deep copying to ensure data isolation. The type is used to manage and manipulate descriptors and representants in a type-safe manner, particularly for logging and analysis configurations.",
      "description_length": 433,
      "index": 1315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Operators",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the core monadic operations for chaining computations that manipulate environments, produce side outputs, and maintain mutable state. It supports composing functions that operate on the RWS monad's structure, enabling sequential execution where each step can read from or update the state, emit additional data, or modify the environment for nested computations. Concrete use cases include traversing and transforming abstract syntax trees while collecting metadata, generating code with accumulated declarations, or analyzing programs with context-sensitive rules.",
      "description_length": 585,
      "index": 1316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based command-line parameters with support for value validation, alias resolution, and state change tracking through hooks. It operates on strings and string lists to enforce constraints, handle dynamic updates, and serialize configuration state, enabling precise control over runtime settings like analysis or logging behavior. A core data type provides equality, comparison, hashing, and pretty-printing operations, tailored for parameter representations with deep copying and membership checks. This structure ensures value integrity and isolation, particularly in managing and comparing string parameters for configurations such as E-ACSL's widening output.",
      "description_length": 688,
      "index": 1317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Bool",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides monadic operations for handling boolean conditions during the generation of Interlang expressions. It includes the `only_if` function, which conditionally executes a monadic action based on a boolean flag. It works directly with boolean values and the monadic type `unit E_ACSL.Interlang_gen.M.t`, enabling conditional logic in the construction of intermediate language expressions. A concrete use case is selectively generating Interlang code fragments based on static analysis results or configuration flags.",
      "description_length": 531,
      "index": 1318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides imperative hash tables for heterogeneous keys, supporting both structural and physical equality semantics, with operations for traversal, folding, memoization, and safe key lookups. It handles key types that can be either predicates (compared structurally) or terms (compared by physical identity), enabling precise management of logical equivalences and term identities in program analysis. The associated modules offer specialized hash tables for `Data.t` values and custom key types, including equality, comparison, hashing, and project-aware operations, allowing concrete use cases such as tracking logical expressions and managing term-based mappings in analysis plugins. Examples include memoizing analysis results based on term identity or grouping predicates by structural equivalence.",
      "description_length": 814,
      "index": 1319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Concurrency.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides a structured representation for handling concurrency-related options in E-ACSL, including descriptors, packed representations, and deep copying. Use cases include managing and comparing concurrency configurations during static analysis and storing them in a type-safe manner.",
      "description_length": 404,
      "index": 1320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Project_name.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a structured data type with operations for comparison, hashing, and pretty printing, specifically tailored for representing and manipulating project-specific data in the E-ACSL framework. It includes functions for checking membership within project structures, deep copying to prevent shared state, and utilities for type and descriptor management. Concrete use cases include tracking and comparing analysis configurations and managing project-specific values in a type-safe manner.",
      "description_length": 502,
      "index": 1321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a specialized map structure that combines structural and physical equality checks for keys representing either predicates or terms, using structural equality for predicates and physical identity for terms. It supports ordered traversal, transformation, and filtering operations such as `add`, `merge`, and `fold`, along with sequence-based conversions and custom formatting for analysis data associated with logical expressions. The key type enables precise equivalence semantics in symbolic analysis or term rewriting systems, distinguishing between predicate structure and term identity. Submodules provide key definitions with comparison, hashing, and pretty printing, along with a data-parameterized map that supports equality, comparison, and analysis-specific operations over logical terms and predicates.",
      "description_length": 834,
      "index": 1322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type for representing and manipulating structured command-line parameters, including operations for equality, comparison, hashing, and pretty-printing. It works with a custom type `t` that encapsulates values such as strings, integers, and project-specific data, along with descriptors for type and structure. Concrete use cases include parsing and validating E-ACSL instrumentation options, managing configuration state, and supporting extensible command-line interfaces.",
      "description_length": 499,
      "index": 1323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Full_mtracking.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for tracking memory representations in the E-ACSL runtime. It supports structured logging and project-specific membership checks through `mem_project`, enabling precise analysis of memory states. The type is used to represent and manipulate internal memory tracking data during program verification.",
      "description_length": 412,
      "index": 1324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-valued command-line parameters with support for validation, dynamic updates, and alias resolution. It defines a core type `t` for representing string parameters, along with operations for comparison, hashing, pretty-printing, and checking membership in a set of valid values. You can use it to enforce constraints on string inputs like file paths or identifiers, while allowing runtime reconfiguration and side effects via hooks. Submodule functionality extends this by providing utilities to serialize, compare, and manipulate these string parameters in structured ways.",
      "description_length": 598,
      "index": 1325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements set operations for elements that are either structurally compared predicates or physically identified terms, combining structural equality checks for predicate values with term identity based on physical memory addresses. It provides transformations, membership queries, and ordered traversals over heterogeneous collections of these logical expressions, while supporting conversions to sequences and specialized operations for nearest-value approximation. The design accommodates use cases requiring precise handling of symbolic expressions in static analysis contexts where term identity and predicate structure must be distinguished.",
      "description_length": 659,
      "index": 1326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for grouping and controlling widening arguments in the E-ACSL options system. It provides operations to create, enable, and modify categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. These categories determine how parameters are interpreted and applied during static analysis.",
      "description_length": 359,
      "index": 1327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Interlang.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides structured representations and descriptors for type manipulation, including deep copying and project membership checks. Concrete use cases include managing and comparing complex data structures in E-ACSL, such as tracking and serializing analysis results.",
      "description_length": 375,
      "index": 1328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module organizes logic function and predicate profiles into hash tables, enabling efficient insertion, lookup, and deletion keyed on structured identifiers. It supports ordered traversal by keys, values, or entries, and integrates utilities for memoization, sequence conversion, and type construction over arbitrary data. Submodules specialize in key management and comparison, ensuring deterministic handling of profile identities, and in value storage with deep copying and filtering by project context. Example uses include caching analysis results per function profile and traversing logic definitions in a controlled order during static analysis.",
      "description_length": 656,
      "index": 1329,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "E_ACSL.Options.Run.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling structured values in the context of E-ACSL options. It provides a descriptor, packed representation, and a list of representative values for the type, enabling introspection and serialization. Use cases include managing and comparing runtime option values, checking project membership, and ensuring deep copying of configuration data.",
      "description_length": 464,
      "index": 1330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based command-line parameters with support for validation, alias handling, and state tracking, operating on string collections and function identifiers. It provides key operations such as setting defaults, registering change hooks, and validating inputs against rules or function references, while its child module introduces a datatype for string command-line options with utilities for comparison, hashing, pretty-printing, and deep copying. Together, they enable use cases like parsing and managing E-ACSL instrumentation settings, enforcing allowed values, and serializing configurations for runtime checks. The core type `t` represents string parameters, supporting structural equality and project membership checks.",
      "description_length": 748,
      "index": 1331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Operators",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines monadic operators for sequencing computations that generate Interlang expressions during E-ACSL translation. It provides bind and map operations for the monad M, enabling composition of expression-building steps that carry reader, writer, and state effects. These operators are used to construct complex Interlang expressions from simpler components while managing context such as variable bindings or type information.",
      "description_length": 439,
      "index": 1332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Verbose.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured values through a list of representatives, a type descriptor, and a packed descriptor for serialization. The module is used to manage and compare verbose logging options in the E-ACSL plugin, enabling precise control over logging behavior during analysis.",
      "description_length": 396,
      "index": 1333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements ordered sets of profile mappings that associate logic variables with function parameter intervals, using comparison-based ordering to manage elements. It supports set-theoretic operations (union, intersection, difference), iterative transformations (map, filter, fold), and ordered queries (nearest elements, min/max) while preserving structural invariants. These sets are used in static analysis to track parameter-dependent value ranges across function callsites, with utilities for integration into Frama-C's analysis plugins and data representation frameworks.",
      "description_length": 587,
      "index": 1334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc.Id_term.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables using keys based on physical equality, enabling efficient imperative operations like insertion, lookup, and bulk transformations with deterministic traversal. It manages associations between keys of type `E_ACSL.Misc.Id_term.t` and arbitrary values, supporting advanced use cases such as memoization, ordered iteration, and safe value computation with fallbacks. A child module specializes these tables for a specific data type, adding support for deep copying, equality, comparison, and project-aware membership checks, useful for managing collections of terms with structural identity. Another child module defines a key type that enforces physical equality constraints, providing standard operations and utilities tailored for term identifiers in the E-ACSL plugin.",
      "description_length": 803,
      "index": 1335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Functions.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages parameter categories for command-line options, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types that associate names with accessors and dependency states. Use cases include configuring how groups of related command-line parameters are interpreted and enabled during tool execution.",
      "description_length": 384,
      "index": 1336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type for representing and manipulating widening arguments in the context of E-ACSL options. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and membership checking for project-specific values. The type supports structured representation through a list of instances and integrates with Frama-C's type and descriptor system for serialization and introspection.",
      "description_length": 455,
      "index": 1337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for command-line parameter collections, such as `@none`, `@default`, and `@all`. It provides operations to create, enable, and modify categories with accessors and dependencies, and control their behavior in positive or negative contexts. Use cases include configuring and organizing groups of related command-line options in E-ACSL.",
      "description_length": 376,
      "index": 1338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module organizes logic variables as keys tied to interval data derived from function call arguments, enabling precise static analysis of parameter value ranges across callsites. It supports core map operations like insertion, lookup, and deletion, along with advanced transformations such as merging and filtering under partial or total computation models. The key type implements equality, comparison, and hashing for efficient map manipulation, while deep copying and project-aware membership checks allow context-sensitive analysis. For example, it can merge interval data from multiple callsites or extract bindings to model variable behavior through function calls.",
      "description_length": 675,
      "index": 1339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module organizes logic function or predicate profiles using finite maps keyed by identifiers with metadata, supporting efficient updates, queries, and ordered traversals. It combines core map operations\u2014insertion, deletion, and merging\u2014with specialized data handling through its child modules, one defining structured keys for profile identification and the other managing typed analysis data with deep copies and kernel integration. You can track and transform function properties across program analyses, merge intermediate results, or filter profiles based on structured keys and values. Iterators and sequence conversions enable pipeline-style processing while preserving performance through physical equality checks.",
      "description_length": 726,
      "index": 1340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages associative maps with numeric type keys, offering insertion, deletion, transformation, and ordered traversal over persistent data structures optimized for efficiency and minimal allocation. It provides direct operations for map manipulation alongside submodules that define key behaviors and typed map implementations, enabling precise handling of numeric-keyed data in static analysis tasks. You can create maps keyed by number types, perform equality checks, hash and pretty-print them, and use project-aware operations to track and transform analysis data across program states. The combination of key abstraction and typed map modules supports deterministic, type-safe manipulation of structured data tied to numeric identifiers.",
      "description_length": 753,
      "index": 1341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements ordered set operations for numeric or comparable values, supporting efficient union, intersection, difference, and element manipulation while preserving sorted traversal. It works with immutable sets of `Number_ty.t` elements, offering transformations like mapping, filtering, and nearest-value queries, alongside conversions to lists and sequences. Designed for static analysis tasks in Frama-C's E_ACSL plugin, it facilitates precise interval arithmetic, constraint propagation, and symbolic reasoning over ordered numerical domains.",
      "description_length": 558,
      "index": 1342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages parameter categories for command-line options, such as `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with custom accessors and dependencies. Use cases include configuring option groups and controlling default or global behavior in command-line parsing.",
      "description_length": 335,
      "index": 1343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Validate_format_strings.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for validating format strings in E-ACSL. It includes support for deep copying values and checking membership based on project-specific predicates. The type is used to represent and manipulate format string validation settings within the analysis framework.",
      "description_length": 389,
      "index": 1344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Map",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides an ordered, immutable map structure with keys of type `At_data.t` and values parameterized by a `Data` module, enabling precise tracking and transformation of analysis states across Frama-C projects. It supports ordered traversal, merging, and safe key access, with values tied to unique names and project-specific conditions via its child modules. Operations include equality checks, comparison, hashing, and pretty-printing, facilitating analysis workflows such as aggregating computed attributes, managing metadata, and serializing results. Use cases include mapping program elements to analysis data, comparing project-specific states, and transforming maps for debugging or output.",
      "description_length": 707,
      "index": 1345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Debug.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating structured debug information. It supports deep copying, membership testing within project skeletons, and provides descriptors for type and structural representation. Concrete use cases include managing and comparing complex debug data structures in the E-ACSL runtime, such as tracking and logging internal state during program analysis.",
      "description_length": 497,
      "index": 1346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides imperative hash tables mapping number-type keys to arbitrary values, with operations for insertion, lookup, iteration, and sorted traversal, along with utilities for memoization and default value handling. Its key module defines a specialized number-type key with equality, comparison, hashing, and pretty-printing, supporting deep copying and project-based membership checks. The data module builds on this by implementing hash tables tailored to a specific data type, enabling analysis tracking, value comparison, and project-aware membership tests within Frama-C plugins. Together, they allow building and manipulating structured analysis data, such as tracking numeric ranges across program points or caching computed values per analysis context.",
      "description_length": 771,
      "index": 1347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions.As_string",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides utilities for managing string-based command-line parameters with support for constraints, validation, and state synchronization. It defines a core datatype for representing string options with standard operations like comparison, hashing, and pretty printing, along with submodules that extend functionality for structured parsing, deep copying, and membership testing. Use cases include enforcing valid function names, restricting inputs to predefined enums, and tracking global parameter state across components. The module supports both direct manipulation of string values and integration with project-level structures through serialization and comparison hooks.",
      "description_length": 687,
      "index": 1348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Replace_libc_functions.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type for representing and manipulating options related to replacing libc functions in E-ACSL. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for working with project-specific data through the `mem_project` function. The type is used to manage and query configurations for function replacement during static analysis.",
      "description_length": 423,
      "index": 1349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output_base.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing and manipulating widening output configurations in E-ACSL. It supports operations for comparison, hashing, pretty printing, and deep copying, along with checks for project membership. The type is used to manage and persist analysis settings that influence how widening is applied during abstract interpretation.",
      "description_length": 369,
      "index": 1350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.List",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies monadic computations over lists of E-ACSL intermediate language elements. It provides operations to iterate, map, and fold over lists, where each element transformation involves generating Interlang expressions within a monadic context. These functions are used during the translation of E-ACSL predicates into the intermediate language, enabling sequential processing of predicate components with embedded monadic effects.",
      "description_length": 443,
      "index": 1351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.List",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to apply RWS monadic functions to lists, enabling effects like environment manipulation, state updates, and output accumulation during list traversals. It supports `iter`, `map`, and `fold_left` functions that work on lists, allowing transformations and side effects to be sequenced across list elements. Concrete use cases include collecting variable declarations from a list of expressions, transforming terms while maintaining a shared context, and accumulating logging output during list processing.",
      "description_length": 535,
      "index": 1352,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations for immutable sets of ordered elements, supporting construction (e.g., empty, singleton), modification (union, intersection, difference), and querying (membership, cardinality). It includes transformations like mapping and filtering, iteration in ordered or reverse order, and conversions to/from lists and sequences, all maintaining a total ordering via `Ord.compare`. Use cases involve managing analysis data with precise set semantics, such as tracking memory states, constraints, or symbolic values in static analysis tasks requiring ordered element handling and efficient membership checks.",
      "description_length": 627,
      "index": 1353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Option",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies monadic operations to the `option` type, enabling effectful computations over optional values. It provides `iter` for performing side-effecting actions on `Some` values and `map` for transforming `option` values within a monadic context. Concrete use cases include handling optional environment lookups or stateful computations that may fail, where effects like logging or context updates must occur conditionally based on the presence of a value.",
      "description_length": 467,
      "index": 1354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements hash tables keyed by structured types with support for ordered traversal, memoization, and type-aware transformations, enabling efficient aggregation and analysis of abstract values. It provides imperative-style operations for insertion, lookup, and iteration, combined with functional utilities for comparison, sorting, and conversion to sequences. The module integrates with child modules that specialize value handling and define structured key types, allowing use cases such as tracking analyzed values, managing symbolic states, and performing project-aware data analysis. Specific operations include memoizing function results, aggregating analysis state, and traversing hash tables in sorted order based on key or value comparisons.",
      "description_length": 762,
      "index": 1355,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments_base.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the E-ACSL widening arguments system. It supports structured values through a descriptor and provides deep copying and membership checks over project skeletons. Concrete use cases include managing and comparing abstract domain parameters during static analysis.",
      "description_length": 385,
      "index": 1356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides imperative hash tables for efficient key-value storage and manipulation, with support for ordered traversal, memoization, and conversion to sequences. It enables operations such as insertion, deletion, and safe lookup while ensuring compatibility with Frama-C's project-aware data handling through deep copying and project-specific comparisons. The child modules specialize the table for specific data and define key types with necessary operations, enabling structured analysis tasks like tracking and comparing values across projects. For example, it can cache analysis results keyed by project-specific identifiers or maintain ordered mappings for inter-project data comparison.",
      "description_length": 702,
      "index": 1357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with descriptors and representants for structural inspection. It supports deep copying and membership testing within project structures via `copy` and `mem_project`. Concrete use cases include managing and comparing complex configuration values passed through command-line parameters in a static analysis tool.",
      "description_length": 424,
      "index": 1358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides hash tables for mapping keys that represent terms with variable profiles\u2014tracking free variables and their intervals\u2014to arbitrary values. It supports standard operations like insertion, safe lookup (`find_opt`/`find_def`), ordered iteration, and sequence-based updates, along with utilities for memoization and structured type construction. The child modules specialize in handling profiled data and term keys, offering equality, comparison, hashing, and pretty-printing for terms involved in logic functions or predicates. Use this module to efficiently manage and analyze logic terms during program verification, enabling dynamic tracking of variable occurrences and interval constraints.",
      "description_length": 711,
      "index": 1359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Functions.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line parameter handling. It supports structured data representation with a descriptor system, allowing deep copying and membership checks for project-related values. Concrete use cases include managing and validating complex configuration options in E-ACSL tools.",
      "description_length": 395,
      "index": 1360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Interlang_force.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for handling structured values in the context of E-ACSL options. It supports deep copying and membership testing for project-specific values, ensuring no shared references. Concrete use cases include managing and comparing configuration data during static analysis, particularly for options tied to intermediate language transformations.",
      "description_length": 450,
      "index": 1361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.Category",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manages categories for controlling output behavior in a logging or configuration system. It provides operations to create, enable, and modify categories such as `@none`, `@default`, and `@all`, each influencing how output is filtered or interpreted. These categories are associated with accessors and states, allowing dynamic control over output settings based on program context.",
      "description_length": 404,
      "index": 1362,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This set interface supports operations like union, intersection, predicate-based filtering, and ordered traversal for collections of logic function or predicate profiles, which encapsulate analysis metadata with strict uniqueness guarantees enforced via `Ord.compare`. It provides utilities to convert between sets, lists, and sequences, find elements relative to a given value, and perform deep comparisons or copies, catering to static analysis tasks that require tracking and manipulating hierarchical logic constructs. Applications include aggregating profiling data during verification, validating argument constraints, and maintaining canonical representations of logic entities.",
      "description_length": 685,
      "index": 1363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype.Set",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements an ordered, immutable set structure for elements of an analysis-specific type, offering operations like union, intersection, element queries, and ordered iteration. It supports efficient membership checks, set transformations preserving structural properties, and conversions to lists or sequences, while maintaining element ordering through a dedicated comparison function. Designed for static analysis tasks, it facilitates precise set manipulations, nearest element queries, project-specific membership validations, and deep copying with shared state preservation.",
      "description_length": 590,
      "index": 1364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete data type for representing and manipulating widening output configurations in E-ACSL. It supports operations such as equality checking, comparison, hashing, pretty-printing, and deep copying, along with utilities for inspecting and filtering project-related data embedded within the type. The type is used to manage and persist configuration states that control how widening is applied and output during analysis.",
      "description_length": 444,
      "index": 1365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make.Bool",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a single function `only_if` that conditionally executes a monadic action based on a boolean flag. It works with the unit type inside the RWS monad, allowing for conditional execution without affecting the main computation flow. A concrete use case is selectively running initialization or logging actions during term transformation based on a boolean configuration flag.",
      "description_length": 391,
      "index": 1366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile.Hashtbl",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides hash tables that map logic variables to intervals derived from function call arguments, enabling efficient storage and retrieval of parameter profiles with ordered key comparisons. It supports operations like memoization, sorted iteration, and sequence conversion, optimized for static analysis tasks involving precise interval tracking across function calls. The main data types include keys representing function parameters and values capturing interval bounds, with operations for equality, hashing, comparison, and pretty-printing available through child modules. You can use it to aggregate parameter profiles, check membership against predicates, or extend mappings while preserving ordering and efficient lookup.",
      "description_length": 740,
      "index": 1367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Gmp_only.Datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in the E-ACSL runtime system. It supports structured values through a descriptor and provides deep copying and membership checks over project skeletons. Concrete use cases include representing and manipulating symbolic execution states and configuration options within E-ACSL.",
      "description_length": 397,
      "index": 1368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M.Option",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides monadic operations for handling `option` values within the intermediate language generation monad. It supports `iter` for performing side effects on `Some` values and `map` for transforming `option` values while sequencing monadic actions. These functions are used during the translation of E-ACSL predicates into Interlang expressions, enabling clean handling of optional components in the generated code.",
      "description_length": 427,
      "index": 1369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen.M",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a monadic framework for generating intermediate language expressions during the translation of E-ACSL predicates, combining reader, writer, and state effects to manage context, output accumulation, and transformations. It supports key operations like `run`, `bind`, and `return`, along with helpers such as `not_covered` for handling unsupported elements, enabling structured translation of logic expressions into Interlang. Submodules extend this functionality with conditionals via `only_if`, list processing for sequential translation steps, option handling for optional components, and sequencing combinators that preserve context such as variable bindings and type information. Example uses include selectively generating code based on analysis results, building complex expressions from simpler parts, and mapping over lists of predicate elements while maintaining monadic effects.",
      "description_length": 908,
      "index": 1370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term.Predicate",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates logical predicates used in formal verification. It provides functions to create boolean constants, conditional expressions, let bindings, and temporal assertions using labels. These operations target the `predicate` type, enabling precise specification of program properties such as preconditions, postconditions, and invariants.",
      "description_length": 368,
      "index": 1371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Gmp_only",
      "library": "frama-c-e-acsl.core",
      "description": "This component manages a boolean configuration option that controls GMP-specific behavior in static analysis plugins, enabling runtime toggling of arbitrary-precision arithmetic features through direct API calls, command-line flags, or serialized configurations. It maintains shared state with activation and deactivation hooks, integrating with plugin settings for visibility and control. The child module defines a structured data type with equality, comparison, and pretty printing operations, supporting deep copying and membership checks over project skeletons. Together, they enable precise configuration and manipulation of symbolic execution states and analysis settings in Frama-C-based tools.",
      "description_length": 702,
      "index": 1372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Gmp.Q",
      "library": "frama-c-e-acsl.core",
      "description": "Handles rational number operations using GMP, including arithmetic, comparisons, and type conversions. Works with expressions representing real numbers and environments for state management. Used to create and manipulate rational values in ACSL specifications, normalize decimal inputs, and cast between types during verification.",
      "description_length": 330,
      "index": 1373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Validate_format_strings",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a boolean option type to control format string validation behavior, with functions to toggle between enabled and disabled modes. It includes support for state change hooks, serialization, and command-line integration, enabling selective enforcement of format string checks during runtime assertion validation. The custom data type from the child module enhances this functionality by offering equality, comparison, and pretty-printing operations tailored to E-ACSL format string validation. Developers can use these combined features to represent, manipulate, and persist validation settings while integrating reactive updates and deep copying mechanisms into their analysis workflows.",
      "description_length": 706,
      "index": 1374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.S-List",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies monadic computations to lists, providing operations to iterate, map, and fold over list elements within the RWS monad context. It works with lists of values, sequencing monadic actions across each element while accumulating effects like environment changes, state updates, or writer outputs. Concrete use cases include transforming or analyzing recursive term structures where each element may modify the environment, produce side-channel output, or affect state.",
      "description_length": 483,
      "index": 1375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.S",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements the RWS monad, combining Reader, Writer, and State functionalities to manage environments, side-channel output, and mutable state within pure functional computations. It operates on three core data types: `env` for read-only environment access, `out` for accumulating write-only output, and `state` for readable and writable state. Concrete use cases include traversing and transforming abstract syntax trees while maintaining context, collecting generated identifiers or logging events during compilation, and managing mutable state such as counters or caches without side effects.",
      "description_length": 605,
      "index": 1376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output_base",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages configurable integer parameters with dynamic constraints, enabling bounded value updates, default state restoration, and change notifications. It supports command-line configuration, persistent serialization, and tracks state transitions for reactive behavior, particularly in Frama-C plugin contexts. The core type represents widening output configurations with operations for comparison, hashing, pretty printing, and project membership checks. Users can define constrained integer settings, register callbacks for value changes, and persist configurations across sessions.",
      "description_length": 595,
      "index": 1377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Full_mtracking",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean option to control tracking behavior, with support for toggling state, monitoring changes through hooks, and handling configuration defaults. It operates on a structured data type that includes command-line visibility, aliases, and custom serialization, enabling runtime adjustments and persistent state management. The child module defines a memory representation type with equality, comparison, and pretty-printing operations, used for precise memory state analysis during verification. Together, they support use cases like runtime configuration, structured logging, and integration with project-specific memory tracking workflows.",
      "description_length": 663,
      "index": 1378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Interlang",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages boolean flags with rich metadata, supporting state manipulation through direct assignment, command-line arguments, and project-specific configuration. It provides structured representations and operations for equality, comparison, hashing, and pretty-printing, enabling precise control over flag behavior and serialization. Use it to implement feature toggles in interlanguage translation, runtime configuration, or deprecation-aware option management, with support for tracking changes and comparing complex data structures. Submodules enhance its capabilities with type descriptors and deep copying, facilitating the management of analysis results in systems like E-ACSL.",
      "description_length": 693,
      "index": 1379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_build.Lhost",
      "library": "frama-c-e-acsl.core",
      "description": "Converts a CIL variable into an intermediate language host value, using an optional custom name. Works with CIL variable information and intermediate language host structures. Useful for translating C variables into their corresponding abstract representations during static analysis.",
      "description_length": 284,
      "index": 1380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.S-Option",
      "library": "frama-c-e-acsl.core",
      "description": "This module applies monadic functions to values of the `option` type, enabling effectful computations over optional data. It provides `iter` for performing side-effecting operations on `Some` values and `map` for transforming `option` values within a monadic context. Concrete use cases include handling optional environment lookups or conditional state updates within the RWS monad, where computations depend on the presence or absence of a value.",
      "description_length": 448,
      "index": 1381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module organizes command-line parameters through structured data types that support equality, comparison, hashing, and pretty-printing, enabling precise control over parameter behavior. It manages parameter categories like `@none`, `@default`, and `@all`, allowing configuration of how groups of options are interpreted and enabled during execution. String-based parameters are handled with validation, constraints, and synchronization, supporting use cases such as enforcing valid function names or restricting inputs to enums. Submodules extend functionality for parsing, deep copying, and membership testing, integrating with project-level structures through serialization and comparison hooks.",
      "description_length": 702,
      "index": 1382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types.Z",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines and manipulates an unbounded integer type used for representing GMP values at runtime. It provides functions to obtain the type, its pointer variant, and utilities to check and initialize its usage. It is used when working with arbitrary-precision integers in CIL code, particularly during type checking and transformation passes involving GMP values.",
      "description_length": 371,
      "index": 1383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term.S",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to construct and manipulate logical terms and expressions, including creating boolean constants, conditional expressions, let bindings, and labeled terms. It operates on the abstract type `t`, representing logical entities, and supports building logic bodies and visiting terms with custom logic visitors. Concrete use cases include assembling verification conditions and transforming logical expressions during static analysis.",
      "description_length": 459,
      "index": 1384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Lscope.D",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for a data type representing analysis scopes, including equality, comparison, hashing, and pretty-printing. It supports working with project-based data through membership checks and deep copying. Concrete use cases include managing and comparing analysis contexts within static analysis tools.",
      "description_length": 324,
      "index": 1385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Cache_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a cache directory path for the E-ACSL plugin, providing functions to retrieve, set, and check the status of the directory. It works with `Frama_c_kernel.Filepath.t` to represent file paths and supports operations to access or create cache files and directories. Concrete use cases include storing and retrieving cached analysis results in a specified directory during static analysis runs.",
      "description_length": 409,
      "index": 1386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.State_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages the creation and retrieval of directories and files within a plugin-specific state directory. It provides direct access to set, get, and check the state directory path, along with obtaining file and directory paths derived from it. It is used to organize runtime-generated files in a structured and configurable way.",
      "description_length": 336,
      "index": 1387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Number_ty",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a concrete numeric type `t` with standard operations like equality, comparison, hashing, and pretty printing, along with utilities for copying and checking membership of project-specific values. Its Set submodule supports efficient, ordered set operations such as union, intersection, and mapping, enabling precise interval arithmetic and symbolic reasoning over numeric domains. The Map submodule provides persistent, ordered maps keyed by the numeric type, allowing insertion, transformation, and traversal while ensuring type-safe data handling in static analysis. The Hashtbl submodule implements imperative hash tables with number-type keys, supporting memoization, default values, and efficient lookups, ideal for tracking analysis data across program states or caching results in Frama-C plugins.",
      "description_length": 823,
      "index": 1388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang.Varinfo",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents variables in the E-ACSL intermediate language, handling both freshly generated logic variables and references to existing Cil logic variables. It provides operations to construct these variable representations and to pretty-print them for debugging or logging. Concrete use cases include tracking variable origins during intermediate code generation and interfacing with Cil's term system during compilation.",
      "description_length": 431,
      "index": 1389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types.Q",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the rational number type used at runtime, including operations to retrieve the type and its pointer variant, check type equivalence, and initialize type usage. It works with the `Frama_c_kernel.Cil_types.typ` data type to represent GMP rational values. Concrete use cases include type checking and manipulation when analyzing or transforming C code involving GMP rationals.",
      "description_length": 393,
      "index": 1390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Instrument",
      "library": "frama-c-e-acsl.core",
      "description": "This module organizes command-line parameters as set-based collections, enabling dynamic value updates, custom serialization, and state tracking through abstract option states and imperative sets of functions. It supports structured and string-based parameters via child modules, offering operations like membership checks, validation, alias handling, and category management with accessors and dependencies. Main data types include `t` for abstract option states, string parameters with structural equality, and category types like `@none` and `@all`. You can use it to configure analysis tools with validated, extensible command-line interfaces, track parameter changes, and manage interdependent option groups in E-ACSL instrumentation.",
      "description_length": 739,
      "index": 1391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term.Term",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates logical terms and predicates used in formal verification. It provides functions to create boolean constants, conditional expressions, let bindings, and labeled terms, operating on types like `term`, `predicate`, and `logic_body`. Concrete use cases include building logical assertions, modeling program states, and encoding verification conditions in static analysis tools.",
      "description_length": 412,
      "index": 1392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Functions.RTL",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles name manipulation and identification for functions and variables in the E-ACSL runtime library. It provides functions to prefix names with specific identifiers, check if a name was generated during instrumentation, and retrieve the original name of a kernel function. Use cases include managing symbol namespaces during static analysis and ensuring correct handling of instrumented code elements.",
      "description_length": 416,
      "index": 1393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Translate_ats.Malloc",
      "library": "frama-c-e-acsl.core",
      "description": "This module tracks and manages dynamic memory allocation statements for specific kernel functions during translation. It provides operations to find and remove `malloc` statements associated with a given function, ensuring correct insertion and cleanup of memory allocations. It works directly with `kernel_function` and `stmt` types from the CIL framework, targeting functions that require explicit memory handling in generated C code.",
      "description_length": 436,
      "index": 1394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Dkey",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for managing and querying dynamic keys used to parameterize various E-ACSL analysis components. It provides functions to create, compare, and associate values with keys that are used to configure analysis categories such as bound variables, inductive reasoning, and interval tracking. Concrete use cases include enabling per-key configuration of analysis precision and enabling/disabling specific analysis phases based on key settings.",
      "description_length": 466,
      "index": 1395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Error.S",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for creating and handling exceptions related to typing errors, unsupported features, and memoization failures, using location-annotated messages. It provides functions to raise or construct these errors, along with utilities to handle them during computations, optionally returning fallback values or formatted error messages. Concrete use cases include signaling unhandled language constructs during analysis, managing incomplete preprocessing phases, and propagating errors through result values in transformation pipelines.",
      "description_length": 557,
      "index": 1396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Interlang_build.Exp",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs expressions in an intermediate language using smart constructors. It provides functions to create expressions from expression nodes, lvalues, integers, and sizeof operations, all tied to a specific type system and term origin. Concrete use cases include building typed expressions for static analysis tools that require precise semantic representations of C code constructs.",
      "description_length": 397,
      "index": 1397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Config_dir",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages file paths for a plugin-specific configuration directory, providing operations to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to handle path manipulations and ensures the existence of required paths based on the `create_path` flag. Concrete use cases include setting up and accessing plugin-specific configuration files and directories during analysis.",
      "description_length": 422,
      "index": 1398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Profile",
      "library": "frama-c-e-acsl.core",
      "description": "This module maps logic variables to intervals derived from function call arguments, enabling precise static analysis of parameter value ranges across callsites. It supports creation, comparison, and manipulation of profiles, with operations for checking inclusion, emptiness, and equality, while child modules provide ordered sets, maps, and hash tables for structured, efficient storage and transformation of interval data. The main data types include logic variables as keys with interval values, supporting set-theoretic operations, map transformations, and hash-based lookups. You can use it to merge interval data from multiple callsites, track variable bounds during analysis, or perform ordered queries to model variable behavior through function calls.",
      "description_length": 760,
      "index": 1399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Logic_normalizer.Logic_infos",
      "library": "frama-c-e-acsl.core",
      "description": "This module tracks and manages relationships between original and transformed logical entities during predicate normalization. It provides `generated_of` to retrieve auxiliary logic definitions created from a given logic definition, and `origin_of_lv` to identify the source logic variable of a transformed variable. These functions support accurate referencing and user feedback when dealing with generated logic constructs.",
      "description_length": 425,
      "index": 1400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Misc.Id_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents terms using physical equality, offering direct operations like equality checking, hashing, and deep copying on `term` values from Cil_types, ensuring identity-based semantics for efficient in-memory management and comparison. Its specialized `Hashtbl` module enables imperative key-value associations with deterministic traversal, supporting advanced uses such as memoization and safe value computation with fallbacks. A derived submodule extends these tables with type-specific operations including deep copying, equality, and project-aware membership, ideal for handling structurally identified term collections. Another submodule defines a key type enforcing physical equality, providing utilities tailored for term identifiers within the E-ACSL plugin.",
      "description_length": 779,
      "index": 1401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.S-Operators",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operator primitives for sequencing and transforming computations within a combined Reader, Writer, and State monadic context. It supports binding operations through infix operators like `>>-`, `let*`, `>>-:`, and `let+`, enabling fluent composition of effectful actions that read from an environment, write to a log, and manipulate state. These operators are used to build transformations that thread environment, state, and writer values through a computation pipeline without explicit parameter passing.",
      "description_length": 525,
      "index": 1402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Pred_or_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents a union of predicates and terms, using structural equality for predicates and physical identity for terms, with core operations like `equal`, `compare`, `hash`, `copy`, and `pretty` to manage logical expressions and terms in static analysis. It includes a hash table module for heterogeneous keys supporting memoization and project-aware lookups, a map module for ordered key-value storage with mixed equality semantics, and a set module for collections of predicates and terms with precise membership and traversal. These components enable tasks such as grouping logically equivalent predicates, tracking term identities in analysis passes, and transforming symbolic expressions with correct equivalence checks. Example uses include memoizing analysis results by term identity, merging predicate-based mappings, and filtering term sets during symbolic rewriting.",
      "description_length": 886,
      "index": 1403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Bimap.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a bidirectional mapping between keys using two hash tables, allowing efficient lookups in both directions. It supports operations to add mappings, retrieve associated keys in either direction, and manage chains of mappings with functions like `tail`, `head`, and their optional variants. Use cases include maintaining inverse mappings for symbol tables, tracking forward and backward relationships in graphs, and managing paired identifiers in transformation pipelines.",
      "description_length": 492,
      "index": 1404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_binding",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic variable bindings within an environment, providing operations to add, retrieve, and remove associations between logic variables and their corresponding variable information. It works with environments (`E_ACSL.Env.t`), logic variables (`Frama_c_kernel.Cil_types.logic_var`), and variable info (`Frama_c_kernel.Cil_types.varinfo`). Used during logic expression evaluation to track variable instantiations and support substitution in symbolic reasoning tasks.",
      "description_length": 483,
      "index": 1405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions.Concurrency",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to check for and retrieve drop-in replacements for C library functions in the RTL. It operates on string identifiers representing function names. Use cases include resolving function calls during translation or analysis when targeting the RTL backend.",
      "description_length": 282,
      "index": 1406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_output",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages dynamic configuration options with stateful operations like setting, retrieving, and comparing values, while supporting aliases, visibility controls, and deprecation. It provides core data types for key-value collections and customizable serialization, enabling precise control over runtime settings such as analysis and logging behavior. The string-based submodule enforces constraints and tracks changes for parameters, while the category submodule allows dynamic control of output through named filters like `@default` and `@all`. Together, these components support complex configuration workflows, including managing E-ACSL widening output with persisted, versioned settings and backward-compatible aliases.",
      "description_length": 731,
      "index": 1407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_scope",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic scopes within an environment, providing operations to retrieve, extend, and remove logic variables. It supports scoped logic variable management by associating variables with their analysis information. Use cases include tracking logic variables during static analysis and controlling scope resets based on analysis needs.",
      "description_length": 348,
      "index": 1408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Ival_datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents integer value abstractions for static analysis, supporting equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership testing. It enables construction of efficient sets, maps, and hash tables over these abstractions, facilitating data manipulation in analysis passes. The ordered map submodule manages interval and integer keys with ordered traversal and transformation, useful for symbolic memory states, while the hash table submodule supports memoization and aggregation over structured keys. The set submodule provides ordered, immutable sets with union and intersection operations, enabling precise set-based analysis and ordered iteration.",
      "description_length": 714,
      "index": 1409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Memory_tracking.SpecialPointers",
      "library": "frama-c-e-acsl.core",
      "description": "Tracks properties of pointers in memory, such as whether they are freeable, writeable, or initialized. It analyzes CIL terms to determine pointer characteristics, aiding in precise memory modeling. Used during static analysis to ensure correct handling of pointer operations and memory safety.",
      "description_length": 293,
      "index": 1410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LF_env",
      "library": "frama-c-e-acsl.core",
      "description": "Implements a fixpoint algorithm environment for tracking and updating interval analysis of recursive logic functions. It maintains per-logic_info state including current profile, inferred interval, call arguments, and recursion depth to manage safe unification during analysis. Used to infer and refine value ranges for logic function parameters based on call-site arguments and recursive behavior.",
      "description_length": 398,
      "index": 1411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Error.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines functions to create and handle phase-specific exceptions like `Typing_error` and `Not_yet`, with support for error propagation through `result`-typed values. It works with exceptions, result types, and location data from CIL to manage errors during analysis phases. Use cases include raising and handling errors during type checking, memoization, and preprocessing, while formatting error messages with source locations.",
      "description_length": 440,
      "index": 1412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Interlang_force",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a mutable boolean state with lifecycle hooks, enabling toggling values, registering change listeners, and customizing command-line interactions for project-scoped flags. It supports serialization, default value restoration, and conditional documentation visibility, making it ideal for synchronizing interlanguage processing features across components. The core data type provides equality, comparison, hashing, and pretty printing operations, with deep copying and membership testing to ensure isolated configuration management during static analysis. Use cases include programmatically controlling feature activation and persisting analysis options tied to intermediate language transformations.",
      "description_length": 717,
      "index": 1413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Valid",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean state flag with support for direct manipulation, value change callbacks, and integration with Frama-C's state and command-line systems. It defines a dedicated boolean option type with operations for setting, querying, and persisting values, and works with structured data representations provided by its child module. The child module introduces a data type `t` with equality, comparison, and pretty-printing, along with utilities for structural inspection and project membership checks. Together, they enable runtime configuration of validation features through command-line arguments and structured logging of option states.",
      "description_length": 656,
      "index": 1414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Gmp.Z",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements arithmetic and comparison operations for arbitrary-precision integers using the GMP library. It provides functions to create and manipulate `mpz_t` variables, perform binary operations like addition and multiplication, and compare values with support for typed expressions. Concrete use cases include implementing precise integer computations in static analysis plugins and generating GMP-based code for arbitrary-precision arithmetic.",
      "description_length": 458,
      "index": 1415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Verbose",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages verbosity levels using integer parameters constrained by configurable bounds, with support for default values, update hooks, and integration with Frama-C's option system to enable user-defined aliases and state management for E-ACSL diagnostics. It provides structured data types with equality, comparison, hashing, and pretty printing operations, along with type descriptors and serialization support through packed representations. Child modules enhance control over logging behavior by enabling structured value management and precise comparison of verbose options during analysis. Example uses include defining logging thresholds, tracking verbosity state changes, and serializing verbose configurations for persistent or distributed analysis settings.",
      "description_length": 776,
      "index": 1416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages integer and string configuration options with support for command-line parsing, change tracking, and project-specific state management. It provides typed parameters with aliases, visibility controls, and deprecation markers, along with operations for validation, comparison, and serialization. The child modules extend this functionality by introducing widening argument categories, structured data types for argument representation, and validation logic for string-based parameters. Examples include parsing and enforcing valid function names, managing analysis modes through categories like `@default`, and serializing parameter states across sessions.",
      "description_length": 674,
      "index": 1417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Id_term_in_profile",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents terms paired with profiles that specify intervals for free variables, used in logic functions or predicates. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks and deep copying. The associated hash table module enables efficient mapping of these profiled terms to arbitrary values, supporting insertion, safe lookup, and structured updates. Use this module to manage and analyze logic expressions with variable constraints during static analysis, enabling precise tracking of variable occurrences and interval-based reasoning.",
      "description_length": 638,
      "index": 1418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp_types.S",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for working with a specific GMP type, including retrieving the type itself, checking type equivalence, and handling pointer representations. It operates on `Frama_c_kernel.Cil_types.typ` values, providing direct utilities for type inspection and initialization. Concrete use cases include type validation during GMP value manipulation and setting up type representations in CIL-based analyses.",
      "description_length": 424,
      "index": 1419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang.Pretty",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements precise pretty-printing routines for Interlang constructs such as variables, expressions, and memory locations. It operates directly on Interlang's core data types including `varinfo`, `lval`, `exp`, and their subcomponents, producing human-readable representations suitable for debugging or logging. Each function formats a specific Interlang element, ensuring structural fidelity during inspection without altering the data.",
      "description_length": 449,
      "index": 1420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Inductive.Derived_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module maps inductive predicates to derived logic functions generated during their transformation into executable form. It provides `iter` to traverse these derived functions, applying a function to each predicate-function pair stored in the hash table. It directly supports processing logic functions derived from inductive predicate definitions that conform to generalized Horn clauses.",
      "description_length": 393,
      "index": 1421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Run",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages runtime state for boolean options with support for toggling values, registering change callbacks, and integrating with Frama-C's project system for persistence. It defines the boolean type `t` and operations like `on`, `off`, and hook registration, enabling dynamic configuration during execution or via command-line flags. The child module enhances `t` with equality, comparison, and serialization capabilities, supporting introspection and structured value handling. Together, they allow managing, comparing, and persisting runtime options, such as enabling analysis features or tracking configuration changes across projects.",
      "description_length": 648,
      "index": 1422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Assert_print_data",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean state to control the display of assertion-related data, with functions to enable or disable output. It integrates with project state through hooks and metadata, allowing the configuration of diagnostic displays during execution. The child module enhances this by defining a structured data type with equality, comparison, and pretty-printing operations, supporting type-safe manipulation of descriptors and representants for logging and analysis. Together, they enable conditional output of rich, structured assertion data based on runtime configuration.",
      "description_length": 584,
      "index": 1423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Rtl.Symbols",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides operations to check and retrieve symbols such as globals, kernel functions, and variable identifiers within the RTL context. It works with CIL types including `global`, `kernel_function`, and `varinfo`, and supports symbol lookups by name or via replacement logic. Concrete use cases include determining if a given variable or function is part of the RTL and resolving replacements for functions with associated RTL implementations.",
      "description_length": 453,
      "index": 1424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Conf",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines the configuration for building a RWS monad instance by specifying the environment, output, and state types. It includes operations to create and merge writer values, enabling the accumulation of side-effect data during computations. Concrete use cases include managing transformation environments, collecting generated variables, or tracking changes in compiler passes.",
      "description_length": 389,
      "index": 1425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.At_data",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines `at_data` values representing analysis data tied to program points, with operations for creation, comparison, and visualization. It supports tracking assertions, terms, and scopes, and provides core functions like `create`, `equal`, `compare`, and `pretty` for precise data handling. The Set submodule manages ordered sets of `at_data` with operations like union and membership checks, while the Map submodule implements ordered maps for associating program elements with analysis states. The Hashtbl submodule provides imperative hash tables for efficient storage and memoization, supporting ordered traversal and project-aware data handling.",
      "description_length": 663,
      "index": 1426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Debug",
      "library": "frama-c-e-acsl.core",
      "description": "The module manages a global mutable integer state with constrained value ranges, supporting operations to set, increment, reset, and validate values, while integrating change hooks, value aliases, and serialization via `Frama_c_kernel`. Its child module defines a structured data type with equality, comparison, and pretty-printing operations, enabling precise representation and manipulation of debug information within project skeletons. Together, they support configuration systems and debugging tools where state evolution must adhere to dynamic constraints and maintain structured, serializable debug metadata. Example uses include tracking analysis state in E-ACSL or enforcing valid parameter ranges in interactive debugging interfaces.",
      "description_length": 743,
      "index": 1427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions.Libc",
      "library": "frama-c-e-acsl.core",
      "description": "This module identifies and maps C standard library functions to their RTL equivalents, checking for replacements and equivalence. It provides predicates to recognize specific functions like `memcpy`, `memset`, VLA allocators, and `printf`-like functions, both from function names and expressions. It also generates abbreviated type strings for variadic function arguments and exposes the name of the actual `alloca` implementation used at link time.",
      "description_length": 449,
      "index": 1428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Widening_arguments_base",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages integer parameters with command-line configurability, value tracking hooks, and bounded constraints, integrating with a state system to ensure consistent updates. It defines a structured data type with equality, comparison, and pretty-printing operations, supporting descriptors for abstract domain parameters and deep copying over project skeletons. Users can define configurable analysis options with default values and serialization rules, track changes through hooks, and enforce valid value ranges during dynamic adjustments. Example uses include tuning static analysis precision and synchronizing domain-specific parameters across analysis phases.",
      "description_length": 673,
      "index": 1429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.LFProf",
      "library": "frama-c-e-acsl.core",
      "description": "This module represents logic functions and predicates with detailed argument profiles, offering equality, comparison, hashing, and deep copying operations to support static analysis tasks like signature comparison and project membership checks. Its hash table submodule enables efficient keyed access, ordered traversal, and memoization, useful for caching analysis results and structured iteration. The finite map submodule enhances this with metadata-rich keys, typed storage, and merging capabilities for tracking and transforming function properties across analyses. The set interface provides union, intersection, and filtering operations with strict uniqueness, supporting aggregation and canonical representation of logic entities during verification tasks.",
      "description_length": 764,
      "index": 1430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.Make",
      "library": "frama-c-e-acsl.core",
      "description": "This module combines reader, writer, and state capabilities into a single monadic structure, enabling computations that access an environment, accumulate side outputs, and manipulate state. It provides core operations like `read`, `write`, and `get`/`set`/`modify`, with execution starting from an initial environment and state, ideal for structured term transformation and context-sensitive analysis. Submodules extend this functionality to list and option types, supporting effectful traversals and transformations, and include utilities like conditional execution via `only_if`. Examples include collecting metadata during AST traversal, accumulating logs over lists, and selectively applying stateful actions based on flags.",
      "description_length": 728,
      "index": 1431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Monad_rws.S-Bool",
      "library": "frama-c-e-acsl.core",
      "description": "`only_if` conditionally executes a monadic action based on a boolean value. If the boolean is `true`, the action is performed; otherwise, it is skipped. This function is useful for integrating conditional logic into monadic computations that involve environment, state, and writer effects.",
      "description_length": 289,
      "index": 1432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Options.Share",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages paths related to a shared directory for the E-ACSL plugin. It provides functions to set, retrieve, and check the status of a directory path, as well as to resolve specific files or subdirectories within that path. It is used to locate plugin resources such as configuration files or shared libraries during execution.",
      "description_length": 337,
      "index": 1433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_ats.Free",
      "library": "frama-c-e-acsl.core",
      "description": "Translates E-ACSL \\at() terms into C code by identifying and managing free statements that must be inserted into functions. Works with `kernel_function` and `stmt` types from the Frama-C CIL framework. Used during E-ACSL instrumentation to generate valid C implementations of logical expressions at specific program points.",
      "description_length": 323,
      "index": 1434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Project_name",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages string-based configuration parameters with validation, state tracking, and change notifications, integrating with project state systems for dynamic reconfiguration and CLI interactions. It supports operations on strings and string lists, with utilities for defining valid values and function name validation, enabling runtime checks and customizable serialization workflows. A child module enhances it with structured data types for E-ACSL, offering comparison, hashing, and type-safe manipulation of project-specific values, including deep copying and membership checks. Together, they support use cases like synchronizing config changes with Frama-C's lifecycle, tracking analysis settings, and managing typed project data across sessions.",
      "description_length": 761,
      "index": 1435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Concurrency",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean concurrency setting in E-ACSL's analysis framework, providing operations to toggle its state, register callbacks for value changes, and define serialization behavior. It integrates with Frama-C's project and kernel systems to control analysis workflows, using a boolean type `t` that supports equality, comparison, hashing, and pretty-printing. The child module enhances this by defining a structured, type-safe representation of concurrency options, enabling deep copying, descriptors, and packed storage for use in static analysis configurations. Example uses include enabling or disabling concurrency checks, where state changes propagate to project settings or serialization logic.",
      "description_length": 715,
      "index": 1436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Context",
      "library": "frama-c-e-acsl.core",
      "description": "Maintains and manipulates contextual information during program analysis. It provides a `save` function to persist the current analysis state, working with the `E_ACSL.Env.t` type that represents the environment context. Useful for tracking variable bindings and scope information at specific points in the code.",
      "description_length": 312,
      "index": 1437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Session",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages the session directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations like setting a custom session directory, checking its existence, and ensuring paths are created on demand. Concrete use cases include storing transient analysis results or logs in a structured directory specific to the plugin's execution session.",
      "description_length": 469,
      "index": 1438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Temporal_validity",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a boolean parameter that controls temporal validity checks, allowing runtime toggling of enforcement during analysis through direct operations to set, retrieve, and track changes via hooks. It integrates with Frama-C's state system for command-line aliases, default values, and project-specific configurations, supporting use cases like selective check activation or user-driven settings. The child module defines a structured data type with equality, comparison, and pretty-printing operations, used to represent and manipulate temporal validity options in the E-ACSL plugin. Together, they enable precise, configurable handling of temporal validity across analysis phases with support for deep copying, membership checks, and serialization.",
      "description_length": 762,
      "index": 1439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Builtins",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages command-line parameters through a core string set type (`t`) that supports standard set operations, value mutation, and change hooks, enabling dynamic tracking and cross-component synchronization. It integrates with submodules that handle string parameter validation, category management for option groups like `@default` or `@all`, and structured manipulation of complex configuration values with deep copying and project-aware membership checks. You can use it to enforce constraints on inputs such as file paths, manage runtime reconfiguration via hooks, and control global parsing behavior through categorized options. The combined functionality allows for structured, state-aware handling of command-line arguments in static analysis and configuration tools.",
      "description_length": 783,
      "index": 1440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Logic_env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a logic environment that tracks intervals for bound variables, combining a profile for function arguments with an association list for let-bound or quantified variables. It supports operations to add, refine, and look up variable intervals, and to construct or extract profiles. Concrete use cases include analyzing logical expressions during static analysis to track variable bounds and refine interval constraints.",
      "description_length": 436,
      "index": 1441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options.Replace_libc_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module controls a boolean configuration flag that determines whether standard library functions are substituted at runtime, enabling analysis tools to dynamically toggle libc interception. It defines a data type for representing replacement options, supporting operations like comparison, hashing, and pretty printing, along with utilities for integrating with project-specific data. The module allows tracking and serializing the state of function replacement, facilitating precise control during static analysis. Example usage includes enabling replacement for specific analysis phases or inspecting configuration values through comparison and printing functions.",
      "description_length": 670,
      "index": 1442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses_datatype.Annotation_kind",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines operations for managing and comparing annotation kinds used in static analysis. It provides equality, comparison, hashing, and pretty-printing functions for the `annotation_kind` type, along with utilities for deep copying and checking project membership. These functions support analysis-specific annotations in Frama-C, enabling precise handling of different specification constructs during verification.",
      "description_length": 426,
      "index": 1443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Env.Logic_env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages logic environments and profiles in a program analysis context. It supports operations to add logic variables with associated values, retrieve the current logic environment and profile, and manipulate the environment stack with push and pop operations. It is used during static analysis to track and update logical states associated with program variables.",
      "description_length": 375,
      "index": 1444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_trans",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a function `try_il_compiler` that attempts to compile E-ACSL predicates using a new intermediate language (Interlang) translation process, falling back to a direct-to-Cil compiler if the new method fails. It works with E-ACSL predicates and Cil expressions, specifically handling compilation errors by switching strategies. A concrete use case is compiling E-ACSL assertions into Cil code during static analysis, leveraging the most up-to-date translation approach while maintaining compatibility with legacy code.",
      "description_length": 535,
      "index": 1445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang",
      "library": "frama-c-e-acsl.core",
      "description": "The module introduces an intermediate language for E-ACSL-to-Cil compilation, centered around expressions (`exp`) and variables (`varinfo`) that blend features of Cil expressions and logic terms. It supports arithmetic and comparison operations while preserving source term origins to ensure accurate and position-equivalent Cil output. Submodule 1 handles variable representation, enabling precise tracking of logic variables during translation, while Submodule 2 provides detailed pretty-printing for expressions, variables, and memory locations. This structure enables tasks like inspecting intermediate code fidelity and structuring complex expressions for downstream compilation stages.",
      "description_length": 691,
      "index": 1446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interval_utils",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements operations on intervals represented by the `ival` type, including inclusion checks, joins, meets, and construction of intervals from integers or types. It provides functions to lift arithmetic operations, normalize intervals, and convert between intervals and C types or logic types. Use cases include static analysis of numeric ranges in C code, determining type compatibility, and computing bounds for variables in logical expressions.",
      "description_length": 460,
      "index": 1447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Logic_functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module generates C function implementations for logic functions defined in the specification, handling type-specific overloading and translation of terms and predicates to expressions. It works with abstract data types representing logic functions, terms, expressions, and environments, using Frama-C's kernel types for function and expression manipulation. Concrete use cases include translating logic function calls like `g(5)` and `g(10*INT_MAX)` into distinct C functions such as `g_1(int)` and `g_2(long)`, and inserting these generated functions into the global scope of the analyzed C file.",
      "description_length": 602,
      "index": 1448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Literal_strings",
      "library": "frama-c-e-acsl.core",
      "description": "This module maps string literals to unique variable identifiers, enabling tracking and retrieval of variables associated with specific string values. It provides operations to add, find, and fold over these associations, ensuring each string is bound to a fresh variable. Useful for analyses requiring distinct variable handling per string literal, such as slicing or constant propagation.",
      "description_length": 389,
      "index": 1449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Inductive",
      "library": "frama-c-e-acsl.core",
      "description": "This module processes inductive predicate definitions, converting them into a direct form suitable for translation into Cil by working with logic definitions and terms. It identifies inductive structures using `is_inductive`, extracts predicates with `extract_predicate`, and handles incomplete definitions through `is_fallthrough_term`. The child module maps these predicates to derived logic functions, enabling traversal and processing via `iter`, which applies functions to predicate-function pairs. Together, they support translating restricted inductive predicates into executable code while managing fallthrough cases and derived function generation.",
      "description_length": 657,
      "index": 1450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Contract",
      "library": "frama-c-e-acsl.core",
      "description": "This module processes ACSL contracts by translating them into C statements for runtime assertion checking. It operates on contract data structures derived from function or statement specifications, using location and environment information. Concrete use cases include converting preconditions and postconditions into executable checks during program analysis.",
      "description_length": 360,
      "index": 1451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Injector",
      "library": "frama-c-e-acsl.core",
      "description": "Injects monitoring code into a program to enforce and check runtime assertions specified in E-ACSL annotations. Works directly with the program's abstract syntax tree and annotation metadata. Used during the instrumentation phase of E-ACSL-enabled programs to insert checks for memory safety and behavioral contracts.",
      "description_length": 317,
      "index": 1452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Rte",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to retrieve runtime error (RTE) annotations for statements and expressions within a CIL-based analysis. It works with CIL types such as `kernel_function`, `stmt`, `exp`, and `code_annotation`, and includes a function to get state selections that include RTE dependencies. It is used to analyze and extract potential runtime errors from C code during static analysis.",
      "description_length": 397,
      "index": 1453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Build_pred_or_term",
      "library": "frama-c-e-acsl.core",
      "description": "This module builds and manipulates logical predicates and terms for static analysis, supporting first-order logic expressions over program syntax. It provides core operations to construct boolean constants, conditionals, let bindings, and labeled assertions, working with types like `predicate`, `term`, and `logic_body`. Users can generate verification conditions, encode program assertions, and apply custom transformations to logical expressions. Submodules extend these capabilities with specialized construction and traversal functions for both predicates and terms.",
      "description_length": 571,
      "index": 1454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Logic_normalizer",
      "library": "frama-c-e-acsl.core",
      "description": "This module preprocesses logical predicates and terms in the AST by guarding Pvalid and Pvalid_read clauses with Pinitialized and replacing Papp applications with Tapp terms, operating on CIL types like annotations, predicates, and terms. It transforms and stores normalized versions of these structures to improve precision in static analysis, while tracking relationships between original and generated entities. Key operations include predicate guarding, term replacement, and mapping between original and transformed variables and definitions. For example, it ensures that a normalized Pvalid clause includes a corresponding Pinitialized guard, and allows retrieving the source variable of a transformed logic variable via `origin_of_lv`.",
      "description_length": 742,
      "index": 1455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_array",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to generate C code for array comparisons and to translate runtime exceptions related to array references. It operates on expressions representing arrays and binary operations, producing equivalent logical expressions while updating the environment. It is used in contexts like array equality or inequality checks and handling annotations during static analysis.",
      "description_length": 392,
      "index": 1456,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Contract_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a `contract` type that represents function or statement contracts in C code, capturing their location, specification, and behavior metadata. It provides operations to manage named behaviors, including mappings from behavior names to indices and tracking whether all assume clauses were successfully translated. The module is used to support runtime checking of ACSL contracts by storing and managing the necessary C API structure bindings and translation state.",
      "description_length": 481,
      "index": 1457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Memory_translate",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements functions for translating memory-related operations into expressions, handling calls to memory functions like allocation or validity checks, and converting predicates and terms into expressions. It operates on types such as `E_ACSL.Assert.t`, `Frama_c_kernel.Cil_types` expressions, terms, and predicates, along with kernel functions and environments. It is used during static analysis to generate intermediate code for memory operations, supporting tasks like pointer validity and size conversion with GMP integers.",
      "description_length": 539,
      "index": 1458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines types and printers for representing logical scopes, annotations, and numeric values during E-ACSL analyses. It includes variants for logic variables, predicates, terms, and numeric types such as integers, floats, and rationals, along with structured data like `at_data` for tracking annotation context. It is used to model and manipulate logical expressions and their evaluation states in static analysis passes.",
      "description_length": 432,
      "index": 1459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Analyses",
      "library": "frama-c-e-acsl.core",
      "description": "This module performs preprocessing tasks and resets analysis results for E-ACSL translation. It operates on internal analysis data structures generated during verification. Use it to prepare or clean up analysis state before or after translation steps.",
      "description_length": 252,
      "index": 1460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_ats",
      "library": "frama-c-e-acsl.core",
      "description": "This module translates E-ACSL \\at() terms and predicates into executable C code during CIL processing, managing both immediate translation and retrieval of cached results. It operates on statements, terms, and predicates within functions and environments, generating C expressions and updated assertions while coordinating with memory management through its Malloc and Free submodules. The Malloc submodule tracks and manipulates dynamic memory allocations for kernel functions, enabling correct insertion and removal of `malloc` statements. The Free submodule identifies and inserts necessary `free` statements at specific program points, ensuring proper memory cleanup in the generated C code.",
      "description_length": 695,
      "index": 1461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Global_observer",
      "library": "frama-c-e-acsl.core",
      "description": "This module tracks global variables and manages their observation throughout a program's lifecycle. It provides functions to add variables for observation, handle their initializers, and generate C functions for initializing and cleaning up observers. It works directly with CIL types like `varinfo`, `offset`, and `init`, and is used to inject instrumentation code for global variable monitoring in generated C code.",
      "description_length": 417,
      "index": 1462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Monad_rws",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a combined Reader, Writer, and State monad for managing environments, accumulating auxiliary output, and maintaining mutable state within pure computations. It provides core operations `read`, `write`, `get`, `set`, and `modify`, enabling structured transformations of terms with context-sensitive analysis, logging, and stateful manipulations. Submodules extend this functionality to lists and optional values, supporting effectful traversals and conditional execution via `only_if`. Specific use cases include variable binding analysis, code generation with logging, and environment-aware transformations of abstract syntax trees.",
      "description_length": 655,
      "index": 1463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Error",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides core error-handling mechanisms including exceptions and result types to manage errors during typing, preprocessing, and unsupported operations. It supports structured error propagation with location-annotated messages, allowing operations like raising typing errors, handling failed phases, and mapping over results while preserving error states. Submodules extend this functionality with phase-specific exceptions such as `Typing_error` and `Not_yet`, and utilities for error handling in transformation pipelines with fallbacks and formatted messages. Example uses include signaling unhandled language constructs, managing incomplete preprocessing, and propagating errors through analysis phases with source location tracking.",
      "description_length": 748,
      "index": 1464,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Translate_rtes",
      "library": "frama-c-e-acsl.core",
      "description": "Translates RTE annotations into runtime checks for a given function and environment. Works with CIL types and environments to generate code annotations that enforce runtime assertions during program execution. Useful for integrating dynamic checks into C programs during static analysis.",
      "description_length": 287,
      "index": 1465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Smart_stmt",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates C statements for instrumentation purposes, focusing on memory operations, control flow, and structure initialization. It works directly with CIL types such as `stmt`, `block`, `lval`, `exp`, and `varinfo` to build specific statements like assignments, function calls, and memory handling operations. Concrete use cases include generating code for memory allocation tracking, field assignments in structures, conditional branches, and injecting initialization or read-only markers into C code.",
      "description_length": 531,
      "index": 1466,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Assigns",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to analyze and retrieve variable assignments in the context of formal verification. It operates on logic variables and expressions, generating lists of assigned variables and their corresponding values based on a given location and environment. It is used to track modifications in memory or state during program verification, particularly for handling GMP variables and generating assigns clauses in annotations.",
      "description_length": 444,
      "index": 1467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Lscope",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a collection of logic variables using physical equality for precise control over variable identity, enabling operations to add, remove, and retrieve variables while tracking their usage within logical terms. It integrates analysis scope management through a dedicated submodule that defines equality, comparison, and pretty-printing for scopes, supporting tasks like context comparison and project-based analysis in static verification tools. The combined functionality allows for structured manipulation of logic variables and their enclosing scopes, facilitating tasks such as binding tracking and context-sensitive analysis. Example uses include maintaining variable bindings during term traversal and managing analysis contexts in formal verification workflows.",
      "description_length": 785,
      "index": 1468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Typing",
      "library": "frama-c-e-acsl.core",
      "description": "This module infers minimal C types for integer and rational expressions through interval analysis, determining when operations require GMP arithmetic or safe coercions between types like int, char, or narrower/wider integral types. It processes CIL abstract syntax trees and logic variables to compute type constraints, ensuring correctness in expressions with potential overflows or mixed-type operations. Its use cases include optimizing type precision in code annotations and verifying safe arithmetic in static analysis scenarios where overflow risks must be explicitly managed.",
      "description_length": 582,
      "index": 1469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Libc",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements code generation for libc functions, specifically handling memory model updates during analysis. It provides operations to determine if a function writes memory and to generate code that updates the memory model accordingly. It works with CIL variables, expressions, and kernel functions, targeting use cases like modeling the effects of functions such as `memcpy` or `memset` on memory.",
      "description_length": 409,
      "index": 1470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Main",
      "library": "frama-c-e-acsl.core",
      "description": "This module initializes and registers the E_ACSL plugin within the Frama-C kernel, enabling integration of the plugin's analysis capabilities into the Frama-C framework. It operates on Frama-C's internal structures, specifically the kernel's plugin registration system. A concrete use case is loading the E_ACSL plugin when launching Frama-C to perform runtime verification of C programs.",
      "description_length": 388,
      "index": 1471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Translate_predicates",
      "library": "frama-c-e-acsl.core",
      "description": "This module converts ACSL predicates into C expressions for runtime checking, translating them within a given environment and function context. It handles both generalized and untyped predicate transformations, supporting optional RTE annotations and message predicates. Use cases include generating executable checks for assertions and integrating formal specifications into C code during analysis.",
      "description_length": 399,
      "index": 1472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Labels",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles pre-analysis of labeled terms and predicates in CIL code, determining where translations should occur. It processes statements to extract labeled elements and tracks translation points using CIL statement structures and logic terms. Used during static analysis to prepare labeled assertions and terms for further processing in verification workflows.",
      "description_length": 370,
      "index": 1473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Gmp",
      "library": "frama-c-e-acsl.core",
      "description": "This module interfaces directly with the GMP library to support arbitrary-precision integer and rational number operations, generating appropriate CIL code for variable initialization, assignment, and arithmetic. It works with `mpz_t` for integers and `mpq_t` for rationals, offering operations such as addition, multiplication, comparison, and type conversion, all integrated into CIL expressions and statements. The integer submodule enables precise computations in static analysis plugins, while the rational submodule supports manipulation of real-number expressions in ACSL specifications and normalization of decimal inputs. Together, they allow embedding GMP-based arithmetic into CIL code for accurate numerical reasoning during verification.",
      "description_length": 750,
      "index": 1474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.E_acsl_visitor",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines a visitor pattern for traversing and processing global declarations and annotations in CIL (C Intermediate Language) code, specifically tailored for E-ACSL transformations. It provides a `case_globals` function that dispatches to specialized handlers based on the type of global element, such as variable definitions, function declarations, or annotations. Use cases include translating or analyzing E-ACSL assertions, handling built-in symbols, and processing global variables and functions during instrumentation or verification workflows.",
      "description_length": 561,
      "index": 1475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Logic_aggr",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to analyze and classify aggregate types in CIL. It includes `get_array_typ_opt` to extract array type details and `get_t` to determine if a type is an array, struct, union, or not an aggregate. It works directly with CIL types, supporting use cases like type checking and structure manipulation in static analysis.",
      "description_length": 345,
      "index": 1476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Env",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages environments for tracking variables, scopes, and statements during code analysis and transformation, supporting tasks like invariant enforcement and contract verification. It provides data types for environments (`t`), logic variables, and statements, with operations to create variables, manipulate scopes, insert statements, and save analysis state. Submodules handle logic variable bindings, scoped variable management, context persistence, and logic environment stacks, enabling tasks like symbolic reasoning and static analysis. Examples include adding logic variables with associated values, saving the current environment state before transformations, and managing scoped variable instantiations during analysis.",
      "description_length": 739,
      "index": 1477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Bimap",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a bidirectional mapping between keys using two hash tables, enabling efficient lookups in both directions. It supports operations to add mappings, retrieve associated keys in either direction, and manage chains of mappings with functions like `tail`, `head`, and their optional variants. Use cases include maintaining inverse mappings for symbol tables, tracking forward and backward relationships in graphs, and managing paired identifiers in transformation pipelines. Example operations include inserting a key pair and retrieving either key from its counterpart, or traversing chains of linked keys.",
      "description_length": 625,
      "index": 1478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Varname",
      "library": "frama-c-e-acsl.core",
      "description": "Handles variable name generation for different scopes, providing functions to retrieve fresh names based on expressions and to reset local name counters. Works with string identifiers and expression nodes from the CIL framework. Used when generating intermediate variables during static analysis to avoid naming conflicts.",
      "description_length": 322,
      "index": 1479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_tracking",
      "library": "frama-c-e-acsl.core",
      "description": "This module computes a sound over-approximation of which program elements must be tracked for accurate memory modeling during static analysis. It provides direct checks on variables, expressions, and left-values to determine tracking requirements, and identifies concurrent functions when concurrency is disabled. The child module analyzes CIL terms to track pointer properties such as freeability, writability, and initialization status. Together, they enable precise memory safety analysis by determining both which program elements require tracking and what memory properties must be preserved.",
      "description_length": 597,
      "index": 1480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Widening",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements widening operations for interval and profile analysis in static program verification. It provides functions to compute the widened interval or profile given two consecutive analysis states, using logic information from the kernel to guide the approximation. These operations are essential for accelerating the convergence of fixed-point computations in abstract interpretation.",
      "description_length": 400,
      "index": 1481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Memory_observer",
      "library": "frama-c-e-acsl.core",
      "description": "This module manipulates memory tracking information in an environment by inserting calls to memory management functions. It operates on variables from CIL's intermediate representation, using lists or sets of variable identifiers to determine which memory blocks to track, duplicate, or remove. It is used during instrumentation to maintain accurate memory state by adding specific memory operation calls to the environment.",
      "description_length": 424,
      "index": 1482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translation_error",
      "library": "frama-c-e-acsl.core",
      "description": "This module defines exception constructors and error-handling utilities for managing translation phases. It works with result types and functions that may raise specific exceptions like `Typing_error`, `Not_yet`, or `Not_memoized`, often tied to location information. Functions support error propagation, mapping over results, and handling failed preprocessing steps in translation passes.",
      "description_length": 389,
      "index": 1483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Misc",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides utilities for analyzing and manipulating logic expressions, terms, and types in E-ACSL, with core operations for extracting base pointers, retrieving variable and type information, and checking term properties like bitfield usage. Its child module enhances term handling through physical equality-based representations, offering efficient equality checks, hashing, and deep copying, alongside specialized hashtables for deterministic storage and retrieval. These structures support advanced functionality such as memoization, type-specific operations, and project-aware term management. Examples include processing logic annotations during static analysis and managing expressions in E-ACSL contracts using identity-preserving term tables.",
      "description_length": 760,
      "index": 1484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Smart_exp",
      "library": "frama-c-e-acsl.core",
      "description": "This module constructs and manipulates CIL expressions for low-level memory operations, logical negation, and pointer arithmetic. It operates on CIL expressions (`exp`) and types (`typ`), handling tasks like dereferencing pointers, accessing array elements, and generating null pointers. Concrete use cases include building expressions for memory reads, logical conditions, and array indexing during static analysis or transformation of C code.",
      "description_length": 444,
      "index": 1485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Options",
      "library": "frama-c-e-acsl.core",
      "description": "This module implements a comprehensive logging and configuration system for E-ACSL, centered around adjustable verbosity levels and categorized diagnostics. It provides core data types for boolean, integer, and string-based configuration options, each supporting operations like setting, querying, validation, serialization, and change tracking through hooks. These options integrate with command-line interfaces, project state management, and runtime analysis workflows, enabling use cases such as enabling concurrency checks, controlling format string validation, configuring cache directories, and managing widening parameters with dynamic constraints. Submodules enhance these capabilities with structured types that support equality, comparison, pretty printing, and deep copying, allowing precise manipulation and persistence of analysis settings across sessions and plugins.",
      "description_length": 881,
      "index": 1486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Assert",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages assertion contexts by tracking data contributions for runtime checks. It supports creating, merging, and cleaning assertion data structures, and registering expressions linked to terms, predicates, or custom messages. It is used to generate runtime assertions with associated metadata, such as locations, names, and error messages, ensuring proper memory management through cleanup calls.",
      "description_length": 408,
      "index": 1487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_terms",
      "library": "frama-c-e-acsl.core",
      "description": "This module translates E-ACSL terms into C expressions or intermediate language expressions, handling type conversion and environment updates. It operates on ACSL terms, CIL types, and environments, producing expressions suitable for use in generated C code or analysis. Concrete use cases include converting logical assertions into runtime checks and translating specifications for static analysis tools.",
      "description_length": 405,
      "index": 1488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_build",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides smart constructors for translating CIL variables and expressions into intermediate language representations, capturing type and origin information. It supports operations to build expressions from variables, integers, lvalues, and sizeof constructs, producing host values tied to a specific term structure. For example, it can convert a C variable into an abstract host value or construct a typed expression from a C expression node during static analysis.",
      "description_length": 477,
      "index": 1489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Bound_variables",
      "library": "frama-c-e-acsl.core",
      "description": "This module processes quantified predicates by extracting and refining variable bounds and guards. It works with logic variables, terms, and predicates to simplify and store preprocessed quantifier information. Use it to analyze or transform logical expressions involving bounded quantification in Frama-C's AST.",
      "description_length": 312,
      "index": 1490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Literal_observer",
      "library": "frama-c-e-acsl.core",
      "description": "Replaces literal strings in C expressions with observed variables during analysis. Operates on C expressions and environment state, tracking substitutions for further processing. Useful for analyzing string handling in C code where literal strings need to be monitored or modified.",
      "description_length": 281,
      "index": 1491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Typed_number",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a function `add_cast` that converts number expressions to be compatible with a given typing context, handling both string-represented numbers and C number types. It operates on expressions, types, and terms from the CIL framework, using location and environment information to ensure correct casting. Concrete use cases include type coercion during static analysis of C code involving numeric literals and expressions.",
      "description_length": 439,
      "index": 1492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Loops",
      "library": "frama-c-e-acsl.core",
      "description": "This module handles loop-specific transformations and annotations in CIL code, inserting verification logic for loop invariants and variants. It works with CIL statements, kernel functions, and environment structures to manage variable scopes and logic transformations. It is used to generate nested loops from logic variables and translate formal predicates and terms into executable expressions for verification purposes.",
      "description_length": 423,
      "index": 1493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Analyses_datatype",
      "library": "frama-c-e-acsl.core",
      "description": "This collection of modules provides precise numeric and symbolic abstractions for static analysis, centered around interval arithmetic, logic variables, and structured data mappings. Core data types include numeric intervals, logic terms with profiles, function argument profiles, and program-point annotations, each supporting equality, comparison, and pretty-printing, alongside set, map, and hash table structures for efficient manipulation. You can use these modules to track variable bounds across function calls, perform fixpoint analysis on recursive logic, memoize analysis results by term identity, and manage structured annotations for verification. Specific tasks include merging interval constraints, refining logic function parameters, and modeling symbolic expressions with correct equivalence checks.",
      "description_length": 815,
      "index": 1494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Functions",
      "library": "frama-c-e-acsl.core",
      "description": "This module orchestrates function annotation checks and instrumentation decisions in E-ACSL, analyzing CIL expressions and kernel functions to determine runtime monitoring behavior. It integrates name management, symbol resolution, and C-to-RTL function mapping through its submodules, enabling precise control over generated instrumentation code. Key operations include identifying instrumented symbols, resolving C library function replacements in RTL, and generating type abbreviations for variadic arguments. Examples include prefixing runtime symbols, checking if a function requires monitoring, and mapping `memcpy` calls to their RTL equivalents during translation.",
      "description_length": 672,
      "index": 1495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Translate_annots",
      "library": "frama-c-e-acsl.core",
      "description": "This module translates ACSL annotations into C statements for runtime assertion checking, integrating them into the environment. It processes function preconditions, postconditions, and code annotations' preconditions and postconditions. Used during static analysis to generate checks that validate program properties at runtime.",
      "description_length": 329,
      "index": 1496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Rtl",
      "library": "frama-c-e-acsl.core",
      "description": "This module bridges the RTL's AST with the user's source code, ensuring precise alignment between low-level RTL constructs and high-level source structures during verification. It supports operations to associate RTL elements with CIL types like `global`, `kernel_function`, and `varinfo`, enabling symbol resolution and replacement logic. Submodules allow querying for specific symbols, checking their presence in the RTL, and mapping functions to their RTL counterparts. For example, it can determine whether a function has an RTL implementation or resolve a variable's RTL representation for analysis.",
      "description_length": 604,
      "index": 1497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Translate_utils",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions for translating logical constructs and GMP integers into C expressions, handling conditional logic, comparisons, and environment management during translation. It operates on data types such as `term`, `exp`, `kernel_function`, `Env.t`, and `Assert.t`, primarily used in the context of C code generation and static analysis. Concrete use cases include converting logic conditions to C expressions, translating GMP values to `size_t` with RTE checks, and managing environments during assertion translation.",
      "description_length": 536,
      "index": 1498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Prepare_ast",
      "library": "frama-c-e-acsl.core",
      "description": "This module prepares the abstract syntax tree (AST) for E-ACSL generation by transforming function definitions, removing term sharing, and adding alignment attributes where necessary. It works with CIL types, particularly statements, expressions, and variable information. It is used to ensure the generated E-ACSL code is compatible with the runtime verification framework by restructuring the AST before code generation.",
      "description_length": 422,
      "index": 1499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interlang_gen",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides a monadic framework for generating Interlang expressions during the translation of E-ACSL to Cil, combining reader, writer, and state effects to manage context, output accumulation, and transformations. It supports operations like `binop` for converting Cil binary operators, `run`, `bind`, and `return`, along with helpers such as `not_covered` for handling unsupported elements, and submodules for conditionals, list processing, option handling, and sequencing. These components work together to enable structured translation of logic expressions into Interlang, allowing tasks like selectively generating code based on analysis results, building complex expressions from simpler parts, and mapping over lists of predicate elements while preserving variable bindings and type information.",
      "description_length": 811,
      "index": 1500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Gmp_types",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages GMP value handling by integrating runtime type manipulation with static analysis requirements. It provides core operations for initializing and checking GMP types, including unbounded integers and rational numbers, using `Frama_c_kernel.Cil_types.typ` for type representation. Submodules support type retrieval, pointer variant handling, and equivalence checks, enabling precise type analysis during CIL code transformations. Examples include validating GMP integer and rational types during static analysis and setting up their proper type representations in transformation passes.",
      "description_length": 602,
      "index": 1501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "E_ACSL.Temporal",
      "library": "frama-c-e-acsl.core",
      "description": "This module provides functions to enable temporal memory error detection, update environments for tracking referent numbers across function calls and statements, and generate tracking statements for global initializers. It operates on CIL types such as kernel functions, statements, and variable initializers, alongside environment structures. It is used to detect stale pointer dereferences by inserting tracking logic during analysis.",
      "description_length": 436,
      "index": 1502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Quantif",
      "library": "frama-c-e-acsl.core",
      "description": "Converts quantified predicates into expressions, working with CIL types such as kernel functions, environments, and predicates. It returns a converted expression along with an updated environment. This module is used during static analysis to handle logical quantifiers in annotations, enabling further processing by tools like value analysis or proof engines.",
      "description_length": 360,
      "index": 1503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Builtins",
      "library": "frama-c-e-acsl.core",
      "description": "This module manages a database of E-ACSL built-in functions, providing operations to check existence (`mem`), retrieve (`find`), and update (`update`) their associated variable information. It works directly with string identifiers and `varinfo` structures from the Frama-C CIL library. Concrete use cases include resolving built-in function symbols during translation or modifying their properties dynamically during analysis.",
      "description_length": 427,
      "index": 1504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Exit_points",
      "library": "frama-c-e-acsl.core",
      "description": "This module identifies points in a function where variables must be explicitly deleted or re-recorded due to early scope exits such as gotos, breaks, or continues. It processes CIL function definitions to analyze control flow and maintain accurate tracking of local variables across such jumps. It is used during instrumentation to ensure correct memory management for variables in transformed code.",
      "description_length": 399,
      "index": 1505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL.Interval",
      "library": "frama-c-e-acsl.core",
      "description": "This module computes intervals for integer and real number terms based on their possible values, using type information from C variables and registered logic variables. It provides functions to infer intervals for terms, check inclusion within types, and preprocess terms and annotations to compute and store interval information. Concrete use cases include optimizing static analysis by narrowing variable ranges and validating term constraints in program annotations.",
      "description_length": 469,
      "index": 1506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "E_ACSL",
      "library": "frama-c-e-acsl.core",
      "description": "The E_ACSL system enables translation and analysis of formal specifications embedded in C code by integrating logic predicates, intermediate representations, and runtime instrumentation. Core data types include logic terms, predicates, intervals (`ival`), CIL expressions, and intermediate language (`exp`, `varinfo`) structures, manipulated through operations like translation, normalization, and monadic environment tracking. Users can compile E-ACSL assertions into executable C code, generate logic function implementations, analyze memory and numeric ranges, and inject runtime checks for contracts and RTE annotations. Specific tasks include converting quantified predicates into expressions, tracking global variables, handling GMP arithmetic, and translating inductive definitions into executable form while preserving source fidelity and analysis precision.",
      "description_length": 866,
      "index": 1507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_types.S",
      "library": "frama-c-eva.gui",
      "description": "This module defines operations for pretty-printing and comparing GUI-related result and after-execution values, along with extracting variable information from results. It works with abstract `value` types wrapped in `gui_res` and `gui_after` structures. Concrete use cases include displaying analysis outcomes in a formatted way, checking result equality for regression testing, and gathering variables involved in GUI interactions.",
      "description_length": 433,
      "index": 1508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates program elements such as l-values, expressions, terms, and predicates across multiple callstacks, producing results like offset maps, zones, or lattice bounds. It operates on abstract domains, CIL types, and GUI-specific location and callstack data. Concrete use cases include evaluating expressions in a GUI context, determining memory zones for l-values, and checking predicate validity with respect to abstract states.",
      "description_length": 443,
      "index": 1509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Eval",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates expressions, l-values, and function calls within a specific analysis state, producing valuations and values that capture computed results and associated alarms. It operates on expressions, l-values, and locations within a state, handling forward and backward propagation of constraints, value reduction, and function interpretation. Concrete use cases include evaluating conditions for program slicing, computing values for debugging or visualization, and refining analysis states based on assumed expression values.",
      "description_length": 538,
      "index": 1510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Map-Make",
      "library": "frama-c-eva.gui",
      "description": "This module implements a map structure over a user-defined `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing for values of the map type. It supports concrete use cases such as tracking and analyzing evaluation results across different project states in a GUI environment, where each map value corresponds to a specific data value defined by the `Data` module. The module also includes functionality for deep copying and checking membership based on project-specific predicates.",
      "description_length": 528,
      "index": 1511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Interferences",
      "library": "frama-c-eva.gui",
      "description": "This module tracks and manages interferences between concurrent threads during static analysis. It provides functions to inject interference data into abstract states, update interference representations from analysis results, and check whether interferences exist after specific transitions. It operates on thread analysis states, interference sets, and control flow transitions, specifically supporting concurrency analysis by capturing memory accesses that may affect other threads.",
      "description_length": 485,
      "index": 1512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Val",
      "library": "frama-c-eva.gui",
      "description": "The module type centers on an abstract value type `Analysis.Val.t` designed for static analysis tasks, supporting lattice operations (join, top), type-aware equality checks, and structured manipulation through",
      "description_length": 209,
      "index": 1513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_callstacks_manager.Input",
      "library": "frama-c-eva.gui",
      "description": "This module defines the input interface for managing callstack-based value displays in the GUI's \"Values\" panel. It specifies operations to format and compare GUI-specific value representations (`gui_res`, `gui_after`) and to generate value data for lvalues in specific program locations. These functions enable the panel to show and update analysis results tied to user-selected callstacks and expressions.",
      "description_length": 407,
      "index": 1514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Compute",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates program expressions and statements during static analysis, handling operations like computing initial states, analyzing function calls, and propagating abstract values through control flow. It operates on abstract states, locations, and values tied to CIL kernel functions and statements. Concrete use cases include evaluating l-values, expressions, and predicates at specific program points during the Eva analysis pass.",
      "description_length": 443,
      "index": 1515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Hashtbl-Make",
      "library": "frama-c-eva.gui",
      "description": "This module implements a hash table data structure specialized for analysis domains, where keys map to values of type `Data.t`. It provides standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate analysis results that are associated with specific Frama-C projects.",
      "description_length": 381,
      "index": 1516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.Make",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates expressions, l-values, terms, and predicates within a GUI context, producing results like offset maps, zones, or lattice bounds. It operates on data types such as `Analysis.Dom.t`, `Frama_c_kernel.Cil_types.lval`, `term`, and `predicate`, using evaluation functions parameterized by location and callstack information. Concrete use cases include computing memory zones for l-values, evaluating term expressions under specific environments, and checking predicate validity with associated reduction statuses.",
      "description_length": 529,
      "index": 1517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Hashtbl",
      "library": "frama-c-eva.gui",
      "description": "This module offers specialized hash table operations for domain-specific keys (`Analysis.Dom.t`) and values, supporting creation, modification, ordered iteration, and value-based comparisons. It provides utilities like safe key lookup (`find_opt`), memoization, and sequence replacement, tailored for managing static analysis data across multiple callstacks. Designed for program analysis tasks, it enables efficient tracking and querying of evaluated expressions, l-values, and predicates while integrating with Frama-C's kernel for structured data representation.",
      "description_length": 565,
      "index": 1518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Hashtbl-Key",
      "library": "frama-c-eva.gui",
      "description": "This module defines a data type and operations for keys used in a hash table within a static analysis context. It provides standard functionalities such as equality, comparison, hashing, and pretty printing for these keys, which are essential for managing and querying analysis data. Use cases include tracking and comparing abstract values across different program points during analysis.",
      "description_length": 389,
      "index": 1519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_types.Make",
      "library": "frama-c-eva.gui",
      "description": "This module provides functions to format, compare, and extract variables from GUI result and after-execution state types parameterized by an abstract value type `V`. It includes conversions between these abstract values and C values, enabling integration with C-based analysis tools. Concrete use cases include displaying analysis results in a user interface, comparing analysis states for equivalence, and extracting variable information from analysis outputs.",
      "description_length": 461,
      "index": 1520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates expressions, l-values, and function calls within abstract states inferred during static analysis. It provides precise access to global, function entry, and statement-level abstract states, supporting queries filtered by callstack. Key operations include expression evaluation, l-value copying, and location resolution, working directly with analysis domains for values, locations, and states.",
      "description_length": 414,
      "index": 1521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Map",
      "library": "frama-c-eva.gui",
      "description": "This module provides ordered map operations for managing key-value associations where keys are drawn from a strict total order domain. It supports functional manipulation of immutable maps through insertion, removal, traversal, filtering, and transformation operations, along with utilities for ordered iteration, sequence conversion, and customizable pretty-printing. These capabilities are particularly useful for tracking analysis states across evaluation contexts, aggregating domain-specific results with ordered keys, and implementing visualization pipelines that require structured data representation.",
      "description_length": 609,
      "index": 1522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Store",
      "library": "frama-c-eva.gui",
      "description": "This module stores and retrieves abstract states computed during analysis for various program points, including global, function entry, and statement-level states. It supports operations to register states at different control-flow points and query them either directly or via callstack-specific lookups. It is used to persist and access analysis results for l-values, expressions, and predicates during Eva evaluations.",
      "description_length": 420,
      "index": 1523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Loc",
      "library": "frama-c-eva.gui",
      "description": "This module supports operations for comparing, validating, and transforming memory locations and offsets, including field and array offset computations, base replacement, and non-overlap assumptions. It works with abstract memory locations, offsets, and values, leveraging helper modules for type and variable handling in static memory analysis. These capabilities enable symbolic backward analysis of pointers, struct fields, and array indices, along with polymorphic traversal and in-place modifications of complex data structures during program analysis.",
      "description_length": 557,
      "index": 1524,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Set",
      "library": "frama-c-eva.gui",
      "description": "This module provides set-theoretic operations (union, intersection, difference) and transformations (map, filter, fold) over abstract domain values, with support for ordered iteration, nearest-element queries, and structural decomposition. It works with sets of elements conforming to `Analysis.Dom.t`, offering utilities for membership testing, comparison, and integration with Frama-C's plugin system via metadata and pretty-printing. It is used in static analysis to track possible runtime values of program variables, optimize data flow computations, and visualize abstract domain states during evaluation tasks like expression or predicate analysis.",
      "description_length": 654,
      "index": 1525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_types.GCallstackMap",
      "library": "frama-c-eva.gui",
      "description": "This module provides associative map operations for ordered key-value pairs, where keys are structured callstack representations. It supports functional manipulation including insertion, deletion, ordered traversal, and transformation, alongside sequence-based construction and iteration. Designed for scenarios requiring hierarchical data management with precise ordering guarantees, such as GUI callstack tracking or structured state propagation.",
      "description_length": 448,
      "index": 1526,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Eval-Valuation",
      "library": "frama-c-eva.gui",
      "description": "This module caches evaluation results for expressions and l-values during analysis, mapping them to their computed values and origins. It supports operations to retrieve, add, fold over, and remove these cached results, as well as find and manipulate memory locations for l-values. Concrete use cases include tracking intermediate expression values and l-value locations during symbolic execution or static analysis.",
      "description_length": 416,
      "index": 1527,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom-Map-Key",
      "library": "frama-c-eva.gui",
      "description": "This module defines a data type for keys used in a map structure, along with operations for equality, comparison, hashing, and pretty printing. It supports working with lists of key representatives, deep copying of keys, and checking membership based on project values. Concrete use cases include managing and comparing symbolic evaluation keys in static analysis contexts.",
      "description_length": 373,
      "index": 1528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Dom",
      "library": "frama-c-eva.gui",
      "description": "This module provides lattice operations (join, widening, inclusion checks) and abstract interpretation primitives (assignment, assumption, predicate evaluation) for analyzing program states. It operates on abstract domain values (`Analysis.Dom.t`) representing program states, memory bases, and logic clauses, with support for relational property tracking and memory state transformations. Key use cases include evaluating expressions across callstacks, refining states via logical predicates, and managing scope/loop-sensitive analysis through state initialization and reuse optimizations.",
      "description_length": 590,
      "index": 1529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_eval.S-Analysis-Ctx",
      "library": "frama-c-eva.gui",
      "description": "This module provides operations to manipulate and query a polymorphic context structure, supporting key-based access, modification, and traversal of abstract state components. It works with heterogeneous data through type-safe keys and abstract domain-specific values, enabling precise context composition and inspection. Concrete use cases include merging evaluation contexts during abstract interpretation and extracting or updating domain-specific state components during analysis.",
      "description_length": 484,
      "index": 1530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_callstacks_filters",
      "library": "frama-c-eva.gui",
      "description": "This module provides functions to filter and match analysis callstacks based on structured callstack representations. It works with `rcallstack` values derived from `Eva.Callstack.t` and supports filtering via statement-level inspection, including reachability and non-termination checks. Concrete use cases include focusing on specific callstacks during analysis, determining if a statement belongs to a filtered callstack, and integrating filtering with zone-based evaluation functions.",
      "description_length": 488,
      "index": 1531,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_callstacks_manager",
      "library": "frama-c-eva.gui",
      "description": "This module manages the \"Values\" panel in the lower notebook of the GUI, displaying analysis results for selected expressions and lvalues across different callstacks. It provides functions to create, reset, and update the panel's content dynamically, using value abstractions from the analysis to reflect computed results in a table format. The child module defines the interface for formatting and comparing GUI-specific value representations and generating value data for lvalues at specific program locations. Together, they enable the panel to show and update analysis values filtered by user-selected callstacks and expressions.",
      "description_length": 633,
      "index": 1532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_types",
      "library": "frama-c-eva.gui",
      "description": "This module organizes GUI-specific data types and operations for static analysis, centering on callstacks, selections, offsetmap results, and locations, with core functions for comparison, hashing, pretty-printing, and value joining. It enables tracking and rendering UI state, handling user interactions, and integrating with analysis tools through structured data manipulation. The child modules refine these capabilities with value formatting, variable extraction, and C-value conversions, alongside ordered map operations for hierarchical callstack data. Together, they support precise analysis display, regression testing, and structured state propagation in GUI-driven tools.",
      "description_length": 681,
      "index": 1533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui.Gui_red",
      "library": "frama-c-eva.gui",
      "description": "This module adds a dedicated tab to the main GUI for displaying red alarms generated during value analysis. It provides the `make_panel` function, which integrates the tab into the Frama-C GUI using the main window's extension points. The module works with the Frama-C GUI framework to visualize analysis results directly within the interface.",
      "description_length": 343,
      "index": 1534,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Register_gui",
      "library": "frama-c-eva.gui",
      "description": "Implements GUI extensions for visualizing and interacting with value analysis results. Works with abstract syntax trees and value domains to display analysis states. Enables users to inspect variable bindings and control flow during program analysis.",
      "description_length": 250,
      "index": 1535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Eva_gui.Gui_eval",
      "library": "frama-c-eva.gui",
      "description": "This module evaluates program elements like l-values, expressions, and predicates across multiple callstacks using logic environments derived from code locations, supporting conditional evaluation based on function properties. It provides data types for abstract values, states, and locations, with operations for expression evaluation, memory zone computation, and predicate checking, used to determine valid logic labels or display analysis results. Submodules handle domain-specific maps and hash tables for managing evaluation data, interference tracking in concurrent programs, and context manipulation for abstract interpretation. Additional components support lattice operations, memory offset analysis, caching of evaluation results, and set-theoretic manipulations of abstract values, enabling tasks like symbolic execution, program slicing, and visualization of analysis states.",
      "description_length": 888,
      "index": 1536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eva_gui",
      "library": "frama-c-eva.gui",
      "description": "This module integrates static analysis results into a graphical interface, enabling users to explore and filter callstacks, evaluate program elements, and visualize analysis states. It operates on structured callstacks, lvalues, and abstract values, offering operations for filtering, comparison, evaluation, and display updates. Users can inspect variable bindings, track reachability, view red alarms in dedicated tabs, and analyze values across different contexts. Specific examples include filtering callstacks based on statement properties, updating GUI panels with computed values, and visualizing alarms and analysis states directly in the interface.",
      "description_length": 657,
      "index": 1537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Obfuscator",
      "library": "frama-c-obfuscator.core",
      "description": "This module implements an obfuscator plug-in that registers transformation functions dynamically through `Dynamic.register`. It operates on abstract syntax trees or intermediate representations, applying obfuscation techniques like name mangling, control flow alteration, or dead code insertion. Concrete use cases include protecting source code during compilation or transforming bytecode to deter reverse engineering.",
      "description_length": 419,
      "index": 1538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate.Instantiator_builder.Generator_sig-Hashtbl",
      "library": "frama-c-instantiate.core",
      "description": "This module supports creation, modification, and ordered traversal of hash tables mapping override keys to arbitrary values, with operations for in-place updates, functional queries, and memoization. It integrates with structural type systems to enable efficient function caching in transformation pipelines, particularly for managing function overrides during static analysis or compiler optimizations.",
      "description_length": 403,
      "index": 1539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate.Instantiator_builder.Generator_sig",
      "library": "frama-c-instantiate.core",
      "description": "This module defines the interface for generating function overrides during transformation. It includes operations to validate call typing, create unique keys for function calls, adjust argument types, and generate function prototypes and specifications. It works directly with CIL types like `lval`, `varinfo`, and `exp`, and is used to build specialized instantiator functions for transformed code.",
      "description_length": 399,
      "index": 1540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate.Instantiator_builder.Generator_sig-Hashtbl-Make",
      "library": "frama-c-instantiate.core",
      "description": "This module implements a hash table-based data structure with operations for type representation, comparison, and project membership checks. It works with values of type `Data.t` stored in a hash table, providing deep copying, equality, and pretty-printing for debugging. It is used to represent and manipulate collections of project-specific data where each entry must be uniquely identified and efficiently compared.",
      "description_length": 418,
      "index": 1541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Instantiate.Instantiator_builder.Generator_sig-Hashtbl-Key",
      "library": "frama-c-instantiate.core",
      "description": "This module defines a key type for use with hashtables, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports concrete data types that require structured representation, such as those involving Frama-C project data. Specific use cases include managing and identifying values within a transformation system that relies on unique, hashable keys with rich metadata.",
      "description_length": 412,
      "index": 1542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate.Instantiator_builder",
      "library": "frama-c-instantiate.core",
      "description": "This module constructs an instantiator from a generator signature, enabling the transformation of abstract code representations into executable forms by leveraging generator definitions for code elements like expressions and statements. It integrates with submodules that manage hash tables for override keys, function override generation, data structure manipulation, and key type definitions. These components collectively support tasks like function caching, type validation, and data comparison in transformation pipelines. For example, it can generate specialized instantiator functions for transformed CIL code or manage override mappings during static analysis.",
      "description_length": 668,
      "index": 1543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Instantiate.Transform",
      "library": "frama-c-instantiate.core",
      "description": "Registers instantiator functions by linking them with a visitor, enabling the generation of specific instantiator logic. Works with instantiator builders and visitor patterns to support dynamic instantiation. Used when creating new instantiator modules that need to integrate with existing visitor structures.",
      "description_length": 309,
      "index": 1544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Instantiate.Global_context",
      "library": "frama-c-instantiate.core",
      "description": "This module provides a function `get_variable` that retrieves or creates a global variable in the CIL types system by name. It works with CIL's `varinfo` type, ensuring a unique variable exists for a given name. A concrete use case is managing global variables during C code analysis or transformation, where variables need to be referenced consistently across different parts of the code.",
      "description_length": 389,
      "index": 1545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instantiate",
      "library": "frama-c-instantiate.core",
      "description": "This module enables the transformation of abstract code representations into executable forms by constructing and managing instantiators linked to generator signatures. It provides key data types like instantiators, visitors, and override mappings, along with operations for function registration, variable management, and dynamic instantiation. Specific functionality includes generating specialized instantiator functions for CIL code, managing global variables via `get_variable`, and integrating with visitor patterns for static analysis and transformation pipelines. It supports tasks like function caching, type validation, and data comparison through structured override and data manipulation components.",
      "description_length": 711,
      "index": 1546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RteGen.Flags",
      "library": "frama-c-rtegen.core",
      "description": "This module defines a record type `t` for configuring which categories of alarms to filter during analysis. It includes boolean flags for specific alarm types like memory access, division, overflow, and casting issues, along with a set of kernel functions to track initialization. The module provides `default`, `all`, and `none` constructors to create flag configurations, enabling precise control over alarm generation based on predefined categories.",
      "description_length": 452,
      "index": 1547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RteGen.Visit",
      "library": "frama-c-rtegen.core",
      "description": "This module provides functions to generate and retrieve code annotations for CIL elements such as functions, statements, expressions, and l-values, specifically tied to alarm handling. It includes visitor iterators for traversing l-values, expressions, instructions, and statements, along with a registration function to associate alarms with code annotations. Concrete use cases include attaching runtime error checks to specific code locations and extracting annotations during static analysis passes.",
      "description_length": 503,
      "index": 1548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RteGen",
      "library": "frama-c-rtegen.core",
      "description": "This module enables configuration of alarm filtering and integration of code annotations for CIL elements to support runtime error analysis. It defines a record type `t` with boolean flags for alarm categories like memory access, division, and overflow, along with functions to generate, retrieve, and associate annotations with code locations. Users can construct configurations using `default`, `all`, or `none` to control alarm generation, and employ visitors to traverse and annotate code during analysis passes. Example uses include enabling overflow checks on specific expressions and extracting attached alarms during static analysis.",
      "description_length": 641,
      "index": 1549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_boot.Boot",
      "library": "frama-c.boot",
      "description": "This module serves as the main entry point for initializing and launching Frama-C. It handles command-line argument parsing, plugin loading, and core system setup. Concrete use cases include starting the Frama-C kernel, configuring analysis parameters, and orchestrating plugin execution during static analysis.",
      "description_length": 311,
      "index": 1550,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_boot",
      "library": "frama-c.boot",
      "description": "This module initializes and coordinates the core components of Frama-C, including command-line parsing, plugin management, and system configuration. It provides data types for analysis settings, plugin descriptors, and execution contexts, along with operations to load plugins, set analysis options, and launch the kernel. Users can configure and start static analyses, enable specific plugins, and control analysis behavior through command-line arguments or configuration files. For example, it allows launching Frama-C with a specified input file and a set of active plugins to perform targeted code analysis.",
      "description_length": 611,
      "index": 1551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Users.Users_register",
      "library": "frama-c-users.core",
      "description": "Registers and analyzes user-defined functions related to user behavior tracking. It processes kernel functions to identify registration patterns and user interaction points within the code. This module is used to detect entry points for user-specific logic in software analysis tasks.",
      "description_length": 284,
      "index": 1552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Users",
      "library": "frama-c-users.core",
      "description": "This module tracks user behavior by analyzing defined functions and interactions within the code. It identifies registration patterns and entry points for user-specific logic through kernel function processing. Key operations include function registration, interaction point detection, and pattern analysis. For example, it can trace how user actions trigger specific code paths or detect when and where user-defined logic is invoked during execution.",
      "description_length": 451,
      "index": 1553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters in a plugin's configuration, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with strings and project-related predicates, enabling deep copies and membership checks within project skeletons. Concrete use cases include managing plugin-specific string settings and ensuring consistent handling of string values across different plugin components.",
      "description_length": 460,
      "index": 1554,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store and manage statement-related data in CIL, providing operations for equality checks, comparison, hashing, and pretty-printing. It works with the `Stmt.Hptset.Hashtbl.key` type, which encapsulates values that may include project-specific information. Concrete use cases include tracking and comparing CIL statements across different analysis contexts, enabling efficient lookups and ensuring deep copies to avoid shared state.",
      "description_length": 477,
      "index": 1555,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for handling multiple function declarations as string parameters, supporting operations like equality, comparison, hashing, and pretty-printing. It works with function declarations and string representations, enabling command-line options to accept and process sets of functions. It is used to define parameters that collect function names or prototypes, with support for checking project membership and deep copying values.",
      "description_length": 459,
      "index": 1556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps used in unrolled unnatural automata, where each key represents a versioned control point in a modified control flow graph. It provides operations for comparing, hashing, and printing these keys, as well as checking project membership and creating deep copies. These keys are used to track and manipulate control flow states during abstract interpretation of C programs.",
      "description_length": 403,
      "index": 1557,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores CIL variable information with project-aware semantics. It provides standard operations including equality, comparison, hashing, and pretty-printing for keys, along with deep copying and project membership checks. It is used to manage and manipulate keys that uniquely identify variable information entries within a CIL-based analysis context.",
      "description_length": 404,
      "index": 1558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a datatype representing a list of file paths as strings. It provides equality, comparison, hashing, and pretty-printing functions for handling file path lists in a type-safe manner. Concrete use cases include managing and comparing collections of file paths during plugin initialization and configuration in Frama-C.",
      "description_length": 351,
      "index": 1559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling command-line parameters as string values with support for multiple bindings. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of parameter values. It is used to manage string-based configuration options in Frama-C plugins, allowing multiple instances of the same option with distinct values.",
      "description_length": 385,
      "index": 1560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of strings with operations for comparison, hashing, and pretty-printing. It supports concrete use cases like tracking collections of string identifiers or managing sets of user-defined string parameters in a plugin. The module includes utilities for checking membership in projects and performing deep copies, ensuring values are independent.",
      "description_length": 391,
      "index": 1561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling multiple string values with operations for equality, comparison, hashing, and pretty printing. It supports string-based parameter management in plugins, enabling deep copies, membership checks over projects, and structured representation. Concrete use cases include managing plugin configurations and command-line arguments with string values.",
      "description_length": 388,
      "index": 1562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string set data type with standard operations for comparison, hashing, and pretty printing. It supports command-line parameter handling by providing structured representations, equality checks, and project membership queries. Concrete use cases include managing collections of string-based options in Frama-C plugins, such as sets of function names or file paths for analysis configurations.",
      "description_length": 413,
      "index": 1563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling a list of file paths as a string-based parameter type, supporting standard comparisons, hashing, and pretty-printing. It provides utilities to manage and query file path data through functions like `equal`, `compare`, `hash`, and `pretty`, ensuring deep copies and project membership checks via `mem_project`. Concrete use cases include parsing and validating command-line file path arguments in static analysis tools.",
      "description_length": 462,
      "index": 1564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of strings as string values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data representation and manipulation for plugin parameters that require string set values, ensuring deep copying and project membership checks. Concrete use cases include managing configuration options or string-based identifiers within Frama-C plugins.",
      "description_length": 430,
      "index": 1565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based identifiers in Frama-C plugins, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with lists of representants, checking membership in projects, and performing deep copies without shared references. Concrete use cases include managing function names or string keys in plugin-specific data structures during static analysis.",
      "description_length": 437,
      "index": 1566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are statement handles from CIL, supporting operations like equality, comparison, hashing, and pretty printing. It works with CIL statements wrapped in a handle type, enabling their use as keys in map structures. Concrete use cases include managing per-statement data in analyses or transformations, such as tracking control flow or annotating specific statements with metadata.",
      "description_length": 428,
      "index": 1567,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters in a plugin, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values and project-related structures, enabling storage and manipulation of string data within Frama-C's plugin system. Concrete use cases include managing configuration options, storing analysis results as strings, and facilitating data exchange between plugin components.",
      "description_length": 462,
      "index": 1568,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a string-based data type used in plugin development, including equality, comparison, hashing, and pretty printing. It supports manipulation and inspection of string values within Frama-C's plugin system, ensuring deep copies and project membership checks. Concrete use cases include handling configuration parameters, storing analysis results, and managing string identifiers across different plugin components.",
      "description_length": 446,
      "index": 1569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Implements a hash table where keys are `Varinfo` values and values are of a specified type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking variable-specific data across CIL analyses, enabling efficient lookups and storage during static analysis. The module ensures deep copying and project-aware membership checks, making it suitable for managing analysis results tied to specific variables and projects.",
      "description_length": 492,
      "index": 1570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are `Varinfo` values and values are of a specified `Data` module type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management tasks such as deep copying and project membership checking via `mem_project`. Concrete use cases include tracking variable-specific analyses or annotations across different project contexts in static analysis plugins.",
      "description_length": 454,
      "index": 1571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based file paths in Frama-C plugins, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with file paths as strings, enabling storage, comparison, and manipulation of file references within plugin data structures. Concrete use cases include tracking source file paths across different analysis phases and persisting file-related metadata in a project context.",
      "description_length": 466,
      "index": 1572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify vertices in an unrolled control flow graph with normalized loop structures. It provides standard operations for equality, comparison, hashing, and pretty-printing vertex keys, along with deep copying and project membership checks. It is used to manage and query vertex identifiers during abstract interpretation or analysis of program control flow.",
      "description_length": 411,
      "index": 1573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters in a plugin's configuration, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings as atomic values, providing deep copy functionality and project membership checks. Concrete use cases include storing and managing string settings that must be uniquely identified and compared within a plugin's analysis framework.",
      "description_length": 436,
      "index": 1574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type specifically for managing and comparing unique identifiers in the context of unrolled unnatural loops within an interpreted automaton. It supports operations such as equality checking, comparison, hashing, and pretty-printing, all tailored to keys that represent control flow graph elements. The module is used to ensure efficient and correct handling of versioned keys in data structures like hashtables, particularly during analysis or transformation passes that require stable key identity and deep copying.",
      "description_length": 552,
      "index": 1575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string-based command line parameters with operations for comparison, hashing, pretty printing, and deep copying. It works with string values and project skeletons, supporting checks for project membership and structural representation. Concrete use cases include managing string options in Frama-C plugins, such as file paths, identifiers, or configuration strings passed via the command line.",
      "description_length": 437,
      "index": 1576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of strings as command-line parameters, supporting operations like equality, comparison, hashing, and pretty-printing. It works with string values and project skeletons to manage parameter state and project membership checks. Concrete use cases include parsing and managing string-based options in Frama-C plugins, such as lists of file paths or identifier filters.",
      "description_length": 413,
      "index": 1577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for managing string-based values in the context of Frama-C plugin development. It supports equality checks, comparison, hashing, pretty printing, and deep copying, ensuring proper handling of string parameters within the analysis framework. Concrete use cases include storing and manipulating string values associated with kernel functions, particularly when integrating custom plugins that require string-based configuration or representation.",
      "description_length": 492,
      "index": 1578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for versioned data in the context of interpreted automata with unrolled unnatural loops. It provides standard operations including equality checks, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. The hash table stores values of a given `Data` module type, which must conform to the expected versioned data structure.",
      "description_length": 414,
      "index": 1579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling string-based parameters associated with kernel functions, supporting equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing string values, along with standard types like `formatter`, `int`, and `bool`. Concrete use cases include defining and manipulating command-line options that accept function names or string identifiers, ensuring deep copying, project membership checks, and structured serialization.",
      "description_length": 502,
      "index": 1580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on CIL variable information, supporting operations like equality, comparison, hashing, and pretty printing. It works with structured data types involving `Varinfo` and includes utilities for checking membership in projects and deep copying values. Concrete use cases include managing and comparing variable identifiers in static analysis plugins.",
      "description_length": 407,
      "index": 1581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are statements from CIL (C Intermediate Language) and values are elements of a specified data type. It provides standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing capabilities. It is used in static analysis plugins for Frama-C to associate statement-specific data with CIL statements, such as analysis results or transformation metadata.",
      "description_length": 450,
      "index": 1582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map parameter type for command-line options, supporting operations like equality, comparison, hashing, and pretty-printing. It works with string-keyed maps containing values of a specific data type, providing deep copying and membership checks over project skeletons. It is used to define and manage structured command-line parameters in Frama-C plugins.",
      "description_length": 386,
      "index": 1583,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a command-line parameter type for handling lists of strings as a single string value, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `As_string.Datatype.t` type, which represents string-based command-line arguments. Concrete use cases include parsing and managing string lists in Frama-C plugins, such as collecting include paths or defining macro names during analysis configuration.",
      "description_length": 455,
      "index": 1584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for CIL statement types, providing operations for equality checking, comparison, hashing, and pretty printing. It works with values of type `Data.t` and supports deep copying, membership testing based on project skeletons, and type-safe storage and retrieval. Concrete use cases include managing and analyzing collections of CIL statements during static analysis, such as tracking control flow or collecting statement-specific annotations.",
      "description_length": 502,
      "index": 1585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for vertex sets from an interpreted automaton with unnatural loops unrolled. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to manage and manipulate sets of automaton vertices efficiently in abstract interpretation tasks.",
      "description_length": 382,
      "index": 1586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling collections of string-based parameters within a plugin system. It supports operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate string parameter lists in a structured and type-safe way during plugin execution.",
      "description_length": 373,
      "index": 1587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string-based command line parameters in a map structure where each key maps to a single value. It provides operations for equality, comparison, hashing, pretty printing, and deep copying, ensuring values are fully independent. It is used to implement command line options that require unique string bindings, such as parsing and managing individual string flags or settings.",
      "description_length": 418,
      "index": 1588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by version identifiers, where values are of a parameterized `Data` type. It provides standard map operations\u2014lookup, insertion, iteration, and equality checks\u2014along with serialization, pretty-printing, and project-aware membership checks. It is used to manage versioned data in unrolled control flow graphs, enabling precise tracking and manipulation of analysis states across different program versions.",
      "description_length": 439,
      "index": 1589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by vertices from an interpreted automaton with unnatural loops unrolled, where each binding associates a vertex to a value of a specified type. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to track and manipulate per-vertex data during abstract interpretation or analysis passes over control flow graphs.",
      "description_length": 464,
      "index": 1590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling string-based command line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with string values in the context of Frama-C's parameter system, including deep copying and membership checks over project skeletons. Concrete use cases include parsing and managing string options in Frama-C plugins, such as file paths, identifiers, or configuration strings.",
      "description_length": 454,
      "index": 1591,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters in a plugin's configuration, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings as the underlying data type and provides utilities for deep copying values, checking membership within projects, and describing the type for integration with Frama-C's plugin system. Concrete use cases include storing and managing string options or identifiers within a plugin's state or configuration.",
      "description_length": 508,
      "index": 1592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling command-line parameters as strings, specifically for file paths. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to define and manage string-based command-line options that represent file paths within the Frama-C kernel.",
      "description_length": 379,
      "index": 1593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that represents vertices in an unrolled control flow graph with normalized loop structures. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to track and manipulate control flow graph vertices during abstract interpretation, particularly in handling state transitions and reachability analysis.",
      "description_length": 446,
      "index": 1594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling sets of function declarations (`Fundec.t`) as string parameters, supporting operations like equality, comparison, hashing, and pretty-printing. It provides utilities to manage and query these sets in the context of command-line options, specifically for Frama-C's kernel parameters. Use cases include parsing and validating function sets specified by users during analysis configuration.",
      "description_length": 431,
      "index": 1595,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling sets of function declarations (`Fundec_set`) represented as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports working with Frama-C's internal project structures through `mem_project` and provides deep copying to ensure no shared references. Concrete use cases include managing and comparing sets of function declarations in plugins, particularly when tracking or analyzing specific functions across different project versions.",
      "description_length": 514,
      "index": 1596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for handling multiple string values as command-line parameters, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with strings and project skeletons to manage parameter representations and project membership queries. Concrete use cases include defining and manipulating string-based command-line options that require multiple values, such as file paths or configuration flags.",
      "description_length": 456,
      "index": 1597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of strings as a single string in a plugin context. It provides standard operations including equality, comparison, hashing, and pretty printing, along with functions for project membership checks and deep copying. It is used to manage string list configurations or parameters within Frama-C plugins.",
      "description_length": 349,
      "index": 1598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of strings as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of representable values, ensuring deep copies and proper project membership checks. Concrete use cases include parsing and managing string-based options in Frama-C plugins, such as file paths or symbol lists.",
      "description_length": 405,
      "index": 1599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued plugin configuration options with support for validation, command-line parsing, and state change hooks. It provides data types for constrained strings, including specialized handling for function names and aliases, with customizable serialization and update callbacks. A key submodule introduces a type-safe representation for lists of file paths, offering equality, comparison, and pretty-printing operations. Example uses include validating file path inputs, extracting function names from strings, and managing plugin configurations that require dynamic updates and command-line integration.",
      "description_length": 628,
      "index": 1600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a functional set interface for managing HPT sets of CIL statements, enabling operations like union, intersection, and difference alongside element queries and ordered traversal. It supports transformations, filtering, and conversions to and from lists, while integrating with Frama-C's project system for deep copying and type-aware comparisons. Primarily used in static analysis plugins, it aids tasks like data flow tracking and property propagation by efficiently handling sets of statements grouped into hierarchical, persistent structures.",
      "description_length": 565,
      "index": 1601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as managing and querying hash table keys with precise semantic descriptions and deep copying. The module also includes functionality for checking membership based on project-specific predicates.",
      "description_length": 370,
      "index": 1602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys based on expressions and values determined by the provided `Data` module, using structural equality for comparisons. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, along with project-aware membership testing. It is suitable for scenarios requiring precise value tracking and manipulation in static analysis plugins, such as managing expression-based mappings in CIL AST transformations.",
      "description_length": 499,
      "index": 1603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hashtbl used to represent memory zones, providing operations to compare, hash, and print these keys. It supports data types related to memory base addresses and their validity, enabling precise tracking and manipulation of memory regions. Use cases include managing memory state in static analysis plugins, such as tracking allocated zones or validating pointer accesses.",
      "description_length": 402,
      "index": 1604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a map structure, including equality, comparison, hashing, and pretty-printing. It works with the `t` type representing logic label map keys, supporting efficient key-based lookups and manipulations. Concrete use cases include managing and comparing symbolic logic labels during static analysis of C code.",
      "description_length": 352,
      "index": 1605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table implementation, including equality, comparison, hashing, and pretty-printing functions. It works with a specific key type that includes project-aware values, supporting deep copying and membership checks over project data. Concrete use cases include managing and querying attribute keys in a hash table while ensuring proper value separation and project-specific filtering.",
      "description_length": 434,
      "index": 1606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table implementation, specifically tailored for integer-based keys within the Frama-C kernel. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate hash table keys in a type-safe manner during static analysis tasks.",
      "description_length": 401,
      "index": 1607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps with operations for comparison, hashing, and pretty-printing. It works with ordered key types and supports set operations through deep copying, membership testing, and project-based filtering. Concrete use cases include managing unique, comparable keys in map structures and performing set operations without side-effects.",
      "description_length": 362,
      "index": 1608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, providing operations such as equality checking, comparison, hashing, and pretty printing. It works with a specific key type that includes project membership checks and supports deep copying. Concrete use cases include managing and identifying entries in a hashtable that represent model information tied to CIL structures, such as during static analysis in Frama-C plugins.",
      "description_length": 427,
      "index": 1609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that uniquely identify types without unrolling struct definitions, using a comparison based on structural equivalence. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checks over project skeletons. Concrete use cases include managing type-based mappings in static analysis plugins where struct identity must be preserved.",
      "description_length": 451,
      "index": 1610,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map for kernel functions with support for equality, comparison, hashing, and pretty-printing of function keys. It handles data types representing function declarations, including pure prototypes, and provides operations to check membership within projects and perform deep copies. It is used to manage and manipulate function-related data in Frama-C plugins, enabling precise tracking and analysis of function definitions across different project contexts.",
      "description_length": 481,
      "index": 1611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Enum.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for a fixed set of values with support for equality, comparison, hashing, and pretty-printing. It works with variant types that have a finite number of constructors, requiring structural equality. Concrete use cases include representing and managing plugin-specific enumerated types, such as analysis modes or configuration options, within Frama-C's plugin system.",
      "description_length": 395,
      "index": 1612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype specialized for logic type information, where keys are identifiers and values are of a specified `Data` module type. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate logic type metadata in a structured and efficient way during static analysis.",
      "description_length": 424,
      "index": 1613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash-consed key type for maps, including operations for equality, comparison, hashing, and pretty-printing. It works with abstract key values that represent hash-consed data, along with project-aware membership checks and deep copying. Concrete use cases include efficient key management in stateful analyses and ensuring canonical representations for keys in persistent data structures.",
      "description_length": 409,
      "index": 1614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based lattice structure where keys are standard hash table keys and values conform to a lattice structure provided by the `Data` module. It supports operations like equality checking, comparison, hashing, deep copying, and pretty printing, along with lattice-specific operations such as `mem_project` to check membership based on project conditions. It is used to represent and manipulate value mappings in static analysis contexts, such as tracking abstract memory states or variable bindings during program analysis.",
      "description_length": 554,
      "index": 1615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued command-line parameters with support for validation, value change hooks, and alias handling, enabling strict option constraints and dynamic behavior extension. It provides data types for strings and string-keyed maps, with operations for equality, comparison, hashing, and pretty-printing. The map functionality allows structured command-line parameters with deep copying and membership checks, useful in static analysis tools and Frama-C plugins. Example uses include restricting parameter values to predefined lists and defining extensible option behaviors through custom hooks.",
      "description_length": 614,
      "index": 1616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and retrieving logic information with efficient lookups, and tracking project-specific data in Frama-C analyses. The hash tables are used to manage and manipulate CIL logic constructs in a type-safe manner during plugin execution.",
      "description_length": 455,
      "index": 1617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and retrieving CIL labels with custom value types, enabling efficient lookups and structural comparisons. The module also includes project-aware membership checks and deep copying, suitable for analysis plugins requiring precise label manipulation.",
      "description_length": 473,
      "index": 1618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines hash table keys based on CIL variable information, providing equality, comparison, hashing, and pretty-printing operations. It works with `Varinfo` structures to enable key creation and manipulation in hash tables that require project-aware memory management. Concrete use cases include tracking variable-specific data across different analysis passes in Frama-C plugins.",
      "description_length": 391,
      "index": 1619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Float.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float parameter type that supports optional decimal point parsing and conversion to OCaml float values. It provides standard operations including equality, comparison, hashing, pretty printing, deep copying, and project membership checks. It is used to handle numeric plugin parameters with precise representation and structural manipulation.",
      "description_length": 364,
      "index": 1620,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store and manage logic information in CIL-based analyses. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with deep copying and project membership checks. It is used to uniquely identify and manipulate logic entities within Frama-C's kernel, particularly during static analysis tasks involving logic functions and predicates.",
      "description_length": 420,
      "index": 1621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with typed, structured data representations, including deep copying and project membership checks. Concrete use cases include managing and manipulating structured declarations with precise type and project information in static analysis tools.",
      "description_length": 418,
      "index": 1622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of strings within Frama-C's plugin system. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to represent and manipulate string list values in a way that integrates with Frama-C's analysis framework, particularly for plugin-specific data.",
      "description_length": 393,
      "index": 1623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map based on component information (`Compinfo`) from CIL, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with structured data representations in static analysis plugins, particularly for tracking and comparing CIL components across different projects. Key functions enable deep copying, membership checks over projects, and handling of type descriptors for serialization and introspection.",
      "description_length": 480,
      "index": 1624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a map where each key is a string-based datatype. It provides functions for equality checks, comparison, hashing, and pretty-printing keys, along with deep copying and checking for the presence of specific projections within a key. These operations support precise key manipulation and are particularly useful when implementing or working with persistent and project-aware map structures in Frama-C plugins.",
      "description_length": 458,
      "index": 1625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing kernel functions within a plugin, enabling dynamic configuration through command-line options. It provides operations to define categories, set default behaviors, and control activation states, working with types like `Category.t` and `Frama_c_kernel.State.t`. Concrete use cases include categorizing analysis options, enabling/disabling groups of functions via `@all`, and associating accessors to control parameter visibility and behavior.",
      "description_length": 500,
      "index": 1626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by wide strings, with values of a specified data type. It provides standard map operations including insertion, lookup, equality, comparison, and pretty-printing, along with project-aware membership checks and deep copying. It is suitable for managing wide string-indexed data in static analysis plugins, such as symbol tables or configuration settings.",
      "description_length": 403,
      "index": 1627,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by normalized filepaths, where each key is a `Filepath.t` and values are of a specified type `Data.t`. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the map itself. It is used to manage and manipulate sets of values associated with unique, normalized filepaths in a type-safe manner.",
      "description_length": 408,
      "index": 1628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate memory location zones with specific data. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, which are essential for managing and querying memory zone mappings. Use cases include tracking variable bindings or analyzing memory regions in static analysis plugins.",
      "description_length": 369,
      "index": 1629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL type representations. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring consistent handling of type identities. Use cases include efficient lookup and storage of type-specific data in hash tables during CIL analysis or transformation passes.",
      "description_length": 388,
      "index": 1630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of the provided `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with CIL instruction (`Kinstr`) data structures wrapped in a hash table, enabling efficient lookups and manipulations. Concrete use cases include tracking and managing sets of CIL instructions during static analysis, such as in Frama-C plugins that require fast access to analyzed code elements.",
      "description_length": 488,
      "index": 1631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are of type `Data.t` and values are of type `Frama_c_kernel.Datatype.Unit.t`. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage mappings from data values to unit, typically for tracking presence or absence of specific elements in a project-aware context.",
      "description_length": 421,
      "index": 1632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map with 64-bit integer keys and values of a specified data type, providing standard operations like lookup, insertion, and traversal. It supports efficient key-based access and manipulation of structured data, particularly for use cases such as tracking and managing analysis results indexed by identifiers. The map integrates with Frama-C's project system, allowing for deep copying, comparison, and pretty-printing of its contents.",
      "description_length": 459,
      "index": 1633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and controlling command-line options related to kernel functions. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, each controlling how options are interpreted and enabled. Use cases include organizing plugin options into logical groups and controlling their activation behavior through command-line flags.",
      "description_length": 408,
      "index": 1634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are of type `Data.t` and values are managed with operations including equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing collections of typed values, and performing deep copies or membership checks based on project skeletons. The module is designed for scenarios requiring structured value management with full type descriptions and representations.",
      "description_length": 467,
      "index": 1635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for use in hashtables, specifically tailored for CIL location data. It provides operations for equality, comparison, hashing, and pretty-printing keys, as well as deep copying and checking project membership. These keys are used to uniquely identify and manipulate location-based entries in a hashtable structure, particularly in the context of Frama-C's CIL analysis.",
      "description_length": 393,
      "index": 1636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that supports structural equality and comparison of CIL expressions, particularly handling `sizeof` expressions by comparing their size rather than identity. It provides standard operations including equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used in contexts requiring canonical representation and efficient lookup of CIL expressions based on structural equivalence.",
      "description_length": 493,
      "index": 1637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set of operations for managing and manipulating a specific abstract data type `t`, including equality, comparison, hashing, and pretty-printing functions. It provides utilities for deep copying values, checking membership based on project properties, and accessing type descriptors and representants. These operations support precise data manipulation and introspection in the context of plugin development and analysis extensions.",
      "description_length": 453,
      "index": 1638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map.Make",
      "library": "frama-c.kernel",
      "description": "Implements a map where keys are term lhosts and values are of a specified data type, providing standard map operations. Supports key-based comparisons, hashing, and pretty-printing for user-friendly output. Useful for managing term lhost-indexed data in static analysis plugins, such as tracking expressions or annotations tied to specific program points.",
      "description_length": 355,
      "index": 1639,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, specifically for floating-point values. It provides operations for equality checking, comparison, hashing, and pretty-printing keys, along with deep copying and membership testing within projects. Use cases include managing and querying floating-point keys in a hash table with precise control over their representation and behavior.",
      "description_length": 395,
      "index": 1640,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for strict constant values from the CIL framework. It provides standard operations such as equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It is used when precise, value-based distinctions are required, such as in analysis plugins that track constant expressions with strict semantic identity.",
      "description_length": 444,
      "index": 1641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing 32-bit integer keys in a map structure. It provides standard key functionalities such as equality, comparison, hashing, and pretty-printing, specifically tailored for use in Frama-C's internal data representations. These keys are used to index and manipulate map entries in a type-safe and efficient manner.",
      "description_length": 365,
      "index": 1642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are properties ordered by function-specific criteria, including kernel function name, instruction, property kind, and property ID. It provides standard operations such as comparison, equality, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate property-based data in a structured and ordered way within Frama-C's analysis framework.",
      "description_length": 468,
      "index": 1643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps with kernel function HPT sets, supporting equality, comparison, hashing, and pretty-printing operations. It provides functions to check membership based on project properties, create deep copies, and manage type descriptors for serialization and representation. Concrete use cases include managing per-function state in analyses and storing function-specific metadata across different projects.",
      "description_length": 448,
      "index": 1644,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of the `Data` module, using structural comparison for keys. It supports standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Use it when you need a hash table that ensures structural consistency and provides representable values for analysis plugins.",
      "description_length": 394,
      "index": 1645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent built-in logic information in CIL, including operations for equality, comparison, hashing, and pretty-printing. It works with the `key` type, which encapsulates data such as type information and project-specific values. Use cases include managing and retrieving logic function metadata during static analysis, and tracking built-in logic entities uniquely across different analysis contexts.",
      "description_length": 448,
      "index": 1646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports creating, copying, and comparing hash tables with user-defined value types, enabling structured storage and retrieval of CIL-related data. Concrete use cases include managing logic function metadata or tracking analysis results indexed by CIL expressions.",
      "description_length": 433,
      "index": 1647,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Bool.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean datatype with standard operations including equality, comparison, hashing, and pretty printing. It supports deep copying and provides functionality to check membership within a project context. It is used to represent and manipulate boolean values in Frama-C plugins, particularly for analysis and transformation tasks involving logical states or flags.",
      "description_length": 383,
      "index": 1648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are term locations (`Term_lval`) and values are of a specified `Data` module type. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate mappings involving CIL term locations in a type-safe manner.",
      "description_length": 376,
      "index": 1649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a list-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports list values through a structured descriptor, providing deep copying and membership checks over project skeletons. Concrete use cases include managing collections of analysis states or transformation rules in static analysis plugins.",
      "description_length": 358,
      "index": 1650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are syntactic scopes and values are of a specified data type. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate scope-indexed data in CIL-based analyses, such as tracking analysis results per function or code block.",
      "description_length": 392,
      "index": 1651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for `Term_lhost` values in the CIL datatype hierarchy. It provides standard operations including equality, comparison, hashing, and pretty-printing, ensuring proper handling of key values within analysis plugins. Use cases include tracking and comparing term hosts in static analysis contexts, such as value analysis or slicing, where efficient key-based lookups are required.",
      "description_length": 452,
      "index": 1652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by CIL variable information, where each entry holds values of a specified data type. It supports operations like equality checking, comparison, hashing, and pretty-printing for maps, along with deep copying and project-aware membership testing. It is useful for tracking variable-specific data across CIL constructs, such as associating analysis results or metadata with specific variables in a C program.",
      "description_length": 439,
      "index": 1653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for wide string keys, where values are of the type provided by the `Data` parameter. It supports standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. Concrete use cases include managing mappings from wide string identifiers to analysis data in Frama-C plugins, such as tracking variable names or function signatures across different translation units.",
      "description_length": 506,
      "index": 1654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.Key.t` type, offering functions to manage key representations, check membership in projects, and perform deep copies. Concrete use cases include managing unique identifiers in analysis plugins and ensuring consistent key handling across different hash table implementations.",
      "description_length": 439,
      "index": 1655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype specialized for integer keys and a given value type, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with values of type `Data.t` and supports concrete use cases such as efficient storage and retrieval of integer-indexed data in static analysis plugins. The module also includes support for deep copying, project membership checks, and type descriptors for integration with Frama-C's internal frameworks.",
      "description_length": 497,
      "index": 1656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations such as equality checking, comparison, hashing, and pretty printing. It works with the `Hashtbl.Key.t` type, offering functionalities like deep copying, membership testing based on project values, and type representation. Concrete use cases include managing and manipulating hash table keys in Frama-C plugins, particularly for analysis tasks requiring structured key handling.",
      "description_length": 459,
      "index": 1657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing operations such as equality, comparison, hashing, and pretty printing. It supports key values that may contain project-specific data, enabling checks on embedded projects and deep copying to avoid shared state. Concrete use cases include managing and comparing map keys in static analysis plugins where keys must be uniquely identified and manipulated independently of their original context.",
      "description_length": 466,
      "index": 1658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.False.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype implementation for a command line option that represents a false or disabled state. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to construct and manage command line flags that indicate the absence or deactivation of a feature in Frama-C plugins.",
      "description_length": 392,
      "index": 1659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, where each hash table maps keys to CIL global annotations. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checking. Use cases include managing and manipulating collections of annotated CIL elements, such as tracking function or variable annotations across different analysis phases.",
      "description_length": 450,
      "index": 1660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for function declarations (`Fundec`) in the CIL intermediate language. It provides standard operations such as equality, comparison, hashing, and pretty printing, enabling efficient and safe manipulation of function keys in hash tables. Concrete use cases include tracking and managing function definitions during static analysis, where unique identification and comparison of functions are required.",
      "description_length": 476,
      "index": 1661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.True.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in command line option handling. It supports structured data representation with a unique name, type descriptor, and deep copying, ensuring safe manipulation of values. It is used to define parameter types that can be parsed from the command line, checked for project membership, and displayed to users.",
      "description_length": 433,
      "index": 1662,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Custom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered custom data type with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership testing within project skeletons. Use it to integrate custom data structures into Frama-C plugins, enabling seamless parameter handling and project-aware computations.",
      "description_length": 329,
      "index": 1663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data structures used in CIL-based analyses, particularly for managing logic types with name-based identifiers. Concrete use cases include tracking and manipulating logic type definitions across different analysis contexts.",
      "description_length": 407,
      "index": 1664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued plugin parameters with validation, transformation, and serialization, supporting predefined values and C identifier formatting. It enables use cases like command-line argument parsing, runtime configuration, and project state persistence, with value change hooks, alias handling, and customizable marshaling. A child module extends this functionality to file paths, offering equality, comparison, and pretty printing for string-based paths, enabling robust tracking and persistence of source file references across analysis phases. Together, they provide a cohesive interface for handling both general and path-specific string data throughout Frama-C's plugin ecosystem.",
      "description_length": 704,
      "index": 1665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data structure for managing sets of kernel functions with support for both defined functions and pure prototypes as keys. It provides standard operations like equality, comparison, hashing, and pretty-printing for these sets, along with deep copying and project membership checks. It is used to implement command-line options that accept multiple function declarations, enabling precise control over function inclusion in static analysis configurations.",
      "description_length": 475,
      "index": 1666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are positions in source files and values are of a specified type. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to associate structured data with specific source code locations, such as storing analysis results or annotations tied to exact lines in C source files.",
      "description_length": 419,
      "index": 1667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string-based command line parameter type with operations for equality, comparison, hashing, and pretty printing. It supports creating and managing command line options that accept string values, ensuring deep copying and project-aware membership checks. Concrete use cases include defining configurable string options in Frama-C plugins, such as file paths, identifiers, or user-defined labels.",
      "description_length": 416,
      "index": 1668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.key` type, offering functions to manage and manipulate key values in a way that supports efficient storage and retrieval. Concrete use cases include managing unique identifiers or structured keys in plugin-specific data structures within Frama-C.",
      "description_length": 411,
      "index": 1669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL labels within a project. It provides operations for comparing, hashing, and printing these keys, as well as checking project membership and creating deep copies. It is used to manage and manipulate label-based identifiers in static analysis plugins for Frama-C.",
      "description_length": 330,
      "index": 1670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies with named categories. Concrete use cases include setting up configurable behavior for plugin parameters and controlling global category interpretations in Frama-C plugins.",
      "description_length": 447,
      "index": 1671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a parameter type for command-line options representing maps with unique bindings. It supports operations for equality, comparison, hashing, and pretty-printing map values, along with deep copying and project membership checks. It is used to implement command-line parameters that accept key-value pairs where duplicates are disallowed.",
      "description_length": 355,
      "index": 1672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for floating-point values, using the provided `Data` module to define the value type. It supports standard hash table operations such as equality, comparison, hashing, and pretty printing, tailored for use with Frama-C's internal type and project system. Concrete use cases include managing and manipulating collections of floating-point data in static analysis plugins, such as tracking numerical approximations or symbolic expressions.",
      "description_length": 491,
      "index": 1673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store wide strings, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured data management by enabling deep copies, membership checks over project skeletons, and type-safe value representations. Concrete use cases include tracking and manipulating wide string identifiers in CIL-based analyses where key uniqueness and efficient lookup are critical.",
      "description_length": 467,
      "index": 1674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, where keys are based on `Enuminfo` from CIL. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. Use cases include managing and manipulating CIL enumeration data within Frama-C plugins, such as tracking enum values across different analysis phases.",
      "description_length": 421,
      "index": 1675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are term offsets and values are of the `Data` module's type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the map itself. It is used to manage and manipulate term offset-indexed data in static analysis plugins, such as associating annotations or attributes with specific program points.",
      "description_length": 418,
      "index": 1676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for hash tables that supports structural equality and comparison of CIL expressions, particularly handling `sizeof` expressions by considering equivalent types within `sizeof` as equal. It provides standard operations such as `equal`, `compare`, `hash`, and `pretty`, along with utilities for deep copying and checking project membership. Concrete use cases include managing and comparing CIL expressions in static analysis plugins where structural equivalence is required, such as tracking expressions across different analysis states or optimizing expression caching.",
      "description_length": 600,
      "index": 1677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype where keys are based on the `Model_info` structure and values are defined by the `Data` module. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage structured collections of analysis data indexed by model information in CIL-based static analysis plugins.",
      "description_length": 417,
      "index": 1678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps with normalized filepaths, providing equality, comparison, hashing, and pretty-printing operations. It supports type-safe manipulation of filepath keys with functions like `equal`, `compare`, `hash`, and `pretty`. Use cases include managing filepath-based keys in maps for analysis plugins, ensuring correct handling of normalized paths during static analysis.",
      "description_length": 413,
      "index": 1679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps where keys are based on CIL types with structural comparison by name. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checks over project skeletons. It is used to manage and manipulate type-based keys in map structures during static analysis tasks.",
      "description_length": 391,
      "index": 1680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on CIL predicates with structural equality. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with functions to check project membership and perform deep copies. It is used to manage and manipulate map keys derived from CIL predicate structures in a type-safe and efficient manner.",
      "description_length": 407,
      "index": 1681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are global annotations and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to manage and manipulate maps of CIL global annotations in a type-safe manner.",
      "description_length": 348,
      "index": 1682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type where keys and values are based on the provided `Data` module. It supports standard hash table operations like equality, comparison, hashing, and pretty printing, while ensuring deep copying and project membership checks. Concrete use cases include managing dynamic collections of values with efficient lookups and maintaining unique, hash-based representations of structured data.",
      "description_length": 419,
      "index": 1683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify logic types by their name and type information. It provides operations to compare, hash, and pretty-print these keys, along with introspection functions like `mem_project` to check for embedded project values. The module is used to manage and retrieve logic type definitions in a structured and efficient manner during static analysis.",
      "description_length": 400,
      "index": 1684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.False.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports deep copying, membership testing within projects, and provides descriptors for type representation. Concrete use cases include managing plugin-specific data structures that require serialization, comparison, or integration with Frama-C's project system.",
      "description_length": 416,
      "index": 1685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, enabling efficient storage and retrieval of values with standard hash table operations. It supports concrete use cases like tracking CIL AST nodes or analysis results during static analysis, where each entry's identity and equality are preserved. The hash tables are equipped with serialization, comparison, and pretty-printing capabilities for integration into Frama-C's analysis frameworks.",
      "description_length": 470,
      "index": 1686,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string set data type with standard operations including equality, comparison, hashing, and pretty printing. It supports working with sets of strings as first-class values, enabling their use in persistent data structures and project-specific contexts. Concrete use cases include tracking collections of unique string identifiers across different analysis phases or configurations in a plugin.",
      "description_length": 414,
      "index": 1687,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on the `PredicateStructEq` type and values are of a specified `Data` module type. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage structured data mappings in CIL-based analyses requiring precise type handling and value representation.",
      "description_length": 412,
      "index": 1688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps based on logic type information, providing standard operations including equality, comparison, hashing, and pretty printing. It works with the `t` type representing logic type keys and supports operations for checking membership in projects and deep copying. Concrete use cases include managing and manipulating logic type keys in static analysis plugins, particularly for CIL-based transformations and queries.",
      "description_length": 445,
      "index": 1689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store and manage CIL terms with operations for equality, comparison, hashing, and pretty-printing. It supports data types involving `Project.t` values, enabling checks on project membership and deep copying to avoid shared references. Concrete use cases include managing unique term identifiers in static analysis plugins and ensuring structural integrity during term manipulations.",
      "description_length": 429,
      "index": 1690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete data structures such as logic types in CIL, ensuring deep copies and project-aware membership checks. Use cases include managing and comparing collections of CIL logic types within Frama-C plugins.",
      "description_length": 396,
      "index": 1691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for CIL function definitions (`Fundec.t`), where each map is indexed by these function definitions and holds values of a specified data type. It provides standard map operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to associate and manipulate function-specific data in a type-safe and efficient manner during static analysis.",
      "description_length": 468,
      "index": 1692,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, project membership testing, and type-safe storage and retrieval of CIL term offsets. Concrete use cases include tracking term offset mappings during static analysis and persisting analysis results tied to specific program terms.",
      "description_length": 464,
      "index": 1693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing keys in a hash table, including operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.Key.t` type, providing functions to manipulate and inspect hash table keys directly. Concrete use cases include managing unique identifiers in a hash table, comparing and hashing keys for efficient lookups, and generating human-readable representations of key values.",
      "description_length": 442,
      "index": 1694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.WithOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option parsing with support for structured data types, including equality, comparison, and pretty-printing operations. It works with a custom `Datatype.t` type, which represents values that can be parsed, compared, and displayed. Concrete use cases include defining and handling options that accept complex values such as ranges, identifiers, or structured configurations during static analysis.",
      "description_length": 431,
      "index": 1695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of a specified data type, supporting standard operations such as comparison, hashing, and pretty printing. It works with values wrapped in a map type that allows deep copying, membership checks over projects, and type-safe equality. Concrete use cases include managing and manipulating structured data associated with AST elements during source code pretty printing.",
      "description_length": 416,
      "index": 1696,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent abstract memory values in Frama-C's value analysis. It provides operations for equality checking, comparison, hashing, and pretty-printing these keys, along with deep copying and project membership testing. The keys are used to index memory states in static analysis plugins, enabling precise tracking and manipulation of program values during analysis.",
      "description_length": 410,
      "index": 1697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in attribute maps, including equality, comparison, hashing, and pretty-printing. It works with keys that may contain project-specific data, supporting deep copying and membership checks against project skeletons. Concrete use cases include managing and comparing attribute keys in CIL-based analyses, such as tracking variable or function attributes across different project contexts.",
      "description_length": 429,
      "index": 1698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings from control flow graph vertices to arbitrary data, enabling efficient traversal, merging, and transformation of vertex-associated information. It supports operations like filtering, sequence conversion, and reverse iteration, essential for analyzing reachable states and transitions in normalized control flow graphs. The key module defines identifiers for vertices in unrolled graphs, offering equality, comparison, and membership checks, while the vertex-based map module associates these keys with typed values, supporting deep copying and project-aware queries. Together, they facilitate precise abstract interpretation tasks such as tracking per-vertex data during control flow analysis.",
      "description_length": 722,
      "index": 1699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based data type for managing collections of values with syntactic scope information, using the provided `Data` module to handle the elements. It supports standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is suitable for tracking scoped CIL entities like variables or labels within Frama-C analyses.",
      "description_length": 432,
      "index": 1700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, ensuring structural equality and proper hashing for CIL expressions. It provides standard operations like `equal`, `compare`, `hash`, and `pretty` for handling hash tables with CIL-specific value types. Concrete use cases include managing and comparing sets of CIL expressions with structural equivalence in static analysis plugins.",
      "description_length": 423,
      "index": 1701,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are abstract memory values and values are determined by the `Data` parameter. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage structured data indexed by memory locations in static analysis tasks, such as tracking variable bindings or abstract states.",
      "description_length": 413,
      "index": 1702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map keyed by the `Base.t` type, where values are of the parameterized `Data.t` type. It provides standard map operations such as lookup (`find`), insertion (`add`), membership testing (`mem`), and traversal (`iter`, `map`, `fold`), all while preserving the structural properties of the base memory zone. It is used to associate data with memory bases in static analysis, such as tracking memory permissions or abstract values per memory block.",
      "description_length": 480,
      "index": 1703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string command-line options with validation, alias resolution, and serialization customization, operating on string data and lists for constraints. It supports setting and retrieving values, change hooks, and dynamic transformations, ensuring type safety with Frama-C's kernel state. The child module extends this with kernel function integration, offering equality checks, comparison, hashing, and pretty-printing for string-based parameters. Together, they enable defining command-line options that accept function names or identifiers, supporting deep copying, project membership checks, and structured serialization.",
      "description_length": 640,
      "index": 1704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports project membership checks, deep copying, and type representation for integration with Frama-C's plugin system. Concrete use cases include managing annotated CIL code entities with associated metadata in a plugin's analysis or transformation passes.",
      "description_length": 426,
      "index": 1705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of strings with value semantics, supporting operations like membership testing, comparison, hashing, and pretty-printing. It works with a custom `t` type representing string sets, along with associated descriptors and representations for integration with Frama-C's plugin system. It is used to manage collections of strings in a way that supports deep copying, project-specific filtering, and structured serialization within static analysis plugins.",
      "description_length": 478,
      "index": 1706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with the `Frama_c_kernel.Parameter_category.t` type, allowing plugins to associate parameters with specific behaviors and dependencies. Concrete use cases include setting up configurable analysis options and controlling plugin behavior through command-line flags or GUI elements.",
      "description_length": 467,
      "index": 1707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes CIL statements as keys in map structures, enabling the association of statement-specific data with standard map operations like lookup, insertion, and iteration. It supports key operations on wrapped CIL statements, including equality, comparison, hashing, and pretty printing, facilitating their use in static analysis or transformation tasks. Submodules provide concrete implementations for maps with CIL statements as keys, including support for serialization, comparison, and structured output. Examples include tracking control flow information or annotating statements with analysis results in Frama-C plugins.",
      "description_length": 638,
      "index": 1708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on logic function information with structural comparison. It provides operations for equality, comparison, hashing, and pretty-printing keys, which encapsulate logic symbol names and argument types. Use cases include managing logic function metadata in analyses or transformations that require precise symbol identity and structure.",
      "description_length": 378,
      "index": 1709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a map structure, specifically handling character-based keys. It provides operations for equality checks, comparison, hashing, and pretty-printing keys, along with deep copying and membership testing within projects. Use cases include managing and manipulating map keys in analysis plugins, such as tracking character identifiers across different project contexts.",
      "description_length": 411,
      "index": 1710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table indexed by properties ordered by function criteria, where values are of type `Data.t`. It provides standard operations including equality, comparison, hashing, pretty-printing, deep copying, and membership checks based on project conditions. Use cases include managing property-specific data in static analysis plugins, such as tracking function-specific invariants or per-property analysis results.",
      "description_length": 435,
      "index": 1711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for `Lval` values with structural equality based on `eid`. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include managing and caching analysis results keyed by l-values in CIL-based plugins.",
      "description_length": 388,
      "index": 1712,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys used in a map structure, including equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing map keys, which may include project-specific data. Concrete use cases include storing and retrieving values associated with keys in a map, comparing keys for ordering, and checking key membership based on project conditions.",
      "description_length": 416,
      "index": 1713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with wide strings, including equality, comparison, hashing, and pretty-printing. It supports data types involving wide strings and project-specific values, enabling efficient key-based lookups and manipulations. Concrete use cases include managing symbol tables or caches where wide strings serve as keys in static analysis plugins.",
      "description_length": 385,
      "index": 1714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify global variables in CIL (C Intermediate Language) within Frama-C. It supports operations like equality checking, comparison, hashing, and pretty-printing for these keys, enabling efficient storage and retrieval in hash tables. It is used when analyzing or transforming C programs, where tracking global variables across different program points or analyses is required.",
      "description_length": 434,
      "index": 1715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for managing multiple kernel function maps with support for equality, comparison, hashing, and pretty-printing operations. It works with function declarations and pure prototypes as keys, enabling precise analysis and transformation tasks in Frama-C plugins. Concrete use cases include tracking function-specific properties and enabling inter-procedural analysis by associating data with multiple functions.",
      "description_length": 441,
      "index": 1716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL types compared by name without unrolling, and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage type-indexed data in CIL-based analyses, such as tracking type-specific properties or annotations across C program elements.",
      "description_length": 432,
      "index": 1717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages configurable string parameters for Frama-C plugins, supporting value validation against predefined string sets, alias resolution, and persistent state management. It handles individual strings as parameter values and uses string lists or sets for defining valid options, with hooks for change notifications and serialization. The child module enhances this functionality by providing efficient set operations for tracking identifiers and managing user-defined parameters with membership checks and deep copying. Together, they enable plugins to enforce restricted input domains, such as command-line options with fixed choices, while maintaining consistent and serializable state across projects.",
      "description_length": 716,
      "index": 1718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module configures string parameters with validation, aliases, and change tracking for plugin settings in analysis workflows. It supports strings and string lists with command-line parsing, defaults, and state persistence, enabling tasks like filtering functions during static analysis. A key child module provides `Fundec_set` for managing sets of function declarations with equality, comparison, and project-aware operations. Together, they allow precise control and transformation of string-based settings and function sets across analysis runs.",
      "description_length": 552,
      "index": 1719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for a given `Data` module, enabling operations like lookup, comparison, and hashing on map values. It supports structured data management with functionalities such as deep copying, pretty printing, and project-aware membership checks. Concrete use cases include maintaining and manipulating collections of CIL entities like variables or functions indexed by identifiers.",
      "description_length": 417,
      "index": 1720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure parameterized by a `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing for values stored in the table. It works with abstract memory representations defined in `Frama_c_kernel.Cvalue.Model.Hashtbl`, supporting deep copying and project-based membership checks. Concrete use cases include managing and manipulating abstract memory states during static analysis, such as tracking variable bindings or memory slices in value analysis.",
      "description_length": 530,
      "index": 1721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that are based on logic real numbers in CIL. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, as well as functions for deep copying and checking project membership. The module is used to manage and manipulate logic real-based identifiers in analyses that require precise keying, such as memoization or caching of results tied to specific logical real values.",
      "description_length": 460,
      "index": 1722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with abstract types representing categories and states, enabling precise control over plugin behavior through configuration parameters. Concrete use cases include defining default and special categories like `@none`, `@default`, and `@all`, and setting up how these categories interact with plugin parameters and command-line options.",
      "description_length": 517,
      "index": 1723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associating field information with values. It supports equality checks, comparison, hashing, and pretty-printing of keys, which are essential for managing field data during static analysis. Concrete use cases include tracking and comparing struct field properties, such as offsets or types, within CIL-based analyses.",
      "description_length": 370,
      "index": 1724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based parameters associated with the `-cpp-extra-args-per-file` option, providing standard operations for comparison, hashing, and pretty printing. It supports managing and querying representations of these parameters, enabling precise control over per-file C preprocessor arguments during analysis. Concrete use cases include validating and transforming file-specific compilation flags in Frama-C plugins.",
      "description_length": 458,
      "index": 1725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps, providing equality, comparison, and hashing operations. It supports structured values with deep copying, pretty printing, and project membership checks. Concrete use cases include managing symbolic keys in static analysis plugins and ensuring unique, comparable identifiers for map-based data representations.",
      "description_length": 363,
      "index": 1726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.V",
      "library": "frama-c.kernel",
      "description": "This module represents vertices in a service graph, where each vertex has a unique label and supports comparison, hashing, and equality checks. It provides operations to create vertices from labels and retrieve their labels, ensuring vertices can be used in ordered and hashed collections. Concrete use cases include managing function nodes in a callgraph for static analysis, where each vertex corresponds to a function with a unique identifier.",
      "description_length": 446,
      "index": 1727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string list data type with operations for equality, comparison, hashing, and pretty printing. It provides structured handling of command-line parameters represented as lists of strings, including deep copying and project membership checks. Concrete use cases include parsing and managing multi-value command-line options in Frama-C plugins.",
      "description_length": 365,
      "index": 1728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with logic real values, including equality, comparison, hashing, and pretty-printing functions. It supports data types involving `Frama_c_kernel.Cil_datatype.Logic_real.Map.key`, typically representing keys tied to logic real expressions in CIL. Use cases include managing and manipulating map keys in static analysis plugins that handle logical real numbers, ensuring efficient lookups and comparisons.",
      "description_length": 456,
      "index": 1729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent syntactic scopes in CIL, including operations for equality, comparison, hashing, and pretty-printing. It works with types like `Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl.key` and `Project_skeleton.t`, supporting deep copies and membership checks over project skeletons. Concrete use cases include managing and querying scoped identifiers in C analysis plugins, such as tracking variable declarations within specific syntactic contexts.",
      "description_length": 502,
      "index": 1730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters with validation and state handling, particularly for values referencing functions or symbols. It supports registering dynamic constraints, validating inputs against function declarations, and maintaining aliases for serialization. The core data types represent single or multiple function declarations, enabling operations like equality, comparison, and pretty-printing, while submodules handle sets of functions with project membership checks and deep copying. Examples include defining command-line options that accept function names, validate them against available symbols, and support flexible input formats for analysis tools.",
      "description_length": 689,
      "index": 1731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store CIL statement-related data. It provides standard operations including equality checks, comparison, hashing, and pretty printing for keys, which are essential for managing and retrieving statement-specific information efficiently. The module supports deep copying and project membership checks, making it suitable for scenarios where distinct key identities and project-specific filtering are required.",
      "description_length": 465,
      "index": 1732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify type information in CIL (C Intermediate Language) within Frama-C. It provides operations for equality checking, comparison, hashing, and pretty-printing keys, which are essential for managing and querying type data during static analysis. Use cases include tracking and comparing C type structures across different parts of the analyzed codebase.",
      "description_length": 411,
      "index": 1733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for grouping command-line parameters, specifically working with `Category.t` and `elt` types. It allows creating named categories, setting default behaviors, and enabling the `@all` category with specific interpretations. Concrete use cases include organizing related options in Frama-C plugins and controlling global parameter behavior through category hierarchies.",
      "description_length": 409,
      "index": 1734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps where each value has a lattice structure, enabling operations like equality, comparison, hashing, and pretty printing. It supports data types built over a lattice-equipped value type, providing deep copy and project-aware membership checks. Concrete use cases include analyzing program states where values have hierarchical or partial-order relationships, such as abstract interpretation domains.",
      "description_length": 424,
      "index": 1735,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that uniquely identify built-in logic information entries. It provides standard operations such as equality, comparison, hashing, and pretty printing for these keys, along with deep copying and membership testing based on project skeletons. The keys are used to manage and query distinct logic constructs in static analysis plugins, ensuring efficient and precise handling of CIL-based data.",
      "description_length": 426,
      "index": 1736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent memory locations with bit-level precision, combining base addresses and bit offsets. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with deep copying and project membership checks. It is used to track and manipulate fine-grained memory regions in static analysis, such as during pointer or memory state computations.",
      "description_length": 422,
      "index": 1737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports deep copying, project membership checks, and exposes type descriptors for integration with Frama-C's typing system. Concrete use cases include managing collections of logic type information with efficient lookups and persistence across analysis phases.",
      "description_length": 430,
      "index": 1738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Zero.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with support for equality, comparison, hashing, and pretty-printing operations. It works with a specific type `t` that represents values of the defined data type, alongside lists of type representatives and descriptors for structural manipulation. It is used to implement command line options with rich type handling, enabling features like deep copying, project membership checks, and user-friendly value display.",
      "description_length": 455,
      "index": 1739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string and string list parameters for plugins, offering validation against criteria like function names, alias handling, and serialization control. It supports operations such as equality, comparison, hashing, and pretty printing, along with utilities for tracking changes, persisting state, and checking project membership. The child module extends this functionality by treating string lists as single values, enabling structured handling of multi-item configurations. Examples include validating plugin options dynamically, managing configuration files with aliases, and maintaining consistent string-based state across sessions.",
      "description_length": 652,
      "index": 1740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map.Make",
      "library": "frama-c.kernel",
      "description": "Implements a map datatype for values of a specified type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. Supports deep copying, membership checks over project skeletons, and integrates with Frama-C's type and descriptor system for serialization and representation. Useful for managing structured collections of CIL terms with efficient lookups and type-safe transformations.",
      "description_length": 428,
      "index": 1741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL statements as values. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. It is used to manage and manipulate statement-based key sets in static analysis plugins.",
      "description_length": 316,
      "index": 1742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map used to manage logic information in CIL-based analyses. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used in associative data structures and displayed meaningfully. The keys are designed to encapsulate logic-related data with support for project membership checks and deep copying to avoid shared state.",
      "description_length": 418,
      "index": 1743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are structured values with equality and comparison operations. It supports concrete operations like deep copying, hashing, equality checks, and pretty-printing for structured keys. Use cases include managing unique identifiers for analysis artifacts or tracking structured data in static analysis passes.",
      "description_length": 355,
      "index": 1744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based configuration parameters for plugins, supporting validation, change tracking, and alias handling for individual strings and string lists. It enables use cases like command-line parsing and dynamic configuration with side-effect triggers, while its child module adds set-based string operations for managing unique string collections with equality checks and project-aware data handling. Examples include tracking plugin options, storing project-specific string sets, and synchronizing parameter changes across Frama-C components. Key data types include strings, string lists, and string sets, with operations for validation, comparison, and state serialization.",
      "description_length": 694,
      "index": 1745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing operations for equality, comparison, hashing, and pretty-printing. It supports data types related to map keys with functions to check membership in projects, create deep copies, and describe key values. Concrete use cases include managing and comparing keys in map-based data structures and ensuring correct serialization and project membership checks in Frama-C plugins.",
      "description_length": 445,
      "index": 1746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table implementation, specifically tailored for character-based keys. It provides essential operations including equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. Use cases include managing symbol tables, caching mechanisms, and efficient lookups in analysis plugins where character keys are significant.",
      "description_length": 426,
      "index": 1747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for string keys, where the values are of a provided `Data` module's type. It supports standard operations like equality checking, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage string-indexed collections of values with strong typing and efficient lookups, particularly in static analysis contexts requiring precise data representation.",
      "description_length": 466,
      "index": 1748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities to define, validate, and manipulate string-based command-line parameters, supporting both single values and lists with features like value constraints, alias resolution, and dynamic state hooks. It includes operations for comparison, hashing, pretty printing, and deep copying, working seamlessly with project skeletons and string values. You can use it to manage validated options such as file paths, identifiers, or configuration strings in Frama-C plugins, ensuring proper project membership and structural representation. The integration of serialization and dynamic behavior makes it suitable for parameters that trigger actions or require persistence during analysis.",
      "description_length": 704,
      "index": 1749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps, providing operations such as equality, comparison, hashing, and pretty printing. It supports structured values of type `Map.Key.t`, including handling project-specific data through `mem_project` and deep copying with `copy`. Concrete use cases include managing and comparing map keys in static analysis plugins, particularly when tracking project-specific state or attributes.",
      "description_length": 430,
      "index": 1750,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for logic types, using the provided `Data` module to define the value type. It supports standard map operations like comparison, equality, hashing, and pretty-printing, while ensuring deep copying and project-aware membership checks. It is used to manage and manipulate logic type maps in CIL-based analyses.",
      "description_length": 355,
      "index": 1751,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are expressions with structural equality and values are of a given data type. It supports standard map operations like lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing. It is used to associate CIL expressions with custom data in a way that respects project-specific analysis states.",
      "description_length": 365,
      "index": 1752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and controlling command-line parameters related to kernel functions. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, each influencing how function declarations are interpreted. Use cases include organizing plugin options and controlling default or global behavior of function-related parameters in static analysis tools.",
      "description_length": 425,
      "index": 1753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are of a fixed type and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with maps whose values adhere to the provided `Data` module's type and includes utilities for project membership checks and deep copying. Concrete use cases include managing value mappings in static analysis plugins where type-specific behavior and deep copies are required.",
      "description_length": 463,
      "index": 1754,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent memory location zones, which associate bases with bit ranges. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. Use cases include managing and querying memory regions in static analysis plugins, such as tracking variable allocations or analyzing pointer ranges.",
      "description_length": 432,
      "index": 1755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are compared structurally, treating equivalent CIL expressions with matching sizes inside `sizeof` as equal. It supports standard map operations like lookup, insertion, and iteration, along with deep copying, hashing, and pretty printing. It is used to manage and manipulate CIL expressions in contexts where structural equivalence and size-based comparison are required, such as in static analysis plugins.",
      "description_length": 447,
      "index": 1756,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps representing memory slices, providing equality, comparison, hashing, and pretty-printing operations. It supports data types that include project-specific identifiers and memory representations, ensuring deep copying and membership checks for project values. Concrete use cases include managing and comparing memory keys in abstract interpretation contexts, such as tracking variable bindings or memory regions during static analysis.",
      "description_length": 479,
      "index": 1757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table indexed by CIL statements, where values are of a specified data type. It supports standard operations like equality, comparison, hashing, and pretty-printing for statement-indexed tables. It is used to associate and manipulate data tied to specific points in C code, such as analysis results or annotations.",
      "description_length": 340,
      "index": 1758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys and values are of a specified type, supporting operations like equality, comparison, hashing, and pretty-printing. It works with any data type through the `Data` module parameter, enabling storage and retrieval of structured values. Concrete use cases include managing mappings from keys to analyzed program states or tracking variable-value associations during static analysis.",
      "description_length": 434,
      "index": 1759,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps that uniquely identifies CIL types, supporting efficient comparison, equality checks, and hashing. It works with the `Typ` module's type definitions, using keys to represent types in a normalized form, typically for analysis or transformation passes. Concrete use cases include tracking type-specific properties across a program's AST or caching type analysis results.",
      "description_length": 411,
      "index": 1760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables tailored for static analysis plugins, mapping CIL statement HPT sets to arbitrary values with support for insertion, lookup, iteration, and in-place filtering. It enables ordered traversal, bulk conversions, and safe value access via optional returns and default values, while allowing custom comparison logic for structured data. The key module handles statement identifiers with deep copies, equality, and pretty-printing, facilitating context-sensitive analysis across CIL statements. The value module specializes in type-safe storage and manipulation of statement-associated data, supporting deep copying, membership tests, and analysis-specific annotations like control flow tracking.",
      "description_length": 733,
      "index": 1761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership checks over project skeletons, and type-safe value representations. Concrete use cases include tracking and manipulating CIL component metadata in static analysis plugins.",
      "description_length": 411,
      "index": 1762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table mapping memory locations to byte-based offsets, supporting operations like equality, comparison, hashing, and pretty-printing. It works with types involving memory bases and offsets, along with project-aware data through `mem_project`. Concrete use cases include tracking and comparing memory access patterns in static analysis plugins.",
      "description_length": 378,
      "index": 1763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps where each key represents a position in a source file. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, as well as functions to check project membership and perform deep copies. It is used when managing per-position data, such as in static analysis passes that track information at specific program points.",
      "description_length": 396,
      "index": 1764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps where each value has a lattice structure, enabling operations like equality, comparison, hashing, and pretty-printing on these maps. It supports data types composed of key-value pairs, with values adhering to a lattice structure defined by the `Data` module. Concrete use cases include analyzing program states where each key represents a variable and each value tracks abstract properties that form a lattice, such as intervals or sets.",
      "description_length": 465,
      "index": 1765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic type names and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It provides a deep copy function, a membership check for project skeletons, and standard map functionalities such as key-based lookups and value insertion. This structure is used to manage and manipulate collections of logic types indexed by name in a type-safe manner.",
      "description_length": 450,
      "index": 1766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling file paths within a plugin, supporting operations like equality, comparison, hashing, and pretty printing. It works with a custom type `t` representing file paths and integrates with Frama-C's project system through functions like `mem_project` to check project membership. Concrete use cases include managing and comparing file path data in plugin analyses, ensuring deep copies and proper serialization for project-specific values.",
      "description_length": 477,
      "index": 1767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values that include project-specific data. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and membership checking over project skeletons. The key type supports structured values with embedded project information, enabling precise handling and discrimination of CIL predicates based on their structural and project-related properties.",
      "description_length": 479,
      "index": 1768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify logic symbols based on their name and structural type information, ignoring polymorphism. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with utilities for deep copying and checking project membership. These keys are used to manage and retrieve logic function or predicate definitions with structural equivalence in Frama-C's analysis plugins.",
      "description_length": 457,
      "index": 1769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing individual keys. It supports concrete use cases such as managing and querying hash tables with structured keys, ensuring deep copying and project membership checks. The type `t` represents the key values, while functions like `equal`, `hash`, and `mem_project` enable efficient storage, retrieval, and analysis of key-based data within the hash table.",
      "description_length": 490,
      "index": 1770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking and comparing field information in CIL structures, with deep copying and project-aware membership checks. The hash tables are used to manage and manipulate CIL field data efficiently within Frama-C plugins.",
      "description_length": 432,
      "index": 1771,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are identifiers and values are of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data management with deep copying, membership checks over projects, and type-safe value representations. Concrete use cases include tracking term identifiers in CIL-based analyses and maintaining value mappings across program transformations.",
      "description_length": 441,
      "index": 1772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for logic variables, where keys are logic variables and values are of a specified data type. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate mappings involving logic variables in static analysis plugins.",
      "description_length": 404,
      "index": 1773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for 64-bit integer keys, where the value type is determined by the provided `Data` module. It supports standard operations such as lookup, insertion, and iteration, along with deep copying, equality checking, and pretty printing. It is used when building analyses or plugins that require efficient mapping of 64-bit integers to structured data, such as tracking value ranges or abstract states in static analysis.",
      "description_length": 467,
      "index": 1774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t` with structural equality and comparison, including specialized handling for `sizeof` expressions. It provides standard operations like `equal`, `compare`, `hash`, and `pretty`, along with deep copying, membership checking, and project-aware queries. Concrete use cases include managing and comparing CIL expressions with structural identity, particularly in analysis plugins requiring precise expression equivalence.",
      "description_length": 489,
      "index": 1775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are standard integers and values are of a specified datatype, supporting operations like equality, comparison, hashing, and pretty printing. It is designed for managing collections of values with efficient lookup and traversal, suitable for scenarios requiring structured data storage with fast access. Concrete use cases include tracking analysis results or mapping identifiers to complex values in static analysis plugins.",
      "description_length": 477,
      "index": 1776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map-like data structure that enforces unique bindings, supporting operations like insertion, lookup, and iteration. It works with key-value pairs where keys are ordered and values can be any type that conforms to the required equality and comparison constraints. It is used to manage internal plugin state where multibindings are invalid, such as tracking unique analysis results or configuration settings per key.",
      "description_length": 448,
      "index": 1777,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that conform to the `Data` module signature, enabling efficient lookups and storage keyed by `Varinfo` instances. Concrete use cases include tracking variable-specific analyses or annotations across CIL structures in Frama-C plugins.",
      "description_length": 425,
      "index": 1778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, using `Nativeint` keys. It provides standard map operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate maps of native integer-indexed data in a type-safe manner.",
      "description_length": 356,
      "index": 1779,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for normalized filepaths, providing equality, comparison, and hashing operations tailored for use in persistent and project-aware data structures. It supports type-safe manipulation of filepath keys with functions like `equal`, `compare`, `hash`, and `pretty`, ensuring correct behavior in hash-based containers. Concrete use cases include tracking file-based analyses across different projects and managing file-specific data in Frama-C plugins.",
      "description_length": 488,
      "index": 1780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map data structure with operations for key-value associations, including insertion, lookup, and iteration. It works with string keys and arbitrary values conforming to the `Datatype` signature, supporting serialization, comparison, and pretty-printing. Concrete use cases include managing configuration settings or command-line option values indexed by string identifiers.",
      "description_length": 404,
      "index": 1781,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with `Term_lval` values, including equality, comparison, hashing, and pretty-printing. It supports data types involving CIL term locations (`Term_lval`) and includes utilities for checking membership in projects and deep copying. Concrete use cases include managing and comparing symbolic expressions or memory locations in static analysis plugins.",
      "description_length": 401,
      "index": 1782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line string parameters with validation and state handling, supporting restricted value sets and C function name checks. It includes a string set submodule for structured collections with comparison, hashing, and project integration, enabling precise handling of function names or configuration options. You can define CLI options that accept only specific strings, validate identifiers, and persist selections across sessions. The set module enhances this by allowing set operations and structured storage for analysis configurations.",
      "description_length": 562,
      "index": 1783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table that supports equality, comparison, and hashing operations tailored to values containing project-specific data. It includes functions to check membership within project contexts, perform deep copies, and pretty-print keys. The module is used to manage and query structured, project-associated keys in a hash table, enabling precise and context-aware value storage and retrieval.",
      "description_length": 426,
      "index": 1784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps over CIL offsets, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with values that include project-specific data, enabling checks on project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing offset-based keys in static analysis plugins, such as tracking memory layout or field positions in C structures.",
      "description_length": 459,
      "index": 1785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store kernel function-related data, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with the `Frama_c_kernel.Kernel_function.Hptset.Hashtbl.key` type, which represents keys tied to kernel function state across different projects. Concrete use cases include managing per-function metadata in plugins, such as analysis results or annotations, ensuring correct comparison and storage behavior across project variants.",
      "description_length": 520,
      "index": 1786,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are of type `Data.t` and values are booleans. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to track sets of `Data.t` elements with efficient lookup and storage, particularly in static analysis plugins requiring boolean-valued mappings.",
      "description_length": 412,
      "index": 1787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "Creates a hash table specialized for CIL lvalue keys with structural equality and serialization support. It provides standard operations like `add`, `find`, and `iter`, along with deep copying, pretty printing, and project-aware membership checks. Useful for tracking or analyzing C program variables and memory locations during static analysis.",
      "description_length": 345,
      "index": 1788,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by strings, where the values are of a specified type provided by the `Data` module. It includes standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage string-indexed collections of values with full semantic support for analysis and display in Frama-C plugins.",
      "description_length": 403,
      "index": 1789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module handles string-based parameters in a plugin's configuration, supporting equality checks, comparison, hashing, and pretty-printing. It works with strings and project-related predicates to enable deep copies and membership checks within project skeletons. Concrete use cases include managing plugin-specific string settings and ensuring consistent handling of string values across different plugin components. Submodules extend this functionality to structured string collections and validation rules.",
      "description_length": 511,
      "index": 1790,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for a given data type, enabling operations like lookup, comparison, and pretty-printing on map values. It supports data types that conform to the `Data` module signature, organizing values indexed by keys within Frama-C's project management system. Concrete use cases include tracking and manipulating project-specific internal states or analysis results associated with abstract syntax trees.",
      "description_length": 441,
      "index": 1791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for logic types in CIL. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hashtable structure when working with logic type representations in Frama-C plugins.",
      "description_length": 377,
      "index": 1792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for `int32` keys, where the mapped values are of a provided `Data` module's type. It supports standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing. It is suitable for managing collections of analysis data indexed by 32-bit integers in Frama-C plugins.",
      "description_length": 369,
      "index": 1793,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given CIL expression type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that conform to the CIL expression structure, using `eid`-based equality unless structural equality is explicitly required. Concrete use cases include managing and manipulating collections of CIL expressions with efficient lookups, such as tracking expression occurrences or building analysis-specific caches.",
      "description_length": 507,
      "index": 1794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify predicates in CIL-based analyses. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with utilities for deep copying and checking project membership. The keys are used to manage and query predicate-specific data during static analysis, ensuring efficient and precise tracking of analysis states.",
      "description_length": 417,
      "index": 1795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for character keys, where each table's values are of a specified data type. It supports standard operations such as equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to manage and manipulate character-indexed collections of custom data in a type-safe manner.",
      "description_length": 390,
      "index": 1796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic real numbers, with keys ordered by structural comparison. It provides standard map operations including insertion, lookup, deletion, and traversal, along with equality, hashing, and pretty-printing functions. The map is used to manage and manipulate sets of logic real values with efficient key-based access, suitable for static analysis tasks involving numerical constraints.",
      "description_length": 442,
      "index": 1797,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines hash table keys based on CIL expressions, providing equality, comparison, and hashing operations that respect the structural identity of expressions via their `eid`. It supports creating, copying, and printing keys, as well as checking membership based on project information embedded in the keys. Use this module when building or manipulating hash tables that index CIL expressions by their structure or associated project data.",
      "description_length": 449,
      "index": 1798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes associations between variable information sets and arbitrary values, enabling ordered map operations such as insertion, merging, filtering, and traversal. It supports advanced iteration patterns like reverse traversal and bounded searches, along with transformations including `map`, `fold`, and `filter_map`, ensuring strict key ordering for correctness in static analysis contexts. One sub-module specializes in managing maps with `Varinfo` keys and structured `Data` values, offering operations like equality, comparison, and project membership checks, useful for tracking variable-specific analyses across contexts. Another sub-module defines key operations for CIL-based variable information, supporting identifier management and structured comparisons in static analysis plugins.",
      "description_length": 807,
      "index": 1799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map for handling multiple values per key, supporting operations like insertion, lookup, and iteration over key-value pairs. It works with string keys and lists of values, providing efficient storage and retrieval for configurations with repeated keys. Concrete use cases include managing command-line options that accept multiple arguments or parsing structured input where keys may occur more than once.",
      "description_length": 444,
      "index": 1800,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for storing values of type `Data.t` indexed by kernel functions. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Use cases include managing per-function data in static analysis plugins, such as caching analysis results or tracking function-specific properties.",
      "description_length": 407,
      "index": 1801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL types without unrolling struct definitions during comparison. It supports operations like equality checking, comparison, hashing, and pretty-printing for these keys, which are essential for managing type representations in analyses. The module is used to track and compare CIL types efficiently in contexts like value analysis or slicing, where precise type identity is critical.",
      "description_length": 448,
      "index": 1802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that uniquely identify code annotations in the CIL intermediate language representation. It supports operations such as equality checking, comparison, hashing, and pretty printing for these keys, enabling efficient storage and retrieval in maps or hash tables. It is used to manage and manipulate keys tied to specific code annotations, such as those associated with CIL statements or functions, during static analysis.",
      "description_length": 454,
      "index": 1803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are identifiers and values are of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with structured data in the context of CIL-based analysis, particularly for handling predicates associated with project identifiers. Use cases include tracking and manipulating project-specific data during static analysis, such as storing and querying analysis results keyed by project identifiers.",
      "description_length": 494,
      "index": 1804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL structures with offset equality semantics. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate keys in a hashtable where structural equivalence of CIL elements matters.",
      "description_length": 385,
      "index": 1805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with the `Frama_c_kernel.Parameter_category` type to represent categories and uses strings for category names. Concrete use cases include setting up default and \"all\" categories, enabling all parameters with specific interpretations, and defining relationships between categories for option grouping and activation.",
      "description_length": 501,
      "index": 1806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps, providing operations such as equality, comparison, hashing, and pretty printing. It supports data types that can be stored in a map, ensuring deep copying and membership checks within project contexts. Concrete use cases include managing symbolic keys in static analysis plugins, where unique identification and comparison are required.",
      "description_length": 390,
      "index": 1807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.True.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing. It supports structured values through a descriptor and provides deep copying, membership testing within projects, and a list of representative values. Concrete use cases include managing and manipulating abstract values in static analysis plugins, such as tracking program states or analysis results.",
      "description_length": 414,
      "index": 1808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for hash tables using CIL offset values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types involving CIL offsets, particularly for analysis plugins requiring structural equivalence and project-aware memory management. Concrete use cases include tracking field offsets in structs or unions during static analysis and managing offset-based mappings in Frama-C plugins.",
      "description_length": 451,
      "index": 1809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string set data type with operations for membership testing, comparison, hashing, and pretty-printing. It supports command-line option parsing by providing a structured descriptor and deep copy functionality. Concrete use cases include managing sets of strings as configuration options or analysis parameters in Frama-C plugins.",
      "description_length": 353,
      "index": 1810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module handles command-line parameters that accept lists of strings, supporting validation, alias management, and custom serialization. It works with string lists as core data structures and provides specialized functions to enforce constraints or allow arbitrary input, such as validating function names or collecting analysis options. The child module extends this functionality by treating string lists as single values, enabling operations like equality checks, comparison, and pretty-printing using the `As_string.Datatype.t` type. Together, they facilitate building configurable command-line interfaces, such as managing include paths or macro definitions in Frama-C plugins.",
      "description_length": 686,
      "index": 1811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued plugin parameters in Frama-C, organizing them in maps keyed by function declarations to support configuration and analysis tasks. It provides data types and operations for storing, validating, and transforming string values with support for aliases, hooks, and serialization. Submodules enhance handling by enabling equality checks, comparison, and pretty printing, facilitating integration with custom plugins. Example uses include tracking function-specific string settings and enforcing constraints during static analysis.",
      "description_length": 559,
      "index": 1812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on CIL l-values with eid-based equality, and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to track or associate data with CIL l-values in a way that respects their identity within the analysis framework.",
      "description_length": 412,
      "index": 1813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Action.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured datatype with support for equality, comparison, hashing, and pretty-printing operations. It works with a specific type `t` that represents values of the datatype, along with associated descriptors and representants. Concrete use cases include implementing command-line options that require structured data handling, such as parsing and storing complex configuration values with custom semantics.",
      "description_length": 428,
      "index": 1814,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify logic constants in CIL (C Intermediate Language) within Frama-C. It provides operations for equality checking, comparison, hashing, and pretty-printing these keys, along with deep copying and membership testing based on project projections. The module is used to manage and manipulate logic constant identifiers in static analysis plugins, ensuring efficient and correct handling of symbolic values during analysis.",
      "description_length": 480,
      "index": 1815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in boolean maps, providing equality, comparison, hashing, and pretty-printing operations. It supports keys that may contain project-specific values, allowing checks for the presence of projects satisfying a predicate and enabling deep copies to avoid shared state. Concrete use cases include managing and comparing boolean map keys in static analysis plugins where project-specific data must be tracked and manipulated.",
      "description_length": 464,
      "index": 1816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line parameters in Frama-C's autocomplete system. It supports operations like equality checking, comparison, hashing, and pretty-printing for values of this type, along with deep copying and project membership testing. It is used to represent and manipulate string parameters in a structured way during command-line processing.",
      "description_length": 393,
      "index": 1817,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for values of a given `Data` type, enabling operations like equality checks, comparison, hashing, and pretty-printing on those values. It supports concrete data types that require structured representation, such as those used in Frama-C annotations or property tracking. Use cases include managing and querying collections of emitter-related data with strong typing and efficient lookups.",
      "description_length": 436,
      "index": 1818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like `equal`, `compare`, `hash`, and `pretty` for native integer keys. It supports concrete use cases such as efficient storage and retrieval of typed values indexed by native integers, with deep copying and project membership checks. The module works directly with `Frama_c_kernel.Type.t`, `Frama_c_kernel.Descr.t`, and `Stdlib.Format.formatter` for type handling, description, and pretty printing.",
      "description_length": 520,
      "index": 1819,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure keyed by the `Data` module's type, supporting operations like equality, comparison, hashing, and pretty-printing. It provides typed values with descriptors for integration into the Frama-C kernel, including deep copying and project membership checks. Concrete use cases include managing typed maps of analysis data within Frama-C plugins.",
      "description_length": 379,
      "index": 1820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type with operations for equality, comparison, hashing, and pretty-printing. It supports hashconsed data structures by providing a unique named type, descriptor, and representants, ensuring deep copying and project membership checks. Concrete use cases include managing interned keys in hash tables for efficient memory usage and comparison in static analysis plugins.",
      "description_length": 405,
      "index": 1821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths within a plugin, supporting operations like equality checking, comparison, hashing, and pretty-printing. It provides a structured way to register and manipulate file path data in Frama-C plugins, ensuring deep copies and project-specific membership checks. Concrete use cases include managing configuration file paths or tracking source file locations during static analysis.",
      "description_length": 439,
      "index": 1822,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype with keys based on the structural equality of CIL lvalues, using strict constant comparison. It supports operations like equality checking, comparison, hashing, and pretty printing, and is suitable for tracking and comparing CIL value structures in a strict manner. It is useful in static analysis plugins needing precise value tracking across program states.",
      "description_length": 401,
      "index": 1823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are compared structurally without unrolling, using the provided `Data` module for value operations. It supports standard hash table operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include managing CIL types with structural identity in static analysis plugins, such as tracking type definitions or analyzing type-based properties across C codebases.",
      "description_length": 489,
      "index": 1824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with the `Frama_c_kernel.Parameter_category.t` type, which encapsulates category elements and their accessors. Concrete use cases include setting default category behavior, enabling all options with specific interpretations, and defining dependencies for custom categories.",
      "description_length": 461,
      "index": 1825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Frama_c_kernel.State.t` lists and `Parameter_category.accessor` values to associate behaviors with categories. Concrete use cases include setting default category behavior, enabling all options with a specific interpretation, or aliasing the `@all` category to another category.",
      "description_length": 475,
      "index": 1826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued configuration parameters for plugins, supporting validation, command-line parsing, and state persistence. It provides data types for atomic string values with operations for comparison, hashing, and pretty printing, along with utilities to retrieve and validate strings as plain values or function identifiers. Submodules enhance these capabilities by enabling deep copies, project membership checks, and unique identification of string settings. Example uses include defining plugin command-line flags, handling project-scoped strings, and validating user input during analysis.",
      "description_length": 613,
      "index": 1827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line string parameters with support for validation, aliases, and function identifier resolution, enabling strict input control and flexible configuration in analysis tools. It provides data types for single and set-based string parameters, with operations for comparison, hashing, pretty-printing, and state management through change hooks and custom serialization. Submodules extend functionality to handle string sets, supporting membership checks and integration with project skeletons for context-aware parameter handling. Example uses include managing file path lists, identifier filters, and validated plugin options in Frama-C extensions.",
      "description_length": 673,
      "index": 1828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for `Fundec.t` values with standard operations such as membership testing, comparison, and pretty printing. It supports command line option handling by providing deep copying, hashing, and project-aware filtering capabilities. Concrete use cases include managing and querying sets of function declarations during static analysis plugin execution.",
      "description_length": 390,
      "index": 1829,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype with deep copy, equality, comparison, and hashing operations based on the provided `Data` module. It supports structured values stored in `Hashtbl.t` and enables precise memory representation tracking, project membership checks, and pretty printing. Concrete use cases include managing stateful analyses or caching computed values in static analysis plugins.",
      "description_length": 400,
      "index": 1830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps based on CIL expressions, providing structural equality, comparison, and hashing operations. It works with CIL expressions (`Exp.t`) and supports efficient key-based lookups and map manipulations. Concrete use cases include managing expression-indexed data during static analysis, such as caching analysis results or tracking expression-specific properties across different analysis passes.",
      "description_length": 433,
      "index": 1831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for maps using `Term_offset` values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with map keys that represent term offsets in CIL structures, enabling precise manipulation and analysis of C code. Concrete use cases include tracking memory layout information and managing term-based identifiers in static analysis plugins.",
      "description_length": 417,
      "index": 1832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Float.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float parameter type for command-line options, supporting parsing of decimal values. It provides standard comparison, hashing, and pretty-printing operations tailored for float values. Concrete use cases include handling numerical configuration settings like thresholds or scaling factors in static analysis plugins.",
      "description_length": 338,
      "index": 1833,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Empty_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling empty strings within a plugin registration system. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to represent and manipulate string values that are guaranteed to be empty in the context of Frama-C plugin development.",
      "description_length": 369,
      "index": 1834,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing project-specific keys in static analysis plugins, ensuring deep copying and membership checks over project skeletons. The module works directly with `Hashtbl.Key.t` and integrates with Frama-C's type and descriptor system for structural representation.",
      "description_length": 454,
      "index": 1835,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing equality, comparison, and hashing operations required for map functionality. It supports concrete data types with a unique name, descriptor, and representation list for introspection and type management. Use cases include creating and managing key-based data structures in maps with precise type handling and efficient lookups.",
      "description_length": 401,
      "index": 1836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in maps within the value analysis framework, primarily for indexing abstract memory locations. It supports operations like equality, comparison, hashing, and pretty-printing for keys, which are essential for managing and querying abstract values. Concrete use cases include tracking memory regions during static analysis and enabling efficient lookups in abstract domains.",
      "description_length": 410,
      "index": 1837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL attributes within the Frama-C kernel. It supports operations such as equality checking, comparison, hashing, and pretty-printing for these keys, enabling efficient storage and retrieval in attribute-based analyses. Use cases include tracking and managing CIL attribute metadata during static analysis, such as associating attributes with specific AST nodes or handling project-specific attribute extensions.",
      "description_length": 476,
      "index": 1838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL component information, such as structures or unions, within the Frama-C kernel. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. These keys are used to manage and retrieve CIL component data efficiently in Frama-C plugins and analyses.",
      "description_length": 404,
      "index": 1839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps where keys are based on CIL types with structural comparison that ignores attributes. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate type-based keys in map structures during static analysis tasks, such as tracking type equivalence or organizing type-related data in plugins.",
      "description_length": 465,
      "index": 1840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type where keys are compared using structural equality, including strict handling of constants and `sizeof` expressions. It supports operations like equality checking, comparison, hashing, and pretty-printing for values stored in the hash table. It is used when building analyses that require canonical forms of CIL expressions with precise structural identity.",
      "description_length": 394,
      "index": 1841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values in Frama-C's abstract memory model, where keys are bytes-indexed locations and values are managed according to the provided `Data` module. It supports standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to represent and manipulate abstract memory states in static analysis plugins, particularly when tracking value associations in a mutable, efficient structure.",
      "description_length": 517,
      "index": 1842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like data structure with operations for comparing, hashing, and pretty-printing elements of a specific datatype. It works with values of type `Datatype.t`, supporting deep copies, membership checks over projects, and standard equality and ordering. Concrete use cases include managing and manipulating sets of abstract values in static analysis plugins, such as tracking sets of program states or expressions.",
      "description_length": 438,
      "index": 1843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by memory zones, where each zone is associated with a value of a specified type. It supports operations like equality checking, comparison, hashing, pretty-printing, and deep copying, as well as querying membership based on project-specific criteria. It is used to manage and manipulate zone-indexed data, such as memory state or analysis results, in a type-safe and efficient manner.",
      "description_length": 434,
      "index": 1844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store logic type information, including operations for equality, comparison, hashing, and pretty-printing. It works with CIL logic type descriptors and project skeletons to enable key-based lookups tied to specific analysis contexts. Concrete use cases include managing and retrieving logic type metadata during static analysis, ensuring keys are uniquely identified by name and type structure.",
      "description_length": 441,
      "index": 1845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in map structures, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing map keys, which may include project-specific data. Use cases include managing and comparing keys in maps that associate values with project elements, ensuring deep copies and proper semantic comparisons.",
      "description_length": 379,
      "index": 1846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that provides defined equality, comparison, and hash functions, organizing values into a map structure. Concrete use cases include managing collections of analyzed program elements indexed by keys, such as variable states or analysis results mapped to specific program points.",
      "description_length": 451,
      "index": 1847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map based on CIL enumeration items, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with unique identifiers for enum items in CIL, enabling efficient key-based lookups and manipulations. Use cases include tracking and comparing individual enumeration constants during C code analysis.",
      "description_length": 379,
      "index": 1848,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module constructs a map datatype based on a given value datatype, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with map structures where keys and values are governed by the provided `Data` module. Concrete use cases include managing collections of analyzed program elements indexed by identifiers, such as variable states or function summaries.",
      "description_length": 401,
      "index": 1849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype where values are of a specified `Data` module type, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports operations such as membership testing via `mem_project`, deep copying with `copy`, and integrates with Frama-C's typing and description systems via `ty`, `descr`, and `packed_descr`. Concrete use cases include managing and manipulating collections of logic information entries tied to CIL structures, such as annotations or built-in logic definitions, within Frama-C plugins.",
      "description_length": 564,
      "index": 1850,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports creating and managing typed, user-friendly representations of hash tables within Frama-C, with capabilities for deep copying and project-aware membership checks. Concrete use cases include tracking and emitting analysis results or annotations keyed by specific data values during static analysis.",
      "description_length": 487,
      "index": 1851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling lists of file paths as command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It supports parsing and representing file paths with standard list semantics, ensuring deep copying and project membership checks. Concrete use cases include defining command-line options that accept multiple file inputs, such as source files or output directories.",
      "description_length": 437,
      "index": 1852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for `Kinstr` values in the CIL (C Intermediate Language) representation. It provides standard operations including equality, comparison, hashing, and pretty-printing, enabling efficient storage and retrieval of CIL instruction-related data. Concrete use cases include tracking and managing analysis results or metadata associated with specific instructions during static analysis.",
      "description_length": 456,
      "index": 1853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table used in tracking and comparing declaration elements during pretty printing of C source code. It supports equality, comparison, hashing, and pretty printing operations, along with deep copying and project membership checks. The key type is used to uniquely identify and manage declaration metadata within analysis plugins.",
      "description_length": 369,
      "index": 1854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checks over project skeletons, and type-level representations for structural manipulation. Concrete use cases include managing collections of analyzed data values with efficient lookups and traversals in static analysis contexts.",
      "description_length": 419,
      "index": 1855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It supports keys of type `Hashtbl.key`, enabling their use in hash tables with deep copying and membership checks over project skeletons. Concrete use cases include managing and comparing hash table keys in static analysis plugins, particularly when tracking or querying key values across different analysis states.",
      "description_length": 454,
      "index": 1856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps with strict structural equality, specifically for use with CIL types that require precise constant comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing for keys, along with deep copying and project membership checks. It is used in contexts where strict equivalence between CIL structures is necessary, such as in analysis plugins that track or compare program elements based on their exact structure.",
      "description_length": 495,
      "index": 1857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype with structural equality and strict constant comparison for values. It provides standard operations including equality checking, comparison, hashing, pretty printing, and deep copying, along with support for project-aware membership queries. It is suitable for use in analysis plugins requiring precise value tracking and comparison within the Frama-C framework.",
      "description_length": 407,
      "index": 1858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in maps with `nativeint` values, providing equality, comparison, hashing, and pretty-printing operations. It supports structured data management through type descriptors, memory project checks, and deep copying. Concrete use cases include managing unique identifiers or configuration settings in static analysis plugins where precise key handling is essential.",
      "description_length": 405,
      "index": 1859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` type, supporting standard operations like equality, comparison, hashing, and pretty printing. It provides a deep copy function, a membership check for project skeletons, and type descriptors for integration with Frama-C's infrastructure. Concrete use cases include managing sets of rational-typed values with efficient lookups and persistence across analysis phases.",
      "description_length": 449,
      "index": 1860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control how parameters are grouped and interpreted. Concrete use cases include setting up default and \"all\" categories, enabling all parameters with specific interpretations, and defining custom categories for plugin options.",
      "description_length": 483,
      "index": 1861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are expressions or structures with equality and values are of a specified data type. It supports operations like equality checking, comparison, hashing, pretty-printing, and deep copying, as well as project-aware membership checks. It is used to manage and manipulate maps of CIL expressions or structures paired with custom data in a type-safe manner.",
      "description_length": 392,
      "index": 1862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter builders, allowing the association of states and accessors with each category. Concrete use cases include configuring how groups of command-line options are enabled or disabled, setting default behaviors, and defining global option interpretations.",
      "description_length": 474,
      "index": 1863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports working with project-related data by allowing membership checks within projects and deep copying of key values. Concrete use cases include managing and tracking internal states associated with different projects in a structured and efficient manner.",
      "description_length": 411,
      "index": 1864,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking and comparing logic constant values in CIL-based analyses, ensuring deep copies and project-aware membership checks. The module works directly with `Data.t` values, structured as a hash table with associated type and descriptor metadata.",
      "description_length": 463,
      "index": 1865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-valued plugin parameters, supporting validation, alias resolution, and custom marshaling. It defines a core data type for representing string parameters, with operations for comparison, hashing, pretty printing, and deep copying, enabling structured manipulation of parameter lists. It supports global string parameters and function name references, allowing enforcement of command-line argument validity and synchronization of plugin state with runtime configurations. Use cases include managing plugin options with dynamic value hooks and verifying function references during alias resolution.",
      "description_length": 646,
      "index": 1866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string parameters for kernel functions with support for validation, alias handling, and serialization, integrating them into Frama-C's state management system. It allows plugins to define command-line options that accept either predefined function names or arbitrary strings, with strict validation for each. The child module enhances this functionality by providing core utilities for string-based data types, including equality checks, comparison, hashing, and pretty printing, enabling robust manipulation and inspection within plugins. Use cases include managing configuration settings, storing and retrieving analysis results, and ensuring consistent handling of string identifiers across project components.",
      "description_length": 733,
      "index": 1867,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing elements in a kernel function multiple map, using string-named categories and accessors. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, with support for dependency tracking and state control. Concrete use cases include organizing analysis options or plugin parameters by category, enabling bulk operations on grouped elements, and customizing behavior based on category interpretation.",
      "description_length": 506,
      "index": 1868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for edges in an interpreted automaton, supporting equality, comparison, and hashing operations. It works with edge data structures that include guards, actions, or return transitions, enabling efficient lookups and set operations. Concrete use cases include tracking control flow transitions and managing edge-specific metadata in abstract interpretation analyses.",
      "description_length": 406,
      "index": 1869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module constructs a map datatype based on a provided `Data` module, supporting standard operations like `equal`, `compare`, `hash`, and `pretty`. It works with key-value pairs where keys and values conform to the `Data` type, enabling rich data associations. Concrete use cases include managing symbol tables, tracking variable mappings in analysis plugins, or storing configuration settings with typed keys.",
      "description_length": 413,
      "index": 1870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling string-based custom specifications in the context of Frama-C's kernel. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying of values of type `t`, along with descriptors and representants for type inspection and representation. It is used to manage and manipulate string parameters passed via the `-generated-spec-custom` option during analysis.",
      "description_length": 458,
      "index": 1871,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set of operations for managing a datatype `t` representing kernel functions, including equality, comparison, hashing, and pretty-printing. It supports command-line option handling by providing structural descriptions and project membership checks. Use cases include defining and manipulating sets of kernel functions with precise semantic comparisons and persistent storage via deep copying.",
      "description_length": 413,
      "index": 1872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uses structural equality with strict constant comparison and handles expressions within `sizeof` operations by comparing their structure rather than identifiers. It supports standard map operations including equality, comparison, hashing, and pretty printing, while also providing deep copying and project membership checks. Concrete use cases include managing and comparing CIL expressions in static analysis plugins where structural equivalence is required.",
      "description_length": 504,
      "index": 1873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Zero.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered plugin datatype with operations for equality, comparison, hashing, and pretty-printing. It works with a specific type `t` and provides structural descriptions, representants, and deep copying. Concrete use cases include managing and manipulating plugin-specific data within Frama-C's analysis framework, such as storing and comparing abstract values or analysis states.",
      "description_length": 402,
      "index": 1874,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a boolean hashtbl structure, providing equality, comparison, and hashing operations required for key management. It supports concrete operations such as checking membership based on project properties and deep copying keys to avoid shared references. Use cases include managing boolean state mappings in static analysis plugins where key identity and project-specific filtering are essential.",
      "description_length": 440,
      "index": 1875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys in a hashtbl, including equality, comparison, and hashing operations. It works with the `Hashtbl.key` type, providing functions to compare, hash, and pretty-print keys, along with utilities for project membership checks and deep copying. Concrete use cases include managing and manipulating keys in custom hashtbl-based data structures within Frama-C plugins.",
      "description_length": 399,
      "index": 1876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables that manage addressable memory zones, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete data types such as `Project.t` values, and includes functions to check membership within projects, deep copy keys, and retrieve type descriptors. Use cases include tracking and managing memory base keys in static analysis plugins, ensuring unique identification and proper handling of memory zones across different analysis phases.",
      "description_length": 531,
      "index": 1877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a comparable key type for maps, including equality, comparison, and hashing operations. It works with structured data types that require unique representation and deep copying. Concrete use cases include managing symbolic values in static analysis, where keys must be compared, hashed, and displayed in a consistent manner.",
      "description_length": 343,
      "index": 1878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table-based lattice structure where each entry's value adheres to a lattice type. It provides operations for equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to represent and manipulate mappings with lattice-valued entries in a way that supports analysis within Frama-C's abstract interpretation framework.",
      "description_length": 405,
      "index": 1879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Custom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a customizable data type interface for command-line parameters, providing operations for equality, comparison, hashing, and pretty-printing. It works with a custom `Datatype.t` and supports deep copying, membership testing within projects, and descriptor management. It is used to integrate custom parameter types into Frama-C's command-line handling with precise type representation and user feedback.",
      "description_length": 422,
      "index": 1880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module configures string-based command-line parameters with validation, value change notifications, and alias handling, particularly for parameters requiring constraints like predefined value sets or valid C identifier syntax. It supports data types for general string parameters and includes a dedicated submodule for file path handling, offering operations such as comparison, hashing, pretty-printing, and project membership checks. Users can define options that validate input against allowed values or enforce syntactic correctness for use in C code analysis. The combined interface enables managing both generic string parameters and specialized path values within the same command-line workflow.",
      "description_length": 707,
      "index": 1881,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, ensuring type-specific operations. It supports standard hash table functionalities like equality, comparison, hashing, and pretty printing, tailored to CIL model information. Use it to manage collections of CIL-based data with efficient lookups and type-safe manipulations in Frama-C plugins.",
      "description_length": 383,
      "index": 1882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are based on the structural equality of CIL predicates, using the provided `Data` module for value operations. It supports standard hash table operations like equality, comparison, hashing, and pretty-printing, while ensuring deep copying and project membership checks. It is used to manage and manipulate collections of CIL predicate-based data with efficient lookups and structural consistency.",
      "description_length": 449,
      "index": 1883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a string-based hash table, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports concrete use cases like storing and retrieving values indexed by string keys in a hash table, ensuring deep copying and project-aware membership checks. The type `t` represents these keys, with functions tailored for integration into Frama-C's plugin architecture.",
      "description_length": 442,
      "index": 1884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype where keys and values are parameterized by the `Data` module. It provides standard operations including equality, comparison, hashing, pretty-printing, and deep copying, all tailored to the specific key-value pairs stored in the map. Concrete use cases include managing structured value mappings in static analysis plugins, such as tracking variable bindings or analysis results across different program points.",
      "description_length": 449,
      "index": 1885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for a given data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with values of type `Data.t` and provides a deep copy function, a list of representatives, and a way to check membership based on project properties. Concrete use cases include managing machine-dependent data with unique type representations and structured comparisons.",
      "description_length": 439,
      "index": 1886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values that include project-specific data. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and membership checking for project-related values. It is suitable for tracking and managing keys in a hashtable where each key may contain embedded project identifiers that need to be inspected or duplicated independently.",
      "description_length": 459,
      "index": 1887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data manipulation and project-aware membership checks, suitable for analysis plugins requiring persistent or versioned data mappings. Use cases include tracking annotated CIL code elements across different analysis phases or project configurations.",
      "description_length": 445,
      "index": 1888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a hash table, specifically for use with the `Kf.Hashtbl` structure. It provides equality, comparison, hashing, and pretty-printing functions for key values, along with deep copying and membership checks over project skeletons. These operations support efficient key-based lookups and manipulations in hash tables used within static analysis plugins.",
      "description_length": 401,
      "index": 1889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for managing function declarations (`Fundec`) within Frama-C's plugin system, including equality, comparison, hashing, and pretty-printing. It works with `Fundec.t` values, which represent C functions in the abstract syntax tree. Concrete use cases include tracking analyzed functions, comparing or storing function metadata across different analysis passes, and ensuring deep copies for safe manipulation in different project contexts.",
      "description_length": 479,
      "index": 1890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in a hash table for logic variables, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports data types related to CIL logic variables, including their descriptors, representations, and project membership checks. Concrete use cases include managing and manipulating logic variable keys in static analysis plugins, such as tracking variable identities and ensuring correct hash-based lookups.",
      "description_length": 475,
      "index": 1891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing service graph nodes. It supports concrete use cases such as checking membership of project elements within a node and performing deep copies of nodes. The data type is designed for use in analysis tools that require precise manipulation and inspection of service graphs derived from callgraphs.",
      "description_length": 386,
      "index": 1892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by `Kinstr.t` keys, where the associated values are of the type provided by the `Data` parameter. It supports standard map operations including lookup, insertion, iteration, and comparison, along with serialization, pretty-printing, and project-aware membership checks. It is used to manage heterogeneous data tied to specific CIL kernel instructions, such as analysis results or transformation metadata.",
      "description_length": 438,
      "index": 1893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table that stores logic constructor information. It provides equality, comparison, hashing, and pretty-printing functions for these keys, which are essential for managing and accessing hash table entries efficiently. The module also includes functions for checking membership based on project properties and creating deep copies of key values.",
      "description_length": 398,
      "index": 1894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps used in model information handling, providing standard operations like equality, comparison, hashing, and pretty printing. It works with structured data types involving projects and model keys, ensuring deep copies and project membership checks. Concrete use cases include managing and comparing keys in maps that track model-specific data during static analysis.",
      "description_length": 403,
      "index": 1895,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued plugin parameters with support for multiple values, validation, and change hooks, organizing them in a map structure that allows constrained values and custom marshaling. It defines operations for handling string data across plugin configurations and command-line arguments, including equality checks, comparison, hashing, and pretty printing. The child module enhances this functionality by supporting multi-value collections with deep copies, project-based membership checks, and structured representations. Together, they enable managing complex string-based configurations with enforced constraints and customizable data handling in Frama-C plugins.",
      "description_length": 687,
      "index": 1896,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are kernel functions and values are of the type specified by the `Data` parameter. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, as well as project-aware membership checks. It is used to associate structured data with specific kernel functions in a type-safe and efficient manner.",
      "description_length": 386,
      "index": 1897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a typed hash table for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It integrates with Frama-C's typing and description system, enabling the hash table to be used as a first-class data type with project-aware membership checks and deep copying. Concrete use cases include managing collections of analyzed AST elements with efficient lookups and project-specific filtering.",
      "description_length": 467,
      "index": 1898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure indexed by integers where values are of a specified data type, supporting operations like equality checks, comparison, hashing, and pretty printing. It is used to manage and manipulate integer-indexed data in abstract interpretation contexts, such as tracking variable values across program states. Concrete use cases include representing and reasoning about integer-mapped abstract values in static analysis plugins.",
      "description_length": 453,
      "index": 1899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and validating string-based command-line parameters with dynamic constraints, function name resolution, and state transition hooks. It includes a data type for handling string parameters with support for equality, comparison, hashing, pretty-printing, and deep copying, particularly in the context of Frama-C's parameter system. Users can enforce valid kernel function names, restrict values to specific patterns, and synchronize string parameters with project state. Example uses include parsing file paths, configuration strings, and identifiers in Frama-C plugins while ensuring consistency across project skeletons.",
      "description_length": 664,
      "index": 1900,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic labels and values are of the type provided by the `Data` parameter. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing for use in data structures like hash tables. It is suitable for tracking logic label\u2013value associations in static analysis plugins, such as mapping labels to expressions or analysis results.",
      "description_length": 431,
      "index": 1901,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in integer maps, providing equality, comparison, and hashing operations. It supports structured values that may contain project-specific data, enabling precise representation and manipulation of map keys. Concrete use cases include managing and comparing keys in persistent data structures and project-aware map implementations.",
      "description_length": 373,
      "index": 1902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a 32-bit integer hashtable, providing equality, comparison, hashing, and pretty-printing operations tailored for key values. It supports operations like `equal`, `compare`, `hash`, and `pretty`, which ensure proper handling of key values within hashtables and user-facing displays. Concrete use cases include managing and comparing keys in a type-safe hashtbl structure, ensuring deep copying and project membership checks for analysis plugins.",
      "description_length": 492,
      "index": 1903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given `Data` module, providing standard operations like `equal`, `compare`, `hash`, and `pretty` for values stored in the table. It supports concrete data structures such as integer-indexed collections and enables deep copying, project membership checks, and type-safe comparisons. Use cases include managing typed, persistent mappings in static analysis plugins where value integrity and precise equality are critical.",
      "description_length": 479,
      "index": 1904,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command line options for handling sets of strings with filled values. It provides operations for equality, comparison, hashing, and pretty-printing string sets, along with deep copying and project membership checks. Suitable for configuring analysis parameters that involve string set values.",
      "description_length": 303,
      "index": 1905,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for a given data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with values of a specified type `Data.t` and provides a structured way to manage and manipulate these values within a hash table context. Concrete use cases include efficiently storing and retrieving CIL function definitions with associated data, enabling analysis plugins to track and process function-specific information during static analysis.",
      "description_length": 512,
      "index": 1906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and operations for a lattice-equipped map, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.Key.t` type, which represents keys in the map, and provides utilities for checking membership in projects, deep copying keys, and describing their type and structure. Concrete use cases include managing and manipulating keys in a lattice-structured map, ensuring correct value comparisons and efficient storage.",
      "description_length": 482,
      "index": 1907,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for string sets in Frama-C plugins, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control parameter behavior based on dependencies and accessors. Concrete use cases include setting up plugin command-line options with specific category semantics and managing default or global parameter behaviors.",
      "description_length": 447,
      "index": 1908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype for a given value type, enabling operations like insertion, lookup, and iteration with strong typing guarantees. It works with any data type that provides defined equality, comparison, and hashing functions. Concrete use cases include managing collections of program elements such as variables, functions, or annotations in static analysis plugins.",
      "description_length": 390,
      "index": 1909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for edge values in an interpreted automaton, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that conform to the `Data` module parameter, enabling efficient storage and retrieval of edge-related information. Concrete use cases include tracking transitions with associated guards and actions in abstract interpretation workflows.",
      "description_length": 438,
      "index": 1910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line string parameters with support for value assignment, retrieval, change tracking, and validation against predefined acceptable strings or function identifiers. It provides core operations for handling string and string list values, including defaulting, alias resolution, and customizable serialization, enabling precise control over option state and project-specific configurations. Its child module enhances string list handling with equality, comparison, and pretty-printing, supporting deep copies and membership checks for representable values. Examples include parsing file paths, managing symbol lists in plugins, and defining validated command-line options with state-aware defaults.",
      "description_length": 723,
      "index": 1911,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in integer maps, providing operations for equality, comparison, hashing, and pretty-printing. It supports working directly with key values through functions like `equal`, `compare`, `hash`, and `pretty`, as well as introspection via `reprs` and type metadata through `ty`, `name`, and `descr`. Concrete use cases include managing and comparing symbolic integer keys in abstract interpretation lattices, and inspecting or serializing key structures during analysis or debugging.",
      "description_length": 523,
      "index": 1912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and operations for a map lattice that combines maps and sets with lattice structures. It provides equality, comparison, hashing, and pretty-printing functions for key values, along with utilities for deep copying and checking project membership. Concrete use cases include managing symbolic keys in static analysis contexts and ensuring structural consistency in lattice-based dataflow computations.",
      "description_length": 432,
      "index": 1913,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports concrete use cases like tracking and comparing structured CIL data within Frama-C plugins, particularly when managing and querying analysis results tied to specific project contexts. The module also includes functionality for deep copying and checking membership based on project-specific predicates.",
      "description_length": 494,
      "index": 1914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores CIL field information, providing standard operations including equality, comparison, hashing, and pretty printing. It supports data types related to CIL's `Fieldinfo` structures, enabling efficient lookups and manipulations of field data within a project. Concrete use cases include managing and querying CIL field metadata during static analysis, such as tracking field offsets or types in composite data structures.",
      "description_length": 479,
      "index": 1915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure where keys are bases and values are memory slices, providing operations for equality, comparison, hashing, and pretty-printing. It supports data types defined by the `Data` parameter, which must conform to the `Lmap_sig` interface, and is used to represent abstract memory models in value analysis. Concrete use cases include tracking memory states during static analysis and managing memory slices in Frama-C's value plugin.",
      "description_length": 464,
      "index": 1916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered maps for polymorphic data indexed by versioned control flow keys, enabling efficient insertion, deletion, and ordered traversal. It specializes in handling versioned keys derived from unrolled unnatural loop structures, supporting precise tracking of state transitions and guarded actions during abstract interpretation. The first child module defines key operations for control points in modified control flow graphs, including comparison, hashing, and project membership checks, while the second implements a version-keyed map with parameterized values, offering standard operations alongside serialization and project-aware queries. Together, they enable aggregating reachable states, merging path-sensitive data, and analyzing control flow modifications across program versions.",
      "description_length": 810,
      "index": 1917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL predicates, including their type, name, and descriptor. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with deep copying and checking for the presence of a valid project within a key. These keys are used to manage and track predicate-specific data across different analysis phases in Frama-C plugins.",
      "description_length": 418,
      "index": 1918,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are CIL types compared by name without unrolling, and values are of a specified `Data` module type. It provides standard operations including equality, comparison, hashing, pretty printing, deep copying, and project-aware membership checks. Concrete use cases include managing type-indexed data in static analysis plugins, such as tracking type-specific annotations or analysis results across different translation units.",
      "description_length": 477,
      "index": 1919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are integers and values are of the provided `Data` module's type. It supports standard map operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage collections of data indexed by integers, such as tracking variable states across program points in static analysis.",
      "description_length": 402,
      "index": 1920,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a hash table that stores memory map entries associated with bases and offset information. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, which are essential for managing and querying memory state in static analysis. The module supports deep copying and project membership checks, enabling precise manipulation of memory representations during analysis phases.",
      "description_length": 451,
      "index": 1921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure where keys are hash-consed trees and values are of a specified type, supporting efficient insertion, lookup, and traversal. It provides operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities to inspect values based on project membership. It is suitable for scenarios requiring precise map manipulation in static analysis tasks, such as tracking value flow or state in abstract interpretation.",
      "description_length": 489,
      "index": 1922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table type specialized for values of a given data type, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete data types through a deep copy function and integrates with Frama-C's type and descriptor system for runtime inspection and project-specific membership checks. Use cases include managing and comparing structured data representations in static analysis plugins.",
      "description_length": 454,
      "index": 1923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, providing operations such as equality, comparison, hashing, and pretty printing. It works with logic types that do not require unrolling, along with project-based filtering and deep copying. Concrete use cases include managing and comparing symbolic logic expressions in static analysis plugins.",
      "description_length": 349,
      "index": 1924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing keys used in integer maps, including equality, comparison, hashing, and pretty-printing. It supports data types related to `Frama_c_kernel.Datatype.Integer.Map.key`, providing functionalities such as deep copying, membership testing based on project properties, and representation of key values. Concrete use cases include tracking and manipulating keys in persistent data structures, ensuring correct behavior during map operations and analysis tasks involving integer keys.",
      "description_length": 533,
      "index": 1925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered, immutable set structure for managing collections of CIL variable information (`Varinfo`) with efficient operations like insertion, deletion, union, and range-based traversal. It supports advanced queries for nearest elements, ordered iteration, and transformation via mapping or filtering, leveraging structural and type-based comparisons. It is particularly useful in static analysis tasks for tracking variable usage, dependencies, or scoping relationships in C code.",
      "description_length": 504,
      "index": 1926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by memory locations associated with byte offsets, where each map value adheres to the provided `Data` module's type. It supports standard map operations including lookup, insertion, iteration, and comparison, along with serialization, pretty printing, and deep copying. It is used to track and manipulate memory state information at byte-level precision, such as in static analysis of low-level memory operations or program verification tasks.",
      "description_length": 478,
      "index": 1927,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and retrieving logic type values with efficient lookups, and checking membership based on project skeletons. The module also enables deep copying and structured comparisons for precise data manipulation in static analysis plugins.",
      "description_length": 455,
      "index": 1928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line parameters in Frama-C's kernel, specifically for the `-load-library` option. It provides operations for equality checks, comparison, hashing, and pretty-printing instances of this type, ensuring deep copies and supporting project-specific membership checks. It is used to manage and manipulate library loading specifications during analysis configuration.",
      "description_length": 426,
      "index": 1929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling collections of files as string parameters in Frama-C's kernel. It provides operations for equality checking, comparison, hashing, and pretty printing, as well as deep copying and project membership testing. It is used to manage file lists passed via command-line arguments in a structured and type-safe way.",
      "description_length": 352,
      "index": 1930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with CIL locations, including equality, comparison, hashing, and pretty-printing. It supports data types that represent keys with embedded project information, enabling checks on project membership and deep copying. Concrete use cases include managing and comparing keys in maps that track CIL location metadata across different projects.",
      "description_length": 391,
      "index": 1931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table, specifically tailored for integer values within the Frama-C kernel. It provides operations for equality checking, comparison, hashing, and pretty-printing keys, along with functions to inspect and manipulate key representations. Use cases include managing integer-based identifiers in analysis plugins, such as tracking memory locations or symbolic values during static analysis.",
      "description_length": 442,
      "index": 1932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate global annotations with unique identifiers, providing standard operations like equality, comparison, hashing, and pretty-printing. It works with global annotation keys tied to CIL (C Intermediate Language) constructs, enabling precise tracking and manipulation of annotations across C code analyses. Concrete use cases include managing per-function or per-global-variable metadata in static analysis plugins, such as storing and retrieving specification or verification results.",
      "description_length": 533,
      "index": 1933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by properties ordered by a custom function, where values are of a specified `Data` module type. It provides standard map operations including comparison, equality, hashing, pretty-printing, and deep copying, along with project-aware membership checks. Concrete use cases include managing property-indexed data in static analysis plugins, such as associating proof obligations or annotations with specific code locations.",
      "description_length": 455,
      "index": 1934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that identifies syntactic scopes in CIL, such as functions or blocks. It provides standard operations like equality, comparison, hashing, and pretty printing for these keys. It is used to manage and manipulate scope-specific data during static analysis, such as tracking variable bindings or analysis results per scope.",
      "description_length": 354,
      "index": 1935,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic constructor information and values are of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate structured logic data in CIL-based analyses.",
      "description_length": 354,
      "index": 1936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for list-typed parameters, providing operations to define, parse, and manipulate list values. It works with `Datatype.t` values, supporting equality, comparison, hashing, and pretty-printing. Concrete use cases include defining options that accept multiple values, such as file paths or analysis targets, and validating or transforming list inputs during command-line parsing.",
      "description_length": 428,
      "index": 1937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control parameter behavior across plugin features. Concrete use cases include setting up configurable analysis options, enabling/disabling groups of parameters, and defining default or global behaviors for plugin extensions.",
      "description_length": 483,
      "index": 1938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integers and values are of the `Data` module's type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions. It is used to manage integer-indexed collections of `Data` values in a way that supports deep copying, pretty printing, and project-aware membership checks.",
      "description_length": 387,
      "index": 1939,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are rational numbers and values are of the type provided by the `Data` module. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage and manipulate maps of rational-number-indexed data in static analysis plugins for Frama-C.",
      "description_length": 378,
      "index": 1940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure, specifically working with `Frama_c_kernel.Datatype.Rational.Map.key` values. It includes standard comparison, equality, hashing, and pretty-printing functions, along with utilities for deep copying and checking membership based on project projections. It is used to manage and manipulate key values within map implementations that require stable and consistent key handling.",
      "description_length": 455,
      "index": 1941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, supporting operations like equality, comparison, hashing, and pretty printing. It provides a deep copy function, project membership checks, and type descriptors for structural introspection. Concrete use cases include managing and comparing sets of localized AST elements during static analysis, such as tracking variable annotations or source code transformations.",
      "description_length": 452,
      "index": 1942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with `Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl.t` structures, ensuring deep copies and project-aware membership checks. Concrete use cases include managing sets of logic real numbers in a hash table with efficient lookups and serialization.",
      "description_length": 444,
      "index": 1943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by file paths with operations for equality, comparison, hashing, and pretty printing. It supports persistent storage and project-specific filtering through `mem_project`. Typical use includes tracking file-specific analysis data across Frama-C plugins.",
      "description_length": 287,
      "index": 1944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate values with declaration elements in the AST, supporting operations like equality, comparison, hashing, and pretty printing. It works with structured data types that include project-specific information, enabling precise tracking and manipulation of declarations during source code pretty printing. Concrete use cases include managing and querying declaration metadata in maps, ensuring correct handling of project-specific contexts during analysis or transformation passes.",
      "description_length": 528,
      "index": 1945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are booleans and values are of the provided `Data` module's type. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions. It is used to manage boolean-indexed data in static analysis plugins, such as tracking binary properties across program states.",
      "description_length": 367,
      "index": 1946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table structure specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty printing. It works with data types that include memory locations and bit-level offsets, supporting precise manipulation and querying of stored values. Concrete use cases include tracking and comparing memory state snapshots during static analysis, such as checking if a specific memory project is present or generating unique representations of memory layouts.",
      "description_length": 524,
      "index": 1947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` for keys in a map that associates memory locations with byte-level offsets. It provides operations for equality testing, comparison, hashing, and pretty-printing keys, as well as deep copying and checking project membership. The module is used to manage and manipulate keys in maps that track memory base-offset associations, particularly in static analysis plugins for Frama-C.",
      "description_length": 414,
      "index": 1948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages versioned control flow graph keys and associated automata states using hash tables, supporting efficient dynamic updates, lookups, and ordered traversal during abstract interpretation. It provides core operations for handling versioned state transitions, including memoization, bulk updates, and ordered edge processing, with keys designed for unique identifiers in unrolled unnatural loops, supporting equality, comparison, hashing, and pretty-printing. The specialized hash table stores versioned data conforming to a given `Data` module type, enabling deep copying, project membership testing, and stable key identity across analysis iterations. Together, these components facilitate precise state tracking and transformation in operational semantics with complex control flow structures.",
      "description_length": 811,
      "index": 1949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are structurally equivalent expressions. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate expression-based keys in map structures during CIL analysis.",
      "description_length": 352,
      "index": 1950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are offsets and values are of a specified data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It is used to manage and manipulate mappings involving CIL offsets, such as tracking field positions in structs or unions. Concrete use cases include analyzing or transforming C code structures with precise offset-based data associations.",
      "description_length": 419,
      "index": 1951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys and values are of a specified type, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete data types through a parameterized module interface, enabling use cases like tracking analyzed program states or caching computed values during static analysis. Key functionality includes deep copying, membership testing with project functions, and structured representation of hash table contents.",
      "description_length": 488,
      "index": 1952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps used in pretty-printing source code with location-aware AST elements. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. The keys are used to manage and query structured data during the pretty-printing process, particularly in relation to source code locations and project-specific information.",
      "description_length": 442,
      "index": 1953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype with fully functional equality, comparison, and hashing operations, based on the provided value datatype. It supports structured printing, deep copying, and project-aware membership checks for analysis within Frama-C plugins. Concrete use cases include managing and comparing maps of abstract values, identifiers, or analysis states in static analysis plugins.",
      "description_length": 395,
      "index": 1954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys based on CIL lvalues under strict structural equality, where values are of the provided `Data` module type. It supports standard map operations including lookup, insertion, and traversal, along with equality, comparison, and hashing tailored to strict structural identity of keys. It is suitable for analyses requiring precise tracking of CIL lvalue-based keys with strict constant comparison semantics, such as value analysis or dependency tracking in C programs.",
      "description_length": 518,
      "index": 1955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are compared using structural equality with strict constant comparison. It provides standard operations such as `equal`, `compare`, `hash`, and `pretty` for key manipulation and inspection, along with `copy` for deep copying and `mem_project` to check properties on embedded project values. The keys are used in contexts requiring precise structural identity, such as analysis state management or value tracking in CIL-based plugins.",
      "description_length": 484,
      "index": 1956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based plugin parameters with support for validation, value change hooks, and serialization, enabling dynamic resolution of identifiers such as function names or configuration keys. It defines core operations for creating, comparing, and transforming string values, along with utilities for handling aliases and synchronizing state across analysis contexts. The child module enhances this functionality by providing standard data operations like equality, hashing, and pretty-printing for string identifiers, while supporting list-based representants and project membership checks. Together, they allow plugins to manage complex string-based configurations and identifiers with strong consistency and adaptability during static analysis.",
      "description_length": 763,
      "index": 1957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in a hash table for term l-values, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working directly with term l-value keys through functions like `equal`, `compare`, and `hash`, which are essential for hash table manipulation. Concrete use cases include managing and querying term l-value mappings in static analysis plugins, such as tracking memory locations or symbolic expressions during program verification.",
      "description_length": 506,
      "index": 1958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table structure specialized for values of type `Data.t`, indexed by memory zones. It supports standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate collections of data associated with memory locations in static analysis plugins.",
      "description_length": 381,
      "index": 1959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of a given `Data` module type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership testing, and project-based filtering. Concrete use cases include tracking and manipulating collections of CIL enumeration items with efficient lookups and type-safe operations.",
      "description_length": 422,
      "index": 1960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a map structure, specifically handling equality, comparison, hashing, and pretty-printing operations on those keys. It supports data types that can be stored in a map, including the ability to check membership based on project criteria and perform deep copies of key values. Concrete use cases include managing and querying key-value pairs in a map where keys may contain project-specific data and require custom comparison or traversal logic.",
      "description_length": 491,
      "index": 1961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation specialized for values of a given data type, supporting operations like equality checking, comparison, hashing, and pretty printing. It works with any data type provided through the `Data` parameter, ensuring each value's structural properties are respected. Concrete use cases include managing collections of CIL-based values with structural equality, such as tracking expressions or statements in static analysis plugins.",
      "description_length": 471,
      "index": 1962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling keys used in attribute maps, including equality checks, comparison, hashing, and pretty-printing. It works with the `key` type, which represents keys in a map structure. Concrete use cases include managing and comparing keys during attribute map manipulations, ensuring deep copies to avoid shared references, and checking project membership within keys.",
      "description_length": 398,
      "index": 1963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a map key type for working with `Identified_term` values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports map manipulations by ensuring keys are uniquely identifiable and can be efficiently compared or serialized. Use cases include managing term identifiers in CIL-based analyses where key uniqueness and ordering are essential.",
      "description_length": 399,
      "index": 1964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between vertex sets and arbitrary values, enabling efficient insertion, lookup, and iteration over keys or entries. It supports operations on `Vertex_Set.t` keys, which represent control points in unrolled control flow graphs, and is used for caching computed states or tracking transitions during abstract interpretation. The first child module specializes in hash tables for vertex sets from interpreted automata, providing equality, comparison, and deep copying for efficient set manipulation. The second child module defines a key type for unrolled control flow graph vertices, supporting state transitions and reachability analysis with standard operations like hashing and pretty printing.",
      "description_length": 724,
      "index": 1965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based configuration parameters with validation, semantic interpretation, and global state handling, supporting multivalued mappings and customizable persistence. It defines operations for equality, comparison, hashing, and pretty printing, while enabling command-line integration and domain-specific constraints such as valid function names. Submodules provide utilities for deep copying, project membership checks, and type descriptions, facilitating seamless interaction with Frama-C's plugin system. Example uses include enforcing valid string options, maintaining persistent plugin state, and customizing string serialization for analysis sessions.",
      "description_length": 679,
      "index": 1966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters in a map structure where each category is uniquely identified and configured. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, using accessors and dependency lists. Concrete use cases include organizing and controlling groups of related command-line options in static analysis tools built on the Frama-C framework.",
      "description_length": 433,
      "index": 1967,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for vertex data in an interpreted automaton, where keys are vertices and values are determined by the parameter module `Data`. It provides standard operations like lookup, insertion, and equality checks, along with serialization, comparison, and pretty-printing capabilities. It is used to associate vertex-specific metadata, such as analysis results, with control flow graph nodes in abstract interpretation plugins.",
      "description_length": 465,
      "index": 1968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are characters and values are of the provided `Data` module's type. It supports standard map operations like lookup, insertion, and iteration, along with type-specific functionality such as comparison, hashing, and pretty printing. It is used when building character-indexed collections that require deep copying, equality checks, or integration with Frama-C's typing and description system.",
      "description_length": 431,
      "index": 1969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in global map structures, including equality, comparison, hashing, and pretty-printing functions. It works with the `t` type representing global map keys, which encapsulate project-specific data. Use cases include managing and manipulating keys for global maps in static analysis plugins, ensuring correct key behavior during map operations and project transformations.",
      "description_length": 414,
      "index": 1970,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that use `OffsetStructEq`-equivalent keys, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured keys containing project-specific data, enabling efficient key-based lookups and ensuring deep copying and project membership checks. Concrete use cases include managing CIL-based analyses where structural equivalence and project-scoped data are critical.",
      "description_length": 447,
      "index": 1971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based representations of kernel functions, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with strings and structured descriptors to manage how these representations are stored and manipulated within the kernel. Concrete use cases include tracking function identifiers, comparing and copying string-based function data, and formatting values for user output or debugging.",
      "description_length": 471,
      "index": 1972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for abstract interpretation, where keys are integers and values are of a given abstract domain type. It provides operations for creating, copying, and querying the hash table, as well as supporting equality checks, comparison, hashing, and pretty-printing. Concrete use cases include tracking abstract values during static analysis, such as mapping variable identifiers to their abstract properties in a lattice-based analysis.",
      "description_length": 490,
      "index": 1973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map structure that uses hash-consed trees as keys, with support for compositional boolean attributes. It provides equality, comparison, hashing, and pretty-printing functions for keys, along with deep copying and project membership checks. It is used to manage keys in a Patricia tree-based map where each node carries boolean information, enabling efficient lookups and manipulations of structured data with precise key identity and traversal controls.",
      "description_length": 518,
      "index": 1974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a map structure, including equality, comparison, hashing, and pretty-printing functions. It works with the `Int64.Map.key` type, supporting efficient key-based lookups and manipulations. Concrete use cases include managing unique identifiers or numeric keys in map-like data structures for analysis plugins.",
      "description_length": 355,
      "index": 1975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing string set command-line options. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, and control their behavior and dependencies. Use cases include structuring related options under named categories and controlling global option behavior through the `@all` category.",
      "description_length": 380,
      "index": 1976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in logic variable maps, including equality, comparison, hashing, and pretty-printing. It supports data types representing logic variables with functionalities for deep copying, membership testing with project functions, and type descriptors for integration with Frama-C's internal systems. Concrete use cases include managing and manipulating logic variable keys during static analysis tasks, such as tracking variable properties across different analysis phases.",
      "description_length": 508,
      "index": 1977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports project-aware value management with deep copying and membership checks over project skeletons. Use it to maintain stateful mappings tied to Frama-C's internal projects, such as tracking analysis results per AST node across multiple projects.",
      "description_length": 419,
      "index": 1978,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are of type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty printing, as well as deep copying and project membership checks. It is used to manage collections of values with efficient lookup and structural comparison.",
      "description_length": 315,
      "index": 1979,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are `Enumitem` values and values are of type `Data.t`. It provides standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate mappings involving CIL enumeration items in a type-safe and structured way.",
      "description_length": 362,
      "index": 1980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and includes functions to add new categories, set default behavior, and control the `@all` category's interpretation. Concrete use cases include organizing related command-line options into logical groups and controlling their activation and dependencies within Frama-C's plugin system.",
      "description_length": 529,
      "index": 1981,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Verbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured values that may contain embedded project data, enabling checks on project membership and deep copying. Concrete use cases include managing and persisting plugin-specific data structures with type-safe representations and comparisons.",
      "description_length": 371,
      "index": 1982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing operations such as equality checking, comparison, hashing, and pretty printing. It supports data types related to map keys, including their representation, descriptors, and project membership checks. Concrete use cases include managing and manipulating map keys in static analysis plugins, particularly when deep copies, comparisons, or project-specific queries are required.",
      "description_length": 449,
      "index": 1983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given type `Data`, indexed by file positions. It supports standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to associate CIL analysis data with specific source code locations in a way that supports precise tracking and comparison.",
      "description_length": 399,
      "index": 1984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for command-line option groups, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with category types tied to parameter collections, allowing configuration of default and special categories like `@none`, `@default`, and `@all`. Concrete use cases include organizing related command-line options under named categories and controlling their activation behavior in the presence of flags like `-@all`.",
      "description_length": 505,
      "index": 1985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type where keys are hash-consed trees and values are of a specified data type, leveraging Patricia trees for efficient lookups. It provides standard hash table operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include managing mappings from abstract syntax trees to analysis results or annotations in static analysis plugins.",
      "description_length": 450,
      "index": 1986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in a map structure, including operations for equality, comparison, hashing, and pretty-printing. It supports working with a specific abstract data type `t` that represents keys, which can include project-specific information. Use cases include managing and querying keys in a map where each key may be associated with project data, ensuring deep copies and proper comparison semantics.",
      "description_length": 423,
      "index": 1987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing operations such as equality, comparison, hashing, and pretty printing. It supports key values that may contain project-specific data, enabling checks on embedded projects and deep copying to avoid shared state. Concrete use cases include managing and comparing map keys in static analysis plugins where project-sensitive data must be tracked and manipulated.",
      "description_length": 432,
      "index": 1988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking and comparing logic labels within CIL-based analyses, where each label's identity and properties must be uniquely represented and efficiently queried. The module ensures deep copying and project-aware membership checks, enabling robust manipulation of logic labels in static analysis plugins.",
      "description_length": 518,
      "index": 1989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys used in map structures, providing operations such as equality, comparison, hashing, and pretty printing for these keys. It supports data types involving CIL type information, including handling of project-specific data through deep copying and membership checks. Concrete use cases include managing and manipulating keyed collections of type information in static analysis plugins.",
      "description_length": 406,
      "index": 1990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table implementation for a given data type, enabling efficient storage and retrieval of values with standard operations. It supports hash tables where keys and values are of the provided `Data` module's type, ensuring proper equality, comparison, and hashing. Concrete use cases include managing state entries during static analysis where fast lookups and unique representation are required.",
      "description_length": 418,
      "index": 1991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP.V",
      "library": "frama-c.kernel",
      "description": "This module defines a vertex type for a service graph, where vertices are labeled and support comparison, hashing, and equality checks. It works with callgraph data to represent nodes as labeled entities, enabling precise tracking and manipulation of service dependencies. Concrete use cases include analyzing function call relationships and computing service reachability in static code analysis.",
      "description_length": 397,
      "index": 1992,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype based on a provided value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type that defines `equal` and `hash` functions, encapsulating them into a hash table structure. Concrete use cases include managing collections of analyzed program elements where fast lookup and value-based comparison are required.",
      "description_length": 416,
      "index": 1993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps associating vertices of an interpreted automaton with values. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate vertex-based key-value associations within abstract interpretation workflows, particularly when tracking control flow state transitions.",
      "description_length": 452,
      "index": 1994,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, using CIL type semantics for equality and hashing. It supports operations like equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing via `mem_project`. Concrete use cases include managing collections of CIL types with structural identity, such as tracking type definitions or analyzing type-based properties across a program.",
      "description_length": 478,
      "index": 1995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports maps with keys based on CIL attributes and values conforming to the `Data` signature, enabling precise handling of CIL-level metadata in analyses. Concrete use cases include tracking function attributes across different analysis contexts or aggregating CIL element annotations during static analysis.",
      "description_length": 483,
      "index": 1996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership checks over project skeletons, and type-safe value representation. Concrete use cases include tracking type-specific metadata across CIL analyses and maintaining structured value mappings in plugin development.",
      "description_length": 450,
      "index": 1997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for mapping kernel functions with support for equality, comparison, hashing, and pretty-printing operations. It works with function declarations and prototypes, enabling command-line options to reference and manipulate these entities directly. Concrete use cases include tracking function-specific parameters and customizing analysis settings for individual functions during static analysis.",
      "description_length": 425,
      "index": 1998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a native integer hashtable, providing equality, comparison, and hashing operations required for hashtable functionality. It supports operations like `equal`, `compare`, `hash`, and `pretty` for value manipulation and inspection, specifically tailored for native integer keys. Use cases include managing unique identifiers or mappings involving native integers in static analysis plugins.",
      "description_length": 435,
      "index": 1999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify kernel instructions (kinstr) within the CIL-based intermediate representation. It provides standard operations for equality, comparison, hashing, and pretty-printing keys, ensuring consistent handling of kinstr values across analyses. It is used to manage and query distinct instruction contexts in static analysis plugins, such as tracking or transforming specific code locations.",
      "description_length": 444,
      "index": 2000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete data types used in CIL analysis, such as expressions, statements, or variables, by leveraging the `Term_lhost.Hashtbl` structure. Use cases include managing and querying collections of CIL terms with efficient lookups and maintaining project-specific data across analysis phases.",
      "description_length": 478,
      "index": 2001,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure where keys are based on memory zone bases and values are of a specified type. It supports operations like equality checking, comparison, hashing, pretty-printing, and deep copying, tailored for use in static analysis contexts. Concrete use cases include tracking and manipulating memory zone properties in Frama-C's analysis plugins.",
      "description_length": 372,
      "index": 2002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Bool.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command-line boolean options with support for parsing, comparison, and pretty-printing. Works with `Datatype.t` values representing boolean states, providing equality checks, hashing, and project membership queries. Used to define and manage boolean configuration flags in Frama-C plugins.",
      "description_length": 300,
      "index": 2003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent CIL enumeration information. It provides operations for equality checking, comparison, hashing, and pretty-printing these keys, along with deep copying and project membership testing. The keys are used to uniquely identify and manipulate enum-related data in the context of CIL-based analyses.",
      "description_length": 350,
      "index": 2004,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on the `Data` module's type and values are tied to CIL-related data structures. It provides standard map operations like comparison, equality, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to manage and manipulate mappings involving CIL entities such as functions or variables in Frama-C plugins.",
      "description_length": 402,
      "index": 2005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Enum.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It provides operations to check membership in projects, create deep copies, and describe the type for integration with Frama-C's option system. Concrete use cases include defining command-line options with a limited set of valid inputs, such as selecting analysis modes or output formats.",
      "description_length": 404,
      "index": 2006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with abstract category types and state lists to control plugin behavior. Concrete use cases include setting default categories, enabling all parameters under a specific interpretation, and creating custom categories with explicit dependencies.",
      "description_length": 426,
      "index": 2007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map for handling multiple instances of a registered plugin datatype, supporting operations like equality, comparison, hashing, and pretty-printing. It works with the `Datatype.t` type, which represents values associated with a plugin, along with project-aware membership checks and deep copying. Concrete use cases include managing and distinguishing multiple plugin configurations or analysis states indexed by string keys.",
      "description_length": 464,
      "index": 2008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set-like datatype with operations for equality, comparison, hashing, and pretty-printing. It works with a specific `Datatype.t` and provides concrete functionality for managing representants, checking membership based on project conditions, and performing deep copies. It is used to register and handle custom data structures within a plugin, enabling precise data manipulation and introspection during static analysis.",
      "description_length": 441,
      "index": 2009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, including operations for equality, comparison, hashing, and pretty-printing. It supports data types used in memory zone abstractions, providing deep copying and membership checks over project skeletons. Concrete use cases include managing unique identifiers for memory regions and facilitating map operations in static analysis contexts.",
      "description_length": 378,
      "index": 2010,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic constants, where keys are logic constants and values are determined by the `Data` parameter. It provides standard map operations such as `equal`, `compare`, `hash`, and `pretty`, along with project-aware membership checks via `mem_project` and deep copying through `copy`. It is used to manage and manipulate mappings involving logic constants in static analysis plugins for Frama-C.",
      "description_length": 449,
      "index": 2011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checks over project skeletons, and type-level metadata such as descriptors and type representations. Concrete use cases include managing collections of structured values with efficient lookups and persistence across analysis states.",
      "description_length": 433,
      "index": 2012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a map key type with strict structural equality for CIL lvalues, supporting operations like comparison, hashing, and pretty-printing. It works with CIL types and project skeletons, providing precise equality checks and deep copying. Concrete use cases include managing and comparing structured CIL keys in analyses requiring strict value differentiation.",
      "description_length": 373,
      "index": 2013,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on CIL lvalues, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with `Lval` values that include project-specific data, ensuring structural consistency through dedicated comparison and copy functions. Concrete use cases include managing per-lvalue state in analyses or transformations that require precise tracking of memory locations across different project contexts.",
      "description_length": 473,
      "index": 2014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables associated with emitters that generate annotations or property statuses. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. Concrete use cases include managing and tracking distinct annotation sources or property identifiers within Frama-C's analysis framework.",
      "description_length": 423,
      "index": 2015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are of type `Data.t`. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage collections of values with efficient lookup, particularly in static analysis plugins requiring persistent state tracking.",
      "description_length": 369,
      "index": 2016,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables optimized for static analysis plugins, where keys are structured CIL variable information with project-aware identity, supporting efficient insertion, lookup, and traversal while ensuring type safety and deep copying. It includes a specialized key module for variable-based identifiers with equality, hashing, and pretty-printing, and a concrete hash table implementation for mapping `Varinfo` keys to arbitrary values, enabling use cases like tracking variable properties across CIL analyses. Operations include safe value retrieval, ordered iteration, and conversion to sequences, with integration into Frama-C's project system for analysis state management. Example uses include memoizing analysis results per variable or maintaining imperative state tied to specific C program variables within a plugin.",
      "description_length": 840,
      "index": 2017,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing keys for a hash table, along with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying of keys and provides introspection capabilities through descriptors and representants. Concrete use cases include managing and comparing hash-consed keys in a map structure, and enabling project-specific filtering via `mem_project`.",
      "description_length": 407,
      "index": 2018,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map-like data structure that supports multiple bindings per key, with operations for equality, comparison, hashing, and pretty-printing. It works with arbitrary data types through a type parameter `Datatype.t`, providing deep copying and project membership checks. Concrete use cases include managing command-line options with multiple values per key and maintaining extensible, type-safe configuration settings in analysis plugins.",
      "description_length": 466,
      "index": 2019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for a map that associates memory bases with memory maps, specifically using offset-based memory representations. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used efficiently in map structures. The keys are tied to a specific memory model and support deep copying and project membership checks for analysis purposes.",
      "description_length": 427,
      "index": 2020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a service graph, where each edge has a source and destination vertex along with a label. It provides operations to create edges, retrieve their source, destination, and label, and compare edges based on their direction. The module is used to model labeled control-flow or dependency relationships between vertices in static analysis tasks such as service computation.",
      "description_length": 408,
      "index": 2021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with `Frama_c_kernel.Parameter_category.t` and `Frama_c_kernel.State.t` to control parameter behavior across plugins. Concrete use cases include setting up default and \"all\" categories, enabling parameters globally with specific interpretations, and defining how parameters interact with other plugin states.",
      "description_length": 492,
      "index": 2022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are statements from the CIL representation of C programs, and values are of a specified data type. It provides standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing functions for the map itself. It is used to associate structured data with specific points in C code, such as during static analysis or transformation passes.",
      "description_length": 420,
      "index": 2023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types and state lists to control parameter behavior, particularly handling special categories like `@none`, `@default`, and `@all`. Concrete use cases include setting up configurable parameter groups for plugins and defining how they interact with command-line flags or GUI elements.",
      "description_length": 489,
      "index": 2024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are CIL types without attributes and values are of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage type-indexed data in a way that ignores type attributes during comparison, suitable for CIL-based analyses requiring precise type handling.",
      "description_length": 431,
      "index": 2025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type used in a hash table for `Term_offset` values, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with `Term_offset` keys in a hash table context, ensuring proper value representation and structural integrity. Concrete use cases include efficient storage and retrieval of term offset information in static analysis plugins, such as tracking memory offsets during value analysis.",
      "description_length": 472,
      "index": 2026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for 32-bit integer keys, where the value type is determined by the provided `Data` module. It supports standard operations such as `find`, `add`, `remove`, and iteration, along with deep copying, equality checking, and pretty-printing of hash tables. It is used when managing mappings from 32-bit integers to structured values that require custom memory management or serialization within Frama-C plugins.",
      "description_length": 459,
      "index": 2027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are floating-point numbers and values are of a specified data type, providing standard map operations like lookup, insertion, and iteration. It supports concrete use cases such as tracking floating-point indexed metadata in static analysis plugins or associating real-number keys with abstract values in semantic analysis. The module ensures proper handling of equality, comparison, hashing, and pretty-printing for the map structure.",
      "description_length": 474,
      "index": 2028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are of a fixed type and values are of a type provided by the `Data` module. It supports standard map operations including lookup, insertion, equality, comparison, and pretty printing, along with deep copying and project membership checks. It is suitable for managing structured collections of values with associated metadata, such as tracking analysis results per function or variable in a plugin.",
      "description_length": 437,
      "index": 2029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that store logic labels from CIL, providing operations for equality, comparison, hashing, and pretty-printing. It supports data types related to CIL's logic labels and includes functions for checking project membership and creating deep copies. Use cases include managing and manipulating logic label keys in static analysis plugins, such as tracking label usage or implementing label-based analyses.",
      "description_length": 442,
      "index": 2030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are CIL expressions with structural equality, treating equivalent expressions within `sizeof` operations as equal. It provides standard map key operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate expression-based keys in a map structure, particularly in analyses involving CIL expressions with size-related equivalences.",
      "description_length": 483,
      "index": 2031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype where keys are from a specified `Data` module and values are of type `Data.t`. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage structured collections of values with efficient lookups and transformations, such as tracking variable associations in static analysis.",
      "description_length": 429,
      "index": 2032,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associating enum information with other data. It supports key comparison, equality, hashing, and pretty-printing, along with deep copying and project membership checks. These keys are specifically tied to CIL enum definitions and are used to manage and retrieve enum-related data in static analysis plugins.",
      "description_length": 360,
      "index": 2033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing machine-dependent key values, deep copying keys to avoid shared references, and checking membership based on project values within keys. The type `t` represents the key, while functions like `equal`, `compare`, and `hash` enable use in standard map and set implementations.",
      "description_length": 478,
      "index": 2034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear.Vector",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and manipulating vectors in a linear space, including creating zero vectors, repeating scalar values, and accessing or modifying vector elements. It supports vectors parameterized by a dimension type and includes functions for computing the norm, comparing vectors element-wise, and determining vector size. Concrete use cases include implementing linear algebra operations for static analysis filters and representing state vectors in abstract interpretation.",
      "description_length": 509,
      "index": 2035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table specific to project management within Frama-C. It provides operations for equality checking, comparison, hashing, and pretty-printing these keys, as well as functions for deep copying and inspecting project membership. These keys are used to manage and track internal computational states associated with different projects in Frama-C.",
      "description_length": 397,
      "index": 2036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are CIL types with structural comparison ignoring attributes, and values are of a specified type. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate collections of CIL types and associated data in a type-safe and efficient manner.",
      "description_length": 423,
      "index": 2037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered string-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing within projects, and provides type descriptors for integration with Frama-C's plugin system. Concrete use cases include representing and manipulating string identifiers or values within static analysis plugins, such as tracking variable names or string literals in C code.",
      "description_length": 444,
      "index": 2038,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-typed command-line parameters with validation, particularly for handling function names. It supports setting values, registering change hooks, defining aliases, and customizing serialization, with key operations like `get_function_name` ensuring valid function identifiers and `get_plain_string` allowing unvalidated input. A child module extends this functionality by defining a datatype for handling sets of function declarations (`Fundec.t`), supporting equality, comparison, hashing, and pretty-printing. These tools enable parsing, validating, and querying function sets from command-line or configuration inputs, integrating with project state management.",
      "description_length": 712,
      "index": 2039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic map type with multibindings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with arbitrary data types through a descriptor-based representation, enabling type-safe manipulation and introspection. Concrete use cases include managing plugin-specific state with multiple values per key and persisting typed data across analysis sessions.",
      "description_length": 409,
      "index": 2040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a hashtbl, including operations for equality, comparison, hashing, and pretty printing. It supports keys that may contain project-specific data, enabling checks and deep copies. Use cases include managing and comparing complex key values within a hashtbl, particularly when keys involve project-specific information.",
      "description_length": 358,
      "index": 2041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configuration, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with category types that represent sets of parameters, allowing plugins to group and control behavior through named categories like `@default` or `@all`. Concrete use cases include enabling or disabling sets of parameters collectively, defining fallback behaviors via the `none` category, and setting global defaults for parameter groups.",
      "description_length": 521,
      "index": 2042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure specialized for a given value type, supporting efficient insertion, lookup, and traversal operations. It works with hash-consed tree keys and values of the provided `Data` module, using Patricia trees for optimized access. Concrete use cases include managing analysis states indexed by abstract syntax tree nodes in static analysis tools.",
      "description_length": 379,
      "index": 2043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by interpreted automaton edges, where values are of a specified data type. It provides standard map operations\u2014lookup, insertion, iteration, and equality checks\u2014along with serialization, pretty printing, and project-aware membership testing. It is used to associate edge-specific data with control flow transitions in abstract interpretation analyses.",
      "description_length": 386,
      "index": 2044,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure specialized for a given `Data` module, supporting operations like equality, comparison, hashing, and pretty printing. It works with key-value pairs where values are of type `Data.t`, and provides functionality for project membership checks and deep copying. Concrete use cases include managing machine-dependent value mappings with precise control over their representation and comparison logic.",
      "description_length": 436,
      "index": 2045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a lattice-structured map combined with sets, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports deep copying and membership testing with project functions, ensuring keys can be uniquely identified and manipulated within a lattice context. Concrete use cases include managing symbolic keys in static analysis plugins where precise data flow tracking and set operations are required.",
      "description_length": 474,
      "index": 2046,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are expressions with structural equality, including strict constant comparison and structural comparison within `sizeof` expressions. It supports operations like lookup, equality check, comparison, and pretty-printing, with values parameterized by the `Data` module. It is used to track or analyze CIL expressions in a way that considers structurally equivalent expressions as equal, particularly in contexts involving `sizeof`.",
      "description_length": 468,
      "index": 2047,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps indexed by edges in an interpreted automaton, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with edge values that represent transitions in a control flow graph, including guards and actions derived from CIL code. Use cases include tracking and manipulating edge-based properties in abstract interpretation or program analysis tasks.",
      "description_length": 423,
      "index": 2048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing command-line parameters related to kernel functions. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, each controlling how parameters are interpreted and activated. Use cases include structuring plugin options and controlling parameter activation based on user input or dependencies.",
      "description_length": 402,
      "index": 2049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports data types that can be stored in Frama-C's project-aware structures, ensuring deep copying and project membership checks. Concrete use cases include managing unique identifiers or structured keys in a hash table where project-specific properties must be preserved and queried.",
      "description_length": 435,
      "index": 2050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling keys in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `Hashtbl.Key.t` type, offering functions to manage and inspect hash table keys, including deep copying and membership checks over project skeletons. Concrete use cases include managing unique identifiers in a hash table structure and ensuring consistent key handling across different hash table implementations.",
      "description_length": 472,
      "index": 2051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with keys in a hash table, including equality, comparison, hashing, and pretty-printing. It provides a structured way to handle key values with functions like `equal`, `hash`, and `pretty`, along with utilities for deep copying and membership testing within projects. Concrete use cases include managing hash table keys in Frama-C plugins, particularly when keys involve project-specific data that must be compared, stored, or displayed uniquely.",
      "description_length": 489,
      "index": 2052,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Debug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing. It supports structured data representation with descriptors, packed descriptions, and deep copying. Useful for managing complex data in plugins requiring persistent or project-specific state.",
      "description_length": 310,
      "index": 2053,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements command-line options for handling file paths with support for equality, comparison, hashing, and pretty printing. Works with `Datatype.t` values representing file paths, providing deep copy and project membership checks. Useful for defining and managing file path parameters in Frama-C command-line tools.",
      "description_length": 316,
      "index": 2054,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line arguments in Frama-C's kernel, specifically for the `-cpp-extra-args` option. It provides operations for equality, comparison, hashing, and pretty-printing values of this type, along with deep copying and project membership checks. It is used to manage and manipulate string representations of preprocessor arguments during analysis.",
      "description_length": 404,
      "index": 2055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for expressions with structural equality and strict constant comparison. It provides standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate expression keys in a type-safe and efficient manner within analysis plugins.",
      "description_length": 408,
      "index": 2056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that represent positions in source files, including operations for equality, comparison, hashing, and pretty-printing. It works with position data structures that include file, line, and column information, along with project context. It is used to track and manipulate source code locations in Frama-C plugins, enabling precise analysis and transformation tasks.",
      "description_length": 405,
      "index": 2057,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of a given CIL component type, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports data types structured around CIL's component information, enabling efficient lookups and integrity-preserving manipulations. Concrete use cases include tracking and managing CIL-based project data across different analysis phases.",
      "description_length": 424,
      "index": 2058,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages named categories for organizing parameters in a plugin, supporting operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with strings for category names, state lists for dependencies, and accessors for parameter interpretation. Concrete use cases include setting up plugin configuration groups, enabling global parameter behavior, and defining fallback or aggregate categories.",
      "description_length": 450,
      "index": 2059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table that maps to abstract memory slices in a value analysis context. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checking for project-specific data. These keys are used to index memory models in a way that supports precise and efficient value analysis during static program verification.",
      "description_length": 444,
      "index": 2060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, using CIL's `Offset` type as keys. It provides standard operations like equality, comparison, hashing, and pretty-printing for these tables, along with deep copying and project membership checks. Concrete use cases include managing per-offset metadata in CIL analyses or transformations, such as tracking variable annotations or analysis results across different program points.",
      "description_length": 469,
      "index": 2061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map data structure with operations for equality, comparison, hashing, and pretty-printing. It provides a registered datatype for use in Frama-C plugins, including deep copy and project membership checks. Concrete use cases include managing plugin-specific data indexed by strings and ensuring safe data transfer across Frama-C analyses.",
      "description_length": 368,
      "index": 2062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a hash table, providing operations for equality, comparison, hashing, and pretty-printing. It supports the `Hashtbl.Key.t` type, which is used to represent keys in a hash table structure. Concrete use cases include managing unique identifiers or symbolic values in static analysis plugins, where deep copying, comparison, and project membership checks are required.",
      "description_length": 413,
      "index": 2063,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module parameter, organizing values into a hash table structure. Concrete use cases include efficiently storing and retrieving typed values in Frama-C plugins, such as analysis results or structured program data.",
      "description_length": 429,
      "index": 2064,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling string-based command-line parameters in Frama-C kernel extensions. It supports operations like equality checking, comparison, hashing, and pretty-printing for values of this type, along with deep copying and project membership testing. It is used to manage and manipulate load-module options passed via the `-load-module` command line argument.",
      "description_length": 389,
      "index": 2065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for 64-bit integer keys used in hash tables, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with lists of key representatives, deep copying, and checking membership based on project conditions. Concrete use cases include managing and querying 64-bit integer identifiers in Frama-C's analysis plugins.",
      "description_length": 396,
      "index": 2066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with CIL attributes in Frama-C plugins, particularly for managing and manipulating attribute values stored in hash tables. Concrete use cases include tracking and transforming CIL attributes during static analysis, such as handling function or variable annotations.",
      "description_length": 451,
      "index": 2067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by `Fieldinfo` values, where the associated data type is specified by the `Data` parameter. It supports standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing for debugging or analysis output. It is suitable for tracking field-specific annotations or metadata in CIL-based analyses or transformations.",
      "description_length": 411,
      "index": 2068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL types with structural comparison and attribute-ignoring semantics. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checks. Concrete use cases include managing and querying type-based keys in Frama-C plugins where structural identity matters and attributes should be disregarded.",
      "description_length": 455,
      "index": 2069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are identifiers and values are of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types that include project-specific information, enabling checks on embedded projects via `mem_project` and deep copying with `copy`. Concrete use cases include managing collections of CIL entities with associated metadata across different analysis projects.",
      "description_length": 458,
      "index": 2070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports maps keyed by `Enuminfo` types, enabling efficient lookups and manipulations of CIL enumeration-based data. Concrete use cases include tracking and analyzing C enumeration constants during static analysis, such as mapping enum values to their associated attributes or computed properties.",
      "description_length": 471,
      "index": 2071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype keyed by CIL labels with values parameterized by the `Data` module. It supports standard map operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate label-indexed data in CIL-based analyses, such as tracking per-label analysis results or annotations.",
      "description_length": 394,
      "index": 2072,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Int.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines an abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides a structured descriptor, a list of representative values, and utilities for deep copying and project membership checks. Concrete use cases include managing plugin-specific data with strong type integrity and enabling serialization through packed descriptors.",
      "description_length": 388,
      "index": 2073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with CIL logic constructor information, enabling storage and retrieval of values while preserving structural properties. Concrete use cases include managing logic function symbols or annotations in static analysis plugins.",
      "description_length": 408,
      "index": 2074,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for associating bases with memory maps, where each memory map is parameterized by the `Data` module. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying, along with project-based membership queries. It is used to manage and manipulate memory states in static analysis, particularly when tracking data associated with different memory regions.",
      "description_length": 434,
      "index": 2075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for expressions with structural equality in the context of CIL-based analysis. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking the presence of project-specific data. It is used to manage and manipulate keys that uniquely identify expressions in a way that supports efficient lookup and comparison in analysis plugins.",
      "description_length": 490,
      "index": 2076,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are based on the provided `Data` module's values. It supports standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate collections of constant values in CIL-based analyses, such as tracking and comparing constant expressions across different program points.",
      "description_length": 437,
      "index": 2077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports structured data handling with deep copying, membership testing by project, and type-safe value representation. Concrete use cases include managing collections of CIL type information with efficient lookups and type-aware manipulations in Frama-C plugins.",
      "description_length": 439,
      "index": 2078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by memory locations with bit-level precision, where each binding associates a `Location_Bits` key with a value of a specified type. It supports operations like equality testing, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to track and manipulate data tied to specific memory regions in bit-level detail, such as during static analysis of low-level memory operations.",
      "description_length": 483,
      "index": 2079,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values with structural equality and strict constant comparison. It supports operations such as equality checking, comparison, hashing, and pretty-printing, making it suitable for use in analysis plugins requiring precise key management. The module also provides utilities for deep copying and project membership testing, enabling robust handling of key values across different analysis contexts.",
      "description_length": 475,
      "index": 2080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on CIL types with comparison done by key identity without unrolling, and values are determined by the provided `Data` module. It supports standard map operations including equality, comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is suitable for scenarios requiring associative storage of CIL-based keys with strict structural identity semantics.",
      "description_length": 451,
      "index": 2081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Action.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing. It supports structured values through a descriptor and provides deep copying and project membership checks. Concrete use cases include managing plugin-specific data with strong identity and structural guarantees, such as analysis results or configuration settings.",
      "description_length": 378,
      "index": 2082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify terms in CIL (C Intermediate Language) during analysis. It provides operations for comparing, hashing, and pretty-printing these keys, along with deep copying and checking membership based on project-specific criteria. It is used to manage and manipulate term identifiers in a way that supports precise static analysis tasks such as value tracking or term-based dataflow analysis.",
      "description_length": 445,
      "index": 2083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table mapping memory locations (as base-offset pairs in bytes) to values of a specified data type. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage and manipulate byte-level memory associations in static analysis plugins.",
      "description_length": 378,
      "index": 2084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are compared using structural equality based on CIL offset and struct equivalence, and values are of the provided `Data` module type. It supports standard map operations like lookup, insertion, and iteration, along with type-specific functionality such as equality checking, comparison, hashing, and pretty printing. Concrete use cases include managing and manipulating CIL-based data indexed by structurally equivalent keys in static analysis plugins.",
      "description_length": 492,
      "index": 2085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Empty_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a command-line option datatype for handling empty strings, providing operations for equality, comparison, hashing, and pretty-printing. It works with the `t` type representing empty string values, along with standard infrastructure for project membership checks and deep copying. Concrete use cases include defining and managing command-line flags that accept empty string arguments in Frama-C plugins.",
      "description_length": 422,
      "index": 2086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps, including equality, comparison, hashing, and pretty-printing. It works with the abstract key type `t` representing keys in a map structure. Concrete use cases include managing and comparing keys in map-based data structures, ensuring deep copies, and checking project membership via custom predicates.",
      "description_length": 355,
      "index": 2087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing keys in a hash table, specifically for values of type `Frama_c_kernel.Datatype.Rational.Hashtbl.key`. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership testing for project-specific data. These functions support efficient storage, retrieval, and manipulation of rational-number-based keys in analysis plugins.",
      "description_length": 415,
      "index": 2088,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store code annotations, specifically handling equality, comparison, and hashing operations. It works with structured descriptors and project-based data, enabling efficient lookups and manipulations of annotated CIL code elements. Concrete use cases include tracking and retrieving annotations associated with specific code locations or constructs in static analysis plugins.",
      "description_length": 432,
      "index": 2089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic information values, providing standard operations like equality, comparison, hashing, and pretty printing. It works with the `t` type, which represents a map of logic information values parameterized by the `Data` module. Concrete use cases include managing and manipulating logic-specific data mappings during static analysis, such as tracking logical properties or annotations across different program points.",
      "description_length": 477,
      "index": 2090,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map that identify logic constructor information in CIL (C Intermediate Language) data structures. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and membership checks for project-specific data. These keys are used to manage and access logic constructor entries in a map, specifically in the context of Frama-C plugin development.",
      "description_length": 441,
      "index": 2091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing command-line parameters, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with parameter states and accessors to control how options are interpreted and activated. Concrete use cases include setting up default behaviors, enabling all options under a specific interpretation, and defining dependencies between categories.",
      "description_length": 442,
      "index": 2092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with key-value pairs where keys are from the `Attributes` module and values are of the provided `Data` type. It is used to manage structured attribute-value mappings in CIL-based analyses, enabling precise data representation and manipulation for specific analysis needs.",
      "description_length": 439,
      "index": 2093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.WithOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a registered datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise data manipulation and analysis. Concrete use cases include defining custom analysis data structures and ensuring consistent serialization, comparison, and display within Frama-C's plugin ecosystem.",
      "description_length": 471,
      "index": 2094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are based on CIL constants with strict comparison semantics, ensuring that textual representations influence equality checks. It supports operations like equality testing, comparison, hashing, and pretty-printing for values stored in the hash table. Concrete use cases include managing and comparing CIL constants with precise textual fidelity, such as tracking and analyzing constant expressions in C code during static analysis.",
      "description_length": 483,
      "index": 2095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are logic symbols with structural comparison, and values are of a specified type. It supports standard map operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project-aware membership checks. It is used to manage collections of logic symbol-based mappings in a way that respects structural identity and enables safe analysis during CIL processing.",
      "description_length": 431,
      "index": 2096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps that associate memory locations with bit-level offsets. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. These keys are used to manage and query memory location mappings in static analysis plugins for Frama-C.",
      "description_length": 376,
      "index": 2097,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps associated with CIL function declarations. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and membership checks over project skeletons. The module supports efficient key-based data management and is used in static analysis plugins to track and manipulate function-specific data across different project contexts.",
      "description_length": 431,
      "index": 2098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing elements within a kernel function map, using string-named categories and accessors. It supports operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with setting dependencies and enabling behaviors. Concrete use cases include categorizing analysis options or function behaviors in a plugin, where category semantics affect how parameters are interpreted during analysis.",
      "description_length": 477,
      "index": 2099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based configuration parameters for Frama-C plugins, combining direct operations for validation, storage, and change tracking with structured data handling from its child modules. It supports key operations such as setting and retrieving constrained string values, registering update hooks, and enforcing validity checks, working primarily with strings and project-specific data structures. The integrated functionality allows plugins to define configurable options requiring controlled input, such as valid function names, while enabling data serialization and exchange between components. Example uses include tracking user-defined settings and maintaining analysis results as strings within a project.",
      "description_length": 730,
      "index": 2100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for logic types without unrolling, based on the provided `Data` module. It supports standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate collections of logic type values in a type-safe and efficient manner, particularly in static analysis plugins requiring precise type handling.",
      "description_length": 461,
      "index": 2101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list.Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define and manipulate named categories with associated accessors and dependencies. It works with category types and state lists to control plugin behavior through parameters. Concrete use cases include setting up configurable options for static analysis tools, such as enabling or disabling specific analysis features via command-line flags.",
      "description_length": 433,
      "index": 2102,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, where keys are CIL locations. It provides standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. Concrete use cases include tracking and manipulating location-indexed data during CIL analysis, such as mapping source code locations to analysis results.",
      "description_length": 421,
      "index": 2103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map implementation based on hash-consed trees. It includes standard operations like equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It is used to manage keys that index into a Patricia tree-based map structure, ensuring efficient and consistent handling of tree-structured keys.",
      "description_length": 418,
      "index": 2104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by CIL types, where type comparisons account for structural equivalence of structs and typedef unrolling. It provides standard map operations\u2014lookup, insertion, iteration\u2014along with serialization, comparison, and pretty-printing tailored for CIL type-based keys. Concrete use cases include managing type-specific analyses or annotations in C code, such as tracking type properties across a program's abstract syntax tree.",
      "description_length": 456,
      "index": 2105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of the `Term_lval` type, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working directly with `Term_lval` values in a hash table structure, enabling efficient lookups and storage. Concrete use cases include managing and tracking term-level CIL l-values during static analysis, such as in dataflow or points-to analyses.",
      "description_length": 441,
      "index": 2106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a hash table implementation, specifically tailored for abstract interpretation contexts. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with utilities for deep copying and checking membership based on project-specific predicates. The key type is designed to support structured, project-aware data storage and retrieval in static analysis plugins.",
      "description_length": 446,
      "index": 2107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a graph structure, where each edge has a source and destination vertex along with a label. It provides operations to create edges, retrieve their source, destination, and label, and compare edges based on their direction. It is used to model relationships between vertices in a service graph, particularly for tracking dependencies or connections in a callgraph.",
      "description_length": 403,
      "index": 2108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a map for file paths with operations for equality, comparison, hashing, and pretty printing. Works with `Datatype.t` values representing file paths and supports deep copying and project membership checks. Useful for managing file path data in command-line options with structured persistence and comparison.",
      "description_length": 318,
      "index": 2109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for grouping command-line options related to file paths. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each controlling how options are interpreted and enabled. Use cases include organizing related file path parameters and controlling their activation behavior in the command line interface.",
      "description_length": 392,
      "index": 2110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module parameter, organizing values into a hash table structure with efficient lookups and storage. Concrete use cases include managing collections of CIL entities like functions or variables with fast access and structural consistency checks.",
      "description_length": 460,
      "index": 2111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports working with structured data through a list of representants, a type descriptor, and deep copy functionality. Concrete use cases include managing unique identifiers in maps and comparing or serializing structured values within analysis plugins.",
      "description_length": 389,
      "index": 2112,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a hash table implementation, including equality, comparison, hashing, and pretty-printing functions. It works with the abstract type `t` representing hash table keys and supports operations like checking membership in projects, deep copying, and generating representative values. Concrete use cases include managing and comparing keys in hash tables that store CIL constants, ensuring efficient lookups and consistent handling of key values across different analyses.",
      "description_length": 515,
      "index": 2113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for maps with operations including equality, comparison, hashing, and pretty printing. It works with the `t` type, representing keys in a map structure. Concrete uses include managing unique identifiers for map entries, comparing and hashing keys for efficient lookups, and deep copying keys to avoid shared state.",
      "description_length": 339,
      "index": 2114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Int.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling integer-based command-line parameters with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing within projects, and provides descriptors for type representation. Concrete use cases include defining and managing integer configuration options in Frama-C plugins, such as setting analysis thresholds or numeric limits.",
      "description_length": 419,
      "index": 2115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map indexed by CIL locations, where values are of the parameterized `Data` type. It provides standard map operations such as lookup, insertion, and traversal, along with equality, comparison, and hashing functions for the map itself. It is suitable for tracking per-location data in CIL-based analyses, such as annotations or analysis results tied to specific program points.",
      "description_length": 400,
      "index": 2116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify global annotations in CIL. It provides operations for comparing, hashing, and printing these keys, along with utilities for checking membership based on project properties and creating deep copies. It works directly with CIL's global annotation keys, enabling precise handling and efficient lookups in contexts like static analysis plugins that require tracking or querying annotated program elements.",
      "description_length": 466,
      "index": 2117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are based on CIL constants with strict comparison, and values are of a specified data type. It supports operations like equality checking, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to manage structured collections of CIL constants with strict identity, suitable for static analysis tasks requiring precise constant tracking.",
      "description_length": 433,
      "index": 2118,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map, based on logic types without unrolling, providing standard operations like equality, comparison, hashing, and pretty printing. It supports working with CIL types, projects, and descriptors, enabling precise key management in maps that require structural and semantic integrity. Use cases include tracking logic type keys in analysis plugins, ensuring unique identification and comparison within Frama-C's abstract interpretation frameworks.",
      "description_length": 476,
      "index": 2119,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module implements a key type for maps based on `Term_lhost`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured data manipulation with deep copying, membership testing with project functions, and type representation features like descriptors and representants. Concrete use cases include managing and querying term-based identifiers in static analysis plugins where structured keys are necessary for map operations.",
      "description_length": 484,
      "index": 2120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are constants and values are of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with CIL constants as keys and user-defined data types for values, enabling structured storage and retrieval. Concrete use cases include tracking constant-value associations during static analysis, such as mapping integer constants to analysis results or symbolic expressions.",
      "description_length": 459,
      "index": 2121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hashconsed map structure where keys are associated with values of a specified data type. It provides standard map operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage state with unique, immutable key-value associations in static analysis plugins.",
      "description_length": 367,
      "index": 2122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are compared strictly, including textual representation when present. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys. It is used to manage map keys in a way that ensures precise and consistent behavior during analysis tasks involving CIL data structures.",
      "description_length": 361,
      "index": 2123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for values with structural equality and strict constant comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking the presence of project values. The key type is used to represent and manipulate CIL lvalues in contexts requiring precise structural identity, such as analysis state tracking or value caching.",
      "description_length": 482,
      "index": 2124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.As_string.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling symbolic path entries as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports working with Frama-C's project structure through membership checks and deep copying, ensuring values are fully independent. It is used to manage and manipulate symbolic path representations in a type-safe manner during analysis.",
      "description_length": 391,
      "index": 2125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear.Matrix",
      "library": "frama-c.kernel",
      "description": "This module implements matrix operations for fixed-size matrices with scalar coefficients, supporting arithmetic operations like addition, multiplication, and inversion, as well as norms and transformations like transpose and shifting. It works with matrices indexed by finite types, using natural numbers for dimensions and scalars for entries. Concrete use cases include computing and manipulating linear filters for invariant analysis, such as finding bounds on state dimensions through matrix powers and solving linear recurrence relations.",
      "description_length": 544,
      "index": 2126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype specialized for values of a given `Data` module, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as storing and managing CIL terms with structural identity, ensuring deep copies and project-aware membership checks. The hash tables are used to maintain mappings between CIL entities in static analysis plugins.",
      "description_length": 426,
      "index": 2127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a specialized hashtbl, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured keys that may contain project-specific data, enabling deep copying and membership checks against project predicates. Concrete use cases include managing and querying machine-dependent state with strong identity and structural guarantees.",
      "description_length": 417,
      "index": 2128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with CIL terms that are identified and stored in a hash table structure, ensuring deep copies and project-aware membership checks. Concrete use cases include managing collections of CIL entities like variables or expressions with efficient lookups and structural comparisons.",
      "description_length": 468,
      "index": 2129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type for vertices in an interpreted automaton, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with vertex data structures that include project-specific information, enabling efficient lookups and manipulations in hash tables. Concrete use cases include tracking control flow graph nodes with associated semantic properties during abstract interpretation.",
      "description_length": 439,
      "index": 2130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for command-line parameters in a map structure that supports multiple bindings. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, each associated with a list of states and an accessor function. Use cases include organizing and controlling groups of related command-line options in static analysis tools built on the Frama-C framework.",
      "description_length": 432,
      "index": 2131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered, immutable set operations for managing collections of control flow vertices in automata with unrolled loops, supporting union, intersection, filtering, and ordered traversal. It works with vertex sets from interpreted automata that model program control flow, enabling precise manipulation of vertex neighborhoods during abstract interpretation tasks like loop analysis or path-sensitive state tracking. Key features include nearest-neighbor queries, sequence conversion, and introspection tools tailored for program analysis workflows involving unrolled control structures.",
      "description_length": 603,
      "index": 2132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line string parameters with support for value setting, update hooks, default handling, and serialization, interpreting strings either as plain file paths or validated function names. It includes a dedicated submodule for handling lists of file paths, offering operations like `equal`, `compare`, `hash`, and `pretty` for comparison, querying, and pretty-printing, along with project membership checks via `mem_project`. The core module supports operations such as setting values with optional validation, attaching update hooks for reactive changes, and serializing parameters for persistence. Example uses include parsing and validating file path arguments or function targets in static analysis tools, ensuring correct syntax while allowing flexible input handling.",
      "description_length": 795,
      "index": 2133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table indexed by filepaths, where each table instance is parameterized by the data type stored in the table. It supports standard hash table operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage collections of values associated with normalized filepaths, enabling efficient lookups and manipulations tied to specific files in analysis plugins.",
      "description_length": 463,
      "index": 2134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are compared using structural equality based on the `LvalStructEq` semantics, and values are of the provided `Data` module type. It supports standard map operations like lookup, insertion, and iteration, along with derived capabilities such as comparison, hashing, and pretty printing. Concrete use cases include managing value maps in static analysis where structural equality on CIL l-values is required, such as tracking memory states or variable bindings in an analyzer plugin.",
      "description_length": 521,
      "index": 2135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with keys based on `OffsetStructEqStrict` and values determined by the `Data` parameter. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, all tailored to maintain strict structural consistency. It is suitable for managing structured CIL data mappings where precise equality and strict constant comparison are required, such as analyzing or transforming C code elements with associated metadata.",
      "description_length": 501,
      "index": 2136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in a map structure, providing essential operations such as equality, comparison, hashing, and pretty printing. It supports concrete data types like `Project_skeleton.t` and is used to manage and manipulate key-based data representations in a map. Specific use cases include tracking and comparing map keys in static analysis plugins, ensuring deep copies and proper memory management.",
      "description_length": 429,
      "index": 2137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure associated with usable emitters, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports working with emitter keys that may contain project-specific data, enabling checks on project membership and deep copying to avoid shared state. Concrete use cases include managing and distinguishing emitter states across different analysis projects and ensuring correct key handling in map-based data structures.",
      "description_length": 512,
      "index": 2138,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string command-line options with support for validation, change hooks, aliases, computed defaults, and value constraints. It provides core operations for defining and manipulating string parameters, including setting and retrieving values, applying transformations, and enforcing allowed value sets. The child module enhances this functionality by organizing parameters in a map structure with strong equality, comparison, and copying semantics. Together, they enable tasks like parsing command-line flags, binding string options with validation rules, and maintaining independent string settings with custom behaviors.",
      "description_length": 639,
      "index": 2139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with keys of type `Data.t` using structural equality and strict constant comparison. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Suitable for managing collections of CIL expressions where strict structural identity and efficient hash-based lookups are required.",
      "description_length": 402,
      "index": 2140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module handles multiple string values as command-line parameters, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with strings and project skeletons to manage parameter representations and project membership queries. Concrete use cases include defining and manipulating string-based command-line options that require multiple values, such as file paths or configuration flags. It integrates with submodules to extend functionality for specific parameter handling needs.",
      "description_length": 521,
      "index": 2141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables where keys are based on properties ordered by function criteria, including attributes like kernel function name, kinstr, property kind, and property ID. It provides operations for equality, comparison, hashing, and pretty-printing these keys, along with utilities for deep copying and checking project membership. Concrete use cases include managing property-based mappings in Frama-C plugins, such as storing analysis results or annotations tied to specific code elements.",
      "description_length": 527,
      "index": 2142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by interpreted automaton vertices, with values parameterized by the `Data` module. It provides standard map operations including equality, comparison, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to associate vertex-specific data with control flow graph nodes in abstract interpretation workflows.",
      "description_length": 386,
      "index": 2143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages command-line parameters that accept multiple string values, supporting validation, alias resolution, and state serialization through string-based data structures and map-like constructs. It defines a data type for handling parameters with multiple bindings, offering operations for equality, comparison, hashing, pretty printing, and deep copying, enabling robust management of configuration options in Frama-C plugins. Submodules extend this functionality to support multibindings, allowing parameters to accumulate multiple entries, such as repeated `-I` paths, with mechanisms to enforce value constraints and resolve aliases. Examples include parsing and validating repeated string inputs, dynamically updating project-specific configurations, and serializing current parameter states for persistence or debugging.",
      "description_length": 838,
      "index": 2144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a hash table that uniquely identify CIL enumeration items. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate distinct enum item identifiers in Frama-C analyses and transformations.",
      "description_length": 359,
      "index": 2145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports project-aware membership checks, deep copying, and integrates with Frama-C's typing and structural description systems. Concrete use cases include managing attribute-based metadata across CIL constructs, such as tracking function or variable annotations during static analysis.",
      "description_length": 455,
      "index": 2146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integers and values are of the provided `Data` module's type. It supports standard map operations such as lookup, insertion, and iteration, along with equality, comparison, and hashing for use in collections. It is suitable for managing integer-indexed collections of values with precise type control, such as tracking analysis results per program point.",
      "description_length": 398,
      "index": 2147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype where keys are standard hash table keys and values are of a specified datatype. It supports operations like equality checking, comparison, hashing, and pretty-printing for the hash table values. It is used to manage hash tables with structured values in Frama-C plugins, enabling deep copies and project-aware membership checks.",
      "description_length": 370,
      "index": 2148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where keys are of type `Data.t`. It provides operations for equality checking, comparison, hashing, deep copying, and pretty-printing hash tables, along with descriptors for type representation and project membership testing. It is used when building datatypes that require structural equality and comparison over hash tables of a specific data type.",
      "description_length": 395,
      "index": 2149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data management tasks such as deep copying, membership checking within projects, and type representation with descriptors. Concrete use cases include tracking and manipulating collections of memory base values in static analysis plugins.",
      "description_length": 413,
      "index": 2150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in a map structure that associates logic types by name. It provides equality, comparison, hashing, and pretty-printing functions for these keys, along with deep copying and project membership checks. These keys are specifically designed to index logic types in a map, enabling efficient and structured access to CIL logic type information.",
      "description_length": 384,
      "index": 2151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for keys used in maps with `Varinfo` values, including equality, comparison, hashing, and pretty-printing. It supports data types representing variable information keys, typically used for managing and querying variable metadata in CIL-based analyses. Concrete use cases include tracking variable properties across different analysis phases and implementing efficient lookups in static analysis plugins.",
      "description_length": 434,
      "index": 2152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored for CIL types compared by name without unrolling. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include managing and retrieving CIL type information in a hashtable, ensuring correct behavior when keys are structurally equivalent but named differently.",
      "description_length": 449,
      "index": 2153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a map used to represent logic constants in CIL-based analyses. It provides standard operations including equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate logic constant identifiers in static analysis plugins.",
      "description_length": 346,
      "index": 2154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and operations for a map, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.key` type, providing utilities to manage key values within a map structure. Concrete use cases include efficient key-based lookups, set operations, and serialization for analysis plugins in Frama-C.",
      "description_length": 352,
      "index": 2155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version.Set",
      "library": "frama-c.kernel",
      "description": "This module offers an ordered, immutable set abstraction for managing versioned control flow states, supporting operations like union, intersection, ordered iteration, and nearest-neighbor queries. It works with versioned elements in interpreted automata, leveraging a total ordering to enable efficient set transformations and precise membership checks. Its functionality is particularly useful for static analysis tasks involving loop unrolling and state version tracking, where ordered set manipulations help model control flow transitions and analyze program paths systematically.",
      "description_length": 584,
      "index": 2156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure keyed by logic variables, with values parameterized by the `Data` module. It provides standard map operations such as lookup, insertion, and iteration, along with serialization, comparison, and pretty-printing capabilities. It is used to manage collections of logic variable bindings in a type-safe manner, particularly during CIL analysis and transformation tasks.",
      "description_length": 409,
      "index": 2157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a functional set interface for hash-consed tree keys, supporting ordered set operations such as union, intersection, and difference, alongside ordered iteration, filtering, and partitioning. It operates on sets of hash-consed trees (`Set.t`), leveraging a total ordering module to maintain structure invariants and enable efficient membership queries, nearest-neighbor searches, and conversions to ordered sequences or lists. Designed for static analysis tools, it integrates serialization, deep copying, and plugin-compatible type management, facilitating tasks like program dependency tracking and constraint propagation.",
      "description_length": 644,
      "index": 2158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CodeOutput.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating code output descriptors in the kernel. It supports equality checks, comparison, hashing, pretty printing, and deep copying, along with utilities to inspect and filter based on project membership. It is used to manage structured data during code analysis and transformation tasks tied to the `-ocode` functionality.",
      "description_length": 406,
      "index": 2159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module manages mutable sets of strings for command-line options, supporting dynamic updates, membership checks, and integration with Frama-C's state system. It works with `Frama_c_kernel.Datatype.String.Set.t` and provides operations for serialization, parsing, and hook-based modification, enabling use cases like target file or exclusion list configuration. Submodules extend this functionality by managing parameter categories, validating string inputs, and handling filled string sets with deep copying and project-aware checks. Together, they support structured, customizable analysis configurations with strict input control and context-sensitive behavior.",
      "description_length": 667,
      "index": 2160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_map",
      "library": "frama-c.kernel",
      "description": "This module implements map-based parameter handling with unique key-value semantics, using `K.Map.t` to manage hierarchical configurations through operations like insertion, default management, and change notifications. It supports structured state management for analysis settings via command-line options, with utilities for iteration, serialization, and alias resolution. Child modules enhance this by adding support for parameter equality, category management with dependency tracking, and string option validation with transformation rules. Examples include configuring per-function analysis settings, organizing command-line flags into logical groups, and enforcing constraints on string inputs with dynamic defaults.",
      "description_length": 723,
      "index": 2161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_list",
      "library": "frama-c.kernel",
      "description": "This module manages string lists as plugin configuration values with support for command-line parsing, default handling, and update hooks, while maintaining a persistent, project-aware collection for aggregation and serialization. It operates on string lists and a global collection type, offering operations like addition, iteration, fusion, equality, hashing, and pretty-printing, with deep integration into Frama-C's analysis framework for dynamic configuration and incremental updates. The module enables plugins to define parameter categories, validate string inputs against criteria like function names, and treat string lists as single values for structured configuration, supporting use cases such as analysis option setup, alias management, and session-persistent state tracking. Submodules enhance these capabilities by providing project membership checks, category-based parameter behavior, and structured validation with serialization control.",
      "description_length": 955,
      "index": 2162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides efficient key-value storage indexed by native integers, supporting operations like insertion, lookup, iteration, and ordered traversal with custom comparisons. It includes submodules that specialize the hash table for specific data types and define key operations for native integer identifiers, enabling use cases like caching and large dataset processing. The API allows bulk updates from sequences and integrates with type handling and pretty printing for structured data manipulation. Together, the module and its children offer a robust solution for high-performance mappings with native integer keys and typed values.",
      "description_length": 644,
      "index": 2163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on integer intervals with congruence, supporting operations such as equality, comparison, hashing, and pretty printing. It works with intervals defined by min, max, rem, and modu, where bounds can represent infinity and congruence is enforced modulo modu. It is used to manage and manipulate symbolic integer ranges in static analysis contexts, such as tracking variable bounds and arithmetic properties in program analysis.",
      "description_length": 470,
      "index": 2164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements backward dataflow analysis on control flow graphs, computing dataflow facts from the exit node toward the entry. Works with graph structures built from CIL expressions and instructions, using a specified data domain `D`. Useful for analyses like liveness or constant propagation where information flows from successors to predecessors.",
      "description_length": 346,
      "index": 2165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps keyed by component information, supporting efficient insertion, deletion, and ordered traversal over polymorphic values. It enables static analysis tasks like aggregating metadata or processing structured C elements with physical equality optimizations and customizable pretty-printing. The key module provides comparison, hashing, and introspection for CIL components, while the data-specific submodule offers type-safe value management with deep copying and project-wide membership checks. Together, they facilitate structured data tracking and manipulation across CIL-based analyses.",
      "description_length": 634,
      "index": 2166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_map",
      "library": "frama-c.kernel",
      "description": "This module organizes command-line parameters using string-keyed maps that support value mutation, default handling, and change tracking, with integration for marshaling, aliasing, and functional transformations. It provides data types for string-based keys and abstract values with operations for comparison, hashing, and structured manipulation, enabling use cases like hierarchical configuration parsing and dynamic reconfiguration with side-effect tracking. Child modules extend this foundation with validation and hooks for string parameters, general string map operations over arbitrary values, and category management for grouping and activating related options. Examples include restricting parameter values to predefined lists, serializing persistent state, and defining interdependent parameter groups with custom activation logic.",
      "description_length": 841,
      "index": 2167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_weak.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table for hashconsing values of a specific datatype, ensuring that equivalent values are represented identically in memory. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage interned values efficiently, particularly in static analysis contexts where memory usage and value identity are critical.",
      "description_length": 448,
      "index": 2168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintShare.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation and manipulation, primarily used for handling and querying project-specific data through descriptors and representants. Concrete use cases include managing and comparing complex data structures during static analysis, particularly when tracking or printing shared project paths.",
      "description_length": 500,
      "index": 2169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Caml_weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table for managing OCaml values with identity-based equality and hashing. Works with any datatype that supports comparison, hashing, and deep copying, leveraging structural descriptions for representational integrity. Useful for caching analyses or intermediate results tied to specific project states without preventing garbage collection.",
      "description_length": 363,
      "index": 2170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Set",
      "library": "frama-c.kernel",
      "description": "This module supports standard set operations for logic variables, including union, intersection, difference, and ordered traversal, along with transformation functions like map and filter. It works with sets of `Logic_var.t` values, supporting project membership checks, ordered manipulations, and type-safe conversions, which are essential for static analysis tasks like CIL code verification and transformation. Key use cases include efficient membership queries, nearest-element lookups, and maintaining ordered logic variable sets during CIL-based program analysis.",
      "description_length": 569,
      "index": 2171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associative maps with keys of type `Typeinfo.t`, offering operations for ordered key manipulation, conditional traversal, and bidirectional iteration. It supports advanced map transformations, filtering, and comparison, along with sequence-based construction and customizable pretty-printing, making it ideal for static analysis tasks like merging CIL type definitions or generating type summaries. The key module provides core operations for key equality, comparison, and pretty printing, while the data-specialized submodule enables structured value management with type-safe operations across project analyses. Together, they facilitate precise type information handling in complex static analysis workflows.",
      "description_length": 731,
      "index": 2172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of `Term_lval` elements with standard set operations (union, intersection, difference, membership checks) and ordered traversal capabilities. It supports transformations (map, filter), bulk conversions to/from lists/sequences, and range-based queries, leveraging `Term_lval.compare` for ordering. Such functionality is useful in static analysis for tracking CIL terms representing memory locations or expressions, enabling efficient set-theoretic reasoning over program elements with inherent ordering.",
      "description_length": 538,
      "index": 2173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides the `only_if` function, which conditionally executes a monadic action based on a boolean flag. It works with monadic values of type `unit t`, where `t` is a monad instance. A concrete use case is selectively running a stateful or effectful operation only when a specific condition is met, such as logging or updating state only on certain branches of a computation.",
      "description_length": 386,
      "index": 2174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map where keys are integer intervals with congruence, and values are of a specified data type. It supports operations such as equality checking, comparison, hashing, pretty printing, and deep copying of the map. Concrete use cases include tracking value ranges with modular constraints in static analysis, efficiently storing and querying interval-based mappings, and supporting project-specific data management with custom descriptors and representations.",
      "description_length": 481,
      "index": 2175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of memory zones, where each zone pairs a base identifier with a bit range, enabling precise tracking of memory regions in static analysis. It supports efficient set operations like union, intersection, and difference, along with ordered traversal, filtering, and mapping over these zones to model memory state transformations. Key use cases include analyzing C program memory accesses, verifying pointer safety, and managing dynamic memory regions during abstract interpretation.",
      "description_length": 515,
      "index": 2176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for mapping CIL types to arbitrary values using structural key comparison that ignores attributes, enabling efficient lookups and transformations in C analysis tools. It supports ordered iteration and folding over entries sorted by keys, values, or custom criteria, along with memoization and initialization from sequences. The associated modules define hash table data structures and key types tailored for CIL, offering operations like equality, hashing, pretty printing, and project-aware membership checks. Examples include tracking type-based metadata in compiler plugins or performing attribute-agnostic type analysis in static code processing tools.",
      "description_length": 689,
      "index": 2177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure that supports efficient comparison, equality checks, and hashing. It works with a specific type `t` representing map keys, along with associated descriptors, representations, and project membership checks. Concrete use cases include managing and querying structured annotations or property statuses tied to different emitter instances in static analysis tasks.",
      "description_length": 440,
      "index": 2178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Set",
      "library": "frama-c.kernel",
      "description": "This module enables ordered manipulation of CIL attribute sets through operations like union, filtering, and ordered iteration, while supporting conversions between sets, sequences, and lists. It includes utilities for membership checks, comparison, and pretty-printing, facilitating static analysis tasks such as attribute management and subset verification in C code analysis.",
      "description_length": 378,
      "index": 2179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatHex.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for managing and comparing values related to floating-point hexadecimal representations. It includes standard equality, comparison, and hashing functions, along with pretty-printing and deep copying capabilities. It is used to handle internal state values tied to the `-float-hex` option, enabling precise analysis and transformation of floating-point literals in source code.",
      "description_length": 424,
      "index": 2180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of logic constants with operations for creation, modification, and querying, supporting both imperative-style updates and functional transformations. It provides ordered traversal, subset checks, and conversions to lists and sequences, leveraging the underlying ordered structure for efficient element selection and comparison. Designed for static analysis tasks, it handles logic constant sets in CIL-based plugins, with use cases like constraint propagation and symbolic state merging where precise set semantics and ordered iteration are critical.",
      "description_length": 586,
      "index": 2181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing CIL structure offsets with equality semantics, supporting efficient element queries, transformations, and ordered traversal. It works with sets of `OffsetStructEq.t` values, leveraging comparator-driven ordering for tasks like static analysis of C memory layouts, tracking struct field offsets, and resolving nearest-neighbor offset relationships in program data structures. Key capabilities include monotonic predicate-based filtering, bidirectional iteration, and set-theoretic operations tailored for compiler or analysis tools handling low-level memory representations.",
      "description_length": 628,
      "index": 2182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Enum",
      "library": "frama-c.kernel",
      "description": "This module enables defining type-safe enumerations with a fixed set of values, supporting comparison, hashing, and pretty-printing. It provides operations to manage values, check membership in projects, and integrate with Frama-C's option system for command-line customization of analysis parameters. Submodules extend this functionality with utilities for deep copying, type description, and structured serialization. Use cases include selecting analysis modes or output formats with guaranteed validity through variant types.",
      "description_length": 528,
      "index": 2183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map structure using emitter-based keys, supporting functional transformations like insertion, deletion, and ordered traversal while preserving immutability. It provides core operations for managing emitter-associated data, including filtering, mapping, and folding, with support for structured data types through specialized submodules that enable equality checks, comparison, and pretty-printing. One submodule focuses on value handling for data types like Frama-C annotations, enabling typed queries and efficient lookups, while the other specializes in key management, offering operations for project-based emitter states and deep copying. Together, they facilitate tasks such as aggregating analysis results, tracking property statuses, and generating structured outputs from emitter data.",
      "description_length": 830,
      "index": 2184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.List_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic list type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides utilities to manipulate list values, including deep copying and checking membership based on project values. The type supports standard list operations and is used to represent and process structured data in Frama-C plugins.",
      "description_length": 356,
      "index": 2185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Custom",
      "library": "frama-c.kernel",
      "description": "This module enables the integration of custom data types into Frama-C plugins by providing core operations for equality, comparison, hashing, and pretty-printing, along with support for deep copying and membership testing in project skeletons. Its child modules extend this functionality to specialized data structures, allowing custom types to be used seamlessly as parameters in plugin APIs and project-aware computations. For example, users can define a custom abstract syntax tree node type and use it directly in Frama-C analyses or transformations. The combined interface supports both direct manipulation of custom values and structured interaction through plugin-specific extensions.",
      "description_length": 691,
      "index": 2186,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables that map source code positions to typed values, providing operations for insertion, lookup, filtering, and ordered traversal with custom comparators. It supports safe access through optional returns and defaults, with utilities for memoization and type construction tailored to CIL analysis. The child modules define specialized hash tables for associating analysis data with source positions and provide key operations for handling file, line, and column information with project context. Examples include tracking annotations, error locations, or transformation histories tied to specific code spans, enabling precise analysis and transformation in Frama-C plugins.",
      "description_length": 702,
      "index": 2187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure, using a parent directory and a new directory name. It provides `get_dir` and `get_file` operations to retrieve validated directory or file paths within the site, ensuring correct type and existence. It works directly with `Frama_c_kernel.Filepath.t` and string identifiers, serving use cases like organizing plugin-specific resources or managing structured file layouts in static analysis tools.",
      "description_length": 477,
      "index": 2188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for mapping memory zone keys to arbitrary values, supporting efficient insertion, lookup, and in-place modification with ordered traversal. It includes operations for folding, filtering, and converting to sequences, enabling deterministic processing of memory associations. The key module defines a specialized type for addressable memory zones with comparison and hashing primitives, while the value module handles data management for `Data.t` values. Together, they facilitate tasks like memory analysis, caching, and validity tracking in static analysis plugins by ensuring structured, type-safe handling of memory base associations.",
      "description_length": 669,
      "index": 2189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kernel_function_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a hash table for kernel functions with operations for equality, comparison, hashing, and pretty printing. Works with `Datatype.t` values representing kernel functions and project skeletons. Used to store, retrieve, and compare function data during static analysis, such as tracking function properties or analysis results.",
      "description_length": 333,
      "index": 2190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent, ordered-key map implementation with support for insertion, combination, querying, and transformation of key-value pairs. It includes a key module that defines ordered, project-aware key types with comparison, hashing, and pretty-printing capabilities, and a value module that enforces type-specific behavior, equality checks, and deep copying. Together, these enable precise management of hierarchical, project-sensitive data in static analysis scenarios, such as tracking variable mappings or analyzing control flow graphs. Example uses include creating immutable map updates, filtering entries based on project membership, and converting maps to lists for further processing.",
      "description_length": 712,
      "index": 2191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Set",
      "library": "frama-c.kernel",
      "description": "This module implements **ordered, immutable sets** of 64-bit integers with efficient operations for insertion, deletion, union, intersection, and difference, ensuring elements remain sorted and unique. It supports transformations, filtering, and ordered iteration, along with utilities for nearest-neighbor searches, sequence conversions, and project-specific membership checks. Designed for use in static analysis tools, it is particularly suited for tasks requiring precise tracking of integer ranges, dependency resolution, or set-based computations where immutability and ordered traversal are critical.",
      "description_length": 607,
      "index": 2192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and controlling preprocessor extra arguments in Frama-C, specifically handling named categories like `@none`, `@default`, and `@all`. It provides operations to define, modify, and enable categories with custom accessors and dependencies, allowing fine-grained control over how C files are preprocessed. Concrete use cases include setting default preprocessing flags, enabling specific flags for all files, or defining conditional argument groups based on file categories.",
      "description_length": 515,
      "index": 2193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes and manipulates key-value associations where keys represent abstract memory locations or scalar values, and values carry arbitrary data, enabling precise modeling of memory states. It supports ordered traversal, deterministic insertion and deletion, filtering, and transformation, while child modules refine key semantics and provide data-specific operations for static analysis tasks. The key type handles equality, comparison, and hashing for efficient lookups, and the data module adds deep copying, membership checks, and pretty-printing, allowing structured manipulation of abstract states. Examples include tracking variable bindings during verification, managing hierarchical memory regions, and processing ordered sequences of abstract values.",
      "description_length": 773,
      "index": 2194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages plugin-specific configuration directories and files. It provides operations to retrieve or create directories and files within the plugin's user directory, and allows setting or querying the directory path. Use cases include storing and accessing plugin-specific settings or persistent data during analysis sessions.",
      "description_length": 336,
      "index": 2195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Set",
      "library": "frama-c.kernel",
      "description": "This module offers set operations for managing collections of project-related declaration elements, supporting union, intersection, difference, ordered traversal, and predicate-based filtering. It provides utilities for efficient membership checks, extremal element extraction, and conversions to sequences or lists, while enabling transformations like mapping and partitioning. Typical use cases include structured manipulation of declarations for pretty-printing, nearest-element queries, and project-specific value management with ordered traversal guarantees.",
      "description_length": 563,
      "index": 2196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables keyed by CIL l-values with structural equality, enabling efficient storage and retrieval of values through operations like insertion, lookup, and iteration. It supports sequence-based initialization and ordered traversal, making it suitable for static analysis tasks such as caching results for structurally equivalent expressions or tracking relationships between C code elements. A child module defines a key type for hashtables that incorporates project-specific data, offering deep copying, equality, and inspection of embedded project identifiers. Another child module specializes hash tables for arbitrary data types, ensuring structural equality and supporting use cases like managing CIL expressions or statements in analysis plugins.",
      "description_length": 775,
      "index": 2197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_map",
      "library": "frama-c.kernel",
      "description": "This module organizes mappings from kernel functions to arbitrary values, enabling command-line option management with default values, change tracking, and update hooks. It supports direct operations for setting and retrieving function-value associations, along with custom marshaling, option aliasing, and category-based configuration. The child modules enhance this functionality by adding string-based parameter handling with validation, a data type for function mappings with equality and comparison, and category management for grouping options. Together, they allow defining and manipulating function-specific settings, such as analysis parameters or command-line flags tied to function declarations, with full support for serialization, dynamic updates, and user interface integration.",
      "description_length": 792,
      "index": 2198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a functional map structure for key-value pairs where keys are CIL offsets, supporting operations like insertion, deletion, merging, and value transformation, along with ordered traversal and filtering. The key module defines the offset-based key type with equality, comparison, hashing, and pretty-printing, enabling precise management of project-specific data and deep copying, useful for tracking and comparing field positions in C structures. The value module pairs these keys with arbitrary data types, supporting similar operations and facilitating tasks like static analysis of memory layouts or transformation of C code structures. Together, they enable concrete use cases such as analyzing struct field alignments or managing offset-based metadata in compiler plugins.",
      "description_length": 797,
      "index": 2199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes logic information using a key-value structure, where keys support equality, comparison, hashing, and pretty-printing for use in associative containers. It manages mappings of logic data through a specialized map implementation that allows tracking and manipulation of logical properties across program analyses. Operations include inserting, looking up, and transforming entries, with support for deep copying and project membership checks on keys. Example uses include maintaining annotated state at different program points or aggregating analysis results keyed by logic expressions.",
      "description_length": 607,
      "index": 2200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing `iter`, `map`, and `fold_left` to sequence monadic actions over list elements. It works with lists and monadic values parameterized by `'a` and `'b`. Use it to traverse lists with effects, transform elements using monadic functions, or accumulate results in a monadic context.",
      "description_length": 334,
      "index": 2201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` for keys used in a state map, along with operations for equality, comparison, hashing, and pretty printing. It supports working with project-compliant mutable values, providing deep copy functionality and introspection through descriptors and representants. Concrete use cases include managing and querying state keys in Frama-C plugins, ensuring unique identification and proper handling of state elements across different project contexts.",
      "description_length": 477,
      "index": 2202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for chaining stateful computations in the State monad. It provides bind and map operations through familiar syntax, enabling concise composition of functions that manipulate a shared state. These operators are used to sequence stateful actions and transform their results in a purely functional context.",
      "description_length": 339,
      "index": 2203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing sets of bit-level memory location descriptors, supporting creation, modification, and querying through standard set algebra (union, intersection, difference), ordered traversal, and conversion to structured representations like lists. It works with elements representing base-offset pairs in bits, enabling precise modeling of memory regions for static analysis tasks such as pointer aliasing detection and memory safety verification in Frama-C's analysis framework.",
      "description_length": 509,
      "index": 2204,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_ref.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype instance from a polymorphic type, providing standard operations like equality, comparison, hashing, and pretty printing. It works with types that conform to the `T` module's structure, supporting deep copies and project-aware membership checks. Concrete use cases include defining and manipulating typed references in static analysis plugins, such as tracking variable states or abstract values across program points.",
      "description_length": 460,
      "index": 2205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation for mapping `Term_offset.t` keys to polymorphic values, supporting creation, insertion, lookup, and ordered traversal with customizable comparison. It includes utilities like `find_opt`, `find_def`, and memoization functions to efficiently cache computation results tied to term offsets. The child modules specialize this functionality: one focuses on structured data management with `Data.t` values, offering deep copying and project membership checks, while the other defines the `Term_offset` key operations necessary for correct hash table behavior. Together, they enable precise tracking and analysis of term offset data in static analysis plugins, such as associating memory values with specific program terms or persisting analysis results.",
      "description_length": 796,
      "index": 2206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for managing CIL expressions using `eid`-based structural equality, supporting key-value associations, in-place updates, and iteration over expression-centric data. It includes a child module that specializes hash tables for specific CIL expression types with standard operations and another that defines hash keys based on expression structure and project identity. Together, they enable efficient tracking of expression occurrences, memoization of analysis results, and ordered processing of expression data in Frama-C pipelines. Use these modules to build caches, detect duplicates, or index expressions by structure or project context.",
      "description_length": 683,
      "index": 2207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter`, `map`, and `fold_left`, where each function applies a monadic effect to elements of a list. It operates on lists of values within a monadic context, enabling sequential composition of effects across list elements. Concrete use cases include processing lists of computations that each return a monadic result, such as parsing or analysis steps that carry state or potential failure.",
      "description_length": 463,
      "index": 2208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables keyed on logic types with support for insertion, lookup, and in-place filtering, along with ordered traversal and memoization tailored for deterministic processing of CIL structures. It provides utilities for converting between hash tables and sequences, enabling efficient static analysis workflows in Frama-C plugins. The first child module specializes the hash table for a given `Data` module, adding equality, comparison, and pretty-printing for concrete logic type values, while supporting deep copies and project-aware membership checks for structured data handling. The second child module defines a key type with logic type-based equality, comparison, and hashing, optimized for symbolic expressions and project-based filtering in static analysis tasks.",
      "description_length": 796,
      "index": 2209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations on CIL constants (`Frama_c_kernel.Cil_datatype.Constant.t`), supporting union, intersection, difference, and transformations like mapping, filtering, and folding with efficient membership checks. It maintains elements in sorted order, enabling range-based queries, nearest-neighbor searches, and conversions to sequences or lists, while providing structural comparison, hashing, and pretty-printing. It is particularly useful in static analysis for tracking and manipulating sets of constants during CIL code transformations or value-flow analysis.",
      "description_length": 590,
      "index": 2210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Version.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for version-related data structures. It supports deep copying, membership testing within projects, and provides descriptors for type and structural representation. Concrete use cases include managing and comparing version identifiers in Frama-C's kernel and plugins, ensuring consistency during analysis or serialization tasks.",
      "description_length": 457,
      "index": 2211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides mutable hash tables for logic symbols using structural equality, with keys that uniquely identify symbols by name and type while ignoring polymorphic variables. It supports imperative operations like insertion, lookup, and in-place filtering, along with ordered traversal and sequence-based initialization, making it suitable for memoization and tracking symbols across translation units. The child modules specialize the hash table for `Data` values and define structural keys with utilities for comparison, hashing, and pretty printing. Together, they enable managing structural comparisons in type-sensitive analyses, such as verifying or transforming programs based on logic function definitions.",
      "description_length": 721,
      "index": 2212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Set",
      "library": "frama-c.kernel",
      "description": "This module implements set algebra and manipulation operations for boolean values, supporting union, intersection, difference, and membership checks with both exception-safe and option-based accessors. It operates on ordered collections of elements from a boolean datatype, offering transformations via mapping, filtering, and folding, along with conversions to sequences and lists. Designed for applications requiring precise boolean state tracking, such as static analysis or formal verification tasks, it integrates ordering guarantees and type introspection utilities for robust data handling.",
      "description_length": 597,
      "index": 2213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps where keys are based on integer sets, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with non-empty small integer sets and handles conversions to intervals when cardinality exceeds a threshold. Concrete use cases include managing sets of integers in static analysis contexts, such as tracking program variable ranges or control flow paths.",
      "description_length": 439,
      "index": 2214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to the option type, providing `iter` and `map` to sequence operations over `option` values within a monadic context. It handles computations where values may be absent, integrating them with monadic effects like state or error handling. Use cases include safely processing optional data in stateful or effectful computations, such as parsing or validation pipelines.",
      "description_length": 404,
      "index": 2215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Model_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating abstract data types within the context of computing AST differences. It provides equality, comparison, hashing, and pretty-printing functions, along with utilities for deep copying and checking project membership. The type `t` is used to capture structural information needed for diff computation, particularly handling cases where standard hashtables are unsuitable due to custom rehashing requirements.",
      "description_length": 485,
      "index": 2216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing operations to iterate, map, and fold over list elements within a monadic context. It works with lists of values and monadic functions that return values wrapped in a combined monad structure. Concrete use cases include processing sequences of stateful or fallible computations, such as parsing or validating a list of inputs where each step may modify shared state or fail.",
      "description_length": 431,
      "index": 2217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between logic constants and arbitrary values, providing standard map operations like insertion, lookup, and traversal, along with utilities for ordered iteration, conditional updates, and sequence conversions. It supports key comparison, hashing, and pretty-printing, with specialized functions for project-aware membership checks and deep copying, enabling robust handling of logic constant mappings across different analysis contexts. Submodules define key behaviors and data-specific operations, allowing precise manipulation of logic constant identifiers and their associated data in static analysis plugins. Example uses include tracking variable bindings, merging analysis states, and transforming logic constant environments during CIL code processing.",
      "description_length": 792,
      "index": 2218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.False",
      "library": "frama-c.kernel",
      "description": "This module manages boolean command-line options for Frama-c plugins, enabling configuration of analysis behaviors through on/off flags. It supports state tracking, aliases, serialization, and integration with the Frama-C kernel's parameter system. The child module implements a false-state option with operations like equality, comparison, and pretty-printing, used to represent disabled features. Together, they allow defining, manipulating, and persisting boolean flags that control plugin functionality, such as toggling analysis checks.",
      "description_length": 541,
      "index": 2219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This set interface provides structural equality and strict constant comparison operations for CIL l-values, supporting standard set manipulations like union, intersection, and element queries. It works with sets of l-values from the C Intermediate Language, enabling efficient iteration, transformation, and conversion to sequences or lists. The module is particularly useful in static analysis tasks requiring precise structural comparisons of program data, such as tracking memory states or analyzing pointer aliasing.",
      "description_length": 520,
      "index": 2220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.DoCollapseCallCast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing values that represent the behavior of the `-collapse-call-cast` option in Frama-C's kernel. It supports equality, comparison, hashing, pretty-printing, and deep copying, and allows checking membership based on project-related predicates. The type is used internally to control how call and cast operations are handled during CIL transformation, specifically whether to allow implicit casts at call sites.",
      "description_length": 464,
      "index": 2221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered immutable sets of native integers with efficient membership testing, ordered traversal, and standard set operations like union/intersection. It supports transformations through mapping and filtering, conversions to/from sequences/lists, and nearest-value queries, while maintaining compatibility with Frama-C's static analysis infrastructure through project membership and deep copy utilities. The ordered structure enables predictable iteration and optimized operations for use cases like value range tracking or dependency resolution in program analysis tasks.",
      "description_length": 593,
      "index": 2222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AbsoluteValidRange.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing absolute valid ranges. It supports deep copying, membership testing within projects, and provides descriptors for type and structure representation. Concrete use cases include managing and comparing value ranges in static analysis, ensuring accurate project-specific validations and efficient data manipulation during analysis phases.",
      "description_length": 481,
      "index": 2223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping `Term_lval.t` keys to arbitrary values, supporting insertion, lookup, iteration, ordered folding, memoization, and sequence-based updates. It provides standard operations like `add`, `find`, `iter`, and `fold`, with customizable key comparisons for deterministic traversal and compatibility with OCaml's standard library. The key module defines `Term_lval` equality, comparison, and hashing functions, enabling precise key handling in static analysis plugins for tasks like tracking memory locations or symbolic expressions. A specialized hash table module for `Term_lval` values builds on this, offering efficient storage and lookup for CIL l-values in dataflow or points-to analyses.",
      "description_length": 728,
      "index": 2224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hptset",
      "library": "frama-c.kernel",
      "description": "This module manages heterogeneous persistent sets of CIL statements with cache-aware merging and structural equivalence replacement, supporting efficient set operations crucial for static analysis and plugin-driven optimizations. It provides functional set and map interfaces for statement grouping, transformation, and data association, with imperative hash tables for context-sensitive analysis and type-aware comparisons. Submodules enable hierarchical set traversal, keyed data mapping, and imperative storage of statement-related analysis results, such as control flow tracking and property propagation. Specific uses include data flow analysis, annotation of CIL statements, and structured transformation across Frama-C plugins.",
      "description_length": 734,
      "index": 2225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_queue.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic queue datatype from a polymorphic queue type, providing standard operations such as equality, comparison, hashing, and pretty printing. It works with elements of type `T.t` wrapped in a polymorphic queue structure, supporting deep copying, membership checks over project skeletons, and type-level introspection via a unique name and descriptor. Concrete use cases include managing analysis states or value sets in static analysis plugins where queue semantics and deep equality are required.",
      "description_length": 525,
      "index": 2226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes hierarchical model data using maps keyed by `Model_info` structures, supporting efficient insertion, traversal, and transformation with both single and list-valued bindings. It offers precise lookups via predicates, structural operations like `split` and `equal`, and bulk conversions to and from sequences, enabling workflows such as aggregating analysis results or transforming CIL representations. The child modules refine this functionality by defining key semantics and value policies, ensuring project-aware comparisons, deep copies, and structured pretty printing. Together, they support static analysis plugins that track and manipulate model-specific data with strict key ordering and integrity.",
      "description_length": 726,
      "index": 2227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for handling extra command-line arguments passed to the C preprocessor, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with lists of command-line arguments and includes utilities for deep copying and checking project membership. Concrete use cases include managing and manipulating preprocessor arguments during analysis configuration and ensuring consistent handling of command-line options across different parts of the kernel.",
      "description_length": 509,
      "index": 2228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for enumeration items, supporting standard manipulations like union, intersection, and difference, as well as transformations via mapping and filtering. It works with sets of enumeration elements, enabling efficient membership tests, ordered traversal, and conversions to sequences or lists. Use cases include static analysis tasks requiring precise handling of enumerated constants, such as tracking possible values in program variables or analyzing switch statement coverage.",
      "description_length": 521,
      "index": 2229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing abstract values used in command-line option autocompletion. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with introspection via descriptors and representants. It is used to manage and query structured data types during the processing of Frama-C command-line arguments, particularly for the `-autocomplete` feature.",
      "description_length": 426,
      "index": 2230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a sorted set structure for rational numbers, enabling operations like union, intersection, ordered traversal, and efficient membership testing. It supports transformations through filtering, mapping, and partitioning, alongside conversions to sequences and lists for bulk processing. These features are particularly useful in static analysis contexts requiring precise manipulation of rational number sets, such as computing program invariants or symbolic constraint propagation.",
      "description_length": 502,
      "index": 2231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutoLoadPlugins.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating abstract data structures used in plugin management. It supports operations for comparing, hashing, and pretty-printing these structures, as well as checking membership based on project properties and performing deep copies. It is used to manage and reason about plugin data representations in a type-safe and structured way.",
      "description_length": 390,
      "index": 2232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module organizes command-line configurations that associate file paths with arbitrary values, enabling per-file settings for analysis or source code processing. It provides a typed map over file paths with mutation, iteration, and change tracking, while supporting custom marshaling for persistence. Child modules handle string-based parameters with validation and file path operations, enabling use cases like enforcing valid C identifiers or managing file-specific analysis rules. Together, they unify file path handling, parameter validation, and category-based option grouping for structured command-line configuration.",
      "description_length": 628,
      "index": 2233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered functional maps keyed by `Term_offset` values, supporting construction, modification, and traversal operations such as insertion, filtering, folding, and ordered iteration. It works with polymorphic key-value pairs where keys represent structured offsets in CIL's term representation, enabling efficient lookups, merges, and transformations while preserving key ordering. The module includes a specialized child module for maps with `Data`-typed values, offering standard operations like lookup, insertion, and iteration alongside equality, comparison, and hashing for the maps themselves. Another child module defines the `Term_offset` key type with support for equality, comparison, hashing, and pretty-printing, facilitating precise manipulation of term-based identifiers and tracking memory layout information in static analysis plugins.",
      "description_length": 872,
      "index": 2234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a user directory option for a plugin, allowing the directory path to be set, retrieved, and queried. It provides functions to access files and subdirectories within the user-specified path, with optional path creation. It works directly with `Frama_c_kernel.Filepath.t` and is used to handle plugin-specific configuration or resource directories.",
      "description_length": 378,
      "index": 2235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables that map CIL global annotations to arbitrary values, supporting imperative updates, functional transformations, and ordered traversal. It enables efficient storage, retrieval, and manipulation of annotated data through operations like insertion, deletion, folding, and safe lookups, with utilities for sequence-based updates and project-aware membership checks. The associated key module ensures precise and efficient handling of annotation identifiers, while the data module offers standard operations for annotated values, including equality, comparison, and deep copying. Together, they facilitate tasks such as tracking function annotations across analysis phases or managing metadata in static analysis plugins.",
      "description_length": 749,
      "index": 2236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RightShiftNegative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for handling the behavior of right-shifting negative integers, specifically in the context of the `-warn-right-shift-negative` option. It provides equality, comparison, hashing, pretty-printing, deep copying, and project membership checks for values of this type. The module is used to represent and manipulate the possible states or configurations related to this warning behavior within Frama-C's kernel.",
      "description_length": 464,
      "index": 2237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages associations between logic constructor metadata and values, using specialized keys and tables to support efficient lookups, ordered traversal, and value memoization. The key module provides equality, comparison, and hashing for `Logic_ctor_info.t`, enabling precise table operations and project-aware membership checks, while the value module handles structured data such as logic function symbols with structural preservation. Together, they facilitate tasks like caching analysis results or tracking constructor properties during CIL processing. Specific operations include creating and iterating over tables with sorted keys, safely retrieving values by key, and deep copying entries for use across analysis phases.",
      "description_length": 738,
      "index": 2238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fieldinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing structured data in the context of computing project diffs. It provides equality, comparison, hashing, and pretty-printing functions for values of this type, along with utilities for project membership checks and deep copying. Use cases include tracking and analyzing changes in structured data across different versions of a project.",
      "description_length": 411,
      "index": 2239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Typeinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` and operations for comparing, hashing, and pretty-printing values of that type, ensuring deep equality and consistent ordering. It provides utilities to inspect and manipulate structured data with support for project-specific filtering via `mem_project`, and guarantees non-sharing deep copies. Concrete use cases include tracking and diffing structured AST elements across different project versions, where precise equality and memory management are critical.",
      "description_length": 503,
      "index": 2240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements state builders for integer-indexed hash tables with support for equality, comparison, hashing, and pretty-printing operations. Works with `Datatype.t` values, providing deep copies and project-aware membership checks. Useful for managing and manipulating state in static analysis plugins where integer keys map to structured data.",
      "description_length": 341,
      "index": 2241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line module loading, supporting operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and `State.t` lists, using accessors to interpret category behavior during module loading. Concrete use cases include setting the default category for loaded modules and enabling the `@all` category with specific interpretations for dependency handling.",
      "description_length": 458,
      "index": 2242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module supports operations for creating, modifying, and querying ordered sets with functional persistence, enabling efficient unions, intersections, element removal, and structural queries like subset checks or nearest-neighbor searches. It operates on a parameterized `Set.t` structure with elements of type `Set.elt`, interacts with sequences (`Stdlib.Seq.t`) for bulk conversions, and integrates with Frama-C's internal representations (`Type.t`, `Project_skeleton.t`) for deep copying and projection-based membership tests. It is particularly suited for static analysis plugins requiring ordered set manipulations, iterative transformations, or integration with Frama-C's core data models.",
      "description_length": 698,
      "index": 2243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements forward dataflow analysis on control flow graphs with unnaturally loop-structured transitions, computing abstract values at each node using a provided abstract domain. It processes unrolled automata where unnatural loops are normalized to ensure correct fixpoint computation. Useful for static analysis tasks like interval analysis or liveness detection where loop heads must be revisited until convergence.",
      "description_length": 418,
      "index": 2244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Float",
      "library": "frama-c.kernel",
      "description": "This module manages floating-point parameters for plugins, supporting value registration, retrieval, and constraint enforcement such as min/max bounds. It integrates with OCaml's `float` type and includes operations for defining update hooks, aliases, and persistent state, enabling precise configuration of numerical options in static analysis tools. The child module extends this functionality by providing standard operations like equality, comparison, and pretty printing, along with structured parsing of decimal inputs. Together, they allow defining, validating, and manipulating numeric plugin parameters with both precision and flexibility.",
      "description_length": 648,
      "index": 2245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for string elements, including set algebra (union, intersection, difference), membership checks, ordered iteration, and transformations like mapping or filtering. It works with sets of `Frama_c_kernel.Datatype.String.t` values, supporting conversions to/from lists/sequences and providing ordered traversal guarantees. It is particularly useful in static analysis plugins for managing collections of strings with predictable ordering, such as tracking identifiers or symbolic values during program analysis.",
      "description_length": 549,
      "index": 2246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String",
      "library": "frama-c.kernel",
      "description": "This module manages string-based plugin parameters with support for validation, CLI integration, and serialization control. It enables defining string options with constraints, aliases, and update hooks, while its child module provides core operations like comparison, hashing, and pretty-printing for registered string types. Users can create configurable string parameters, enforce allowed values, and persist state across analysis sessions. Examples include tracking string literals in C code, managing plugin-specific identifiers, and synchronizing string options with command-line arguments.",
      "description_length": 596,
      "index": 2247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store integer value abstractions. It provides standard operations including equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copying. It works directly with `Frama_c_kernel.Int_val.Hashtbl.key` values, which represent keys in a hashtable mapping to integer value abstractions.",
      "description_length": 397,
      "index": 2248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes CIL enumeration items into ordered maps, enabling efficient key-based access and structured transformations while preserving key ordering. It provides core operations like insertion, deletion, merging, and traversal, along with utilities to convert maps to ordered sequences and perform filtering or structural queries. The module supports working with keys derived from CIL enum items and manages mappings to arbitrary data, such as tracking enum constant definitions or associating metadata with each enum value during static analysis. Submodules handle key definitions and type-specific map implementations, ensuring type safety and deep integration with CIL-based workflows.",
      "description_length": 700,
      "index": 2249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, supporting operations like equality, comparison, hashing, and pretty-printing. It works with hash tables mapping keys to values of type `Data.t`, and provides deep copying, project membership checks, and type descriptors for integration with Frama-C's plugin system. Concrete use cases include managing per-project settings or caching computed values associated with analysis projects.",
      "description_length": 472,
      "index": 2250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes heterogeneous maps keyed by `Term_lhost` values, enabling ordered storage, transformation, and traversal of data indexed by program terms. It supports core operations like insertion, deletion, filtering, and folding, alongside structural queries such as `split` and `partition`, while allowing custom pretty-printing for debugging. Child modules refine this structure by fixing value types and enhancing key behavior with comparison, hashing, and deep-copying capabilities. Examples include tracking term-associated metadata in static analysis or organizing analysis results for efficient lookup and transformation in Frama-C plugins.",
      "description_length": 656,
      "index": 2251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module manages lists of file paths for Frama-C plugins, supporting dynamic modification, iteration, and composition with integration into command-line options and project state. It provides core operations for list manipulation alongside submodules that handle string-based configuration with validation, category-based parameter organization, and a specialized file path list type with comparison and serialization. Use cases include configuring plugins with file inputs, managing source dependencies, and defining structured command-line parameters with custom validation and state tracking.",
      "description_length": 598,
      "index": 2252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between structured CIL locations and arbitrary data, supporting operations like insertion, deletion, merging, and ordered traversal. It provides utilities for converting maps to sequences and formatting their contents, enabling tasks like error tracking and metadata reporting during static analysis. The key module handles equality, comparison, and pretty-printing of location-based keys, including those with embedded project data, while the map module implements standard map operations for location-indexed data. Together, they support use cases such as cross-project analysis and per-location annotation tracking with robust comparison and transformation capabilities.",
      "description_length": 706,
      "index": 2253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Map",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-aware map operations that combine and transform key-value associations, supporting standard manipulations like `add`, `remove`, and `update` alongside lattice-specific combinators such as `merge` and `union`. It operates on polymorphic maps with ordered keys and arbitrary value types, enabling ordered traversal, filtering, partitioning, and conversions to lists or sequences, which are particularly useful for static analysis tasks requiring aggregation of value sets across keys or deterministic processing of bindings in key order. One submodule represents maps where each value has a lattice structure, supporting equality, comparison, hashing, and pretty-printing on these maps, enabling analysis of program states where keys represent variables and values track abstract lattice properties such as intervals or sets. Another submodule defines key types and operations for a map lattice that combines maps and sets with lattice structures, providing utilities for deep copying, membership checks, and structural consistency in lattice-based dataflow computations.",
      "description_length": 1098,
      "index": 2254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameter collections, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with types like `elt`, `t`, and `State.t` lists, using accessors to bind categories to parameter behaviors. Concrete use cases include configuring how command-line options are grouped and interpreted, such as setting default behavior or enabling all parameters under a specific interpretation.",
      "description_length": 485,
      "index": 2255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between syntactic scopes in CIL and arbitrary values, enabling operations like insertion, lookup, ordered traversal, and merging. It supports advanced transformations such as predicate-based filtering and structural decomposition, with utilities for reverse traversal and sequence-driven construction. The module's key type represents structural contexts like functions or blocks, and it includes standard operations for key comparison, hashing, and pretty printing, while the value-specific submodules provide typed map functionality including equality checks, deep copying, and membership tests. It is particularly effective in static analysis for tracking hierarchical data such as variable bindings, control flow relationships, or annotated AST transformations across different scopes.",
      "description_length": 822,
      "index": 2256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes memory zones as keys in a map structure, enabling type-safe associations between zones and arbitrary data. It supports core operations like insertion, lookup, and iteration, while its submodules provide specialized key handling and value management. You can use it to track memory state during analysis, associate bindings with regions, or build zone-based summaries. The combined interface allows comparing, copying, and querying zone-indexed data efficiently.",
      "description_length": 483,
      "index": 2257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a suite of operations for managing immutable sets of localizable printer tags, including standard set operations (union, intersection, filtering), ordered traversal, and transformations via mapping or folding. It works with sets of `Localizable.t` elements, which represent regions in source code annotated with location information, and provides utilities for querying elements relative to positions, converting between lists/sequences, and safely searching with predicates. These capabilities are particularly useful in source code pretty-printing workflows, where precise manipulation of tagged AST regions is required for tasks like filtering subsets, aggregating metadata, or generating structured output.",
      "description_length": 729,
      "index": 2258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.ReadAnnot.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling annotation data during parsing. It supports introspection through descriptors and representants, and provides deep copying and project membership checks. Concrete use cases include managing and comparing structured annotation values read from source files, ensuring correct data representation and efficient lookups during static analysis.",
      "description_length": 482,
      "index": 2259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a suite of set operations for managing and transforming collections of control flow edges, including union, intersection, difference, and ordered traversal, alongside utilities for membership checks, filtering, and conversion to lists or sequences. It operates on sets of edges that model transitions with guards and actions in a control flow graph, facilitating tasks like abstract interpretation, reachable state computation, and program behavior analysis. Additional capabilities, such as reverse iteration and deep copying, support advanced manipulation of edge sets during static analysis.",
      "description_length": 615,
      "index": 2260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for chaining computations that produce values within a monadic context, supporting both binding and mapping operations. It works with monadic types that implement the minimal interface of `map` and `product`. These operators are used to sequence analysis steps in static analysis plugins, where each step may depend on the result of previous computations, such as propagating program state or handling optional or error-prone operations.",
      "description_length": 475,
      "index": 2261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-based command-line parameters in Frama-C's kernel, focusing on configuration options that accept validated string values with support for aliases, persistence, and stateful operations. It defines a core data type for string parameters with operations including validation against predefined lists, enforcement of C-style function name syntax, and raw string handling, along with equality, comparison, hashing, and pretty-printing functions. Submodules extend this functionality to manage load-module options, enabling deep copying, project membership testing, and manipulation of values passed via arguments like `-load-module`. Examples include defining configurable module-loading behaviors, validating user-provided identifiers, and serializing string-based settings across analysis sessions.",
      "description_length": 846,
      "index": 2262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by integer sets, where each key maps to a value of the provided `Data` module type. It supports operations like equality, comparison, hashing, and pretty-printing for maps, along with deep copying and checking presence of project values via a predicate. It is used to manage mappings from integer sets to arbitrary data, particularly in static analysis contexts where set-based keys represent abstract states or constraints.",
      "description_length": 459,
      "index": 2263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Quiet.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with support for deep copying and project membership checks. It works with lists of `t` values and integrates with project descriptors for structural inspection. Concrete use cases include managing and comparing abstract data values within Frama-C's kernel, particularly during analysis state manipulation and project transformations.",
      "description_length": 448,
      "index": 2264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_ctor_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in logic constructor environments. It supports structured values with deep copying, project membership checks, and descriptors for type representation. Concrete use cases include managing logic type representations in static analysis plugins, where precise type identity and traversal are required.",
      "description_length": 418,
      "index": 2265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a type-safe hash table implementation for normalized filepaths, enabling efficient storage and retrieval of arbitrary data while ensuring deterministic iteration and ordered traversal. It combines a specialized key module for filepath equality, comparison, and hashing with a generic table module that supports operations like lookup, insertion, deep copying, and project membership checks. The key module allows for precise manipulation of filepath keys in persistent contexts, while the table module facilitates caching file metadata, analysis results, or configuration settings across different projects. Example uses include tracking per-file analysis states and managing plugin-specific data indexed by file in Frama-C.",
      "description_length": 745,
      "index": 2266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables optimized for logic constants in CIL, offering insertion, lookup, sorted iteration, and in-place filtering with customizable key ordering. It directly supports structured key-value associations using `Frama_c_kernel.Cil_datatype.Logic_constant.t` keys and arbitrary data values, enabling efficient memoization and transformation of logic constant mappings in static analysis plugins. The key submodule ensures correct handling of equality, comparison, and hashing for logic constants, while the data submodule provides a fully featured hash table type with deep copy and project-aware operations. Example uses include tracking symbolic values during analysis and maintaining ordered, project-specific logic constant environments.",
      "description_length": 775,
      "index": 2267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating collections of files within the analysis framework. It provides operations for equality checks, comparison, hashing, and pretty-printing file data, along with deep copying and project membership testing. Concrete use cases include managing file sets during static analysis and querying project-specific file properties.",
      "description_length": 385,
      "index": 2268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.String",
      "library": "frama-c.kernel",
      "description": "This module provides operations to retrieve, set, and manage string parameters in a loaded Frama-C plugin. It supports checking whether a parameter has been set or is using its default value, as well as clearing the parameter state. These functions operate directly on string identifiers for parameter names, enabling configuration and runtime adjustments of plugin behavior.",
      "description_length": 375,
      "index": 2269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with keys based on CIL expressions, using structural equality and strict constant comparison to ensure precise key handling for static analysis. It supports standard operations like insertion, deletion, merging, and ordered traversal, along with bulk conversions to and from sequences and customizable pretty-printing for deterministic processing. The key module provides `equal`, `compare`, `hash`, and `pretty` functions, enabling accurate structural identity checks and deep copying, while the data module allows associating arbitrary values with these keys. Examples include tracking expression-based mappings during CIL AST transformations or managing analysis state with exact value correspondence.",
      "description_length": 729,
      "index": 2270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "This module provides two key operations, `narrow` and `narrow_reinterpret`, which compute over-approximated intersections of interval-value maps. These functions operate on the abstract type `t`, which represents mappings from intervals to values, and require both inputs to cover the same range. The `narrow` function treats values without bitwise reinterpretation, potentially leading to unsound results, while `narrow_reinterpret` ensures normal forms by reinterpreting values bit-by-bit, making it the preferred choice for accurate intersection computation.",
      "description_length": 561,
      "index": 2271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.BigIntsHex.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling arbitrary-precision integers in hexadecimal representation. It provides equality, comparison, hashing, pretty-printing, deep copying, and project membership checks for values containing project skeletons. These functions support analysis plugins that need to manipulate or track hexadecimal big integers within Frama-C's kernel.",
      "description_length": 403,
      "index": 2272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements standard set operations like union, intersection, and difference, alongside element manipulation functions (add, remove, find) that return `option` types for safe empty-set handling. It operates on ordered sets (`Set.t`) with elements of type `elt`, supporting functional transformations (map, filter, partition), ordered iteration, and conversions to/from lists and sequences. Use cases include scenarios requiring precise membership checks, ordered traversal, nearest-element queries, and type-safe set manipulations with projections or deep copying, particularly in static analysis contexts where ordered collections and error-resilient operations are critical.",
      "description_length": 687,
      "index": 2273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for managing mappings with keys representing CIL types compared structurally by name without unrolling. It supports imperative manipulation via `add`, `find`, and `remove`, along with ordered iteration and memoization using custom comparisons, enabling efficient caching and aggregation of type-based data in static analysis. The child modules define a key type and a fully functional hash table implementation, offering equality, comparison, hashing, and pretty printing for CIL types, along with deep copying and project-aware membership checks. Specific use cases include tracking type-specific annotations, analysis results, or metadata across translation units with deterministic traversal and type-based equivalence.",
      "description_length": 765,
      "index": 2274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identifies properties in the Frama-C kernel. It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, along with deep copying and project membership checks. It is used to manage and manipulate property-based data in Frama-C's analysis plugins.",
      "description_length": 344,
      "index": 2275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables optimized for boolean keys and values, supporting efficient creation, insertion, lookup, and iteration with advanced operations like ordered folding and bulk updates. It operates on polymorphic tables (`'a t`) with keys constrained to boolean types, enabling efficient tracking of boolean-state mappings in program analysis or caching logical expressions. Child modules extend this functionality by implementing boolean-valued mappings with custom key types and providing key management operations, including project-aware membership checks and deep copying. Together, they enable use cases such as tracking sets of data elements under boolean conditions, managing state in static analysis plugins, and handling project-specific boolean associations with identity-sensitive keys.",
      "description_length": 823,
      "index": 2276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps keyed by CIL labels with polymorphic values, supporting insertion, deletion, ordered traversal, merging, and extremal key operations. It includes utilities for key-based transformations, filtering, and sequence conversions, optimized for static analysis tasks like tracking label-associated metadata in C code. The child module introduces a concrete map type with support for standard operations such as equality, comparison, hashing, and pretty-printing, enabling efficient management of label-indexed data in CIL-based analyses. Another child module provides key-specific operations including comparison, hashing, and project-aware membership checks, facilitating deep copies and key manipulation within map structures.",
      "description_length": 757,
      "index": 2277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for manipulating collections of CIL left-values (Lval.t), including union, intersection, difference, predicate-based filtering, and ordered traversal. It supports efficient transformations, structural queries, and conversions to sequences/lists while preserving element ordering, with specialized functions for nearest-element searches and deep-copying. These capabilities are particularly useful in static analysis tasks requiring precise tracking of memory locations or variable assignments in C code.",
      "description_length": 547,
      "index": 2278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadState.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing structured values related to project states during loading. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership checks over project skeletons. These capabilities support precise handling of loaded state representations in kernel extensions and plugins.",
      "description_length": 402,
      "index": 2279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.WithOutput",
      "library": "frama-c.kernel",
      "description": "This module manages boolean configuration options and controls output behavior for plugins, offering stateful interactions with boolean values through project lifecycle events, dependency tracking, and customizable serialization. It includes a registered datatype with operations for equality, comparison, hashing, and pretty-printing, designed for structured data representation in Frama-C plugins. Users can define custom analysis structures, control logging output dynamically based on plugin state, and ensure consistent data handling across project sessions. The combination enables precise data manipulation, conditional output suppression, and seamless integration with Frama-C's plugin system.",
      "description_length": 701,
      "index": 2280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintVersion.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating version information in the context of the `-print-version` command-line option. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over project data. The type `t` is used to encapsulate version-related data, supporting inspection and serialization through `reprs`, `descr`, and `packed_descr`, with `mem_project` enabling predicate checks on embedded project values.",
      "description_length": 528,
      "index": 2281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered key-value maps with polymorphic values, supporting insertion, deletion, lookup, and ordered transformations like folding and filtering. It integrates key management through a dedicated key module, providing comparison, hashing, and project-aware operations, while a specialized map implementation offers efficient structured collections with deep copying and project membership checks. Use cases include tracking variable associations in static analysis, managing sorted data with ordered aggregations, and converting maps to sequences for iterative processing or visualization. Together, the core module and its submodules enable robust handling of ordered, structured, and project-aware map data.",
      "description_length": 729,
      "index": 2282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins.Plugins_gui",
      "library": "frama-c.kernel",
      "description": "This module manages plugin loading and configuration paths for a GUI environment. It provides access to plugin directories, lists available plugins, and supports loading all plugins or a specific named plugin. Concrete use cases include initializing plugin-based interfaces and dynamically extending application functionality through plugins.",
      "description_length": 342,
      "index": 2283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTOIndex.Table",
      "library": "frama-c.kernel",
      "description": "This module maps vertices of an interpreted automaton to their weak topological order (WTO) indices and provides efficient lookups for loop structure analysis. It uses a hash table to store associations between vertices and their WTO indices, supporting operations to build the mapping from a WTO, check if a vertex is a loop head, and determine if an edge is a back edge. Concrete use cases include analyzing control flow during abstract interpretation to detect loops and manage iteration order for fixpoint computations.",
      "description_length": 523,
      "index": 2284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Set",
      "library": "frama-c.kernel",
      "description": "This module offers set-theoretic operations, ordered traversal, and sequence conversion for managing collections of global CIL annotations. It works with sets containing elements of type `Global_annotation.t`, supporting union, intersection, filtering, mapping, and nearest-element queries, alongside utilities for converting between sets and sequences. These capabilities are particularly useful for static analysis tasks that require aggregating, transforming, or querying annotation metadata across C programs.",
      "description_length": 513,
      "index": 2285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatNormal.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation with a unique name, descriptor, and list of representatives. Concrete use cases include managing and manipulating abstract values in static analysis plugins that require precise floating-point behavior under the `-float-normal` option.",
      "description_length": 457,
      "index": 2286,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides specialized imperative hash tables for logic types in CIL, enabling efficient insertion, lookup, and in-place modification with support for custom key ordering and duplicate handling. It includes a key module defining equality, comparison, and hashing for logic type identifiers, and a data module offering structured storage with deep copying and membership checks. Together, they facilitate precise key-value associations in static analysis workflows, such as tracking logic type relationships during CIL processing. Example uses include memoizing type computations, managing project-specific logic type mappings, and converting hash tables to ordered sequences for deterministic analysis passes.",
      "description_length": 719,
      "index": 2287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for mapping structured, machine-dependent keys to arbitrary values, enabling efficient insertion, deletion, lookup, and ordered traversal. It supports polymorphic hashtables where keys are tied to architecture-specific configurations, and includes submodules for defining specialized key and table types with deep copying, comparison, and membership checking. The first child module creates a hash table specialized for a given data type, supporting operations like equality, hashing, and pretty printing, with use cases in managing machine-dependent data and structured comparisons. The second child module defines a key type for such hashtables, enabling structured keys with project-specific data, deep copying, and membership checks, useful for managing machine-dependent state with strong identity guarantees.",
      "description_length": 847,
      "index": 2288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic composition operators for combining two monads with a defined swap function, enabling seamless chaining of operations across the interior and exterior monads. It supports concrete data types like `'a T.t S.t`, where computations can represent effects such as stateful operations paired with failure handling. These operators are used to define sequential and parallel computations in a structured monadic context.",
      "description_length": 442,
      "index": 2289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.True",
      "library": "frama-c.kernel",
      "description": "This module manages boolean command-line options with support for activation, deactivation, change tracking, and serialization. It defines a boolean type `t` with operations for comparison, hashing, and pretty printing, enabling structured representation of options with unique names and type descriptors. Users can define configurable flags to control analysis behaviors, such as enabling verbose output or toggling experimental features, while ensuring safe value manipulation and project consistency. Submodules enhance this functionality by providing utilities for parsing, displaying, and deep copying these structured parameters.",
      "description_length": 635,
      "index": 2290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.BackwardAnalysis.Result",
      "library": "frama-c.kernel",
      "description": "This module represents the outcome of a backward dataflow analysis over an interpreted automaton, providing access to computed abstract states at various control points. It allows querying states at the function entry, return point, and before or after specific statements, as well as iterating over results in different traversal orders. The module also supports exporting analysis results to DOT format for visualization or storage, using a custom state pretty printer.",
      "description_length": 471,
      "index": 2291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables with support for custom key types and advanced operations such as sorted traversal, memoization, and structural descriptions, centered around the `'a Hashtbl.t` type. It includes a key module defining equality, comparison, and hashing for keys, enabling efficient storage and retrieval of structured or unique identifiers, and a data module implementing hash tables over a specific data type with structural equality, deep copying, and type descriptors. You can create and manipulate hash tables with arbitrary key types, iterate over entries in sorted order, or use memoization to cache function results based on key equality. It is ideal for static analysis plugins needing efficient, structured key-based data storage with customizable ordering and comparison semantics.",
      "description_length": 806,
      "index": 2292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map type specialized for values of a given `Data` module, supporting operations like equality, comparison, hashing, and pretty printing. It works with the `Typed_parameter.Map.t` structure, parameterized by the `Data` module's type. Concrete use cases include managing sets of typed parameters with unique names, ensuring deep copies, and checking project membership via custom predicates.",
      "description_length": 411,
      "index": 2293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a polymorphic hash table structure optimized for static analysis tasks, where keys represent memory zone bases with validity information and support imperative operations like insertion, lookup, and in-place transformation. It enables ordered traversal, bulk processing through folds and filters, and conversion to key-value sequences, with utilities for memoization and default value handling. The first child module defines key operations for memory base addresses, supporting comparison, hashing, and printing to facilitate precise memory region tracking in static analysis plugins. The second child module specializes the hash table for `Data.t` values, offering deep copying, equality checks, and metadata handling to support structured data management across analysis states.",
      "description_length": 802,
      "index": 2294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module provides functional, persistent ordered sets with operations for creation, modification, and set-theoretic operations (union, intersection, difference), along with ordered traversal, filtering, and conversion to/from sequences. It works with elements of type `elt` and structured values like `Set.t`, supporting safe iteration, monotonic predicate-based searches, and deep copying. Designed for scenarios requiring precise ordered collections, such as static analysis plugins managing intervals, symbols, or project-specific data with immutable transformations.",
      "description_length": 573,
      "index": 2295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables mapping structured CIL expressions to arbitrary values, with support for keyed lookups, ordered iteration, and memoization. It ensures structural consistency of keys and efficient table construction, while its child modules specialize hash table datatypes and define key types for CIL expressions with structural equality. Operations include `equal`, `compare`, `hash`, and `pretty`, enabling precise handling of expression-equality mappings in static analysis. Examples include tracking analysis state, caching transformation results, and managing sets of expressions with structural equivalence.",
      "description_length": 630,
      "index": 2296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic and applicative operators for composing computations that may return a value wrapped with a top element in a lattice structure. It provides bind and map operations, along with product constructors, specifically for the `Top.t` type, enabling sequential and parallel combination of lattice-bound computations. These operations are used to manipulate abstract values in static analysis contexts where the top element represents an over-approximation of possible values.",
      "description_length": 495,
      "index": 2297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a state-compliant hash table, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports working with project-compliant mutable values, specifically tailored for use with the `Frama_c_kernel.State.Hashtbl` module. Concrete use cases include managing and querying state keys in static analysis plugins, such as tracking analysis results across different project versions or configurations.",
      "description_length": 474,
      "index": 2298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic4.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype with four type parameters, supporting operations like equality, comparison, hashing, and pretty printing. It works with any four underlying datatypes, producing a composite type that can be deeply copied, compared, and described. Concrete use cases include defining complex structured values for static analysis that combine multiple distinct typed components into a single, manageable unit.",
      "description_length": 434,
      "index": 2299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations where keys are source declaration tags, supporting transformations, filters, and merges while preserving physical equality. It provides operations for bidirectional iteration, bulk updates from sequences, and customizable structural formatting, working with polymorphic maps and sequences. The child modules define key and value types for structured data with project-specific information, supporting equality, comparison, hashing, and pretty printing. Examples include merging annotated AST fragments, tracking declaration metadata during pretty printing, and performing context-aware analysis with precise type and project information.",
      "description_length": 680,
      "index": 2300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of set-theoretic operations for managing collections of syntactic scopes in CIL-based analyses, including union, intersection, difference, and transformations like mapping or filtering. It operates on ordered sets of `Syntactic_scope.t` elements, supporting efficient membership checks, nearest-neighbor queries, and conversions to sequences or lists while preserving structural consistency. These capabilities are particularly useful for static analysis tasks such as tracking nested code scopes, resolving variable visibility, or analyzing control flow hierarchies in C programs.",
      "description_length": 622,
      "index": 2301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Set",
      "library": "frama-c.kernel",
      "description": "This module implements set algebra operations (union, intersection, difference) and immutable manipulations for attribute collections, supporting ordered traversal, filtering, and functional transformations. It operates on sets of attribute elements with integration for project-based membership checks, deep copying, and compatibility with Frama-C's type system. These capabilities are applied in static analysis workflows to manage CIL attribute states, verify code properties, and analyze compiler intermediate representations.",
      "description_length": 530,
      "index": 2302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space.Matrix",
      "library": "frama-c.kernel",
      "description": "This module implements a comprehensive set of matrix operations over a field, including addition, subtraction, multiplication, scalar multiplication, exponentiation, and inversion, with static enforcement of dimension compatibility. It supports concrete data types such as square and rectangular matrices indexed by natural numbers, with functions to construct identity, zero, and shift matrices, as well as access and modify individual elements. It is used to represent and manipulate linear transformations in the computation of linear filter invariants.",
      "description_length": 556,
      "index": 2303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedOverflow.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling unsigned overflow scenarios in Frama-C's kernel. It provides functions for equality checks, comparison, hashing, pretty printing, and deep copying, along with descriptors for type and structural representation. It is used to manage and manipulate values related to unsigned overflow analysis, particularly in the context of static code analysis and project state management.",
      "description_length": 449,
      "index": 2304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_list",
      "library": "frama-c.kernel",
      "description": "This module combines command-line option handling with mutable string list operations to manage ordered collections of strings, supporting actions like addition, iteration, folding, and emptiness checks. It introduces core data types including string lists and categories, enabling structured grouping, visibility control, and default behaviors for command-line parameters. Child modules enhance this functionality by providing deep comparison, serialization, and validation capabilities, along with category-based organization of related options. Use cases include parsing and managing include paths, plugin configurations, and multi-value analysis options in Frama-C.",
      "description_length": 669,
      "index": 2305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing loadable library specifications, including operations for equality, comparison, hashing, and pretty-printing. It works with structured descriptors, project skeletons, and lists of representants to manage library loading behavior. Concrete use cases include checking project membership in library data, deep copying library representations, and formatting them for user output.",
      "description_length": 425,
      "index": 2306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines operator-based combinators for monadic computations built from a bind operation with product support. It provides sequencing operators like `>>-`, `let*`, and `and*` for composing monadic actions, along with their non-monadic counterparts `>>-:`, `let+`, and `and+` for pure transformations. These operators are used to structure and chain effectful computations in a readable, imperative style, particularly when working with custom monads defined using the kernel's monad interface.",
      "description_length": 504,
      "index": 2307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mappings with keys of type `t`, enabling efficient storage and retrieval of values based on keys. It includes core operations such as insertion, lookup, and iteration, while supporting deep copying, membership testing, and structured representation of contents. The child modules extend this functionality by defining key-specific operations and parameterized hash table datatypes, allowing use cases like tracking program states or managing symbolic identifiers in static analysis. Together, they enable precise handling of complex data structures with customizable equality, hashing, and comparison behaviors.",
      "description_length": 658,
      "index": 2308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing values that can be printed using the `-print` option, supporting operations like equality, comparison, hashing, and pretty-printing. It works with structured descriptors and project-based data, enabling deep copying and membership checks over project values. Concrete use cases include managing and comparing intermediate representations of code during static analysis.",
      "description_length": 418,
      "index": 2309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized hash table for keys representing source code annotations, combining imperative and functional operations with ordered traversal and memoization support. It provides key operations like insertion, deletion, and safe lookup alongside bulk transformations using sequences, with child modules defining structured key types and value-handling logic for project-specific data. The key module enables context-aware equality, comparison, and pretty-printing of keys, while the value module adds deep copying, structural introspection, and analysis-friendly comparisons for localized AST elements. Together, they support efficient, typed storage and transformation of annotated source code during static analysis and pretty-printing tasks.",
      "description_length": 767,
      "index": 2310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.E",
      "library": "frama-c.kernel",
      "description": "This module defines operations for constructing and manipulating directed edges in a control flow graph, where each edge is labeled with a transition condition or action from an interpreted automaton. It provides functions to create edges between vertices, retrieve source and destination vertices, and access edge labels, all ordered by a comparison function. It works with vertices representing control points and edges labeled with CIL expressions or instructions to model transitions in program analysis.",
      "description_length": 508,
      "index": 2311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements persistent ordered maps with key-value pairs, where keys are structured values supporting equality, comparison, and pretty printing, and values often enable accumulation. It provides operations for ordered traversal, selective filtering, monadic updates, and sequence-based transformations like merging and splitting, with safe lookups returning optional values. The key module enables deep copying and project membership checks, while the value module supports structured collections with metadata, making the full system ideal for static analysis tasks requiring ordered aggregation, predicate-driven partitioning, or hierarchical key-value output. Example uses include tracking analysis results per function, comparing and manipulating map keys independently, and merging structured data with custom formatting.",
      "description_length": 837,
      "index": 2312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralDebug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation and introspection, primarily used for debugging and analysis within the kernel. Concrete use cases include tracking and comparing internal state values, validating project containment in data structures, and generating readable output for diagnostics.",
      "description_length": 473,
      "index": 2313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint.Map",
      "library": "frama-c.kernel",
      "description": "This module implements immutable maps with native integer keys, offering ordered insertion, deletion, and traversal while preserving key order during transformations like map and filter. It provides core operations for lookup, update, merging, and conversion to sequences or lists, along with functions to retrieve minimum and maximum bindings or perform conditional searches. The first child module specializes the map for a given `Data` module's values, adding type-safe equality, comparison, and pretty-printing, enabling structured manipulation of native integer-indexed collections in domains like static analysis. The second child module defines key types with nativeint values, supporting precise key management through comparison, hashing, and structured printing, ideal for handling unique identifiers or configuration data in typed map contexts.",
      "description_length": 855,
      "index": 2314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module manages collections of CIL function declarations within a Frama-C plugin environment, supporting modification, change tracking via hooks, and integration with project state and command-line interfaces. It works with `Fundec.Set.t` structures and includes utilities for string representation, categorization, and semantic handling of function sets, enabling plugins to analyze or transform specific function subsets during static analysis. A child module provides `Fundec_set` for set operations with equality, comparison, and project-aware handling, while another implements `Fundec` operations like hashing and pretty-printing for C function AST nodes. Additional submodules configure string parameters with validation and manage parameter categories to control plugin behavior across analysis runs.",
      "description_length": 812,
      "index": 2315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for the `-cpp-extra-args` command-line option, allowing the definition and manipulation of named argument categories such as `@none`, `@default`, and `@all`. It supports operations to create categories with custom accessors and dependencies, set default behavior, and control how arguments are interpreted when using the `@all` category. Concrete use cases include configuring how specific preprocessor arguments are grouped, enabled, or interpreted during Frama-C analysis.",
      "description_length": 505,
      "index": 2316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a sorted associative map structure for managing key-value pairs where keys are `Fieldinfo` values, enabling ordered traversal and transformation of maps. It supports operations like merging, filtering, and splitting based on key order, along with conversions to lists and sequences while preserving field metadata. The module includes a key operations submodule for equality, comparison, and pretty-printing of `Fieldinfo` keys, and a generic map implementation that allows associating arbitrary data with fields, supporting lookup, insertion, iteration, and serialization. It is particularly useful in CIL-based static analysis for tracking field dependencies, comparing struct properties, or aggregating annotations across composite types.",
      "description_length": 762,
      "index": 2317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing files in a static analysis context. It provides operations to define, retrieve, and modify categories such as '@none', '@default', and '@all', each controlling how files are interpreted during analysis. Functions allow setting accessors, enabling categories with specific states, and defining relationships between categories.",
      "description_length": 372,
      "index": 2318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for integer references with operations for equality, comparison, hashing, and pretty-printing. It supports state management in static analysis by providing deep copies and membership checks over project skeletons. Use cases include tracking and manipulating integer state values during program analysis.",
      "description_length": 334,
      "index": 2319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a suite of set operations for CIL types where structural equality disregards attributes, supporting union, intersection, difference, and element insertion/deletion. It works with sets of `TypNoAttrs.t` values, enabling efficient membership tests, ordered traversal, and transformations like mapping or filtering. Key use cases include analyzing or transforming C code structures in Frama-C plugins where attribute-agnostic type comparisons are required, such as comparing struct definitions without considering compiler-specific annotations.",
      "description_length": 560,
      "index": 2320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files.As_string",
      "library": "frama-c.kernel",
      "description": "This module handles string-valued command-line parameters with validation, state tracking, and serialization, supporting use cases like CLI parsing and input constraint enforcement. It includes operations for validating against predefined value lists, extracting C function names, and retrieving raw strings, while its child module extends functionality to manage collections of files with type-safe operations such as comparison, hashing, and project membership testing. Examples include validating file paths passed as arguments, enforcing correct function identifier inputs, and managing structured file lists in static analysis tools. The combined interface enables robust parameter handling and structured data manipulation across command-line and internal tool workflows.",
      "description_length": 777,
      "index": 2321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for a specialized key type, supporting creation, insertion, deletion, and lookup, along with sorted iteration, folding over keys or values, and conversion to and from sequences. The main data types are `t` for keys\u2014supporting equality, comparison, and hashing\u2014and `'a Hashtbl.t` for hash tables mapping these keys to arbitrary values. Operations allow efficient key-value management, such as memoization or data aggregation in static analysis plugins, with in-place filtering and bulk transformations. Submodules define key representations and hash table implementations tailored to specific data types, enabling consistent key handling and persistent state tracking across analyses.",
      "description_length": 727,
      "index": 2322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements a narrowing operation for memory maps that merge two maps by intersecting their base keys and applying the narrowing function to their associated values. Works with maps where keys are bases and values are memory maps with offset-based structures. Useful for analyzing memory states in static analysis, where precise merging of memory abstractions is required.",
      "description_length": 371,
      "index": 2323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing `iter`, `map`, and `fold_left` to sequence monadic actions over list elements. It works with lists and monadic values parameterized by a type `'a` and a monad `t`. Use it to process lists in a monadic context, such as accumulating state or handling side effects per element.",
      "description_length": 332,
      "index": 2324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are integer values and values are of a specified data type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with abstract integer values from the `Int_val` module and a user-provided `Data` module for value handling. Concrete use cases include managing mappings from integer identifiers to abstract values in static analysis plugins, such as tracking variable bindings or state representations.",
      "description_length": 490,
      "index": 2325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Set",
      "library": "frama-c.kernel",
      "description": "This module provides standard set operations\u2014union, intersection, difference, and ordered traversal\u2014for sets of CIL kernel instructions (Kinstr), along with element access (min, max), conversion to sorted lists or sequences, and reverse iteration. It supports transformations like mapping, filtering, and partitioning, as well as comparisons, hashing, and pretty-printing, enabling efficient analysis of CIL code through ordered instruction sets, subset checks, and predicate-based queries. These capabilities are particularly useful for tasks requiring precise manipulation of instruction groups, ordered traversal, or structural introspection in compiler or static analysis tools.",
      "description_length": 682,
      "index": 2326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_set",
      "library": "frama-c.kernel",
      "description": "This module manages a global string set for plugin configuration and state, offering operations for element addition, membership checks, iteration, and change hooks. It includes a core data type for string sets with equality, comparison, and pretty printing, enabling first-class handling of unique string collections across analysis phases. A configuration submodule supports validated string parameters with change tracking and command-line integration, while a category submodule allows defining and managing parameter behaviors based on categories like `@default` or `@all`. Together, these components enable tracking analysis options, synchronizing string collections across components, and managing project-specific data with robust state handling.",
      "description_length": 754,
      "index": 2327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SaveState.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing values that can be saved and restored during Frama-C's analysis sessions. It supports equality checks, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. It is used to handle state persistence for analysis results tied to specific projects.",
      "description_length": 347,
      "index": 2328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set operations for logic labels, including creation, union, intersection, and element selection, alongside transformations like mapping and filtering. It works with ordered sets of `Logic_label` elements, supporting efficient membership checks, iteration, and conversion to sequences or lists. These capabilities are used in formal verification tasks such as tracking logic labels during program analysis, managing verification conditions, and integrating plugin-specific logic with Frama-C's project system via deep copying and project-aware predicates.",
      "description_length": 575,
      "index": 2329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic2.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype combining two distinct types, supporting operations like equality, comparison, hashing, and pretty printing. It works with any two modules `T1` and `T2` that define their own datatypes, producing a composite type that can be used in structured data analysis and manipulation. Concrete use cases include modeling pairs of values with different type behaviors, such as combining abstract memory states with control flow information in static analysis plugins.",
      "description_length": 500,
      "index": 2330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.StringList",
      "library": "frama-c.kernel",
      "description": "This module manages lists of string parameters for Frama-C plugins, providing operations to get, set, modify, and query these lists. It works with the type `string list` and supports concrete actions like adding or removing specific strings, appending lists, and iterating over elements. Use cases include handling command-line options, configuring plugin behaviors, and maintaining sets of identifiers or file paths during static analysis.",
      "description_length": 440,
      "index": 2331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsInitialized.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing values related to the behavior of the `-asm-contracts-ensure-init` option. It provides functions for equality, comparison, hashing, pretty printing, and deep copying, along with descriptors and representants for structural manipulation. It is used to handle and query initialized assembly contract data within kernel extensions.",
      "description_length": 417,
      "index": 2332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes memory mappings where keys combine memory bases and byte offsets, enabling precise tracking of memory regions and their associated data. It supports core operations like insertion, lookup, and iteration, along with advanced transformations such as merging overlapping regions and filtering by address ranges. Submodules provide concrete implementations for key structures and value handling, allowing full manipulation of memory states in static analysis workflows. Example uses include modeling heap allocations, verifying pointer accesses, and analyzing low-level memory operations in C programs.",
      "description_length": 620,
      "index": 2333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a purely functional interface for managing ordered polymorphic maps with immutable key-value pairs, supporting efficient queries, structural transformations, and ordered traversal. It integrates a key module that defines comparable key types with set operations and a data module that implements typed maps with support for deep copying, equality, and kernel integration. Together, they enable use cases such as managing analysis data in Frama-C plugins and performing symbolic computations with persistent, ordered maps. Key operations include `find`, `map`, `filter`, and `merge`, alongside typed key management and project-based filtering.",
      "description_length": 663,
      "index": 2334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Option_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic option type with operations for equality, comparison, hashing, and pretty-printing. It supports state management in Frama-C plugins by providing deep copy and project membership checks. Concrete use cases include handling optional values in analysis states and defining extensible data descriptors for plugin components.",
      "description_length": 354,
      "index": 2335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered maps with strict structural equality and optimized physical equality checks for keys based on CIL types with precise constant comparison. It supports insertion, merging, ordered traversal, filtering, and customizable pretty-printing, making it suitable for static analysis tasks like tracking dataflow values or analyzing memory layouts. The key module offers strict structural equality, comparison, hashing, and pretty-printing for CIL types, enabling exact structure-based tracking of program elements. The map module built on these keys provides full structural consistency for mappings, supporting deep copies, comparisons, and transformations tailored for structured CIL data with strict equality requirements.",
      "description_length": 744,
      "index": 2336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered, immutable set abstraction for elements with a total ordering, supporting operations like union, intersection, difference, and element-wise transformations. It works with sets of type `t` containing elements of type `elt`, maintaining internal sorted order for efficient membership checks, range queries, and ordered traversal via iterators or sequence conversions. Designed for use cases requiring precise set manipulation in static analysis tasks, such as tracking program state ranges, managing unique identifiers, or implementing algorithms that rely on ordered collections for correctness or performance.",
      "description_length": 643,
      "index": 2337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Verbose",
      "library": "frama-c.kernel",
      "description": "This module manages integer-based verbosity settings with typed state (`t`), supporting operations to set, retrieve, and constrain values, along with callbacks for state changes. It integrates with command-line interfaces using aliases and help messages, and allows customization of serialization and project-specific behavior. The child module extends this by defining a registered data type with equality, comparison, and pretty-printing, enabling structured values with embedded project data. Together, they support use cases like controlling diagnostic output levels, persisting plugin state, and validating numeric inputs with type-safe data structures.",
      "description_length": 658,
      "index": 2338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SafeArrays.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling safe array representations in the kernel. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with deep copying and membership checks over project skeletons. These capabilities support analysis plugins that need to manipulate and reason about array data structures with safety guarantees.",
      "description_length": 399,
      "index": 2339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.As_string",
      "library": "frama-c.kernel",
      "description": "This module configures and validates string-valued parameters with constraints, supporting allowed values, change hooks, and persistence. It handles global string parameters that distinguish between plain strings and C function names, with integration for command-line aliases and serialization. The core type `t` enables manipulation of string-based custom specifications, offering equality, comparison, hashing, and pretty-printing, used notably for managing `-generated-spec-custom` options in Frama-C analyses. Examples include enforcing valid function identifiers, customizing analysis settings, and maintaining consistent parameter state across sessions.",
      "description_length": 660,
      "index": 2340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a comprehensive set of ordered operations for managing collections of CIL statements, including union, intersection, difference, membership checks, and ordered iteration via `fold` and `iter`. It operates on sets of `Stmt.t` values, leveraging their inherent ordering for efficient element selection, reverse-ordered sequence conversion, and nearest-neighbor queries. These capabilities are particularly useful in static analysis tasks such as control flow traversal, data dependency tracking, or code transformation pipelines, where precise manipulation of statement sets underpins tasks like slicing, impact analysis, or transformation validation.",
      "description_length": 672,
      "index": 2341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfig.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing structured configuration data used in the kernel's printing functionality. It provides utilities for equality checks, comparison, hashing, pretty-printing, and deep copying, along with support for querying embedded project data. Concrete use cases include handling and persisting configuration states for the `-print-config` option and comparing or serializing internal kernel settings.",
      "description_length": 475,
      "index": 2342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_list.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic list datatype from a given element module T, providing standard operations including equality, comparison, hashing, and pretty printing. It supports working with lists of T values as a fixed type, enabling use cases like representing sequences of typed values in analyses or plugins. The module also supports deep copying, membership checks over project skeletons, and includes descriptors for integration with Frama-C's type system.",
      "description_length": 467,
      "index": 2343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters, particularly for C preprocessing arguments and function name validation, supporting operations like value setting, retrieval, alias resolution, and serialization. It works directly with string primitives and collection-like structures to enforce allowed values, handle project-specific state, and validate inputs against C function name constraints. The child module introduces a dedicated data type for `-cpp-extra-args`, offering equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Together, they enable parsing and restricting preprocessor arguments, validating function identifiers, and ensuring consistent parameter handling across analysis sessions.",
      "description_length": 768,
      "index": 2344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fundec.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing function declarations in the context of computing AST differences between projects. It provides operations for equality checking, comparison, hashing, and pretty-printing values of this type, along with utilities for deep copying and inspecting project-related data. Use cases include tracking changes to function definitions across different versions of a C project and enabling accurate diff computations that respect semantic differences.",
      "description_length": 489,
      "index": 2345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype for lattice values that may include a bottom element, based on a given domain. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with support for project membership checks and deep copying. It is used to represent and manipulate lattice elements in static analysis, where the bottom value signifies an absence or undefined state.",
      "description_length": 411,
      "index": 2346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditCheck.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for auditing checks in the Frama-C kernel. It supports structured data representation with descriptors, packed descriptors, and a list of representants, enabling introspection and serialization. Use cases include tracking and validating audit check data during static analysis, ensuring deep copies and project membership checks for analysis plugins.",
      "description_length": 476,
      "index": 2347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores values associated with memory base addresses. It provides operations for equality testing, comparison, hashing, and pretty-printing keys, as well as deep copying and checking the presence of specific projections within a key. The module is used to manage and manipulate keys that uniquely identify memory zones in static analysis tasks.",
      "description_length": 398,
      "index": 2348,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Version",
      "library": "frama-c.kernel",
      "description": "This module represents versioned control flow states as pairs of vertices and vertex sets, enabling precise tracking of loop head entries during graph transformations. It supports equality, comparison, hashing, and pretty-printing of versions, along with deep copying and project membership tests, facilitating analysis of unrolled unnatural loops in abstract interpretation. The version type underpins ordered maps and hash tables for polymorphic data indexed by control flow keys, enabling efficient state aggregation, ordered traversal, and serialization across program versions. Additionally, it integrates with an ordered set module for union, intersection, and ordered iteration over versioned control flow states, enhancing static analysis of loop transformations and path-sensitive data merging.",
      "description_length": 803,
      "index": 2349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associative maps keyed by property-centric identifiers ordered through function-specific criteria, supporting efficient insertion, deletion, ordered traversal, and merging. Its core operations handle range queries, sequence conversion, and aggregation, enabling deterministic processing of property dependencies and analysis results across Frama-C passes. The key module defines structured property keys based on kernel functions, instructions, and IDs with comparison and printing utilities, while the data module associates these keys with typed values, supporting project-aware operations and deep copies. Together, they facilitate managing proof obligations, annotations, and property-centric data in static analysis plugins.",
      "description_length": 749,
      "index": 2350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation tailored for managing CIL type information in Frama-C, combining key operations with specialized data handling. It supports keys that uniquely identify type data and values of type `Data.t`, offering efficient lookups, equality checks, and pretty-printing for structured analysis. Submodules define type-specific behaviors, enabling deep copies, project-based membership tests, and type-safe manipulations. Examples include tracking C type definitions across translation units and comparing type structures during static analysis.",
      "description_length": 579,
      "index": 2351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to the `option` type, providing `iter` and `map` operations that integrate monadic effects. It works with values of type `'a option` and monadic actions `'a t`, allowing traversal and transformation within a monadic context. Concrete use cases include handling optional values in stateful or effectful computations, such as parsing or analysis passes that track additional context.",
      "description_length": 419,
      "index": 2352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for key-value pairs where keys come from a lattice-equipped type, supporting efficient creation, in-place modification, and sorted traversal. It enables advanced operations such as sequence-based construction, memoization, and structural transformations, with key functionality including customizable iteration and lattice-based combination of values. The first child module implements a lattice-structured hash table where values also form a lattice, offering operations like `mem_project`, equality, and pretty printing, useful for static analysis tasks such as abstract memory tracking. The second child module defines a key type for lattice-structured maps combined with sets, supporting deep copying, membership testing, and symbolic key management in data flow analysis.",
      "description_length": 820,
      "index": 2353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally executes a state monad action based on a boolean flag. It operates on the state monad type `unit t`, allowing imperative-style control flow while preserving functional purity. A typical use case is to selectively run state-modifying operations, such as logging or configuration updates, based on dynamic conditions.",
      "description_length": 383,
      "index": 2354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes key-value associations where keys are memory base identifiers, offering operations to insert, delete, and traverse mappings in key order. It supports transformations, comparisons, and conversions to sequences, enabling analysis of memory regions and symbolic state aggregation. The polymorphic child module provides standard map operations for associating arbitrary data with memory bases, such as tracking permissions or abstract values. A key-definition submodule supplies necessary comparison and hashing primitives for memory-related key types, ensuring correct and efficient map behavior during static analysis tasks.",
      "description_length": 644,
      "index": 2355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a reference-based datatype with operations for state management, including equality, comparison, hashing, and pretty-printing. It works with a specific type `t` that wraps a reference to `Data.t`. Use it to create and manipulate stateful values in a way that supports deep copying, project membership checks, and structured serialization.",
      "description_length": 358,
      "index": 2356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized hash table for CIL expressions where keys are compared using structural equality, with dedicated handling for constants and `sizeof` expressions based on their computed size. It supports standard operations such as insertion, lookup, and iteration, along with ordered traversal and folding over keys or values sorted by custom criteria, enabling efficient memoization and structural analysis. The key module provides structural comparison, hashing, and pretty printing for CIL expressions, while the hash table module built on it ensures precise equivalence checks and canonical representation. Example uses include static analyses that track equivalent expressions across different contexts or optimize repeated computations based on structural identity.",
      "description_length": 792,
      "index": 2357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps with integer keys and arbitrary value types, supporting functional updates, ordered traversal, and bulk operations like merging and filtering. It enables sorted iteration over key-value pairs, predicate-based searches, and conversions to sequences or lists, while its key management submodule handles equality, comparison, and project-aware membership checks for integer keys. The data-specific submodule provides typed integer-indexed collections with deep copying, pretty printing, and efficient lookups, making the system suitable for tasks like interval analysis, persistent data management, and ordered aggregation of structured values. Example uses include tracking integer-identified entities with rich metadata, performing sorted accumulations, and integrating map data with analysis workflows requiring precise key handling.",
      "description_length": 868,
      "index": 2358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_set",
      "library": "frama-c.kernel",
      "description": "This module manages command-line options representing sets of values with support for element addition, membership checks, iteration, and state tracking through hooks and serialization. It works with a set type (`E.Set.t`) and individual elements (`elt`), offering utilities for handling aliases with visibility controls and deprecation, along with predicates for querying set properties. The module integrates string-based parameter handling, set-like structures for abstract datatypes, and category management for organizing and activating related options. You can use it to collect file lists, manage configuration flags, track program states, and organize plugin options into logical groups with customizable activation behavior.",
      "description_length": 733,
      "index": 2359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_option.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype from a polymorphic option type, providing standard operations like equality, comparison, hashing, and pretty printing. It works with types that conform to the `T` module signature, wrapping them in an option-like structure. Concrete use cases include defining optional values with rich introspection and serialization, such as representing the presence or absence of analysis results in static analysis plugins.",
      "description_length": 454,
      "index": 2360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_var.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating logic variables in the context of computing project diffs. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Use cases include tracking and comparing logic variable states across different project versions and ensuring correct handling of project-specific data during diff computations.",
      "description_length": 463,
      "index": 2361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic operation `only_if` that conditionally executes a monadic action based on a boolean value. It works with unit-returning monadic values and is useful for controlling execution flow in monadic contexts without branching outside the monad. A concrete use case is selectively performing side effects or state updates in a pure monadic pipeline based on dynamic conditions.",
      "description_length": 399,
      "index": 2362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages hash tables with keys based on CIL offset structures, offering efficient lookup, insertion, and iteration while ensuring structural equality checks. It supports specialized key handling through its child module, which defines offset-aware equality, comparison, and hashing, enabling precise key management in static analysis contexts. The value-handling submodule provides operations for structured data, including deep copying and project-aware membership checks, facilitating analysis result tracking in Frama-C plugins. Together, these components allow for memoization, sorted traversal, and context-sensitive caching of CIL-based computations.",
      "description_length": 667,
      "index": 2363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements hashconsed data structures with strong equality and efficient sharing, using weak or non-weak hash tables based on the `Cmdline.deterministic` flag. It provides operations for creating, comparing, hashing, and pretty-printing hashconsed values, along with deep copying and project membership checks. Concrete use cases include managing immutable, interned representations of program elements like types, expressions, or states in static analysis.",
      "description_length": 469,
      "index": 2364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module enables manipulation of sets containing CIL expressions with structural equality, offering operations like union, intersection, difference, and ordered traversal. It supports precise queries for extremal elements (min, max, nearest values), transformations via mapping and filtering, and conversions between sets and sequences. These capabilities are particularly useful in static analysis for tracking structurally equivalent expressions, optimizing expression comparisons, or implementing algorithms requiring ordered set operations on CIL code constructs.",
      "description_length": 570,
      "index": 2365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that takes a boolean condition and a bottom value, returning the same bottom value if the condition is true, or a distinct representation of bottom otherwise. It operates on the unit type wrapped in a bottom-aware lattice structure. This supports precise control flow analysis in static analysis tools by allowing conditional propagation of bottom values.",
      "description_length": 404,
      "index": 2366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.M",
      "library": "frama-c.kernel",
      "description": "This module manages associations between memory bases and bit-level offset intervals. It provides operations to iterate over, fold, and query these associations, as well as extract their structural shape. It is used to track and analyze memory locations at the bit level, such as in static analysis of low-level memory manipulations or precise aliasing behavior.",
      "description_length": 362,
      "index": 2367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a user directory within an existing directory structure. It provides operations `get_dir` and `get_file` to retrieve or create directories and files under a specified parent path. These functions are used to manage plugin-specific file paths during analysis, ensuring proper isolation and organization of generated files.",
      "description_length": 344,
      "index": 2368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables for managing key-value pairs with customizable ordering and efficient lookup, supporting operations like insertion, deletion, iteration, and bulk conversion to and from sequences. It enables memoization and caching during analysis tasks, with administrative controls for table management. One child module provides a hash table type with deep copying and project-aware value handling, ideal for managing structured data with unique hash-based representations. Another defines a key type with equality, comparison, and hashing, tailored for structured or project-specific identifiers that require preservation of project membership and deep copying.",
      "description_length": 694,
      "index": 2369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally executes a monadic action based on a boolean value. It operates on the unit type within a monadic context, allowing controlled execution flow based on boolean conditions. A typical use case is to conditionally trigger side effects or computations in a monadic chain without explicitly handling the unit value.",
      "description_length": 377,
      "index": 2370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Time.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation with a descriptor, packed descriptor, and list of representatives, enabling introspection and serialization. Concrete use cases include managing time-related data across different analysis contexts and ensuring consistent handling of time values in plugins and command-line options.",
      "description_length": 504,
      "index": 2371,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by normalized filepaths, where each map entry holds a value of a specified type. It supports operations like equality checking, comparison, hashing, and pretty-printing for maps, along with deep copying and project membership testing. It is useful for managing per-file data in static analysis tools, such as tracking file-specific analysis results or configurations.",
      "description_length": 401,
      "index": 2372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidBool.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with standard operations including equality, comparison, hashing, and pretty printing. It provides utilities to work with lists of representants, descriptors for structural manipulation, and supports deep copying and project membership checks. Concrete use cases include managing and comparing values related to the behavior of the `-warn-invalid-bool` option in Frama-C's kernel.",
      "description_length": 416,
      "index": 2373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a `only_if` function that conditionally executes a monadic action based on a boolean flag. It works with monadic values of type `'a t`, where `t` is a monad instance, typically used to control execution flow in composed monadic contexts. A concrete use case is selectively running stateful or effectful computations only when a certain condition holds, such as skipping a logging action if a debug flag is false.",
      "description_length": 433,
      "index": 2374,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings from kernel functions to value lists, supporting dynamic parameter state, default values, and project-specific tracking. It allows keys to be either defined functions or pure prototypes, with operations for alias resolution, membership checks, and categorized grouping. Submodules handle function sets with deep copying and comparison, string-based parameters with validation and serialization, and categories for organizing function-related options. Examples include defining command-line flags that accept multiple function names, validate against available symbols, and control behavior through categories like `@default` or `@all`.",
      "description_length": 664,
      "index": 2375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_list",
      "library": "frama-c.kernel",
      "description": "This module organizes list-based plugin options with dynamic behavior, combining structured list operations, string parameter utilities, and category management to support rich, stateful configurations. It centers on lists of elements with deep manipulation, string parameters with validation and aliasing, and categories for grouping and dependency tracking. Operations include folding, comparison, serialization, and visibility control across project sessions. Examples include tracking analysis rules with dynamic updates, managing validated command-line options, and defining interdependent configuration flags for static analysis plugins.",
      "description_length": 643,
      "index": 2376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table implementation for mapping CIL labels to arbitrary values, supporting imperative and functional operations such as insertion, deletion, iteration, and deterministic traversal via custom comparisons. It includes utilities like `find_opt`, `find_def`, and `memo` for safe and efficient key lookups, particularly useful in static analysis tasks requiring ordered label processing. The child modules enhance this functionality by defining key structures that uniquely identify CIL labels within a project and by creating value-specialized hash tables with structural comparisons and project-aware operations. Together, they enable precise manipulation of label-based data, such as memoizing analysis results or aggregating values tied to specific C source code locations.",
      "description_length": 813,
      "index": 2377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for creating, modifying, and querying ordered character sets with efficient membership checks, range-based element retrieval, and set algebra (union, intersection, difference). It works with character sets represented as balanced trees, ensuring unique elements and ordered traversal based on a comparator, while supporting conversions to sequences/lists and integration with plugin metadata systems. Typical use cases include static analysis tasks requiring precise character range tracking, input constraint validation, or state management in Frama-C plugins where ordered set semantics and deep copying are critical.",
      "description_length": 649,
      "index": 2378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a polymorphic map structure where keys are CIL expressions compared structurally, normalizing equivalent expressions within `sizeof` operations. It supports standard map operations\u2014insertion, lookup, merging, and ordered traversal\u2014while ensuring canonical treatment of keys based on CIL expression semantics. The associated key module enables deep copying, hashing, and pretty printing, making it suitable for static analysis tasks like tracking expression-based properties or eliminating redundant computations. For example, it can merge maps of analyzed expressions, perform ordered traversal over normalized keys, or serve as a foundation for size-aware expression indexing in C code analysis tools.",
      "description_length": 723,
      "index": 2379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes heterogeneous maps keyed by function identifiers, enabling ordered traversal, selective updates, and structured transformations over polymorphic values. It supports specialized submodules for managing CIL-based data mappings with project-aware operations and for defining structured keys with deep copy, comparison, and serialization capabilities. You can merge analysis results across functions, filter or map values conditionally, and generate formatted reports with precise key ordering. Specific uses include tracking function properties, aggregating plugin data, and managing unique identifiers in static analysis workflows.",
      "description_length": 651,
      "index": 2380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure indexed by the `Data` module's type, providing standard operations like comparison, equality, hashing, and pretty-printing for values stored in the map. It supports persistent and deep-copy manipulation of alarm-related data, ensuring structural integrity across operations. Concrete use cases include managing alarm states associated with different analysis projects and querying alarm properties based on project-specific criteria.",
      "description_length": 472,
      "index": 2381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative and functional hash tables for mappings with logic type keys, supporting efficient creation, insertion, lookup, and deletion, along with ordered iteration and folding over entries. It bridges mutable and immutable operations, enabling use cases such as memoizing type-based computations, accumulating metadata during analysis, and managing structured transformations with key ordering. The child modules define specialized keys and hash table operations for `Data.t`, offering equality, comparison, hashing, and integration with Frama-C's typing system, supporting deep copying, project membership checks, and pretty printing. Together, they facilitate managing logic type information with efficient lookups, persistence across analysis phases, and context-specific metadata retrieval tied to CIL type descriptors and project skeletons.",
      "description_length": 868,
      "index": 2382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic structure with a focus on conditional execution through the `only_if` function, which restricts computation to cases where a boolean condition holds. It operates on a unit type within a monadic context, enabling chaining of effectful operations that depend on boolean guards. Concrete use cases include controlling execution flow in static analysis plugins, where certain analyses are conditionally enabled based on configuration or intermediate results.",
      "description_length": 485,
      "index": 2383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered integer set operations with functional, immutable transformations, supporting queries for extremal values, range-preserving traversals, and set algebra (union, intersection, difference). It works with sets of integers represented as `Frama_c_kernel.Datatype.Integer.t` values, maintaining strict ordering during operations and enabling efficient membership tests, nearest-value searches, and conversions to sequences or lists. Typical use cases include static analysis tasks requiring precise tracking of integer ranges, such as modeling program variable domains or analyzing control flow constraints with ordered collections.",
      "description_length": 655,
      "index": 2384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing plugins to store transient data like intermediate results or persistent caches. Concrete use cases include storing analysis results between sessions or caching parsed external data.",
      "description_length": 390,
      "index": 2385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module performs a backward dataflow analysis on control flow graphs where unnatural loops are normalized, computing a fixpoint over a given abstract domain `D`. It processes unrolled automata by traversing the graph in a weak topological order, applying transfer functions to propagate state from successors to predecessors. The result is a mapping of control points to abstract values that capture properties such as postconditions or invariants, useful for verification tasks like reachability analysis or bug detection.",
      "description_length": 527,
      "index": 2386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Gcc_builtin_templates_loaded.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` representing GCC built-in templates in Frama-C's CIL analysis framework. It provides operations for equality checking, comparison, hashing, and pretty-printing values of type `t`, along with accessors for metadata such as the type, name, and descriptor of the built-in template. The module supports deep copying and membership testing over project values, enabling precise manipulation and analysis of GCC-specific constructs in static analysis plugins.",
      "description_length": 498,
      "index": 2387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintAsIs.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values in the context of the `-print-as-is` option's behavior. It includes functions for equality checks, comparison, hashing, pretty-printing, and deep copying, along with support for querying values based on project membership. The module is used to handle structured data during kernel operations, particularly when preserving and inspecting the original form of printed values is required.",
      "description_length": 485,
      "index": 2388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for mapping logic type identifiers to arbitrary values, supporting insertion, lookup, in-place modification, and deterministic traversal. It includes utilities for memoization, default values, and conversion from sequences, enabling efficient management of logic type metadata and caching of type-dependent computations. One child module specializes the hash table for `Data.t`, offering equality, comparison, and pretty-printing tailored to CIL-based analyses, while another defines keys that uniquely identify logic types by name and type info, with operations for comparison, hashing, and introspection. Together, they support structured, efficient retrieval and manipulation of logic type definitions across analysis contexts.",
      "description_length": 774,
      "index": 2389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Debug.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for debugging purposes. It supports structured data representation through descriptors, packed descriptions, and a list of representatives for introspection. Use cases include inspecting and comparing complex data structures during kernel development, such as analyzing project-specific values or debugging state transitions in Frama-C plugins.",
      "description_length": 470,
      "index": 2390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLibc.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating abstract data structures used in the printing of C library functions. It provides equality, comparison, hashing, and pretty-printing functions for values of this type, along with deep copying and membership testing over project skeletons. It is used specifically to handle data involved in the `-print-libc` command-line option, enabling accurate and customizable output of C library function signatures during analysis.",
      "description_length": 512,
      "index": 2391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages hash tables mapping control flow graph vertices to arbitrary data, enabling efficient lookups, updates, and ordered traversal. It supports key operations like `find_opt`, bulk modifications from sequences, and deterministic iteration over keys or entries, with `Vertex.t` as the key type and customizable value types. The first child module specializes these tables for vertex metadata storage with built-in serialization and comparison, while the second defines the vertex key type with necessary hash and order operations. Use cases include tracking per-vertex analysis results or memoizing transition effects in abstract interpretation plugins.",
      "description_length": 667,
      "index": 2392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for CIL types, enabling efficient manipulation of collections through union, intersection, difference, and ordered iteration. It works with sets of `Frama_c_kernel.Cil_datatype.Typ.t` elements, leveraging structural comparison and typedef-unrolling for equivalence checks. Typical use cases include analyzing C codebases to track type hierarchies, validate disjoint type constraints, or process ordered type sequences during static analysis passes.",
      "description_length": 494,
      "index": 2393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations where keys represent positions in source code, enabling precise tracking of data like annotations or diagnostics at specific locations. It supports map construction, querying, and transformation operations, including addition, lookup, traversal, and merging, while its key module provides comparison, hashing, and formatting for source positions. Child modules specialize in typed map instances and key manipulation, allowing operations such as project-aware membership checks and structured data association with exact source locations. For example, it can store analysis results per line in a C file, merge maps from different files, or filter diagnostics based on position ranges.",
      "description_length": 726,
      "index": 2394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hptset",
      "library": "frama-c.kernel",
      "description": "This module manages collections of CIL variable information with efficient set operations, including union, intersection, and membership checks, while supporting transformations like merging and element replacement using specialized data structures such as `Hptset.t`. Its submodules extend this functionality by organizing variable sets with arbitrary values in ordered maps, implementing immutable `Varinfo` sets with range traversal, and providing hash tables optimized for static analysis plugins with project-aware keys. These components enable precise tracking of variable dependencies, scoping relationships, and analysis state across C code, with support for advanced iteration, structural manipulation, and memoization of per-variable results. Specific use cases include comparing program state snapshots, optimizing memory during large-scale analyses, and maintaining imperative state tied to CIL variables in Frama-C plugins.",
      "description_length": 936,
      "index": 2395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table optimized for managing mappings between control flow graph edges and arbitrary values, supporting imperative operations like insertion, lookup, and ordered iteration with custom comparisons. It enables efficient tracking of edge-related metadata such as guards and actions, facilitating abstract interpretation tasks like state-space exploration and memoization of edge computations. The key module defines hashable edge types with equality and comparison operations for use as table keys, while the value module specializes in storing and printing edge-associated data conforming to a given data interface. Together, they support concrete workflows such as analyzing transitions in an interpreted automaton with associated semantic actions and guards.",
      "description_length": 786,
      "index": 2396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized map structure over hash-consed tree keys and values, using Patricia trees for efficient storage and access. It provides core operations for insertion, lookup, and traversal, while its key module handles equality, comparison, hashing, and pretty-printing of tree-structured keys. The map supports use cases like tracking analysis states indexed by abstract syntax tree nodes in static analysis tools. Together, the modules enable efficient, type-safe manipulation of large, structured key-value collections.",
      "description_length": 543,
      "index": 2397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_array.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic array type based on the provided element type, supporting operations such as equality, comparison, hashing, and pretty printing. It works with polymorphic arrays where elements are of a fixed type, enabling precise data representation and manipulation. Concrete use cases include defining typed arrays for static analysis components, such as tracking sets of values or structured data in Frama-C plugins.",
      "description_length": 438,
      "index": 2398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a state-aware hash table type specialized for a given data module, supporting operations like equality, comparison, hashing, and pretty printing. It works with arbitrary data types through the provided `Data` module parameter, ensuring deep copies and project-aware membership checks. Concrete use cases include managing project-specific metadata or analysis results in a hash table while maintaining compatibility with Frama-C's state management and serialization mechanisms.",
      "description_length": 496,
      "index": 2399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a symbolic path data type with operations for equality, comparison, hashing, and pretty printing. It supports working with project-based values through membership checks and deep copying. Use cases include managing symbolic path representations in Frama-C plugins, particularly for analysis configurations involving project-specific data.",
      "description_length": 358,
      "index": 2400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation for CIL types using structural equality and key-based comparison, supporting operations like insertion, lookup, iteration, and in-place filtering. It works with key-value pairs where keys are structural type representations (`Typ.t`) and values are arbitrary, offering utilities for memoization, default value computation, and type-aware transformations. The module includes a key type definition for CIL types with equality, hashing, and comparison, enabling efficient storage and retrieval of type-specific data, and a specialized hash table type for managing CIL values with structural identity, supporting deep copying and project membership checks. Example uses include tracking equivalent types across a program, implementing type-based analyses, and managing type-driven state in analysis plugins.",
      "description_length": 853,
      "index": 2401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with arbitrary data types encapsulated through the `Data` parameter, enabling structured storage and retrieval. Concrete use cases include managing sets of analyzed values in static analysis plugins, where deep copying, precise equality, and project-aware membership checks are required.",
      "description_length": 471,
      "index": 2402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath",
      "library": "frama-c.kernel",
      "description": "This module manages file path command-line options with support for value tracking, alias resolution, and serialization control. It provides operations for working with `Filepath.t` values, including emptiness checks, dynamic state updates, and type-safe project membership tests. Submodules extend this functionality with equality, comparison, and pretty printing capabilities for `Datatype.t` file paths, enabling robust parameter handling in Frama-C tools. Example uses include validating input paths, tracking file dependencies, and customizing configuration marshaling.",
      "description_length": 574,
      "index": 2403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic3.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype combining three other datatypes, supporting operations like equality, comparison, hashing, and pretty printing. It works with any three datatypes that conform to the `t` type, enabling structured representation and manipulation of heterogeneous data. Concrete use cases include defining composite data structures for static analysis plugins, where precise type handling and deep copying are required.",
      "description_length": 443,
      "index": 2404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of logic type information elements, enabling operations like union, intersection, and difference alongside ordered transformations such as splitting ranges or finding nearest neighbors. It supports reverse iteration, sequence-based construction, and integration with Frama-C's plugin system through project membership checks and serialization utilities. These sets are particularly useful in static analysis tasks requiring precise set manipulations, such as tracking logic type constraints or partitioning data during abstract interpretation.",
      "description_length": 579,
      "index": 2405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes key-value associations using ordered keys, enabling efficient insertion, lookup, and traversal while maintaining immutability. It leverages a key module to define ordering and operations like comparison and hashing, supporting structured data processing and project-specific state tracking. A data module specializes maps for specific value types, adding pretty-printing and comparison for analysis results tied to AST nodes. Together, they enable precise management of hierarchical project data, such as tracking analysis states indexed by syntax tree nodes or converting structured sequences bidirectionally.",
      "description_length": 632,
      "index": 2406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages hash tables mapping CIL enumeration descriptions to arbitrary values, supporting imperative updates and bulk transformations. It enables ordered traversal, memoization, and structural customization, with operations for insertion, lookup, iteration, and folding. The child modules provide specialized key handling and data management for `Enuminfo.t`, including equality, hashing, and pretty-printing. Use cases include tracking enum metadata, caching analysis results, and associating semantic properties with C enums during static analysis.",
      "description_length": 561,
      "index": 2407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping rational numbers to arbitrary values, with imperative and functional operations for insertion, lookup, and sorted iteration. It supports converting tables to sequences, memoizing functions over rational keys, and defining custom key modules with comparison logic. Child modules specialize the table for specific data types and manage rational keys with equality, hashing, and pretty-printing operations. Examples include caching analysis results and managing ordered collections of numerical data across plugin phases.",
      "description_length": 561,
      "index": 2408,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Custom",
      "library": "frama-c.kernel",
      "description": "This module enables the definition and manipulation of command-line parameters with custom data types, supporting operations to set values, manage visibility and deprecation, and enforce constraints through allowed values or aliases. It introduces the custom type `t` (derived from `V.t`), string lists for aliases and enumerations, and integrates with project state management for serialization and dynamic updates via hooks. The child module provides a data type interface with equality, comparison, hashing, and pretty-printing for custom types, enabling deep copying, membership testing, and descriptor management. Together, they allow implementing complex options with type-specific validation, backward compatibility through aliases, and synchronized state across analysis tools.",
      "description_length": 785,
      "index": 2409,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of `Term_offset` values with standard operations like union, intersection, and difference, alongside transformations such as `map`, `filter`, and `fold`. It supports efficient ordered traversal, element queries, and conversions to lists or sequences, optimized for static analysis tasks like code slicing or abstract interpretation. The structure is designed for precise positional tracking of program elements in Frama-C's kernel, enabling use cases such as dependency analysis and control-flow reasoning.",
      "description_length": 542,
      "index": 2410,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Machdep.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating abstract data types in the context of machine-dependent configurations. It supports introspection through descriptors and provides utilities to check membership in projects and perform deep copies, ensuring no shared references. Concrete use cases include managing type representations during AST preparation and handling machine-specific data type behaviors in static analysis plugins.",
      "description_length": 550,
      "index": 2411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages a string-indexed map of value lists with support for change notifications, aliases, and custom marshaling, integrating with Frama-C's plugin system for state registration and project-specific updates. It provides operations for adding, retrieving, and modifying entries, along with lifecycle hooks, deprecation, and visibility controls, enabling use cases such as tracking analysis state across projects or managing multi-value plugin options. The child modules extend this functionality by supporting string-valued parameters with validation, multi-instance plugin data with project-aware operations, and parameter categories with dependencies and accessors. Together, they allow structured handling of complex plugin configurations with constraints, custom data representations, and scoped state management.",
      "description_length": 829,
      "index": 2412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set abstraction for managing identified CIL predicates, supporting standard operations like union, intersection, difference, and element queries, along with iteration, filtering, and transformations. It maintains ordered traversal and structural integrity, enabling efficient membership checks, nearest-element queries (e.g., `nearest_elt_ge`), and conversions between sets and sequences. These capabilities are used in Frama-C plugins to analyze logical conditions during static analysis, such as verifying code invariants, managing preconditions/postconditions, and performing predicate-based reasoning with deep copying or project-specific membership checks.",
      "description_length": 686,
      "index": 2413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associations between global annotations and arbitrary values, offering efficient insertion, lookup, and traversal with physical equality optimizations. It supports transformations like filtering and folding, and converts maps to lists or sequences for further processing, enabling precise tracking of CIL-level metadata during program analysis. Submodules provide type-safe handling of annotation-value pairs and define key types for associating annotations with identifiers, supporting operations like equality checks, hashing, and pretty printing. These components together facilitate tasks such as storing function-specific analysis results or managing global variable metadata in static analysis plugins.",
      "description_length": 736,
      "index": 2414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingForce.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` and associated operations for managing and comparing structured data, including equality, comparison, hashing, and pretty-printing. It supports deep copying and provides utilities to check membership of project values within the data structure. The module is used to handle complex data representations in the context of kernel-level analysis options, specifically for the `-ulevel-force` command-line parameter.",
      "description_length": 455,
      "index": 2415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecMode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling generated specification modes in the kernel. It provides utilities to check membership within project structures, create deep copies, and manage type descriptors for serialization and introspection. Use cases include configuring and validating analysis behaviors through the `-generated-spec-mode` command-line option.",
      "description_length": 461,
      "index": 2416,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LibEntry.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation with descriptors, packed descriptions, and a list of representative values. Concrete use cases include managing and manipulating abstract data types in kernel extensions, particularly for plugin developers needing to handle entry point logic and project-specific data queries.",
      "description_length": 498,
      "index": 2417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.WTO",
      "library": "frama-c.kernel",
      "description": "This module implements the Bourdoncle algorithm to compute a weak topological order (WTO) partition for control flow graphs with unnaturally structured loops. It provides functions to partition a graph based on a given preference relation, compare and print components and partitions, and ensures correct traversal order for abstract interpretation tasks. It operates on nodes representing control points and is used to optimize fixed-point computations in static analysis by enforcing a consistent iteration strategy.",
      "description_length": 518,
      "index": 2418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements immutable ordered maps with efficient key-based access, supporting functional transformations and persistent operations over structured data. It provides core operations like insertion, lookup, iteration, and folding, along with customizable pretty-printing and conversion to and from lists and sequences. The key module enables precise type handling and introspection for map keys, while the map module instantiates full map structures over arbitrary value types. Example uses include static analysis databases mapping program points to variable states, and symbolic computation engines tracking key-value associations with ordered traversal.",
      "description_length": 666,
      "index": 2419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a specialized hashtbl structure, providing standard operations including equality, comparison, hashing, and pretty printing. It supports structured keys that may contain project-specific data, enabling deep copying and membership checks against project properties. Concrete use cases include managing and querying alarm data indexed by structured keys in a type-safe and efficient manner.",
      "description_length": 430,
      "index": 2420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.V",
      "library": "frama-c.kernel",
      "description": "This module defines a vertex type for control flow graphs with labels based on versioned states, supporting comparison, hashing, and equality checks. It works with vertices labeled by versioned control points to manage state transitions in unrolled unnatural loops. Concrete use cases include tracking control flow changes and state versions during abstract interpretation of programs with modified loop structures.",
      "description_length": 415,
      "index": 2421,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between keys that uniquely identify logical predicates in CIL-based analyses and arbitrary values, supporting functional updates, ordered traversal, and precise key-based queries. It provides operations for filtering, merging, and transforming maps, along with utilities for converting to and from sequences and lists, and includes structured data handling through a specialized key type that supports equality, comparison, and pretty-printing. Submodules define key-specific operations and a data map for project identifiers, enabling efficient tracking and manipulation of predicate and project-specific analysis states. Example uses include storing analysis results keyed by predicate identifiers and merging predicate data across different analysis phases.",
      "description_length": 793,
      "index": 2422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Value_int",
      "library": "frama-c.kernel",
      "description": "This module implements an integer-based value type with standard operations including equality, comparison, hashing, and pretty printing. It supports conversion to and from strings, deep copying, and project membership checking via user-defined predicates. The type is intended for use in plugin development where typed values must be registered, persisted, or compared within Frama-C's analysis framework.",
      "description_length": 406,
      "index": 2423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations optimized for managing project-specific internal states in Frama-C, using keys that uniquely identify projects and support deep copying, comparison, and pretty-printing. It enables imperative manipulation of key-value pairs, ordered traversal, and safe value retrieval with functions like `find_opt` and `find_def`, facilitating efficient, reproducible computations across multiple concurrent projects. The associated key and value modules extend this functionality by defining project-aware data types with full support for equality, hashing, and skeleton-based membership checks. Use this combination to track analysis results per AST node, synchronize state between projects, or memoize computations based on project-specific inputs.",
      "description_length": 779,
      "index": 2424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLib.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling structured data representations in the kernel. It supports deep copying, membership checks over project skeletons, and provides descriptor metadata for type information and structural inspection. This module is used to manage and manipulate complex data structures that represent internal kernel entities, ensuring consistency and integrity during analysis tasks.",
      "description_length": 502,
      "index": 2425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Model_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's logic environment. It supports values that may contain project-specific data, enabling checks for project membership and deep copying to avoid shared state. Concrete use cases include managing and comparing logic model instances during static analysis, where precise type handling and project isolation are critical.",
      "description_length": 449,
      "index": 2426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module organizes file path-based data mapping with mutable state management, allowing key-value associations between file paths and typed values for tracking analysis results or metadata. It supports operations like filtering by project, comparing and serializing entries, and integrating with plugin parameters through customizable marshaling and validation. The design enables use cases such as synchronizing file-specific data across analysis phases, persisting state changes, and managing configuration with path-aware parameters. Submodules enhance this functionality with specialized handling for string and file path values, along with parameter categorization for plugin configuration.",
      "description_length": 698,
      "index": 2427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for mappings from CIL constants to arbitrary values, supporting insertion, lookup, iteration, and in-place filtering, along with ordered traversal and sequence conversion. Its core data type is a hash table parameterized over `Constant.t` keys, with operations for memoization, conditional extraction, and ordered folding, enabling efficient tracking of relationships between constants and computed data like value ranges or symbolic expressions. The child modules enhance key management with support for equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks, facilitating structured manipulation and analysis of constant values across program points. Together, they enable precise and efficient static analysis workflows involving CIL constants and associated data.",
      "description_length": 861,
      "index": 2428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatRelative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling values related to the `-float-relative` option. It provides utilities to check membership within projects, create deep copies, and manage type descriptors for serialization and introspection. Concrete use cases include analyzing or transforming floating-point relative settings in Frama-C's kernel during static analysis.",
      "description_length": 464,
      "index": 2429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Check.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, along with deep copying and membership testing within projects. It works with a structured type `t` that includes a descriptor, a name, and a list of representatives, supporting introspection and project-specific queries. Concrete use cases include managing and analyzing program representations in Frama-C plugins, such as tracking and comparing analysis states or configurations.",
      "description_length": 481,
      "index": 2430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Int",
      "library": "frama-c.kernel",
      "description": "This module manages integer parameters with range constraints, supporting state tracking, serialization, and equality checks. It allows defining valid value ranges, registering change hooks, and persisting state across sessions, while handling aliased parameters and incremental updates. The abstract type `t` enables structured data representation with comparison, hashing, and pretty-printing, along with descriptors for serialization and project membership checks. Use cases include configuring plugin settings with bounded integers and maintaining validated, persistent state variables with cross-parameter coordination.",
      "description_length": 624,
      "index": 2431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of enumeration information elements (`Enuminfo.t`) with standard set operations (union, intersection, difference, membership checks) and ordered traversal capabilities (reverse iteration, nearest element queries). It supports transformations from sequences and lists, equality comparisons, and analysis-specific utilities like finding elements bounded by a value. These structures are used in static analysis tasks to track or manipulate sets of C enumeration constants while preserving deterministic ordering for predictable processing.",
      "description_length": 573,
      "index": 2432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with lattice-structured values, enabling insertion, removal, lookup, and bulk transformations such as merging and unioning, where values are combined using lattice joins and meets. It supports ordered keys and lattice-equipped value types, facilitating efficient traversal, filtering, and ordered iteration, particularly in static analysis contexts where divergent program paths must be merged. The child modules enhance this functionality by providing support for lattice-aware value operations, including equality, comparison, hashing, and pretty printing, as well as structured key handling with deep copying, membership checks, and type description. Together, they enable concrete use cases like abstract interpretation, where program states with hierarchical or partial-order values are analyzed and merged efficiently.",
      "description_length": 849,
      "index": 2433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AggressiveMerging.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values involved in aggressive merging behavior. It supports equality testing, comparison, hashing, pretty-printing, deep copying, and project membership checks, making it suitable for use in analysis states and value representations. Concrete use cases include tracking and comparing abstract values during static analysis and implementing merge strategies that require structural equivalence checks.",
      "description_length": 496,
      "index": 2434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages and validates string parameters, particularly for command-line arguments with support for aliases, value change hooks, and marshaling. It enforces string validity against constraints like C function name syntax and integrates with kernel state tracking for project-specific configurations. The child module handles `-cpp-extra-args-per-file` parameters, supporting comparison, hashing, and transformation of file-specific compilation flags. Together, they enable precise control over string-based configuration data in static analysis workflows, such as validating function identifiers or managing per-file compiler arguments.",
      "description_length": 646,
      "index": 2435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make.PrinterClass",
      "library": "frama-c.kernel",
      "description": "This module defines a class-based interface for constructing customizable pretty-printers that dynamically bind to an object obtained via `P()`. It provides methods to format and output structured data such as abstract syntax trees, values, or states, typically used during program analysis. Concrete use cases include generating human-readable representations of analysis results or intermediate program states.",
      "description_length": 412,
      "index": 2436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered immutable sets of `Logic_type_ByName` elements, enabling operations like union, intersection, and difference alongside transformations such as mapping and filtering. It supports efficient membership tests, ordered traversal, and conversions to sequences or lists, relying on a total ordering for consistency. These sets are particularly suited for static analysis tasks requiring precise management of logic type collections, such as resolving dependencies or analyzing type hierarchies in CIL-based program representations.",
      "description_length": 555,
      "index": 2437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for efficient key-value storage and retrieval, with support for custom key types, polymorphic values, and functor-based construction. It offers core operations like insertion, deletion, and lookup, along with advanced features such as sorted iteration, memoization, and sequence conversion, enabling use cases like tracking program states or variable associations in static analysis. The key module handles type-safe key management with equality, hashing, and membership checks, while the data module generalizes storage to structured values, supporting analysis scenarios requiring type-preserving mappings. Together, they enable extensible, project-specific data association with integrated pretty-printing, comparison, and ordering capabilities.",
      "description_length": 792,
      "index": 2438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes logic information entries using keys that uniquely identify built-in constructs, supporting efficient lookups, ordered traversal, and structural transformations. It provides operations for inserting, deleting, and mapping over key-value pairs, along with utilities for filtering, merging, and converting from sequences. The key module ensures precise equality, comparison, and pretty printing for identifiers tied to CIL structures, while the value module supports typed data management with deep copying and integration into Frama-C's type system. Example uses include tracking annotations, managing logic definitions during static analysis, and transforming structured data across project skeletons.",
      "description_length": 723,
      "index": 2439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages symbolic path parameters through string manipulation, offering operations to set and validate values against predefined patterns or function names while supporting alias resolution and state persistence. It defines a core data type for symbolic path entries with equality, comparison, and pretty-printing, alongside membership checks and deep copying for use in Frama-C's project structure. With this module, users can configure project-specific path mappings, handle symbolic path transformations, and integrate custom path logic into command-line workflows. Submodules extend these capabilities by enabling type-safe manipulation and analysis of symbolic paths in different contexts.",
      "description_length": 705,
      "index": 2440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation specialized for CIL instruction data, offering efficient storage and retrieval of instruction-related values. It supports key operations like equality, comparison, hashing, and pretty printing, with direct APIs for table manipulation and specialized key handling via its submodules. Users can track analysis results or metadata across specific CIL instructions, enabling fast lookups and updates during static analysis tasks. The combination of generic hash table functionality and instruction-specific key definitions facilitates robust and performant code analysis workflows.",
      "description_length": 626,
      "index": 2441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Stmt.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing and comparing abstract syntax tree (AST) statement differences in a project-aware manner. It supports operations such as equality checking, comparison, hashing, and pretty printing, while ensuring deep copying and proper handling of project-specific data through custom rehashing. It is used to track and analyze changes in C statements across different versions of a project.",
      "description_length": 424,
      "index": 2442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages configuration parameters with multi-value mappings, allowing multiple values per key through operations like addition, iteration, folding, and key-based lookups. It supports command-line options with repeated values, such as multiple `-I` paths, and maintains project-specific configuration states with type-safe, extensible semantics. The core data structure enables deep copying, equality checks, and custom serialization, while submodules organize command-line categories, validate string-based parameters, and enforce constraints during alias resolution. Examples include managing analysis plugin settings, grouping related options under categories like `@default`, and dynamically updating configurations with validated, multibinding inputs.",
      "description_length": 766,
      "index": 2443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Empty_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based plugin parameters with robust support for validation, default values, dynamic updates, and serialization. It introduces key types such as `Typed_parameter.t`, string lists, and an empty string type that ensures safe handling of empty values through operations like equality, comparison, and deep copying. Users can define configurable options with restricted value sets, attach validation callbacks to enforce constraints, and persist settings across sessions. The module enables project-specific state transitions and integrates with Frama-C's plugin system through alias management and project membership checks.",
      "description_length": 647,
      "index": 2444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Set",
      "library": "frama-c.kernel",
      "description": "This module manages ordered collections of CIL locations with operations for set algebra (union, intersection, difference), element-wise transformations, and ordered iteration over elements. It supports efficient membership queries, sequence conversions, and project-aware condition checks, tailored for static analysis tasks like tracking source code regions or analyzing control/data flow in CIL-based programs.",
      "description_length": 413,
      "index": 2445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RemoveExn.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling values that may involve project-specific information, supporting deep copying, equality, comparison, and pretty-printing. It includes functions to check membership based on project projections and provides structured representations for serialization and type description. Use cases include managing and comparing abstract values in static analysis plugins that need to track or remove exceptions.",
      "description_length": 457,
      "index": 2446,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a boolean type `t` alongside utilities for managing boolean values, including equality checks, comparison, hashing, and pretty printing. It supports dynamic configuration through operations to set, retrieve, and monitor boolean parameters, enabling use cases like analysis flags that trigger logic updates or persist state across sessions. Child modules extend core functionality with project-specific membership checks and deep copying, enhancing integration within plugin workflows. Examples include interactive toggles for analysis options and command-line flags that propagate changes through dependent components.",
      "description_length": 639,
      "index": 2447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module offers operations for managing immutable ordered sets of memory zone descriptors, supporting standard set algebra (union, intersection, difference), membership checks, and ordered traversal. It works with elements representing addressable memory regions, enabling efficient queries like nearest-neighbor searches, filtered transformations, and conversions to sequences or lists. Typical use cases include tracking valid memory ranges during static analysis, analyzing overlapping regions, or processing ordered memory states with precise insertion/removal logic.",
      "description_length": 574,
      "index": 2448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides integer-keyed hash tables with efficient insertion, lookup, and iteration over keys of type `Frama_c_kernel.Datatype.Integer.t`, supporting ordered traversal and value-based queries. It enables bulk updates from sequences and memoization, making it suitable for caching computations on integer-identified entities and managing large analysis datasets. Submodule 1 specializes the hash table for a specific value type, adding equality, comparison, and pretty-printing operations, along with deep copying and project membership checks for use in static analysis plugins. Submodule 2 defines the integer key type with hashing, comparison, and inspection functions, enabling precise handling of identifiers like memory locations or symbolic values during analysis.",
      "description_length": 781,
      "index": 2449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Float",
      "library": "frama-c.kernel",
      "description": "This module handles floating-point parameters for command-line interfaces, converting decimal inputs into OCaml `float` values and supporting default values, bounds checking, and change hooks. It includes operations for parsing, comparison, hashing, and pretty-printing, enabling precise configuration of numeric thresholds and tolerances in plugins. Submodules extend this functionality to define specialized float parameter types with standard operations tailored for use in static analysis settings. Example uses include configuring scaling factors or error margins in Frama-C plugins.",
      "description_length": 588,
      "index": 2450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.Domain",
      "library": "frama-c.kernel",
      "description": "This module defines an abstract domain interface for use in the analysis of control flow graphs. It provides operations for joining and widening abstract states, as well as transferring abstract information across edges. The `transfer` function applies edge-specific transformations to abstract values, enabling precise propagation of program properties during abstract interpretation.",
      "description_length": 385,
      "index": 2451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table datatype based on the provided `Data` module, which defines the type of values stored in the table. It implements standard operations such as equality, comparison, hashing, and pretty printing, tailored to the specific value type. Use it to manage collections of typed values with efficient lookup and structural consistency, particularly when integrating with Frama-C's analysis frameworks.",
      "description_length": 424,
      "index": 2452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with character keys and arbitrary values, enabling efficient insertion, deletion, lookup, and ordered traversal. It supports key operations like merging, filtering, and custom formatting, while its key submodule handles character key comparison, hashing, and pretty-printing. The value-specific submodule provides typed maps with deep copying, equality, and integration with analysis systems. Examples include tracking character-based symbol tables, analyzing program states indexed by characters, and building typed, character-indexed collections for static analysis plugins.",
      "description_length": 601,
      "index": 2453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables associated with emitters, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data types with descriptors and representants, enabling precise type handling and introspection. Concrete use cases include managing and querying emitter-specific data in Frama-C plugins, such as tracking and comparing annotated program properties.",
      "description_length": 438,
      "index": 2454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepUnusedFunctions.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing values that represent whether unused functions should be kept during analysis. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and membership checks over project skeletons. It is used specifically to handle the internal state and behavior of the `-keep-unused-functions` option in Frama-C's kernel.",
      "description_length": 398,
      "index": 2455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Share",
      "library": "frama-c.kernel",
      "description": "This module manages the retrieval and validation of directories and files within a plugin's share directory. It provides functions to set and check the share directory path, as well as to resolve specific directories or files by name, ensuring correct type and existence. It is used to access plugin-specific resources such as configuration files or shared data during analysis.",
      "description_length": 378,
      "index": 2456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Offsetmap.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "This module implements over-approximated intersection operations for memory slices represented as interval-to-value maps in bits. It provides two functions: `narrow`, which intersects abstract values without bitwise reinterpretation, and `narrow_reinterpret`, which normalizes values via bitwise reinterpretation before intersection. These operations are used to compute common memory states in abstract interpretation, particularly when merging or comparing value ranges during static analysis.",
      "description_length": 495,
      "index": 2457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables with support for insertion, deletion, lookup, in-place filtering, and iteration, optimized for use with hashconsed keys and values. It enables efficient state management and value caching through customizable ordering, sorted traversal, and memoization, particularly suited for static analysis plugins. The associated key module defines hashconsed key types with equality, comparison, and pretty-printing, facilitating memory-efficient key management and project membership checks. A dedicated submodule builds hash tables over arbitrary data types, ensuring correct handling of equality, hashing, and comparison for fast lookups and state tracking.",
      "description_length": 693,
      "index": 2458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppCommand.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling values related to the `-cpp-command` option's behavior. It includes functions for deep copying values, checking membership based on project predicates, and exposing type-level metadata such as a descriptor and representants. Use cases include managing and manipulating `-cpp-command` configurations in a type-safe manner during kernel development.",
      "description_length": 490,
      "index": 2459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered, immutable sets of CIL offsets with structural equality, supporting operations like union, intersection, and difference alongside iteration, filtering, and mapping. It works with `Offset.t` values representing positions within C structures or arrays, providing efficient membership checks, ordered traversal, and conversions to lists/sequences. Designed for static analysis plugins, it enables precise tracking of offset ranges in CIL code, such as analyzing struct field accesses or array index dependencies.",
      "description_length": 540,
      "index": 2460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Kernel_function.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing kernel functions in the context of computing AST differences. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Use cases include tracking changes to kernel functions across different project versions and ensuring correct handling of project-specific data during diff computations.",
      "description_length": 438,
      "index": 2461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Exp_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for expressions, providing operations for efficient insertion, lookup, and comparison of expression-based keys. It works with the `t` type representing expressions and leverages `Hashtbl`-compatible hashing and equality functions to manage bindings. Concrete use cases include caching analysis results for expressions during static analysis or tracking expression occurrences across different program points.",
      "description_length": 471,
      "index": 2462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Set",
      "library": "frama-c.kernel",
      "description": "This module implements standard set operations\u2014union, intersection, difference, and membership checks\u2014along with transformations like mapping and filtering, all tailored for immutable sets of CIL identified terms. It operates on `Identified_term.t` values, supporting ordered traversal, sequence interconversion, and project-aware comparisons, while maintaining functional purity. These capabilities are particularly useful in static analysis tasks such as tracking term relationships, performing data-flow computations, or managing CIL term hierarchies during Frama-C plugin development.",
      "description_length": 588,
      "index": 2463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_set_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for managing collections of `Stmt.t` values with efficient membership testing and union operations. It provides functions for creating, modifying, and querying sets of statements, including operations like `add`, `remove`, `mem`, and `iter`. The data structure is specifically designed for use in static analysis plugins that track or process CIL statements during Frama-C's analysis phases.",
      "description_length": 435,
      "index": 2464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintComments.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for managing and comparing comment-related values, including operations for equality, comparison, hashing, and pretty-printing. It supports structured data handling with functions for deep copying, membership testing within projects, and provides descriptors for type representation. Concrete use cases include tracking and manipulating comment metadata during code analysis, ensuring accurate and efficient handling of comment persistence and transformation across different analysis phases.",
      "description_length": 524,
      "index": 2465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements a value type for strings within a plugin system, providing essential operations for registration, comparison, serialization, and project membership checks. It works with string-based values that can be converted to and from regular strings, supporting deep copying, pretty printing, and hash-based identity checks. Concrete use cases include storing and managing string configuration values, identifiers, or symbolic representations within Frama-C plugins.",
      "description_length": 479,
      "index": 2466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables that map logic variables to arbitrary values, supporting imperative updates and functional transformations through operations like insertion, deletion, iteration, and folding with customizable key ordering. It provides utilities for safe value retrieval, memoization, and bulk updates via sequences, while enabling type-aware processing through structural descriptions. The module includes a specialized hash table implementation for logic variables with standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project-aware membership checks. These features are used in static analysis plugins to track variable bindings, cache analysis results, and manage symbolic representations during program verification.",
      "description_length": 798,
      "index": 2467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make.PrinterExtension",
      "library": "frama-c.kernel",
      "description": "This module provides functions to extend a pretty-printer with custom formatting rules for specific data types. It operates on abstract syntax trees and semantic objects, enabling precise control over output representation. Use it to define how analysis results or program constructs are displayed in textual interfaces or logs.",
      "description_length": 328,
      "index": 2468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for managing key-value associations where keys uniquely identify CIL-level predicates, supporting operations such as creation, modification, and ordered traversal via `iter_sorted` and `fold_sorted`. It includes safe accessors like `find_opt` and `find_def`, and enables memoization over predicate keys, facilitating efficient tracking of logical assertions or cached analysis results across code transformations. The first child module defines the predicate-identifying keys with equality, comparison, hashing, and pretty-printing, along with utilities for checking valid embedded projects and deep copying. The second child module implements a concrete hash table over these keys with values of type `Data.t`, supporting standard operations and project-specific data management, including `mem_project` and `copy` for handling CIL entities with metadata across analysis phases.",
      "description_length": 923,
      "index": 2469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyTrivialLoops.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing and comparing values used in the loop simplification process. It includes standard equality, comparison, and hashing functions, along with utilities for deep copying and checking project membership. The type `t` is used to represent and manipulate internal states during loop simplification, ensuring correctness and consistency in transformations applied by the `-simplify-trivial-loops` option.",
      "description_length": 456,
      "index": 2470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Make_Table.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table data structure indexed by kernel functions, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with the abstract type `t` representing entries in the table, along with project-aware values through functions like `mem_project` and `copy`. Concrete use cases include associating per-function analysis data with kernel functions and managing project-specific state in a type-safe, hash-based collection.",
      "description_length": 482,
      "index": 2471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Set_project_as_default.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing a set of project representations with support for equality, comparison, hashing, and pretty printing. It includes functions to check membership based on project properties, perform deep copies, and provides descriptors for type handling. Concrete use cases include tracking and manipulating sets of projects in a kernel plugin, ensuring deep copies and precise comparisons.",
      "description_length": 433,
      "index": 2472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map with structural key comparison, optimized for static analysis tasks involving logic functions and their metadata. It supports standard operations like insertion, deletion, merging, and ordered traversal, with keys based on `Logic_info_structural.t` that capture symbol names and argument types under structural equality. Submodules define the key type with comparison, hashing, and pretty-printing, and a map implementation that adds deep copying and project-aware checks. Use it to track type-specific logic bindings or aggregate analysis results across CIL structures with precise symbol identity.",
      "description_length": 640,
      "index": 2473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes finite maps with ordered keys based on logic types, offering operations like insertion, deletion, merging, and ordered traversal while ensuring key ordering consistency. It supports transformations through `map`, `fold`, and `filter`, and integrates pretty-printing and project-aware utilities for managing logic type bindings in static analysis. Submodules specialize the map for specific value types and define key operations including comparison, hashing, and deep copying, enabling precise handling of CIL data structures. Example uses include tracking variable bindings, analyzing type relationships, and transforming logic expressions during program analysis.",
      "description_length": 687,
      "index": 2474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set operations for manipulating collections of abstract memory values (`Cvalue.V.t`), including union, intersection, difference, and ordered transformations like `map`, `filter`, and `fold`. It supports ordered sets with utilities for membership checks, nearest-value queries, and conversions to sequences or lists, while enabling project-specific checks and deep copying. These capabilities are used in static analysis to track and reason about program values, such as merging memory states or filtering possible value ranges during abstract interpretation.",
      "description_length": 579,
      "index": 2475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module manages command-line file path collections with structured operations for setting, retrieving, and tracking changes, supporting custom marshaling and integration with project state. It provides core data types for lists of file paths with utilities for adding, folding, and checking emptiness, along with hooks for updates and deep copying, enabling use cases like handling source file inputs or output directories. Submodules organize file path options into activation-controlled categories and manage string parameters with validation, offering comparison, hashing, and pretty-printing operations. Together, they support building rich command-line interfaces that handle complex file path configurations with persistence and reactive behavior.",
      "description_length": 757,
      "index": 2476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables with specialized key and lattice-based value handling, enabling efficient storage and retrieval of structured data in static analysis contexts. It supports key operations like equality, comparison, and hashing through its key module, while the lattice module extends hash tables to handle values with lattice semantics, including deep copying and project membership checks. Examples include tracking project-specific keys across analysis passes or modeling abstract program states using lattice-valued mappings. Together, these components allow building and manipulating complex, structured hash tables tailored to Frama-C's abstract interpretation framework.",
      "description_length": 692,
      "index": 2477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditPrepare.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership. It supports structured data representation and introspection, primarily used for managing and analyzing abstract data in the context of the `-audit-prepare` option. Concrete use cases include tracking and validating data transformations during static analysis and plugin development.",
      "description_length": 462,
      "index": 2478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module manages sets of function declarations and definitions through a rich set of operations including addition, membership checks, iteration, and folding, while supporting customization via marshaling, aliases, and visibility controls. It provides command-line handling for function sets and string parameters, with utilities for validation, deep copying, and project-aware filtering, enabling precise selection and processing of functions during analysis. Submodules implement core set operations for `Fundec.t`, manage validated string inputs for function names, and organize parameters into categories for structured configuration. Examples include filtering functions for analysis plugins, registering change hooks, and defining category-based option groups like `@default` or `@all` to control behavior.",
      "description_length": 815,
      "index": 2479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in map structures, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports key values that may contain project-specific data, enabling membership checks based on project properties and allowing deep copying to avoid shared references. Concrete use cases include managing and querying key-value pairs in maps where keys must be compared, stored efficiently, or displayed in a human-readable format.",
      "description_length": 483,
      "index": 2480,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Varinfo_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a hash table for `Varinfo` values with standard operations like `add`, `find`, `remove`, and `iter`. Works directly with `Varinfo` keys and arbitrary data values, supporting efficient lookups and mutations. Used to track variable metadata across CIL transformations, such as mapping variables to analysis results or annotations.",
      "description_length": 339,
      "index": 2481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes maps with keys of type `Term.t`, supporting ordered traversal, functional updates, and operations like merge and filter, tailored for static analysis tasks over CIL terms. It includes key management features such as comparison, hashing, and pretty-printing, while its value-specific submodules enable structured storage, deep copying, and type-aware transformations. Examples include tracking variable properties across a project, transforming term-value pairs during analysis, and generating formatted outputs based on key membership or predicate checks. Bidirectional iteration and sequence-based construction further streamline processing in analysis pipelines involving complex term associations.",
      "description_length": 722,
      "index": 2482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module manages sets of kernel functions with operations for addition, membership testing, iteration, and folding over `Frama_c_kernel.Cil_datatype.Kf.Set.t` values. It supports command-line configuration and analysis targeting through categorized option groups, string parameter validation, and semantic-preserving data operations. Submodules enable category-based option control, structural manipulation of kernel function sets, and constrained string parameter handling with project-aware validation. Example uses include restricting analysis to specific functions via CLI flags, grouping plugin options by activation context, and synchronizing string identifiers with evolving project state during analysis.",
      "description_length": 715,
      "index": 2483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides infix operators for monadic composition, specifically designed to handle combined monads with a defined swap function. It supports operations like `>>-`, `let*`, `>>-:`, and `let+` to sequence and transform computations within nested monadic structures. Concrete use cases include managing stateful computations that may fail by combining monads like State and Option, enabling concise and safe error handling with state propagation.",
      "description_length": 454,
      "index": 2484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes logic label\u2013value associations with ordered key handling, enabling efficient insertion, deletion, traversal, and transformation tailored for static analysis tasks. It supports key operations like comparison, hashing, and pretty-printing through its key module, while the data-parameterized map module implements full map functionality for arbitrary value types, including lookup, iteration, and structural equality. You can use it to track label-to-expression mappings during CIL analysis, merge maps with custom predicates, or filter key-value pairs based on analysis needs. The combination of ordered key manipulation and efficient value association makes it ideal for incremental and symbolic processing in static analysis plugins.",
      "description_length": 756,
      "index": 2485,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associations between memory bases and abstract values, enabling precise manipulation of structured memory states through operations like traversal, filtering, and combination. It defines a key type for memory slices with equality, comparison, and pretty-printing, supporting deep copying and membership checks for use in abstract interpretation. The map structure uses these keys to represent memory models in value analysis, supporting operations tailored for static analysis tasks like tracking memory states and merging symbolic execution paths. Concrete applications include managing variable bindings during analysis and transforming memory slices in verification workflows.",
      "description_length": 707,
      "index": 2486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_map",
      "library": "frama-c.kernel",
      "description": "This module manages a stateful key-value map parameter for Frama-C plugins, enforcing unique key bindings and supporting operations like setting, querying, and folding over entries, along with change hooks and default handling. It integrates with key and value modules that enforce ordering and equality constraints, enabling use cases such as tracking analysis results or managing plugin configurations. Submodules provide string-valued parameters with validation and parsing, and parameter categories for grouping and dependency management, supporting features like command-line flags, project-scoped settings, and GUI integration. Together, they enable structured, state-aware data management across plugin analyses with marshaling, aliasing, and dependency-aware updates.",
      "description_length": 775,
      "index": 2487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation with values of type `Data.t`, offering standard operations such as equality, comparison, hashing, and pretty-printing. It supports deep copying, membership checks over project skeletons, and type-level representations for structural manipulation, enabling efficient management of analyzed data collections in static analysis. The key type module extends this functionality by defining keys that may include project-specific data, supporting complex key comparisons and deep copies. Together, they facilitate managing and traversing structured data with customizable, efficient lookups keyed on rich, project-aware values.",
      "description_length": 670,
      "index": 2488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that uniquely identify typed parameters, supporting operations like equality, comparison, hashing, and pretty-printing. It works with abstract key values that may contain project-specific data, enabling checks and transformations over parameter keys. Concrete use cases include managing command-line options with distinct keys, comparing or hashing them efficiently, and filtering keys based on embedded project information.",
      "description_length": 464,
      "index": 2489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes maps keyed by CIL expressions using structural equality, enabling precise tracking and transformation of expression-associated data. It supports construction, ordered traversal, filtering, and aggregation operations over arbitrary value types, including lists, with submodules handling key definition and typed map manipulation. You can, for example, build a map from expressions to value sets, filter entries within a key range, or split maps based on key properties during static analysis. The module facilitates structured data aggregation and ordered processing, essential for tasks like code optimization and value analysis.",
      "description_length": 651,
      "index": 2490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsAutoValidate.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values related to the behavior of the `-asm-contracts-auto-validate` option. It provides access to type information, descriptors, and project membership checks, enabling precise handling of validation states during analysis. Use cases include managing and querying contract validation settings tied to specific projects or configurations.",
      "description_length": 492,
      "index": 2491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations where keys are CIL variable identifiers (`Varinfo.t`) and values can be arbitrary types, supporting insertion, deletion, querying, and ordered traversal. It includes submodules that provide value-specific operations like equality, comparison, and pretty-printing, as well as key-specific utilities for efficient lookups and metadata tracking across analysis phases. Together, they enable structured mappings between program variables and analysis data, such as tracking variable properties or aggregating results in static analysis plugins. Example uses include associating type information with variables, maintaining analysis state across CIL constructs, and custom iteration over variable-centric data.",
      "description_length": 748,
      "index": 2492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides integer-keyed hash tables with imperative and functional operations for insertion, lookup, and in-place transformation, supporting safe value access with defaults and sorted iteration. It includes a key module defining equality, comparison, hashing, and pretty-printing for integer keys, ensuring type-safe key management during static analysis. A value module specializes hash tables for a given data type, providing `equal`, `compare`, `hash`, and `pretty` for stored values, enabling precise equality and deep copying. Together, they support cache-efficient lookups, memoization, and persistent mappings between associative and sequential representations in static analysis plugins.",
      "description_length": 706,
      "index": 2493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps with rich operations for key-value manipulation, structural transformation, and ordered traversal over `'a t` structures, supporting use cases like symbol table management and configuration handling. It provides core operations for bidirectional iteration, sequence conversion with lazy evaluation, and customizable pretty-printing, while integrating specialized submodules for key-specific behavior and integer-indexed data management. The first child module enables working with maps keyed by integers and arbitrary values, offering equality, comparison, and project-aware membership checks for tasks like tracking variable states. The second child module defines key datatypes with equality, comparison, and pretty-printing, supporting advanced key manipulation in static analysis plugins requiring deep copies or project-specific queries.",
      "description_length": 890,
      "index": 2494,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Set",
      "library": "frama-c.kernel",
      "description": "This set module implements an immutable functional API for managing collections of CIL variable descriptors, supporting creation, union/intersection operations, and element-wise transformations. It maintains ordered sets of `Varinfo` elements with efficient membership checks, iteration via folds, and conversion to sequences or lists. Typical applications include static analysis passes requiring precise variable tracking, such as dataflow analysis or transformation pipelines where set operations enable merging variable states or filtering based on analysis criteria.",
      "description_length": 571,
      "index": 2495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module provides an immutable set structure with ordered elements, supporting operations like union, intersection, difference, and ordered traversal, along with transformations such as filtering, mapping, and partitioning. It works with elements of a type equipped with a comparison function (`Ord`), enabling efficient membership checks, ordered enumeration, and nearest-element queries. Use cases include managing finite collections with strict ordering requirements, integrating set operations into dataflow analysis, and bridging set-based and sequence-based data processing pipelines.",
      "description_length": 593,
      "index": 2496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered key-value maps with keys of a specific unit type and polymorphic values, supporting insertion, deletion, lookup, and ordered traversal. It provides utilities for sequence-based construction, bidirectional iteration, and key-driven transformations while preserving structural invariants like key ordering. The first child module specializes this structure for keys of type `Data.t` and values of type `Frama_c_kernel.Datatype.Unit.t`, offering project-aware membership checks and standard operations like equality, comparison, and pretty printing. The second child module defines key datatypes, supporting concrete types like `Project_skeleton.t` with deep copy, comparison, and memory management features, enabling precise key manipulation in static analysis plugins.",
      "description_length": 798,
      "index": 2497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing logic datatypes in Frama-C, equipped with operations for equality, comparison, hashing, and pretty-printing. It provides access to the type's descriptor, name, and representative values, along with deep copying and project membership checks. It is used to manipulate and analyze logic datatype definitions within Frama-C's kernel, particularly during type checking and plugin-specific logic processing.",
      "description_length": 451,
      "index": 2498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic and applicative operators for composing computations that may produce bottom values within a lattice structure. It provides bind and map operations, along with product constructors, for sequencing and combining lattice-bound values. These operations support precise propagation of bottom states in static analysis contexts, such as tracking undefined behavior or uninitialized data in program analysis.",
      "description_length": 430,
      "index": 2499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables that store normalized filepaths, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete use cases such as tracking filepaths in a project-aware context, where keys may contain project-specific information and must be compared or stored efficiently. Functions like `mem_project` allow filtering keys based on associated project data, and `copy` ensures deep copies of keys for safe manipulation in different contexts.",
      "description_length": 522,
      "index": 2500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppGnuLike.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling C++-like data representations under the `-cpp-frama-c-compliant` option. It supports structured data manipulation with deep copying, membership testing on projects, and type descriptors for introspection and serialization. Concrete use cases include analyzing and transforming C++ code elements within Frama-C, such as tracking type definitions and ensuring consistent data handling across analysis passes.",
      "description_length": 536,
      "index": 2501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table data structure with custom key types, supporting operations like equality, comparison, hashing, and pretty-printing. It works with project-aware data types that may contain embedded project identifiers, enabling checks and transformations tied to specific project contexts. Concrete use cases include managing stateful mappings where keys must be compared, hashed, or filtered based on project membership, and ensuring deep copies with no shared references.",
      "description_length": 498,
      "index": 2502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling generated specification customizations. It provides access to type descriptors, structural representations, and utilities for project membership checks and deep copying. Concrete use cases include managing and manipulating abstract syntax tree nodes or analysis artifacts that require structural equality and efficient traversal.",
      "description_length": 459,
      "index": 2503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables for mapping C function definitions (`Fundec.t`) to arbitrary data, supporting insertion, lookup, iteration, and in-place updates, along with ordered traversal and bulk operations using custom comparisons. It enables efficient function-centric data management in Frama-C plugins, such as memoizing analysis results or transforming C code based on structured key-value associations. The first child module defines a key type for function declarations, providing equality, comparison, and hashing to ensure safe and efficient key handling during static analysis tasks like function tracking. The second child module generates hash tables for arbitrary data types, offering structured storage and retrieval of values associated with CIL functions, supporting efficient processing of function-specific information in analysis plugins.",
      "description_length": 875,
      "index": 2504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for managing polymorphic values indexed by keys conforming to `Frama_c_kernel.Datatype.Unit.t`, enabling creation, insertion, deletion, and safe lookups, along with ordered iteration and bulk updates via customizable comparison functions. The key module defines structured keys with equality, hashing, and project membership checks, while the table module builds a typed hash table structure supporting efficient storage and retrieval of values such as analysis results. Together, they allow operations like memoizing function results based on structured keys, traversing tables in custom order, or integrating with Frama-C's type system for key-driven data analysis. Key-based traversal, deep copying, and project-scoped queries are supported through the combined use of key and table modules.",
      "description_length": 827,
      "index": 2505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype based on a given value datatype, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module, organizing values into a map structure. Concrete use cases include managing collections of typed values with efficient lookups and transformations, such as tracking variable bindings or analysis results in static analysis plugins.",
      "description_length": 445,
      "index": 2506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module extends OCaml's hashtables to manage associations between memory zones and arbitrary values, supporting deterministic iteration, safe lookups, sequence-based updates, and custom ordered traversal. It provides key operations like `find_opt`, `find_def`, `memo`, and statistical analysis tools, all tailored for precise memory zone tracking in static analysis. The child modules define zone keys with bit-range semantics and a specialized hash table for `Data.t` values, enabling efficient, project-aware manipulation of memory region mappings. Examples include tracking variable allocations, performing alias analysis, and processing data flow over memory zones.",
      "description_length": 673,
      "index": 2507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing loadable kernel modules with operations for equality, comparison, hashing, and pretty-printing. It supports structured values through a descriptor system, allowing deep copying, membership checks over project skeletons, and serialization via packed descriptors. Concrete use cases include managing and comparing module configurations during command-line processing and plugin loading.",
      "description_length": 433,
      "index": 2508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables keyed by properties ordered by function criteria, supporting imperative operations like insertion, lookup, and in-place modification, along with ordered iteration and folding using custom comparators. It provides core data types such as `t` for the table itself, `key` representing structured property identifiers including function name and property ID, and `Data.t` for associated values, enabling precise handling of static analysis artifacts. Operations include equality checks, hashing, pretty-printing, and deep copying, facilitating integration into Frama-C plugins for tasks like tracking function-specific invariants or aggregating analysis results. Submodules refine this structure by defining key semantics and value types, ensuring consistent and project-aware property-based mappings.",
      "description_length": 832,
      "index": 2509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables optimized for managing CIL model information, supporting key operations like insertion, lookup, and iteration with efficient, type-safe manipulations. It includes a key module for equality, comparison, and hashing tailored to CIL structures, enabling precise identification and management of model data during static analysis. A specialized hash table module builds on these keys, offering type-specific operations for storing and transforming CIL-based values in Frama-C plugins. Together, they facilitate tasks like tracking analysis results, memoizing transformations, and maintaining structured model information across program verification stages.",
      "description_length": 696,
      "index": 2510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Enum",
      "library": "frama-c.kernel",
      "description": "This module manages enumerated types with a fixed set of values, supporting operations to set, query, and persist values while allowing command-line integration and change hooks. It works with variant types that have structural equality, enabling use cases like analysis modes or configuration options in plugins. The module provides direct access to value manipulation and parsing, while child modules enhance these capabilities with equality, comparison, and pretty-printing for variant-based enums. For example, it can represent sensitivity levels in a plugin, expose them via command-line flags, and store their state across sessions.",
      "description_length": 638,
      "index": 2511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype with values from `Domain` extended by a top element, supporting lattice operations. It provides equality, comparison, hashing, pretty-printing, and deep copying for these values, along with a way to check membership based on project properties. It is used to represent and manipulate lattice elements that may include a maximal value, enabling precise static analysis in domains like program verification.",
      "description_length": 439,
      "index": 2512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations `iter` and `map` for processing values within an `option` context, producing results in a monadic type `t`. It enables chaining computations that handle optional values, where each function applies a monadic effect to the contents of an `option`. Use cases include safely processing potentially missing data while accumulating effects, such as logging or state updates, without unwrapping the option manually.",
      "description_length": 449,
      "index": 2513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FramaCStdLib.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with descriptors and representants for structural inspection. It supports deep copying and project membership checks, enabling precise manipulation and analysis of data structures within Frama-C's kernel. Concrete use cases include managing and comparing abstract values during static analysis and implementing data representations that integrate with Frama-C's internal project model.",
      "description_length": 499,
      "index": 2514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Session",
      "library": "frama-c.kernel",
      "description": "This module manages the session directory for a plugin, providing functions to retrieve or create directories and files within the session context. It works with file paths represented by `Frama_c_kernel.Filepath.t` and allows setting and querying a user-defined directory. Concrete use cases include storing plugin-specific session data, such as intermediate files or logs, during analysis.",
      "description_length": 391,
      "index": 2515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered associative maps with keys of type `Frama_c_kernel.Machdep.Machdep.t` and polymorphic values, enabling efficient insertion, deletion, lookup, and ordered traversal. It supports advanced operations such as key-range queries, bidirectional iteration, and structural comparison, making it suitable for managing platform-specific configurations and optimizing analysis pipelines. The key module provides essential operations like equality, comparison, and hashing for key values, while the data-specialized submodule enables precise control over value representation and comparison logic. Together, they facilitate tasks such as tracking machine-dependent key-value mappings, performing project membership checks, and generating ordered diagnostic outputs.",
      "description_length": 783,
      "index": 2516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes logic types using ordered keys derived from CIL type names, enabling structured associations between type names and arbitrary data. It supports core operations like insertion, deletion, traversal, and transformation, along with comparisons, filtering, and custom formatting, making it ideal for static analysis tasks that require ordered, type-safe mappings. Submodules refine key behavior with equality, hashing, and pretty-printing tailored to logic type names, while the main module enables bulk operations and conversions to lists or sequences for flexible data processing. Example uses include tracking type definitions across program modules and synchronizing logic type metadata during analysis passes.",
      "description_length": 731,
      "index": 2517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Bound_Lattice",
      "library": "frama-c.kernel",
      "description": "This module implements a semi-lattice structure where elements are either values of a wrapped lattice type or bottom. It provides lattice operations including `join` for over-approximating unions, `is_included` for inclusion checks, and standard data operations like `equal`, `compare`, and `pretty`. It is used to represent and manipulate abstract values in static analysis where the bottom element denotes an undefined or minimal state.",
      "description_length": 438,
      "index": 2518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables mapping hash-consed tree keys to arbitrary values, supporting insertion, deletion, lookup, and in-place filtering, with advanced iteration, folding, and sorting over structured key-value pairs. It provides a hash table type with standard operations including equality, comparison, hashing, and pretty printing, alongside utilities for memoization, safe value extraction, and conversion to structured representations. The key type supports deep copying, introspection via descriptors, and project-specific filtering through membership checks, enabling precise data-flow tracking and analysis in static analysis plugins. Example uses include mapping abstract syntax trees to analysis results or annotations, and managing dynamic mappings in compiler optimizations.",
      "description_length": 808,
      "index": 2519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered finite maps keyed by `OffsetStructEq.t` values, offering insertion, deletion, ordered traversal, and transformation operations. It includes a key module that defines structural equivalence for keys, supporting deep comparisons and project-specific data handling, alongside a data module that provides value storage and type-specific operations like equality and hashing. Together, they enable efficient, deterministic processing of structured data in static analysis tasks, such as tracking memory offsets or CIL program elements with guaranteed key ordering and deep integrity checks. Example uses include analyzing and transforming CIL-based code by associating structured annotations with memory offsets and querying them efficiently.",
      "description_length": 765,
      "index": 2520,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for `Term_lhost.t` values, a CIL type representing term left-hand sides in Frama-C's analysis framework. It supports efficient membership queries, set algebra (union, intersection, difference), ordered traversal, and transformations via functions like `map` and `filter`, alongside utilities for proximity searches (`nearest_elt_ge`, `nearest_elt_le`) and integration with Frama-C's plugin system. Typical use cases include static analysis tasks requiring precise tracking and manipulation of term-level memory locations or symbolic expressions in C code verification.",
      "description_length": 614,
      "index": 2521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables with keys of type `Option_with_collections.t`, supporting imperative and functional operations like insertion, lookup, in-place modification, and ordered iteration via custom comparisons. It includes a key module for handling equality, hashing, and pretty-printing of keys, enabling efficient lookups and human-readable key representations, useful for managing unique identifiers or dynamic collections. A separate submodule specializes in integer-keyed tables with structured values, ideal for fast access to analysis results or identifier mappings. Together, these components enable memoization, ordered key-value processing, and efficient data management in static analysis workflows.",
      "description_length": 720,
      "index": 2522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for key-value storage with support for ordered iteration, folding, and in-place filtering, leveraging key constraints for equality and hashing. It introduces main data types like `t` for keys and `'a Hashtbl.t` for hash tables, offering operations such as insertion, lookup, deletion, and conversion to and from sequences. With child modules handling key definitions and typed hash table instantiations, it enables structured key management, deep copying, and typed collections useful for static analysis tasks like memoizing program element states or processing structural data. Examples include tracking variable states across program points, managing function annotations, or implementing efficient, ordered caches in Frama-C plugins.",
      "description_length": 780,
      "index": 2523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value maps with ordered key handling, supporting insertion, deletion, traversal, and structured transformations like merge and filter. It defines core operations over maps parameterized by key and value types, enabling efficient lookups, dependency tracking, and ordered queries such as range-based iteration. The key module defines typed keys with comparison, hashing, and pretty-printing, while the data module implements parameterized maps with deep copying, equality, and serialization. Example uses include tracking variable bindings, analysis results, or project-specific attributes in static analysis plugins with ordered and structured key-value management.",
      "description_length": 689,
      "index": 2524,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent, ordered set data structure for managing collections of CIL types that avoid structural unrolling during comparison. It supports standard set operations like insertion, deletion, union, and intersection, along with iteration, filtering, and transformations, while preserving immutability and order. The set is particularly useful for analyzing or manipulating C code structures (e.g., structs, arrays) in Frama-C plugins, where type equality checks and nearest-element queries are required without recursively expanding composite types.",
      "description_length": 570,
      "index": 2525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module extends hash table functionality by introducing specialized operations for in-place filtering, sequence-based input/output, and customizable iteration order, centered around a key type `t`. It supports advanced transformations such as memoization and safe lookups, while integrating structured type representations for keys and values, including equality, comparison, and pretty-printing. Submodules provide dedicated support for key management with deep copying and membership checks, and for handling hash tables with structured values in static analysis plugins. Example uses include tracking key values across analysis states and managing hash tables with rich value types in Frama-C extensions.",
      "description_length": 711,
      "index": 2526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module provides persistent set operations for managing CIL component information (`Compinfo.t`), including union, intersection, difference, and ordered traversal via sorted representations. It supports efficient querying, predicate-based filtering, and conversions between sets, lists, and sequences, while enabling project-specific element filtering and structured data manipulation for tasks like static analysis or code transformation workflows.",
      "description_length": 453,
      "index": 2527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a rich set of ordered set operations including element manipulation, transformation, and ordered traversal, working with sets of totally ordered elements via the `Ord` module. It supports advanced set-theoretic operations like lattice-consistent union/intersection, nearest-neighbor queries, and sequence conversions while maintaining structural invariants. These capabilities are particularly useful for static analysis tasks requiring precise set-based abstractions with ordered domains, such as value range tracking or dependency analysis in program verification.",
      "description_length": 587,
      "index": 2528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive library for manipulating immutable sets of comparable elements, supporting operations like union, intersection, difference, ordered traversal, and monotonic predicate-based filtering. It relies on a total ordering relation for element comparison and works with sets represented as `Set.t` values containing elements of type `Set.elt`. Typical use cases include static analysis tasks requiring efficient set-theoretic computations, ordered data processing, and scenarios where elements must be tested for membership, transformed via mapping, or aggregated into lists/sequences.",
      "description_length": 613,
      "index": 2529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations `iter` and `map` for the `option` type, enabling effectful traversal and transformation of optional values. It supports use cases like chaining computations that may fail or produce side effects, handling optional results within a monadic context.",
      "description_length": 287,
      "index": 2530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Set",
      "library": "frama-c.kernel",
      "description": "This module offers immutable ordered set operations for elements of type `elt`, supporting creation (e.g., `empty`, `singleton`), modification (e.g., `add`, `union`), and queries (e.g., `mem`, `cardinal`). It maintains elements in sorted order using a comparison function and provides transformations like `map`, `filter`, and `fold`, along with conversions to/from lists and sequences. It is particularly useful for static analysis plugins requiring efficient set algebra, ordered data processing, or iterative computations over structured program states.",
      "description_length": 556,
      "index": 2531,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and manipulating ordered sets of logic constructor information, supporting standard set operations like union, intersection, and difference, as well as ordered iteration, filtering, and element-wise transformations. It includes utilities for sequence conversion, reverse traversal, nearest-element queries (e.g., `nearest_elt_ge`), and type-safe comparisons, equality checks, and hashing. These capabilities are particularly useful in static analysis scenarios for managing logic expressions, such as tracking constructor usage or validating structured invariants in CIL-based code transformations.",
      "description_length": 647,
      "index": 2532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Zero",
      "library": "frama-c.kernel",
      "description": "This module manages integer configuration options with support for validation, default values, command-line integration, and state persistence, enabling plugin parameters that enforce constraints and adapt to changes. It provides types and operations for defining options with bounds, change handlers, and deprecation policies, while its child module enhances plugin data management with equality, comparison, and serialization for custom types. Examples include tracking analysis state within plugins, enforcing valid integer ranges for configuration flags, and maintaining backward compatibility when renaming deprecated options. Together, they support robust, extensible configuration handling and structured data manipulation in Frama-C plugins.",
      "description_length": 749,
      "index": 2533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice.With_Cardinality",
      "library": "frama-c.kernel",
      "description": "This module provides operations to compute and constrain the cardinality of map bindings, where each value has a lattice structure and keys may represent summaries of multiple keys. It includes functions to check if a map has zero or one element, safely subtract maps, fold over enumerated elements, and find unique bindings under specific conditions. These operations are used to reason about the size and contents of maps in abstract interpretation contexts, particularly when handling summarized or merged keys.",
      "description_length": 514,
      "index": 2534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Debug",
      "library": "frama-c.kernel",
      "description": "This component manages debug-level integer parameters for Frama-C plugins, supporting operations to set, query, and validate values within defined ranges, along with change notifications. It centers around the `Debug.t` type for state variables and integrates with `Project.t` and `State.t` for project-specific state management. The child module enhances this functionality by providing structured data handling with descriptors and deep copying, enabling complex data representation and persistence. Examples include parsing and validating command-line options, dynamically adjusting parameters via hooks, and serializing debug settings across analysis sessions.",
      "description_length": 664,
      "index": 2535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Frama_c_builtins.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating built-in function data during CIL processing. It includes utilities for deep copying values, checking membership based on project conditions, and managing type descriptors for serialization and representation. Concrete use cases include tracking and comparing built-in function metadata during static analysis and ensuring consistent handling of function representations across different analysis phases.",
      "description_length": 555,
      "index": 2536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable set interface with operations for standard set algebra (union, intersection, difference), ordered element queries (min, max, nearest elements), and transformations (filtering, mapping, folding). It leverages a Patricia tree structure with compositional boolean tracking over hash-consed tree keys, using big-endian bit ordering for efficient comparisons. The design supports use cases requiring precise set manipulation in static analysis tasks, such as tracking hierarchical data dependencies or performing range-based queries on structured keys.",
      "description_length": 583,
      "index": 2537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages string-keyed maps with multiple values per key, supporting command-line options and configuration parameters with change tracking, aliases, and custom marshaling. It provides core operations for setting, querying, and iterating over key-value lists, while integrating with project state and kernel APIs for persistence across sessions. Submodules handle category-based grouping of options, define parameter behaviors for different contexts, and support string-based values with comparison and pretty-printing utilities. Example uses include command-line parsers accepting repeated flags, hierarchical configuration systems, and analysis tools requiring structured parameter handling.",
      "description_length": 703,
      "index": 2538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables keyed on logic real numbers, providing operations for creating, modifying, and traversing tables with deterministic ordering and efficient lookups. It supports memoization, folding, and conversion to and from sequences, enabling caching of computed values during static analysis and structured processing of CIL data. The key module defines logic real-based identifiers with equality, comparison, and hashing, allowing precise key management for analyses requiring exact value tracking. A value-specializing submodule enables building hash tables over arbitrary data types, offering deep copies, project-aware membership, and efficient serialization for use in CIL-based analyses.",
      "description_length": 715,
      "index": 2539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associations between CIL code annotations and structured data, enabling functional updates, ordered traversal, and transformations while preserving key order during iteration. It provides core operations like conditional search, bulk insertion, filtering, and partitioning, with keys identifying specific CIL elements and values supporting structured data manipulation. Child modules define annotation-based keys with comparison and hashing capabilities, and specialize maps for data modules with equality and pretty printing. Examples include tracking analysis metadata across CIL statements or maintaining versioned mappings of annotated code elements during static verification.",
      "description_length": 709,
      "index": 2540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a functional interface for ordered sets of wide strings, supporting operations like union, intersection, difference, and transformations via `map` and `filter`. It works with immutable sets containing `Frama_c_kernel.Cil_datatype.Wide_string.t` elements, emphasizing ordered traversal, membership queries, and conversions to/from lists or sequences. It is particularly useful in static analysis scenarios requiring precise handling of wide string collections, such as tracking unique string literals or managing ordered identifier sets in C code.",
      "description_length": 565,
      "index": 2541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes heterogeneous maps keyed on kernel function sets and individual kernel functions, enabling structured association of arbitrary data with precise scoping to functions or function groups. It supports key operations like insertion, filtering, and merging, with specialized submodules handling set-based keys for grouped function metadata and function-specific data attachment. Users can, for example, map analysis results to sets of functions sharing a property or attach per-function annotations during static analysis. The design combines ordered key manipulation with type-safe value storage, facilitating efficient, scoped data management across different analysis contexts.",
      "description_length": 697,
      "index": 2542,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.TP",
      "library": "frama-c.kernel",
      "description": "This module provides graph query and traversal operations for directed graphs, enabling checks for vertex and edge existence, adjacency tests, and degree calculations. It supports labeled vertices and edges through its submodules, where vertices carry identifiers for comparison and hashing, and edges connect two vertices with directional labels. Operations include folding over vertices and edges, transforming graph elements, and computing reachability or dependency chains in callgraphs. These capabilities facilitate static program analysis, dependency tracking, and Graphviz-based visualization workflows.",
      "description_length": 611,
      "index": 2543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Domain",
      "library": "frama-c.kernel",
      "description": "This module defines an abstract domain for analyzing unrolled unnatural loops in control flow graphs. It provides operations to merge states (`join`), apply widening (`widen`), and propagate abstract values across edges (`transfer`). The domain works with abstract states (`t`) and is used to compute reachable states in programs with modified loop structures.",
      "description_length": 360,
      "index": 2544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of type `Frama_c_kernel.Rational.t`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports creation, lookup, and manipulation of rational number mappings while ensuring deep copying and project-aware membership checks. Concrete use cases include managing symbol tables and caches in static analysis plugins where rational numbers serve as keys or values.",
      "description_length": 461,
      "index": 2545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.ForwardAnalysis.Result",
      "library": "frama-c.kernel",
      "description": "This module provides access to the results of a forward dataflow analysis on an interpreted automaton, allowing retrieval of analysis states at specific control points such as function entry, return, and before or after individual statements. It supports iteration over analysis results either per vertex or per statement, in arbitrary or statement-id order, and offers output facilities to visualize results in DOT format. Concrete use cases include inspecting abstract states at specific program points, generating control-flow graphs annotated with analysis data, and debugging or validating the effects of abstract interpretation passes.",
      "description_length": 641,
      "index": 2546,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Filepath",
      "library": "frama-c.kernel",
      "description": "This module provides operations to retrieve, set, and manage file path parameters for plugins, using the `Frama_c_kernel.Filepath.t` type. It allows checking whether a parameter is set or uses its default value, and supports clearing parameters. Concrete use cases include configuring input/output file paths for analysis plugins or setting log file destinations dynamically.",
      "description_length": 375,
      "index": 2547,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with character keys, offering creation, insertion, lookup, deletion, iteration, and conversion to sequences. It provides key operations through a dedicated key module that handles equality, comparison, hashing, and pretty-printing, ensuring efficient lookups and project-aware management for symbol tables or caching. The value module allows storing and manipulating type-specific data indexed by characters, supporting deep copies and project membership checks. Examples include tracking variable symbols in analysis plugins or mapping characters to custom metadata in a type-safe, ordered manner.",
      "description_length": 633,
      "index": 2548,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AllowDuplication.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for handling values that can be duplicated, with support for equality checks, comparison, hashing, and pretty printing. It works with a custom type `t` that represents structured data involving projects, allowing deep copies and membership checks over project skeletons. Concrete use cases include managing and comparing analysis states or configurations that include project-specific data under the `-allow-duplication` behavior.",
      "description_length": 488,
      "index": 2549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, specifically tailored to handle integer sets from the `Int_set` module. It provides standard operations such as equality, comparison, hashing, and pretty printing, ensuring proper handling of set values as keys. Use cases include efficiently storing and retrieving integer sets in hash tables, particularly when managing small sets that may transition to intervals.",
      "description_length": 420,
      "index": 2550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool.Map",
      "library": "frama-c.kernel",
      "description": "This module implements persistent maps over hash-consed keys using big-endian Patricia trees, enabling efficient key-based operations such as insertion, deletion, union, and ordered traversal. It supports specialized transformations and compositional boolean tracking per node, making it suitable for formal verification tasks like symbolic execution and abstract interpretation. The main data types include hash-consed tree keys and map values, with operations for equality, comparison, hashing, pretty printing, and deep copying. Specific uses include tracking value flow, managing structured state, and performing precise key-increasing traversals in static analysis workflows.",
      "description_length": 680,
      "index": 2551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module supports creation and manipulation of ordered sets containing constants with strict comparison semantics, enabling operations like union, intersection, difference, and ordered traversal while preserving textual representation-based equality. It provides structural transformations (filtering, partitioning, mapping), nearest-element queries, and conversions to sequences or lists, all operating on sets of constants where lexical forms dictate ordering. Such functionality is particularly useful in static analysis tasks requiring precise tracking of constant ranges, deterministic merging of value sets, or validation of strict equality constraints in program contexts.",
      "description_length": 682,
      "index": 2552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with 64-bit integer keys and arbitrary value types, supporting efficient insertion, lookup, and ordered traversal, along with bulk updates and memoization. It provides core operations like mapping, folding, and filtering, with safe access patterns via optional return types and higher-order functions, enabling deterministic traversal and aggregation of sequential data. The first child module specializes the hash table for structured values, supporting deep copying, equality checks, and pretty printing, ideal for static analysis tasks like tracking abstract states or value ranges. The second child module handles 64-bit integer keys with comparison, hashing, and membership operations, facilitating management of numeric identifiers in analysis plugins.",
      "description_length": 793,
      "index": 2553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps for associations between integer-like keys and arbitrary values, emphasizing precise control over key ordering during insertion, traversal, and transformation. It supports operations such as ordered iteration, bounded search, monotonic filtering, and bulk updates, with key data types offering equality, comparison, hashing, and pretty printing. Submodules provide concrete integer-indexed map structures and dedicated key types, enabling tasks like tracking variable values across program states or managing symbolic keys in abstract interpretation lattices. Specific applications include static analysis domains where integer keys represent symbolic identifiers or memory offsets requiring strict ordering for lattice computations.",
      "description_length": 769,
      "index": 2554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` operations to retrieve validated directory or file paths within the site, ensuring correct type and existence. It is used to manage hierarchical file paths in Frama-C's configuration system, particularly for locating resources like plugins or libraries during initialization.",
      "description_length": 394,
      "index": 2555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kinstr_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for a specific data type, providing operations to store, retrieve, and manage values with efficient lookups. It works with a structured data type `t` that includes equality, comparison, and hashing capabilities, along with project membership checks and deep copying. Concrete use cases include caching analysis results tied to specific project states or managing stateful transformations during static analysis passes.",
      "description_length": 454,
      "index": 2556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCppCommands.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values related to the `-print-cpp-commands` option in Frama-C's kernel. It supports equality checks, comparison, hashing, pretty-printing, deep copying, and project membership testing, enabling precise handling of configuration or command data. Concrete use cases include managing and querying internal representations of preprocessor command-line arguments during analysis.",
      "description_length": 466,
      "index": 2557,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.Vertex_Set",
      "library": "frama-c.kernel",
      "description": "This module represents sets of control flow graph vertices in unrolled, loop-normalized graphs, supporting standard set operations, membership checks, and project-aware queries. It enables deep copying, hashing, and precise manipulation of vertex neighborhoods during abstract interpretation tasks like loop analysis and path-sensitive state tracking. Child modules extend its functionality with vertex-to-data mappings, vertex-set-based key-value storage, and ordered immutable set operations, enabling efficient traversal, merging, and transformation of vertex-associated information. Specific uses include caching computed states, tracking transitions in interpreted automata, and performing nearest-neighbor queries over control flow vertices.",
      "description_length": 747,
      "index": 2558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.C11.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling C11-specific data representations. It provides access to type descriptors, structural descriptions, and utilities for deep copying and project membership checks. It is used to manage and manipulate C11 datatype definitions and their properties within the Frama-C kernel.",
      "description_length": 400,
      "index": 2559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Verbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating verbose datatype representations, including equality checks, comparison, hashing, and pretty-printing. It works with structured data types that include descriptors, project skeletons, and representants, supporting deep copying and membership queries over project data. It is used to handle complex data representations in kernel extensions, particularly for analysis and transformation tasks involving structured values with project dependencies.",
      "description_length": 507,
      "index": 2560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Zero",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and management of integer-based command-line parameters with range constraints, supporting initialization, comparison, increment/decrement, and state change hooks. It operates on integer values augmented with metadata for validation, serialization, and project state tracking, allowing plugins to define numeric configuration options with custom update logic and persistent behavior. The child module provides concrete implementations of equality, comparison, and pretty-printing for these values, enabling deep copying, structural manipulation, and user-friendly display. Together, they support defining a parameter like `-my-interval 5` with min/max validation, automatic persistence across analysis sessions, and custom actions on value changes.",
      "description_length": 781,
      "index": 2561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable functional interface for ordered sets of source code positions, enabling operations like union, intersection, difference, and ordered iteration while preserving structural sharing. It supports specialized queries for nearest elements (`nearest_elt_le`, `nearest_elt_ge`), project-specific membership checks (`mem_project`), and conversions to sequences, all tailored for analyzing C code locations. These sets are used in static analysis to track and manipulate file positions during tasks like error tracing, code slicing, or project modularization.",
      "description_length": 586,
      "index": 2562,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Keep_unused_types.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing structured data representations. It provides functions for equality checks, comparison, hashing, pretty-printing, and deep copying, along with accessors for type descriptors and representants. This module is used to handle complex data structures that must be persisted or analyzed independently, such as when implementing custom data analyses or transformations in Frama-C plugins.",
      "description_length": 471,
      "index": 2563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath.Category",
      "library": "frama-c.kernel",
      "description": "This module manages symbolic path categories, which are used to classify and control the behavior of symbolic paths in Frama-C. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, each influencing how symbolic paths are interpreted during analysis. Use cases include configuring analysis options via command-line flags and controlling the propagation of symbolic execution paths in static analysis plugins.",
      "description_length": 463,
      "index": 2564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes structured key-value mappings where keys are CIL l-values compared by structural equality, offering insertion, deletion, traversal, and transformation operations optimized for static analysis tasks like variable tracking and memory state modeling. It includes a key module defining structured values with equality, comparison, and pretty-printing, used to uniquely identify analysis artifacts, and a map implementation that uses these keys to manage value associations with support for iteration, comparison, and serialization. You can use it to build precise alias analysis models by mapping l-values to memory regions or track variable bindings during symbolic execution. The combination of structural key handling and map transformations enables efficient, ordered analysis state management across C program traversals.",
      "description_length": 844,
      "index": 2565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module implements persistent ordered key-value maps with functional update semantics, supporting efficient insertion, deletion, and ordered traversal operations. It enforces comparable key types and provides operations for map combination, min/max binding retrieval, and structural comparison, enabling tasks like ordered scope resolution and data flow tracking. The key module defines structured key types with equality, comparison, and pretty printing, used to manage symbolic identifiers in analyses. The value module builds map types with full equality and comparison support, facilitating structured printing and deep copying of maps used in static analysis plugins for managing abstract states and identifiers.",
      "description_length": 721,
      "index": 2566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent map structure for key-value associations using logic type identifiers from CIL, enabling ordered traversal, bulk transformations, and analysis-specific operations such as merging symbol tables and tracking type constraints. It supports efficient physical equality checks and ordered key comparisons, facilitating incremental updates during static analysis passes. The child modules specialize the map for logic types without unrolling, offering standard operations like equality, hashing, and pretty-printing, while defining keys that ensure structural and semantic integrity when working with CIL types, projects, and descriptors. Examples include managing type-value mappings in analysis plugins and tracking logic type keys for precise static analysis in Frama-C.",
      "description_length": 800,
      "index": 2567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String_set",
      "library": "frama-c.kernel",
      "description": "This module manages string sets for command-line configuration, offering operations to add, query, and iterate over elements with support for dynamic updates, serialization, and project-specific state. It includes a core string set data type with membership testing, comparison, and pretty-printing, enabling structured handling of sets as configuration options or analysis parameters. A category system organizes options into groups like `@none`, `@default`, and `@all`, allowing dependency management and global behavior control. Use cases include defining validated CLI options, managing include paths or macro definitions, and structuring analysis configurations with set-based logic.",
      "description_length": 688,
      "index": 2568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.WTO",
      "library": "frama-c.kernel",
      "description": "Implements the Bourdoncle algorithm to compute weak topological orderings (WTOs) for control flow graphs, using a partitioning strategy based on node precedence. Operates on graph nodes and components, providing functions to pretty-print and compare these structures. Useful for optimizing abstract interpretation by structuring chaotic iterations with widenings over control flow graphs derived from CIL code.",
      "description_length": 410,
      "index": 2569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages a key-value structure where each key maps to multiple values, supporting additions, queries, and transformations with typed keys and value lists. It integrates with command-line interfaces and tracks state changes, making it ideal for plugin configurations with repeated arguments or dynamic analysis tools. Submodules handle parameter categories, string-based configurations with validation, and polymorphic maps with type-safe introspection, enabling use cases like enforcing valid options, persisting plugin state, and defining global category behaviors. Operations include folding, membership checks, marshaling, and semantic interpretation across multivalued mappings.",
      "description_length": 693,
      "index": 2570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filepath",
      "library": "frama-c.kernel",
      "description": "This module manages file path configurations for Frama-C plugins, supporting operations such as setting, retrieving, and validating paths, registering change callbacks, and handling command-line integration and persistence. It works with `Frama_c_kernel.Filepath.t` values, which encapsulate path data and enforce correctness constraints, and includes functions for comparing, hashing, and pretty-printing these values. Submodule functionality extends path handling with project-aware operations like `mem_project`, enabling plugins to manage file path state consistently across sessions. Example uses include tracking analysis input paths, synchronizing configuration changes, and ensuring valid path usage during plugin execution.",
      "description_length": 732,
      "index": 2571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.TypeCheck.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing and manipulating type-checking entities in the kernel, supporting operations like equality, comparison, hashing, and pretty-printing. It works with structured descriptors, type representations, and project-based values, enabling precise type analysis during semantic checks. Concrete use cases include validating type consistency in C code during analysis and managing type representations in plugins.",
      "description_length": 450,
      "index": 2572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Map",
      "library": "frama-c.kernel",
      "description": "This module manages hash-consed maps with ordered keys, offering standard associative operations like insertion, lookup, and removal, alongside advanced merging, filtering, and ordered traversal. It supports immutable transformations and physical equality checks, with customizable pretty-printing and sequence conversions. The key module defines hash-consed key types with comparison, hashing, and project-aware checks, enabling canonical key representations, while the value module pairs these keys with arbitrary data types in a hash-consed map structure, supporting deep copying and project membership checks. Examples include tracking state configurations in static analysis, combining symbolic data, and processing ordered key-value collections in functional pipelines.",
      "description_length": 775,
      "index": 2573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Float_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float reference datatype with operations for equality, comparison, hashing, and pretty-printing. It supports state management by providing deep copy and project membership checks. Use it to handle mutable float values within Frama-C's state system, such as tracking floating-point variables during static analysis.",
      "description_length": 336,
      "index": 2574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.List",
      "library": "frama-c.kernel",
      "description": "This module applies stateful monadic functions to lists. It provides `iter` for performing stateful actions across list elements, `map` for transforming lists with stateful computations, and `fold_left` for accumulating state while processing lists. Use it to manage state during list traversals, such as collecting analysis results or maintaining counters in static code analysis.",
      "description_length": 381,
      "index": 2575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations where keys represent abstract memory slices and values are polymorphic, enabling efficient insertion, lookup, and in-place modification with support for ordered traversal and statistical analysis. It includes a parameterized hash table implementation that provides standard operations like equality, comparison, hashing, and pretty-printing, while supporting deep copying and project-based membership checks for abstract memory states. The key module defines identifiers for memory slices used in value analysis, offering precise indexing with operations tailored for static program verification. Together, they support tasks like memoizing analysis results, tracking memory transformations, and performing deterministic reductions over structured data.",
      "description_length": 796,
      "index": 2576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G.E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a state dependency graph, where each edge connects two vertices of type `State.t` and carries a label. It provides operations to create edges with a specified source, destination, and label, as well as to retrieve the source, destination, and label of an edge. Concrete use cases include modeling dependencies between program states during static analysis, such as tracking control flow or data flow transitions.",
      "description_length": 453,
      "index": 2577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_list",
      "library": "frama-c.kernel",
      "description": "This module organizes and manipulates list-based command-line options and element collections, combining dynamic state updates, value accumulation, and serialization with support for categories, string parameters, and list-typed options. It centers around lists of type `E.t` and individual elements (`elt`), offering iteration, folding, alias management, and category-based organization with submodules handling string validation, list parsing, and category configuration. You can define command-line options that accept multiple values like file paths or analysis targets, manage backward-compatible aliases, set category-specific behaviors, or serialize and restore list-based state across sessions. Submodules enhance string handling with customizable validation, track changes to string and list values, and associate named categories with specific behaviors for option grouping and selection.",
      "description_length": 898,
      "index": 2578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make.Linear",
      "library": "frama-c.kernel",
      "description": "This module provides the foundation for linear algebra computations over scalar fields, enabling precise numerical operations on vectors and matrices required for filter state analysis. It supports core data types like vectors and matrices parameterized by dimension, with operations including addition, multiplication, inversion, and norm calculation. The vector submodule allows construction and manipulation of fixed-size vectors, with functions for element access, comparison, and size determination, while the matrix submodule offers arithmetic, transformation, and analysis tools for fixed-size matrices. Examples include computing matrix powers to bound state dimensions and solving linear recurrences for invariant analysis.",
      "description_length": 732,
      "index": 2579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnspecifiedAccess.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling unspecified memory access behavior in Frama-C's kernel. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying of values of type `t`, along with utilities to inspect and manipulate project-related data embedded within these values. The module is used to manage and reason about memory access semantics during static analysis, particularly when the `-unspecified-access` option is enabled.",
      "description_length": 499,
      "index": 2580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables with ordered traversal, memoization, and sequence conversion, supporting key-value operations like insertion, deletion, and lookup with `find_opt`. It integrates submodules that enhance key and table handling with deep copy, comparison, hashing, and pretty printing, enabling precise memory tracking and project membership checks. You can use `memo` to cache function results, iterate over sorted keys with `iter_sorted`, and manage structured values in static analysis plugins. The key module customizes hash and comparison logic, while the table module supports stateful analyses requiring deterministic traversal and value caching.",
      "description_length": 667,
      "index": 2581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.Set",
      "library": "frama-c.kernel",
      "description": "This module offers lattice-structured set operations with ordered elements, supporting functional transformations (map, filter), structural queries (subset, partition), and ordered iteration. It works with sets of ordered elements (type `elt`) that form a lattice, enabling precise manipulation of hierarchical or partially ordered data. Use cases include static analysis tasks requiring merging, splitting, or transforming sets while preserving element ordering and lattice relationships, such as tracking variable states or control-flow dependencies in program analysis.",
      "description_length": 572,
      "index": 2582,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for values of type `Data.t`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports creating and managing typed emitters with unique names and descriptors, enabling tracking and representation of values within Frama-C's analysis framework. Concrete use cases include storing and retrieving analysis results associated with specific projects or emitting annotations based on computed value states.",
      "description_length": 488,
      "index": 2583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing immutable, sorted sets of `Logic_type_NoUnroll.t` elements, supporting efficient membership checks, ordered traversal, and set algebra (union, intersection, difference). It includes utilities for transforming elements via `map` and `filter`, converting sets to ordered lists or sequences, and finding elements relative to a given value (e.g., nearest \u2264 or \u2265). These sets are particularly useful in static analysis scenarios requiring deduplicated collections with ordered processing, such as tracking type constraints or analyzing CIL constructs with inherent ordering.",
      "description_length": 614,
      "index": 2584,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_functions.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing built-in function specifications in a CIL-based analysis tool. It provides operations for comparing, hashing, and pretty-printing these specifications, along with utilities for deep copying and checking project membership. It works with CIL types and descriptors, and is used to manage built-in function metadata during static analysis of C code.",
      "description_length": 395,
      "index": 2585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter`, `map`, and `fold_left`, where each function applies a monadic effect to elements of a list. It handles computations that produce effects encapsulated in a monad `t`, over lists of values. Use this module to sequence list traversals with effectful operations, such as accumulating state or handling optional or error-prone computations per element.",
      "description_length": 429,
      "index": 2586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set operations for managing collections of CIL type information elements, supporting algebraic operations (union, intersection, difference), ordered traversal, and predicate-based filtering. It works with sets containing `Typeinfo` values, offering transformations like mapping, folding, and partitioning, as well as utilities for membership testing, nearest-element queries, and conversions to sequences or lists. These capabilities are particularly useful for analyzing or transforming C code semantics in Frama-C plugins, such as tracking type hierarchies, resolving type aliases, or enforcing type constraints during static analysis.",
      "description_length": 658,
      "index": 2587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with normalized filepaths as keys, providing standard operations like insertion, deletion, lookup, and traversal, along with transformation, filtering, and structural queries. It supports type-safe manipulation of file-centric data through a key module that ensures path normalization and offers comparison, hashing, and pretty-printing, while the data module allows associating typed values with these keys. Examples include tracking file metadata, analyzing configuration mappings, or storing per-file analysis results with guaranteed key consistency and safe access. Submodules refine key behavior and data association, enabling precise and robust static analysis workflows.",
      "description_length": 702,
      "index": 2588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralVerbose.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling verbose output configurations. It supports structured data manipulation with functions like `copy` for deep cloning, `mem_project` to check project membership, and integrates descriptors for type representation. Concrete use cases include managing and comparing verbose settings in kernel extensions and providing structured output for analysis tools.",
      "description_length": 493,
      "index": 2589,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PreprocessAnnot.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for comparing, hashing, and pretty-printing its values. It supports deep copying, membership testing within projects, and provides descriptors for structural manipulation. Concrete use cases include managing and analyzing annotated preprocessing data during Frama-C plugin execution, particularly when handling the `-pp-annot` option for source code transformation and analysis tasks.",
      "description_length": 436,
      "index": 2590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module manages string sets with support for mutable operations like adding elements, checking membership, and tracking changes through hooks, while integrating with project state and marshaling systems. It works with `String.Set.t` and custom `t` types to enable structured configuration of string-based parameters, including alias resolution, default values, and category-based organization. The child modules enhance this by providing efficient set operations, validation against predefined domains, and named categories for grouping parameters. Example uses include defining command-line options with fixed choices, persisting analysis settings, and managing user-defined string collections with deep copying and filtering in static analysis plugins.",
      "description_length": 758,
      "index": 2591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label.Set",
      "library": "frama-c.kernel",
      "description": "This module supports standard ordered set operations on `Label.t` elements, including union, intersection, difference, and ordered iteration, alongside transformations like mapping and filtering with monotonicity constraints. It manages sets through list and sequence conversions, nearest-element queries, and project-aware membership checks, maintaining elements in sorted order. Designed for CIL-based static analysis, it facilitates tasks like control flow graph manipulation, label tracking in ASTs, and data-flow analysis where ordered set semantics and efficient membership operations are critical.",
      "description_length": 604,
      "index": 2592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational.Map",
      "library": "frama-c.kernel",
      "description": "This module manages polymorphic maps indexed by rational numbers, supporting insertion, deletion, traversal, and transformation with functions like `map`, `filter`, and `merge`, while preserving key order for ordered processing. Its core data type represents a map with rational keys and arbitrary values, offering operations for querying, structural manipulation, and sequence conversion, suitable for symbolic or numerical computations needing precise arithmetic and ordered key sets. A child module specializes this structure with values from the `Data` module, adding equality, comparison, and pretty printing for use in static analysis plugins, while another focuses on key handling with utilities for projection, copying, and membership checks. Together, they enable precise map manipulation in analysis tools where key stability and ordered traversal are essential.",
      "description_length": 872,
      "index": 2593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables keyed by CIL structural offsets, offering insertion, lookup, deletion, iteration, and folding operations, while enabling ordered traversal and memoization for efficient mapping of offset-related data in static analysis. It includes a key module that defines equality, comparison, and hashing for CIL offset values, facilitating structural equivalence checks and offset-based mappings, particularly useful for tracking memory layouts or analysis metadata across program points. A dedicated table module builds on these keys to provide typed hash tables with deep copying, project-aware equality, and pretty-printing, enabling robust handling of per-offset data such as variable annotations or transformation rules. Example uses include tracking struct field offsets during CIL analysis, memoizing offset-dependent computations, and managing analysis results across different project versions.",
      "description_length": 937,
      "index": 2594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associative maps keyed by CIL attributes, offering structural operations like union and intersection, ordered traversal, and conversions to sequences and lists. It provides core functions such as `find`, `update`, and `to_list`, while its submodules handle key operations and define specialized map datatypes for arbitrary data values. The key module supports equality, comparison, and pretty-printing for attribute keys, enabling safe manipulation and analysis of C metadata. Together, they facilitate tasks like tracking function attributes across analysis contexts or aggregating annotations during static analysis of C code.",
      "description_length": 656,
      "index": 2595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Unicode.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling Unicode-related data in the kernel. It provides utilities to manage descriptors, representations, and project membership checks, ensuring deep copying and structural integrity. Concrete use cases include managing Unicode character sets, validating project-specific data, and supporting serialization through packed descriptors.",
      "description_length": 470,
      "index": 2596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.False",
      "library": "frama-c.kernel",
      "description": "This module manages boolean plugin options with support for state mutation, value observation, and lifecycle hooks, operating on a boolean type enriched with metadata for defaults, command-line aliases, and serialization. It allows controlled state changes through explicit `set` operations and change notification callbacks, enabling use cases like configuring plugin features via command-line flags or tracking runtime state transitions with validation. The child module extends this functionality by defining a registered datatype with equality, comparison, and pretty-printing operations, supporting deep copying and integration with Frama-C's project system for plugin-specific data structures. Together, they facilitate robust configuration management and data representation in Frama-C plugins.",
      "description_length": 801,
      "index": 2597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in a property-based hashtbl, providing equality, comparison, and hashing operations tailored to property keys. It supports structured data types with representations, descriptors, and project-aware membership checks, enabling precise key manipulation and introspection. Use cases include managing and querying property keys in static analysis plugins, particularly for tracking and comparing properties across different project contexts.",
      "description_length": 476,
      "index": 2598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype instance from a polymorphic type with a single type variable. It provides standard operations including equality, comparison, hashing, and pretty printing for the instantiated type. It is used to define concrete data structures with full introspection and serialization support for analysis in Frama-C plugins.",
      "description_length": 353,
      "index": 2599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string values, providing conversions between strings and a typed representation. It supports equality checks, comparison, hashing, and pretty-printing for string-based parameters. Use it to define and manage configurable string options in Frama-C plugins or command-line interfaces.",
      "description_length": 338,
      "index": 2600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.True",
      "library": "frama-c.kernel",
      "description": "This module manages boolean configuration options integrated with Frama-C's plugin state system, supporting operations for setting, retrieving, and monitoring changes through hooks and default values. It enables use cases such as parsing command-line arguments, dynamically updating plugin settings, and serializing persistent state, with built-in support for `bool` values. The child module extends this functionality by defining a registered datatype with equality, comparison, and pretty-printing operations, allowing structured value manipulation in static analysis contexts. Together, they support managing both simple boolean flags and complex structured values, such as tracking analysis states or plugin-specific data across projects.",
      "description_length": 742,
      "index": 2601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters with support for validation, alias resolution, and serialization, handling both individual strings and string lists. It provides data types and operations for equality checking, comparison, hashing, pretty-printing, deep copying, and project membership testing, enabling structured manipulation of parameters during command-line processing. It supports tracking state changes, enforcing value constraints, and integrating with Frama-C's project system for persistent configuration of kernel extensions. Specific use cases include implementing autocompletable options for plugins, such as specifying function names or file paths via command-line arguments.",
      "description_length": 712,
      "index": 2602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.True_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean reference initialized to `true`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports data types related to Frama-C's state management, including project-aware values and deep copy semantics. Concrete use cases include tracking analysis states and managing configuration flags within Frama-C plugins.",
      "description_length": 379,
      "index": 2603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_type_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for representing and manipulating logic type information in the context of computing project diffs. It includes functionality for checking project membership and performing deep copies, ensuring no shared references between original and copied values. Use cases include tracking and comparing logic type representations across different project states.",
      "description_length": 489,
      "index": 2604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of CIL expressions with structural equality and strict constant comparison semantics, supporting operations like union, intersection, filtering, and nearest-element queries. It is designed for static analysis tasks requiring precise equivalence checks between expressions involving `sizeof` or constants, such as tracking memory layout dependencies or optimizing symbolic evaluations where structural identity and size-based equivalence are critical. The ordered structure enables efficient traversal and partitioning, leveraging expression size and strict constant equality for deterministic comparisons.",
      "description_length": 641,
      "index": 2605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table for string keys with imperative operations including insertion, deletion, lookup, and in-place filtering, supporting efficient data management for static analysis plugins. It enables sorted traversal by key, value, or binding, and includes utilities for memoization, table lifecycle management, and bulk updates from sequences. The associated key module ensures strong typing and project-aware operations such as deep copying and membership checks, while the value-specialized table module adds typed storage with equality, comparison, and pretty-printing capabilities. Example uses include symbol tables, caches, and configuration systems where ordered, string-indexed data requires precise and efficient manipulation.",
      "description_length": 765,
      "index": 2606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for keys used in a map structure within an alarms database system. It supports key comparison, equality, hashing, and pretty-printing, enabling efficient map manipulation and debugging. The module also provides introspection capabilities through representants and descriptors, and allows checking for the presence of specific project values within keys.",
      "description_length": 400,
      "index": 2607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes and extends map functionality for handling CIL statements as keys, offering both key-specific operations and a fully-featured map implementation. It includes a key module that supports equality, comparison, hashing, and deep copying for statement-based keys, while the main map module enables efficient association of arbitrary data with CIL statements. You can insert, look up, and iterate over statement-value pairs, and compare or hash both keys and maps for analysis or transformation tasks. Examples include tracking variable states at specific code points or annotating statements with analysis results during static code processing.",
      "description_length": 661,
      "index": 2608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise.Make_bitwise.LOffset",
      "library": "frama-c.kernel",
      "description": "This component provides lattice-based operations for interval-to-value mappings, enabling precise modeling of memory offsets in static analysis. It supports interval binding, customizable merging strategies, and consistency checks, operating on interval-based representations augmented with validity states and size metadata. Key applications include merging abstract memory states, validating memory accesses, and efficiently handling sparse data structures in program analysis.",
      "description_length": 479,
      "index": 2609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for mapping code annotations to arbitrary values, enabling imperative updates, ordered traversal, and custom key comparisons. It supports structured access to CIL code metadata through keys based on `Code_annotation.t` and integrates with Frama-C's analysis pipeline for tracking, aggregating, and memoizing annotation-driven data. The child modules enhance this functionality by defining specialized key operations and value types with support for deep copying, project membership, and pretty-printing. Example uses include storing analysis results per annotation, correlating CIL constructs with metadata, and implementing annotation-based transformations across project scopes.",
      "description_length": 713,
      "index": 2610,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by `Ival` values with values of a specified data type, supporting operations like equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership check for project skeletons, and standard map utilities tailored for use in static analysis contexts. Concrete use cases include tracking value abstractions across program points or managing analysis results keyed by integer intervals.",
      "description_length": 450,
      "index": 2611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes logic constructor metadata from CIL into ordered key-value mappings, supporting transformations, filtering, and structured traversal. It uses keys representing logic constructor information to manage polymorphic values, enabling precise queries and analysis-specific operations in static analysis pipelines. Submodules provide standard map operations like equality, comparison, and pretty printing, along with key-specific utilities for deep copying and project-aware membership checks. Example uses include tracking logic function signatures and analysis annotations during Frama-C plugin execution.",
      "description_length": 622,
      "index": 2612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Set",
      "library": "frama-c.kernel",
      "description": "This module supports creation, modification, and ordered traversal of immutable sets containing memory offset elements derived from Lmap's base-to-memory-map associations. It provides standard set operations like union, intersection, and difference alongside ordered iteration, folding, and nearest-element queries, leveraging the inherent ordering of offsets for efficient analysis. Such functionality is particularly useful in static analysis plugins requiring precise memory state modeling, such as tracking disjoint memory regions or validating offset-based access patterns in C programs.",
      "description_length": 592,
      "index": 2613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map.Make",
      "library": "frama-c.kernel",
      "description": "Implements a map structure keyed by rational numbers, where values are of a specified data type. Provides standard operations including comparison, hashing, pretty printing, and deep copying, alongside project-aware membership checks. Useful for managing value mappings with rational keys in contexts requiring precise equality, ordering, or serialization.",
      "description_length": 356,
      "index": 2614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes key-value associations where keys represent control flow edges annotated with guards and actions, enabling efficient management and transformation of edge-bound data. It supports core operations like insertion, lookup, iteration, and comparison, along with customizable pretty-printing and ordered traversal, making it suitable for tracking state transitions and merging analysis results in abstract interpretation. Submodules provide specialized edge-based keys with full equality, comparison, and serialization support, while the main module enables project-aware data association and edge-specific property manipulation. Example uses include debugging control flow analyses and aggregating transition-specific metadata across program paths.",
      "description_length": 765,
      "index": 2615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins.Plugins",
      "library": "frama-c.kernel",
      "description": "This module manages plugin loading and configuration paths. It provides operations to retrieve configured plugin paths, list available plugins, and load all or specific plugins. It works with string lists representing plugin paths and is used during initialization to dynamically load plugins based on configuration.",
      "description_length": 316,
      "index": 2616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.EagerLoadSources.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling and comparing structured values. It supports deep copying and provides functionality to check membership of project values through predicate testing. The type is used to represent and manipulate descriptors and their instances in a structured manner.",
      "description_length": 393,
      "index": 2617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports structured data management with deep copying, membership testing, and project-based queries. Concrete use cases include tracking and manipulating collections of memory zones with associated validity information.",
      "description_length": 388,
      "index": 2618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of project state elements, supporting efficient union, intersection, difference, and ordered iteration while preserving element ordering. It works with sets of `Frama_c_kernel.Project.Datatype.t`, providing utilities for conversion to/from sequences, nearest-element queries, and introspection over project skeletons. It is particularly useful for plugins needing to track internal states with strict ordering requirements, such as dependency resolution or incremental analysis workflows.",
      "description_length": 555,
      "index": 2619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered set abstraction for machine-dependent values, supporting operations like union, intersection, filtering, and ordered traversal while preserving element uniqueness. It works with sets of `Frama_c_kernel.Machdep.Machdep.t` elements, integrating sequence conversions, nearest-value queries, and order-preserving transformations. Designed for static analysis contexts, it enables efficient management of machine-specific configurations or state tracking where ordered collections of unique values are required.",
      "description_length": 540,
      "index": 2620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered maps with strict key comparison, focusing on keys that distinguish values based on their textual representation, such as C constants with different suffixes. It supports core operations like insertion, lookup, and traversal, along with advanced transformations such as merging and filtering, enabling precise and deterministic processing in static analysis contexts. One submodule implements a map with CIL constants as keys and customizable values, offering operations like equality, hashing, and pretty-printing, while another defines a strict key type that ensures consistent comparison and handling of textual distinctions. Together, they enable structured, project-aware tracking of CIL constants and support complex analysis tasks requiring exact key identity and ordering.",
      "description_length": 807,
      "index": 2621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AstDiff.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for comparing, hashing, and pretty-printing values of that type, specifically tailored for use with abstract syntax tree differencing in the Frama-C kernel. It includes functions for checking membership of project values, creating deep copies, and exposing type representations and descriptors. Concrete use cases include analyzing and transforming AST differences during static analysis, particularly when tracking changes across different versions of C code.",
      "description_length": 522,
      "index": 2622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a user directory within an existing directory structure. It provides `get_dir` and `get_file` functions to retrieve or create directories and files, with an optional flag to control path creation. It operates on string names and returns paths as `Frama_c_kernel.Filepath.t`, ensuring correct handling of file system operations. Use this module when setting up custom command line options that require directory or file path resolution relative to a parent directory.",
      "description_length": 489,
      "index": 2623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associative maps for source code elements with positional metadata, enabling efficient insertion, lookup, and ordered traversal. It supports polymorphic values and includes specialized operations for merging, filtering, and reverse iteration, along with sequence-based construction for AST-related transformations. One submodule provides a key type with location awareness and standard operations, while another implements a map structure supporting deep copying, type-safe equality, and pretty printing. Examples include tracking formatted representations of AST nodes and performing project-wide data queries during source-to-source translation.",
      "description_length": 675,
      "index": 2624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Caml_weak_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table for a specific data type, allowing keys to be garbage-collected when no longer in use. It provides standard operations such as `add`, `find`, `remove`, and `iter`, along with equality, comparison, and hashing functions required for table management. This structure is particularly useful for caching values associated with program elements where memory retention is not critical.",
      "description_length": 408,
      "index": 2625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Lemmas.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in logic lemma representations. It supports deep copying and project-aware membership checks, ensuring proper handling of structured values within analysis contexts. The type is used to manage and manipulate logic entities with precise semantic distinctions and efficient storage.",
      "description_length": 421,
      "index": 2626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Orig_name.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling and manipulating structured data representations. It provides utilities to check membership within projects, create deep copies, and access type descriptors, supporting precise data management and analysis tasks. Concrete use cases include managing abstract syntax tree nodes, analyzing program constructs, and implementing transformations that require structural integrity and identity tracking.",
      "description_length": 539,
      "index": 2627,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating logic-related information in the context of project diffs. It supports equality, comparison, hashing, and pretty-printing of logic data, along with deep copying and project membership checks. Concrete use cases include tracking changes in logic expressions across different project versions and comparing logic structures for diff computation.",
      "description_length": 424,
      "index": 2628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom.Make_Datatype",
      "library": "frama-c.kernel",
      "description": "This module constructs a datatype with support for top and bottom lattice elements, wrapping a given domain to handle values that may be absent, undefined, or universally true/false. It provides standard operations like equality, comparison, hashing, and pretty printing, along with deep copying and membership checking over projections. Concrete use cases include representing abstract values in static analysis where lattice elements must distinguish between all possible values, no value, or a specific domain instance.",
      "description_length": 522,
      "index": 2629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdep.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for comparing, hashing, and pretty-printing values that represent machine-dependent data types. It provides functions to check membership of project values, create deep copies, and access descriptors and representants of the data type. It is used to handle and manipulate machine-dependent data representations in the context of the `-print-machdep` option behavior.",
      "description_length": 418,
      "index": 2630,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with efficient key-value storage and retrieval, supporting operations like insertion, deletion, lookup, and iteration, along with advanced features such as in-place filtering and bulk processing via sequences. It works with any key type that provides equality and hashing functions, organizing them into a structured table that enables fast access and transformation of stored values. Child modules define key-specific behaviors, including comparison, pretty-printing, and deep copying, enabling precise control over key handling and display in complex use cases such as Frama-C plugin development. Examples include memoizing function results, tracking program elements during analysis, and managing project-scoped data with custom key semantics.",
      "description_length": 781,
      "index": 2631,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally propagates a top value in a lattice context. It operates on boolean values and lattice top markers, allowing lattice computations to proceed only when a given boolean condition holds. A concrete use case is controlling flow within lattice-based static analysis where top represents an indeterminate or maximal state.",
      "description_length": 384,
      "index": 2632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes keys and values into a structured map, supporting efficient insertion, lookup, and traversal over keys that carry rich semantic meaning. It provides core operations like comparison, hashing, and pretty-printing for both keys and values, enabling precise data manipulation and analysis in Frama-C plugins. Submodules specialize in string-based key management and value storage, allowing users to build and inspect maps that track project-specific data. For example, you can insert a value under a string key, check its presence in a specific project context, or print the entire map for debugging.",
      "description_length": 618,
      "index": 2633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a type-safe hash table implementation for managing structured data, such as CIL enumeration items, with efficient lookups and operations including insertion, membership testing, and filtering by project. It uses specialized keys that uniquely identify enum items, supporting equality, comparison, hashing, and pretty printing. Direct operations allow building and manipulating tables with deep copies and project-based constraints, enabling precise analysis and transformation of C code in Frama-C. Example uses include tracking enum definitions across translation units and applying type-preserving transformations selectively based on project context.",
      "description_length": 674,
      "index": 2634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Compinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing structured values used in computing project diffs. It supports equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Concrete use cases include tracking changes in project components and ensuring consistent data representation across diff computations.",
      "description_length": 383,
      "index": 2635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages memory mappings using hash tables keyed on memory bases and offsets, supporting efficient storage and retrieval of arbitrary values during static analysis. It provides operations for iteration, folding, and memoization over dynamically sized memory regions, with keys and values structured to enable precise comparisons, deep copying, and project membership checks. Submodules define specialized key and value types with standard operations like equality, hashing, and pretty-printing, tailored for memory state manipulation and structured data management. Examples include tracking heap allocations, caching analysis results, and implementing custom memory abstractions with ordered keys and runtime type inspection.",
      "description_length": 737,
      "index": 2636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Orig_project.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating project data in the context of computing diffs between projects. It supports equality checks, comparison, hashing, and pretty-printing for diff data types, along with deep copying and membership testing for project skeletons. Concrete use cases include tracking structural changes between different versions of a project and analyzing project evolution through diff representations.",
      "description_length": 463,
      "index": 2637,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables mapping `Term_lhost.t` keys to arbitrary values, enabling efficient creation, modification, and lookup operations. It supports ordered traversal through sorted iteration and folding, and includes utilities like `memo`, `find_opt`, and `find_def` for safe and cached access. The key module provides equality, comparison, hashing, and pretty-printing for `Term_lhost` values, while the data module builds hash tables over custom data types such as expressions and variables. Together, they enable tracking term properties, managing analysis state, and performing efficient lookups in static analysis plugins.",
      "description_length": 641,
      "index": 2638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Axiomatics.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in logic axiomatics. It supports deep copying and project-aware membership checks, ensuring values can be inspected and manipulated independently of their project context. It is used to represent and manage structured logic entities such as types, descriptors, and representants in a consistent and project-safe manner.",
      "description_length": 460,
      "index": 2639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Int",
      "library": "frama-c.kernel",
      "description": "This module provides a structured way to define and manage integer command-line parameters with support for range constraints, value mutation, and state synchronization. It includes operations for comparison, hashing, pretty-printing, and project-aware copying, enabling customization of parameter behavior and integration with plugin state management. You can use it to create configurable analysis thresholds, track counters during instrumentation, or serialize integer settings for user interfaces. The module combines direct manipulation of integer parameters with extensible type handling and project-specific metadata support.",
      "description_length": 632,
      "index": 2640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LogicalOperators.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for managing logical operator representations in the kernel. It supports equality checks, comparison, hashing, and pretty-printing of logical operator values, along with deep copying and project membership testing. It is used to handle logical operators (`&&`, `||`) in a way that preserves their structure during specific analyses that require keeping them as logical expressions rather than converting them into conditionals.",
      "description_length": 474,
      "index": 2641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.String_map",
      "library": "frama-c.kernel",
      "description": "This module organizes string-indexed data with customizable value types, enabling storage, retrieval, and transformation with change tracking and persistence across Frama-C projects. It supports marshaling, equality checks, and integration with state management, while its submodules handle plugin configuration categories, structured string maps with rich operations, and validated string parameters with update hooks. You can define parameter groups with dependencies, store and compare string-mapped data across analyses, and enforce constraints on configurable values like function names. Together, these features support dynamic settings, plugin options, and serialized metadata sharing within Frama-C.",
      "description_length": 707,
      "index": 2642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.JsonCompilationDatabase.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating compilation database entries. It supports deep copying, membership testing within projects, and provides descriptors for type representation and serialization. Concrete use cases include managing and querying structured compilation data during static analysis, ensuring accurate and efficient handling of project-specific configurations.",
      "description_length": 501,
      "index": 2643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Set",
      "library": "frama-c.kernel",
      "description": "This module offers creation, modification, and query operations for immutable sets of integers, including ordered iteration, nearest-element searches (e.g., `nearest_elt_ge`), and set algebra (union, intersection). It works with sets of `Frama_c_kernel.Datatype.Int.t` values, supporting safe operations via option-returning variants and conversions to sequences or lists. Typical use cases involve static analysis plugins requiring precise integer set manipulations with comparison-based correctness and ordered traversal guarantees.",
      "description_length": 534,
      "index": 2644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make.Set",
      "library": "frama-c.kernel",
      "description": "This module supports creation and manipulation of immutable sets containing ordered elements, offering operations such as union, intersection, difference, and disjoint checks, along with transformations like mapping, filtering, and ordered traversal. It provides utilities for converting between sets, sequences, and lists, as well as functions for comparison, hashing, and structural inspection. Such capabilities are particularly useful in static analysis and formal verification contexts, where persistent data structures and precise set-theoretic operations over ordered types are required.",
      "description_length": 594,
      "index": 2645,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent set data structure for integers with efficient functional operations like union, intersection, and difference, alongside element selection and ordered traversal. It supports transformations via mapping and filtering, aggregation through folding, and conversions to sequences/lists, leveraging inherent ordering for predicate-based queries and nearest-value computations. Designed for static analysis tasks, it enables precise integer set manipulations in abstract interpretation contexts while providing utilities for comparison, hashing, and structured serialization.",
      "description_length": 604,
      "index": 2646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfigJson.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating configuration data used by the `-print-config-json` option. It supports equality checks, comparison, hashing, pretty-printing, and deep copying of configuration values, along with querying based on project membership. The module is used to handle structured configuration data in a way that enables accurate JSON output generation for kernel plugins.",
      "description_length": 431,
      "index": 2647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Set",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manipulate, transform, and query sets of control flow graph vertices, including union, intersection, filtering, and ordered traversal. It supports operations like condition-based membership checks, sequence integration, and deep copying, enabling efficient analysis of program states and transitions during abstract interpretation. These capabilities are critical for tasks such as computing reachable states or verifying properties over guarded transitions in interpreted automata.",
      "description_length": 516,
      "index": 2648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath.Set",
      "library": "frama-c.kernel",
      "description": "This module supports operations such as union, intersection, ordered traversal, and predicate-based filtering on immutable sets of type-safe normalized filepaths. It works with sets structured as ordered elements using a comparison function, enabling efficient membership checks, transformations, and conversions to sequences or lists. These capabilities are particularly useful for static analysis tasks like managing file dependencies, analyzing inclusion hierarchies, or enforcing project-specific file groupings with type safety.",
      "description_length": 533,
      "index": 2649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.WithOutput",
      "library": "frama-c.kernel",
      "description": "This module manages boolean command-line parameters with stateful behavior, enabling value toggling, dependency tracking for output caching, and conditional execution of output functions. It works with a typed parameter structure that supports hooks for value changes and marshaling, allowing configuration of output options that reuse cached results unless dependencies have changed. The child module extends this functionality by implementing command-line option parsing for structured data types, including equality, comparison, and pretty-printing for values like ranges or configurations. Together, they support defining and handling complex options that control output generation with fine-grained, state-aware logic.",
      "description_length": 723,
      "index": 2650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make.Option",
      "library": "frama-c.kernel",
      "description": "This module applies stateful monadic operations to optional values. It provides `iter` for performing stateful side-effects on `Some` values and `map` for transforming optional values using stateful computations. It is useful for handling state-dependent optional data, such as parsing or conditional state updates, where the presence or absence of a value affects the state.",
      "description_length": 375,
      "index": 2651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Permissive.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling abstract data in the context of the `-permissive` mode. It provides introspection capabilities through descriptors and representants, enabling checks on embedded project data via `mem_project`. The module supports deep copying to ensure no shared references between original and copied values.",
      "description_length": 432,
      "index": 2652,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables keyed by abstract memory values, enabling efficient insertion, lookup, and traversal for mappings between memory locations and computed values. It supports sorted iteration, sequence conversion, and memoization, operating on parameterized tables where keys and values align with Frama-C's value analysis model. The key submodule defines equality, comparison, and hashing operations for memory value keys, while the value submodule implements specialized tables for managing byte-indexed locations with associated data. Examples include caching analysis results by memory address and transforming value mappings during abstract interpretation.",
      "description_length": 675,
      "index": 2653,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a user directory option for command line configuration, providing functions to retrieve or set a directory path, create files within it, and check its existence. It operates on `Frama_c_kernel.Filepath.t` values, representing directory paths, and supports optional path creation during file or directory access. Concrete use cases include setting up plugin-specific directories via command line flags, storing generated files in structured locations, and isolating user-defined output paths for analysis tools.",
      "description_length": 542,
      "index": 2654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Common",
      "library": "frama-c.kernel",
      "description": "This module provides operations to access and manipulate plugin parameters using dynamic typing. It supports retrieving, setting, clearing, and checking the status of parameters by name, working with values of type `t`. Concrete use cases include managing configuration options or runtime settings for plugins after they have been loaded.",
      "description_length": 338,
      "index": 2655,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Map",
      "library": "frama-c.kernel",
      "description": "This module implements finite maps using ordered keys of type `Identified_term.t`, enabling efficient insertion, deletion, and ordered traversal while supporting advanced operations like merging, filtering, and bidirectional conversion to sequences. It provides direct access to key-based transformations and bounded retrieval, allowing for range queries and customizable serialization, particularly useful in symbol table management and term-based caching. The first child module specializes in maps with identifiers as keys and values of type `Data.t`, offering type-safe operations, equality checks, and deep copying, ideal for tracking term identifiers during CIL analyses. The second child module defines a key type for `Identified_term` values, ensuring unique identification and efficient comparison, hashing, and serialization, crucial for maintaining ordered and unique key sets in analysis workflows.",
      "description_length": 910,
      "index": 2656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.Option",
      "library": "frama-c.kernel",
      "description": "This module combines two monads, Option as the interior and a given monad as the exterior, enabling monadic compositions where the order of wrapping needs to be adjusted. It provides `iter` and `map` functions that apply monadic actions over optional values, allowing operations like stateful computations that may fail. A concrete use case is handling parsing or analysis steps that involve both state management and the possibility of failure, such as traversing abstract syntax trees with optional elements while maintaining a context.",
      "description_length": 538,
      "index": 2657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a structured set interface for managing collections of logic symbols with structural equality, supporting operations like union, intersection, difference, and nearest-element queries based on name and argument type compatibility. It works with sets of `Logic_info_structural` elements, enabling efficient membership tests, transformations, and ordered traversals while ignoring polymorphic type variable names during comparison. It is particularly useful in static analysis plugins for tracking logic function signatures, resolving symbol dependencies, or analyzing type-constrained logical properties in C code.",
      "description_length": 631,
      "index": 2658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables that map CIL terms to arbitrary values, enabling efficient lookups, ordered iteration, and bulk updates via sequences. It supports imperative and functional styles with safety-focused accessors like `find_opt`, `memo`, and `of_seq`, using term identifiers to determine iteration order. The key module handles term identification, comparison, hashing, and pretty-printing, while the value module specializes in managing `Data.t` instances with deep copies and structural checks. Use cases include tracking term metadata, caching computed values, and performing term-based dataflow analysis in static analysis plugins.",
      "description_length": 649,
      "index": 2659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables, specifically tailored to represent integer intervals with congruence information. It provides standard operations such as equality, comparison, hashing, and pretty-printing for these interval keys. Use cases include efficient storage and retrieval of interval-based data in analysis plugins, such as tracking ranges of possible values for variables in static analysis.",
      "description_length": 422,
      "index": 2660,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidPointer.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing values related to invalid pointer warnings in the Frama-C kernel. It provides functions for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and checking project membership within values. These capabilities support precise handling and analysis of invalid pointer states during static analysis.",
      "description_length": 424,
      "index": 2661,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Set",
      "library": "frama-c.kernel",
      "description": "This module enables manipulation of sets of CIL function declarations (Fundec.t) through standard set operations like union, intersection, and difference, alongside transformations (map, filter) and membership checks. It supports ordered iteration, sequence conversion, and nearest-element queries, with utilities for hashing, comparison, and pretty-printing. Designed for static analysis or code transformation plugins, it facilitates tasks like call graph construction, function dependency tracking, or program-wide property verification by efficiently handling collections of CIL function declarations.",
      "description_length": 605,
      "index": 2662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered maps keyed by CIL constants, offering creation, modification, and traversal operations optimized for physical equality and ordered comparison. It supports arbitrary value types and includes utilities for transformation, sequencing, and customizable pretty-printing, enabling efficient tracking of constant-value associations during static analysis. The key module provides semantic equality, comparison, and pretty-printing for map keys, ensuring correct handling of project-specific constant data. A specialized child module extends this structure to enforce specific value types, allowing precise mappings such as associating integer constants with analysis results or symbolic expressions.",
      "description_length": 720,
      "index": 2663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset.Map",
      "library": "frama-c.kernel",
      "description": "This module manages immutable key-value associations with ordered keys, enabling functional updates, predicate-based queries, and efficient traversal via bidirectional sequences. It supports specialized key types that carry project-specific data, allowing deep copies, comparisons, and pretty-printing, which are crucial for precise static analysis tasks like tracking memory zones. The memory zone-based map implementation extends this functionality, offering type-specific operations for managing memory state transitions and properties in analysis plugins. Together, these components enable structured manipulation of hierarchical memory models using semantically rich keys and values.",
      "description_length": 688,
      "index": 2664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.StringSet",
      "library": "frama-c.kernel",
      "description": "This module manages sets of string parameters for plugins, supporting operations to get, set, add, remove, and iterate over strings associated with a parameter name. It works with string sets to configure or track multiple string values dynamically. Concrete use cases include maintaining lists of file paths, identifiers, or options specified through plugin parameters.",
      "description_length": 370,
      "index": 2665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for managing a collection of kernel functions, including equality checks, comparison, hashing, and pretty-printing. It works with the abstract type `t` representing kernel functions and provides utilities for deep copying, membership testing within projects, and descriptor handling. Concrete use cases include tracking function representations, comparing and hashing kernel function instances, and formatting them for user output in analysis tools.",
      "description_length": 492,
      "index": 2666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for integer keys with operations for insertion, deletion, lookup, and in-place modification, along with utilities for iteration, conversion to sequences, and memoization. It manages mappings from abstract integer keys to arbitrary values, supporting efficient storage and traversal with customizable ordering, commonly used in static analysis for tracking data dependencies and caching analysis states. The child modules specialize the hash table for abstract interpretation, offering domain-specific value handling and structured key operations, including equality, comparison, and pretty-printing tailored to project-aware analysis tasks. Together, they enable precise, efficient manipulation of integer-keyed data in complex static analysis scenarios.",
      "description_length": 798,
      "index": 2667,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Set",
      "library": "frama-c.kernel",
      "description": "This module provides standard set operations\u2014union, intersection, difference, membership checks, and ordered element retrieval\u2014on collections of CIL global variables or related entities. It supports transformations (filtering, mapping), traversals (folds, iterators), and conversions to/from lists/sequences while preserving uniqueness and total ordering constraints. Designed for static analysis tasks like tracking global variable interactions, dependency resolution, or dataflow analysis in C programs processed by Frama-C's CIL framework.",
      "description_length": 542,
      "index": 2668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages collections of values associated with syntactic scopes in CIL, using hash tables for efficient access and supporting operations like equality, comparison, hashing, and pretty printing. It integrates with the `Data` module to handle element manipulation and enables deep copying and project membership testing through its scoped key management. The child module defines key types for syntactic scopes, including support for `Project_skeleton.t`, allowing precise tracking of C entities like variables or labels within Frama-C analyses. Together, they enable scoped identifier management, such as tracking variable declarations in specific syntactic contexts during C analysis plugin development.",
      "description_length": 714,
      "index": 2669,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Copy.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling a specific data type used in the implementation of the `-copy` command-line option. It provides functions for equality checks, comparison, hashing, deep copying, and pretty-printing values of type `t`, along with utilities for inspecting and querying project-related properties within those values. The module is used to manage and manipulate structured data representations during analysis sessions that require duplication of internal states.",
      "description_length": 488,
      "index": 2670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables keyed by CIL component information, enabling efficient storage and retrieval of values through imperative operations like insertion, deletion, and lookup. It supports functional traversal with `iter` and `fold`, ordered iteration via custom comparisons, and advanced features like memoization and in-place filtering, making it ideal for static analysis tasks such as tracking type definitions or data-flow properties. The child modules define component-based keys and specialized hash tables, offering equality, comparison, hashing, and pretty-printing operations tailored to CIL types. Together, they enable plugins to manage and manipulate CIL-based data across analysis phases with precision and efficiency.",
      "description_length": 743,
      "index": 2671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between kernel functions and value lists, supporting operations to set, retrieve, and track associations across computations. It works with `kernel_function` keys and `V.t list` values, allowing custom marshaling, equality checks, and category-based queries, with support for both defined functions and pure prototypes as keys. The module enables precise inter-procedural analysis and plugin configuration by associating dynamic metadata such as annotations or prototypes with functions. Submodules enhance this by providing multi-map data structures, string parameter management, and category-based grouping for organizing and transforming function-associated data.",
      "description_length": 695,
      "index": 2672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.List",
      "library": "frama-c.kernel",
      "description": "This module provides operations to iterate over, map, and fold lists within a lattice context where top values are explicitly handled. It works with lists of values wrapped in a lattice-aware monad, allowing computations to signal top results during traversal. Concrete use cases include analyzing or transforming sequences of lattice elements in static analysis tasks, such as propagating abstract values through control-flow graphs.",
      "description_length": 434,
      "index": 2673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized map implementation for 64-bit integer keys and arbitrary value types, offering standard operations such as lookup, insertion, and traversal. It includes support for deep copying, comparison, and pretty-printing, integrating seamlessly with Frama-C's project system for managing analysis results indexed by identifiers. The associated key module enhances map functionality by defining essential key operations like equality, comparison, and hashing for `Int64` keys. Example uses include tracking analysis metadata or efficiently managing large sets of structured data indexed by numeric identifiers.",
      "description_length": 634,
      "index": 2674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Set",
      "library": "frama-c.kernel",
      "description": "This component implements a comprehensive set algebra for managing collections of CIL field descriptors, supporting operations like union, intersection, difference, and predicate-based filtering. It works with ordered sets of field information elements, enabling efficient membership checks, ordered traversal, and conversion to sequences or lists while preserving structural relationships. These capabilities are particularly useful in static analysis tasks that require tracking struct/union field dependencies, comparing type layouts, or extracting subsets of fields matching specific analysis criteria.",
      "description_length": 606,
      "index": 2675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes and extends attribute-based key-value mappings, enabling ordered traversal, merging, and transformation of immutable maps where keys are structured CIL attributes. It provides core operations for safe and unsafe lookups, filtering, and structural manipulations such as union and split, while supporting conversion to ordered sequences. The key module enhances attribute handling with equality, comparison, and pretty-printing tailored to CIL analysis, including deep copying and project-aware membership checks. A data-specific submodule builds typed maps for precise representation and manipulation of attribute-associated values in static analysis workflows.",
      "description_length": 682,
      "index": 2676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module combines a specialized hash table implementation for floating-point values with a custom key type that supports precise equality, comparison, and hashing operations. It provides a full suite of standard hash table operations, including insertion, lookup, and iteration, while integrating deep copying and project-aware membership testing for keys. The associated key module enables fine-grained control over floating-point representations, making it suitable for static analysis tasks such as tracking numerical approximations or symbolic expressions. Together, these components allow developers to build and manipulate hash tables that are tightly integrated with Frama-C's internal type system and analysis frameworks.",
      "description_length": 732,
      "index": 2677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of built-in logic function metadata (`Builtin_logic_info.t`), supporting union, intersection, difference, and ordered traversal while enabling precise queries for nearest elements (e.g., `nearest_elt_ge`). It includes utilities for transforming sets via mapping or folding, filtering based on predicates, and converting between sets and sequences/lists, alongside project-specific membership checks and deep copying. These capabilities are tailored for static analysis plugins to model and manipulate relationships between CIL logic functions, such as resolving dependencies or optimizing logic function lookups during code analysis.",
      "description_length": 700,
      "index": 2678,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ival.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hashtables within the Ival framework, providing essential operations such as equality, comparison, hashing, and pretty printing. It supports data types involving project skeletons, enabling checks on embedded project values via `mem_project` and ensuring deep copying with no shared references. Concrete use cases include managing and querying abstract values tied to specific analysis projects in Frama-C plugins.",
      "description_length": 456,
      "index": 2679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive set of ordered set operations for managing collections of CIL code annotations, including standard manipulations like union, intersection, and difference, as well as ordered traversal, filtering, and conversion to sequences or lists. It works with sets of `Code_annotation.t` elements, leveraging their total ordering for deterministic iteration, nearest-element queries, and efficient membership checks. Specific use cases include analyzing or transforming C programs via static analysis plugins, where maintaining and querying structured annotations (e.g., preconditions, postconditions) across code regions is required, and ensuring consistent processing through ordered element selection.",
      "description_length": 727,
      "index": 2680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map structure specialized for a given data type, enabling efficient storage and retrieval of values indexed by memory base addresses. It supports operations like equality checks, comparison, hashing, and pretty-printing, tailored for analysis of memory zones in static code analysis. Concrete use cases include tracking memory state during abstract interpretation or managing per-base metadata in Frama-C plugins.",
      "description_length": 435,
      "index": 2681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table implementation for 32-bit integer keys paired with polymorphic values, supporting imperative and functional operations such as insertion, lookup, deletion, in-place filtering, and ordered traversal. It enables advanced usage through memoization, sequence conversion, and default value handling, making it suitable for caching numeric identifiers or managing state with structured values. A child module defines key operations including equality, comparison, and hashing for 32-bit integers, ensuring correct behavior within the table, while another builds a concrete hash table type parameterized over value types, supporting deep copying, custom memory handling, and pretty-printing for use in analysis plugins. Example uses include tracking analysis state by integer keys, transforming value sequences in order, and implementing caches with structured or custom-serialized values.",
      "description_length": 928,
      "index": 2682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepBuiltinMacros.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling built-in macro data in the context of machine-dependent printing. It supports structured data representation with descriptors, packed formats, and deep copying, enabling precise manipulation and inspection of macro-related data structures. Concrete use cases include managing and comparing macro definitions during static analysis and generating user-friendly output for debugging or documentation purposes.",
      "description_length": 533,
      "index": 2683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LeftShiftNegative.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling values related to the behavior of left-shifting negative integers, primarily used for warning and analysis purposes. It supports standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Concrete use cases include analyzing C code for undefined behavior when shifting negative integers and implementing custom warnings or transformations based on such analyses.",
      "description_length": 498,
      "index": 2684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary.As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters for library loading in Frama-C, combining core operations for validation, value retrieval, and change tracking with submodules that refine handling of specific parameter types. It supports setting constraints through function checks or string validation, maintains state during dynamic loading, and provides typed collections for valid options. The child module enhances this by defining a dedicated data type for `-load-library` parameters, adding equality, comparison, and pretty-printing capabilities for precise analysis configuration. Together, they enable robust parsing, validation, and manipulation of plugin-related string inputs within Frama-C's kernel.",
      "description_length": 720,
      "index": 2685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map indexed by integer value abstractions, where each key represents a set of integers and values are of a specified data type. It supports operations like equality checking, comparison, hashing, and pretty-printing for maps, along with deep copying and project-based membership queries. It is used to track and manipulate integer-set-indexed data in static analysis contexts, such as associating abstract values or constraints with specific integer ranges.",
      "description_length": 479,
      "index": 2686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associative maps keyed by logic variables, supporting transformations, ordered traversal, and structural queries over arbitrary value types or lists. It provides core operations like merge, filter, compare, and submap extraction, enabling tasks such as static analysis and structured debugging. The key module defines logic variable operations including comparison, hashing, and pretty-printing, while the data module implements type-safe map operations with serialization and iteration. Together, they support use cases like tracking variable properties across analysis phases and managing bindings during CIL processing.",
      "description_length": 642,
      "index": 2687,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option autocompletion, defining operations to create, modify, and enable categories with associated accessors and dependencies. It works with types `t` representing categories and `elt` representing elements within those categories. Concrete use cases include setting the default category, enabling the `@all` category with specific behavior, and adding named categories with accessors for option parsing.",
      "description_length": 453,
      "index": 2688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes wide string-keyed maps with rich operations for ordered traversal, key-based manipulation, and value transformation, alongside utilities for working with list-valued mappings and conversions to and from sequences. It supports core data types including map structures, key-value pairs, and ordered iterators, with operations like merge, filter, and project-aware lookups. You can use it to build and manipulate symbol tables, track properties across C identifiers, or manage configuration data in static analysis plugins. Submodules refine key handling and value typing, enabling precise and efficient map manipulations tied to wide string identifiers.",
      "description_length": 673,
      "index": 2689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G.E",
      "library": "frama-c.kernel",
      "description": "This module represents edges in a control flow graph, where each edge connects two vertices and carries a label. It provides operations to create edges with a source, label, and destination, as well as to retrieve the source, destination, and label of an edge. The module supports directed, ordered edges, making it suitable for modeling transitions in an interpreted automaton with associated conditions and actions.",
      "description_length": 417,
      "index": 2690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes a family of map structures keyed on CIL function definitions, combining efficient associative operations with type-safe value handling for static analysis tasks. It directly supports maps with polymorphic values, offering insertion, deletion, merging, and bidirectional traversal, while its submodules specialize on function-based keys with operations for equality, comparison, hashing, and pretty printing. The key module provides project-aware membership checks and deep copying, enabling robust data tracking across different analysis contexts. Together, they facilitate precise, scalable manipulation of function-specific data during code analysis and transformation.",
      "description_length": 693,
      "index": 2691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V.M",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for associating abstract memory locations with integer values, providing operations to iterate over, query, and fold through these associations. It works with keys of type `Base.t` and values of type `Ival.t`, structured internally as a map (`Location_Bytes.M.t`). It is used to model and manipulate memory states in static analysis, such as tracking the values stored at specific program locations during abstract interpretation.",
      "description_length": 469,
      "index": 2692,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for wide string keys with safe accessors like `find_opt`, supporting creation, insertion, deletion, and deterministic traversal ordered by keys, values, or entries. It enables structured management of mappings from wide string identifiers to analysis data, such as tracking variables or function signatures across translation units in Frama-C plugins. The child modules specialize in defining key types and value types with standard operations including equality, comparison, hashing, and deep copying, ensuring type safety and efficient lookup. Together, they facilitate robust handling of symbol tables and identifier mappings in C analysis contexts requiring consistent ordering and precise data representation.",
      "description_length": 757,
      "index": 2693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps based on normalized filepaths, providing equality, comparison, and hashing operations tailored to file path handling. It supports operations like checking membership within projects, deep copying keys, and pretty-printing for debugging or logging. These functions are used to manage and manipulate filepaths in a structured and consistent way across analysis components.",
      "description_length": 410,
      "index": 2694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice.With_Cardinality",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations for maps combined with sets, supporting cardinality checks and element enumeration. Provides functions to verify if a lattice contains zero or one element, compute differences under cardinality constraints, fold over elements, and extract singleton bindings. Useful for static analysis tasks requiring precise tracking of map and set contents with bounded cardinality.",
      "description_length": 398,
      "index": 2695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool.Map",
      "library": "frama-c.kernel",
      "description": "This module provides an ordered, immutable map structure with boolean keys, enabling efficient queries, functional updates, and set-theoretic operations over boolean-indexed data. It supports traversal in key order and conversion to sequences or lists, making it suitable for static analysis tasks that track binary properties under true/false conditions. The key module defines rich operations for boolean keys, including comparison, hashing, and project-aware equality checks, while the data module instantiates maps mapping booleans to arbitrary values, supporting insertion, lookup, and iteration. Together, they enable precise manipulation of boolean-indexed metadata, such as tracking program properties across conditional branches in analysis plugins.",
      "description_length": 758,
      "index": 2696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Set",
      "library": "frama-c.kernel",
      "description": "This module provides set-theoretic operations (union, intersection, difference) and ordered traversal capabilities for collections of CIL terms, supporting transformations like filtering, mapping, and partitioning. It operates on sets of elements with precise ordering semantics, enabling efficient membership checks, nearest-element queries, and conversions to/from sequences or lists. These operations are utilized in static analysis tasks such as tracking term relationships, managing program state abstractions, and implementing semantic analyses over CIL-converted code.",
      "description_length": 575,
      "index": 2697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_ctor_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in diff computations involving logic constructors. It includes utilities for deep copying values, checking project membership via predicates, and managing type representations, descriptors, and packed descriptors. These features support precise structural analysis and differencing of logic constructs in Frama-C's AST.",
      "description_length": 451,
      "index": 2698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets of CIL expressions with efficient membership testing and structural consistency, using unique expression identifiers (eids) for equality checks. It provides operations like union, intersection, difference, and ordered traversal, alongside functional transformations (map, filter) and conversions to lists/sequences, supporting use cases such as static analysis plugins that track or manipulate collections of expressions during code verification. Key applications include managing expression dependencies, performing bulk set operations, and iterating over structured CIL elements in analysis workflows.",
      "description_length": 639,
      "index": 2699,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines keys for a typed parameter hashtable, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a custom key type that includes project-specific data, enabling checks and deep copies of key values. Concrete use cases include managing and querying typed parameters with project dependencies in Frama-C's kernel.",
      "description_length": 365,
      "index": 2700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info.Set",
      "library": "frama-c.kernel",
      "description": "This set interface provides operations for managing and transforming ordered collections of `Model_info.t` elements, including union, intersection, mapping, filtering, and nearest-element queries. It maintains elements in increasing order, supports both functional and physical equality checks, and offers conversions to sequences and lists, along with utilities for hashing and project membership verification. These capabilities are utilized in static analysis plugins to handle CIL model data, such as tracking analysis states or variable dependencies during program verification.",
      "description_length": 583,
      "index": 2701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for CIL statements, providing operations for equality checking, comparison, hashing, and pretty-printing of statement values. It supports efficient lookups and storage of CIL statement-based data, ensuring deep copies and project-aware membership checks. Concrete use cases include tracking and analyzing control flow statements or maintaining statement-specific metadata during static analysis.",
      "description_length": 458,
      "index": 2702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Action",
      "library": "frama-c.kernel",
      "description": "This module manages boolean plugin options with support for state changes, serialization, and alias definitions, operating on a boolean type with typed parameters and activation functions. It integrates structured data handling through a registered type that supports equality, comparison, hashing, and deep copying, enabling rich representations of plugin state and configuration. Users can define and manipulate plugin features dynamically, track project-specific settings with customizable hooks, and ensure strong identity and structural consistency for values like analysis results or configuration objects. The combined interface allows for both simple boolean toggles and complex, structured data operations within the same configuration framework.",
      "description_length": 755,
      "index": 2703,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.M",
      "library": "frama-c.kernel",
      "description": "This module manages associations between memory bases and byte-level offset intervals. It provides operations to iterate over, fold, and query these associations, enabling precise tracking of memory regions in terms of base pointers and their corresponding byte ranges. It is used in static analysis to represent and manipulate memory layouts at the byte level, such as during pointer aliasing or memory footprint computations.",
      "description_length": 427,
      "index": 2704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes dictionaries that map control-flow instructions from CIL's intermediate representation to arbitrary values, enabling key-based access, ordered traversal, and structural transformations. It supports operations like merging, filtering, and comparison with precise control over instruction ordering, while offering analysis utilities for dataflow tracking and property aggregation. The child modules provide concrete instantiations for working with `Kinstr.t` keys and associated data, including lookup, iteration, and pretty-printing, enabling tasks like tracking analysis results or transformation metadata at specific code locations. Together, they facilitate efficient, instruction-centric data manipulation with customizable iteration and debugging support across compiler passes and static analysis plugins.",
      "description_length": 832,
      "index": 2705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.VTable",
      "library": "frama-c.kernel",
      "description": "The module provides a specialized hash table for mapping control flow graph vertices to arbitrary values, supporting imperative operations like insertion, filtering, and traversal. It works with vertices from an unnatural loop-unrolled control flow graph, enabling ordered iteration, memoization, and state manipulation during abstract interpretation of programs. This structure is particularly useful for tracking dataflow properties or analyzing reachable states in transformed loops where entry points are normalized.",
      "description_length": 520,
      "index": 2706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes vertex-based associative maps for control flow graph analysis, where keys represent automaton vertices and values carry analysis data. It supports standard operations like insertion, filtering, and ordered traversal, alongside specialized merging strategies for handling transitions with guards and actions. The module includes a key module defining vertex identifiers with equality, comparison, and project membership checks, and a data module implementing vertex-keyed maps with parameterized values, enabling precise state tracking and constraint propagation across control flow edges. Example uses include aggregating path-sensitive data, tracking reachable states, and propagating analysis results through control flow transitions.",
      "description_length": 758,
      "index": 2707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized hash table for CIL expression identifiers (`Lval.t`), using structural equality via `eid` to enable efficient storage and retrieval of data linked to program expressions. It supports imperative operations such as insertion, lookup, and in-place updates, along with advanced traversal through folding and filtered iteration, making it suitable for static analysis tasks like caching results or tracking variable properties. A dedicated key module provides structural comparison, hashing, and pretty-printing for `Lval` values, while a derived hash table module adds serialization, deep copying, and project-aware operations for use in CIL-based plugins.",
      "description_length": 689,
      "index": 2708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation for CIL expressions using structural equality and strict constant comparison, enabling efficient key-based operations like insertion, lookup, and ordered iteration. It supports advanced traversal with custom comparators, safe value retrieval via `find_opt` and `find_def`, and memoization patterns for static analysis tasks such as value tracking and code simplification. The key module defines a type with equality, comparison, and hashing operations tailored for expression keys, while the table module implements hash tables over these keys, supporting deep copying, project membership checks, and pretty-printing. Together, they enable precise expression equivalence checks and efficient management of expression-based mappings in Frama-C plugins.",
      "description_length": 800,
      "index": 2709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for managing expressions with structural equality and size-based comparison semantics, primarily used in C analysis contexts. It supports ordered traversal, set algebra operations (union, intersection, difference), and element-wise transformations while preserving equivalence rules where expressions of the same size (particularly within `sizeof` operations) are treated as equal. Typical applications include static analysis plugins requiring precise expression grouping, size-aware dataflow analysis, or equivalence checking in C programs where structural identity and memory footprint alignment are critical.",
      "description_length": 656,
      "index": 2710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top.Option",
      "library": "frama-c.kernel",
      "description": "This module provides `iter` and `map` functions that operate on `option` values within a lattice context where top values are explicitly handled. It works with optional values (`'a option`) and lattice-aware computations returning `Top.t`. Use cases include safely transforming or iterating over optional lattice elements while preserving top semantics, such as propagating top through optional results in static analysis.",
      "description_length": 422,
      "index": 2711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with ordered traversal and value memoization, using CIL function keys to manage analysis results or metadata in plugins. It provides key-based sorting, sequence conversion, and safe value access with default fallbacks, operating on parameterized key-value pairs where keys are tied to Frama-C's CIL representation. The key module supplies equality, comparison, hashing, and pretty-printing for key values, enabling efficient lookups and deep copies over project skeletons, while the data module specializes the hash table for a given value type, supporting fast access and structural consistency checks on CIL entities like functions or variables. Example uses include tracking analysis states across translation units or caching computed properties of C functions with deterministic iteration and key-specific computations.",
      "description_length": 859,
      "index": 2712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes and extends map operations for CIL-based key-value structures with strict equality, combining ordered traversal and transformation with precise key differentiation. It provides core operations like insertion, lookup, aggregation, and ordered iteration, along with child modules that define key types and data mappings based on CIL lvalues. The main data types include maps keyed by CIL lvalues and associated data values, supporting operations such as `find`, `add`, `iter`, and `map`, with strict structural comparison and optional or exception-based handling of missing keys. Examples include tracking memory states during static analysis, transforming CIL intermediate representations with deterministic ordering, and managing dependencies based on precise CIL value identities.",
      "description_length": 803,
      "index": 2713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintPluginPath.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating values related to plugin paths in the kernel. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, along with utilities to inspect and filter based on embedded project data. It is used to manage and query plugin path information in a structured and type-safe manner.",
      "description_length": 390,
      "index": 2714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associative maps keyed by CIL types, using structural comparison that disregards attributes, enabling precise type-based lookups and transformations. It supports standard operations like insertion, deletion, ordered traversal, and value aggregation, with keys and maps tailored for static analysis tasks such as tracking type equivalence or associating metadata with types. The key submodule provides comparison, hashing, and pretty-printing for attribute-agnostic type keys, while the map submodule implements type-indexed maps with deep copying and project-aware membership. Examples include aggregating type properties during analysis, mapping types to metadata in plugins, and efficiently organizing CIL-based data by structural type identity.",
      "description_length": 767,
      "index": 2715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo.Map",
      "library": "frama-c.kernel",
      "description": "This module implements immutable maps keyed by CIL enumeration information, enabling efficient lookups, transformations, and analysis of enum-related data. It provides core operations like fold, map, filter, and optional-value handling, while its key module supports comparison, hashing, and pretty-printing for enum-based keys. A specialized map submodule enables value-specific analysis, such as tracking enum constants and their attributes during static analysis. Together, these components support structured, ordered traversal and manipulation of C enumeration metadata with functional purity and structural sharing.",
      "description_length": 621,
      "index": 2716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables optimized for managing key-value associations where keys are CIL attributes, supporting insertion, deletion, iteration, and bulk transformations. It enables ordered traversal, safe key lookups with defaults, and memoization, particularly for attribute-centric data in CIL analysis tasks like tracking compiler annotations or optimizing intermediate representations. The key module handles project-aware key operations such as equality, comparison, hashing, and pretty-printing, while the value module supports structured `Data.t` values with deep copying, membership checks, and integration with Frama-C's typing system. Examples include tracking function annotations during static analysis or transforming attribute-based metadata across CIL constructs with efficient, project-specific filtering.",
      "description_length": 841,
      "index": 2717,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Bool",
      "library": "frama-c.kernel",
      "description": "This module handles boolean logic and configuration flags with rich operations for parsing, comparing, and printing boolean values. It centers around `Datatype.t` for representing boolean states, supporting equality, hashing, and membership checks. Submodules extend this functionality to command-line option handling, enabling the definition and management of boolean flags in Frama-C plugins. Example uses include parsing user-provided boolean settings and enforcing boolean constraints within plugin logic.",
      "description_length": 509,
      "index": 2718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G.V",
      "library": "frama-c.kernel",
      "description": "This module defines vertices for a state dependency graph, where each vertex is labeled and comparable. It provides operations to create vertices from labels, retrieve vertex labels, and compare, hash, or check equality of vertices. The module works with states as the underlying data type, using their labels to manage identity and relationships in the graph.",
      "description_length": 360,
      "index": 2719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation for mapping CIL locations to arbitrary data, supporting imperative operations like insertion, deletion, and lookup, along with ordered iteration and in-place transformations using custom key comparisons. It includes utilities for safe value retrieval (`find_opt`, `find_def`), memoization, and integration with OCaml sequences, enabling efficient tracking of analysis metadata or caching of computation results during static analysis. A child module defines key operations tailored to CIL location data, offering equality, comparison, hashing, and pretty-printing, while another creates a specialized hash table type for location-indexed values from a given `Data` module. Together, they enable precise manipulation and analysis of C code locations, such as mapping them to analysis outcomes or transformation rules.",
      "description_length": 865,
      "index": 2720,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes memory regions using offset-based keys, where each key represents a memory base and offset, and maps them to arbitrary values, often lists, to support complex memory state modeling. It provides operations for inserting, deleting, and merging memory entries, as well as updating list-valued data, enabling tasks like tracking memory transitions and merging allocation data during static analysis. The first child module defines and manipulates the key structure, ensuring proper ordering, comparison, and efficient use within the map, while the second child module implements the actual map structure, parameterized over data, to manage memory maps associated with each base. Together, they support deterministic traversal, deep copying, and project-based queries, essential for program verification and memory state analysis.",
      "description_length": 847,
      "index": 2721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic operation `only_if` that conditionally executes a monadic action based on a boolean flag. It works with monadic values of type `unit t`, allowing actions to be gated by runtime conditions without altering their core behavior. A concrete use case is selectively running analysis steps in static analysis tools when certain flags are enabled.",
      "description_length": 371,
      "index": 2722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for manipulating collections of abstract memory states, enabling efficient union, intersection, difference, and ordered transformations via functions like `map`, `filter`, and `fold`. It works with sets of elements representing memory slices, ordered via a total comparison function, and supports conversions to sequences, nearest-element queries, and integration with static analysis plugins. Key use cases include tracking possible memory configurations during program analysis, merging or partitioning states, and deterministic processing of abstract values in Frama-C's value analysis framework.",
      "description_length": 643,
      "index": 2723,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enumitem.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing abstract values in the context of projectified AST diffs. It supports concrete operations like deep copying, equality checking, comparison, hashing, and pretty printing, specifically tailored for use with Frama-C's internal project and AST structures. The type `t` encapsulates values that can include project-specific information, ensuring correct handling when custom rehashing is required.",
      "description_length": 470,
      "index": 2724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural.E",
      "library": "frama-c.kernel",
      "description": "This module represents edges in a control flow graph with ordered, directed connections between vertices, each labeled with versioned automaton edges. It provides operations to create edges between vertices, retrieve source and destination vertices, and access edge labels, which encapsulate guards and actions from the original program. Concrete use cases include modeling transitions in abstract interpretation where unnatural loops are normalized, enabling precise state reachability analysis.",
      "description_length": 496,
      "index": 2725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map.Map",
      "library": "frama-c.kernel",
      "description": "This module implements persistent ordered key-value maps with polymorphic keys and values, supporting efficient insertion, deletion, and functional transformations like `merge` and `mapi`. It enables ordered traversal via `to_seq` and `min_binding`, and provides conversions to and from lists and sequences, making it ideal for static analysis tasks such as tracking variable bindings or symbolic expressions. Submodule 1 defines key operations including comparison and hashing, essential for managing symbolic identifiers in analysis plugins, while Submodule 2 constructs full map types from a given data module, enabling type-safe symbol tables and configuration stores with rich data associations.",
      "description_length": 700,
      "index": 2726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent map structure keyed on CIL types compared structurally without unrolling, supporting ordered traversal, set-like operations, and transformations via folds and mergers. It combines structural key comparison with efficient operations on arbitrary value types, enabling precise type-based indexing for static analysis tasks such as tracking type-specific properties or managing analysis results across type hierarchies. The key module ensures structural equivalence checks, hashing, and pretty-printing for type identifiers, while the data module supports project-aware storage and comparison of values tied to those types. Example uses include mapping structs to analysis metadata or aggregating type-based constraints across translation units.",
      "description_length": 776,
      "index": 2727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables mapping CIL global identifiers to arbitrary values, supporting operations like insertion, lookup, and in-place filtering, along with deterministic traversal and memoization. It enables creation of specialized hash tables for specific value types, with utilities for serialization, comparison, and pretty-printing, useful for tracking CIL AST nodes or analysis results. The module includes key definitions for global variables in CIL, allowing efficient storage and retrieval based on unique identifiers with support for equality, hashing, and ordered iteration. Examples include caching analysis results per function or variable, or collecting and transforming global state across C program points.",
      "description_length": 731,
      "index": 2728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for associating CIL types with arbitrary values, using structural comparison without unrolling to ensure deterministic behavior during static analysis. It supports core operations such as insertion, lookup, iteration, and folding over keys of type `TypNoUnroll.t`, which uniquely represent CIL types while preserving their structural identity. The module enables efficient memoization, caching of type-specific computations, and integration with Frama-C's analysis pipelines through sequence conversions. Submodules handle key management and deep value operations, supporting use cases like tracking type definitions, comparing type-based properties, and performing deterministic analysis across C codebases.",
      "description_length": 752,
      "index": 2729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepHeader.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating architecture-dependent data structures used in the `-print-machdep-header` functionality. It includes equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to handle and inspect machine-dependent type information during kernel analysis.",
      "description_length": 391,
      "index": 2730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table structure for managing data indexed by CIL statements, enabling efficient key-based operations like insertion, deletion, and lookup, as well as bulk transformations such as iteration and in-place filtering. It supports customizable comparison functions for sorted traversal and is designed for static analysis tasks that associate values with specific code statements, such as tracking analysis results or metadata. The first child module defines a key type with operations for equality, comparison, and hashing, ensuring efficient retrieval and distinct key identity, while the second implements a fully functional hash table for statement-indexed data with support for equality, comparison, and pretty-printing. Together, they allow precise, scalable manipulation of statement-level data in C code, such as memoizing analysis outcomes or maintaining per-statement annotations across transformations.",
      "description_length": 935,
      "index": 2731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling unsigned downcast warnings in Frama-C's kernel. It provides functions for equality, comparison, hashing, pretty-printing, and deep copying of values of type `t`, along with utilities to inspect and manipulate project-related data through `mem_project`. The type `t` is used to represent and manage internal state related to the `-warn-unsigned-downcast` option's behavior during analysis.",
      "description_length": 463,
      "index": 2732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This component offers ordered set operations with creation, union, intersection, filtering, and ordered iteration, working with elements maintained via a total ordering comparison function. It supports conversion between sets and sequences, nearest-element queries, and structural analysis, enabling use cases like tracking program states or dependencies where ordered collections require efficient membership checks and ordered traversal. The design integrates with static analysis workflows needing precise set manipulation and introspection for properties like hashability or subset relationships.",
      "description_length": 600,
      "index": 2733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations with ordered keys, supporting insertion, lookup, deletion, and combination operations like `merge` and `union`. It enables deterministic traversal and transformation of maps over key ranges, with child modules providing key comparison logic and structured value handling. The key type module ensures consistent equality, comparison, and hashing for structured data, while the value module builds map datatypes with standard operations based on a given `Data` module. Use cases include managing symbol tables, merging configurations, and analyzing program elements indexed by identifiers with customizable display and structural manipulation.",
      "description_length": 684,
      "index": 2734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global.Map",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps with ordered keys of type `Global.t` and polymorphic values, offering efficient insertion, deletion, lookup, and traversal operations. It supports advanced transformations like merging, filtering, and reverse iteration, along with customizable pretty-printing and conversions to sequences and lists, making it suitable for static analysis tasks such as managing CIL program elements. The child modules specialize the map for specific data types and define key operations including equality, comparison, and hashing, enabling structured handling of CIL entities like variables and functions indexed by identifiers. Together, they facilitate project-aware analysis, deep copying, and key-based manipulations during code processing and verification.",
      "description_length": 786,
      "index": 2735,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enuminfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and manipulating abstract values in the context of computing project diffs. It supports equality, comparison, hashing, and pretty-printing of values, along with deep copying and project membership checks. Concrete use cases include tracking structural changes across different versions of a project's abstract syntax tree.",
      "description_length": 386,
      "index": 2736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module manages sets of CIL expressions with structural equality and strict constant comparison, offering operations for set algebra (union, intersection, difference), ordered traversal, and element manipulation (addition, removal, selection). It supports functional transformations like mapping, filtering, and folding, along with utilities for conversion to lists/sequences and nearest-element queries. It is particularly useful in static analysis or code transformation plugins requiring precise handling of expression equivalence and ordered set operations.",
      "description_length": 565,
      "index": 2737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associative maps keyed by memory locations with bit-level precision, combining base pointers and offsets to enable accurate tracking of memory states. It supports efficient insertion, lookup, union operations, and ordered traversal, with optimizations for physical equality, making it ideal for merging symbolic execution paths in program verification. The child modules provide the key type `Location_Bits` and corresponding map implementation, enabling operations like equality testing, comparison, and pretty-printing for both keys and maps. Together, they facilitate detailed memory layout analysis and manipulation during static analysis of low-level code.",
      "description_length": 681,
      "index": 2738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation designed for CIL l-values, using structural equality and strict constant comparison to ensure precise equivalence checks. It supports standard operations like insertion, lookup, iteration, and bulk updates, along with child modules that define key types and utilities for deep copying, equality checks, and pretty printing. The combined functionality enables static analysis plugins to track and memoize equivalent program elements, such as expressions or data layouts, with strict identity guarantees. For example, it can be used to cache analysis results for structurally identical C expressions or to track value changes across program states with exactness.",
      "description_length": 710,
      "index": 2739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Enums.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating a specific datatype `t` used in the analysis of enumerations. It provides equality, comparison, hashing, and pretty-printing functions, along with utilities for deep copying and checking project membership. The module is used to handle enumeration-related data during static analysis, particularly for processing and comparing enumeration types in C code.",
      "description_length": 416,
      "index": 2740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for normalized filepaths, where keys are filepaths and values are of a specified data type. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage and manipulate filepath-indexed data in a type-safe and efficient manner, particularly in static analysis contexts where precise file-level tracking is required.",
      "description_length": 463,
      "index": 2741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables with in-place modification, sorted traversal, and sequence conversion, working with standard OCaml hashtables and sequences. It supports key-value storage where keys conform to a specific type, enabling operations like memoization, ordered collection management, and default value handling. One child module specializes in hash tables with keys of type `Data.t`, offering equality, comparison, and deep copying for efficient structural manipulation, while another focuses on key handling with operations on `Hashtbl.Key.t`, supporting unique identifiers and consistent key inspection across implementations. Example uses include memoizing function results, maintaining sorted key-based iterations, and integrating hash tables with project-specific data and key constraints.",
      "description_length": 806,
      "index": 2742,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Set_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a state builder for a set-like reference type with a structured descriptor, providing operations to manage and query the state's representation, equality, comparison, and pretty-printing. It works with a specific data type `t` that encapsulates values of type `Datatype.t`, supporting deep copies, membership checks over project skeletons, and hash-consing. Concrete use cases include building and manipulating abstract states in static analysis plugins, where precise and efficient state tracking is required.",
      "description_length": 533,
      "index": 2743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InitializedPaddingLocals.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for managing and comparing structured values, including equality, comparison, hashing, and pretty-printing. It works with a specific type `t` that includes attributes like name, type, and descriptors, supporting deep copying and project membership checks. Concrete use cases include representing and manipulating structured data in kernel extensions, such as handling options like \"-initialized-padding-locals\" and ensuring consistent value comparisons and storage.",
      "description_length": 513,
      "index": 2744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Lval_hashtbl.Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a hash table for values of type `Datatype.t` with standard operations including insertion, lookup, and iteration. It supports efficient equality checks, hashing, and pretty-printing of stored values. This structure is particularly useful for managing collections of computed values in analyses that require fast access and comparison, such as tracking memory states or variable bindings during static analysis.",
      "description_length": 421,
      "index": 2745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables specialized for CIL logic labels, offering creation, lookup, iteration, and memoization with customizable key ordering. It provides core operations like `find_opt`, `find_def`, and in-place updates, supporting advanced workflows such as sequence-based initialization and structural introspection in static analysis. Submodules define key and value datatypes with equality, comparison, and pretty-printing, enabling precise tracking and manipulation of logic labels across CIL constructs. Examples include associating metadata with control flow annotations or managing verification conditions using project-aware membership and deep copying.",
      "description_length": 675,
      "index": 2746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G.V",
      "library": "frama-c.kernel",
      "description": "This module defines operations for creating, comparing, and labeling vertices in a control flow graph representing an interpreted automaton. It works with vertices of type `t` that are hashable, comparable, and associated with labels of type `label`. Concrete use cases include managing control points in the automaton's structure, enabling precise tracking of program states during abstract interpretation.",
      "description_length": 407,
      "index": 2747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Modules.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use with logic environment modules. It includes functions for deep copying values, checking membership of project skeletons, and retrieving type descriptors and representants. Concrete use cases include managing and comparing structured logic entities in static analysis plugins.",
      "description_length": 412,
      "index": 2748,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for values of a specified data type, supporting operations like equality, comparison, hashing, and pretty printing. It works with project-compliant mutable states and provides deep copying, membership testing by project, and type-safe handling through a unique type descriptor. Concrete use cases include managing and manipulating collections of analysis states keyed by project-specific identifiers.",
      "description_length": 439,
      "index": 2749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module manages sets of kernel functions with operations for membership, iteration, folding, and serialization, while tracking changes and managing aliases for plugin state synchronization. It works with `Frama_c_kernel.Cil_types.kernel_function` elements and includes submodules that support categorization, dynamic configuration via command-line options, and manipulation of string parameters with validation and serialization. The module enables precise grouping and activation of functions through categories, provides core utilities like comparison and pretty-printing for data manipulation, and supports defining string-based options that integrate with Frama-C's state system. Use cases include tracking safety-critical functions, synchronizing analysis results across plugins, and managing configurable function sets via command-line controls.",
      "description_length": 855,
      "index": 2750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_type_info.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in logic type information. It supports structured values with descriptors, representants, and project-aware memory checks, ensuring deep copies and user-friendly output formatting. Concrete use cases include managing and comparing logic type representations in static analysis tools.",
      "description_length": 403,
      "index": 2751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes mappings from CIL types\u2014compared structurally by name without unrolling\u2014to arbitrary values, enabling precise type-based associations in static analysis. It supports core operations like insertion, deletion, ordered traversal, and transformation through folding or filtering, while preserving key ordering and offering utilities for list updates, sequence conversions, and pretty-printing. The key module provides structural comparison, hashing, and deep copying for CIL type keys, and the value module builds on these to implement type-indexed maps with project-aware operations. Examples include tracking type-specific properties across C program elements or transforming code using name-sensitive type comparisons.",
      "description_length": 739,
      "index": 2752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a functional map interface for key-value associations where keys are logic real numbers, supporting insertion, deletion, lookup, and ordered traversal. It includes safe and unsafe access patterns, aggregation, filtering, and transformation operations, with utilities for sequence conversion, pretty-printing, and set-theoretic comparisons. The key module defines equality, comparison, and hashing for logic real keys, enabling efficient lookups and manipulations in static analysis plugins handling logical expressions. The specialized map module maintains structural key ordering and offers standard operations, making it suitable for managing numerical constraints in symbolic reasoning tasks.",
      "description_length": 716,
      "index": 2753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PointerDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing structured values within Frama-C's kernel. It provides functions for equality checking, comparison, hashing, pretty-printing, and deep copying, along with descriptors for type representation and project membership testing. Concrete use cases include tracking and manipulating pointer downcast warnings with precise type and project information during static analysis.",
      "description_length": 456,
      "index": 2754,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Set",
      "library": "frama-c.kernel",
      "description": "This module implements a set structure for managing elements with structural equivalence and ordering constraints, supporting standard set operations like union, intersection, and difference, as well as element queries (e.g., min/max/nearest element detection) and transformations (e.g., filtering, mapping). It works with ordered, comparable elements that enforce structural equality, enabling precise set algebra and sequence-based construction/iteration. Specific applications include static analysis tasks requiring canonical representation of logical predicates, such as constraint simplification or path-sensitive analysis in C code verification.",
      "description_length": 652,
      "index": 2755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables tailored for CIL attributes, enabling efficient storage and retrieval of key-value pairs where keys are derived from CIL's attribute type hierarchy. It supports operations such as insertion, lookup with optional returns, and sorted iteration using custom comparisons, facilitating attribute management in Frama-C plugins for tasks like metadata tracking or analysis memoization. The associated key module ensures robust handling of attribute identifiers with equality, hashing, and pretty-printing, while the value module offers structured manipulation of stored data, such as annotating AST nodes or transforming function attributes during static analysis.",
      "description_length": 690,
      "index": 2756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table for managing emitter-specific data with polymorphic values, supporting insertion, lookup with fallbacks, and ordered iteration over keys, values, or entries. It works with hash tables keyed by `Usable_emitter.t` instances, enabling structured data association and memoization for tasks like tracking annotations, caching analysis results, or handling emitter-related state in Frama-C plugins. Child module 1 specializes the hash table for `Data.t` values, offering typed representations with equality, comparison, and project-aware checks, useful for emitting and tracking analysis results. Child module 2 defines a key type for emitter-generated annotations, supporting standard operations and deep copying, with use cases in managing distinct annotation sources or property identifiers in Frama-C's analysis framework.",
      "description_length": 866,
      "index": 2757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for managing file-specific preprocessor arguments in Frama-C. It supports equality checks, comparison, hashing, and pretty-printing for values representing argument configurations. It is used to handle and manipulate per-file `-cpp-extra-args` settings during analysis.",
      "description_length": 316,
      "index": 2758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Value_int",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for integer values, supporting operations like parsing from strings, pretty-printing, and deep copying. It works with the `int` type, providing equality checks, comparisons, and hashing for use in option handling and configuration. Concrete use cases include defining and managing numeric command-line flags or configuration parameters in Frama-C plugins.",
      "description_length": 399,
      "index": 2759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingLevel.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling unfolding levels in the kernel. It supports deep copying, membership checks over project skeletons, and provides representants along with descriptors for structural manipulation. Concrete use cases include managing and comparing different levels of code unfolding during analysis, ensuring consistent representation and efficient lookup in the context of Frama-C's kernel services.",
      "description_length": 510,
      "index": 2760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable set abstraction for 32-bit integers with a comprehensive suite of operations including standard set algebra (union, intersection, difference), element-wise transformations, ordered traversal, and bidirectional sequence conversions. It supports efficient querying through monotonic predicate searches, nearest-value lookups, and cardinality tracking, while providing project-specific utilities for deep copying and membership testing. The interface is optimized for functional manipulation of integer ranges in static analysis contexts, such as tracking program state abstractions or bit-precise value sets during code verification tasks.",
      "description_length": 673,
      "index": 2761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table for CIL expressions with structural equality, treating expressions involving `sizeof` as equivalent when their operand types have the same size. It supports standard operations like insertion, lookup, iteration, and folding, along with sequence-based bulk updates and sorted traversals, enabling efficient static analysis tasks such as points-to analysis or value tracking. The key module defines a key type with structural equality and comparison, handling `sizeof` expressions by type size equivalence, while the value module manages `Data.t` values with precise structural identity. Together, they enable robust expression comparison, caching, and analysis across different program states and projects.",
      "description_length": 751,
      "index": 2762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent map structure with float keys and arbitrary values, supporting ordered operations like insertion, deletion, and merging, along with traversal in ascending or reverse order. It includes utilities for functional transformations, filtering, and sequence conversion, enabling tasks like numerical data aggregation or symbolic expression manipulation. A dedicated key module handles comparison, hashing, and pretty-printing, allowing custom key behavior and deep copying, which is useful when working with complex or project-specific key types. The float-specific implementation ensures precise handling of real-number keys in applications such as static analysis or semantic modeling, where exact key ordering and efficient lookup are critical.",
      "description_length": 774,
      "index": 2763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps with rational numbers, providing equality, comparison, and hashing operations. It supports structured data representation with type descriptors, pretty printing, and project membership checks. Concrete use cases include managing symbolic keys in static analysis contexts and ensuring deep copies for state manipulation.",
      "description_length": 373,
      "index": 2764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists in a composed monad context, specifically supporting `iter`, `map`, and `fold_left` functions that sequence list elements through a combined monadic structure. It works with lists of values wrapped in an interior monad, producing results in the exterior monad. Concrete use cases include processing sequences of effectful computations where each element depends on shared state or may fail, such as parsing or analyzing structured input with side effects.",
      "description_length": 518,
      "index": 2765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Bool_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean reference datatype with standard operations including equality, comparison, hashing, and pretty printing. It provides a deep copy function, checks for the presence of specific project values, and includes type descriptors for integration with analysis frameworks. It is used to manage boolean state values in static analysis plugins, where each instance represents a distinct boolean reference with associated project-specific metadata.",
      "description_length": 466,
      "index": 2766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables for associating CIL `Fieldinfo.t` keys with arbitrary values, supporting insertion, lookup, iteration, and folding. It provides utilities for sorted traversal, safe key access via `find_opt` and `find_def`, and conversion to sequences, enabling flexible data association in CIL-based analyses. A child module specializes the hash table for a given `Data` module, providing equality, comparison, hashing, and pretty printing for concrete use cases like tracking and comparing field information. Another child module defines the key type based on CIL field metadata, supporting efficient lookups and manipulations such as tracking field offsets or types during static analysis.",
      "description_length": 721,
      "index": 2767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines custom operators for manipulating lattice values that include explicit top and bottom elements. It supports mapping, binding, and pairing operations over these lattice values, ensuring proper narrowing behavior when combining `Bottom` and `Top`. These operators are used to implement precise lattice-based analyses in static program verification.",
      "description_length": 366,
      "index": 2768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsGenerate.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate abstract data structures related to assembly contract generation. It includes functions for deep copying values, checking membership based on project predicates, and exposing type descriptors for integration with Frama-C's internal mechanisms. Concrete use cases include managing and comparing contract data during analysis of assembly code triggered by the `-asm-contracts` option.",
      "description_length": 536,
      "index": 2769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and customizing generated specifications via command-line options. It provides operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`, each controlling how specification templates are applied. Use cases include configuring which specification behaviors are active during analysis and defining how `-generated-spec-custom` interprets named categories.",
      "description_length": 433,
      "index": 2770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_templates.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use with custom descriptors and project-aware values. It supports deep copying, membership checks over project skeletons, and provides representants for the datatype. Concrete use cases include managing and comparing structured analysis data in Frama-C plugins, particularly when custom rehashing or project-specific equality is required.",
      "description_length": 454,
      "index": 2771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage boolean parameters dynamically, allowing retrieval, setting, and checking of named boolean values. It works with string-identified parameters and supports concrete use cases like toggling analysis options or querying the state of a plugin's boolean settings. Functions include direct on/off switches, value checks, and reset capabilities for named boolean parameters.",
      "description_length": 409,
      "index": 2772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes mappings from term locations to arbitrary data, enabling ordered traversal, transformation, and bulk operations like filtering and partitioning. It supports key operations such as safe lookups, custom-formatted output, and project-aware comparisons, with child modules handling term location keys and type-specific data management. You can use it to track variable relationships during static analysis, perform code transformations, or verify properties across C expressions using precise memory location mappings. The design integrates deep copying, equality checks, and pretty-printing to streamline manipulation and inspection of complex term-based data.",
      "description_length": 679,
      "index": 2773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Make_set",
      "library": "frama-c.kernel",
      "description": "This module manages a set-based configuration abstraction for Frama-C plugins, enabling dynamic manipulation of element collections with atomic updates, change tracking, and persistent state serialization. It operates on a set type (`E.Set.t`) with elements of type `elt`, offering membership checks, iterative transformations, and empty-state verification, while integrating metadata handling through submodules for string representation, category classification, and custom data structure management. The string-handling submodule supports equality, comparison, and pretty-printing of string parameters, enabling consistent handling across plugin components, while the category submodule allows grouping and controlling parameters under named sets for collective behavior and fallback definitions. Together, these components support hierarchical option management with versioned aliases, visibility controls, and deprecation workflows in static analysis toolchains.",
      "description_length": 967,
      "index": 2774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.List",
      "library": "frama-c.kernel",
      "description": "This module provides operations to traverse and transform lists within a lattice structure that explicitly handles bottom values. It supports `iter`, `map`, and `fold_left` functions that propagate bottom values through list computations. It is used in static analysis to handle potentially undefined or failed computations over list-structured data.",
      "description_length": 350,
      "index": 2775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp.Map",
      "library": "frama-c.kernel",
      "description": "This module manages key-value associations where keys are CIL expressions with structural equality and values are polymorphic or type-specific. It supports ordered traversal, structural transformations like filtering and merging, and operations tailored for list-valued maps and reverse iteration. Submodules provide specialized map implementations for custom data types and define efficient key operations for CIL expressions, enabling use cases such as caching analysis results or tracking expression metadata across passes. Examples include building and transforming maps from sequences, filtering maps based on key properties, and serializing expression-indexed data for analysis state management.",
      "description_length": 701,
      "index": 2776,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintReturn.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling values related to the `-print-return` option's behavior. It supports structured data representation with a descriptor, packed descriptor, and a list of representants, enabling precise type manipulation and introspection. Use cases include managing and comparing structured data values in kernel plugins, particularly for analyzing or transforming program return values during static analysis.",
      "description_length": 522,
      "index": 2777,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table implementation tailored for managing and analyzing C source code declarations within Frama-C. It introduces a key type for uniquely identifying declaration elements, supporting operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. The accompanying typed hash table module extends this functionality to values of type `Data.t`, enabling efficient storage and retrieval of analyzed AST elements. Together, they facilitate project-aware analysis plugins with robust, typed data management and integration into Frama-C's description system.",
      "description_length": 654,
      "index": 2778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.Kernel_function_map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between kernel functions and configurable values, supporting dynamic updates through command-line options and change hooks. It provides a customizable map structure with keys based on function declarations, including pure prototypes, and values that can be strings, lists, or categorized settings, offering operations for addition, lookup, iteration, serialization, and equality checks. The module enables plugins to track function-specific configurations across analysis sessions, resolve string-based identifiers with validation and aliases, and organize settings using named categories that influence analysis behavior. It integrates with submodules that handle function key comparison, string parameter management, and category-based grouping for structured configuration control.",
      "description_length": 813,
      "index": 2779,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module organizes hash tables mapping logic metadata keys to structured values, supporting imperative updates, functional transformations, and ordered traversal. It combines key management from its child modules\u2014handling built-in CIL logic information and user-defined data\u2014with value operations for equality, comparison, and pretty-printing. You can use it to cache analysis results keyed by type information, track logic functions across contexts, or process CIL expressions with deterministic traversal. The module enables safe lookups, bulk updates via sequences, and consistent key-value manipulations tailored for static analysis plugins.",
      "description_length": 648,
      "index": 2780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for chaining computations that produce values within a monadic context. It provides infix functions like `>>-`, `let*`, `>>-:`, and `let+` to sequence actions, bind results, and map functions over monadic values. These operators are used to work with custom monads built using the `Make_based_on_bind` functor, enabling concise and compositional handling of effectful computations such as error handling, state management, or optional values.",
      "description_length": 480,
      "index": 2781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedDowncast.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling signed downcast warnings in the kernel. It provides functions for equality, comparison, hashing, and pretty-printing values of type `t`, along with utilities for project membership checks and deep copying. The module is used to manage and manipulate warning data tied to the `-warn-signed-downcast` option during static analysis.",
      "description_length": 404,
      "index": 2782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InlineStmtContracts.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for managing and comparing values related to statement contract inlining behaviors. It provides equality, comparison, hashing, and pretty-printing functions, along with utilities for checking project membership and performing deep copies. The module is used to handle structured data representations within the kernel, particularly for plugins or features interacting with statement contracts and project-specific logic.",
      "description_length": 482,
      "index": 2783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SpecialFloat.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling special floating-point values in the context of Frama-C's kernel. It provides functions for equality checks, comparison, hashing, pretty-printing, deep copying, and project membership testing, ensuring proper manipulation of values with no shared state. The module is used to manage internal representations of floating-point data under the `-warn-special-float` option, supporting analysis and transformation tasks within Frama-C plugins.",
      "description_length": 514,
      "index": 2784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter.Int",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage integer parameters by name, including getting, setting, incrementing, and checking the state of parameters. It works with string identifiers and integer values, supporting dynamic access and modification of plugin parameters. Concrete use cases include retrieving and updating integer configuration values during plugin execution, such as loop iteration limits or threshold settings.",
      "description_length": 425,
      "index": 2785,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables mapping logic-aware keys to arbitrary values, supporting insertion, lookup, iteration, and deterministic traversal ordered by keys, entries, or values. It enables memoization, structured type composition, and safe value extraction, with child modules specializing hash tables for specific data and defining logic-aware keys with equality, comparison, and pretty-printing. The combined functionality facilitates managing CIL logic constructs in Frama-C plugins, such as tracking project-specific data, analyzing logic functions, and performing deterministic transformations based on key-value associations. Example uses include storing and retrieving typed logic information efficiently and implementing analysis passes over C code with consistent key-based processing.",
      "description_length": 801,
      "index": 2786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations with immutable semantics, supporting element manipulation (insertion, removal, union), ordered traversal (iteration, folding, sequence conversion), and proximity queries (nearest elements, range checks). It operates on a parametric set type `t` with ordered elements of type `elt`, maintaining strict ordering during transformations and enabling custom comparison logic through type definitions. Typical applications include static analysis tasks requiring ordered collections, such as tracking program state dependencies, managing sorted value ranges, or implementing domain-specific set abstractions with introspection capabilities.",
      "description_length": 680,
      "index": 2787,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This structure provides hash table operations for mappings with CIL variable identifiers as keys, supporting imperative updates and functional transformations. It enables ordered traversal, comparison-based sorting, safe key lookups, memoization, and sequence synchronization, with keys defined via CIL variable information including equality, comparison, and hashing operations. A specialized hash table for values conforming to a given `Data` module signature supports efficient storage and retrieval keyed by `Varinfo` instances. These capabilities facilitate precise variable tracking and ordered processing of CIL constructs, such as managing variable-specific analyses or annotations across different passes in Frama-C plugins.",
      "description_length": 733,
      "index": 2788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associative maps keyed by logic type information, enabling efficient insertion, deletion, ordered traversal, and value transformations over arbitrary data types. It supports structured metadata operations in CIL analysis through ordered key queries, bulk transformations, and conversions to and from lists and sequences. Submodules specialize the map for logic type identifiers with project-aware operations and define key types with equality, comparison, and pretty-printing for use in static analysis plugins. Example uses include tracking logic type metadata across translation units and aggregating analysis results under ordered keys.",
      "description_length": 667,
      "index": 2789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables where keys are sets of kernel functions and values are arbitrary data, supporting insertion, lookup, iteration, and in-place modification. It allows ordered traversal with custom comparisons and conversion to sequences, enabling efficient tracking of relationships between function sets and associated data such as analysis results. A child module defines key operations for kernel function-based keys, ensuring correct equality, hashing, and printing behavior across project variants. Another child module specializes the hash table for values of type `Data.t`, offering deep copying and project membership checks, ideal for caching per-function analysis results in plugins.",
      "description_length": 719,
      "index": 2790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.False_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean state reference initialized to false, with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function and checks for project membership via a predicate. Use cases include tracking analysis states that default to false, such as flags for analysis phases or condition checks in static analysis plugins.",
      "description_length": 371,
      "index": 2791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This structure provides imperative hash tables for mapping strict constant keys to arbitrary values, supporting efficient insertion, lookup, and in-place modification under strict equality semantics. It enables ordered traversal and folding over entries sorted by keys, values, or custom criteria, along with sequence-based bulk updates and performance introspection, making it suitable for memoization and static analysis tasks. A key module defines a key type for strict CIL constants with deep copying and project membership checks, while a child hash table module specializes the store to CIL constants with textual fidelity, enabling precise constant tracking and comparison in C code analysis. Examples include managing constant propagation, analyzing CIL expressions, and implementing compiler optimizations based on strict key equivalence.",
      "description_length": 847,
      "index": 2792,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space.Vector",
      "library": "frama-c.kernel",
      "description": "This module implements fixed-size vectors over a field, supporting operations such as creating zero or constant vectors, accessing and modifying individual elements, computing the infinity norm, and taking the element-wise maximum between two vectors. It works with vectors indexed by finite types and uses a scalar type defined by the enclosing linear space. Concrete use cases include representing and manipulating points or directions in finite-dimensional vector spaces, particularly in static analysis algorithms that require precise linear algebra operations.",
      "description_length": 565,
      "index": 2793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyCfg.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for handling and manipulating abstract values in the context of the `-simplify-cfg` option. It supports deep copying, membership testing within projects, and provides representants along with type and descriptor information. It is used to manage and reason about control flow graph simplification data within Frama-C's kernel.",
      "description_length": 456,
      "index": 2794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an efficient, immutable set structure for hashconsed elements, supporting standard operations like union, intersection, difference, and membership checks, along with ordered traversal, mapping, and filtering. It operates on sets of hashconsed values with a total ordering, enabling optimized queries for extremal elements, cardinality, and sequence conversions while ensuring functional purity and safe error handling. It is particularly suited for static analysis tasks requiring precise set manipulations, such as modeling program states or analyzing hierarchical data structures.",
      "description_length": 605,
      "index": 2795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table for mappings from CIL terms to arbitrary values, supporting imperative operations like insertion, lookup, and iteration, along with advanced features such as ordered traversal, in-place filtering, and memoization. Its key module handles equality, comparison, and hashing for CIL terms, including support for `Project.t` values to ensure structural integrity and avoid shared references during analysis. The value module provides standard operations for data stored in the table, enabling deep copies and project-aware membership checks. Together, they facilitate efficient management of term-based data in static analysis plugins, such as caching results or aggregating metadata across program inspections.",
      "description_length": 742,
      "index": 2796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.As_string",
      "library": "frama-c.kernel",
      "description": "This module configures string-valued options with validation, aliases, and dynamic updates, while supporting serialization and state management. It provides operations to restrict values to predefined sets, validate against function names, and filter inputs through hooks, working with strings and string lists. A child module handles string-based function representations, offering equality checks, comparison, hashing, and pretty printing for structured descriptors. Examples include enforcing valid plugin parameters, managing user-defined function references, and maintaining consistent string state across analysis sessions.",
      "description_length": 629,
      "index": 2797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl.Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type for a hash table that stores rational number\u2013based values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data structures containing rational numbers and project skeletons, enabling deep copying and membership checks over project data. Concrete use cases include managing and querying collections of rational-valued keys in static analysis plugins.",
      "description_length": 433,
      "index": 2798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages hash tables mapping bit-level memory locations to arbitrary values, supporting insertion, lookup, iteration, and in-place modification with custom comparison and safe retrieval. Its keys represent memory locations as base-offset pairs, enabling precise tracking of fine-grained memory regions with operations for equality, hashing, and pretty-printing. It includes a specialized sub-module for handling values of type `Data.t`, allowing comparison, hashing, and inspection of memory state snapshots. Examples include tracking pointer states, optimizing memory access during static analysis, and generating unique memory layout representations.",
      "description_length": 663,
      "index": 2799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_not_weak.Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a hashconsing table with strong references, ensuring stable and reproducible hashconsing behavior across garbage collection cycles. It provides operations for equality checking, comparison, hashing, and deep copying of hashconsed values, along with utilities for project membership testing and pretty printing. It is suitable for use cases requiring consistent identity and structural comparison of values, such as symbolic representations in static analysis.",
      "description_length": 482,
      "index": 2800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for emitting annotations and property statuses in Frama-C. It provides operations for comparing, hashing, and pretty-printing map values, along with deep copying and membership checks based on project skeletons. It works with values of type `Data.t` and is used when managing and querying analysis results tied to specific projects.",
      "description_length": 388,
      "index": 2801,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind.Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to the `option` type, providing `iter` for performing side-effecting operations on `Some` values and `map` for transforming `option` values within a monadic context. It works directly with the `option` type and monadic actions, enabling chaining operations that handle optional results with effects. Use it to safely process optional data while composing monadic logic, such as error handling or stateful computations.",
      "description_length": 456,
      "index": 2802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.String",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters with support for validation, default values, and state persistence across projects. It provides core operations for defining and manipulating string options, including equality checks, comparison, and pretty printing, while allowing metadata such as allowed values and change hooks to be attached. Submodules enhance this functionality by enabling deep copying, project-aware membership checks, and structured option creation. Example uses include configuring plugin settings with validated input, such as file paths or user-defined labels, that persist and adapt across sessions.",
      "description_length": 637,
      "index": 2803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps, including operations for equality, comparison, hashing, and pretty printing. It works with the abstract `t` type representing map keys, along with projects and formatters. It is used to manage and manipulate keys in map structures, supporting deep copies, membership checks over projects, and standard key operations.",
      "description_length": 358,
      "index": 2804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32.Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered maps with 32-bit integer keys, supporting key-value association, transformation, and traversal while preserving key order. It provides core operations like `find_first`, `min_binding`, `merge`, and `union`, along with functional utilities such as `filter_map` and `split` for complex manipulations. The module enables efficient sequence conversion, reverse iteration, and structured output formatting, making it suitable for analysis tools requiring immutable, ordered key-value storage. Submodules handle key-specific operations including comparison, hashing, and type-safe value mapping, enabling integration with Frama-C's analysis pipelines and plugin data structures.",
      "description_length": 703,
      "index": 2805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table specialized for values of a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports concrete data types through a functorial interface, enabling structured storage and retrieval of values with efficient lookups and integrity checks. Use cases include managing alarm data with unique keys, tracking project-specific values, and ensuring consistent serialization and comparison of stored elements.",
      "description_length": 488,
      "index": 2806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Action",
      "library": "frama-c.kernel",
      "description": "This module manages boolean command-line parameters with operations to toggle state via `on`/`off` actions, track changes, and serialize values. It integrates with the `Project` module to support project-specific configurations, using boolean state types (`t`) and `Typed_parameter.t` structures. A structured data type with equality, comparison, and pretty-printing support enables handling complex configuration values, such as parsing and storing custom-typed CLI options with precise semantics. Example uses include defining dynamic CLI flags that toggle features or persist settings across sessions.",
      "description_length": 604,
      "index": 2807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map.Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in maps, specifically tailored for integer value abstractions. It provides operations for equality, comparison, hashing, and pretty-printing keys, along with deep copying and checking for the presence of specific project values. Use cases include managing and manipulating map keys in static analysis contexts where integer abstractions are required.",
      "description_length": 396,
      "index": 2808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are integer intervals with congruence and values are of a specified data type. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checking. It is used to manage and query collections of values associated with numeric ranges, such as tracking variable bounds in static analysis.",
      "description_length": 412,
      "index": 2809,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type.Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive suite of set operations for logic type elements, including creation, union, intersection, filtering, and ordered traversal (e.g., `find_first`, `find_last`), alongside utilities for conversion to lists, nearest element selection, and set-theoretic comparisons. It works with immutable sets of logic types, ensuring efficient membership checks, ordered element access, and support for hashing, equality, and structured iteration. These capabilities are particularly valuable in static analysis plugins for tasks like verifying logical expressions, analyzing CIL constructs with set semantics, or performing precise code transformations requiring rigorous set-based reasoning.",
      "description_length": 709,
      "index": 2810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register.State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific state directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing plugins to store and access persistent data. Concrete use cases include saving plugin-generated files or caching analysis results in a dedicated directory.",
      "description_length": 363,
      "index": 2811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.MainFunction.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for representing and manipulating the entry point of a C program analyzed by Frama-C. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, along with introspection via project membership testing. Typical use cases include tracking and validating the main function during static analysis and plugin development.",
      "description_length": 400,
      "index": 2812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module creates hash tables indexed by integer sets, where values are of a specified data type. It supports standard hash table operations like lookup, insertion, and iteration, tailored for use with integer sets constrained by the set_small_cardinal limit. Concrete use cases include managing mappings from integer ranges to values in static analysis plugins, such as tracking variable bindings or abstract states.",
      "description_length": 419,
      "index": 2813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Map.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map data structure specialized for values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It provides typed access to map instances, along with deep copy, membership checks over projections, and type-level metadata such as name, type descriptor, and structural representation. Concrete use cases include managing property-based analyses where maps track value states across program points or storing and querying structured analysis results keyed by property identifiers.",
      "description_length": 559,
      "index": 2814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table specialized for storing values of a given data type, providing standard operations like equality, comparison, hashing, and pretty printing. It supports data types that conform to the structural requirements outlined in the Frama-C plugin development guide, enabling deep copying and project-aware membership checks. Concrete use cases include managing property-specific data in static analysis plugins, such as tracking function specifications or variable annotations across different analysis phases.",
      "description_length": 537,
      "index": 2815,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation optimized for structural equality and strict constant comparison, particularly suited for static analysis tasks requiring precise type and value equivalence. It supports key operations like insertion, lookup, and removal, along with advanced features such as bulk updates, in-place transformations, and ordered iteration, primarily using the `OffsetStructEqStrict.t` key type for exact equality checks. Child modules extend this functionality by offering hash tables over values with structural equality and strict constant comparison, along with dedicated key types that support equality, comparison, hashing, pretty printing, and deep copying. Examples include tracking and comparing values across analysis contexts, memoizing structural comparisons, and performing project-aware membership queries in Frama-C plugins.",
      "description_length": 869,
      "index": 2816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.V",
      "library": "frama-c.kernel",
      "description": "This module represents vertices in a control flow graph, providing operations to create, label, and compare vertices. It works with comparable vertex types labeled with arbitrary data, supporting graph construction and manipulation. Concrete use cases include building and analyzing control flow graphs for program verification and abstract interpretation.",
      "description_length": 356,
      "index": 2817,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes polymorphic map operations with total ordering on keys, enabling safe functional updates, ordered traversal, and transformations through folds, filters, and bindings. It supports core operations like insertion, deletion, and lookup while preserving key order, and integrates with child modules that define concrete key-value representations and utilities for structured data management. The first child module specializes in typed value handling with equality, comparison, and pretty-printing for structured analysis tasks, while the second focuses on key-specific operations including efficient lookups and serialization. Together, they support use cases such as state tracking with immutable updates, typed collection transformations, and integration with analysis plugins requiring ordered key-value representations.",
      "description_length": 841,
      "index": 2818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Zero_ref.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a state builder for a reference to an integer initialized to zero. It provides operations for equality, comparison, hashing, and pretty-printing values of type `t`, along with deep copying and membership testing within projects. It is used to manage and manipulate zero-initialized integer references in Frama-C's state system.",
      "description_length": 347,
      "index": 2819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int.Map",
      "library": "frama-c.kernel",
      "description": "This module manages integer-keyed associative structures with ordered key handling, supporting insertion, deletion, traversal, and transformation of key-value pairs. It provides core operations for building and manipulating maps, along with submodules that define structured key representations and typed value mappings. You can use it to maintain ordered collections of values indexed by integers, perform efficient lookups, and integrate with project-specific data through structured keys and typed values. Examples include tracking analysis results per program point or managing persistent, ordered mappings with custom data attached to keys.",
      "description_length": 645,
      "index": 2820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedOverflow.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for handling signed overflow behavior in Frama-C's kernel. It includes functions for equality, comparison, hashing, and pretty-printing values of type `t`, along with utilities for deep copying and checking project membership. The module supports analysis and manipulation of signed integer overflow states during static analysis, particularly in relation to the `-warn-signed-overflow` option.",
      "description_length": 456,
      "index": 2821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module implements forward dataflow analysis on control flow graphs, computing dataflow values for each node using a given direction and worklist algorithm. It operates on graphs built from the `t` type and processes nodes in reverse postorder within each strongly connected component. The analysis uses a user-defined domain `D` to compute and propagate values across the graph.",
      "description_length": 383,
      "index": 2822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make.Service_graph",
      "library": "frama-c.kernel",
      "description": "The module manages mutable directed graphs with vertices and edges, supporting dynamic structural changes and efficient traversal. It provides core operations for adding and removing vertices and edges, checking adjacency, and querying graph structure, while its nested modules define labeled vertices with equality and hashing capabilities, rich node data types with membership checks, and directed edges with source-destination relationships and labels. This enables concrete use cases like modeling function call dependencies, analyzing control flow, and transforming service graphs dynamically. Together, the module and its submodules form a cohesive system for building, modifying, and analyzing complex graph-based representations.",
      "description_length": 737,
      "index": 2823,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered set data structure for elements with strict structural equality, supporting insertion, deletion, set algebra (union, intersection, difference), and ordered traversal with extremal element access. It works with elements of type `OffsetStructEqStrict.t`, which enforce strict comparison of constants, and provides operations for efficient membership checks, transformations, and nearest-element queries. The structure is used in static analysis to manage sets of struct offsets or constants where precise equality and ordered enumeration are required, such as tracking memory layouts or validating data flow constraints.",
      "description_length": 652,
      "index": 2824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for creating, modifying, and querying immutable sets of `Unit.t` elements, supporting standard set algebra (union, intersection, difference), ordered traversal, and predicate-based filtering or mapping. It includes utilities for converting sets to and from lists/sequences, finding extreme or nearest elements relative to a value, and introspection via comparison, hashing, and pretty-printing. Designed for static analysis tasks, it ensures efficient set manipulation with strong guarantees of immutability and ordered element processing, particularly useful for tracking unique program states or variables with safe error handling through optional return types.",
      "description_length": 695,
      "index": 2825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for chaining computations in a monad built using `Make_based_on_map`. It provides infix operators `>>-`, `let*`, `>>-:`, and `let+` to sequence actions and map functions over monadic values. These operations are essential for writing concise, compositional code when working with custom monads that implement the required `map` and `bind` primitives.",
      "description_length": 388,
      "index": 2826,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered sets for managing ACSL properties with a custom ordering based on function attributes (e.g., function name, instruction, property kind). It supports efficient set operations like union, intersection, and difference, along with ordered traversal, nearest-element queries, and project-specific utilities for static analysis plugins. The structure is optimized for scenarios requiring strict property ordering, such as dependency resolution or ordered property propagation in program analysis.",
      "description_length": 521,
      "index": 2827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with structural equality keys for CIL predicates, supporting efficient creation, insertion, lookup, and deletion with arbitrary value types. It enables ordered traversal and folding using custom comparators, while integrating deep copying and project membership checks for precise static analysis tasks. The key module defines structured key types with project-specific data, providing equality, hashing, and pretty-printing operations tailored for CIL predicates. The table module builds on these keys to offer a full hash table implementation with equality, comparison, and structured value management, facilitating efficient, structured data processing in Frama-C analyses.",
      "description_length": 711,
      "index": 2828,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf.Set",
      "library": "frama-c.kernel",
      "description": "This module offers ordered set operations for managing collections of CIL elements (specifically `Kf.t` values), supporting functional transformations like union, intersection, filtering, and order-preserving iteration. It provides utilities for element selection, sequence conversion, and introspection (e.g., hashing, pretty-printing), with a focus on leveraging element ordering for efficient querying and analysis. These sets are particularly useful in static analysis workflows requiring precise tracking and manipulation of function or variable sets during C code verification.",
      "description_length": 583,
      "index": 2829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepSwitch.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and associated operations for managing values related to the `-keep-switch` option in Frama-C. It supports equality checks, comparison, hashing, and pretty-printing for values of this type, along with deep copying and membership testing within projects. It is used to represent and manipulate switch-keeping behavior during analysis, specifically tracking and comparing project-specific values.",
      "description_length": 426,
      "index": 2830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_pair.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic pair datatype combining two distinct types, supporting operations like equality, comparison, hashing, and pretty-printing. It works with any two modules providing their own datatypes, enabling structured composition of values with deep copying and project membership checks. Concrete use cases include modeling compound analysis states or paired program properties in static analysis plugins.",
      "description_length": 426,
      "index": 2831,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom.Option",
      "library": "frama-c.kernel",
      "description": "This module provides `iter` and `map` functions that operate on `option` values within a lattice context where bottom values are explicitly handled. It allows iterating over or transforming optional values while preserving lattice semantics for bottom. Use cases include safely processing optional data in static analysis where absence must be distinguished from valid bottom elements.",
      "description_length": 385,
      "index": 2832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make.Empty_string",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for handling empty strings with validation, serialization, and dynamic state updates through value change hooks. It defines the `t` type for empty string values and supports operations like equality, comparison, hashing, and pretty-printing, along with infrastructure for project membership and deep copying. It enables defining command-line flags that accept empty string arguments, enforcing constraints such as allowed values or function-name acceptability, and integrates with configuration systems for use in Frama-C plugins and extensible analysis tools.",
      "description_length": 604,
      "index": 2833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset.Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered set operations for manipulating collections of kernel functions, supporting efficient union, intersection, difference, and element-wise transformations. It works with HPT sets (`Hptset.Set.t`), which maintain total ordering, and provides utilities for ordered traversal, predicate-based searches (e.g., `find_first`, `find_last`), and conversions to sequences or lists. Use cases include abstract interpretation tasks requiring precise set manipulation, data flow analysis, and integration with Frama-C's kernel APIs that rely on ordered collections for static analysis workflows.",
      "description_length": 611,
      "index": 2834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized.Map",
      "library": "frama-c.kernel",
      "description": "This module manages finite maps with structural equality for keys based on CIL expressions, enabling precise expression comparison in static analysis by evaluating structure rather than identifiers, particularly within `sizeof` contexts. It supports core operations like insertion, deletion, lookup, and ordered traversal, along with transformation and aggregation of key-value pairs, where keys are compared structurally and values can be arbitrary types. The key module provides equality, comparison, hashing, and pretty printing for CIL expressions, while the map implementation builds on it to offer typed maps with full access to key-based operations and value parameterization. Example uses include tracking equivalent expressions in C code analysis or managing expression-based state where structural identity ensures accurate equivalence checks.",
      "description_length": 853,
      "index": 2835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval.Map",
      "library": "frama-c.kernel",
      "description": "This module provides a persistent, ordered map implementation for key-value associations where keys are CIL lvalues (`Lval.t`), supporting structural and physical equality, ordered traversal, and operations like insertion, deletion, merging, filtering, and transformation. It includes submodules that refine key behavior, one using eid-based equality for project-aware membership checks, and another defining a key type with structural consistency for precise tracking of memory locations across analysis contexts. The API enables tasks like tracking memory states or expression evaluations, with utilities for reverse iteration, customizable printing, and deep copying. Example uses include managing per-lvalue state in program analysis or associating metadata with CIL expressions in transformation passes.",
      "description_length": 808,
      "index": 2836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set.Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating sets of kernel functions. It provides operations to define, retrieve, and modify categories such as '@none', '@default', and '@all', along with their behaviors and dependencies. Use cases include configuring function sets based on named categories and controlling function activation through state lists and accessors.",
      "description_length": 381,
      "index": 2837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter.Set",
      "library": "frama-c.kernel",
      "description": "This set abstraction manages collections of `Usable_emitter.t` values, offering standard set operations like union, intersection, and difference alongside ordered processing through predicates, iteration, and mapping. It supports conversions between sets and sequences, nearest-element queries, and utilities for equality checks, hashing, and structured output formatting. Key use cases include aggregating and filtering emitter outputs, ordered traversal for annotation analysis, and efficient retrieval of emitters based on positional or property-driven criteria.",
      "description_length": 565,
      "index": 2838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module organizes memory state tracking through hash tables that map base-offset memory locations to arbitrary values, supporting ordered iteration, safe lookups with defaults, and bulk updates from sequences. It defines key operations for comparing, hashing, and printing memory locations, enabling precise analysis of adjacent regions and efficient grouping. Child modules refine these capabilities by providing key-specific logic and full hash table implementations with deep copying, project-aware checks, and byte-level precision. Examples include tracking memory writes across function calls, optimizing pointer arithmetic, and analyzing dynamic memory usage patterns in static analysis plugins.",
      "description_length": 705,
      "index": 2839,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq.Map",
      "library": "frama-c.kernel",
      "description": "This module manages finite maps with keys based on CIL predicates under structural equality, enabling efficient physical equality checks and deterministic iteration. It supports standard operations like insertion, deletion, union, filtering, and ordered traversal, with key comparisons and hashing handled through the `PredicateStructEq` type. Child modules define key-specific operations and typed value mappings, allowing structured data to be stored, transformed, and queried in CIL-based static analyses. For example, it can aggregate analysis results keyed by CIL constructs, filter maps based on predicate properties, or traverse keys in a deterministic order for consistent output.",
      "description_length": 688,
      "index": 2840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Constfold.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating values used in constant folding during Frama-C's analysis. It includes functions for equality, comparison, hashing, pretty-printing, and deep copying, as well as support for checking membership based on project projections. The module is used to handle the internal representation of constant-folded expressions and their properties in a structured and efficient manner.",
      "description_length": 466,
      "index": 2841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Varinfo.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for representing and comparing variable information in the context of AST differencing. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, which encapsulate variable metadata such as name and type. These operations support tracking variable correspondences across different versions of a project, enabling precise diff computation and analysis.",
      "description_length": 437,
      "index": 2842,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Base.Set",
      "library": "frama-c.kernel",
      "description": "This module offers set operations (union, intersection, difference, element manipulation) and ordered traversal capabilities (sorted iteration, filtering, nearest-element queries) for collections of memory base identifiers, which represent addressable memory zones. It works with sets of `Frama_c_kernel.Base.Base.t` elements, maintaining strict ordering to model memory validity relationships and support static analysis tasks like tracking dynamic memory regions or verifying pointer safety in program analysis workflows.",
      "description_length": 523,
      "index": 2843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model.Make_Narrow",
      "library": "frama-c.kernel",
      "description": "This module implements a narrowing operation that combines two memory models into a more precise approximation, typically used during abstract interpretation to refine value analyses. It operates on `Frama_c_kernel.Cvalue.Model.t`, which represents abstract memory mappings from bases to memory slices. Concrete use cases include improving the precision of value analysis results by iteratively narrowing memory states at loop fixpoints or conditional branches.",
      "description_length": 461,
      "index": 2844,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing string-valued command-line options, including value constraints, validation hooks, and serialization controls. It operates on string data and parameter configurations that enforce allowed values or validate function names. These capabilities are used for command line option parsing, state synchronization, and ensuring input validity in tool extensions.",
      "description_length": 412,
      "index": 2845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Set_ref-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements stateful set operations with support for equality, comparison, hashing, and pretty printing. Works with structured data types that include project skeletons and type descriptors. Useful for managing and manipulating abstract states in static analysis plugins, such as tracking sets of values across program points.",
      "description_length": 325,
      "index": 2846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for representing kernel functions as strings, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type, which encapsulates string-based representations of kernel functions, and integrates with Frama-C's project system through `mem_project` to filter values based on project membership. Concrete use cases include storing and manipulating function identifiers in analyses, and exporting function data in a consistent, serializable format.",
      "description_length": 552,
      "index": 2847,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype based on a provided value datatype, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with key-value pairs where the value type is defined by the `Data` module. Concrete use cases include managing typed mappings in static analysis plugins, such as tracking variable states or function summaries across different analysis phases.",
      "description_length": 410,
      "index": 2848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Info",
      "library": "frama-c.kernel",
      "description": "This module provides values for naming internal states and specifying their dependencies. It works with lists of state objects and string identifiers. Concrete use cases include registering new state builders with explicit dependency tracking and organizing modular state management in static analysis plugins.",
      "description_length": 310,
      "index": 2849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair",
      "library": "frama-c.kernel",
      "description": "This module implements a pair datatype with strict, value-level operations for equality, comparison, hashing, and pretty-printing. It directly supports structured data analysis by providing deep copy and project membership checks for static analysis plugins. Concrete use cases include representing and analyzing pairs of program values such as expressions with associated states or combined abstract domains.",
      "description_length": 409,
      "index": 2850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Float",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage floating-point parameters with configurable ranges, supporting value retrieval, modification, and change monitoring, along with CLI visibility and serialization. It operates on `float` values using state management mechanisms like hooks and persistence tracking, enabling use cases such as defining bounded numerical thresholds for plugin configurations in static analysis tools.",
      "description_length": 421,
      "index": 2851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Vars",
      "library": "frama-c.kernel",
      "description": "This module manages global variables in the AST, providing precise access to variable information (`varinfo`) and initialization data (`initinfo`). It supports direct lookups by name and scope, ordered iteration over globals, and controlled modifications to variable registrations. Use cases include analyzing variable definitions in C source code, tracking initialization patterns, or implementing custom checks during static analysis.",
      "description_length": 436,
      "index": 2852,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for manipulating CIL terms, including equality, comparison, hashing, and pretty-printing, with support for deep copying, project membership checks, and structured term analysis. It includes submodules for map-like structures with ordered traversal and functional updates, set-theoretic operations over term collections, and a hash table implementation for efficient term-to-value mappings with project-aware semantics. These components enable tasks such as tracking variable properties across a project, transforming term-value pairs during analysis, and caching results using term-based keys. Specific uses include static analysis pipelines that require precise term manipulation, semantic analysis over CIL code, and structured storage with type-aware transformations.",
      "description_length": 807,
      "index": 2853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Qstack.DATA",
      "library": "frama-c.kernel",
      "description": "This module defines the data structure and operations for managing a mutable stack with queue-like behavior, implemented as a double-linked list. It supports adding elements to the end and accessing or modifying elements that are not at the top. Concrete use cases include tracking and manipulating sequences of program states or analysis data where arbitrary element access is required.",
      "description_length": 387,
      "index": 2854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports managing string-based command-line parameters with advanced lifecycle control, including value validation, alias resolution, and change notification hooks. It operates on string data (`type t = string`) while enforcing constraints for function name validation and project state integration. Typical use cases include parsing CLI arguments with dynamic validation, tracking configuration changes in interactive tools, and bridging string inputs with structured program behavior through customizable serialization.",
      "description_length": 533,
      "index": 2855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Iter_hook",
      "library": "frama-c.kernel",
      "description": "This module implements an extensible hook system for registering and applying functions that take a parameter of type `param` and return `unit`. It allows adding new functions, applying them in registration order, checking the hook's state, and managing duplicates. It is used to trigger side-effecting actions at specific program points, such as during analysis or transformation phases in static analysis tools.",
      "description_length": 413,
      "index": 2856,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_map-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a map structure keyed by file paths, providing operations to associate, retrieve, and manipulate values based on file path keys. It supports efficient lookups, insertion, and traversal, tailored for managing per-file data in static analysis contexts. This module is used to track file-specific information such as analysis results or configuration settings across different source files.",
      "description_length": 398,
      "index": 2857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_collections",
      "library": "frama-c.kernel",
      "description": "This module extends a datatype with set, map, and hash table functionality, enabling efficient collection management and lookups based on equality, comparison, and hashing operations. It provides core data structures for ordered maps, immutable sets, and hash tables with typed keys, supporting operations like insertion, lookup, union, iteration, and folding, along with conversions to and from lists and sequences. Example uses include static analysis databases, symbolic computation engines, and dataflow pipelines that require ordered traversal, memoization, or efficient membership checks. Child modules refine key handling, type-specific instantiations, and structured key-value associations for applications such as program state tracking, function annotation management, and ordered caching in analysis tools.",
      "description_length": 817,
      "index": 2858,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Set",
      "library": "frama-c.kernel",
      "description": "This module provides functions to update the representative of various AST elements within a visitor behavior, such as variables, structures, enums, statements, and logic entities. Each function takes a visitor, an original element, and a new representative, and modifies the visitor's internal state to use the new representative for that element. It is used during AST transformations to maintain correct references while ensuring that changes propagate consistently across the visited nodes.",
      "description_length": 494,
      "index": 2859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Local",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing a mutable local state that is project-compliant, including creating, clearing, retrieving, and setting the state, as well as selectively clearing parts of the state based on project criteria. It works with a single abstract data type `t` representing the state and uses `Frama_c_kernel.Project_skeleton.t` for project-based filtering. Concrete use cases include initializing analysis states, resetting state values during analysis phases, and pruning state data tied to specific projects.",
      "description_length": 532,
      "index": 2860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AbsoluteValidRange",
      "library": "frama-c.kernel",
      "description": "This module manages the `-absolute-valid-range` command-line option, enabling configuration and validation of string-based address ranges that constrain pointer validity during analysis. It provides operations to set, retrieve, and validate these ranges dynamically, supporting use cases such as restricting memory regions for pointer analysis or ensuring safe function pointer resolution. The core data type `t` represents these ranges with support for equality, comparison, and pretty-printing, while also enabling membership testing and deep copying within a project context. Submodules enhance this functionality with structured representations and type descriptors, facilitating efficient manipulation and project-specific validation of absolute valid ranges.",
      "description_length": 764,
      "index": 2861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between integer abstractions and arbitrary data, enabling ordered traversal, transformation, and precise manipulation of polymorphic maps with lattice-aware key handling. It supports operations like equality checking, comparison, hashing, and pretty-printing, along with deep copying and membership queries using project-based constraints. Submodules provide specialized key handling and map structures, allowing efficient tracking of data tied to abstract integer ranges, such as program values or constraints in static analysis. Example uses include merging or splitting map entries based on semantic ranges, iterating in reverse order, and converting between sequence-based and lattice-based integer key sets.",
      "description_length": 745,
      "index": 2862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between kernel functions and lists of values, enabling operations to set, query, and monitor changes to these associations with support for project-specific state tracking and command-line option integration. It works with map-like structures that use kernel functions as keys and lists of typed values (`V.t`), incorporating features like custom marshaling, alias handling, and deprecation warnings. It is particularly useful for scenarios requiring parameter customization, such as associating multiple configuration values with functions or tracking dynamic updates in a project-aware context.",
      "description_length": 625,
      "index": 2863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Char",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with characters, including equality, comparison, hashing, and pretty-printing, enabling precise representation and symbolic evaluation of character values in static analysis. It supports efficient collection management through submodules for ordered sets, maps, and hash tables keyed by characters, each offering structured operations like set algebra, ordered traversal, and type-safe value storage. These components facilitate tasks such as tracking character ranges, managing symbol tables, and analyzing program states indexed by characters, with integration for deep copying, project-aware metadata, and custom formatting. Specific uses include constraint validation, state management in plugins, and typed, character-indexed collections for analysis systems.",
      "description_length": 813,
      "index": 2864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line parameters for string lists with a structured representation. It provides operations to compare, hash, and pretty-print string list values, along with deep copying and project membership checks. It is used to define and manipulate configuration options that accept multiple string values in Frama-C extensions.",
      "description_length": 346,
      "index": 2865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Based_on_bind",
      "library": "frama-c.kernel",
      "description": "This module defines a monadic structure through `return` and `bind` operations, enabling sequencing of computations that produce values wrapped in a monadic type `'a t`. It works with any type `'a t` that represents a computation or effectful result, allowing functions to chain operations where each step depends on the result of the previous. Concrete use cases include managing state transitions, handling optional or error-prone computations, and structuring parsers or event-driven logic.",
      "description_length": 493,
      "index": 2866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Toplevel_predicate",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with top-level CIL predicates, including equality, comparison, hashing, and pretty-printing. It supports data types related to CIL's `toplevel_predicate`, enabling precise manipulation and analysis of predicate expressions in static analysis plugins. Use cases include checking predicate equivalence, traversing predicate structures for project-specific properties, and generating human-readable representations for debugging or reporting.",
      "description_length": 482,
      "index": 2867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map structure for values of type `As_string.Datatype.t`, supporting key-based insertion, lookup, and traversal operations. It provides efficient equality, comparison, and hashing functions tailored for string-based data representations. Concrete use cases include managing analysis results keyed by string identifiers and persisting structured data across different analysis phases.",
      "description_length": 419,
      "index": 2868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.With_Diff",
      "library": "frama-c.kernel",
      "description": "This module computes the difference between two lattice elements, where the second element must be an under-approximation or exact. It returns an over-approximation of the result, using a type that explicitly handles the absence of a bottom element. This supports precise static analysis operations in value analysis, such as refining abstract values during fixpoint computations.",
      "description_length": 380,
      "index": 2869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Top",
      "library": "frama-c.kernel",
      "description": "This module manages values in a bounded lattice that can represent concrete elements, top, or bottom, offering monadic operations like `bind` and `map` alongside lattice-specific combinators such as `join` and `is_included`. It supports computations over lattice elements extended with a maximal top value, enabling precise static analysis through operations that merge, compare, and transform abstract values. Submodules extend this with lattice-aware list and option manipulations, product constructors, and conditional top propagation, allowing tasks like control-flow analysis and abstract value merging. Examples include composing abstract interpreters, analyzing sequences of lattice elements, and selectively propagating top based on runtime conditions.",
      "description_length": 760,
      "index": 2870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attributes",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for manipulating CIL attributes, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying, project-based membership checks, and managing collections. It supports set algebra, ordered traversal, and functional transformations through its set and map submodules, enabling precise analysis of C code annotations and metadata. The hash table submodule offers efficient key-value storage with custom comparisons, ideal for tracking attribute states and annotating AST nodes during static analysis. Together, these components facilitate robust handling of CIL attributes in Frama-C plugins and analysis workflows.",
      "description_length": 687,
      "index": 2871,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Debug-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a specific debug datatype, including equality, comparison, hashing, and pretty-printing functions. It works with values of type `Debug.Datatype.t`, supporting deep copies, membership checks over project skeletons, and structured representations. Concrete use cases include managing and inspecting debug data within Frama-C plugins, such as tracking and comparing analysis states or debugging information across different project versions.",
      "description_length": 473,
      "index": 2872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides weak hashtables for managing state data with project-aware keys, supporting operations to add, find, remove, and iterate entries. It integrates with the `Datatype` module to handle custom key types with defined equality, hashing, and marshaling, enabling use cases like caching analysis results scoped to specific projects. The child module extends this functionality with support for project-specific comparisons, deep copying, and filtering, ensuring keys are correctly scoped and isolated across project contexts. Together, they enable efficient, context-sensitive state tracking and transformation during static analysis.",
      "description_length": 646,
      "index": 2873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific key-value store with string keys and values as lists of logic-related objects, enabling creation, querying, and transformation over a thread-unsafe global hashtable. It supports event-driven updates and data aggregation, making it suitable for state management in static analysis tools, with built-in hooks for observing changes and custom serialization. The core data type `t` represents logic datatypes with support for equality, comparison, hashing, and pretty-printing, allowing deep copies and project membership checks. It is used extensively in Frama-C's kernel for type checking and plugin-specific logic processing, where descriptors, names, and representative values drive analysis passes and data tracking.",
      "description_length": 756,
      "index": 2874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Vertex",
      "library": "frama-c.kernel",
      "description": "This module defines a vertex type for control points in an automaton's control flow graph, with operations for equality, comparison, hashing, and pretty-printing, along with utilities for inspecting project membership and deep copying. Its associated Set and Map modules enable efficient set-theoretic operations and associative storage keyed by vertices, supporting tasks like reachability analysis and state tracking. The accompanying Hashtbl module allows for efficient, deterministic lookups and bulk updates of vertex-associated data, with specialized variants for metadata storage and key operations. Together, these components facilitate abstract interpretation tasks such as constraint propagation, guarded transition analysis, and memoization of per-vertex results.",
      "description_length": 774,
      "index": 2875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Plugins",
      "library": "frama-c.kernel",
      "description": "This module handles plugin loading and configuration path management, enabling dynamic extension of application functionality. It supports operations to retrieve plugin directories, list available plugins, and load either all plugins or a specific named plugin. Uses string lists to represent plugin paths, and is typically used during initialization to set up plugin-based interfaces. Example usage includes loading a specific plugin by name at runtime or initializing all configured plugins during application start.",
      "description_length": 518,
      "index": 2876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bytes",
      "library": "frama-c.kernel",
      "description": "This module combines lattice and set-theoretic operations with byte-level memory modeling to enable precise tracking of memory locations through base-offset associations. It supports operations such as join, meet, union, and inclusion checks on memory regions, using data structures like maps, sets, and hash tables that associate bases with byte-level offsets or intervals. Submodules refine this functionality by enabling region merging, range filtering, and hash-based storage with ordered iteration and bulk updates. Example uses include analyzing pointer arithmetic, verifying memory accesses, and tracking dynamic memory usage in C programs through precise byte-level abstractions.",
      "description_length": 687,
      "index": 2877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module supports efficient management of key-value pairs with operations like insertion, deletion, lookup, and sorted iteration, where keys are of a builder-defined type `t` (or `key`) and values are polymorphic. It integrates with state builders to track and manipulate abstract states in the Frama-C kernel, enabling use cases such as memoizing computations over analysis states or structuring state transitions with customizable ordering. The module also provides utilities for converting between hash tables and sequences, folding over entries, and defining structural representations for stateful data.",
      "description_length": 611,
      "index": 2878,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps that associate bases with memory maps, specifically using keys from the `Map.Key` module. It provides standard operations such as equality, comparison, hashing, and pretty printing for these keys, along with utilities for project membership checks and deep copying. It is used to manage and manipulate keys in memory map structures that are built using the `Offsetmap` module.",
      "description_length": 416,
      "index": 2879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_One",
      "library": "frama-c.kernel",
      "description": "Implements a low-level cache for values indexed by a single key. Uses hash tables via the `H` module and result storage via `R`. Useful for memoizing expensive computations from a single argument, such as parsing or analysis results tied to unique identifiers.",
      "description_length": 260,
      "index": 2880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AllowDuplication",
      "library": "frama-c.kernel",
      "description": "This module configures the `-allow-duplication` kernel option, managing a boolean state that controls whether code duplication is permitted during analysis. It provides functions to set, query, and observe changes to this setting, along with serialization and alias handling, following Frama-C's plugin patterns. The child module introduces a structured type `t` for project-related data that supports duplication, equality checks, and pretty printing, enabling precise management of analysis states across different project skeletons. Together, they allow fine-grained control over duplication behavior and structured data handling in static analysis workflows.",
      "description_length": 662,
      "index": 2881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Cabs_file",
      "library": "frama-c.kernel",
      "description": "This module handles CABS file representations with operations for equality, comparison, hashing, and pretty-printing. It provides deep copying, project membership checks, and type descriptors for CIL-based analysis. Use it to manipulate and analyze C source files within Frama-C plugins.",
      "description_length": 287,
      "index": 2882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.S",
      "library": "frama-c.kernel",
      "description": "This module defines a parameter abstraction with operations to set, retrieve, and monitor changes to its value, including support for command-line options and project state management. It works with a polymorphic type `t` and provides hooks for pre and post-value updates, custom marshaling, and alias handling. Concrete use cases include managing configurable analysis options in plugins, tracking state changes during program analysis, and integrating with Frama-C's command-line interface.",
      "description_length": 492,
      "index": 2883,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingForce",
      "library": "frama-c.kernel",
      "description": "This module controls the `-ulevel-force` option's behavior, determining whether function calls are forcibly unfolded during Frama-C's static analysis. It provides a boolean setting that can be enabled, disabled, or queried, with support for aliases, default values, and project persistence. The child module enhances this functionality by defining a structured type `t` to represent and manipulate complex option values, supporting comparisons, hashing, and pretty-printing. Together, they enable precise control over function expansion in verification workflows, such as ensuring recursive calls are fully evaluated during kernel analysis.",
      "description_length": 640,
      "index": 2884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic.Parameter",
      "library": "frama-c.kernel",
      "description": "This module enables direct access to plugin parameters and their states through string identifiers, allowing retrieval and manipulation of typed parameter values such as booleans, integers, strings, file paths, string sets, and string lists. It provides core operations to query, set, and manage parameter states dynamically, supporting use cases like configuring analysis options, modifying runtime settings, and tracking plugin behavior during static analysis. Child modules extend this functionality to specific data types, offering targeted operations for string parameters, string lists, file paths, dynamic types, string sets, boolean flags, and integer values, each enabling concrete tasks such as handling command-line options, managing file inputs, or toggling analysis features.",
      "description_length": 788,
      "index": 2885,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Sub_caml_weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table for managing `data` values with `t` as the table type. Provides operations to create tables and add entries. Useful for caching intermediate analysis results without preventing garbage collection of keys.",
      "description_length": 233,
      "index": 2886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Current_loc.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides `let<>` and `let<?>` binding operators for temporarily setting the current location when calling functions that take a location-aware operation. It works with `Current_loc.data` and `Current_loc.data option`, enabling scoped location context in logging or analysis functions that require a current location to be set. These operators simplify the use of `with_loc` and `with_loc_opt` by allowing direct syntax-based scoping without explicit function wrapping.",
      "description_length": 480,
      "index": 2887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing file paths with operations for equality, comparison, hashing, and pretty printing. It provides a structured descriptor for file path values, supporting deep copying and membership checks based on project skeletons. It is used to handle file path data in a way that ensures consistency and immutability, particularly in contexts requiring precise path manipulation and comparison.",
      "description_length": 428,
      "index": 2888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for managing associations between ordered keys and arbitrary values, supporting efficient insertion, lookup, and in-place modification. It works with hash tables that use keys from the enclosing ordered set type (`t`), enabling sorted iteration and folding via custom comparators, as well as safe value retrieval with default handling. Typical use cases include memoizing functions over ordered domains and maintaining dynamic mappings where keys require total ordering, such as tracking analysis results for program variables in static analysis tools.",
      "description_length": 606,
      "index": 2889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data structure for managing multiple kernel function analyses with string-based identifiers, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with abstract data types representing analysis states tied to kernel functions, using `As_string.Datatype.t` for string-encoded values and `Project_skeleton.t` for project context. It is used to store, compare, and manipulate analysis results across different projects, enabling precise tracking and copying of analysis data per function.",
      "description_length": 551,
      "index": 2890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.List-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list-based datatype for command-line parameters, providing operations to compare, hash, and pretty-print values. It supports deep copying and checks for the presence of project-related data through predicate functions. The module is used to manage and manipulate lists of parameter values with rich structural and comparison capabilities.",
      "description_length": 363,
      "index": 2891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enuminfo",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL enumeration information, centered around the `enuminfo` type. It includes functions for equality, comparison, hashing, and pretty-printing, as well as utilities to copy and check project membership in enum data, enabling tasks like tracking enum values across analysis phases or validating enum consistency in C code. The associated hash table module supports imperative mappings from enums to arbitrary values, with ordered traversal and bulk transformations, ideal for caching analysis results or attaching metadata to enums. The set and map modules provide ordered, immutable collections and keyed lookups over enum information, supporting union, intersection, filtering, and ordered iteration for structured analysis and transformation of C enumeration constants and their attributes.",
      "description_length": 846,
      "index": 2892,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set structure for a specific datatype, providing operations such as membership testing, union, intersection, and difference. It works with values of type `Datatype.t`, using the `equal`, `compare`, and `hash` functions defined in the parent module for identity and ordering. Concrete use cases include managing collections of analysis results or tracking sets of program elements like variables or functions across different analysis passes.",
      "description_length": 466,
      "index": 2893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Lattice_Set-O",
      "library": "frama-c.kernel",
      "description": "This module provides set-like lattice operations such as membership testing, union, intersection, and difference, alongside structural manipulations like element selection, type handling, and project-specific membership checks. It operates on a lattice type representing sets, with elements of a specified type, and supports functional transformations, predicate-based queries, and integration with type descriptors and project contexts. These capabilities are particularly useful for static analysis tasks requiring precise data flow tracking or context-sensitive set membership validation.",
      "description_length": 591,
      "index": 2894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing command-line string parameters with advanced features like value validation, alias resolution, and state serialization, alongside tracking modifications through hooks. It works with string-based data, including specialized handling for function names and restricted value sets, while supporting project-specific state tracking. Typical use cases include parsing and validating string arguments, enforcing allowed values for options, and maintaining persistent parameter states across program executions.",
      "description_length": 548,
      "index": 2895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kinstr_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module organizes a customizable hash table for associating `kinstr` keys with arbitrary data, enabling fine-grained state management, ordered traversal, and event-driven updates through value-change hooks. It supports memoization, dependency tracking, and project-specific persistence, with built-in marshaling for state serialization. A child module specializes the structure for a specific data type `t`, offering efficient storage and retrieval with deep copying, equality checks, and project-aware operations. Together, they enable caching analysis results per project state, managing transformations during static analysis, and synchronizing state changes across Frama-C's analysis workflows.",
      "description_length": 702,
      "index": 2896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a command-line option for handling lists of file paths, supporting operations like parsing, validation, and pretty-printing of file path inputs. It works with a list of file path strings, ensuring they conform to expected formats and exist as valid paths. Concrete use cases include specifying input files for analysis, loading plugins, or directing output to specific directories.",
      "description_length": 401,
      "index": 2897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Functions",
      "library": "frama-c.kernel",
      "description": "This module provides operations to query, search, and manipulate kernel functions in the AST, including checking existence by name, retrieving function data, and iterating over function definitions. It works with `kernel_function`, `varinfo`, `fundec`, and `funspec` types, primarily for analyzing and transforming C code during static analysis. Concrete use cases include resolving function definitions by name, checking if a function has both a declaration and a definition, and iterating over all function implementations to perform analysis or instrumentation.",
      "description_length": 564,
      "index": 2898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.String",
      "library": "frama-c.kernel",
      "description": "This module defines a string datatype with equality, comparison, hashing, and pretty printing, tailored for Frama-C's internal type system with support for deep copies, project membership checks, and integration with other structures. Its submodules Set, Map, and Hashtbl provide efficient, string-keyed collection management: Set offers ordered sets with set algebra and predictable traversal, useful for tracking identifiers; Hashtbl implements a typed hash table with imperative updates and sorted iteration, ideal for symbol tables and caches; and Map structures key-value pairs with typed access and project-aware operations, enabling precise data tracking in static analysis plugins. Example uses include managing symbolic values during analysis, building string-indexed caches, and associating project-specific data with readable keys.",
      "description_length": 842,
      "index": 2899,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Log.Messages",
      "library": "frama-c.kernel",
      "description": "This module enables categorized logging, debugging, and warning management for kernel and plugin operations, utilizing structured message formatting with source positions, debug keys, and configurable warning categories. It supports conditional output based on log levels, runtime activation of debug keys, deprecation handling, and internal consistency checks, while allowing dynamic configuration of warning statuses and customizable output handlers for diagnostics. Key use cases include fine-grained control over logging verbosity, tracking feature deprecations, and managing warning suppression or escalation during analysis.",
      "description_length": 630,
      "index": 2900,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic4",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic type values with four type parameters. It provides operations to instantiate a polymorphic type with four concrete types, check if a type is an instance of a polymorphic type, and retrieve the concrete type arguments from a polymorphic type. It works directly with type values from the `Frama_c_kernel.Type` module, handling four type variables in a generic way. Use this module when defining or manipulating ML types that have four type parameters, such as 4-ary polymorphic functions or data structures.",
      "description_length": 540,
      "index": 2901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_api.S_pp",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations for CIL data structures like variables, expressions, statements, and function definitions, as well as Frama-C kernel constructs such as logic annotations, memory models (`assigns`, `allocation`), and specification clauses. It works with CIL types and kernel-specific representations from `Cil_types`, using OCaml's `Format.formatter` to produce customizable human-readable output. The functions support use cases like generating ACSL-annotated code dumps, visualizing internal analysis states, and controlling formatting details (e.g., brace placement, annotation suppression) during model serialization.",
      "description_length": 652,
      "index": 2902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_type_info",
      "library": "frama-c.kernel",
      "description": "This module manages logic type metadata within a project-scoped state system, using custom hashtables that map string keys to `logic_type_info` values with specialized equality and rehashing. It enables atomic updates, change tracking, and bulk operations like iteration and fold, while ensuring project-isolated state transitions compatible with Frama-C's analysis framework. The child module provides structured data operations for logic type descriptors, supporting deep comparisons, memory-aware copies, and formatted output, enabling precise handling of versioned type information across analysis phases. Together, they facilitate inter-procedural analysis and plugin-driven extensions with persistent, serializable type metadata.",
      "description_length": 735,
      "index": 2903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutocompleteHelp",
      "library": "frama-c.kernel",
      "description": "This component manages autocompletion logic for string-based command-line options, offering operations to track valid values, resolve aliases, and persist state across sessions. It works with string sets and collections to support membership checks, iterative processing, and serialization, while integrating hooks for dynamic updates. Key data types include abstract values for command-line arguments, string-based parameters with validation and alias resolution, and categories that organize options with dependencies and accessors. Examples include handling user input suggestions in CLI tools, implementing autocompletable plugin options like file paths or function names, and managing project-specific configuration states with support for persistent storage and dynamic updates.",
      "description_length": 784,
      "index": 2904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lval",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL term l-values, including equality, comparison, hashing, and pretty-printing, with support for variables and memory locations. It enables static analysis tasks such as inspecting and modifying l-values, tracking symbolic expressions, and performing dataflow analysis using set, map, and hash table modules. The set module supports ordered collections with standard operations and range queries, while the hash table module enables efficient key-based storage and retrieval using `Term_lval` keys. A dedicated mapping module extends this functionality with ordered key-value associations, safe lookups, and transformation operations tailored for analyzing C expressions and memory locations.",
      "description_length": 747,
      "index": 2905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Make_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table that maps keys to values with associated type information. It supports operations to create, add, and retrieve typed entries, as well as iterate and fold over the table. It is used to manage dynamically typed data where each entry's type is checked at runtime, particularly in contexts like plugin development or dynamic analysis where type-safe storage is required.",
      "description_length": 416,
      "index": 2906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filled_string_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of strings with value semantics, supporting operations like membership testing, comparison, hashing, and pretty-printing. It works with the `As_string.Datatype.t` type, representing strings in a structured form. It is used to manage string-based data across Frama-C plugins, enabling precise tracking and manipulation of string values in static analysis contexts.",
      "description_length": 392,
      "index": 2907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Array",
      "library": "frama-c.kernel",
      "description": "Implements variable-length arrays for state builders, using a data module for element operations. Provides direct access to elements by index, mutable updates, and iteration over elements. Useful for managing dynamic collections of values within static analysis plugins, such as tracking variable states or constraint sets.",
      "description_length": 323,
      "index": 2908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rational.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables optimized for working with rational numbers, offering operations for creating, querying, and manipulating mappings where either keys or values are of type `Frama_c_kernel.Rational.t`. It includes a specialized key module that supports equality, comparison, hashing, and pretty printing, enabling efficient storage and retrieval of rational-based data in project-aware contexts. The module facilitates deep copying and membership checks over project skeletons, making it suitable for managing caches and symbol tables in static analysis plugins. Example uses include tracking rational-valued expressions or maintaining analysis state keyed by rational numbers.",
      "description_length": 692,
      "index": 2909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filesystem.Compressed",
      "library": "frama-c.kernel",
      "description": "This module provides functions to open files for reading or writing with optional compression handling. It works with file paths and input/output channels, automatically decompressing or compressing data based on the file type and specified flags. Concrete use cases include reading from and writing to compressed log files or binary data streams without manual compression management.",
      "description_length": 385,
      "index": 2910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.ForwardsTransfer-StmtStartData",
      "library": "frama-c.kernel",
      "description": "This module tracks data flow analysis states at the beginning of each statement in a program. It provides operations to query reachability, store and retrieve analysis results, and iterate over statement data. Use it to implement forward data flow analyses that require per-statement initial state information, such as constant propagation or live variable analysis.",
      "description_length": 366,
      "index": 2911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_offset",
      "library": "frama-c.kernel",
      "description": "This module provides fundamental operations for working with term offsets in CIL, including equality, comparison, hashing, and pretty-printing, while supporting efficient data structures like sets, maps, and hash tables. It enables precise manipulation and analysis of structured offsets within C code, facilitating tasks like memory value association and result persistence in static analysis plugins. The module's hash tables support polymorphic mappings with customizable ordering and memoization, while its ordered maps and sets allow for efficient lookups, transformations, and ordered traversal of term offset data. Specific use cases include dependency tracking, code slicing, and abstract interpretation where term offsets represent positions within program expressions or statements.",
      "description_length": 792,
      "index": 2912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S_with_product-List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists, including `iter`, `map`, and `fold_left`, which apply functions across list elements within a monadic context. It handles computations where each element of a list triggers a monadic action, accumulating results or effects sequentially. Concrete use cases include processing lists of abstract syntax tree nodes with potential side effects, or analyzing program elements where each step depends on previous results in a monadic state.",
      "description_length": 497,
      "index": 2913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons",
      "library": "frama-c.kernel",
      "description": "This module enables hash-consing for an arbitrary data type, ensuring structural equality maps to pointer equality, and provides unique identifiers and deep copying for canonical representations. It includes optimized collection types like sets, maps, and hash tables tailored for hash-consed values, supporting fast equality checks, membership queries, and state tracking. These collections allow operations such as union, insertion, lookup, and ordered traversal, with customizable comparison, hashing, and pretty-printing for project-aware analysis. Use cases include symbolic computation, static program analysis, and managing state configurations through efficient, immutable data transformations.",
      "description_length": 702,
      "index": 2914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, enable, and modify parameter categories with specific accessors and dependencies. It works with strings, state lists, and category types to structure parameter handling. Concrete use cases include setting up custom parameter groups, enabling all parameters under a category, and defining default or special categories like '@none' and '@all'.",
      "description_length": 434,
      "index": 2915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation where the value type is determined by the `Data` module, enabling efficient storage and retrieval of typed values. It supports standard operations like insertion, lookup, and iteration, with customization for equality, hashing, and comparison based on the data type. Child modules extend this functionality to specific value types, integrating seamlessly with analysis tools like Frama-C. For example, you can use it to track program variables or analyze data flow by associating typed metadata in a hash table.",
      "description_length": 560,
      "index": 2916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Kernel_function_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents a set of kernel functions with operations for equality, comparison, hashing, and pretty-printing. It works with `Datatype.t`, a polymorphic type representing abstract data, and includes utilities for project membership checks and deep copying. Concrete use cases include managing and manipulating sets of functions with precise semantic properties, such as checking equivalence or maintaining unique representations in static analysis tasks.",
      "description_length": 464,
      "index": 2917,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Bool-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a boolean datatype with standard operations including equality, comparison, hashing, and pretty printing. It provides deep copy functionality and supports project membership checks for analysis contexts. Concrete use cases include representing logical states and flags within static analysis plugins.",
      "description_length": 323,
      "index": 2918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to manage string-based command-line parameters with support for validation, alias resolution, and dynamic state synchronization. It works with string values and lists, leveraging custom marshaling for serialization and project-specific state tracking. Typical use cases include enforcing allowed value constraints, handling parameter aliases, and triggering side effects via change hooks during configuration updates.",
      "description_length": 447,
      "index": 2919,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Initinfo",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and comparing `initinfo` values, which represent initialization information in CIL. It supports equality checks, comparison, hashing, and pretty-printing for debugging or logging purposes. Additionally, it enables deep copying of values and checking for the presence of specific project-related data within them.",
      "description_length": 357,
      "index": 2920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Builtins",
      "library": "frama-c.kernel",
      "description": "This module manages the registration and extension of built-in logic objects in the analysis environment. It provides `apply` to finalize and add all requested built-in objects, and `extend` to defer the definition of such additions. It works with logic functions, predicates, and axioms used in formal verification tasks like memory safety and value analysis.",
      "description_length": 360,
      "index": 2921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Parameters",
      "library": "frama-c.kernel",
      "description": "This module defines parameters for offset maps, including whether to emit feedback during approximation of writes to large memory locations. It works with boolean values to control diagnostic output. A concrete use case is enabling or disabling verbose feedback when analyzing memory operations in static analysis tools.",
      "description_length": 320,
      "index": 2922,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Unit",
      "library": "frama-c.kernel",
      "description": "This module centers around the unit type, offering core operations like equality, comparison, hashing, and pretty-printing, alongside utilities for deep copying, project membership checks, and datatype descriptors. Its Set, Map, and Hashtbl submodules provide specialized, efficient collections for unit-typed keys and values, enabling structured data manipulation in static analysis contexts. The Map submodule supports ordered key-value storage with polymorphic values and ordered traversal, while the Hashtbl submodule enables efficient hash-based lookups with customizable key structures and project-aware operations. The Set submodule delivers immutable sets with full set algebra, ordered iteration, and conversion utilities, ideal for tracking unique program elements with strong correctness guarantees.",
      "description_length": 810,
      "index": 2923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Diff",
      "library": "frama-c.kernel",
      "description": "This module extends lattice operations with a `diff` function that computes an over-approximation of the difference between two lattice values, where the second value must be an under-approximation or exact. It operates on the lattice type `t`, enabling precise tracking of state changes in static analysis. Use cases include modeling memory state transitions and analyzing program invariants in Frama-C plugins.",
      "description_length": 412,
      "index": 2924,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-based data structure for managing collections of `Datatype.t` values with operations for membership, insertion, and iteration. It provides functions for creating empty sets, adding or removing elements, checking subset relationships, and comparing sets. Concrete use cases include tracking sets of program variables, expressions, or control-flow nodes during static analysis.",
      "description_length": 404,
      "index": 2925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-TP",
      "library": "frama-c.kernel",
      "description": "This module provides graph traversal, transformation, and visualization operations for directed graphs with multi-edge support, focusing on vertex/edge attribute handling and structural queries. It works with graph data structures (`Service_graph.t`, `TP.t`) and their associated vertex (`V`) and edge (`E`) types, enabling iteration, mapping, and neighborhood analysis. Key use cases include generating Graphviz DOT visualizations, querying subgraph hierarchies, and analyzing control-flow or dependency relationships in program analysis contexts.",
      "description_length": 548,
      "index": 2926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Model_info",
      "library": "frama-c.kernel",
      "description": "This module provides a project-scoped key-value store with string keys and CIL-derived model metadata values, supporting dictionary operations, change hooks, and custom marshaling over a global, state-aware hash table. It handles keys with custom rehashing logic to maintain consistency during project state transitions, enabling efficient, context-sensitive storage for static analysis tasks like caching results or tracking program properties. The associated datatype module supports equality, comparison, and project-aware copying, facilitating precise manipulation of logic model instances during analysis. Together, they enable operations such as keyed model storage, cross-project comparison, and state-aware value transformations.",
      "description_length": 737,
      "index": 2927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Id_Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map implementation based on hash-consed trees. It includes functions for equality, comparison, hashing, pretty printing, and deep copying of keys, ensuring consistent identity management. It is used to manage keys with unique identifiers and structural equivalence in a Patricia tree-based map.",
      "description_length": 359,
      "index": 2928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.MakeGraph",
      "library": "frama-c.kernel",
      "description": "This functor builds control flow graphs where vertices model control points labeled with program elements and edges carry transition conditions or actions. It supports graph construction, traversal in forward and backward directions, and structural analysis using weak topological orderings. You can create vertices from CIL expressions, connect them with labeled edges, and analyze dataflow in either direction using customizable abstract domains. The module enables precise propagation of program properties through transfer functions and facilitates verification tasks like liveness analysis or constant propagation over structured control flow.",
      "description_length": 648,
      "index": 2929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Compinfo",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL composite type information, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and project-based membership checks. It supports structured data management through sets, maps, and hash tables, enabling efficient aggregation, traversal, and transformation of C code elements. Child modules enhance these capabilities with ordered maps for polymorphic values, persistent sets for efficient querying, and hash tables for imperative and functional data manipulation. These tools collectively enable precise static analysis tasks such as metadata tracking, type definition management, and data-flow analysis across CIL-based projects.",
      "description_length": 729,
      "index": 2930,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Kernel_function_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and organizing command-line parameters. It provides operations to create, modify, and query parameter categories, including special categories like `@none`, `@default`, and `@all`. Use cases include defining logical groupings of options, setting default behaviors, and enabling or disabling sets of parameters collectively.",
      "description_length": 367,
      "index": 2931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintVersion",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean flag that controls version information output, offering operations to toggle its state and register callbacks for state changes. It integrates with project-specific state management systems to trigger version printing during execution or configuration updates, using a shared boolean value that can be manipulated directly or through child modules. The child module defines a data type `t` for version information, providing equality, comparison, hashing, and pretty-printing functions, along with utilities like `mem_project` for checking project membership and `reprs` for serialization. Together, they enable runtime control of version banners, synchronization with other components during option parsing, and structured manipulation of version metadata.",
      "description_length": 787,
      "index": 2932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnfoldingLevel",
      "library": "frama-c.kernel",
      "description": "This module manages integer-based configuration parameters with bounded values, specifically tailored for handling unfolding levels in the kernel. It defines a core type `t` with operations for equality, comparison, hashing, and pretty-printing, enabling deep copying, membership checks over project skeletons, and access to representants and descriptors for structural manipulation. Use cases include managing and comparing different levels of code unfolding during analysis, ensuring consistent representation and efficient lookup within Frama-C's kernel services.",
      "description_length": 566,
      "index": 2933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Set",
      "library": "frama-c.kernel",
      "description": "This module provides a functional set interface for ordered, immutable collections of comparable elements, supporting set-theoretic operations (union, intersection, difference), ordered traversal (ascending/descending), and transformations (filtering, mapping, partitioning). It works with `Set.t` structures representing sets of elements of type `elt` (identical to `t`), including specialized operations for nearest element queries, sequence conversions, and structural comparisons. These capabilities are particularly useful for static analysis tasks requiring precise data flow tracking, project membership validation, and persistent representation of typed collections in CIL-based analyses.",
      "description_length": 696,
      "index": 2934,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEq",
      "library": "frama-c.kernel",
      "description": "This module enables structural equality and comparison for CIL lvalues, supporting precise equality checks, hashing, and ordering based on value structure. It facilitates tasks like memory location tracking, expression comparison, and managing sets or maps of lvalues in analysis plugins. Submodules Set, Map, and Hashtbl provide collection operations tailored to structured lvalues, including efficient storage, retrieval, ordered traversal, and transformation optimized for static analysis. Examples include caching results for equivalent expressions, building alias analysis models by mapping lvalues to memory regions, and tracking variable bindings during symbolic execution.",
      "description_length": 680,
      "index": 2935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Enum-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured enumeration type with support for comparison, hashing, and pretty printing. It provides operations to check membership within project structures, create deep copies, and manage type representations. Concrete use cases include defining and manipulating command-line option values with precise type semantics and project-specific metadata.",
      "description_length": 370,
      "index": 2936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Offsetmap",
      "library": "frama-c.kernel",
      "description": "This module models memory slices as interval-to-value maps with metadata flags, enabling precise bit-level reasoning about memory states. It supports set-theoretic operations like union and intersection, precision-aware transformations such as narrowing and imprecise updates, and analysis queries over abstract representations of memory. The child module enhances intersection capabilities by offering both direct narrowing and bitwise reinterpretation-based intersection, facilitating accurate merging of abstract memory states during static analysis. Examples include tracking bitfield usage in embedded systems or verifying memory safety by analyzing overlapping memory ranges.",
      "description_length": 681,
      "index": 2937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Session_dir",
      "library": "frama-c.kernel",
      "description": "This module manages directory and file path resolution for session files, providing `get_dir` and `get_file` operations that handle path creation and validation. It works with string identifiers and converts them into typed file paths using the `Filepath` module. Concrete use cases include locating session-specific directories and files during analysis, ensuring correct path handling across different Frama-C versions.",
      "description_length": 421,
      "index": 2938,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Function",
      "library": "frama-c.kernel",
      "description": "This module implements first-class functions as datatype values, supporting operations like equality, comparison, hashing, and pretty-printing. It works with functions mapping values of type T1 to type T2, enabling their use in data structures and algorithms requiring such operations. Concrete use cases include storing, comparing, and serializing function values within Frama-C plugins.",
      "description_length": 388,
      "index": 2939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Set",
      "library": "frama-c.kernel",
      "description": "This module implements a functional set interface with persistent, ordered data structures, supporting operations like union, intersection, difference, and cardinality, along with ordered traversal and predicate-based filtering. It works with elements of type `elt` organized into sets (`Set.t`), offering transformations via `map`, `filter`, and `fold`, as well as conversions to sequences and lists, nearest-neighbor queries, and structural inspection tools. Designed for applications requiring precise ordered set manipulations, such as static analysis plugins handling program data with inherent element ordering or symbolic value tracking.",
      "description_length": 644,
      "index": 2940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages cache directories and files by providing functions to retrieve their paths. It works with string identifiers and returns valid file paths as `Frama_c_kernel.Filepath.t` values, optionally creating necessary parent directories. Concrete use cases include locating or generating cache files for analysis results or temporary storage during static analysis tasks.",
      "description_length": 380,
      "index": 2941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_bitwise_sig.S",
      "library": "frama-c.kernel",
      "description": "This module provides interval-based mapping operations where values are implicitly shared across all sub-intervals of a bound interval, supporting efficient lookups (`find`, `find_iset`), set-theoretic operations (`join`, `is_included`), and structural manipulations like folding with interval fusion. It works with integer interval ranges mapped to arbitrary values (`v`), leveraging implicit inheritance rules to avoid redundant storage. Typical use cases include static analysis scenarios requiring precise interval arithmetic, such as tracking bit-level properties or merged memory regions, with project-aware membership checks (`mem_project`) for modular reasoning.",
      "description_length": 670,
      "index": 2942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_api.S",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations for CIL and ACSL data structures, including variables, expressions, statements, function definitions, logic terms, annotations, and control-flow constructs. It formats these types into human-readable strings using OCaml's `Format.formatter`, primarily for debugging, logging, or tool output. The design supports customizable rendering through extensible printer modules, enabling tailored representations of complex constructs like loop annotations, behaviors, and allocation constraints.",
      "description_length": 536,
      "index": 2943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Pure",
      "library": "frama-c.kernel",
      "description": "This module provides a functional interface for constructing and manipulating CIL abstract syntax trees, focusing on expressions, statements, and type representations. It operates on CIL AST nodes like `exp`, `lval`, `stmt`, and `typ` to model arithmetic operations, memory accesses, control flow, and type qualifiers, while abstracting away explicit location handling. Designed for static analysis tasks, it enables building typed intermediate representations of C code, logic predicates, and memory models in a declarative, compositional manner.",
      "description_length": 547,
      "index": 2944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module organizes kernel functions into set-like structures with operations for membership, iteration, and state tracking, while integrating marshaling and command-line alias support for flexible configuration. It defines core types like `t` for function collections and supports dynamic updates through validation hooks and category-based classification. Submodules enhance functionality with pretty-printing and comparison utilities, string option validation for function names, and category management for grouping functions under labels like '@default' or '@all'. Example uses include validating user input against known functions, persisting function sets across sessions, and dynamically activating analysis rules based on category membership.",
      "description_length": 753,
      "index": 2945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Boot.Main",
      "library": "frama-c.kernel",
      "description": "This module registers functions to be executed during Frama-C's initialization. It works with unit functions, allowing plugins or extensions to integrate setup logic into the main entry point. Concrete use cases include initializing analysis modules or setting up custom command-line options.",
      "description_length": 292,
      "index": 2946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.Bool",
      "library": "frama-c.kernel",
      "description": "This module extends the option type with monadic operations, focusing on boolean conditions. It provides functions like `only_if`, which returns `None` if the boolean is false, and preserves the option value otherwise. Useful for conditional propagation of values without explicit pattern matching, especially in validation or filtering contexts.",
      "description_length": 346,
      "index": 2947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S_Basic_Compare",
      "library": "frama-c.kernel",
      "description": "This module provides standard set operations including membership testing, insertion, deletion, and set algebra (union, intersection, difference), alongside utilities for size measurement, element enumeration, and arbitrary element selection. It manipulates an ordered set data structure (`t`) containing elements of a comparable type (`elt`), ensuring purely functional transformations without modifying existing sets. Typical applications include managing unique element collections with efficient lookup, combining or filtering datasets, and converting between sets and lists for ordered processing.",
      "description_length": 602,
      "index": 2948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for handling multiple kernel functions with string representations. It provides operations for equality, comparison, hashing, and pretty-printing of these functions, along with deep copying and project membership checks. It is used to manage and manipulate sets of kernel functions in a type-safe manner during static analysis.",
      "description_length": 366,
      "index": 2949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Compositional_bool",
      "library": "frama-c.kernel",
      "description": "This module implements a compositional boolean attribute over a Patricia tree structure, where each node's boolean value is derived from its subtrees and leaf data. It works with hash-consed key-value pairs, using a big-endian bitwise decomposition for efficient lookups and updates. Concrete use cases include tracking presence or absence of properties across a sparse tree of states or configurations, such as in static analysis or symbolic execution engines.",
      "description_length": 461,
      "index": 2950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Custom",
      "library": "frama-c.kernel",
      "description": "This module enables defining command-line parameters with custom data types, supporting operations to set and retrieve values, register state change hooks, and customize serialization. It works with a custom type `t` (via the `V` submodule), string-based option names, and constrained value lists, while providing mechanisms for validation, alias management, and deprecation handling. It is particularly useful for integrating domain-specific types into Frama-C's option system with fine-grained control over allowed values and dynamic behavior.",
      "description_length": 545,
      "index": 2951,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InitializedPaddingLocals",
      "library": "frama-c.kernel",
      "description": "This component manages a boolean option that controls the initialization of padding bytes in local variables during static analysis, influencing how the kernel handles local variable declarations with padding, particularly in security-critical contexts. It provides functions to modify and query this setting, along with mechanisms for project-specific state tracking, serialization, and change notifications. A child module defines a structured data type `t` with operations for equality, comparison, hashing, and pretty-printing, supporting deep copying and project membership checks. This enables concrete use cases like representing analysis options, ensuring consistent value handling across kernel extensions, and tracking structured data attributes such as names, types, and descriptors.",
      "description_length": 794,
      "index": 2952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rangemap.Make",
      "library": "frama-c.kernel",
      "description": "This module provides purely functional operations for managing ordered key-value associations with interval-based semantics, including creation, lookup, modification, and traversal of balanced binary trees that cache hash values. It works with ordered keys and associated values, supporting precise interval queries, pairwise map comparisons, and range-preserving transformations. Specific use cases include static analysis tasks requiring efficient range-based data flow tracking, interval merging, and cross-map analysis of key-value intervals.",
      "description_length": 546,
      "index": 2953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for use in hash tables, specifically tailored for memory map keys in the analysis of C code. It provides standard operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It works directly with `Hashtbl.Key.t` values, supporting precise and efficient key management in static analysis contexts.",
      "description_length": 394,
      "index": 2954,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditPrepare",
      "library": "frama-c.kernel",
      "description": "This module manages file path configurations for command-line parameter handling, offering operations to set, retrieve, and validate file paths with support for update hooks, aliases, and serialization. It defines a core file path type `t` that tracks emptiness and maintains project-scoped mutability, enabling precise control over path state during audit preparation. The child module enhances this by providing equality, comparison, and introspection capabilities for structured data, supporting deep copies and project membership checks. Together, they enable workflows like validating empty paths before audit execution and synchronizing path settings across project contexts with fine-grained data analysis.",
      "description_length": 713,
      "index": 2955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables optimized for keys representing integer intervals with congruence properties, enabling efficient insertion, lookup, iteration, and conversion to ordered sequences. It supports keys defined by bounded or unbounded ranges combined with modulo constraints\u2014such as even numbers above 10 or values \u22613 mod 5\u2014facilitating precise set manipulation and value mapping for static analysis domains. The key module defines and manipulates these interval-based keys with standard operations like equality, comparison, and hashing, while the hash table module manages collections of values over these keys, supporting deep copying, membership checks, and pretty-printing. Specific uses include symbolic range analysis in program verification, where tracking variable bounds and periodicity is essential.",
      "description_length": 821,
      "index": 2956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option sets, providing operations to define, retrieve, and modify named categories such as '@none', '@default', and '@all'. It works with category types tied to a collection of elements and supports setting accessors and dependencies for each category. Concrete use cases include organizing and controlling groups of related command-line options in static analysis tools.",
      "description_length": 419,
      "index": 2957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map_with_product",
      "library": "frama-c.kernel",
      "description": "This module extends a minimal monad with support for combining two monadic values into a single pair using `product`, while providing standard operations like `return`, `bind`, `map`, and `flatten` derived from a base module. It enables composing effectful computations that carry both results and context, such as handling optional values or lists with side effects. The first child module supports processing lists of monadic values with functions like `map` and `fold_left`, useful for sequencing effects across elements in static analysis tasks. Another child module offers conditional execution via `only_if`, allowing effectful operations to proceed only when a boolean condition holds, which is useful for controlling analysis flow based on runtime or configuration flags.",
      "description_length": 779,
      "index": 2958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo_Id",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and comparing variable information identifiers, including equality, comparison, hashing, and pretty-printing functions. It works with the `varinfo` type, representing variables in CIL (C Intermediate Language) for static analysis tasks. Concrete use cases include tracking variable identities during analysis, comparing variable properties, and ensuring deep copies of variable data structures for accurate program analysis.",
      "description_length": 469,
      "index": 2959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Stateful",
      "library": "frama-c.kernel",
      "description": "This module offers utilities to construct and manipulate C intermediate language (CIL) expressions, types, and control-flow structures programmatically, emphasizing stateful composition of abstract syntax trees (ASTs). It operates on CIL AST nodes like expressions (`exp`), lvalues (`lval`), statements (`stmt`), and types (`typ`), supporting operations such as arithmetic/bitwise logic, memory access, type conversion, and function/variable metadata management. Specific use cases include building C code fragments with explicit control flow (e.g., loops, conditionals), generating ACSL annotations for formal verification, and modeling memory states for static analysis tasks like validity or allocation checks.",
      "description_length": 713,
      "index": 2960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Ty_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table indexed by type values, allowing storage and retrieval of data associated with specific types. It supports creating tables, adding entries with a type key and corresponding data, and finding data by type. Concrete use cases include managing type-specific metadata or configurations in a type-safe manner.",
      "description_length": 354,
      "index": 2961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Custom",
      "library": "frama-c.kernel",
      "description": "This module provides operations to define and manage custom command-line parameters with constrained value sets, including setting allowed values, retrieving current options, and tracking changes via hooks. It works with a parameter type `t` that encapsulates state for permissible strings, supporting use cases like restricted option parsing, dynamic value validation, and persistent state configuration. Features such as alias management and serialization enable integration with larger option frameworks and runtime adjustments.",
      "description_length": 531,
      "index": 2962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.Preprocessor",
      "library": "frama-c.kernel",
      "description": "This module provides access to configuration settings for the C preprocessor used by Frama-C. It exposes values such as the preprocessor command, whether it's GNU-like, and supported architecture options. These settings are used to ensure correct preprocessing behavior, such as preserving comments and selecting appropriate command-line flags based on the environment or build configuration.",
      "description_length": 392,
      "index": 2963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Iter",
      "library": "frama-c.kernel",
      "description": "This module provides iteration functions over pairs of AST elements in a visitor behavior, allowing side effects through a provided function. It processes specific CIL types such as varinfo, compinfo, enumitem, stmt, and others, visiting both the old and new versions of each element. Concrete use cases include comparing or synchronizing changes between AST versions during analysis or transformation passes.",
      "description_length": 409,
      "index": 2964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-module-type-Domain",
      "library": "frama-c.kernel",
      "description": "This module defines operations for abstract domains used in the analysis of interpreted automata. It provides functions to combine abstract states (`join`), extrapolate them (`widen`), and apply edge-based transitions to compute new states (`transfer`). These operations are applied to an abstract domain type `t`, which represents program states during static analysis.",
      "description_length": 370,
      "index": 2965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.FORWARD_MONOTONE_PARAMETER",
      "library": "frama-c.kernel",
      "description": "This module implements a forward dataflow analysis framework where transfer functions operate on control-flow graph edges, allowing state refinement based on branching conditions. It works with a lattice type `t` equipped with join, bottom, inclusion checks, and statement-specific transfer logic. Concrete use cases include tracking variable ranges or possible null pointers through code paths, leveraging edge-based precision to improve analysis accuracy in conditions like `if` statements.",
      "description_length": 492,
      "index": 2966,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line parameters for string-based data types with support for equality, comparison, hashing, and pretty-printing. It works with `As_string.Datatype.t` values, providing operations to describe, compare, and serialize them. Concrete use cases include defining configurable options that accept string inputs, such as file paths, identifiers, or symbolic flags, and integrating them into Frama-C's plugin system with proper project management and deep copying.",
      "description_length": 486,
      "index": 2967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.S_ordered",
      "library": "frama-c.kernel",
      "description": "This module implements hooks with ordered execution based on priority and dependency constraints. It allows registering functions with unique identifiers, defining execution order through dependencies, and applying them in a specific sequence. Use it to manage plugins or callbacks where the order of execution matters, such as analysis passes in a static analysis tool.",
      "description_length": 370,
      "index": 2968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_set",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string sets (`String.Set.t`) within Frama-C plugins, offering operations to add elements, check membership, iterate, and fold over string collections. It integrates with plugin infrastructure through command-line argument parsing, value change hooks, and serialization, enabling use cases like tracking project-specific string-based configurations or dynamically updated options requiring persistence and extensible callbacks. Submodules support string representation and categorization, enhancing flexibility for plugin developers.",
      "description_length": 576,
      "index": 2969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for parameter collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control parameter behavior through accessors and dependencies. Concrete use cases include setting default category behavior, enabling all parameters with specific interpretations, or aliasing the `@all` category to another category.",
      "description_length": 452,
      "index": 2970,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing project-scoped hashtables with key-value pairs, enabling storage, retrieval, iteration, and state-aware memoization. It works with hashtables whose keys must not use custom rehash functions (as projectified state management would break such invariants), and supports use cases like tracking analysis metadata across project state transitions, caching computation results, or registering callbacks to react to state changes. The design ties hash table persistence and mutation to the project's lifecycle, ensuring consistency during incremental updates or rollbacks.",
      "description_length": 610,
      "index": 2971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Int",
      "library": "frama-c.kernel",
      "description": "This module manages integer command-line options by providing operations to set and retrieve values, enforce range constraints, and register change hooks. It operates on integer values and ranges, supporting use",
      "description_length": 211,
      "index": 2972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages file paths for a plugin's configuration directory, providing functions to retrieve or create directories and files within it. It works with `Frama_c_kernel.Filepath.t` to handle paths and allows setting or checking a user-specific directory. Concrete use cases include storing and accessing plugin-specific configuration files or cached data during static analysis.",
      "description_length": 385,
      "index": 2973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Base",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing the base of an addressable memory zone, with core operations for equality, comparison, hashing, and pretty printing. It includes utilities for inspecting and manipulating memory zone descriptors, such as checking project membership and creating deep copies, enabling precise management and comparison of memory regions during static analysis. The associated hash table and map modules support efficient key-based storage and transformation of memory associations, while the set module provides ordered set operations for modeling memory validity and tracking dynamic regions. These components together facilitate tasks like memory analysis, caching, permission tracking, and pointer safety verification in program analysis workflows.",
      "description_length": 782,
      "index": 2974,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.Full_AI_Lattice_with_cardinality",
      "library": "frama-c.kernel",
      "description": "This lattice structure supports union, intersection, difference, and cardinality estimation operations over abstract value sets, using a type `t` that represents over-approximated elements in static analysis. It enables precise set manipulations through enumeration and folding, while handling widening for convergence in fixed-point computations. These capabilities are particularly useful in abstract interpretation for tracking variable ranges, potential runtime values, or disjunctive invariants with cardinality constraints.",
      "description_length": 529,
      "index": 2975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered maps that associate keys with polymorphic values, supporting construction, querying, merging, and ordered traversal. It provides core operations like binding, filtering, and transformation, along with specialized submodules for typed parameter maps and unique key handling. The first submodule enables working with maps parameterized by a specific data type, supporting equality, comparison, and pretty printing for structured values. The second submodule defines keys with embedded project data, allowing efficient comparison and filtering based on key metadata. Example uses include managing command-line configurations with typed values and structured key hierarchies.",
      "description_length": 699,
      "index": 2976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a service computation algorithm over directed graphs to derive service boundaries from a given entry point, working with graph structures that support vertex and edge operations. It integrates graph traversal and query capabilities from its submodules, which provide labeled vertices and edges, reachability analysis, and dynamic graph modification, enabling tasks like control flow analysis and dependency tracking. Main data types include vertices with identifiers, directed edges with labels, and graph structures that support folding, transformation, and reachability checks. Example uses include analyzing program callgraphs to identify cohesive service units, dynamically modifying graph structures to reflect changing dependencies, and visualizing service boundaries using Graphviz.",
      "description_length": 812,
      "index": 2977,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.StmtStartData",
      "library": "frama-c.kernel",
      "description": "This module manages per-statement data at the start of dataflow analysis. It provides operations to add, replace, retrieve, and iterate over data associated with CIL statements. Use it to track analysis state at function entry points or specific control flow nodes in static analysis plugins.",
      "description_length": 292,
      "index": 2978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map",
      "library": "frama-c.kernel",
      "description": "This module builds a map structure over arbitrary data types, enabling efficient key-value operations like insertion, lookup, and traversal. It integrates with the `Data` module to support typed values, offering equality checks, comparison, and pretty printing for maps. With its submodules, it allows organizing and manipulating structured data, such as tracking variable bindings or analysis metadata in static analysis plugins. Example uses include mapping variable names to types or associating analysis results with specific code locations.",
      "description_length": 545,
      "index": 2979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Option_ref",
      "library": "frama-c.kernel",
      "description": "This module implements a state reference for an optional value with support for setting, getting, and memoizing values, along with update hooks and custom marshaling for serialization. It provides a polymorphic option type with operations for equality, comparison, hashing, and pretty-printing, enabling robust state management in plugins through deep copy and project membership checks. Use it to track analysis results that are computed lazily or updated incrementally during static analysis, such as optional values in analysis states or extensible data descriptors for plugin components.",
      "description_length": 591,
      "index": 2980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kf",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with kernel functions in CIL, including equality, comparison, hashing, and pretty-printing, while supporting efficient data structures like sets, maps, and hash tables for function instance manipulation. Its submodules enable structured heterogeneous mappings with ordered traversal, memoizing hash tables with safe access and key-based sorting, and ordered sets with functional transformations for managing CIL elements. You can use it to track function properties across translation units, merge analysis results conditionally, or filter and iterate over function collections with precise ordering. Specific capabilities include generating formatted reports, caching computed function properties, and managing analysis states with deterministic iteration and deep copy operations.",
      "description_length": 831,
      "index": 2981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto.S",
      "library": "frama-c.kernel",
      "description": "This module computes weak topological orderings (WTOs) of directed graphs using a customizable preference function to prioritize node ordering. It operates on nodes and partitions them into strongly connected components, recursively ordered to support fixpoint evaluation. Concrete use cases include analyzing control flow graphs in program analysis to determine efficient iteration strategies for dataflow analysis.",
      "description_length": 416,
      "index": 2982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for string-based parameters with operations for equality, comparison, hashing, and pretty printing. It works with `As_string.Datatype.t`, a type representing command-line parameters as strings, and supports deep copying and project membership checks. Concrete use cases include managing and comparing string-based configuration options in Frama-C plugins.",
      "description_length": 399,
      "index": 2983,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Obj_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table where keys are type-indexed and values are polymorphic. It supports operations to create, add, find, check membership, and iterate over entries. Concrete use cases include associating type-specific metadata with values in static analysis plugins, such as mapping abstract types to their corresponding analysis states or annotations.",
      "description_length": 382,
      "index": 2984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.With_output-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a datatype with command-line option support, including equality, comparison, hashing, and pretty-printing. It works with a specific abstract type `t` and lists of its values, providing deep copying and project membership checks. Concrete use cases include managing configurable analysis parameters and persisting their state across projects.",
      "description_length": 376,
      "index": 2985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String",
      "library": "frama-c.kernel",
      "description": "This component manages string-valued plugin parameters, offering operations to set, retrieve, and validate values against constraints like function name existence, along with serialization, alias handling, and dynamic help output generation. It supports use cases requiring validated configuration storage, runtime updates via change hooks, and seamless integration with code analysis workflows that reference program elements.",
      "description_length": 427,
      "index": 2986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Value_int",
      "library": "frama-c.kernel",
      "description": "This module implements operations for a value type representing integers in the Frama-C kernel, supporting equality checks, comparison, hashing, and pretty-printing. It provides conversions to and from strings, deep copying, and project membership testing for use in plugin-specific data management. These functions are used to handle integer values within Frama-C's abstract interpretation frameworks and plugin data structures.",
      "description_length": 429,
      "index": 2987,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice_with_cardinality",
      "library": "frama-c.kernel",
      "description": "This module provides operations to reason about the cardinality of mapset lattices, including checking if a lattice contains zero or one element, approximating set differences, and folding over elements when countable. It works with mapset lattice values, which are maps from keys to elements of a lattice type, and supports concrete use cases such as analyzing program states with bounded or singleton value sets. Functions like `find_lonely_binding` enable extracting unique key-value pairs under cardinality constraints, useful in static analysis scenarios requiring precise value tracking.",
      "description_length": 593,
      "index": 2988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice",
      "library": "frama-c.kernel",
      "description": "This module provides lattice operations (join, meet, narrow), map transformations, and structural manipulations for associative containers binding keys to lattice-typed values. It operates on parameterized map structures with support for key-value pairs, set operations, and cached computations, leveraging submodules like `Set` and `Map` for underlying representations. Designed for scenarios requiring hierarchical data combination, such as static program analysis or abstract interpretation domains, it enables efficient merging, filtering, and approximation of key-indexed lattice elements.",
      "description_length": 594,
      "index": 2989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer.PrinterExtension",
      "library": "frama-c.kernel",
      "description": "This module defines a signature for extending an existing pretty-printer, enabling customization of how abstract syntax trees (ASTs) are formatted as strings. It works with OCaml functors and class-based printers, specifically targeting AST structures. Concrete use cases include adding custom formatting rules for new AST node types or modifying the output style of existing nodes without altering the core printer implementation.",
      "description_length": 431,
      "index": 2990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Bool",
      "library": "frama-c.kernel",
      "description": "This module defines a boolean type with standard operations like equality, comparison, and pretty printing, while supporting deep copies, project-based membership checks, and structured representations for use in Frama-C's type system. Its submodules extend this foundation with set algebra for boolean collections, imperative hash tables for efficient boolean-keyed mappings, and ordered immutable maps for functional manipulation of boolean-indexed data. These components enable precise boolean state tracking across static analysis plugins, including managing conditional branches, caching logical expressions, and handling project-specific boolean associations. Example uses include tracking sets of program elements under boolean conditions, performing set operations with exception-safe accessors, and maintaining ordered mappings of binary properties for analysis metadata.",
      "description_length": 880,
      "index": 2991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make",
      "library": "frama-c.kernel",
      "description": "This module manages mappings from intervals to arbitrary values, enabling construction of evenly spaced interval maps, merging of interval-bound data, and lattice-aware analysis through widening and narrowing. It supports structured iteration, slicing, and imprecise value resolution over `Ival.t` ranges, with core operations like `narrow` and `narrow_reinterpret` in its submodules computing over-approximated intersections while preserving range coverage. Use cases include static analysis of program value ranges, cache state modeling, and abstract domain computations requiring precise interval partitioning. The `narrow_reinterpret` function ensures soundness by enforcing value normal forms through bitwise reinterpretation, making it suitable for domains where representation matters.",
      "description_length": 792,
      "index": 2992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int64",
      "library": "frama-c.kernel",
      "description": "This module provides a 64-bit integer type with precise arithmetic, comparison, and serialization, serving as the foundation for structured integer-based data manipulation in static analysis. It includes a set module for ordered, immutable collections with efficient set-theoretic operations and ordered traversal, ideal for tracking integer ranges and dependencies, and a hash table module supporting arbitrary value types, deterministic iteration, and memoization keyed on 64-bit integers. A dedicated map module enables efficient, typed storage and retrieval of structured data indexed by 64-bit keys, with built-in support for deep comparison and integration with analysis frameworks. These components together enable robust modeling of integer semantics in static analysis, from low-level bit behavior to high-level data aggregation.",
      "description_length": 838,
      "index": 2993,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_lattice_with_isotropy.S",
      "library": "frama-c.kernel",
      "description": "This module supports lattice operations such as equality, comparison, inclusion checks, widening, and isotropy handling, alongside bit-level manipulations including range extraction, shifting, and merging. It operates on fixed-size bitvectors and abstract memory offset representations (`t`), incorporating origin tracking to model imprecision in low-level data analysis. Designed for Frama-C's abstract interpretation framework, it enables precise reasoning about bit-level transformations and memory layouts while preserving uniformity across isotropic regions.",
      "description_length": 563,
      "index": 2994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage and manipulate sets of kernel functions (`Frama_c_kernel.Cil_datatype.Kf.Set.t`) through command-line interfaces, enabling set operations like addition, membership checks, iteration, and serialization. It supports advanced features such as value tracking, default restoration, alias resolution, and project-specific state management, with utilities for string representation and category-based organization. These capabilities are used to configure static analysis parameters, dynamically update function sets, and persist or restore analysis contexts across sessions.",
      "description_length": 610,
      "index": 2995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Empty_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string command-line options with support for value change hooks, marshaling, alias resolution, and project-specific state synchronization. It handles string-based parameters that can enforce value constraints, validate function names, and extract raw string arguments, enabling customizable option behavior. These capabilities are specifically used in Frama-C plugin development to implement command-line interfaces with validated inputs and dynamic response logic.",
      "description_length": 510,
      "index": 2996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Rel",
      "library": "frama-c.kernel",
      "description": "This module represents integers as differences between absolute values, enabling operations like addition, subtraction, and comparison of relative values. It supports concrete computations involving offsets or differences between abstract integer values, such as computing remainders and validating modular relationships. Typical use cases include symbolic analysis and constraint solving in static analysis tools.",
      "description_length": 414,
      "index": 2997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.S-G-V",
      "library": "frama-c.kernel",
      "description": "This module defines vertices for a state dependency graph, where each vertex represents a state and carries a label. It provides operations to create vertices from labels, retrieve labels from vertices, and compare, hash, and check equality of vertices. The module is used to model dependencies between program states, enabling analysis of state transitions and relationships in static analysis tools.",
      "description_length": 401,
      "index": 2998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.TopBottom",
      "library": "frama-c.kernel",
      "description": "This module provides a lattice structure for values that can be concrete, top, or bottom, with monadic operations like `bind`, `map`, and `flatten`, as well as lattice-specific operations such as `join`, `narrow`, and `is_included`. It enables precise modeling of abstract domains where extremal values represent undefined or maximal states, such as in static analysis. One submodule introduces a datatype wrapper for domains with explicit top and bottom elements, supporting equality, comparison, and pretty printing, while the other defines custom operators for mapping, binding, and pairing lattice values with proper narrowing behavior. Together, they allow operations like joining abstract values, checking inclusion, and composing analyses while preserving lattice properties.",
      "description_length": 782,
      "index": 2999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Set",
      "library": "frama-c.kernel",
      "description": "This module supports querying, manipulating, and transforming ordered collections of memory base abstractions through standard set operations (union, intersection, difference), element-wise modifications, and predicate-based filtering. It operates on sets of `Frama_c_kernel.Base.Set.elt` values\u2014representing memory zone bases\u2014with utilities for ordered iteration, sequence integration, and nearest-neighbor queries, while providing type introspection and pretty-printing capabilities. Typical applications include analyzing memory validity regions, tracking dynamic memory allocations, and performing static analysis tasks requiring precise memory state modeling.",
      "description_length": 664,
      "index": 3000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptshape",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps over memory base keys with operations for structural analysis, comparison, and cardinality tracking, alongside heterogeneous map combinators that enable ordered traversal, cache-aware folding, and predicate-based equivalence checks. It works with memory base types representing addressable zones and their validity states, supporting use cases in static analysis where precise memory state tracking and cross-map relationships are required. The heterogeneous operations facilitate combining different memory region representations while handling asymmetries in key presence, with cache management enabling efficient repeated analyses.",
      "description_length": 674,
      "index": 3001,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filled_string_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string set data structure with filled builder functionality, providing operations for creating, modifying, and querying sets of strings. It supports standard set operations such as membership testing, union, intersection, and difference, along with serialization and pretty-printing for user interaction. Concrete use cases include managing collections of unique string identifiers, such as command-line option arguments or configuration keys, with efficient lookup and manipulation.",
      "description_length": 508,
      "index": 3002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Kernel_function_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports managing string-based command-line parameters with operations for value assignment, validation against allowed sets, alias resolution, and lifecycle hooks for state transitions. It works with string data representations, particularly for enforcing constraints on function names or predefined string enumerations. Typical use cases include parsing validated options in CLI tools, such as restricting inputs to known function identifiers or maintaining consistent project state configurations through serialized string parameters.",
      "description_length": 549,
      "index": 3003,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple_with_collections",
      "library": "frama-c.kernel",
      "description": "This module defines a quadruple type that combines four distinct components into a single value, supporting equality, comparison, hashing, and pretty printing. It includes specialized collection modules for managing sets, maps, and hash tables keyed by these quadruples, enabling efficient storage, lookup, and transformation of structured data. You can use it to represent compound identifiers, coordinates, or structured fields, and perform operations like set union, ordered map traversal, or memoization with typed keys. Submodules provide concrete implementations for key representations, typed value handling, and serialization, supporting use cases such as static analysis, state tracking, and data aggregation with strong type guarantees.",
      "description_length": 746,
      "index": 3004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval_sig.S",
      "library": "frama-c.kernel",
      "description": "This module provides abstract interpretation operations for floating-point intervals with configurable precision (single/double), supporting lattice-based analysis through inclusion checks, joins, and widening. It handles arithmetic, trigonometric, and rounding operations alongside special value propagation (NaN, infinity), while enabling constraint refinement via backward/forward comparisons and bit-level conversions for static verification tasks like program analysis and interval narrowing. Key use cases include verifying floating-point computations, refining value ranges through relational constraints, and modeling precision-sensitive behaviors in numerical code.",
      "description_length": 674,
      "index": 3005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.BigIntsHex",
      "library": "frama-c.kernel",
      "description": "This module manages hexadecimal representation settings for large integers through a configurable option, enabling stateful updates and integration with validation hooks. It supports bounded integer parameters with range constraints, increment actions, and custom marshaling, while its child module defines a data type `t` for arbitrary-precision hexadecimal integers with equality, comparison, and pretty-printing operations. The combined functionality allows dynamic formatting of numeric outputs, deep copying of integer states in analysis workflows, and synchronization with project-wide state systems. Use cases include controlled manipulation of big integers in analysis plugins and persistent configuration of integer representations across tool sessions.",
      "description_length": 762,
      "index": 3006,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Counter",
      "library": "frama-c.kernel",
      "description": "This module implements a projectified counter that provides operations to increment, retrieve, and reset an integer value. It maintains internal state across function calls, allowing clients to generate sequential identifiers or track progress within a project. The counter starts at 0 and supports operations `next` to increment and return the new value, `get` to read the current value, and `reset` to set it back to 0.",
      "description_length": 421,
      "index": 3007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCppCommands",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls the printing of preprocessor commands during analysis, integrating internal state handling, value change hooks, and serialization mechanisms. It defines a data type for representing `-print-cpp-commands` values with support for equality, comparison, hashing, pretty-printing, deep copying, and project membership checks. Operations allow setting, querying, and monitoring the flag's state, enabling precise control and debugging of preprocessing steps. Use cases include auditing command-line argument handling and logging preprocessor actions in Frama-C's analysis pipeline.",
      "description_length": 638,
      "index": 3008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables for mappings involving abstract integer keys with deterministic traversal, supporting key-based insertion, lookup, and removal. It works with `Frama_c_kernel.Int_val.t` keys and arbitrary value types, enabling efficient state management in static analysis where key ordering and deterministic iteration matter. The key module defines operations for integer value abstractions used as keys, while the hash table module combines these keys with user-provided data types to manage mappings like variable bindings or analysis state transformations. Example uses include memoizing results over integer ranges and tracking program state during abstract interpretation.",
      "description_length": 706,
      "index": 3009,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` by extending an existing directory structure. It provides `get_dir` and `get_file` operations to resolve subdirectories and files within the site, ensuring correct type and existence. Use it to organize and access structured data directories with strict path validation.",
      "description_length": 306,
      "index": 3010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.String_tbl",
      "library": "frama-c.kernel",
      "description": "This module implements a heterogeneous hash table indexed by strings, where each entry associates a key with a typed value. It supports operations to create, add, and retrieve entries, as well as iterate and fold over the table's contents. The module is used to manage dynamically typed values with string keys, particularly in contexts requiring type-safe storage and retrieval of heterogeneous data.",
      "description_length": 401,
      "index": 3011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_map",
      "library": "frama-c.kernel",
      "description": "This module implements a string-keyed map with tracking mechanisms for managing key-value pairs, supporting operations to set values with default fallbacks, add aliases, monitor state changes, and customize serialization. It enables command-line configuration handling, dynamic project-specific state updates, and computed value tracking, while providing utilities for membership checks, categorized data grouping, and iterative processing of string-mapped values. Use cases include persistent state management, option parsing with contextual help, and cross-execution configuration synchronization.",
      "description_length": 599,
      "index": 3012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedDowncast",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls warning generation for signed integer downcasts, providing operations to set, query, and track changes to the flag's state, with support for serialization and alias management. It defines the `bool` type as the core data structure and includes functions for runtime state monitoring and plugin configuration, enabling precise control over diagnostic messages during static analysis of C code. The child module introduces a data type `t` to represent and manipulate signed downcast warnings, offering equality checks, comparison, hashing, pretty-printing, and utilities for project membership and deep copying. Together, they allow users to configure warning behavior via command-line options and programmatically inspect or modify analysis outcomes based on signed downcast risks.",
      "description_length": 843,
      "index": 3013,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath",
      "library": "frama-c.kernel",
      "description": "This module type provides operations for managing file path options in plugins, including value setting/retrieval, command-line alias handling, state persistence control, and change hooks. It works with `Frama_c_kernel.Filepath.t` values and exposes a module type for typed file path parameters with validation via an `is_empty` predicate. These features support use cases like plugin configuration, project-specific path validation, and dynamic behavior customization based on file path state.",
      "description_length": 494,
      "index": 3014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.List_ref",
      "library": "frama-c.kernel",
      "description": "This module implements a state reference for a list of values with operations to add, iterate, fold, and track changes, enabling dynamic list management in analyses. It provides direct access to the underlying list via `get` and `set`, while supporting standard list operations like equality, comparison, and pretty-printing through its value type. Submodules offer utilities for list manipulation, deep copying, and membership checks, facilitating structured data processing in plugins. Example uses include accumulating analysis results or tracking evolving value sets across program points.",
      "description_length": 593,
      "index": 3015,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.Simple_backward",
      "library": "frama-c.kernel",
      "description": "Implements a simple backward data flow analysis over a user-defined domain `P`, computing pre- and post-states for statements based on a transfer function. Provides direct access to analysis results through iteration and folding over all reachable statements. Useful for analyses such as backward constant propagation or dependency tracking, where the state before a statement is derived from the state after its successors.",
      "description_length": 424,
      "index": 3016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Bool-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line boolean options with support for parsing, equality checks, and pretty-printing. It defines a data type for boolean flags, including operations to compare, hash, and display values. Concrete use cases include enabling or disabling analysis features via command-line switches, such as `-no-ansi-colors` or `-verbose`.",
      "description_length": 351,
      "index": 3017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string-based data types, providing operations to compare, hash, and pretty-print values. It supports data types that conform to the `As_string.Datatype` interface, enabling seamless conversion to and from strings. Concrete use cases include parsing and validating string inputs, managing configuration options, and generating user-friendly output for string-based settings.",
      "description_length": 429,
      "index": 3018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages the resolution of state directories and files for Frama-C's kernel operations. It provides `get_dir` and `get_file` to locate or create state paths based on a given name, returning validated file paths or aborting on failure. It works directly with string identifiers and handles paths using the `Frama_c_kernel.Filepath` type. Use cases include retrieving plugin-specific state storage locations during analysis or session management.",
      "description_length": 455,
      "index": 3019,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for manipulating CIL statements, including equality, comparison, hashing, and pretty printing, centered around the `t` type for representing statements. It integrates sets, maps, and hash tables for efficient grouping, association, and indexing of statements, enabling tasks like control flow analysis and code transformation. Submodules support ordered set operations, statement-keyed mappings, and imperative storage for associating data with statements, such as tracking variable states or annotating code during static analysis. Specific capabilities include set union and difference, keyed data mapping, and hash-based lookups, all tailored for scalable and precise manipulation of C code structures.",
      "description_length": 742,
      "index": 3020,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages a string-keyed map of value lists, supporting operations to set, retrieve, and iterate over entries while handling aliases, custom marshaling, and metadata. It works with a collection type `t` containing key-value pairs (`elt = key * value list`), where values are module-type instances. It is particularly suited for command-line option handling with multiple values per key, default tracking, and structured help generation in static analysis tools.",
      "description_length": 471,
      "index": 3021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.S-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements state management for analysis plugins by defining data types with equality, comparison, and serialization. Provides operations to create, compare, and pretty-print structured data, along with deep copying and project membership checks. Used to build and manipulate abstract states during static analysis of C code.",
      "description_length": 325,
      "index": 3022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Get",
      "library": "frama-c.kernel",
      "description": "This module defines transformation functions for various CIL data structures, including variables, types, statements, and function definitions. Each function applies a visitor behavior to an element, returning a modified version of that element. It is used to implement custom traversals and transformations of C code during static analysis.",
      "description_length": 341,
      "index": 3023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string-based data types, providing operations to define, parse, and manipulate string values with support for equality, comparison, hashing, and pretty-printing. It works with a concrete string type, offering functions to check membership within projects, create deep copies, and describe values for user output. Use cases include defining configurable string options in Frama-C plugins, such as file paths, identifiers, or textual settings exposed through the command line.",
      "description_length": 530,
      "index": 3024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control option behavior through accessors and dependencies. Concrete use cases include setting default category behavior, enabling all options with specific interpretations, or aliasing the `@all` category to another category.",
      "description_length": 456,
      "index": 3025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Constant",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL constants, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying, project membership checks, and managing collections like sets, maps, and hash tables. Its submodules offer ordered sets for efficient constant manipulation with union and range queries, hash tables for keyed storage and memoization, and ordered maps for structured associations with customizable value types. These components support static analysis tasks such as evaluating constant expressions, tracking value flow, and associating constants with symbolic data or analysis results. Specific operations include mapping over constant sets, inserting into hash tables with ordered traversal, and building typed mappings from constants to analysis metadata.",
      "description_length": 825,
      "index": 3026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LeftShiftNegative",
      "library": "frama-c.kernel",
      "description": "This module configures whether to warn on left-shifting negative integers, manipulating a boolean value that controls this behavior and integrates with project state to enforce context-specific settings. It supports toggling the option, tracking changes via hooks, and persisting values across sessions, while its child module defines data types and operations for analyzing and handling such shifts, including equality, comparison, and pretty printing. Together, they enable static analysis of C code to detect undefined behavior from shifting negative values, allowing developers to customize warnings or transformations based on analysis results. Specific uses include enforcing coding standards, implementing linter rules, and preventing subtle bugs in low-level bit manipulation.",
      "description_length": 784,
      "index": 3027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Verbose",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for managing a configurable integer-based verbosity level in a Frama-C plugin, including operations to set, retrieve, and increment the level, enforce value constraints, and register hooks for state changes. It works with a `Verbose.t` type backed by an integer state, supporting command-line option integration, state persistence across sessions, and customizable serialization via a `Datatype` module. Typical use cases include dynamically adjusting logging detail through CLI flags, enforcing safe value ranges, and tracking verbosity modifications in analysis tools.",
      "description_length": 605,
      "index": 3028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage sets of CIL function declarations (`Fundec.Set.t`) through command-line interfaces, enabling value assignment, state change tracking, alias handling, and customizable serialization. It supports set-like manipulations such as membership checks, iteration, folding, and predicate evaluations, while integrating with Frama-C's plugin system and project management workflows to handle dynamic configuration and persistence of function definition states.",
      "description_length": 491,
      "index": 3029,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_hashtbl-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling hash table keys, providing operations such as equality, comparison, hashing, and pretty printing. It works with the abstract type `Hashtbl.Key.t`, supporting deep copying, membership testing within projects, and type representation. Concrete use cases include managing and comparing keys in hash tables used for project-specific data storage and retrieval in Frama-C plugins.",
      "description_length": 419,
      "index": 3030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure keyed by file paths, supporting efficient lookups, insertions, and deletions. It operates on a specific data type `t` representing file path mappings, with values of a parameterized `Datatype.t`. Concrete use cases include tracking file-specific analysis results or configuration settings across different source files in static analysis tools.",
      "description_length": 383,
      "index": 3031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in map structures, providing operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as managing unique identifiers or symbolic representations in static analysis, where precise key handling is required. The module also includes functions for deep copying and checking the presence of project-specific data within keys.",
      "description_length": 412,
      "index": 3032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Names",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve and manipulate property names within the Frama-C kernel. It operates on `identified_property` values, extracting base names and generating unique identifiers. Concrete use cases include generating stable identifiers for properties during analysis or reporting, and handling name-based comparisons or lookups in static analysis tasks.",
      "description_length": 376,
      "index": 3033,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fieldinfo",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for manipulating CIL fieldinfo values, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying, membership testing, and managing structured collections. It supports precise static analysis through sets, maps, and hash tables keyed by fieldinfo, enabling ordered traversal, transformation, and aggregation of field-related data. The set module handles algebraic operations and ordered collections, the map module supports key-based associations with arbitrary data and ordered transformations, and the hash table module enables efficient imperative lookups and value associations. These components together facilitate tasks like tracking field dependencies, comparing type layouts, and extracting or transforming subsets of struct or union fields based on analysis criteria.",
      "description_length": 854,
      "index": 3034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-V",
      "library": "frama-c.kernel",
      "description": "This module defines a labeled, comparable vertex type for use in control flow graphs. It provides operations to create vertices from labels, retrieve labels from vertices, and compare, hash, or check equality of vertices. The module is used to represent control points in an abstract interpretation framework, where each vertex corresponds to a program point annotated with semantic information.",
      "description_length": 395,
      "index": 3035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Set",
      "library": "frama-c.kernel",
      "description": "This module implements hash-consed sets with ordered elements, offering standard set operations like union, intersection, and membership checks, alongside transformations such as mapping and filtering. It works with immutable sets (`Set.t`) where elements are hash-consed values (`Set.elt`) compared using a fixed ordering, enabling efficient equality checks and deterministic iteration. Designed for static analysis tasks, it supports use cases like tracking program entities (e.g., variables, expressions) with guaranteed uniqueness and fast membership queries, integrating seamlessly with Frama-C's internal state management and project-specific analyses.",
      "description_length": 658,
      "index": 3036,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement.WTO",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for representing weak topological orderings (WTOs) of CIL statements, along with operations for equality, comparison, hashing, and pretty printing. It supports working with lists of WTO values, provides deep copying, and includes predicates for checking membership based on project projections. Concrete use cases include analyzing control flow dependencies in C programs and managing iterative fixpoint computations over statement graphs.",
      "description_length": 471,
      "index": 3037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module manages configuration settings tied to file path keys, enabling dynamic updates through value hooks and customizable serialization, while providing operations to handle aliases, metadata flags (deprecation, visibility), and collection traversal. It works with key-value pairs where file paths act as identifiers, supporting use cases like command-line interface configurations that require per-file path state management and metadata-aware option parsing.",
      "description_length": 467,
      "index": 3038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_queue",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic queue type that supports dynamic instantiation with specific types, enabling the creation of monomorphic queue instances while preserving type-level metadata. It provides operations to check if a queue is instantiated with a specific type and to retrieve the original type used for instantiation. The child module builds on this by generating a fully-featured monomorphic queue for a given type, offering equality, comparison, hashing, and pretty printing, all while supporting deep copying and membership checks over structured data. Together, they enable precise queue-based tracking of typed values in static analysis plugins, such as maintaining sequences of values during program analysis or managing state with strong type guarantees.",
      "description_length": 774,
      "index": 3039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.JOIN_SEMILATTICE",
      "library": "frama-c.kernel",
      "description": "Implements a join semilattice structure with operations for combining elements using a join function that is idempotent, commutative, and associative. Works with a base type `t` representing abstract domain elements, alongside a distinguished `bottom` element that acts as the identity for join. Used in data flow analysis to merge information from different control-flow paths, where `join_and_is_included` optimizes recomputation decisions by combining join and inclusion checks.",
      "description_length": 481,
      "index": 3040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Memo",
      "library": "frama-c.kernel",
      "description": "This module provides memoization functions for various AST elements during visitor behavior processing, ensuring consistent bindings across transformations. It maps elements like variables, types, statements, and functions to their counterparts in a new project context, creating them if absent. Use cases include tracking transformed AST nodes during analysis or plugin development, ensuring referential consistency without redundant creation checks.",
      "description_length": 451,
      "index": 3041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string set data structure with operations for equality checking, comparison, hashing, and pretty printing. It provides a deep copy function and membership testing based on project values. The set is used to manage collections of string-based identifiers in a way that supports analysis project tracking and manipulation.",
      "description_length": 345,
      "index": 3042,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepBuiltinMacros",
      "library": "frama-c.kernel",
      "description": "This module controls a boolean kernel option that toggles the behavior of the `-print-machdep-builtin-macros` flag, determining how machine-dependent built-in macros are displayed during static analysis. It provides operations to set, retrieve, and observe changes to the flag's state, with support for persistence and notification hooks. The child module enhances this functionality by defining structured data types and operations for representing, comparing, and printing macro information, enabling precise manipulation and debugging of macro definitions. Together, they allow developers to customize macro output formatting and analyze platform-specific macro behavior in Gallium and later Frama-C versions.",
      "description_length": 712,
      "index": 3043,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are based on the `Data` module's type and values are instances of a field, supporting operations like equality, comparison, hashing, and pretty printing. It provides typed representations, descriptors, and project-aware membership checks for analysis purposes. Concrete use cases include modeling field-valued environments for static analysis of numerical computations and managing project-specific field data with deep copying and structural comparison.",
      "description_length": 509,
      "index": 3044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables with typed keys and values, enabling operations like insertion, lookup, iteration, and in-place transformations with custom key comparisons. It supports managing plugin configuration state through command-line parameters, with utilities for ordered traversal, memoization, and safe value extraction, such as persisting parameters across analysis phases or building type-safe caches. A child module specializes hash tables for values from a given `Data` module, supporting deep copying, project membership checks, and integration with Frama-C's plugin system, useful for caching analysis results per project. Another child module defines typed parameter keys with project-specific data, enabling structured queries and dependency tracking in Frama-C's kernel.",
      "description_length": 793,
      "index": 3045,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports managing plugin configuration options with string values, using an abstract `As_string.t` type to handle operations like value setting/retrieval, alias resolution, and validation against allowed values or function names. It facilitates command-line interface integration, state serialization, and dynamic value change hooks, particularly for scenarios requiring project-specific state management or constrained input validation. Use cases include parsing user-provided strings into validated parameters, tracking configuration changes across analysis sessions, and bridging plugin settings with Frama-C's internal state mechanisms.",
      "description_length": 652,
      "index": 3046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Funspec",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling function specifications in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `funspec` type representing C function specifications. Use cases include analyzing or transforming function contracts during static analysis, such as in Frama-C plugins.",
      "description_length": 325,
      "index": 3047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Lval_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table implementation optimized for values of type `Datatype.t`, offering efficient insertion, lookup, and iteration. It includes operations for equality checks, hashing, and pretty-printing, making it suitable for static analysis tasks like tracking memory states or variable bindings. Submodules extend its functionality with additional utilities for value manipulation and table traversal. For example, you can store and retrieve computed values, iterate over bindings, or compare entries for equality directly.",
      "description_length": 541,
      "index": 3048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintAsIs",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean state flag that controls the `-print-as-is` behavior, allowing clients to toggle, monitor, and serialize its value. It provides core operations to manipulate the flag directly, while its child module introduces a structured data type with equality, comparison, and pretty-printing capabilities for representing related values during analysis. Together, they enable precise control over output formatting, such as preserving original code structure during static analysis or transformation tasks. Use cases include registering listeners for flag changes, querying project-specific values, and ensuring consistent serialization across sessions.",
      "description_length": 672,
      "index": 3049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Based_on_map",
      "library": "frama-c.kernel",
      "description": "This module defines a monad interface based on `return`, `map`, and `flatten`, enabling structured handling of effectful computations. It works with monadic types `'a t` that support embedding values, transforming contents via functions, and collapsing nested structures. Concrete use cases include managing optional values, collections, or stateful operations where chaining and composition must preserve context.",
      "description_length": 414,
      "index": 3050,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Model",
      "library": "frama-c.kernel",
      "description": "This module represents abstract memory models as maps from bases to memory slices and offset maps, supporting operations like merging, joining, widening, and narrowing to manipulate and compare memory states. It provides data structures for ordered associations between memory keys and values, enabling precise tracking and transformation of memory regions during static analysis, with support for deep copying, membership checks, and ordered traversal. Submodules handle map and set operations for structured memory states, allowing tasks like merging symbolic execution paths, memoizing analysis results, and performing deterministic reductions over memory slices. Specific applications include binding variables to computed values, refining memory states at loop fixpoints, and integrating with static analysis plugins for deterministic processing of abstract values.",
      "description_length": 870,
      "index": 3051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Fundec_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set data structure for function declarations (`Fundec.t`) with operations for membership testing, comparison, and pretty-printing. It provides efficient set manipulation functions such as union, intersection, and difference, along with a hash-consed representation for structural equality and sharing. Concrete use cases include tracking sets of functions during static analysis and managing function-level properties across different analysis passes.",
      "description_length": 476,
      "index": 3052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-Service_graph-E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a service graph, where each edge connects two vertices and carries a label of type `Frama_c_kernel.Service_graph.edge`. It provides operations to create edges between vertices, retrieve their source and destination vertices, and access their labels. The module ensures edges are ordered and comparable, enabling precise graph construction and traversal for analyzing dependencies or flows between services in a callgraph.",
      "description_length": 462,
      "index": 3053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for managing collections of `Datatype.t` values with operations for membership, insertion, and iteration. It provides efficient functions for checking presence, adding elements, and folding over the elements of the set. Concrete use cases include tracking unique values during analysis, managing command-line option states, and ensuring canonical forms of data during transformations.",
      "description_length": 428,
      "index": 3054,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.S-G-E",
      "library": "frama-c.kernel",
      "description": "This module defines a directed edge structure for a state dependency graph, where each edge connects two states and carries a label. It provides operations to create edges with a source, destination, and label, as well as to retrieve those components from an edge. The module is used to represent and manipulate dependencies between program states, particularly in static analysis tasks involving control or data flow.",
      "description_length": 418,
      "index": 3055,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedOverflow",
      "library": "frama-c.kernel",
      "description": "This module controls a boolean configuration flag that enables or suppresses warnings for unsigned overflow behavior during static analysis in Frama-C. It provides operations to toggle the flag, register callbacks for state changes, and serialize its value, integrating directly with kernel-level services for analysis customization. The child module defines a data type `t` with functions for equality, comparison, hashing, and pretty printing, used to represent and manipulate overflow-related values in analysis workflows. Together, they support precise handling of unsigned overflow diagnostics and state management across analysis sessions.",
      "description_length": 645,
      "index": 3056,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Make_Hashconsed_Lattice_Set",
      "library": "frama-c.kernel",
      "description": "This module provides lattice operations like join, meet, and narrowing alongside set-theoretic union, intersection, and membership checks for abstract domains requiring precise value tracking. It works with hash-consed elements from an underlying module `O`, organizing them into a bounded lattice structure that represents either finite sets or an unbounded top element. Designed for static analysis tasks such as program value abstraction, it ensures efficient equality checks and avoids hashconsing conflicts when multiple modules share the same element type.",
      "description_length": 562,
      "index": 3057,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_list-Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for command-line options, providing operations to create, modify, and query named categories with associated accessors and dependencies. It works with strings, state lists, and category types to represent and manipulate option groups. Concrete use cases include setting up default and special categories like '@all' and '@none', enabling all options with specific interpretations, and dynamically adding new option categories during configuration.",
      "description_length": 490,
      "index": 3058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash-consed map structure where keys are based on the `Data` module's type and values are mapped accordingly. It provides operations for equality checking, comparison, hashing, and pretty-printing maps, along with deep copying and project-aware membership checks. It is used to manage state in a way that ensures structural sharing and efficient comparisons, particularly useful in static analysis contexts where state must be tracked and compared across different analysis phases.",
      "description_length": 506,
      "index": 3059,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.S_no_parameter",
      "library": "frama-c.kernel",
      "description": "This module defines a parameter with no associated value, offering operations to set, retrieve, and reset its state, along with hooks to monitor or react to changes. It supports boolean-like behavior through `is_default` and provides mechanisms for command-line integration, such as help printing and aliases management. Use cases include flags that trigger specific behaviors, such as enabling or disabling analysis features in plugins without requiring additional configuration data.",
      "description_length": 485,
      "index": 3060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_predicate",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with identified predicates in CIL, including equality, comparison, hashing, and pretty-printing, along with utilities for project membership checks, deep copying, and managing collections. Its set submodule supports efficient set operations and ordered traversal, enabling tasks like predicate filtering and nearest-element queries during static analysis. The map submodule associates predicate identifiers with arbitrary data, supporting functional updates and structured transformations, while the hash table submodule offers imperative storage with memoization and project-specific tracking. Together, these components enable precise manipulation and analysis of logical conditions in C code, such as verifying invariants, managing preconditions, and merging analysis results across phases.",
      "description_length": 842,
      "index": 3061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.Version",
      "library": "frama-c.kernel",
      "description": "This module provides direct access to version metadata such as the version identifier, codename, and major/minor version numbers. It works with string and integer data types to expose static version information. Concrete use cases include displaying the current Frama-C version in output messages or checking compatibility based on major and minor version numbers.",
      "description_length": 364,
      "index": 3062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic2",
      "library": "frama-c.kernel",
      "description": "This module handles instantiation and inspection of polymorphic type values with two type variables. It provides operations to create a polymorphic type from two monomorphic types, check if a type is an instance of a polymorphic schema, and retrieve the concrete types from a polymorphic instance. Concrete use cases include implementing type inference mechanisms and managing generic data structures that require two type parameters.",
      "description_length": 434,
      "index": 3063,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a collection data type with operations for equality, comparison, hashing, and pretty printing, tailored for use with command-line parameters. It supports structured data through a descriptor system, enabling deep copying and membership checks over project skeletons. Concrete use cases include managing sets of analysis options or configuration values that require robust serialization and comparison logic.",
      "description_length": 427,
      "index": 3064,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.Dot",
      "library": "frama-c.kernel",
      "description": "This module generates a Dot representation of the state dependency graph, writing it to a specified file path. It operates on the internal state dependency structures maintained by the analysis kernel. Use this module to visualize dependencies between states in the analysis, such as for debugging or reporting.",
      "description_length": 311,
      "index": 3065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection",
      "library": "frama-c.kernel",
      "description": "This module supports operations to manage and manipulate command-line parameters, including setting and retrieving values, handling update hooks, serializing data, and controlling alias visibility, while also providing collection-specific functionality like iteration, folding, and element addition. It operates on a parameter type `t` and a generic element type `elt`, leveraging modules like `As_string` and `Category` for string conversion and classification. These features are particularly useful for building command-line interfaces, managing option aliases, and implementing stateful parameter handling with dynamic updates or persistence.",
      "description_length": 646,
      "index": 3066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Instr",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL instructions, including equality, comparison, hashing, and pretty-printing. It provides utilities to inspect and manipulate instruction data types, such as checking membership within a project context and performing deep copies. Concrete use cases include analyzing or transforming C code during static analysis, such as tracking control flow or modifying assignments and function calls.",
      "description_length": 439,
      "index": 3067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Based_on_map_with_product",
      "library": "frama-c.kernel",
      "description": "This module defines a monad with operations to wrap values (`return`), transform contained values (`map`), flatten nested structures (`flatten`), and combine two monadic values into a pair (`product`). It works with monadic types `'a t` that support these operations, enabling composition of effectful computations. Concrete use cases include chaining analyses or stateful operations in static code analysis plugins where combining results from multiple passes is required.",
      "description_length": 473,
      "index": 3068,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Fold_ordered",
      "library": "frama-c.kernel",
      "description": "This module manages ordered execution of functions registered as hooks, applying them in sequence from least recently added to most recent. It supports dependency management between hooks to enforce execution order, with operations to register, extend, and clear functions. Concrete use cases include orchestrating analysis phases in a static analysis tool where specific processing steps must run in a defined order relative to each other.",
      "description_length": 440,
      "index": 3069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_set_and_map-Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations including element manipulation (add, remove, find), set algebra (union, intersection, difference), and transformations (map, filter, partition) over elements of type `elt` (equivalent to `t`). It maintains internal ordering via a comparator module and supports bidirectional conversions with lists/sequences, nearest-neighbor queries, and type introspection features. Use cases include static analysis tasks requiring ordered collection processing, project membership validation, and integration with Frama-C's datatype system for structured data manipulation.",
      "description_length": 604,
      "index": 3070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling lists of strings with deep copy, equality, comparison, and pretty-printing operations. It supports storage and manipulation of string lists in Frama-C's plugin system, enabling use cases like tracking sets of identifiers or paths across analysis sessions. The type `t` represents string lists with associated metadata, and operations ensure proper handling within Frama-C's project management and dataflow analysis frameworks.",
      "description_length": 473,
      "index": 3071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Based_on_bind_with_product",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operations including `return`, `bind`, and `product`, enabling composition of effectful computations that carry values within a monadic context. It works with monadic types `'a t`, supporting the combination of two monadic values into a single one holding their paired results. Concrete use cases include sequencing analysis steps in static analysis plugins where state or side conditions must be tracked alongside computed values.",
      "description_length": 459,
      "index": 3072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a map structure, including operations for equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing key values, checking membership based on project properties, and creating deep copies of key instances. The type `t` represents the key values, while functions like `equal`, `compare`, and `pretty` enable precise manipulation and inspection of these keys.",
      "description_length": 460,
      "index": 3073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_info.Function",
      "library": "frama-c.kernel",
      "description": "This module provides functions to inspect and analyze CIL function structures, including retrieving formal arguments, checking variable roles (formal, local, or static), and accessing function metadata like name, ID, and definition status. It operates on CIL types such as `cil_function`, `fundec`, and `varinfo`, enabling precise queries on function prototypes and variable relationships. Concrete use cases include static analysis passes that require identifying function parameters, determining variable scope, or distinguishing function definitions from declarations.",
      "description_length": 571,
      "index": 3074,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option groups, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to a collection's elements and supports setting accessors and dependencies for each category. Concrete use cases include organizing plugin options into logical groups and controlling default and global behavior through category activation and aliasing.",
      "description_length": 460,
      "index": 3075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PointerDowncast",
      "library": "frama-c.kernel",
      "description": "This module configures and monitors a boolean setting that controls warnings for pointer downcast operations during static analysis, working with boolean values and integrating project-specific state management. It defines a data type `t` for managing structured values, supporting operations like equality checking, comparison, hashing, pretty-printing, and deep copying, along with type and project descriptors. The module enables precise tracking and manipulation of pointer downcast warnings, including their type information and project context. Use cases include enforcing or suppressing diagnostic messages when converting pointers to more specific types in the analysis pipeline.",
      "description_length": 687,
      "index": 3076,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Type",
      "library": "frama-c.kernel",
      "description": "This module unifies the construction and conversion of C and logic types into a parameterized representation, bridging OCaml and CIL type systems. It handles primitive C types (e.g., integers, floats), composite structures (pointers, arrays, structs), and qualifiers (const, attributes), while abstracting away location requirements. Its operations simplify type manipulation for use cases like expression building and logic-specific transformations, using \"prime\" types for low-level control and \"harden\" functions to unwrap polymorphic variants.",
      "description_length": 547,
      "index": 3077,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash-consed map key type with standard comparison, equality, and hashing operations. It supports structured data types through type descriptors and provides deep copying, pretty printing, and project membership checks. Concrete use cases include managing state keys in static analysis plugins where structural equality and efficient lookups are required.",
      "description_length": 376,
      "index": 3078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_list",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and manipulation of monomorphic list types from polymorphic ones, using type representations like `poly` and `Type.t` to support type instantiation, checking, and parameter extraction. It provides core operations for constructing typed lists and inspecting their structure, particularly for use in static analysis and Frama-C kernel extensions. The child module builds concrete list types from element modules, offering equality, comparison, and pretty printing, while supporting deep copying and membership checks over analysis data. Together, they facilitate working with typed list structures across different analysis phases and plugins.",
      "description_length": 674,
      "index": 3079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type for values that can be converted to and from strings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a polymorphic type `t` and includes utilities for deep copying, checking project membership, and maintaining a list of representative values. Concrete use cases include implementing command-line parameters that require structured value parsing and display, such as enum-like options or complex configuration settings.",
      "description_length": 503,
      "index": 3080,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make",
      "library": "frama-c.kernel",
      "description": "This module combines two monads into a single structure that supports return, map, bind, and flatten operations, enabling compositions like State over Option by requiring a swap function to reorder nested layers. It provides core monadic functionality while its child modules extend it with conditional execution, option and list processing, and infix operators for sequencing and transforming combined monadic computations. Main data types include monadic values of type `t` and functions like `only_if`, `map`, `iter`, and operators such as `>>-` and `let*`. Examples include selectively running stateful operations, processing optional or list-based data with monadic effects, and composing State and Option to build error-tolerant, stateful pipelines.",
      "description_length": 755,
      "index": 3081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Fundec_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for function declarations (`Fundec.t`) with operations for membership, comparison, and pretty-printing. It supports efficient set manipulations such as union, intersection, and iteration over collections of function declarations. Concrete use cases include tracking analyzed functions, managing call graphs, or filtering functions based on properties like reachability or side effects.",
      "description_length": 429,
      "index": 3082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.With_Under_Approximation",
      "library": "frama-c.kernel",
      "description": "This module provides operations for under-approximating union and intersection on lattice elements that do not include a bottom element. It works with lattice values of type `t`, where operations return `Bottom` in place of a bottom element when necessary. Concrete use cases include static analysis domains where under-approximations of set unions and intersections are used to model possible program behaviors with limited precision.",
      "description_length": 435,
      "index": 3083,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Set",
      "library": "frama-c.kernel",
      "description": "The module provides operations for managing ordered sets of normalized filepaths, including set algebra (union, intersection, difference), element insertion/removal, membership checks, and property queries (cardinality, min/max). It supports transformations via mapping, filtering, and folding, along with ordered iteration, sequence conversion, and project-aware membership checks, enabling efficient analysis of file path collections and integration with Frama-C's internal systems through type descriptors and deep-copy functionality.",
      "description_length": 537,
      "index": 3084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int",
      "library": "frama-c.kernel",
      "description": "This module defines an integer type with standard operations like equality, comparison, and hashing, tailored for Frama-c's type system with support for deep copies and project-based membership checks. Its submodules Set, Map, and Hashtbl provide efficient, type-safe collections: sets for ordered integer manipulation and nearest-element queries, maps for ordered key-value associations, and hash tables for cache-efficient lookups and memoization with customizable keys and values. You can use it to implement static analysis plugins that track integer-indexed data, manage persistent mappings, or perform precise set algebra with ordered traversal. Examples include analysis state caches, program point indexing, and integer set-based constraint representations.",
      "description_length": 765,
      "index": 3085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_real",
      "library": "frama-c.kernel",
      "description": "This module handles logic real numbers in CIL with operations for equality, comparison, hashing, and pretty-printing, along with standard data structures for managing these values. It includes a hash table module for deterministic, efficient key-based storage and retrieval of logic real values, supporting memoization and traversal, and a map module offering functional, ordered key-value associations with comprehensive manipulation utilities. The key module under both submodules defines precise equality, comparison, and hashing for logic real identifiers, enabling exact value tracking and efficient lookups in static analysis. Example uses include analyzing floating-point constants in C code, caching intermediate analysis results, and managing numerical constraints during symbolic reasoning.",
      "description_length": 800,
      "index": 3086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Int",
      "library": "frama-c.kernel",
      "description": "This module provides core utilities for working with integers as keys in various data structures, combining ordered maps, persistent sets, and imperative hash tables into a unified interface for precise manipulation and traversal. It defines key operations such as comparison, hashing, and pretty printing across integer-like keys, enabling efficient lookups, transformations, and aggregations in both functional and imperative contexts. With support for bounded search, ordered iteration, memoization, and set algebra, it facilitates tasks like static analysis, abstract interpretation, and program state tracking where strict key ordering and performance are critical. Submodules refine these capabilities for specific use cases, offering optimized structures and domain-aware operations tailored to symbolic analysis and lattice computations.",
      "description_length": 845,
      "index": 3087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating sets of parameters within a plugin, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with the `Category.t` type, which represents a parameter category, and interacts with `Frama_c_kernel.State.t` lists to define dependencies. Concrete use cases include setting up configurable parameter groups like `@default` or `@all`, enabling bulk configuration changes, and defining how parameters are interpreted in different analysis contexts.",
      "description_length": 571,
      "index": 3088,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for type representation, comparison, hashing, and pretty-printing. It works with structured values involving projects, descriptors, and type information. It is used to manage and manipulate complex data types in static analysis plugins, enabling deep copies, project membership checks, and consistent serialization.",
      "description_length": 362,
      "index": 3089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Zero_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a reference to an integer initialized to zero, offering operations to get, set, reset, and finalize its value, along with hook registration and custom serialization. It supports per-project state tracking and is integrated with Frama-C's state system for analysis and stabilization workflows. The child module enhances it with equality checks, comparison, hashing, pretty-printing, and deep copying, enabling robust manipulation of zero-initialized integer references. Together, they facilitate precise, modular state management for static analysis tasks.",
      "description_length": 587,
      "index": 3090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.ReadAnnot",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean option that controls annotation handling during static analysis, integrating directly with command-line parsing and project state. It provides operations to set values, trigger change hooks, serialize, and define aliases, enabling dynamic control via the `-read-annot` flag. The core type `t` supports equality, comparison, hashing, and pretty-printing, facilitating structured annotation management and efficient lookups. Use cases include enabling annotation processing at runtime and comparing or copying parsed annotation data during analysis.",
      "description_length": 577,
      "index": 3091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer.PrinterClass",
      "library": "frama-c.kernel",
      "description": "Defines operations for customizing and extending the pretty-printing of abstract syntax trees (ASTs). It works with AST nodes and formatting contexts to enable precise control over output representation. Used to implement language-specific or context-sensitive pretty-printing rules, such as generating valid C code or debugging-friendly AST dumps.",
      "description_length": 348,
      "index": 3092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Tag",
      "library": "frama-c.kernel",
      "description": "Handles the association of unique string identifiers to source code elements for precise pretty-printing. Works with `localizable` types from the AST to generate tags that map printed output back to their original source locations. Enables accurate source reconstruction and navigation in analysis tools.",
      "description_length": 304,
      "index": 3093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for handling multiple kernel functions with a shared parameter configuration. It supports operations to create, update, and query mappings between function identifiers and their associated parameter values, ensuring consistency across different function instances. The map is designed for use in static analysis contexts where parameters must be applied selectively to different functions based on project-specific criteria.",
      "description_length": 463,
      "index": 3094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Weak",
      "library": "frama-c.kernel",
      "description": "This module implements a weak hash table for managing values of type `W.t` with custom equality, comparison, and serialization. It supports operations like `equal`, `compare`, `hash`, and `pretty` for value manipulation and inspection, along with `mem_project` to check properties over embedded project values. It is used to store and manage data that must be associated with Frama-C projects, allowing efficient lookups and deep copies without shared references.",
      "description_length": 463,
      "index": 3095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling keys in a hash table, including equality, comparison, hashing, and pretty-printing. It supports concrete use cases like efficient key lookup, set membership testing, and project-based filtering using `mem_project`. The type `t` represents hash table keys, with functions to inspect, compare, and manipulate them in a purely functional manner.",
      "description_length": 402,
      "index": 3096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SymbolicPath",
      "library": "frama-c.kernel",
      "description": "This module manages symbolic path mappings as key-value associations between filepaths and identifiers, supporting operations to add, query, and manipulate entries with visibility and deprecation controls. It provides data types for symbolic paths with equality, comparison, and pretty-printing, along with mechanisms to handle command-line updates, project-based values, and category classifications such as `@none`, `@default`, and `@all`. Users can configure path aliases, perform analysis-specific path resolution, and integrate custom logic into Frama-C's project structure and command-line workflows. Submodules enhance these capabilities by enabling typed manipulation, validation, and category-based behavior control for symbolic paths.",
      "description_length": 744,
      "index": 3097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S_with_product",
      "library": "frama-c.kernel",
      "description": "This module defines a monadic interface with a product operation, enabling the combination of two independent monadic computations into a single one. It supports data types like `option`, `list`, and custom monadic structures, allowing operations such as `bind`, `map`, and `product` to handle sequencing and parallel composition. Concrete use cases include managing concurrent computations, combining error-handling contexts, and structuring complex data flows with deterministic merging of results.",
      "description_length": 500,
      "index": 3098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Validity",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and querying the validity of memory zones in a program analysis context. It provides equality, comparison, hashing, and pretty-printing functions for validity values, along with deep copying and membership testing over project-specific data. These functions support precise tracking and manipulation of memory state during static analysis, particularly in scenarios involving abstract interpretation or value analysis.",
      "description_length": 462,
      "index": 3099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Automaton",
      "library": "frama-c.kernel",
      "description": "This module defines the core data structure for representing interpreted automata, including states, transitions, guards, and actions. It provides operations for equality checking, comparison, hashing, and pretty-printing automata, along with deep copying and project membership testing. Concrete use cases include modeling control flow graphs for abstract interpretation and tracking program behaviors through guarded transitions and associated actions.",
      "description_length": 454,
      "index": 3100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for grouping and controlling command-line parameters. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with their behaviors and dependencies. Use cases include organizing plugin options and controlling parameter activation through predefined categories.",
      "description_length": 348,
      "index": 3101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based operations on maps and sets, where maps associate keys with values and sets are treated as maps binding keys to a top element. It supports approximation operations like union (`join`), intersection (`meet`), and inclusion checks (`is_included`), alongside standard manipulations such as filtering, mapping, and folding, all adhering to lattice semantics. These structures are particularly useful in static analysis for abstract interpretation, enabling precise yet efficient approximations of data flow and set relationships in program analysis tasks.",
      "description_length": 586,
      "index": 3102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Permissive",
      "library": "frama-c.kernel",
      "description": "This module controls a boolean kernel option that adjusts permissive behavior, allowing dynamic leniency in input handling during analysis. It provides operations to set, query, and monitor changes to the option's state, integrating with command-line interfaces through customizable aliases, help messages, and serialization. The module's data type `t` supports equality, comparison, hashing, and pretty-printing, along with deep copying and introspection via descriptors and `mem_project` checks. These features enable robust manipulation and inspection of abstract data tied to permissive mode across different analysis contexts.",
      "description_length": 631,
      "index": 3103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Debug",
      "library": "frama-c.kernel",
      "description": "This module manages integer-based debug states with dynamic configurability, supporting hooks for change tracking, command-line integration, and project-specific persistence. It provides operations to manipulate bounded integer parameters, enforce valid ranges, and customize serialization, while enabling callbacks for state updates and default value management. Typical use cases include fine-grained control over plugin debugging levels, trace output configuration, and persistent storage of analysis settings across sessions.",
      "description_length": 529,
      "index": 3104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Reset",
      "library": "frama-c.kernel",
      "description": "This module provides functions to reset internal tables associated with specific AST element types in a visitor behavior, such as variables, statements, function definitions, and type information. Each function (e.g., `varinfo`, `stmt`, `fundec`) clears data tied to its corresponding AST element type, ensuring clean state for repeated visitor transformations. It is useful when reusing visitor instances across multiple analysis or transformation passes.",
      "description_length": 456,
      "index": 3105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations like insertion, deletion, and in-place modification alongside functional transformations via iteration and folding over key-value pairs. It operates on hashtables with keys of a specialized type (aliased as `key`) and arbitrary values, supporting conversions to sequences, sorted traversal, and integration with structural type systems. These capabilities are particularly useful for memoization, deterministic processing of memory maps, and safe key-based queries in static analysis contexts.",
      "description_length": 547,
      "index": 3106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyTrivialLoops",
      "library": "frama-c.kernel",
      "description": "This module controls loop simplification behavior in static analysis through a boolean flag, with functions to enable or disable the feature via direct calls or command-line integration. It interacts with Frama-C's project state system to persist configuration and optimize analysis precision by collapsing trivial loops. A child module defines the core data type `t` with equality, comparison, and hashing operations, along with utilities for deep copying and project membership checks, ensuring consistent internal state during loop transformations. These components together support precise and configurable loop simplification during code processing.",
      "description_length": 654,
      "index": 3107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Fold",
      "library": "frama-c.kernel",
      "description": "This module performs fold operations over tables of specific AST element types in a visitor behavior, such as variables, structures, statements, and logic types. Each function applies a given accumulator function to pairs of original and transformed AST elements, enabling traversal and aggregation across registered elements. It is used to analyze or transform CIL AST components during static analysis, such as tracking variable modifications or statement changes.",
      "description_length": 466,
      "index": 3108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Session",
      "library": "frama-c.kernel",
      "description": "This module manages file paths within a plugin's session directory, providing functions to retrieve or create directories and files relative to that session context. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing plugins to store and access session-specific data. Concrete use cases include saving temporary analysis results, caching plugin-specific configurations, or logging session-specific outputs during static analysis.",
      "description_length": 459,
      "index": 3109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make_pp",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations that convert CIL and ACSL data structures\u2014including expressions, statements, logic predicates, function specifications, and control-flow constructs\u2014into human-readable strings using OCaml's formatter. It handles core CIL types like variables, allocations, and loop annotations, as well as kernel-specific constructs such as behaviors and logic labels, with formatting options to control output details like brace visibility and annotation suppression. The functionality is primarily used for debugging, logging, and visualizing abstract syntax trees or analysis results during static code verification.",
      "description_length": 650,
      "index": 3110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Empty_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for empty string parameters, providing operations to define, parse, and manage such options. It works with the `t` type and interacts with `Datatype.t` for equality, comparison, hashing, and pretty printing. Concrete use cases include setting up configurable options in Frama-C plugins that accept empty string values through the command line.",
      "description_length": 395,
      "index": 3111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Model_info",
      "library": "frama-c.kernel",
      "description": "This module manages and manipulates analysis model data in CIL, centering on `model_info` values with core operations for equality, comparison, copying, and structured output. It supports hierarchical organization through map-like structures with predicate-based lookups, efficient aggregation via sequences, and project-aware transformations. Hash tables enable type-safe, efficient storage and retrieval of CIL-based values, while set operations maintain ordered collections with standard set-theoretic and nearest-element capabilities. These tools collectively support static analysis plugins by enabling precise tracking, transformation, and querying of model data throughout verification workflows.",
      "description_length": 703,
      "index": 3112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnspecifiedAccess",
      "library": "frama-c.kernel",
      "description": "This module manages a global boolean state that controls how unspecified memory accesses are handled during static analysis, with support for enabling or disabling the behavior via programmatic flags and integration with Frama-C's configuration system. It provides direct operations to set, track, and serialize the state, while its child module introduces a data type `t` for fine-grained manipulation of memory access semantics, including comparison, pretty-printing, and project-aware inspection. Together, they enable dynamic control of analysis rules and precise handling of memory access events based on project-specific contexts. For example, users can toggle the `-unspecified-access` behavior at runtime or inspect memory access data structures during analysis passes.",
      "description_length": 777,
      "index": 3113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsGenerate",
      "library": "frama-c.kernel",
      "description": "This module manages a configuration flag that controls assembly contract generation, enabling tools to conditionally include formal contracts in generated assembly code based on user settings. It provides functions to set, query, and observe changes to the flag, and integrates with command-line parsing and project serialization for persistence. The module also includes a data type `t` with operations for equality, comparison, and pretty-printing, used to represent and manipulate contract-related structures during analysis. These values support deep copying, membership checks, and type introspection, facilitating precise contract handling when the `-asm-contracts` option is enabled.",
      "description_length": 690,
      "index": 3114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_constant",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with logic constants in CIL, including equality, comparison, hashing, and pretty-printing, centered around the `logic_constant` type. It supports static analysis tasks such as constraint propagation, symbolic execution, and state merging by enabling precise manipulation of logical expressions. The module is extended by set and map abstractions that offer ordered traversal, functional and imperative updates, and efficient lookups, all tailored for analysis plugins requiring accurate logic constant handling. Hash tables and ordered sets facilitate efficient storage, transformation, and querying of logic constant environments with support for project-aware operations and custom ordering.",
      "description_length": 742,
      "index": 3115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enuminfo",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific hashtable mapping enum declarations to metadata, enabling AST differencing workflows with keyed lookups, insertion, removal, iteration, and change hooks. It supports custom marshaling, versioned mapping memoization, and tracks enum evolution across project versions. The child module enhances this by providing abstract value manipulation for computing project diffs, supporting equality, comparison, hashing, and pretty-printing of values. Together, they enable dynamic reaction to structural changes and deep analysis of enum correspondences across AST versions.",
      "description_length": 603,
      "index": 3116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.PredicateStructEq",
      "library": "frama-c.kernel",
      "description": "This module provides structural equality and comparison operations for CIL predicates, enabling precise manipulation and analysis of logical assertions in C code. It includes core functions like `equal`, `compare`, `hash`, and `pretty`, along with support for deep copying, project-based membership testing, and standard collection interfaces (Set, Map, Hashtbl). The set module supports canonical representation and algebraic operations on structurally equivalent predicates, useful for constraint simplification and path-sensitive analysis. The hash table and map modules enable efficient key-based data management with structured traversal, filtering, and deterministic iteration, suitable for aggregating and transforming analysis results in Frama-C plugins.",
      "description_length": 762,
      "index": 3117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rangemap.S",
      "library": "frama-c.kernel",
      "description": "This module offers purely functional maps with ordered keys, supporting operations like insertion, lookup, traversal, and filtering while maintaining balanced binary tree structures with cached hashes for efficient equality checks. It works with polymorphic key-value pairs, enabling introspection through structural descriptions and project-aware membership tests that account for contextual shadowing of bindings. The combined traversal functions allow pairwise comparison or merging of two maps in key order, making it suitable for scenarios requiring incremental updates, serialization, or diff-based analysis in structured environments like program analysis frameworks.",
      "description_length": 674,
      "index": 3118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filter.F",
      "library": "frama-c.kernel",
      "description": "This module provides the `build_cil_file` function, which constructs a new CIL file from an existing one by applying filtering logic defined in the `Info` submodule. It operates on CIL projects and transformation parameters, enabling selective inclusion or exclusion of code elements such as functions or statements. A concrete use case is generating sliced versions of a C project where only specific functions or paths are retained for analysis or transformation purposes.",
      "description_length": 474,
      "index": 3119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Hptset",
      "library": "frama-c.kernel",
      "description": "This module provides set-like operations for managing collections of elements with lattice semantics, supporting standard manipulations such as membership testing, insertion, deletion, union, intersection, and difference, alongside iteration and folding over elements. It works with an abstract data type `t` parameterized by element type `elt`, incorporating introspection via type descriptors, comparison, hashing, and project-aware membership checks, while enabling conversion to lists and structured pretty-printing. Designed for static analysis frameworks, it facilitates abstract interpretation tasks requiring precise set-based dataflow computations and semantic-aware element tracking.",
      "description_length": 693,
      "index": 3120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Float",
      "library": "frama-c.kernel",
      "description": "This module provides operations to define and manage floating-point command-line parameters with support for value validation, range constraints, and dynamic state updates. It works with `float` values and structured metadata to handle default values, help documentation, and project-specific serialization, while enabling callbacks for value changes and alias management. It is particularly useful for configuring numerical settings that require bounds checking, such as simulation tolerances or resource limits, and integrates with state-tracking workflows in analysis tools.",
      "description_length": 577,
      "index": 3121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Intersects",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations with support for intersection checks. Works with lattice elements of type `t`, enabling precise analysis of value ranges or program states. Useful for static analysis tasks like determining overlapping memory regions or feasible execution paths.",
      "description_length": 275,
      "index": 3122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where each entry's value conforms to the provided `Data` module's type. It supports standard operations like equality checking, comparison, hashing, and pretty-printing, along with deep copying and project membership testing via `mem_project`. It is suitable for managing collections of structured values that require persistence, comparison, or display within a Frama-C plugin context.",
      "description_length": 431,
      "index": 3123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.List",
      "library": "frama-c.kernel",
      "description": "This module extends standard list operations to support monadic behavior for non-deterministic computations. It provides key functions like `iter`, `map`, and `fold_left`, which chain list-producing actions over list inputs, accumulating possible outcomes. Use it to model branching logic where each step can yield multiple results, such as symbolic execution paths or combinatorial search.",
      "description_length": 390,
      "index": 3124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with strings, state lists, and category accessors to establish named categories with dependencies and access behavior. Concrete use cases include setting up option groups that can be enabled or disabled together, controlling default behavior, and defining global (`@all`) interpretation rules for option processing.",
      "description_length": 500,
      "index": 3125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-WTO",
      "library": "frama-c.kernel",
      "description": "Implements algorithms for constructing and manipulating weak topological orderings (WTOs) of control flow graphs using Bourdoncle's approach. It provides functions to partition a graph into strongly connected components with a given priority order, compare and print these partitions and components. This supports abstract interpretation by enabling efficient traversal strategies for fixed-point computations.",
      "description_length": 410,
      "index": 3126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure categories such as '@none', '@default', and '@all'. It works with category types and state lists, allowing the association of accessors and dependencies with named categories. Concrete use cases include enabling all options under a category, setting a default category behavior, or defining how '@all' should be interpreted in the presence of positive or negative flags.",
      "description_length": 494,
      "index": 3127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map specialized for kernel functions, providing operations to manage and manipulate function-specific data within Frama-C's analysis framework. It supports key operations like equality checks, comparison, hashing, and pretty-printing, tailored for kernel-level function representations. Concrete use cases include tracking function properties, caching analysis results, and enabling modular reasoning over C functions during static analysis.",
      "description_length": 466,
      "index": 3128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-False-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete data type with support for equality, comparison, hashing, and pretty-printing operations. It manages structured values through a descriptor and provides deep copying and project membership checks. Use it to represent and manipulate complex, project-associated data within static analysis plugins.",
      "description_length": 327,
      "index": 3129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_collections",
      "library": "frama-c.kernel",
      "description": "This module builds a comparable data type with full equality, comparison, hashing, and pretty printing support from an input module X, and generates optimized collection modules for structured data manipulation. It provides core operations for type-driven value comparison and transformation, enabling tasks like deep copying, filtering, and representation inspection. The associated Set and Map modules implement efficient ordered collections and persistent maps with functional updates, supporting operations like union, intersection, ordered traversal, and key-based memoization. You can use it to create type-safe, comparable data structures, build symbol tables with custom keys, or track abstract states in static analysis with precise ordering and structural comparison.",
      "description_length": 777,
      "index": 3130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make",
      "library": "frama-c.kernel",
      "description": "This module builds efficient map structures over hash-consed tree keys, using Patricia trees to enable fast insertion, deletion, and traversal while supporting advanced operations like customizable merging, subtree manipulation, and heterogeneous comparisons. It provides a core map type alongside three submodules: one for ordered sets of tree keys with union and intersection operations, another for specialized map structures optimized for static analysis tasks like tracking AST-node-indexed states, and a third for imperative hash tables with in-place updates and structured iteration. Together, they allow working with large, complex key domains through bitwise decomposition and persistent state, enabling use cases such as program dependency tracking, constraint propagation, and memoization of analysis results. Example workflows include mapping abstract syntax trees to annotations, managing dynamic compiler optimizations, and performing cached transformations over structured keys.",
      "description_length": 993,
      "index": 3131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Set_orig",
      "library": "frama-c.kernel",
      "description": "This module defines operations to update the original representative of various AST elements during visitor traversal. It provides functions like `varinfo`, `compinfo`, and `stmt` that associate a new original reference with a given AST node in the visitor state. These are used when transforming or tracking changes in the AST structure, such as during code rewriting or analysis passes.",
      "description_length": 388,
      "index": 3132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typeinfo",
      "library": "frama-c.kernel",
      "description": "This module handles type information in CIL with operations for equality, comparison, hashing, and pretty-printing of `typeinfo` values, supporting deep copies, membership checks, and structured management of type data through sets, maps, and hash tables. Its submodules provide specialized containers: one for ordered maps with advanced traversal and transformation capabilities, another for efficient hash tables integrating key and data operations, and a third for algebraic set manipulations with ordered elements and filtering. These components enable tasks like merging CIL type definitions, tracking type hierarchies across translation units, and enforcing type constraints during static analysis. Specific uses include generating type summaries, resolving type aliases, and comparing type structures in Frama-C plugins.",
      "description_length": 827,
      "index": 3133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEq",
      "library": "frama-c.kernel",
      "description": "This module provides structural equality, comparison, and hashing for CIL offset values, enabling precise manipulation and analysis of C structure layouts. It includes Set, Map, and Hashtbl submodules tailored for working with these offsets, supporting efficient storage, lookup, and ordered traversal. With these tools, users can perform tasks like tracking field accesses, resolving offset relationships, or memoizing analysis results in Frama-C plugins. Example uses include optimizing memory layouts, verifying struct transformations, and associating annotations with precise memory positions in CIL code.",
      "description_length": 609,
      "index": 3134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for plugin parameters, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with the `Category.t` type, which wraps parameter categories, and uses accessors to link categories with states. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a specific interpretation, and defining dependencies between categories and plugin states.",
      "description_length": 477,
      "index": 3135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition.Axiom",
      "library": "frama-c.kernel",
      "description": "This module defines a set of operations for composing monads by providing a mechanism to swap the order of nested monadic structures. It works with any two monads, specifically referred to as the interior and exterior monads, allowing the transformation of values from a composition of exterior followed by interior to interior followed by exterior. A concrete use case is combining the State and Option monads to model stateful computations that may fail, where the swap function enables correct monadic composition without rewriting existing operations.",
      "description_length": 555,
      "index": 3136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes and extends map operations for alarm-related data, combining core associative map functionalities with specialized submodules for key and value handling. It supports key-value maps with ordered bindings, allowing insertion, deletion, merging, bidirectional traversal, and predicate-based queries. The first submodule provides value-specific operations like comparison, equality, and pretty-printing for alarm data, enabling persistent manipulation and cross-project state management. The second submodule defines structured key operations, including introspection and project-based filtering, ensuring efficient and meaningful access to alarm entries.",
      "description_length": 673,
      "index": 3137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, enable, and modify parameter categories with specific accessors and dependencies. It works with strings, state lists, and category types to structure how parameters are grouped and interpreted. Concrete use cases include setting up the `@all` category to control global parameter behavior and linking categories to specific command-line flags through accessors.",
      "description_length": 453,
      "index": 3138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.Option",
      "library": "frama-c.kernel",
      "description": "This module extends the option type with monadic operations compatible with the list monad, enabling non-deterministic computations. It provides `iter` to apply a function to an option value and `map` to transform an option value, both returning list-wrapped results. Use it to chain computations where an option may produce multiple outcomes represented as lists.",
      "description_length": 364,
      "index": 3139,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RightShiftNegative",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration of a boolean flag that controls whether warnings are generated for right shifts on negative integers. It provides operations to set, query, and monitor changes to the flag, influencing compiler diagnostics during static analysis of C code that may depend on implementation-defined shift behavior. The associated child module defines a data type representing the possible states of this warning behavior, along with utilities for equality, comparison, pretty-printing, and deep copying. Together, they enable precise control and introspection of warning settings for negative integer shifts within Frama-C's analysis framework.",
      "description_length": 664,
      "index": 3140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-VTable",
      "library": "frama-c.kernel",
      "description": "This module provides a hash table structure for associating vertices in a control flow graph with arbitrary data, supporting efficient insertion, lookup, and transformation of key-value pairs. It includes operations for ordered traversal using custom comparators, filtering entries, and computing statistics, which are particularly useful for analyzing or transforming program states during abstract interpretation. The structure is optimized for scenarios requiring memoization, default value handling, and deterministic iteration over control points in an interpreted automaton.",
      "description_length": 580,
      "index": 3141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdep",
      "library": "frama-c.kernel",
      "description": "This module controls a boolean kernel option that enables or disables the printing of machine-dependent information during analysis, with support for toggling, persistence, and change handling. It manages a mutable flag scoped to projects, allowing fine-grained control over low-level output details in static analysis workflows. The associated data type `t` provides comparison, hashing, and pretty-printing operations for representing and manipulating machine-dependent values, with utilities to check project membership and manage deep copies. Together, they enable use cases such as selectively suppressing architecture-specific details or inspecting data type representations in Frama-C's output.",
      "description_length": 701,
      "index": 3142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Ref",
      "library": "frama-c.kernel",
      "description": "This module provides state references with versioning and serialization control for a specific data type, allowing get, set, and clear operations, update hooks, and custom marshaling. Its child module introduces a reference-based datatype that supports equality, comparison, hashing, and pretty-printing, wrapping a reference to the main data type. Together, they enable managing versioned state with fine-grained control over updates and serialization, such as tracking changes across project versions or persisting structured data. Example uses include maintaining stateful analysis results with versioned snapshots and defining custom serialization for complex data structures.",
      "description_length": 680,
      "index": 3143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_sig.S",
      "library": "frama-c.kernel",
      "description": "The module provides operations for creating, manipulating, and querying offset maps\u2014data structures that map intervals of offsets to arbitrary values\u2014supporting directional traversal, value transformations, and set operations. It handles abstract interpretation tasks like joining, widening, and range-based analysis, commonly used in static analysis for memory modeling and cache management, while offering utilities for slicing intervals, verifying cardinality constraints, and managing validity states.",
      "description_length": 505,
      "index": 3144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module manages a map of filepath-indexed values with operations to set, retrieve, and monitor changes, including hooks for pre/post updates, default value handling, and command-line option integration. It operates on `Fc_Filepath.Map.t` (key-value pairs) and supports serialization, equality checks, and standard map manipulations like `add`, `find`, and `fold`. It is suited for configuration management, tracking file-associated metadata, or maintaining project-specific state with dynamic updates and validation via hooks.",
      "description_length": 530,
      "index": 3145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages plugin-specific configuration directories and files within Frama-C. It provides operations to retrieve or create directories and files, set or query the user directory, and check if the user directory has been set. Use cases include storing and accessing plugin-specific settings or persistent data during analysis.",
      "description_length": 335,
      "index": 3146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-keyed map for handling multiple values per key, supporting operations like insertion, lookup, and iteration. It works with string keys and abstract data type values that conform to the `Datatype` signature, ensuring proper equality, comparison, and copying. Concrete use cases include managing command-line options with multiple string arguments and tracking analysis configurations across different project contexts.",
      "description_length": 449,
      "index": 3147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic3",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic type values with three type parameters, supporting type instantiation and inspection. It provides operations to create a polymorphic type from three monomorphic types, check if a type is an instance of such a polymorphic type, and retrieve the concrete type arguments from an instantiated polymorphic type. Concrete use cases include modeling and manipulating ML types with three type variables in static analysis plugins.",
      "description_length": 457,
      "index": 3148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Constfold",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean flag that controls constant folding optimizations in the analysis kernel, allowing the state to be toggled and monitored through callbacks. It works with the child module's `t` type, which represents constant-folded values with operations for comparison, copying, and project-based membership checks. Together, they enable dynamic control of optimization passes and structured manipulation of constant expressions during static analysis. Example use cases include activating folding optimizations selectively and tracking changes to analysis values tied to specific projects.",
      "description_length": 605,
      "index": 3149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based plugin parameters, including value setting/retrieval, alias handling, state persistence, and validation through allowed value lists or function name checks. It works with strings and string lists, supporting use cases like configuring plugin options with restricted values or validating identifiers against specific patterns. The module enables dynamic parameter updates via hooks and enforces constraints for robust option parsing in plugin development.",
      "description_length": 512,
      "index": 3150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ConstantStrict",
      "library": "frama-c.kernel",
      "description": "This module enables strict comparison of CIL constants by incorporating textual representation into equality checks, providing core data types and utilities for precise static analysis. It supports ordered sets and maps for managing collections of constants with lexical-based ordering, allowing operations like union, intersection, nearest-element queries, and deterministic merging. Imperative hash tables facilitate efficient key-value storage and traversal under strict equality, ideal for memoization and compiler optimizations. Examples include tracking constant ranges, validating exact C constant suffixes, and analyzing CIL expressions with strict equivalence constraints.",
      "description_length": 681,
      "index": 3151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Label",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL labels, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and project-aware membership checks. It supports the management of labels through sets, maps, and hash tables, enabling efficient data organization and retrieval during static analysis of C code. The associated map module allows ordered, polymorphic label-keyed data structures with transformations and extremal key operations, while the hash table variant offers imperative and functional mappings with deterministic traversal and safe lookups. These components collectively support tasks like tracking label metadata, memoizing analysis results, and manipulating control flow graphs using ordered sets and maps of labels.",
      "description_length": 789,
      "index": 3152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash tables designed for state-compliant mutable keys, enabling creation, lookup, in-place updates, and ordered traversal of entries. It centers around parameterized `t` structures mapping `State.t` keys to arbitrary values, supporting efficient memoization, caching, and conversion to sequences. The key module defines operations for equality, comparison, hashing, and pretty-printing of keys, facilitating precise management and querying of state keys in static analysis plugins. A specialized hash table module further extends functionality by supporting arbitrary data types with deep copies and project-aware comparisons, enabling robust handling of analysis results and metadata across different project versions or configurations.",
      "description_length": 769,
      "index": 3153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Option_ref-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements state builders for optional references, enabling the creation and manipulation of mutable state within Frama-C plugins. It provides operations for defining, comparing, hashing, and pretty-printing optional reference values, along with deep copying and project membership checks. It is used to manage optional data structures that can be embedded into Frama-C's global state, such as analysis results that may or may not be present.",
      "description_length": 454,
      "index": 3154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Debug",
      "library": "frama-c.kernel",
      "description": "This module enables managing debug integer parameters through operations like setting and retrieving values, enforcing range constraints, incrementing values, and registering hooks for state changes, while supporting alias handling and marshaling for persistence. It operates on `Debug.t` data structures that encapsulate project",
      "description_length": 329,
      "index": 3155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Custom-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom abstract data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use within Frama-C's plugin system. It supports structured data representation through a descriptor and provides deep copying and project membership checks. Concrete use cases include managing analysis results or stateful data that must persist across different phases of static analysis.",
      "description_length": 421,
      "index": 3156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Cacheable",
      "library": "frama-c.kernel",
      "description": "This module defines an abstract type `t` with operations for hashing, equality checking, and a distinguished sentinel value. It supports use cases such as efficient storage and retrieval of binary data in low-level caches, where identity and equality must be explicitly controlled. The module is designed for use in contexts requiring strict binary representation management, such as serialization or persistent storage of structured values.",
      "description_length": 441,
      "index": 3157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and configure parameter categories such as `@none`, `@default`, and `@all`. It works with strings, state lists, and accessors to build and manipulate category values within a parameter system. Concrete use cases include setting default parameter behaviors, enabling all parameters with specific interpretations, and defining dependencies for grouped command-line options.",
      "description_length": 473,
      "index": 3158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_hashtbl-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing with project functions, and exposes type descriptors for integration with Frama-C's typing system. Concrete use cases include managing collections of analysis values with efficient lookups and persistence across Frama-C sessions.",
      "description_length": 440,
      "index": 3159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Set",
      "library": "frama-c.kernel",
      "description": "This module offers a comprehensive library for manipulating immutable ordered sets, supporting operations like creation (empty, singleton), modification (union, intersection, difference), ordered traversal (iter, fold), predicate-based filtering (filter, partition), and conversion to/from sequences. It operates on sets (`t`) with elements (`elt`) ordered via a comparator module (`Ord`), enabling efficient querying (e.g., nearest elements, subset checks) and structural transformations (map, filter_map). Designed for applications requiring precise ordered set manipulation, such as static analysis tasks involving numerical fields (e.g., modeling floating-point computations) or scenarios needing monotonic predicate evaluation over ordered data.",
      "description_length": 750,
      "index": 3160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Enumeration",
      "library": "frama-c.kernel",
      "description": "This module provides operations for enumerating elements of a lattice type, specifically `fold_enum` to iterate over elements and `cardinal_less_than` to check the size of the lattice. It works with lattice values of type `t` that support finite enumeration. Concrete use cases include analyzing or transforming finite sets of abstract values in static analysis, such as tracking possible integer ranges or program states with bounded possibilities.",
      "description_length": 449,
      "index": 3161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Builtin_logic_info",
      "library": "frama-c.kernel",
      "description": "This module manages built-in logic information in CIL with core operations for equality, comparison, hashing, and pretty-printing of `builtin_logic_info` values. It provides set, map, and hash table structures through submodules that support efficient lookups, ordered traversal, and transformations over logic metadata. You can track logic functions, resolve dependencies, cache analysis results, or manipulate structured data across CIL constructs using precise key-value associations and typed storage. Key operations include nearest element queries, deep copying, filtering, and project-aware membership checks, tailored for static analysis plugins working with logic functions and annotations.",
      "description_length": 698,
      "index": 3162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic",
      "library": "frama-c.kernel",
      "description": "This module provides functors to instantiate polymorphic types with a single type variable, producing monomorphic types with full support for standard operations like equality, comparison, hashing, and pretty printing. It allows checking whether a type is an instantiation and retrieving its base type, enabling type-safe manipulation of parameterized structures such as lists or options in static analysis plugins. The child module focuses on generating concrete data structures with introspection and serialization capabilities, directly supporting analysis workflows in Frama-C plugins. Together, they facilitate the creation and management of type-specific values with consistent, built-in operations.",
      "description_length": 705,
      "index": 3163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement.WTOIndex",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing indices in a weak topological order (WTO) specific to the CIL statement graph. It provides operations for equality checking, comparison, hashing, and pretty-printing these indices, along with utilities for deep copying and checking membership based on project skeletons. Concrete use cases include managing and traversing control-flow graph components during static analysis passes in Frama-C.",
      "description_length": 442,
      "index": 3164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_api.S-module-type-PrinterExtension",
      "library": "frama-c.kernel",
      "description": "This module defines a signature for extending pretty-printers in the AST, enabling customization of output formatting through functors. It works with abstract syntax tree (AST) structures and printer classes that require extensibility. Concrete use cases include adding custom printing rules for new language constructs or modifying the display of existing nodes during static analysis.",
      "description_length": 386,
      "index": 3165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-True",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean configuration parameters in Frama-C plugins, including value manipulation, change hooks, serialization, and alias definitions. It works with boolean states (`t = bool`) and `Typed_parameter.t` instances to enable project-specific behavior through persistence mechanisms and callback registration. Specific use cases include enabling/disabling plugin features via `on`/`off` functions and synchronizing configuration changes with project state updates.",
      "description_length": 504,
      "index": 3166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Set",
      "library": "frama-c.kernel",
      "description": "This module enables configuration of command-line parameter sets through operations that manage element membership, iteration, and state persistence over a parameterized collection type. It supports structured manipulation of set-like command-line arguments with typed elements (`elt`), including membership checks, predicate-based queries, and transformation hooks, while integrating with project state systems. Typical use cases involve defining options that accumulate values (e.g., analysis targets) or enforce constraints on multi-flag inputs with dynamic defaults.",
      "description_length": 570,
      "index": 3167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a specialized hash table for managing data associated with CIL statements, using `Cil_types.stmt` as keys and supporting efficient lookups, updates, and comparisons. It includes operations for atomic modifications, existence checks, iteration, and dependency tracking, enabling use cases such as caching analysis results or maintaining metadata across control flow structures. The child module enhances this functionality with deep copy support, project-aware membership, and pretty-printing, facilitating integration into larger static analysis workflows. Together, they enable precise, consistent handling of statement-bound data with performance-optimized access and change propagation.",
      "description_length": 710,
      "index": 3168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Value",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations for map values with support for equality, comparison, hashing, and pretty-printing. It handles structured data types with descriptors, representants, and project-aware membership checks. Useful for static analysis tasks requiring precise value tracking and transformation across program states.",
      "description_length": 324,
      "index": 3169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with logic types in CIL, including equality, comparison, hashing, and pretty-printing through the `logic_type` data type. It supports analysis and manipulation of logical type information during static analysis, enabling tasks like type equivalence checks and debugging output. Submodules extend this foundation with efficient imperative hash tables for key-value storage, ordered finite maps for structured transformations, and set operations for precise set-theoretic reasoning. Examples include memoizing type computations, tracking variable bindings, and performing union or intersection operations on logic type sets.",
      "description_length": 671,
      "index": 3170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection_category",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing categories within a collection, including creating named categories, setting default and \"all\" categories, and enabling or disabling them with specific interpretations. It works with types `elt` representing elements of the collection and `t` as a parameterized category type. Concrete use cases include configuring command-line option groups, controlling default behavior, and defining meta-categories like \"@all\" for collective enablement.",
      "description_length": 485,
      "index": 3171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map keyed by file paths with support for efficient lookups, insertions, and deletions. It operates on a custom datatype `t` representing file path associations, providing equality, comparison, and hashing operations tailored to file path semantics. It is suitable for tracking file-specific data across different projects, such as analysis results or configuration settings.",
      "description_length": 399,
      "index": 3172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Default_offsetmap",
      "library": "frama-c.kernel",
      "description": "Implements maps from bases to offset-based memory maps, where each base key is associated with a lattice-bound memory map or bottom. Provides default values for unbound bases and optimizes insertion operations by leveraging default content semantics. Useful for static analysis passes that track memory states with offset precision, such as value analysis or pointer aliasing detection.",
      "description_length": 386,
      "index": 3173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_ByName",
      "library": "frama-c.kernel",
      "description": "This module organizes logic types by name with support for equality, comparison, hashing, and pretty-printing, enabling precise manipulation of CIL-based type representations in Frama-C plugins. It includes hash tables for efficient metadata storage and memoization, ordered sets for dependency resolution and type hierarchy analysis, and ordered maps for structured associations between type names and arbitrary data. Specific operations include deep copying, deterministic traversal, union and intersection of type sets, and keyed lookups with custom formatting. Submodules refine these structures with type-specific comparisons, hashings, and introspection tools, enabling tasks like tracking type definitions and synchronizing metadata across analysis passes.",
      "description_length": 763,
      "index": 3174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.Share",
      "library": "frama-c.kernel",
      "description": "This module provides access to shared system configuration paths used by Frama-C. It exposes directories for architecture-independent files, the main Frama-C installation directory, the combined search path, and the location of Frama-C's libc headers. These values are used to locate resources such as plugins, libraries, and headers during analysis.",
      "description_length": 350,
      "index": 3175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.C11",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option for C11 standard compliance, enabling features like conditional parsing of C11 constructs and ensuring consistent analysis through state persistence. It operates on a boolean type `t`, supporting operations to set, retrieve, and track the state across projects. Submodule functionality extends `t` with rich data manipulation capabilities, including equality, comparison, and pretty-printing, enabling precise handling of C11-specific data representations. Together, they support use cases such as deep copying C11 types, validating structural consistency, and integrating C11 features into analysis workflows.",
      "description_length": 661,
      "index": 3176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Int",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing integer configuration parameters with range constraints, including value validation, incrementing, and persistent state tracking. It works with global integer states integrated into Frama-C's project system, supporting command-line interface visibility, serialization, and callback hooks for value changes. These features are used to implement plugin settings that require validated numeric inputs, cross-session persistence, and dynamic adjustments during analysis workflows.",
      "description_length": 521,
      "index": 3177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Int32",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with 32-bit integers, including equality, comparison, hashing, and pretty-printing, and serves as a foundation for specialized data structures tailored for static analysis. It includes a hash table implementation for integer-keyed polymorphic values, supporting imperative and functional updates, ordered traversal, and custom memory handling, enabling efficient state tracking and caching. An integer set module offers immutable sets with set algebra, ordered traversal, and efficient membership queries, ideal for representing value ranges and bit-precise states. A map module provides ordered integer-keyed associations with transformation, merging, and reverse iteration capabilities, supporting structured key-value manipulations in analysis plugins.",
      "description_length": 804,
      "index": 3178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Set",
      "library": "frama-c.kernel",
      "description": "The module offers a suite of ordered set operations\u2014including union, intersection, difference, filtering, and mapping\u2014alongside utilities for ordered traversal, nearest-element searches, and project-specific membership validation for alarm element collections. It operates on structured sets of alarm objects (`Frama_c_kernel.Alarms.t`), preserving element ordering during transformations and conversions to sequences or lists, while supporting deep copying and efficient physical equality checks. These capabilities enable use cases in static analysis workflows, such as alarm dependency tracking, state-sensitive verification, and structured reporting of analysis results.",
      "description_length": 674,
      "index": 3179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps with values of a specific data type, providing operations for equality, comparison, hashing, and pretty printing. It supports working directly with map structures where each value adheres to the lattice properties defined by the `Data` module. Concrete use cases include managing abstract values in static analysis, such as tracking variable states across different program points in Frama-C.",
      "description_length": 420,
      "index": 3180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates project states in Frama-C with support for equality, comparison, hashing, and pretty printing. It provides core data structures\u2014lists, sets, maps, and hash tables\u2014for efficient storage and retrieval of analysis results, transformation metadata, and AST node associations. The map submodule manages key-value pairs with ordered keys and typed values, enabling hierarchical state tracking and bidirectional sequence conversion. The hash table submodule offers imperative state management with safe lookups and project-aware keys, while the set submodule supports ordered collections with standard set operations and skeleton-based introspection, ideal for dependency tracking and incremental analysis.",
      "description_length": 738,
      "index": 3181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Composition.Make_with_product",
      "library": "frama-c.kernel",
      "description": "This module combines two monads into a single structure that supports `return`, `bind`, `map`, and `product`, enabling sequential and parallel effectful computations. It uses a swap function to reconcile the composition order of interior and exterior monads, allowing operations like stateful processing paired with optional results. The child modules extend this with conditional execution via `only_if`, support for composing Option with other monads, and list-based sequencing through `iter`, `map`, and `fold_left`. Examples include analyzing code with stateful passes that may fail, selectively logging based on flags, and processing optional or sequential data under combined effects.",
      "description_length": 690,
      "index": 3182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple_with_collections",
      "library": "frama-c.kernel",
      "description": "This module combines a triple type with persistent collections to manage structured, heterogeneous data alongside sets, hash tables, and maps. It supports operations for creating, comparing, and transforming triples, with child modules handling ordered sets, hash-based lookups, and key-value mappings that support deep copying, membership tests, and integration with Frama-C's core types. You can use it to group related values like function identifiers, analysis states, and metadata, then manipulate them efficiently through set operations, hash-based queries, or ordered traversals. Examples include tracking program elements across analysis passes, aggregating results per function, or managing symbolic identifiers with structured keys and values.",
      "description_length": 753,
      "index": 3183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatHex",
      "library": "frama-c.kernel",
      "description": "This module manages floating-point hexadecimal representation through a boolean configuration flag, enabling dynamic switching between hexadecimal and decimal display formats. It integrates with the `Project.t` type to ensure state consistency across sessions and supports marshaling for persistent storage. The child module defines a data type with comparison, hashing, and pretty-printing operations, used to handle and transform floating-point literals during analysis. Examples include customizing numeric output in static analysis tools and synchronizing project-specific state for consistent floating-point computation handling.",
      "description_length": 634,
      "index": 3184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.List",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for handling lists of optional values, including `iter`, `map`, and `fold_left`, where each function threads `option` results through the computation. It works with lists of type `'a list` and functions that return `'b option`, allowing safe propagation of failure across list traversals. Use cases include parsing or analyzing sequences where each step may fail, such as processing command-line arguments with fallible conversions or validating structured input.",
      "description_length": 503,
      "index": 3185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for keys used in a lattice-structured map, specifically for `Hashtbl.key`. It provides operations for equality, comparison, hashing, and pretty-printing keys, along with deep copying and membership testing based on project functions. It is used to manage and manipulate keys within a lattice-based map structure, particularly in contexts requiring precise key representation and comparison.",
      "description_length": 422,
      "index": 3186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Set_project_as_default",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls project-specific state persistence and configuration defaults, offering operations to set, retrieve, and monitor changes to its value. It works with boolean flags and leverages hooks to handle side effects such as updating dependent configurations or persisting settings across sessions, enabling features like default analysis settings in Frama-C. The child module enhances this functionality by defining a data type for sets of project representations, supporting membership checks, deep copies, and precise comparisons, allowing plugins to track and manipulate project collections reliably. Together, they provide a framework for managing project-wide configurations with both global state control and fine-grained project set operations.",
      "description_length": 799,
      "index": 3187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintCode",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option to control code printing behavior, offering functions to set, retrieve, and monitor changes through hooks, while also supporting aliases and serialization. It defines a data type for printable values with operations for equality, comparison, hashing, and pretty-printing, enabling structured handling of intermediate code representations during analysis. You can toggle `-print` output dynamically during execution or integrate with plugins that require conditional display of project-based data. The combination of runtime control and structured value handling supports adaptive workflows with deep copying, membership checks, and state persistence.",
      "description_length": 701,
      "index": 3188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a monomorphic datatype instance from a polymorphic type, providing standard operations including equality, comparison, hashing, and pretty printing. It works with polymorphic types through a type parameter and generates values of type `t` as instances of the polymorphic type `T.t poly`. Concrete use cases include defining and manipulating typed values in static analysis plugins, such as representing program expressions or abstract states with structured, hashable, and comparable types.",
      "description_length": 510,
      "index": 3189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_hashtbl-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides comprehensive hash table operations including creation, insertion, deletion, lookup, sorted iteration, and memoization, tailored for Frama-C's datatype system. It works with hash tables where keys adhere to the `S_with_hashtbl` type and values are polymorphic, supporting conversion to/from sequences and structural descriptions. It is particularly useful in Frama-C plugins for managing analysis data, caching results with customizable key ordering, or handling complex value types requiring optional/default semantics.",
      "description_length": 541,
      "index": 3190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Offset",
      "library": "frama-c.kernel",
      "description": "This module handles comparison, hashing, and pretty-printing of CIL offset values, which represent field or array indexing operations in C ASTs. It includes Set, Map, and Hashtbl submodules for managing collections of offsets or offset-keyed data, enabling efficient analysis and transformation of C code structures. The Map supports functional manipulation of offset-keyed data with merging and traversal, while the Set provides ordered, immutable offset collections for tracking field accesses or index ranges. The Hashtbl offers imperative tables for offset-based mappings with deep copying and structural equality, useful for static analysis tasks like tracking memory layouts or memoizing offset computations.",
      "description_length": 714,
      "index": 3191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module provides imperative set-like operations for managing collections of strings, including addition, membership checks, iteration, and emptiness tests, while supporting state tracking and project-specific behavior. It operates on `Frama_c_kernel.Datatype.String.Set.t` and integrates with option parsing frameworks to handle aliases, serialization, and dynamic configuration updates. Typical use cases include maintaining plugin state, processing command-line arguments, and synchronizing string sets across different analysis phases in static verification tools.",
      "description_length": 571,
      "index": 3192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_input",
      "library": "frama-c.kernel",
      "description": "This module defines the input requirements for creating a datatype with specific operations such as equality, comparison, hashing, and pretty printing. It works with a type `t` and provides functionality for managing representations, rehashing, and project membership checks. Concrete use cases include defining custom data types that integrate with Frama-C's internal structures, such as abstract values or analysis-specific data, ensuring they can be properly marshaled, compared, and displayed.",
      "description_length": 497,
      "index": 3193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string-based data types, providing operations to compare, hash, and pretty-print values. It supports data structures like string maps and ensures deep copying and project membership checks. Concrete use cases include parsing and validating string inputs, managing configuration options, and integrating with Frama-C's analysis frameworks.",
      "description_length": 394,
      "index": 3194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds.Bottom",
      "library": "frama-c.kernel",
      "description": "This module enables structured manipulation of lattice values with an explicit bottom element, supporting monadic operations and lattice-specific utilities for handling absent or undefined states. It provides core data types like `'a t` and operations such as join, narrowing, and product computations, while submodules handle domain-specific constructions, control flow conditions, and traversals over lists and options. For example, it can lift booleans into lattice contexts, sequence computations with bind and map, or fold over lists while propagating bottom states. Submodules further refine these capabilities with precise equality checks, conditional bottom propagation, and semi-lattice joins, enabling robust static analysis of complex data flows.",
      "description_length": 757,
      "index": 3195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Integer",
      "library": "frama-c.kernel",
      "description": "This module provides integer values with core operations for equality, comparison, hashing, and pretty-printing, designed for use in static analysis plugins. It includes sets and maps for ordered and efficient manipulation of integer collections, supporting operations like union, intersection, ordered traversal, and functional updates. Hash tables enable efficient lookup, memoization, and bulk updates, with submodules offering typed collections and key-specific operations. Examples include tracking integer-identified entities, modeling variable domains, and caching analysis results with precise key handling.",
      "description_length": 615,
      "index": 3196,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintReturn",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean option that controls whether return values are printed during analysis, offering operations to set, query, and observe changes to its state. It defines a data type `t` with support for equality, comparison, hashing, and pretty-printing, enabling structured representation of option values with descriptors and packed variants. The module handles primitive boolean values, project-specific state, command-line parameters, and marshaling for persistence, while supporting conditional logging and integration with analysis plugins. Example uses include customizing output verbosity in static analysis workflows or comparing and transforming structured return value data in kernel plugins.",
      "description_length": 715,
      "index": 3197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Site_dir",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve directories and files from Dune site locations, specifically `get_dir` and `get_file`. It works with string names and returns resolved file paths. Use it to locate installed resources such as shared libraries or configuration files during analysis.",
      "description_length": 291,
      "index": 3198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Abstract",
      "library": "frama-c.kernel",
      "description": "This module provides a way to access and work with abstract types registered in the Frama-C kernel, specifically through the `ty` value which represents the type. It is used to retrieve and manipulate abstract type information in a type-safe manner. Concrete use cases include querying and handling abstract types during static analysis plugin development, such as when implementing custom dataflow analyses or type-based transformations.",
      "description_length": 438,
      "index": 3199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_Two",
      "library": "frama-c.kernel",
      "description": "This module implements a binary cache for combining values of two different types, `H0.t` and `H1.t`, into a result of type `R.t`. It supports `clear` to reset cached results and `merge` to apply a function to pairs of inputs, caching the output. Use it when efficiently memoizing functions that take two distinct structured inputs and produce a derived result, such as combining abstract analysis states from two different domains.",
      "description_length": 432,
      "index": 3200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.JsonCompilationDatabase",
      "library": "frama-c.kernel",
      "description": "This module manages command-line configuration for JSON compilation database paths, offering operations to set, retrieve, and validate file paths with support for defaults and project-specific overrides. It integrates with submodules that define structured types for compilation entries, enabling equality checks, serialization, and membership testing. Use cases include dynamically resolving compilation databases during static analysis and ensuring consistent path handling across different project configurations. Together, the module and its submodules provide a robust interface for managing and querying structured compilation data based on file path inputs.",
      "description_length": 664,
      "index": 3201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Axiomatics",
      "library": "frama-c.kernel",
      "description": "This module provides a mutable, project-aware key-value store using strings as keys and CIL locations as values, supporting insertion, lookup, iteration, and folding, along with project-specific state management via hooks and custom marshaling. Its child module defines a structured data type with equality, comparison, and hashing operations, enabling project-safe manipulation of logic entities like types and descriptors. Together, they allow Frama-C plugins to track axiomatic definitions, cache logic computations, and synchronize state across project contexts while preserving data integrity. Example uses include storing and retrieving axiomatic rules by name, and performing deep copies or membership checks on logic entities across different project phases.",
      "description_length": 766,
      "index": 3202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Set",
      "library": "frama-c.kernel",
      "description": "This component implements a set abstraction layered over lattice-structured maps, enabling operations like union, intersection, difference, and cardinality computation on ordered sets (`Set.t`) of elements (`Set.elt`). It supports efficient transformations through predicates, mappings, and folds, alongside utilities for sequence conversion, nearest-neighbor queries, and membership testing with projections. Designed for static analysis tasks, it facilitates precise set-based reasoning in abstract interpretation and program analysis workflows requiring lattice-theoretic guarantees.",
      "description_length": 586,
      "index": 3203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data.Sites",
      "library": "frama-c.kernel",
      "description": "This module defines lists of locations for various components such as libraries, plugins, GUI plugins, and shared resources. It works with `Dune_site.Private_.Helpers.Location.t` values, organizing them into specific categories. These lists are used to configure and locate installed resources during runtime.",
      "description_length": 309,
      "index": 3204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage boolean command-line options through state manipulation, value change notifications, and alias resolution, with support for custom serialization and project-specific behavior. It operates on boolean values within the Frama-C kernel's state management system, enabling use cases like toggling analysis features, tracking configuration switches, and handling interdependent command-line flags with dynamic marshaling capabilities.",
      "description_length": 470,
      "index": 3205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Set",
      "library": "frama-c.kernel",
      "description": "This module provides persistent set operations for polymorphic elements with a total order, supporting creation, modification, and queries like union, intersection, ordered traversal, and nearest-element search. It includes utilities for converting between sets and sequences, filtering, mapping, and partitioning, along with hashing, comparison, and pretty-printing functions. These operations are particularly useful in scenarios requiring efficient set manipulation, such as managing command-line parameters or static analysis data in Frama-C plugins.",
      "description_length": 554,
      "index": 3206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State.Map",
      "library": "frama-c.kernel",
      "description": "This module manages persistent associative maps with ordered keys and arbitrary value types, enabling keyed lookups, filtered transformations, ordered traversal, and customizable merging. It supports deep copying, structured comparison, and sequence conversion, working with project-compliant mutable states and type-safe value handling. The key module provides total ordering, equality, and introspection for state identifiers, while the value module implements typed map entries with project-specific descriptors. Together, they enable tracking and aggregating analysis states across hierarchical or ordered execution contexts in static analysis plugins.",
      "description_length": 656,
      "index": 3207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Symmetric_Binary_Predicate",
      "library": "frama-c.kernel",
      "description": "This module implements a low-level symmetric binary predicate cache with merging capabilities. It operates on values of type `H0.t`, allowing efficient storage and retrieval of boolean results from pairwise comparisons. It is used to optimize repeated symmetric predicate evaluations, such as equality or ordering checks, in contexts where performance is critical and project-awareness is not required.",
      "description_length": 402,
      "index": 3208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidBool",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls how invalid boolean expressions are handled during static analysis, enabling or disabling warnings based on user settings. It provides a data type `t` with operations for equality, comparison, and pretty printing, allowing structured manipulation of configuration values and their descriptors. The module supports monitoring value changes and executing custom logic, such as updating analysis behavior when the option is toggled. Submodules enhance this functionality with utilities for list management, deep copying, and project membership checks, facilitating integration with Frama-C's kernel state system.",
      "description_length": 674,
      "index": 3209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Kinstr",
      "library": "frama-c.kernel",
      "description": "This module handles CIL kernel instructions with operations for equality, comparison, hashing, and pretty-printing, along with utilities for deep copying, membership checks, and conversion of optional statements. Its set submodule enables ordered manipulation of instruction sets through standard set operations, traversal, and transformation, supporting tasks like subset analysis and predicate-based queries. The hash table and dictionary submodules provide efficient key-based storage and retrieval of instruction-related data, with support for ordered traversal, merging, and dataflow tracking across compiler passes. Together, they enable precise, performant analysis and transformation of C code through structured, instruction-centric data manipulation.",
      "description_length": 760,
      "index": 3210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Int-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured data type with support for equality, comparison, hashing, and pretty-printing operations. It works with a specific datatype `t` that represents values with a unique name, descriptor, and structural properties. Concrete use cases include managing and manipulating abstract values in static analysis, such as tracking variable states or program properties across different analysis phases.",
      "description_length": 420,
      "index": 3211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_site_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a `Site_dir` from an existing directory, using a parent directory and a target directory name. It provides `get_dir` and `get_file` functions to retrieve validated directory and file paths within the site, aborting on failure. It works with `Frama_c_kernel.Filepath.t` to ensure correct path handling, useful for plugin-specific resource management like loading configuration files or storing generated data.",
      "description_length": 431,
      "index": 3212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.File",
      "library": "frama-c.kernel",
      "description": "This module defines operations for manipulating CIL file structures, including equality checks, comparison, hashing, and pretty-printing. It provides functions to inspect and traverse project-related data within a file, such as checking membership based on project predicates and performing deep copies. Use cases include analyzing or transforming C source files during static analysis, tracking project-specific metadata, and ensuring structural consistency across file representations.",
      "description_length": 487,
      "index": 3213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean plugin parameters, including setting values with `on`/`off` states, tracking default or computed values, and integrating with command-line interfaces and project state persistence. It operates on globally managed boolean states, supporting metadata features like aliasing, deprecation, and serialization customization. These capabilities are used when configuring plugin behavior through boolean options that require dynamic updates, version migration, or interaction with Frama-C's analysis framework.",
      "description_length": 555,
      "index": 3214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing set-valued plugin options with stateful computations, supporting element membership tests, iterative transformations, and serialization. It works with set types derived from `E.Set.t`, enriched with metadata tracking via `self` and `mark_as_computed`, and includes utilities for defining versioned option aliases with visibility controls. These capabilities are particularly useful for implementing configurable analysis plugins that require tracking evolving set states, handling custom data marshaling, or organizing elements into hierarchical categories.",
      "description_length": 602,
      "index": 3215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and modify named categories such as '@none', '@default', and '@all'. It works with category types tied to parameter elements and state lists, supporting dynamic configuration through accessors and dependencies. Concrete use cases include setting default category behavior, enabling all options with specific interpretations, and creating custom categories with associated names and accessors.",
      "description_length": 502,
      "index": 3216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Under_Approximation",
      "library": "frama-c.kernel",
      "description": "This module extends lattice operations with under-approximation capabilities for analyzing program states. It provides `link` and `meet` functions that compute under-approximated unions and intersections of lattice elements of type `t`. It is used in static analysis to safely approximate possible program behaviors while ensuring correctness in scenarios like value analysis or abstract interpretation.",
      "description_length": 403,
      "index": 3217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AuditCheck",
      "library": "frama-c.kernel",
      "description": "This module manages file path configurations for the `-audit-check` feature, supporting operations to set and retrieve paths, track project-specific state, and integrate with the command-line interface. It defines a core data type `t` with equality, comparison, and serialization capabilities, enabling structured representation through descriptors and packed values. Submodules enhance this functionality by providing introspection, deep copy support, and dynamic callback registration for audit validation during static analysis. Example uses include validating non-empty file paths, tracking changes across analysis sessions, and ensuring plugin compatibility through project membership checks.",
      "description_length": 697,
      "index": 3218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Map",
      "library": "frama-c.kernel",
      "description": "The module offers map manipulation operations like insertion, deletion, and combination (union, merge), along with ordered traversal, filtering, and transformation functions for key-value pairs. It operates on `'a Map.t` structures with ordered keys, supporting conversions to and from lists, sequences, and formatted strings. These capabilities are suited for static analysis tasks requiring precise data aggregation, ordered key processing, or generating structured representations of mapped data.",
      "description_length": 499,
      "index": 3219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field.S",
      "library": "frama-c.kernel",
      "description": "This module supports arithmetic operations, comparisons, and container management for abstract numeric values represented as a `scalar` type, which models field-like algebraic structures with precise bounds and conversions. It provides operations for addition, multiplication, logarithms, and container types like sets and maps, while enabling conversions between integers, floats, and strings. Designed for static analysis tasks, it facilitates precise modeling of floating-point computations and numeric abstractions in program verification scenarios.",
      "description_length": 553,
      "index": 3220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Bool-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a boolean command-line parameter type with operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to define and manipulate boolean options in Frama-C plugins, including support for project-specific filtering via `mem_project`. Use cases include enabling or disabling analysis features through command-line flags, such as toggling specific warnings or analysis passes.",
      "description_length": 431,
      "index": 3221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype where each entry's value type is defined by the `Data` module. It provides standard operations including equality, comparison, hashing, and pretty-printing for these hash tables, along with deep copying and project membership checks. It is used to manage and manipulate CIL-related data indexed in a hash table structure within Frama-C plugins.",
      "description_length": 389,
      "index": 3222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Orig_project",
      "library": "frama-c.kernel",
      "description": "This module manages the original project state for diff computation, offering operations to set, get, and memoize project data while supporting change tracking through hooks and custom serialization. It includes a core data type for representing project structure, enabling equality checks, comparison, hashing, and pretty-printing, along with deep copying and skeleton membership testing. The module facilitates baseline version storage for comparison and triggers actions on state updates, allowing analysis of structural changes and project evolution through diff representations. Together with its submodules, it provides a structured way to capture, manipulate, and analyze project states during diffing processes.",
      "description_length": 719,
      "index": 3223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Hptset",
      "library": "frama-c.kernel",
      "description": "This module manages sets of kernel functions with efficient operations for union, intersection, difference, and membership checks, using a hash-aware structure that supports deep copying and project-sensitive comparisons. It integrates submodules for heterogeneous maps and hash tables, enabling structured association of data with function sets or individual functions, such as tracking analysis results or attaching annotations. Additional support for ordered traversal, filtering, and transformations facilitates tasks like interprocedural dataflow and abstract interpretation. Specific uses include caching per-function analysis data, grouping functions by properties, and managing function sets across project configurations.",
      "description_length": 730,
      "index": 3224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.RemoveExn",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls exception removal during analysis, with support for setting the flag, triggering change notifications, and customizing serialization. It works alongside a child module that defines structured data types for representing and manipulating values with project-specific context, including deep copying, comparison, and pretty-printing. Together, they enable precise control over exception elimination behavior in the analysis pipeline, allowing plugins to conditionally remove exceptions based on project-specific criteria and maintain consistent, serializable state. Example uses include configuring analysis passes to suppress exceptions in specific project contexts and tracking removal decisions across different codebases.",
      "description_length": 786,
      "index": 3225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Usable_emitter",
      "library": "frama-c.kernel",
      "description": "This module manages usable emitters through core operations like equality, hashing, metadata extraction, and deep copying, organizing them with sets, maps, and hash tables for efficient collection handling. It enables structured data association via emitter-keyed maps and hash tables, supporting typed queries, memoization, and ordered traversal for tasks like annotation emission and property tracking. The set module provides standard set operations along with ordered processing and nearest-element queries, facilitating aggregation and filtering of emitter outputs. Specific uses include tracking Frama-C annotations, caching analysis results, and managing emitter states with typed and project-aware data structures.",
      "description_length": 722,
      "index": 3226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.UnrollUnnatural",
      "library": "frama-c.kernel",
      "description": "This module manipulates control flow graphs by restructuring unnatural loops so that all loop entries pass through the loop head, enabling precise static analysis through operations like unrolling, traversal, and weak topological order computation. It defines core data types such as versioned control flow states, labeled vertices, directed edges, and specialized maps and sets for tracking and analyzing transformed control flow structures. Using forward and backward dataflow analyses, it computes abstract values over normalized loops, supporting tasks like liveness detection, interval analysis, and invariant checking. The module integrates with submodules that implement the Bourdoncle algorithm for weak topological ordering, provide abstract domains with join and transfer operations, and manage versioned state transitions using ordered sets and hash tables.",
      "description_length": 868,
      "index": 3227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralVerbose",
      "library": "frama-c.kernel",
      "description": "This module manages verbosity levels through integer parameters, supporting dynamic control of output detail with hooks for state tracking, value range constraints, and configuration persistence. It provides operations to set, retrieve, and alias verbosity levels, while its child module introduces a polymorphic type `t` with equality, comparison, and pretty-printing for structured configuration handling. The combined functionality enables deep cloning of settings, project membership checks, and integration with analysis tools, supporting use cases like kernel extensions and diagnostic output management. Together, they offer both low-level control and high-level data manipulation for verbose output configurations.",
      "description_length": 722,
      "index": 3228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in map structures, providing operations for equality, comparison, hashing, and pretty-printing individual key values. It supports key values of type `Key.t`, along with standard functions like `equal`, `compare`, `hash`, and `pretty`. Concrete use cases include managing and comparing symbolic keys in static analysis plugins, such as tracking variable identifiers or control-flow nodes in Frama-C's intermediate representations.",
      "description_length": 474,
      "index": 3229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Multiple_map",
      "library": "frama-c.kernel",
      "description": "This module provides map-like operations for managing command-line parameters with support for aliases, value hooks, and customizable serialization, operating on key-value associations where keys and values can be extended with metadata like visibility or deprecation flags. It enables use cases such as command-line interface parsing with parameter aliasing, state change tracking, and persistent configuration handling through marshaling customization, leveraging submodules for string-based value formatting and category-based organization.",
      "description_length": 543,
      "index": 3230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Feedback",
      "library": "frama-c.kernel",
      "description": "This module defines a type `t` representing the possible statuses of properties in static analysis, such as `Valid`, `Invalid`, or `Unknown`. It provides functions to retrieve the status of a single property or a conjunction of properties, and to print the status in a human-readable form. These operations are used to assess and report the results of property validation during analysis.",
      "description_length": 388,
      "index": 3231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Site_root",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration and resolution of Dune site directories and their contained files. It provides operations to set and retrieve the site root directory, check if it has been configured, and locate specific files or subdirectories within the site structure. It directly supports use cases such as loading Dune-specific resources like plugins or configuration files from predefined locations.",
      "description_length": 410,
      "index": 3232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option groups, providing operations to define, enable, and modify categories with specific accessors and dependencies. It works with category types and state lists to control option behavior, such as setting defaults or enabling all options under a category. Concrete use cases include organizing related command-line flags and controlling their activation based on user input or internal logic.",
      "description_length": 443,
      "index": 3233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Modules",
      "library": "frama-c.kernel",
      "description": "This module provides project-scoped key-value storage with string keys and values as optional string pairs paired with CIL locations, supporting operations like insertion, lookup, and iteration with change tracking and custom marshaling. Its core functionality enables context-aware semantic data management during C code analysis, particularly for cross-phase communication in Frama-C. The child module extends this with a polymorphic type `t` that supports equality, comparison, and deep copying, enabling structured logic entity handling in analysis plugins. Together, they facilitate precise, typed storage and manipulation of analysis data across different phases and contexts.",
      "description_length": 682,
      "index": 3234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatNormal",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls floating-point normalization behavior in static analysis workflows, allowing toggling, observation through hooks, and integration with project-specific serialization. It works with internal boolean state representations and callback functions, enabling customization of floating-point value handling during analysis. The module's data type `t` supports structured representation with a unique name, descriptor, and representatives, offering operations for comparison, hashing, pretty-printing, and deep copying. It is used to manage abstract values in static analysis plugins that require precise control over floating-point normalization policies.",
      "description_length": 711,
      "index": 3235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-True",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage boolean command-line options with support for state manipulation, change notifications, and serialization. It works with typed parameters (`Frama_c_kernel.Typed_parameter.t`) and boolean values (`t`), enabling use cases like toggling analysis features via flags (e.g., `--enable-feature`), tracking project-specific state, and synchronizing parameter changes across components through hooks or marshaled representations.",
      "description_length": 462,
      "index": 3236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filled_string_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for handling filled string sets, including creation, comparison, hashing, and pretty-printing. It works with a custom datatype `t` representing string sets, supporting membership checks and project-specific queries. Concrete use cases include managing and comparing sets of strings within Frama-C plugins, particularly for static analysis tasks requiring set operations and persistent storage of string collections.",
      "description_length": 458,
      "index": 3237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Syntactic_scope",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with syntactic scopes in CIL, including equality, comparison, hashing, and pretty-printing, while supporting deep copies, project membership checks, and structured collections like sets, maps, and hash tables. Its submodules enable mapping syntactic scopes to arbitrary values, performing set-theoretic operations on scope collections, and managing scoped key-value associations with efficient access and transformation. You can use it to track variable visibility, analyze control flow, or transform C code during static analysis by leveraging operations like scope-based filtering, structural decomposition, and sequence-driven construction. Specific capabilities include merging scope mappings, computing intersections of scope sets, and associating annotations with syntactic contexts in a type-safe and efficient manner.",
      "description_length": 874,
      "index": 3238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Fundec",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates C function definitions in Frama-C's intermediate language, providing core operations such as equality, comparison, hashing, deep copying, and pretty-printing. It supports efficient collection handling through integrated set, map, and hash table modules, enabling tasks like function property tracking, memoization of analysis results, and transformation of C code based on function-level data. The set module supports standard set operations and ordered iteration over collections of functions, while the map and hash table modules allow associating arbitrary data with functions for efficient lookup and transformation. These components together enable precise, scalable static analysis and code manipulation based on CIL function declarations.",
      "description_length": 784,
      "index": 3239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.List-As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters with support for value validation, alias handling, and dynamic state updates through change hooks. It operates on string values within a project context, providing mechanisms to enforce allowed value constraints, resolve function names, and customize parameter serialization. Typical use cases include configuring tool options via CLI arguments, validating user-provided strings against predefined criteria, and synchronizing parameter changes with other system components through callback registration.",
      "description_length": 560,
      "index": 3240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing keys for hash tables, along with operations for equality, comparison, hashing, and pretty printing. It includes functions for deep copying values, checking membership based on project properties, and providing type and descriptor information. Concrete use cases include managing and comparing hash table keys in static analysis plugins, particularly when tracking project-specific data through hash tables.",
      "description_length": 455,
      "index": 3241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Current_loc.Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for handling location-based data in Frama-C's analysis framework. It includes functions for deep copying values, checking membership within projects, and exposing type descriptors for integration with Frama-C's plugin system. Concrete use cases include tracking and comparing source code locations during static analysis and logging.",
      "description_length": 450,
      "index": 3242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module constructs a user directory option from a base directory and a subdirectory name, supporting command-line configuration. It provides functions to retrieve or create directories and files within the user directory, with options to control path creation. Use it to manage plugin-specific storage paths that depend on a configurable base directory.",
      "description_length": 357,
      "index": 3243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies with named categories. Concrete use cases include enabling all options under a category, setting a default category behavior, or defining how the `@all` category interacts with other options.",
      "description_length": 468,
      "index": 3244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Serializable_undefined",
      "library": "frama-c.kernel",
      "description": "This module implements a serializable, undefined type with standard marshalling support, enabling values of arbitrary types to be compared, hashed, copied, and pretty-printed. It provides structural equality, comparison, and hashing operations, along with project membership checks for Frama-C's project system. It is used when values need to be persisted or transmitted across Frama-C's analysis plugins without relying on hash-consing or project-specific constraints.",
      "description_length": 469,
      "index": 3245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Top",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations with a top element, including comparison, join, and meet functions. Works with abstract data types representing program analysis values, such as integer ranges or symbolic expressions. Used in static analysis to model approximations of program states during fixpoint computations.",
      "description_length": 310,
      "index": 3246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based command-line options, including value validation against allowed sets, alias resolution, and dynamic state updates via change hooks. It works with string data types to enforce constraints, track parameter state, and support customizable behaviors like serialization or function name validation. Use cases include parsing user-provided configuration values, restricting inputs to predefined domains, and triggering side effects when parameter values change.",
      "description_length": 514,
      "index": 3247,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Wto.Make",
      "library": "frama-c.kernel",
      "description": "This module implements the Bourdoncle algorithm to compute weak topological orderings (WTOs) for a given graph structure. It provides functions to partition a graph starting from an initial node, using a preference function and successor traversal, and includes utilities for comparing and printing partitions and components. It is used to determine efficient evaluation orders for fixed-point computations in program analysis.",
      "description_length": 427,
      "index": 3248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_ref",
      "library": "frama-c.kernel",
      "description": "This module provides an integer reference type with built-in support for mutation, observation, and persistence of integer state across analysis phases. It includes operations for creating, updating, querying, and resetting references, along with hooks for change notifications and custom marshaling. The child module enhances this functionality by defining the core datatype with equality, comparison, and pretty-printing operations, enabling deep copies and membership checks over project skeletons. Together, they allow tracking and manipulating integer values during static analysis, such as maintaining counter state across plugin components or serializing reference values for analysis continuation.",
      "description_length": 705,
      "index": 3249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a collection of command-line parameters represented as strings, with operations for equality, comparison, hashing, and pretty-printing. It works with the `As_string.Datatype.t` type, providing functionality for handling and manipulating string-based parameter values. Concrete use cases include parsing and managing command-line options that accept string inputs, ensuring consistent representation and comparison within the analysis framework.",
      "description_length": 464,
      "index": 3250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Correspondence_table-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data structure for mapping and comparing abstract syntax tree (AST) elements during diff computation. It supports operations like equality checking, comparison, hashing, and pretty-printing for AST node correspondences. Concrete use cases include tracking changes between different versions of C code in Frama-C and enabling precise semantic diff analysis.",
      "description_length": 378,
      "index": 3251,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling hash table keys, providing operations such as equality, comparison, hashing, and pretty printing. It supports data types compatible with `Hashtbl.Key.t`, enabling direct use in hash tables. Concrete use cases include managing and manipulating hash table keys with deep copying, checking membership based on project values, and ensuring consistent hashing and comparison behavior.",
      "description_length": 423,
      "index": 3252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Wide_string",
      "library": "frama-c.kernel",
      "description": "This module represents wide strings as lists of 64-bit integers, supporting equality, comparison, hashing, and pretty-printing, with use cases in Unicode handling and CIL-based analysis. It includes submodules for ordered sets, maps, and hash tables that enable efficient manipulation of collections, symbol tables, and identifier mappings with operations like union, map, filter, and deterministic traversal. You can track unique string literals, manage ordered identifier sets, or associate analysis data with wide string keys using safe accessors and ordered iterators. Specific operations include merging maps, filtering sets, and converting between sequences and structured collections.",
      "description_length": 691,
      "index": 3253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Caml_weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a weak hash table implementation for storing elements with weak references, allowing automatic reclamation by the garbage collector. It supports standard operations like adding, finding, and iterating, with specialized handling for duplicates and optional returns. A key feature is its ability to manage values using identity-based equality and structural descriptions, making it suitable for caching analyses or intermediate results tied to transient states. Specific use cases include symbol tables and memoization where memory efficiency and referential integrity are critical.",
      "description_length": 601,
      "index": 3254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module manages logic information structures in Frama-C's CIL framework, offering equality, comparison, and pretty-printing for `logic_info` values alongside deep copying and project membership checks. It provides standard collection interfaces (`Set`, `Map`, `Hashtbl`) tailored for analysis plugins, enabling efficient manipulation of logic data through key-based mappings and hash tables with deterministic traversal. Child modules enhance these capabilities with specialized map and hash table implementations that support insertion, lookup, transformation, and aggregation of logic properties across program analyses. Example uses include tracking annotated program states, memoizing logic results, and structuring typed logic information for deterministic processing in analysis passes.",
      "description_length": 796,
      "index": 3255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_no_copy",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a datatype that supports equality, comparison, hashing, and pretty-printing of values. It works with structured data types that have a descriptor, a name, and a list of representatives, enabling introspection and serialization. Concrete use cases include analyzing and comparing abstract values in static analysis plugins, where project membership checks and type descriptors are essential for tracking and reporting.",
      "description_length": 452,
      "index": 3256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module extends a datatype with hash table operations, enabling creation, querying, and manipulation of key-value stores using the datatype's own `equal` and `hash` functions. It supports core operations like `create`, `add`, `find`, and `iter`, ideal for memoization, caching, and fast lookups. Child modules enhance these capabilities with advanced features such as filtering, bulk processing via sequences, and custom key handling including comparison and pretty-printing. Together, they facilitate efficient management of structured data in use cases like program analysis and plugin development.",
      "description_length": 604,
      "index": 3257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_list",
      "library": "frama-c.kernel",
      "description": "This module supports dynamic management of string sequences with stateful operations for setting, retrieving, and transforming values, including marshaling, update hooks, and project-specific persistence. It works with string lists and categorized string collections, enabling use cases like plugin configuration storage, analysis result aggregation, or tagged string processing through iterative and compositional transformations.",
      "description_length": 431,
      "index": 3258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Enumitem",
      "library": "frama-c.kernel",
      "description": "This module provides a version-aware key-value store for mapping `enumitem` identifiers to AST diff metadata, with atomic operations for insertion, replacement, and iteration, along with change notifications and custom serialization. It ensures safe handling of keys requiring custom rehashing, avoiding issues with standard hashtables, and is optimized for tracking enum member relationships across project versions in Frama-C. The child module defines a data type `t` for representing abstract values in AST diffs, supporting deep copy, equality, comparison, hashing, and pretty printing, with proper handling of project-specific information. Together, they enable precise computation and persistence of enum item differences across analysis runs while maintaining project-lifetime key consistency.",
      "description_length": 800,
      "index": 3259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Fundec_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing command-line options, providing operations to define, enable, and modify categories with specific accessors and dependencies. It works with category types and state lists to control option behavior, such as setting defaults or enabling all options with specific interpretations. Concrete use cases include configuring analysis modules in Frama-C by defining how command-line flags interact and are grouped.",
      "description_length": 452,
      "index": 3260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Fold",
      "library": "frama-c.kernel",
      "description": "This module implements a hook system that allows registering, managing, and applying a collection of transformation functions. It works with a single parameter and result type, both based on the provided module P's type. Concrete use cases include extending analysis phases with custom logic, such as adding pre-processing steps before value computations or injecting custom checks at specific program points.",
      "description_length": 409,
      "index": 3261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic3_input",
      "library": "frama-c.kernel",
      "description": "This module provides operations for handling polymorphic type values with three type variables. It includes functions to retrieve a type's name, describe its structure, and obtain representative values for given type instances. These operations are useful when working with complex, parameterized data types in Frama-C's kernel, particularly when analyzing or manipulating type information during static analysis.",
      "description_length": 413,
      "index": 3262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_ctor_info",
      "library": "frama-c.kernel",
      "description": "This module handles logic constructor information in CIL with core operations like equality, comparison, hashing, and pretty-printing, centered around the `logic_ctor_info` type. It supports analysis and transformation of logic expressions by enabling precise manipulation of constructor metadata, with child modules providing tables for efficient key-value associations, ordered sets for structured set operations and traversal, and maps for organizing metadata into typed mappings. These components allow tasks such as caching analysis results, tracking constructor usage, and validating invariants during static analysis. Specific capabilities include creating lookup tables with project-aware keys, performing set operations on constructor sets, and mapping logic constructors to structured values like function symbols across analysis phases.",
      "description_length": 847,
      "index": 3263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-False",
      "library": "frama-c.kernel",
      "description": "This module enables management of boolean plugin options through operations that set, retrieve, and monitor state changes, with support for project state synchronization and custom serialization. It operates on boolean values (`t = bool`) within Frama-C's plugin framework, providing utilities to bind these values to command-line flags and enforce state consistency. Key use cases include configuring analysis tools via dynamic boolean flags, handling runtime adjustments through registered hooks, and persisting plugin states across sessions.",
      "description_length": 544,
      "index": 3264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Input_with_arg",
      "library": "frama-c.kernel",
      "description": "Implements command-line option parsing with associated arguments, providing structured access to input parameters for kernel extensions. Works with strings and custom data types through conversion functions, supporting both documented and undocumented options. Enables precise configuration of analysis tools via command-line interfaces, such as setting analysis modes or specifying input files.",
      "description_length": 395,
      "index": 3265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PreprocessAnnot",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls annotation preprocessing behavior in the kernel, enabling or disabling preprocessing during analysis and handling command-line exposure, deprecation, and serialization. It defines a data type `t` with operations for comparison, hashing, pretty-printing, and project membership testing, supporting deep copying and structural manipulation. The module integrates with internal state management to handle project-specific configurations and aliased options, while providing hooks to track flag changes. Concrete use cases include managing `-pp-annot` during Frama-C plugin execution to control source code transformation and analysis workflows.",
      "description_length": 704,
      "index": 3266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_set",
      "library": "frama-c.kernel",
      "description": "This module supports managing set-valued command-line options and their state, providing operations to modify values, register change hooks, handle serialization, and track computation status using `E.Set.t`. It enables element-level manipulation (addition, membership checks, iteration, folding) and defines aliases with visibility controls and deprecation flags, catering to use cases like dynamic configuration management, state synchronization, or versioned option handling in command-line interfaces.",
      "description_length": 505,
      "index": 3267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder.Make",
      "library": "frama-c.kernel",
      "description": "This module combines pretty-printing functionality for CIL and Frama-C ACSL data structures with a flexible class-based interface for building customizable formatters. It supports direct formatting of expressions, types, annotations, and control-flow elements using `Format.formatter`, while allowing dynamic extension with custom rules for domain-specific types and analysis results. Submodules enable object-oriented customization and targeted output extensions, useful for debugging intermediate representations or generating structured logs. Examples include printing annotated function definitions with optional braces or custom-formatted analysis states during program verification.",
      "description_length": 688,
      "index": 3268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadModule",
      "library": "frama-c.kernel",
      "description": "This module manages a string list collection to configure command-line parameters for dynamic module loading, supporting addition, iteration, folding, and list manipulation. It tracks and reacts to changes in module load paths, enabling plugin initialization through Frama-C's CLI, and defines structured values for loadable kernel modules with operations for comparison, serialization, and deep copying. It works with categories like `@none`, `@default`, and `@all` to control module loading behavior, and provides utilities for validated string parameters, including support for aliases, syntax enforcement, and stateful configuration. Examples include setting default load categories, validating user-provided module names, and serializing module configurations across analysis sessions.",
      "description_length": 790,
      "index": 3269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Syntactic_search",
      "library": "frama-c.kernel",
      "description": "Performs syntactic searches for variables within specified scopes using original names. Works with `Cil_types.syntactic_scope` and `varinfo` to locate variables based on naming and scope constraints. Useful for analyzing or transforming code by identifying variable declarations in specific syntactic contexts during static analysis.",
      "description_length": 333,
      "index": 3270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_sig.S-Make_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements efficient narrowing operations for intersecting interval maps with arbitrary values, focusing on handling numeric representations with and without bitwise reinterpretation. Provides two key functions: `narrow` for strict over-approximated intersections that may lose soundness due to representation differences, and `narrow_reinterpret` for more accurate intersections by normalizing values before comparison. Useful in static analysis contexts where precise merging of abstract numeric ranges is required, such as in value analysis or program verification tools.",
      "description_length": 574,
      "index": 3271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic2-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype combining two existing datatypes, supporting operations like equality, comparison, hashing, and pretty-printing. It works with structured data of type `(T1.t, T2.t) poly`, enabling deep copies and membership checks over project skeletons. Concrete use cases include defining composite values for abstract interpretation domains and managing structured analysis data in Frama-C plugins.",
      "description_length": 428,
      "index": 3272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Code_annotation",
      "library": "frama-c.kernel",
      "description": "This module handles code annotations in CIL with operations for equality, comparison, hashing, and pretty-printing, centered around the `code_annotation` type. It enables analysis and transformation of C code by tracking source locations and managing sets and maps of annotated elements. The module supports ordered sets for union, intersection, and ordered traversal; hash tables for imperative mapping with custom key comparisons; and functional maps preserving key order for structured data manipulation. Examples include tracking analysis metadata, storing per-annotation results, and implementing transformations across CIL constructs.",
      "description_length": 640,
      "index": 3273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are bases and values are memory maps, specifically using the `Offsetmap` module's memory map type. It provides standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate memory states associated with different program bases in static analysis tasks.",
      "description_length": 418,
      "index": 3274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Undefined",
      "library": "frama-c.kernel",
      "description": "This module provides placeholder implementations for a datatype's required operations, typically used when defining custom data types that lack meaningful structural properties. It includes stubs for equality, comparison, hashing, copying, and pretty-printing, all of which raise undefined exceptions. Use this module when implementing a datatype that does not support these operations or when they are irrelevant to the type's semantics.",
      "description_length": 438,
      "index": 3275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Ref",
      "library": "frama-c.kernel",
      "description": "This module implements reference cells for a given type `T`, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports deep copying and membership testing within project skeletons, making it suitable for scenarios requiring value tracking and manipulation across analysis states. Concrete use cases include managing mutable state in static analysis plugins and ensuring value uniqueness during program transformation passes.",
      "description_length": 468,
      "index": 3276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module represents maps with a lattice structure, where each value in the map is of a specified data type. It provides operations for equality, comparison, hashing, pretty printing, and deep copying of maps, along with functions to check membership based on project conditions and manage type descriptors. It is used to handle structured data mappings in static analysis contexts, such as tracking variable states or abstract values across program points.",
      "description_length": 459,
      "index": 3277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.Attributes",
      "library": "frama-c.kernel",
      "description": "This module defines how to visualize a state dependency graph by specifying attributes for nodes, edges, and the overall graph when generating DOT output. It maps internal state objects to visual properties like labels and colors, enabling tools like Graphviz to render the graph structure. It is used to generate human-readable diagrams of program state dependencies in static analysis.",
      "description_length": 387,
      "index": 3278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Quadruple",
      "library": "frama-c.kernel",
      "description": "This module implements a quadruple data structure as a product of four arbitrary types, equipped with standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing for project skeletons, and provides type descriptors for integration with Frama-C's internal machinery. Concrete use cases include representing compound values in abstract interpretation domains or structured annotations within Frama-C plugins.",
      "description_length": 473,
      "index": 3279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string list data type with operations for equality, comparison, hashing, and pretty-printing. It supports command-line option handling by providing structured representations and descriptors for integration with Frama-C's option parsing system. Use cases include defining and managing lists of strings as plugin configuration options.",
      "description_length": 359,
      "index": 3280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder.Exp",
      "library": "frama-c.kernel",
      "description": "This module constructs and manipulates expressions for static analysis, supporting arithmetic, logical, bitwise, and memory operations on CIL expressions (e.g., `exp`, `lval`) and types (`typ`, `logic_type`). It handles data structures like constants, variables, initializers, and polymorphic variants representing program constructs, enabling tasks such as type conversion, validity checks (e.g., memory safety), and integration of logic terms with C expressions. Specific use cases include building C/ACSL expressions without explicit location handling, analyzing memory states, and constructing compound expressions for static verification.",
      "description_length": 643,
      "index": 3281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Full_Lattice",
      "library": "frama-c.kernel",
      "description": "This module provides operations for over- and under-approximating joins, meets, intersections, and differences on a lattice data type `t`, along with comparison, hashing, pretty-printing, and deep-copying utilities. It is designed for abstract interpretation in static analysis, enabling precise approximation of program value ranges or reachable states, where the `diff` function specifically handles set differences by requiring one operand to be an under-approximation for controlled precision in narrowing analyses.",
      "description_length": 519,
      "index": 3282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Filepath",
      "library": "frama-c.kernel",
      "description": "This module represents filepaths as type-safe, normalized strings with built-in support for equality, comparison, and hashing, ensuring reliable path handling in static analysis workflows. It provides direct operations on filepaths while integrating with submodules for maps, hash tables, and sets to manage collections and associations efficiently. For example, you can use it to track per-file analysis states in a hash table, store metadata in a type-safe map, or compute dependencies using ordered filepath sets. The combined interface guarantees consistent path manipulation, safe key-based access, and deterministic traversal across complex Frama-C plugin operations.",
      "description_length": 673,
      "index": 3283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl",
      "library": "frama-c.kernel",
      "description": "This module provides hashconsing tables for efficient state management with operations like `merge`, `add`, and `find`, ensuring consistent and shared data instances across analyses. It supports arbitrary data types through the `Data` module and adapts its table behavior based on `Cmdline.deterministic`, using either weak or non-weak hashing strategies. The child module extends this functionality by enabling creation, comparison, and pretty-printing of hashconsed values, along with deep copying and project-specific membership checks. Together, they facilitate caching and immutable, interned representations of program elements such as types, expressions, and analysis states.",
      "description_length": 682,
      "index": 3284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-based datatype with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project values, and a list of representative values for the datatype. It is used to manage string data within Frama-C plugins, enabling storage, comparison, and display of string values in a type-safe manner.",
      "description_length": 383,
      "index": 3285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages named categories for plugin parameters, supporting operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with strings for category names, `Frama_c_kernel.State.t` lists for dependencies, and `Parameter_category` accessors to link categories to parameters. Concrete use cases include setting up configurable behavior groups for plugin options and controlling default or global behavior through category inheritance and activation.",
      "description_length": 502,
      "index": 3286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_info",
      "library": "frama-c.kernel",
      "description": "This module organizes logic type information with rich operations for equality, comparison, hashing, and pretty-printing, centered around the `logic_type_info` type that captures logical metadata in CIL. It integrates hash tables, ordered sets, and associative maps to support efficient lookups, set operations, and key-based data organization, all tied to Frama-C's typing and project system. Use it to track type constraints across analysis phases, memoize type-based computations, or manage structured transformations with ordered key queries and persistent metadata. Submodules refine these capabilities with specialized keys, project-aware operations, and utilities for abstract interpretation and static analysis plugins.",
      "description_length": 727,
      "index": 3287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Qstack.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a mutable double-linked list-based structure supporting O(1) insertion at both ends, element access via top, membership checks, filtering, and positional queries through the idx function. It operates on elements of type D.t, enabling in-place transformations via map, iterative processing with iter, and index-based lookups. The design suits scenarios requiring efficient bidirectional modifications while preserving element order, such as algorithmic processing pipelines or data structure implementations needing both stack and queue characteristics.",
      "description_length": 575,
      "index": 3288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Make",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive framework for working with both immutable and mutable data structures, supporting set-like and map-like operations with strong semantic guarantees. It enables purely applicative transformations over ordered sets and maps, with operations such as union, intersection, and map filtering, while also supporting imperative hash tables for efficient caching and memoization. The module handles custom element types with project-specific equality, comparison, and hashing, allowing for deep copying, structural introspection, and traversal strategies tailored to static analysis or symbolic computation. Examples include maintaining persistent analysis data across Frama-C plugin runs, optimizing performance with hash-based lookups, and performing precise set-theoretic operations over ordered types.",
      "description_length": 832,
      "index": 3289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Verbose-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C's plugin system. It supports structured data representation with a descriptor and provides deep copying, membership testing within projects, and a list of representative values. Concrete use cases include managing and manipulating analysis results or configuration data within Frama-C plugins.",
      "description_length": 424,
      "index": 3290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Queue",
      "library": "frama-c.kernel",
      "description": "Implements a stateful queue for managing elements of type `Data.t` within Frama-C's state builder framework. Provides operations to add elements, iterate over the queue, fold over its contents, and check its size or emptiness. Useful for tracking and processing sequences of analysis events or intermediate results in static analysis plugins.",
      "description_length": 342,
      "index": 3291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a hash table type indexed by values of a given `Data` module, supporting standard operations like equality, comparison, hashing, and pretty printing. It provides deep copying, membership testing with project functions, and type descriptors for integration with the kernel's type system. Concrete use cases include managing sets of project-specific values with efficient lookups and ensuring type-safe storage of heterogeneous data in the analysis kernel.",
      "description_length": 474,
      "index": 3292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfig",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls command-line behavior, offering functions to set and retrieve its state, register change notifications, and handle alternative option names. It operates on a custom type `t` that encapsulates the boolean value and metadata, synchronized through an internal state variable, enabling use cases like customizing configuration output and integrating with command-line parsers. The child module enhances this by defining structured operations on `t`, including equality, comparison, hashing, and pretty-printing, supporting tasks such as persisting and comparing kernel configuration states. Together, they allow precise control and manipulation of configuration settings, such as enabling project-specific state persistence or serializing internal settings for debugging.",
      "description_length": 832,
      "index": 3293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Share",
      "library": "frama-c.kernel",
      "description": "This module manages the retrieval and validation of directories and files within a predefined site directory, primarily used for locating plugin-specific resources. It provides operations to set or check the site directory path and to resolve specific directories or files by name, ensuring they exist and are of the correct type. Concrete use cases include loading plugin configurations, scripts, or assets stored in a shared directory during analysis.",
      "description_length": 453,
      "index": 3294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.UnsignedDowncast",
      "library": "frama-c.kernel",
      "description": "This module manages the behavior of unsigned downcast warnings by controlling a boolean flag that determines whether diagnostics are emitted during static analysis. It provides operations to set, get, and toggle the flag, which integrates with project state and command-line configuration through options like `-warn-unsigned-downcast`. The child module extends this functionality by defining a type `t` that encapsulates the warning state, offering utilities for comparison, copying, and project-aware inspection. Together, they enable precise control over unsigned integer conversion warnings, allowing dynamic adjustment and persistent tracking within analysis sessions.",
      "description_length": 673,
      "index": 3295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements a value type for strings with operations for comparison, hashing, serialization, and project membership checks. It supports string-based data representations with strict equality, ordering, and pretty-printing, tailored for static analysis contexts. Use cases include handling string identifiers, configuration values, or symbolic expressions in Frama-C plugins.",
      "description_length": 385,
      "index": 3296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Int_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides an imperative hash table for integer keys mapping to structured data, combining standard operations like insertion, iteration, and lookup with advanced state management features such as change tracking, marshaling, and project-specific serialization. It supports deep manipulation of stored values through equality checks, comparison, and pretty-printing, enabling precise state evolution tracking and dependency-aware computations. The design facilitates use cases like dynamic caching, analysis state persistence, and plugin-driven static analysis where integer keys index complex, versioned data. Submodules enhance this functionality with utilities for state construction, deep copying, and structured value inspection.",
      "description_length": 744,
      "index": 3297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SimplifyCfg",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls control-flow graph simplification during static analysis, directly affecting analysis precision by enabling or disabling graph transformations. It provides functions to set, query, and monitor the flag, integrating with the command line and supporting project-specific persistence. The child module defines a data type `t` with operations for equality, comparison, and pretty-printing, used to manipulate and reason about abstract values tied to the simplification process. Together, they enable precise control and representation of CFG simplification data within Frama-C's analysis pipeline.",
      "description_length": 656,
      "index": 3298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.StartData",
      "library": "frama-c.kernel",
      "description": "This module manages statement-indexed data storage for data flow analyses, providing operations to add, retrieve, and iterate over analysis data associated with specific statements. It works with user-defined data types through the `X` module parameter and uses a hash table internally for efficient access. Concrete use cases include tracking initial analysis states at function entry points or maintaining per-statement metadata during static analysis.",
      "description_length": 454,
      "index": 3299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Top_Opt",
      "library": "frama-c.kernel",
      "description": "This module represents lattices that may include a top element, providing operations to manipulate lattice values with the possibility of absence. It works with lattice structures where the top element is optional, enabling precise handling of partial or incomplete information. Concrete use cases include abstract interpretation frameworks where the presence or absence of a maximal element affects analysis precision.",
      "description_length": 419,
      "index": 3300,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgsPerFile",
      "library": "frama-c.kernel",
      "description": "This module manages per-file C preprocessor arguments through a structured map from file paths to string values, supporting operations to set, update, and query entries with change notifications, default handling, and serialization. It organizes configurations using categories such as `@none`, `@default`, and `@all`, enabling conditional compilation and project-specific static analysis workflows by associating files with custom argument groups. String-based parameters are validated against constraints like syntax rules, with support for aliases, marshaling, and transformation, ensuring correctness and flexibility in command-line and project settings. It also provides equality, comparison, and pretty-printing operations for argument configurations, facilitating precise control and analysis of per-file preprocessor flags.",
      "description_length": 831,
      "index": 3301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_info_structural",
      "library": "frama-c.kernel",
      "description": "This module manages logic function symbols with structural comparison, tracking their names and argument types while disregarding polymorphic type variables. It provides core operations for equality, comparison, hashing, and pretty printing, enabling precise identification of logic symbols in static analysis. Child modules extend this foundation with specialized data structures: hash tables for mutable symbol tracking, polymorphic maps for type-sensitive logic bindings, and structured sets for signature management and dependency resolution. These components together support tasks like memoization, cross-unit symbol analysis, and transformation of logic functions based on structural identity.",
      "description_length": 700,
      "index": 3302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_user_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module constructs and manages a user directory option derived from an existing user directory configuration. It provides operations to retrieve or create directories and files within the directory, set or check the directory path, and access its configuration. Use cases include handling plugin-specific storage paths, managing temporary or persistent files, and organizing user-defined directories in a structured way.",
      "description_length": 424,
      "index": 3303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_templates",
      "library": "frama-c.kernel",
      "description": "This module manages project-scoped key-value associations with string keys and `builtin_template` values, providing operations to insert, replace, retrieve, and iterate while integrating change tracking, memoization, and serialization. It ensures correct handling of project-specific hashtables, avoiding issues with custom rehash functions in analysis contexts such as dynamic configuration of built-in function templates. The child module defines a datatype with custom equality, comparison, and hashing, supporting deep copying and membership checks over project skeletons, enabling structured analysis data management in plugins. Together, they facilitate precise, project-aware storage and manipulation of analysis artifacts with strong identity and dependency guarantees.",
      "description_length": 777,
      "index": 3304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Log.Register",
      "library": "frama-c.kernel",
      "description": "This module provides structured logging and diagnostic utilities for Frama-C plugins, enabling message output with customizable severity levels (e.g., debug, warning, error) and categories. It operates on formatted messages, source positions, and warning statuses, supporting features like conditional execution, deprecation handling, and dynamic debug channel activation. Use cases include suppressing specific warnings, pretty-printing diagnostic output, and managing verbosity thresholds for analysis tools.",
      "description_length": 510,
      "index": 3305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for working with lists as non-deterministic computations. It includes bind, map, and product combinators that enable chaining and combining list values in a monadic context. Concrete use cases include generating combinations of input values, sequencing non-deterministic transformations, and mapping functions over list-based computations.",
      "description_length": 379,
      "index": 3306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-WithOutput",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean command-line options and output control in Frama-C plugins, including value setting/retrieval, state change hooks, and dependency-driven output logic. It works with boolean values (`t`) and project-specific state management structures, enabling use cases like conditional result display based on plugin dependencies or dynamic CLI option updates during analysis. The interface supports customizing serialization, equality checks, and output execution paths for efficient plugin interaction with Frama-C's kernel.",
      "description_length": 565,
      "index": 3307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a command-line option builder for a list of strings, handling parsing, default values, and user-provided inputs. It works with string lists as both internal values and command-line representations, supporting operations like appending, checking membership, and pretty-printing. Concrete use cases include configuring analysis targets, specifying include paths, or collecting user-defined tags during plugin initialization.",
      "description_length": 445,
      "index": 3308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.Simple_forward",
      "library": "frama-c.kernel",
      "description": "Implements a forward data flow analysis over a user-defined domain, computing pre- and post-states for statements based on a transfer function. Works with statements from CIL and a user-supplied property type `P.t`, initializing analysis from `P.init`. Use to propagate information such as constant values, variable dependencies, or taint tracking across a function's control flow graph.",
      "description_length": 387,
      "index": 3309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.S-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation with descriptors, type information, and deep copying, enabling precise handling of complex values. Concrete use cases include managing and comparing abstract syntax tree nodes, analysis results, or configuration settings in static analysis tools.",
      "description_length": 409,
      "index": 3310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.False_ref",
      "library": "frama-c.kernel",
      "description": "This module provides a mutable boolean reference initialized to false, offering functions to get, set, and reset its value. It includes support for state comparison, hashing, serialization, and deep copying, along with hooks to trigger actions on state changes. The module enables tracking of analysis phases or condition flags in static analysis tools, with child modules extending its capabilities for structured state management and project-specific predicates.",
      "description_length": 464,
      "index": 3311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Cardinal_One",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations for values that can only be in one of two states, typically used to model presence or absence of information. It restricts the lattice to a singleton or bottom element, enabling precise and efficient analysis in static verification contexts. Useful in scenarios like tracking uninitialized variables or ensuring definite assignment.",
      "description_length": 362,
      "index": 3312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S",
      "library": "frama-c.kernel",
      "description": "This module defines a monadic interface with standard operations like `return`, `bind`, `map`, and `flatten`, enabling structured handling of effectful computations. It includes specialized submodules for common data types such as `Option`, `List`, and `Bool`, each implementing monadic behavior tailored to the type. Use cases include sequencing parser steps, managing optional values in analysis passes, and composing stateful transformations in static analysis plugins.",
      "description_length": 472,
      "index": 3313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List_with_collections",
      "library": "frama-c.kernel",
      "description": "This module provides a list type with equality, comparison, and pretty-printing, designed for structured value collections in static analysis. It includes submodules for ordered maps with polymorphic values, hash tables with sorted traversal and in-place updates, and ordered sets with immutable semantics and proximity queries. Operations span element-wise transformations, deep copying, membership checks, and ordered aggregations, supporting use cases like variable tracking, memoization, and dependency management. The combined interface enables structured, project-aware collection manipulation with consistent comparison, hashing, and sequence conversion across lists, maps, hash tables, and sets.",
      "description_length": 703,
      "index": 3314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl_with_descr",
      "library": "frama-c.kernel",
      "description": "This module offers a hash table implementation with typed keys and arbitrary values, supporting standard operations like insertion, deletion, and lookup alongside advanced features such as ordered iteration, bulk sequence conversion, and in-place filtering. It enables sorted traversal by keys or values, safe value retrieval via `find_opt`, and memoization, making it suitable for applications requiring structured key-value storage with customizable ordering or bulk data manipulation. The design accommodates dynamic resizing, statistical tracking, and efficient sequence-based initialization, ideal for scenarios like processing ordered datasets or implementing caching mechanisms.",
      "description_length": 685,
      "index": 3315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintMachdepHeader",
      "library": "frama-c.kernel",
      "description": "This module controls a boolean kernel option that determines whether machine-dependent headers are emitted during analysis, allowing the state to be toggled, observed, and persisted across projects. It provides hooks for reacting to state changes and integrates with command-line interfaces for runtime configuration. The core state is a boolean flag augmented with metadata, manipulated through operations like set, get, and register, while child modules handle architecture-specific data structures used in header generation. Examples include enabling headers for debugging analysis output or suppressing them in automated pipelines to reduce verbosity.",
      "description_length": 655,
      "index": 3316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map with operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to handle string-based keys with associated values, supporting deep copying and project membership checks. Concrete use cases include managing analysis results or configuration settings indexed by strings within Frama-C plugins.",
      "description_length": 365,
      "index": 3317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_not_weak",
      "library": "frama-c.kernel",
      "description": "This module provides a non-weak hash table for hashconsing, ensuring stable storage and exact reproducibility of keys across runs. It supports operations like `merge`, `find`, and `add`, along with tracking via `mark_as_computed` and `is_computed`, enabling persistent state management for canonical instances. The child module extends this with strong references, offering equality, comparison, hashing, and deep copy operations, while supporting membership tests and pretty printing. Together, they enable consistent handling of structured values in static analysis tools, where reproducibility and identity preservation are critical.",
      "description_length": 636,
      "index": 3318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-WithOutput-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with comprehensive operations for equality, comparison, hashing, and pretty printing, tailored for use in Frama-C's plugin system. It supports structured data representation with a descriptor, packed representation, and deep copying to ensure value integrity. Concrete use cases include managing analysis results, storing and comparing abstract values, and enabling persistent, project-aware data manipulation in static analysis plugins.",
      "description_length": 468,
      "index": 3319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SpecialFloat",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued configuration options for handling special floating-point behaviors, enabling validation, retrieval, and modification of values with support for custom hooks, aliases, and state serialization. It defines a core data type `t` for representing floating-point values with operations for equality, comparison, hashing, pretty-printing, and deep copying, ensuring safe manipulation without shared state. The module supports defining and enforcing float-handling policies, validating string literals or function names against constraints, and persisting configuration states across sessions. It integrates with Frama-C's kernel to manage internal representations under the `-warn-special-float` option, facilitating analysis and transformation tasks in plugins.",
      "description_length": 789,
      "index": 3320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Set",
      "library": "frama-c.kernel",
      "description": "This module implements ordered, immutable sets with lattice-compatible operations for combining, transforming, and querying element collections. It provides standard set manipulations (union, intersection, difference), ordered iteration, filtering, and structural queries (subset checks, cardinality) over elements maintained via a comparison function, supporting efficient analysis of hierarchical or partially ordered data. Use cases include static analysis tasks requiring precise set merging, ordered element traversal, or conditional membership checks in lattice-based abstract domains.",
      "description_length": 591,
      "index": 3321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Bounded_Join_Semi_Lattice",
      "library": "frama-c.kernel",
      "description": "This module defines a bounded join semi-lattice structure with operations for element comparison, inclusion, and joining. It works with a specific data type `t` that represents lattice elements, supporting deep copying, membership testing within projects, and pretty printing. Concrete use cases include abstract interpretation domains where elements must be combined or compared during fixpoint computations.",
      "description_length": 409,
      "index": 3322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.ForwardsTransfer",
      "library": "frama-c.kernel",
      "description": "Implements a forward dataflow analysis interface with operations to compute and combine data across statements, handle instruction and branch effects, and manage state transitions. It works with a user-defined data type `t` representing analysis states, and CIL statements and expressions for traversing program control flow. Concrete use cases include tracking variable ranges, constant propagation, or liveness information through program points during static analysis.",
      "description_length": 471,
      "index": 3323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements imperative hash tables for normalized filepaths, supporting efficient storage, retrieval, and transformation of key-value pairs with customizable comparisons for ordered traversal. It provides core operations like insertion, deletion, in-place filtering, and memoization, while its child modules define a key type with project-aware utilities and a specialized hash table for type-safe filepath-indexed data. You can use it to manage file-level analysis results in static analysis tools or cache computations per file, leveraging deep copying and project membership checks to handle complex file contexts. Sorted iteration and bulk operations enable structured processing pipelines where ordering and efficiency are critical.",
      "description_length": 748,
      "index": 3324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_pretty",
      "library": "frama-c.kernel",
      "description": "This module defines operations for pretty-printable CIL datatypes, including equality, comparison, hashing, and deep copying. It provides a structured way to describe and manipulate values with a unique name, type, and descriptor, supporting precise pretty-printing and project-aware membership checks. Concrete use cases include managing and comparing CIL expressions, types, or statements in Frama-C plugins.",
      "description_length": 410,
      "index": 3325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.FileIndex",
      "library": "frama-c.kernel",
      "description": "This module manages global C symbols associated with source files, providing access to symbols, variables, functions, and annotations per file. It supports querying global entities like variables, functions, and annotations for specific files, and includes functionality to retrieve and filter functions based on declarations. Use cases include analyzing or transforming global definitions in C files, such as extracting function signatures or processing global variable initializations.",
      "description_length": 487,
      "index": 3326,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hpath.Names",
      "library": "frama-c.kernel",
      "description": "This module tracks associations between Hpath values and strings, offering operations to add, remove, and retrieve these mappings. It maintains an internal registry that can be reset, extended with new entries, or queried for all stored pairs. Useful for managing named references to Hpath elements during analysis phases where persistent labeling is required.",
      "description_length": 360,
      "index": 3327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with category types and state lists to control plugin behavior through accessors. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific accessors, or aliasing the `@all` category to another category.",
      "description_length": 435,
      "index": 3328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqSized",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and comparison for CIL expressions, normalizing expressions within `sizeof` based on operand type size rather than identity. It provides core operations like `equal`, `compare`, `hash`, and `pretty`, along with standard data structures such as `Set`, `Map`, and `Hashtbl` that respect this equivalence. The associated modules support ordered traversal, set algebra, and efficient lookups, enabling tasks like static analysis, redundancy elimination, and size-aware expression indexing. For example, it can merge maps of analyzed expressions, perform ordered traversal over normalized keys, or track equivalent expressions in dataflow analysis where structural and size-based equivalence are critical.",
      "description_length": 740,
      "index": 3329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filled_string_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with strings, state lists, and category types to structure option handling. Concrete use cases include setting up default and special categories like '@all' and '@none', enabling all options with specific interpretations, and redefining '@all' to behave like another category.",
      "description_length": 470,
      "index": 3330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic2",
      "library": "frama-c.kernel",
      "description": "This module handles instantiation and inspection of polymorphic type constructors with two parameters, enabling creation of type instances by applying arguments and checking if a type matches a constructor. It supports operations to retrieve applied type arguments and analyze parameterized types like tuples or result types in static analysis. The child module combines two distinct types into a composite datatype, supporting equality, comparison, hashing, and pretty printing for structured data analysis. Together, they allow modeling and manipulating pairs of values with different type behaviors, such as combining memory states with control flow information in analysis plugins.",
      "description_length": 685,
      "index": 3331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.DataflowAnalysis-Result",
      "library": "frama-c.kernel",
      "description": "This module provides operations to query and iterate over analysis results at specific control points in an interpreted automaton, such as entry, return, and before/after given statements. It works with control flow graph vertices and abstract states, enabling precise inspection of dataflow analysis outcomes. Concrete use cases include extracting state information at function boundaries, traversing reachable states in a defined order, and exporting results to DOT format for visualization or external processing.",
      "description_length": 516,
      "index": 3332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep.Machdep",
      "library": "frama-c.kernel",
      "description": "This module represents machine-dependent configurations with a data type `t`, offering equality, comparison, hashing, and pretty-printing operations. It supports structured manipulation through deep copying, project membership testing, and serialization, enabling precise tracking of architecture-specific values across analysis phases. Its submodules provide hash tables and ordered maps keyed by machine configurations, facilitating efficient storage and retrieval of polymorphic data with strong identity and ordering guarantees. Additionally, the ordered set module allows set-theoretic operations and ordered traversal over unique machine-dependent values, useful for managing platform-specific state in static analysis pipelines.",
      "description_length": 735,
      "index": 3333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This component offers operations for managing string-valued plugin parameters with support for validation, state tracking, and command-line interface integration. It works with string data constrained by allowed value lists or C function name validation, enabling use cases like plugin configuration options, static analysis parameterization, and persistent state management through value change hooks and alias handling.",
      "description_length": 421,
      "index": 3334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types and state lists to control option behavior, particularly handling special categories like `@none`, `@default`, and `@all`. Concrete use cases include setting default category behavior, enabling all options under a category, and defining how the `@all` category interacts with other states.",
      "description_length": 490,
      "index": 3335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad.Make",
      "library": "frama-c.kernel",
      "description": "This module implements a state monad for managing computations that manipulate a global environment, providing core operations like `return`, `bind`, and `map`, along with utilities to retrieve, update, and run stateful computations. Its submodules extend this functionality with infix operators for concise chaining, conditional execution via `only_if`, list operations for stateful traversals, and utilities for handling optional values within stateful contexts. You can use it to sequence stateful actions, selectively apply transformations based on conditions, accumulate state across lists, and handle optional values that affect the environment. Examples include static analysis passes that track variable usage, logging conditionally based on flags, or transforming ASTs while maintaining shared state.",
      "description_length": 809,
      "index": 3336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a key-value map without multibindings, supporting insertion, lookup, modification, and iteration over key-value pairs. It works with data structures defined by modules `K` (keys) and `V` (values), leveraging `Datatype` for map representation and `As_string`/`Category` for string conversion and categorization. It is used in Frama-C plugins to handle configuration parameters, track analysis results, or persist state across sessions via command-line options and project state integration.",
      "description_length": 534,
      "index": 3337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_set_and_map",
      "library": "frama-c.kernel",
      "description": "This module generates a structured data type with built-in equality, comparison, and hashing, along with companion set and map modules for efficient collection management. It enables defining rich, comparable data types that support operations such as ordered traversal, membership testing, and transformation, with sets offering union, intersection, and filtering, and maps providing key-based association with insertion, lookup, and merging. Examples include modeling program elements indexed by identifiers, managing symbol tables with ordered keys, and performing static analysis tasks requiring precise set-theoretic or associative computations. The combined interface supports both direct manipulation of structured values and advanced collection operations through its submodules.",
      "description_length": 787,
      "index": 3338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabshelper.Comments",
      "library": "frama-c.kernel",
      "description": "This module manages comments associated with Cabs locations using a stateful store. It provides operations to add, retrieve, iterate over, and fold across comments linked to specific Cabs location identifiers. Useful for tracking and manipulating source code annotations during static analysis tasks.",
      "description_length": 300,
      "index": 3339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic4",
      "library": "frama-c.kernel",
      "description": "This module defines a functor for creating polymorphic types with four type variables, enabling instantiation, type checking, and parameter retrieval. It supports operations such as equality, comparison, hashing, and pretty printing through its child module, allowing the composition of complex structured values from arbitrary component types. For example, it can represent analysis data combining expressions, environments, states, and annotations into a single type with full structural operations. The combined interface facilitates defining and manipulating parameterized data structures in static analysis plugins.",
      "description_length": 620,
      "index": 3340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Pair_with_collections",
      "library": "frama-c.kernel",
      "description": "This module combines pairs of values from two distinct types into a composite type with full support for equality, comparison, hashing, and pretty-printing. It integrates collection modules for ordered sets, hash tables, and ordered maps, enabling both functional and imperative manipulation of pair-based data structures. You can, for example, create a set of pairs representing intervals, build a hash table mapping pairs to analysis results, or track variable bindings in a static analysis using ordered maps. The combination of pair operations and collection functionality supports precise, structured data management in scenarios like program analysis and symbolic computation.",
      "description_length": 682,
      "index": 3341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-Service_graph",
      "library": "frama-c.kernel",
      "description": "This module supports querying, traversing, and modifying directed graphs with imperative updates, enabling analysis of dependencies and flows in structured data. It operates on graphs composed of vertices (via module `V`) and edges (via module `E`), offering operations like adjacency checks, degree calculations, and in-place vertex/edge insertion or removal. Typical applications include constructing and analyzing callgraphs for program dependency tracking, where dynamic graph updates and reachability queries are critical for static analysis workflows.",
      "description_length": 557,
      "index": 3342,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.FCHashtbl.Make",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations including creation, insertion, deletion, and iteration, along with advanced features like in-place filtering, sequence conversion, and ordered traversal. It operates on polymorphic hash tables (`'a t`) with keys of type `H.t`, supporting bulk updates from sequences, sorted iteration over keys/values, and memoization patterns. Specific use cases include managing dynamic mappings with ordered access, transforming hash tables via functional combinators, and safely retrieving values with default handling.",
      "description_length": 560,
      "index": 3343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.With_Diff_One",
      "library": "frama-c.kernel",
      "description": "This module computes the difference between two lattice elements, returning an over-approximation of the result as an optional bottom value. It operates on lattice elements of type `t`, specifically handling cases where the difference may be undefined or empty. A concrete use case is in static analysis for tracking value ranges or memory states, where precise difference computation aids in detecting changes or invariants.",
      "description_length": 425,
      "index": 3344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option collections, providing operations to define, retrieve, and configure categories such as `@none`, `@default`, and `@all`. It works with category types and state lists, allowing the association of accessors and dependencies with named categories. Concrete use cases include setting up option groups, enabling all options with specific interpretations, and redirecting `@all` to another category.",
      "description_length": 448,
      "index": 3345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List.Bool",
      "library": "frama-c.kernel",
      "description": "Implements conditional inclusion of elements in non-deterministic list computations. Provides the `only_if` function that filters a list based on a boolean condition, allowing the list to represent branching possibilities. Useful for modeling conditional execution paths in static analysis where control flow depends on runtime values.",
      "description_length": 335,
      "index": 3346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filesystem.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides infix operators `let+`, `let*`, and `let$` for handling file operations with result and exception semantics. It works with file channels and functions that process them, enabling concise error handling and chaining of operations. Concrete use cases include reading from or writing to files while managing errors inline, such as parsing a configuration file or logging data with minimal boilerplate.",
      "description_length": 419,
      "index": 3347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line parameters that represent collections of C functions (`Frama_c_kernel.Cil_types.fundec`), supporting operations like membership checks, set modification, iteration, and predicate-based filtering. It integrates state management, serialization, and project-specific value tracking, with utilities for handling aliases and default values. Typical use cases include configuring static analysis scopes by specifying function sets to include/exclude or triggering analysis phases when specific functions are added.",
      "description_length": 550,
      "index": 3348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lval",
      "library": "frama-c.kernel",
      "description": "This module represents CIL l-values with operations for structural manipulation, comparison, and storage, centered around the `Lval.t` type. It supports equality checks, hashing, pretty-printing, and deep copying, while its submodules provide ordered sets, hash tables, and maps for efficient collection management and lookup based on eid. The set module enables ordered traversal, filtering, and nearest-element searches, the hash table module supports imperative data storage with structural keys, and the map module offers persistent, ordered key-value associations with customizable equality. These features facilitate static analysis tasks such as tracking variable assignments, caching expression results, and managing memory states across C code transformations.",
      "description_length": 769,
      "index": 3349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Custom",
      "library": "frama-c.kernel",
      "description": "This module enables state management through value retrieval, update hooks, and serialization for a custom type `t`, while also supporting the definition of CLI parameters with custom types, including value constraints and metadata. It operates on `t` (aliased from `V.t`) for tracking project-specific state and `Typed_parameter.t` for typed parameter handling with visibility controls. These features are used to implement configurable command-line options with validation and maintain persistent plugin state across Frama-C sessions.",
      "description_length": 536,
      "index": 3350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys and values are of type `Data.t`, a field element. It provides standard operations like equality, comparison, hashing, and pretty-printing for these hash tables, along with type descriptors for integration with the Frama-C kernel. It supports deep copying, project membership checks, and maintains a list of representative values for the type.",
      "description_length": 389,
      "index": 3351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph.Node",
      "library": "frama-c.kernel",
      "description": "This module maps elements of a key type to Dot graph nodes, generating unique identifiers and managing their attributes. It supports creating labeled nodes, records, and indexed nodes with custom attributes, writing them into a Dot file buffer. Use it to visualize structured data like control flow graphs or abstract syntax trees by associating each node with a graphical representation.",
      "description_length": 388,
      "index": 3352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S",
      "library": "frama-c.kernel",
      "description": "This module implements polymorphic set operations for ordered elements, supporting membership checks, insertion, deletion, union, intersection, and difference, along with advanced transformations like merging and heterogeneous folding using customizable decision functions. It integrates with maps and hashtables, offering cache-aware operations and project-specific membership queries, while enabling conversions to lists and deep copies for immutable data management. It is particularly suited for static analysis tasks requiring precise tracking of program entities, context-sensitive comparisons, and efficient handling of nested or interdependent data structures.",
      "description_length": 668,
      "index": 3353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module implements operations for managing string-based command-line parameters with validation, dynamic value constraints, and extensible behavior through hooks and aliases. It operates on string values that can be restricted to predefined sets, validated as function names, or treated as plain strings, supporting use cases like restricted input options, stateful parameter handling, and command-line interface customization. The design emphasizes safe parsing, project-specific state management, and integration with option serialization frameworks.",
      "description_length": 556,
      "index": 3354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.States",
      "library": "frama-c.kernel",
      "description": "This module provides operations to iterate over, fold, and retrieve values of registered states within a project. It works with state values of type `'a` encapsulated in `Frama_c_kernel.Type.t`, along with their metadata such as name and computed status. Concrete use cases include inspecting or transforming all current state values, checking the existence and status of a specific state, and aggregating state data across analysis runs.",
      "description_length": 438,
      "index": 3355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.LvalStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module enforces structural equality and strict constant comparison for CIL lvalues, enabling precise semantic analysis of C abstract syntax structures. It offers core operations like `equal`, `compare`, `hash`, and `pretty`, along with container modules for sets, maps, and hash tables that support efficient manipulation and exact identity tracking of lvalues. These tools facilitate static analysis tasks such as memory state tracking, alias analysis, and deterministic transformation of CIL representations. For example, it can distinguish subtly different expressions, cache analysis results for identical structures, or maintain strict ordering and uniqueness in collections of program elements.",
      "description_length": 705,
      "index": 3356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "Supports defining, validating, and modifying string parameters with controlled allowed values and dynamic state handling. Operates on string data, enforcing validation rules against predefined lists or function name syntax, and supports use cases like plugin configuration where values must be checked before updates or persisted across sessions.",
      "description_length": 346,
      "index": 3357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fundec",
      "library": "frama-c.kernel",
      "description": "This module organizes function definition data (CIL `fundec`) within a project-aware, customizable hashtable, enabling efficient lookups, transformations, and change tracking with support for custom marshaling and lifecycle monitoring. It provides core operations like `find_all`, `mem`, `remove`, and `to_seq`, while its child module defines a diff-aware function declaration type with equality, hashing, and pretty-printing for accurate AST comparison across project versions. Together, they support tasks such as semantic diffing of C function definitions and incremental analysis updates based on modified code. The combination allows both fine-grained inspection of function signatures and efficient global management of definition state within a project.",
      "description_length": 760,
      "index": 3358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for handling string-based command-line parameters with support for validation, alias management, and dynamic value change hooks. It works with individual strings and string lists, enabling use cases like parsing restricted command-line arguments where values must conform to predefined options or executable function names. The module also supports extensibility through custom marshaling and state update controls, ensuring flexibility in parameter handling and serialization workflows.",
      "description_length": 519,
      "index": 3359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered key-value associations where keys represent memory base identifiers, supporting efficient insertion, lookup, and ordered traversal over persistent, balanced tree-backed structures. It enables tracking valid memory zones, associating metadata with address regions, and analyzing memory dependencies through immutable updates and safe iteration. The module specializes maps for specific data types, offering equality, comparison, and pretty-printing operations tailored for static analysis tasks like abstract interpretation. Submodules define key operations and formatters, enabling deep copies, project-based membership checks, and structured manipulation of map keys and values.",
      "description_length": 707,
      "index": 3360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Enumitem",
      "library": "frama-c.kernel",
      "description": "This module manages enumeration items in CIL with core operations for comparison, hashing, and pretty-printing, while structuring them into sets, maps, and hash tables for efficient manipulation. It enables static analysis tasks like tracking enum constants, checking value consistency, and analyzing switch coverage through ordered sets and maps that support union, intersection, ordered traversal, and key-based access. The hash table implementation allows project-aware transformations and cross-unit analysis by associating metadata or definitions with enum items. Together, these components support precise, structured handling of C enumerations during code analysis and transformation.",
      "description_length": 691,
      "index": 3361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Map",
      "library": "frama-c.kernel",
      "description": "This module implements ordered key-value maps with typed keys and polymorphic values, supporting efficient insertion, deletion, merging, and ordered traversal operations. It provides specialized functions for safe access (e.g., option-returning lookups), ordered iteration (via sequences, bindings, and extremal key queries), and transformations (filtering, mapping, partitioning) while preserving key ordering. The structure is optimized for use cases requiring persistent state management with ordered associations, such as symbol table construction, ordered attribute tracking, or deterministic traversal in analysis tools.",
      "description_length": 626,
      "index": 3362,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_map",
      "library": "frama-c.kernel",
      "description": "This module enhances a minimal monad by deriving additional operations from `map`, `return`, and `flatten`, enabling monadic composition and transformation for types like `'a t`. It supports concrete use cases such as chaining optional computations, flattening nested lists, and mapping over boolean conditions, while submodules provide specialized instances for `List`, `Option`, `Bool`, and custom operators. The `List` submodule sequences monadic actions over list elements, the `Option` submodule integrates monadic effects with optional values, and the `Bool` submodule conditionally executes monadic actions. Infix operators from the `Operators` submodule allow concise chaining and mapping of monadic computations using `let*`, `>>-`, and similar syntax.",
      "description_length": 761,
      "index": 3363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module offers operations to define and validate string-based command-line parameters, enabling checks for allowed values, parsing arguments as function names or plain strings, and managing aliases. It operates on string data, incorporating mechanisms for state tracking via hooks and persistence controls. It is particularly useful for enforcing constrained inputs (e.g., valid function identifiers or file paths) and customizing parameter serialization in configuration workflows.",
      "description_length": 486,
      "index": 3364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides functions for managing string-based configuration parameters in Frama-C plugins, including setting and retrieving values, defining aliases, validating inputs, and controlling serialization behavior through hooks and custom marshaling. It operates on string types like `As_string.t` and global parameters, enabling use cases such as command-line option parsing, project-specific state persistence, and validating function names or values during plugin execution.",
      "description_length": 482,
      "index": 3365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Get_orig",
      "library": "frama-c.kernel",
      "description": "This module provides direct access to original AST element representatives during visitor transformations. It includes functions to retrieve original versions of various AST nodes such as variables, structures, enums, statements, and functions, by mapping elements from the transformed AST back to their original counterparts in the visitor state. These operations are essential when analyzing or transforming C code in Frama-C plugins, particularly when tracking changes or preserving original references during AST manipulations.",
      "description_length": 531,
      "index": 3366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Version",
      "library": "frama-c.kernel",
      "description": "This module manages a shared boolean state variable to control version reporting behavior, offering operations to set, query, and monitor changes to the `-version` command-line flag. It integrates with kernel services through customizable serialization and project-specific state management, enabling conditional version output and tracking of feature activation across components. A core data type `t` supports equality, comparison, hashing, and pretty-printing for version identifiers, facilitating consistent management and comparison within Frama-C's analysis and plugin systems. The design also allows for deep copying, membership testing, and structural representation, supporting use cases like version synchronization and reactive configuration updates across modules.",
      "description_length": 776,
      "index": 3367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.G",
      "library": "frama-c.kernel",
      "description": "This module provides operations for analyzing and transforming directed graphs representing control flow structures, supporting vertex and edge membership checks, traversal of predecessors and successors, and folding over graph elements. It works with a graph type composed of vertices (V) and edges (E), where edges may carry labels representing CIL expressions, instructions, or return points, enabling precise modeling of program control flow and guarded transitions. The edge module supports directed, ordered edges with source, destination, and label access, ideal for representing transitions with conditions and actions, while the vertex module provides hashable, comparable vertices associated with labels, used to track control points and program states in abstract interpretation. Examples include computing reachable states, analyzing control dependencies, and transforming graph structures based on semantic properties of edges and vertices.",
      "description_length": 953,
      "index": 3368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-Service_graph-V",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating vertices in a callgraph, where each vertex has a unique label and supports comparison, hashing, and equality checks. It works with comparable vertex types (`V.t`) that are labeled with type `V.label`, enabling precise identification and ordering. Concrete use cases include constructing and analyzing service dependency graphs where vertices represent functions or services with distinct identifiers.",
      "description_length": 461,
      "index": 3369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S",
      "library": "frama-c.kernel",
      "description": "This module defines the structure and operations for representing and outputting service graphs derived from a callgraph. It provides types for graph nodes and the graph itself, along with functions to compute a service graph from a given callgraph and output it to a channel. A concrete use case is generating a visual representation of service dependencies for analysis or debugging.",
      "description_length": 385,
      "index": 3370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Structural_descr.Recursive",
      "library": "frama-c.kernel",
      "description": "This module manages recursive structural descriptors by providing `create` to initialize a recursive placeholder and `update` to bind it to a fully constructed descriptor. It works with the `Structural_descr.t` type, which represents OCaml types as first-class values, allowing recursive definitions like trees or self-referential variants. Use it when building descriptors for types that refer to themselves, such as linked lists or algebraic data types with recursive constructors.",
      "description_length": 483,
      "index": 3371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line option groups, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with strings, state lists, and category types to represent and manipulate option group behavior. Concrete use cases include setting up default and \"all\" categories, enabling all options with specific interpretations, and adding custom categories with dependencies.",
      "description_length": 453,
      "index": 3372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for a specific abstract data type, providing operations to compare, hash, and pretty-print values. It works with `As_string.Datatype.t`, a type representing values that can be converted to and from strings, and supports deep copying, equality checks, and membership testing within projects. Concrete use cases include parsing and managing configurable settings or parameters in Frama-C plugins, where structured string-based data must be stored, compared, and displayed consistently.",
      "description_length": 535,
      "index": 3373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLib",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option to control the output of Frama-C's library path during execution, supporting operations to toggle the state, register change listeners, and handle serialization. It works alongside a structured data module that defines a type `t` with equality, comparison, and pretty-printing capabilities for representing and manipulating internal kernel entities. Together, they enable diagnostic output control and structured data management, allowing users to, for example, enable library path printing via a command-line flag or inspect and modify complex data representations during analysis.",
      "description_length": 633,
      "index": 3374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with the `Frama_c_kernel.Parameter_category.t` type, allowing the association of states and accessors with categories. Concrete use cases include setting default parameter behaviors, enabling all parameters with specific interpretations, and defining dependencies for category activation.",
      "description_length": 468,
      "index": 3375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Debug",
      "library": "frama-c.kernel",
      "description": "This module manages integer-based debug options with fine-grained control over their behavior, allowing values to be set, retrieved, and monitored dynamically. It supports structured introspection and comparison of debug states through its core data type `t`, enabling precise tracking of changes during development. You can define aliases for options, control their visibility, and serialize them for persistence across sessions. Example uses include adjusting debug levels at runtime, exposing options in a command-line interface, and inspecting complex state transitions in plugins or kernel modules.",
      "description_length": 603,
      "index": 3376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage command-line string parameters, including setting values, tracking changes via hooks, handling aliases, and validating against allowed values (e.g., function names or plain strings). It works with string-based data, supporting both direct string inputs and validated function identifiers, while enabling serialization, state management, and visibility control in help messages. It is particularly useful for parsing and validating command-line arguments that require restricted value sets, change tracking, or integration with configuration systems.",
      "description_length": 591,
      "index": 3377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.S_pp",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations for converting CIL (C Intermediate Language) data structures and ACSL annotation elements into human-readable text. It works with CIL components like variables, expressions, statements, and control structures, as well as Frama-C-specific constructs such as logic terms, function specifications, and behavioral annotations. The formatters support customization for code display, debugging, and generating annotated output with options to control formatting details like brace placement or annotation visibility.",
      "description_length": 558,
      "index": 3378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rangemap.Value",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` with operations for equality checking, comparison, hashing, and pretty printing, along with support for project membership testing and deep copying. It is used to represent and manipulate values in a way that supports efficient comparison and memory management, particularly in the context of static analysis tasks. Concrete use cases include tracking and comparing abstract values during program analysis, where precise equality and structured representation are required.",
      "description_length": 509,
      "index": 3379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling file paths in the context of command-line options. It supports operations such as equality checking, comparison, hashing, and pretty-printing for file path values. It is used to represent and manipulate file paths during Frama-C's analysis configuration and option parsing.",
      "description_length": 317,
      "index": 3380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages file paths for a plugin's cache directory, providing functions to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, ensuring safe access to cached resources. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 376,
      "index": 3381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Make_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements a narrowing operation that combines two memory maps by retaining only the common base elements and intersecting their associated memory maps. Works with maps where keys are bases and values are memory maps from the Offsetmap module. Useful for analyzing memory states in static analysis, where precise intersections of memory layouts are required.",
      "description_length": 358,
      "index": 3382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Frama_c_builtins",
      "library": "frama-c.kernel",
      "description": "This module manages a project-aware hash table that maps string keys to CIL `varinfo` objects representing built-in functions, supporting insertion, retrieval, iteration, and memoization with custom state tracking. It also provides operations to associate keys with lists of related data values, enabling efficient lookups and change notifications during CIL built-in function processing. The main data type `t` supports equality, comparison, hashing, and pretty-printing, and includes utilities for deep copying, membership checks, and type descriptor management. Example uses include tracking built-in function metadata across analysis phases and ensuring consistent symbol resolution during static analysis.",
      "description_length": 710,
      "index": 3383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Eid",
      "library": "frama-c.kernel",
      "description": "This module generates unique integer identifiers using the `next` function, which increments a counter each time it is called. It works with basic integer values and is used to ensure distinct identifiers for CIL data structures. Concrete use cases include assigning unique IDs to statements, variables, or expressions during CIL manipulation.",
      "description_length": 343,
      "index": 3384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AggressiveMerging",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean flag that controls aggressive merging behavior, allowing dynamic adjustment of merging strategies through direct setting, hook-based updates, and persistent state across projects. It works with a dedicated data type `t` that supports equality, comparison, hashing, and pretty-printing, enabling precise tracking and manipulation of abstract values during static analysis. Operations include enabling or disabling merging via the `-aggressive-merging` option and maintaining consistent state across analysis runs. The module and its submodules together support optimizing analysis precision by structurally controlling merge points and persisting strategy decisions.",
      "description_length": 695,
      "index": 3385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-WithOutput-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured interface for command-line parameters with support for typed values, equality checks, comparison, and pretty printing. It operates on a polymorphic type `t` representing parameter values, alongside associated metadata like names, descriptors, and hash functions. Concrete use cases include parsing and validating command-line arguments with rich type information, ensuring deep copies of parameter values, and generating user-friendly output for debugging or logging purposes.",
      "description_length": 509,
      "index": 3386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued command-line parameters with constrained values, supporting operations to define allowed value sets, validate inputs against function names or predefined lists, and retrieve arguments in normalized forms. It works with strings and lists of allowed values, incorporating hooks for dynamic behavior and aliases for parameter flexibility. Use cases include parsing command-line options that require strict validation (e.g., enum-like parameters or function identifiers) and enabling extensible configuration through dynamic value constraints or project-specific state management.",
      "description_length": 610,
      "index": 3387,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FramaCStdLib",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that determines whether Frama-C uses its own standard library, providing operations to set, retrieve, and observe changes to this value with support for project-aware persistence and serialization. It works with a core data type `t` that enables precise structural manipulation, comparison, and pretty-printing of values, integrating with Frama-C's project model for analysis and transformation tasks. Use cases include toggling the standard library at analysis start-up, synchronizing configuration state across sessions, and tracking value changes through hooks and unit-driven updates. The combination of configuration handling and rich data operations supports both high-level option management and low-level data analysis within the Frama-C environment.",
      "description_length": 807,
      "index": 3388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Int_val.Set",
      "library": "frama-c.kernel",
      "description": "The module offers operations to manipulate sets of integer value abstractions, including union, intersection, difference, and element insertion/removal, leveraging a lattice structure for over-approximated arithmetic. It supports queries for cardinality, bounds, and membership, along with ordered traversal, transformation via mapping and filtering, and conversions to lists or sequences, enabling use cases like static analysis of integer ranges, symbolic value tracking, and program state abstraction. Additional utilities include nearest-value searches, type-class operations, and project-aware membership checks for domain-specific static analysis tasks.",
      "description_length": 659,
      "index": 3389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type and operations for handling keys in a hash table, including equality, comparison, hashing, and pretty-printing functions. It supports concrete use cases such as tracking and comparing project-specific values within static analysis tools. The module also enables deep copying of keys and checking membership based on project projections.",
      "description_length": 368,
      "index": 3390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Ty",
      "library": "frama-c.kernel",
      "description": "This module represents a type along with its corresponding type value, providing direct access to the underlying type information. It works with the `Type.t` structure to enable inspection and manipulation of type definitions. Concrete use cases include type analysis and transformation in static analysis plugins, where precise type information is required for program elements.",
      "description_length": 379,
      "index": 3391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptset.Info",
      "library": "frama-c.kernel",
      "description": "This module defines the required metadata for ensuring the correctness of hash-consed sets, including the element type, initial shared set values, and dependencies that trigger table invalidation. It works with lists of elements to predefine shared sets and tracks state dependencies to manage hash-consing consistency. Concrete use cases include initializing analysis contexts with predefined sets and managing cache invalidation based on analysis state changes.",
      "description_length": 463,
      "index": 3392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Files",
      "library": "frama-c.kernel",
      "description": "This module manages a list of file paths with operations to modify, query, and track changes, integrating submodules for categorization and string-based parameter handling. It supports adding and removing files, defining categories like '@default' or '@all' to control analysis behavior, and validating command-line inputs such as file paths or function names. The core data type represents file collections with support for comparison, hashing, and project membership checks, while submodules enable structured CLI parsing and type-safe file set manipulations. Examples include organizing files into analysis groups, enforcing valid input constraints during tool invocation, and maintaining dynamic file lists across analysis phases.",
      "description_length": 734,
      "index": 3393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Verbose-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in Frama-C's plugin system. It supports values of type `Verbose.Datatype.t`, providing deep copy functionality and integration with project-based queries via `mem_project`. Concrete use cases include managing and manipulating analysis results or configuration data within Frama-C plugins.",
      "description_length": 421,
      "index": 3394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Float-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float-based data type with operations for equality, comparison, hashing, and pretty printing. It provides a structured way to handle command-line parameters of type float, including deep copying and project membership checks. Concrete use cases include parsing and managing numerical configuration options in Frama-C plugins.",
      "description_length": 347,
      "index": 3395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Verbose",
      "library": "frama-c.kernel",
      "description": "This module provides integer-based level control for plugin verbosity, supporting operations to set, retrieve, and constrain valid value ranges with bounds checking. It manages state persistence across project sessions, handles command-line option aliases, and triggers hooks on value changes. Use cases include dynamic configuration of analysis tools via CLI flags, enforcing safe verbosity thresholds, and synchronizing state updates with project lifecycle events in static analysis workflows.",
      "description_length": 495,
      "index": 3396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Consolidation_graph",
      "library": "frama-c.kernel",
      "description": "This module represents a graph structure that captures the consolidated status of a property along with all its dependencies. It provides operations to retrieve the graph for a given property and to print its contents using a formatter. The primary use case is to visualize or analyze the transitive dependencies of a property and their statuses within a Frama-C analysis context.",
      "description_length": 380,
      "index": 3397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-True-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, packed descriptions, and deep copying to ensure value integrity. Concrete use cases include managing abstract syntax tree nodes, analysis results, or configuration settings within static analysis plugins.",
      "description_length": 422,
      "index": 3398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_ctor_info",
      "library": "frama-c.kernel",
      "description": "This module provides a project-aware key-value store for managing logic constructor metadata, using a global hashtable with custom rehashing to support state transitions across projects. It enables insertion, retrieval, and iteration over logic_ctor_info values, along with change tracking via update hooks, ensuring correct handling of project-specific state. The associated datatype module supports structured values with equality, comparison, and pretty-printing, making it suitable for static analysis plugins that require precise type identity and traversal. Together, these components facilitate consistent management of logic types and constructors through analysis phases, including deep copying, project membership checks, and type descriptor operations.",
      "description_length": 763,
      "index": 3399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating sets of kernel functions within a plugin. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with their behaviors and dependencies. Use cases include configuring plugin parameters, enabling or disabling groups of functions, and defining access control for function sets based on category rules.",
      "description_length": 419,
      "index": 3400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements forward dataflow analysis over control flow graphs, computing dataflow values for each node using a widening threshold. Works with control flow graph (`t`) and dataflow state (`D.t`) types, where `D` defines the abstract domain. Useful for static analysis tasks like constant propagation or interval analysis, where reaching definitions or value ranges must be tracked through program control flow.",
      "description_length": 409,
      "index": 3401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Diff_One",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations for tracking and merging abstract states with a focus on difference computation. Provides the `diff_if_one` function to compute an over-approximation of the difference between two lattice elements, useful in fixpoint analysis. Works with abstract domains representing program properties, such as value ranges or memory states, in static analysis.",
      "description_length": 376,
      "index": 3402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Value_string",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string values, providing functions to parse, compare, and display options. It works with a string-based type `Value_string.t` that represents command-line arguments, supporting operations like equality checks, hashing, and pretty-printing. Concrete use cases include defining and processing options such as `-output-dir` or `-log-level` in Frama-C plugins.",
      "description_length": 412,
      "index": 3403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_set_and_map-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map datatype built from a given value type, supporting standard operations like equality, comparison, hashing, and pretty-printing. It works with key-value pairs where the value type is specified by the `Data` module, and provides deep copying, membership testing with `mem_project`, and integration with Frama-C's type and project system. Concrete use cases include managing collections of analysis values indexed by keys, such as variable bindings or program state mappings.",
      "description_length": 501,
      "index": 3404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.S",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and interacting with a specific state kind, including marking states as computed, checking computation status, and registering hooks for updates. It works with a datatype module that represents the state's value and provides functions for custom serialization. Concrete use cases include tracking analysis results that should remain immutable after computation and triggering actions when state values change during analysis.",
      "description_length": 469,
      "index": 3405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing list-based command-line parameters, including value setting/retrieval, update hooks, default handling, and custom serialization. It works with a list type (`t = E.t list`) and offers functions to manipulate individual elements, append lists, and define parameter aliases with visibility or deprecation flags. These features are particularly useful for command-line interfaces requiring multi-value options, structured configuration management, and backward-compatible option evolution with deprecation support.",
      "description_length": 555,
      "index": 3406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for keys used in hash tables, providing operations such as equality checking, comparison, hashing, and pretty printing. It supports data types involving keys with deep copy, membership testing, and project-based filtering. Concrete use cases include managing and manipulating key-based data structures in static analysis plugins, such as tracking variable identifiers or memory locations.",
      "description_length": 419,
      "index": 3407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Make",
      "library": "frama-c.kernel",
      "description": "This module implements type-checking and coercion logic for terms, predicates, and annotations in a logic environment. It handles operations like field typing, term casting, conditional type conversion, and validation of function contracts and code annotations. It works with logic types, terms, and annotations, ensuring correct typing during analysis of annotated C code.",
      "description_length": 373,
      "index": 3408,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Exp_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides a memoized, serialized mapping from CIL expressions to arbitrary data, enabling efficient insertion, lazy lookup, and ordered or unordered traversal of key-value pairs. It supports operations like `replace`, `fold`, and `clear`, while maintaining extensible state with project tracking, change hooks, and custom serialization. A specialized hash table for expression keys enables efficient comparison and caching of analysis results across program points. Examples include tracking evolving expression states during static analysis or performing side-effect-free computations over CIL code with cached results.",
      "description_length": 631,
      "index": 3409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash table operations for CIL key types, supporting creation, lookup, iteration, folding, and ordered traversal using customizable key/value/entry comparisons. It works with polymorphic hash tables (`'a Hashtbl.t`) where keys are CIL-specific types (e.g., variables, expressions) from the `Cil_datatype` module. Use cases include static analysis tasks like variable mapping, memoization of analysis results, and deterministic processing of C AST elements during plugin development.",
      "description_length": 502,
      "index": 3410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with a lattice structure, where each entry's value type is defined by the `Data` module. It supports operations like equality checking, comparison, hashing, and pretty-printing for structured values, along with deep copying and project membership testing. It is used to represent and manipulate stateful data mappings in static analysis, such as variable bindings or memory abstractions.",
      "description_length": 423,
      "index": 3411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string set data structure with operations for membership testing, comparison, and pretty-printing. It provides functions to create and manipulate sets of strings, including checking inclusion, equality, and generating human-readable output. Concrete use cases include managing collections of unique string identifiers and validating string presence in analysis configurations.",
      "description_length": 401,
      "index": 3412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map-like structure for handling command-line parameters with string representations, providing operations to compare, hash, and pretty-print values. It works with the `As_string.Datatype.t` type, supporting deep copies, equality checks, and membership testing over project skeletons. Concrete use cases include managing configurable analysis options and serializing parameter states for user interaction or storage.",
      "description_length": 440,
      "index": 3413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure for handling command-line parameters with operations for equality, comparison, hashing, and pretty printing. It works with a custom `Datatype.t` type, supporting deep copying, membership testing over projects, and structured descriptors for type representation. Concrete use cases include managing and querying analysis configurations in Frama-C plugins, such as tracking and comparing parameter values across different analysis runs.",
      "description_length": 478,
      "index": 3414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing command-line parameters with state tracking, including value setting/retrieval, update hooks, default handling, and serialization. It operates on a parameterized map structure storing key-value pairs, augmented with modules for string representations, category organization, and metadata like visibility or deprecation flags. These features enable building configurable command-line interfaces with support for aliases, project-specific state persistence, and marshaled data exchange.",
      "description_length": 529,
      "index": 3415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Set",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered set abstraction with operations for ordered traversal, element insertion/removal, and set algebra (union, intersection, difference). It manipulates sets of arbitrary elements using a custom comparison function, supporting transformations like mapping, filtering, and partitioning, while providing ordered sequence conversions and nearest-element queries. It is suited for static analysis tasks requiring precise memory state tracking or dependency management where element ordering and efficient set operations are critical.",
      "description_length": 558,
      "index": 3416,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_pair",
      "library": "frama-c.kernel",
      "description": "This module provides operations to construct and manipulate polymorphic pairs, enabling the combination of two distinct types into a single structured type. It supports key operations like creating pairs from individual types, checking if a type is a pair instance, and extracting component types, facilitating tasks like tracking value-constraint pairs in abstract interpretation. The child module enhances this by offering concrete pair datatypes with equality, comparison, and pretty-printing, allowing deep copies and membership checks on composed values. Together, they enable modeling compound analysis states and structured program properties within static analysis frameworks.",
      "description_length": 684,
      "index": 3417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder",
      "library": "frama-c.kernel",
      "description": "This module enables structured definition of command-line parameters with type-specific constraints, supporting operations like parsing, default initialization, and output handling. It works with primitive types (booleans, integers, floats, strings) and composite structures (sets, lists, enumerations) while integrating with kernel-specific data representations. Typical use cases include building plugin configuration interfaces, validating Frama-C's analysis options, and managing hierarchical parameter sets in static analysis workflows.",
      "description_length": 541,
      "index": 3418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Int-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values, as well as checking membership in projects and performing deep copies. It works with a specific datatype `t` and lists of its values, supporting concrete tasks like value comparison, storage in hash tables, and user-friendly output formatting. Use cases include managing and manipulating values in a project-aware context, ensuring structural integrity during comparisons and copies.",
      "description_length": 483,
      "index": 3419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based command-line parameters with controlled value constraints and validation. It works with string data types, supporting features like value whitelisting, function name sanitization, and direct string retrieval, while enabling hooks for dynamic behavior. It is suited for scenarios requiring strict input validation, such as parsing project-specific configuration flags or ensuring valid C-identifier formatting in toolchains.",
      "description_length": 481,
      "index": 3420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Zone",
      "library": "frama-c.kernel",
      "description": "This module models associations between symbolic memory bases and bit ranges, providing lattice operations and map manipulations to analyze abstract memory regions. It supports key operations like join, meet, inclusion checks, and transformations via functions such as `inject` and `find`, working primarily on `Zone.t` structures to represent and combine memory states. The child modules extend this functionality by organizing zones into ordered sets, mapping them to arbitrary data, and implementing hash tables for efficient lookups and updates. Together, they enable precise tracking of memory regions, pointer analysis, alias resolution, and data flow processing during static analysis.",
      "description_length": 692,
      "index": 3421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Enum",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing finite enumeration types with configurable values, supporting operations like value setting, retrieval, and change notification via hooks. It works with variant types (`t`) representing fixed sets of values, integrating with project state management through serialization and command-line parameter handling. It is suited for scenarios requiring extensible configuration options with state tracking, such as plugin settings exposed to users via CLI interfaces or GUI controls.",
      "description_length": 534,
      "index": 3422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph.Record",
      "library": "frama-c.kernel",
      "description": "This module provides operations to build complex node layouts in Dot graphs using records, enabling structured composition of nodes and edges. It works with records representing nodes and links, supporting precise control over node ports, labels, and connections. Concrete use cases include generating detailed control flow graphs or abstract syntax trees with labeled nodes and structured interconnections.",
      "description_length": 407,
      "index": 3423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Declaration",
      "library": "frama-c.kernel",
      "description": "This module provides core data types and operations for working with structured declarations, including equality, comparison, hashing, and pretty printing, with support for deep copying and project membership checks. Its first child module offers set-based manipulation of declaration collections with efficient membership queries, ordered traversal, and set algebra operations, enabling tasks like filtering and partitioning project-specific declarations. The second child module implements key-value associations mapping declaration tags to structured data, supporting transformations, filtering, and bidirectional iteration, with utilities for merging and formatting annotated AST fragments. A specialized hash table module enables efficient, typed storage and retrieval of C source code declarations within Frama-C, integrating with analysis plugins through project-aware data management.",
      "description_length": 892,
      "index": 3424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Stmt_set_ref",
      "library": "frama-c.kernel",
      "description": "This module manages a set of C statements with efficient membership testing and mutation operations, enabling tracking and manipulation of statement-level elements during static analysis. It supports core operations like `add`, `remove`, `mem`, and `iter`, and provides set algebra through union and fold-based aggregations. The child module enhances this functionality with optimized set operations tailored for processing CIL statements in Frama-C plugins. Together, they enable precise statement set management, such as accumulating target statements during analysis passes or filtering based on semantic criteria.",
      "description_length": 617,
      "index": 3425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S-Option",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to the `option` type, providing `iter` for performing monadic actions on `Some` values and `map` for transforming `option` values within a monadic context. It works directly with `'a option` and monadic functions of type `'a -> 'b t`. Use it to chain operations on optional values without explicit pattern matching, such as logging when an option is present or conditionally executing monadic effects based on an option's value.",
      "description_length": 466,
      "index": 3426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a user-specific directory structure based on an existing parent directory and a target directory name. It provides `get_dir` and `get_file` functions to retrieve directory or file paths, optionally creating intermediate paths. These operations are used when managing plugin-specific storage locations within Frama-C's directory hierarchy.",
      "description_length": 361,
      "index": 3427,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered associative map operations for key-value pairs where keys conform to a structured type `t` (mirroring `key`) and values are polymorphic. It supports ordered traversal, bulk transformations (e.g., `map`, `filter`), structural manipulations (`merge`, `split`), and precise querying (`find_first_opt`, `bindings`), ensuring key ordering is preserved. These capabilities are particularly useful for static analysis tasks like symbol table management or control flow graph traversal in C programs, where structured key ordering and customizable pretty-printing of map contents are critical for clarity and debugging.",
      "description_length": 640,
      "index": 3428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_ctor_info",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between logic constructor metadata and correspondence data, using project-aware hashtables optimized for custom rehashing and incremental analysis. It provides keyed lookups, iteration, mutation tracking, and versioned serialization, enabling efficient querying of logic constructor relationships across evolving project states. The core type `t` supports structural comparison, deep copying, and project membership checks, facilitating precise diff computations and AST analysis. Together with its submodules, it offers a cohesive interface for managing and analyzing logic constructors with rich metadata, descriptors, and type representations.",
      "description_length": 675,
      "index": 3429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Input",
      "library": "frama-c.kernel",
      "description": "This module defines the interface for command-line parameters, specifying the option name and help description. It works with string values to represent parameter names and their associated documentation. Used to structure and document command-line arguments in a type-safe manner.",
      "description_length": 281,
      "index": 3430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with efficient key-value operations, supporting insertion, lookup, and iteration. It works with keys that conform to the `Datatype` signature, providing ordered comparisons and hashing. Concrete use cases include tracking analysis results per function or variable, managing per-project configurations, or associating metadata with AST nodes in Frama-C plugins.",
      "description_length": 404,
      "index": 3431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-based plugin parameters in Frama-C, including setting and retrieving values, defining change hooks, handling aliases, and customizing marshaling for serialization. It operates on strings and string lists, supporting validation of allowed values and function names, integration with the command-line interface, and project state persistence. Specific use cases include configuring plugin options with dynamic validation rules and ensuring consistent parameter handling across analysis sessions.",
      "description_length": 542,
      "index": 3432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Intervals_sig.S",
      "library": "frama-c.kernel",
      "description": "This module provides a lattice structure for representing and manipulating sets of integer intervals, automatically merging consecutive or overlapping ranges. It supports operations like union, intersection, difference, widening, and narrowing, along with conversions to and from concrete integer values (Int.t) and symbolic intervals (Ival.t), enabling precise range analysis for program variables. The design facilitates static analysis tasks such as tracking value approximations, verifying safety properties, and integrating with C type systems through type-aware projections and coverage checks.",
      "description_length": 600,
      "index": 3433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.System_config.Lib",
      "library": "frama-c.kernel",
      "description": "This module defines paths and directories used by Frama-C for locating libraries and executables. It provides direct access to the search path as a list of filepaths and as a colon-separated string. Useful for tools needing to resolve Frama-C resource locations during analysis or plugin execution.",
      "description_length": 298,
      "index": 3434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Ref-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements stateful references with rich datatype operations, including equality, comparison, hashing, and pretty-printing. It works with abstract data types that represent values within Frama-C's analysis framework, supporting deep copies and membership checks over project skeletons. Concrete use cases include managing and querying analysis states, such as tracking variable bindings or analysis results across different program points.",
      "description_length": 451,
      "index": 3435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Unset_orig",
      "library": "frama-c.kernel",
      "description": "This module provides functions to remove entries from the AST element table of a visitor behavior, specifically targeting various CIL types such as `varinfo`, `compinfo`, `stmt`, and `fundec`. Each function takes a visitor behavior and an element of a specific type, then unsets the original representative of that element in the visitor's state. These operations are useful when modifying or resetting associations during AST transformations where certain elements should no longer be tracked.",
      "description_length": 494,
      "index": 3436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsInitialized",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls how uninitialized variables are treated in assembly contracts during static analysis, providing operations to set, retrieve, and track changes to this flag. It includes data types for representing the option's state, along with project-specific metadata and serialization support for persistence across analysis sessions. The child module enhances this functionality by defining a structured type `t` with comparison, hashing, and pretty-printing capabilities, enabling precise manipulation and querying of assembly contract initialization behavior. Together, they allow fine-grained control and analysis of uninitialized variable handling in Frama-C's kernel extensions.",
      "description_length": 729,
      "index": 3437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S",
      "library": "frama-c.kernel",
      "description": "This module provides functions for creating, modifying, and merging hierarchical maps with hash-consed tree keys, supporting operations like insertion, deletion, value transformation, and customizable merging of overlapping keys. It works with key-value pairs where keys are hash-consed trees and values are arbitrary, enabling efficient structural comparisons, folding, and partitioning. These operations are particularly useful for program analysis tasks requiring precise manipulation of hierarchical data structures or abstract interpretations involving cached computations and symmetric/idempotent merges.",
      "description_length": 610,
      "index": 3438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SignedOverflow",
      "library": "frama-c.kernel",
      "description": "This module controls the behavior of signed integer overflow warnings through a boolean option state, offering operations to set, query, and persist the state across sessions. It integrates with Frama-C's project management to support dynamic reconfiguration and serialization, enabling consistent handling of overflow diagnostics during static analysis. The core type `t` represents the overflow state, with support for comparison, hashing, and pretty-printing, while submodules provide utilities for analysis, deep copying, and project membership checks. Use cases include enabling overflow warnings, synchronizing state with plugins, and ensuring stable behavior when saving or restoring analysis contexts.",
      "description_length": 709,
      "index": 3439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Bool",
      "library": "frama-c.kernel",
      "description": "This module provides operations to configure, observe, and toggle boolean parameters with support for persistent state across Frama-C projects. It manages boolean values through a global state mechanism, allowing programmatic control via `on`/`off` actions and reactive updates through change hooks. The functionality is particularly useful for analysis plugins requiring command-line switches with project-scoped defaults and dynamic reconfiguration during static analysis workflows.",
      "description_length": 484,
      "index": 3440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S_with_product-Operators",
      "library": "frama-c.kernel",
      "description": "This module defines monadic operators for sequencing computations and combining results within a monadic context. It provides bind and map operations, both sequentially and in parallel, working with monadic values of type `'a t`. These operators are used to structure effectful computations, such as stateful or error-handling operations, in a concise and composable way.",
      "description_length": 371,
      "index": 3441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Compinfo",
      "library": "frama-c.kernel",
      "description": "This module manages a project-scoped, mutable hashtable that maps C composite type identifiers to diff metadata, enabling keyed lookups, insertion, removal, and change tracking with custom hashing to ensure state consistency. It includes hooks for modification notifications and supports iteration and structured serialization of type correspondence data, facilitating analysis of differences between C composite type declarations across project versions. The child module provides data types and operations for representing and comparing structured values used in diff computations, supporting equality, comparison, hashing, and pretty-printing. Together, they enable precise tracking and analysis of structural changes in project components, such as detecting differences in C struct layouts or type definitions across builds.",
      "description_length": 828,
      "index": 3442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Set",
      "library": "frama-c.kernel",
      "description": "This module provides a polymorphic set structure with operations for element manipulation (insertion, removal, membership checks), set-theoretic operations (union, intersection, difference), and ordered traversal (min/max, iteration). It works with elements of any type `'elt` ordered via a comparison function, maintaining canonical representations through uniqueness and ordering constraints. Typical use cases include managing hierarchical program analysis data, project-aware element tracking, and serializing sets to structured formats for debugging or inter-process communication.",
      "description_length": 586,
      "index": 3443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S-List",
      "library": "frama-c.kernel",
      "description": "This module applies monadic functions to lists, providing operations to iterate, map, and fold over list elements within a monadic context. It works with lists and monadic values, allowing sequential composition of effectful computations across list elements. Concrete use cases include processing lists of values that require side effects, such as logging or error handling, within a structured monadic flow.",
      "description_length": 409,
      "index": 3444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list-based data type with string representations, providing operations for equality, comparison, hashing, and pretty-printing. It supports the creation and manipulation of values that can be represented as strings, including deep copying and project membership checks. Concrete use cases include managing symbolic values or identifiers in static analysis plugins where string-based representations are required.",
      "description_length": 436,
      "index": 3445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table creation, manipulation, and conversion operations, supporting imperative and functional styles through in-place updates, safe key-value lookups (`find_opt`, `find_def`), and memoization. It works with hash tables (`'a Hashtbl.t`) and sequences, enabling sorted iteration over keys, values, or entries, while providing structural descriptions for type definitions. Typical use cases include managing mappings between program elements and analysis metadata, caching computed results deterministically, and processing key-value data with ordered traversal requirements.",
      "description_length": 596,
      "index": 3446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Type_namespace",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and manipulating logic type namespaces, including equality, comparison, hashing, and pretty-printing functions. It works with structured logic types and project-based data representations, supporting deep copying and membership checks over project skeletons. Concrete use cases include handling type representations in logic environments and ensuring structural consistency during type analysis in Frama-C.",
      "description_length": 450,
      "index": 3447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.True_ref",
      "library": "frama-c.kernel",
      "description": "This module provides a boolean reference initialized to `true`, offering operations to get, set, and reset its value, along with support for change notifications and custom serialization. It integrates with Frama-C's state management system, enabling project-aware values and deep copies, and allows hooks to trigger on value changes or before updates. Use it to track analysis states, manage configuration flags, or synchronize boolean state across plugins with fine-grained control over updates and persistence.",
      "description_length": 513,
      "index": 3448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Weak_hashtbl-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements a weak hash table with structural comparison and project-aware membership checks. Operates on a polymorphic type `t` that supports equality, comparison, and pretty-printing. Useful for caching analysis results keyed on structured data while allowing garbage collection of unused entries.",
      "description_length": 298,
      "index": 3449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Full_AI_Lattice_with_cardinality",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set of lattice operations, including join, meet, widening, narrowing, and cardinality tracking, along with inclusion checks, intersection, and over-approximated difference computations. It operates on abstract elements of type `t`, which form a complete lattice structure, supporting deep copies, comparisons, and enumeration. Designed for static analysis applications, it enables precise abstract interpretation by managing complex domain manipulations while controlling computational overhead through cardinality-aware operations and safe enumeration strategies.",
      "description_length": 601,
      "index": 3450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Enum",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing command-line options with a fixed set of allowed values, represented as a variant type with structural equality. It supports parsing, state updates via hooks, alias resolution, and serialization, while integrating with Frama-C's project system for typed settings. Use cases include enforcing enumerated configurations (e.g., analysis modes) and dynamically reacting to option changes during tool execution.",
      "description_length": 464,
      "index": 3451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Typeinfo",
      "library": "frama-c.kernel",
      "description": "This module coordinates mappings between CIL type information and project-specific data, using a custom hashtable structure that avoids standard hashtables when custom rehashing is needed. It supports memoization, lookup, and modification of type-related state with operations for iteration, serialization, and change tracking via hooks, specifically tailored for AST differencing across C projects. The polymorphic type `t` enables deep equality checks, structured data inspection, and non-sharing deep copies, with utilities for comparing, hashing, and pretty-printing values. Together, these features allow precise tracking and diffing of structured AST elements across project versions, ensuring accurate equality and controlled memory behavior.",
      "description_length": 749,
      "index": 3452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map for file paths with string keys, supporting operations like equality, comparison, hashing, and pretty printing. It works with `As_string.Datatype.t` values representing file paths and includes utilities for project membership checks and deep copying. Concrete use cases include managing and comparing file path configurations in command-line options or analysis contexts.",
      "description_length": 400,
      "index": 3453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Check",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls analysis validation behavior, supporting state modification, change notifications, and serialization. It integrates with project-specific state systems through hooks and marshaling, ensuring cross-project consistency. The core type `t` includes a descriptor, name, and list of representatives, enabling introspection and structured comparisons. Use cases include configuring analysis checks at runtime and tracking program representations across Frama-C plugins.",
      "description_length": 520,
      "index": 3454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing integer sets with enforced non-emptiness, supporting standard set algebra (union, intersection, difference), ordered iteration, and transformations like filtering or partitioning. It works with compact integer sets optimized for small cardinality, automatically converting to interval representations when exceeding size limits, and maintains elements in sorted order for efficient ordered traversals. Use cases include static analysis scenarios requiring precise tracking of integer ranges, membership checks under project constraints, and scenarios needing reversible sequence conversions or nearest-value queries.",
      "description_length": 661,
      "index": 3455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table datatype based on the provided value datatype, supporting standard operations such as equality, comparison, hashing, and pretty printing. It works with any data type that conforms to the `Data` module signature, enabling structured storage and retrieval of typed values. Concrete use cases include managing collections of analyzed program elements with efficient lookup and comparison, such as tracking variable states or function summaries in static analysis.",
      "description_length": 496,
      "index": 3456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list of file paths as a string-based data type, supporting operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to handle file path lists with deep copying and project membership checks. Concrete use cases include managing command-line file path arguments and ensuring consistent handling of file path data within analysis plugins.",
      "description_length": 399,
      "index": 3457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with associated equality, comparison, and hashing operations, along with set, map, and hash table implementations over the type. It supports structured values with deep copying, pretty printing, and project membership checks. Concrete use cases include managing collections of structured values, tracking unique instances, and implementing efficient lookups and aggregations over complex data.",
      "description_length": 424,
      "index": 3458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Map",
      "library": "frama-c.kernel",
      "description": "This module provides lattice operations for combining and transforming maps with ordered keys and polymorphic values, supporting efficient functional updates, merges, and queries. It works with key-value pairs in `Map.t` structures, leveraging key ordering for operations like range-based iteration, monotonic predicate filtering, and ordered list conversion. Designed for static analysis frameworks, it enables precise data flow modeling through lattice joins/meets and supports debugging via structured pretty-printing.",
      "description_length": 521,
      "index": 3459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Lattice_Base",
      "library": "frama-c.kernel",
      "description": "This module defines a lattice structure for abstract domains, offering operations to combine, compare, and transform abstract values through join, meet, inject, and project functions. It works with hierarchical data structures representing program properties, such as numerical ranges or symbolic expressions, enabling analysis of their relationships and intersections. These capabilities support static analysis tasks like program verification, dependency tracking, and property inference in compiler optimization or bug detection workflows.",
      "description_length": 542,
      "index": 3460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location_Bits",
      "library": "frama-c.kernel",
      "description": "This module combines set-theoretic and arithmetic operations on bit-level memory locations, represented as base-offset pairs, to model and analyze memory states with high precision. It supports union, intersection, inclusion checks, offset shifting, and abstract interpretation techniques like widening and top value handling, enabling tasks such as pointer aliasing detection, memory safety verification, and symbolic execution path merging. Child modules extend this core functionality with specialized data structures: sets for region modeling, maps for key-based memory state tracking, and hash tables for efficient storage and retrieval of bit-level location-value associations. These components work together to enable precise static analysis of low-level memory manipulations, such as tracking pointer states, verifying reachability, and analyzing C program memory accesses.",
      "description_length": 881,
      "index": 3461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string-based data types, providing operations to compare, hash, and pretty-print values. It supports data types that conform to the `As_string.Datatype` interface, enabling seamless integration with Frama-C's option parsing system. Concrete use cases include defining and managing options that accept string inputs, such as file paths or identifiers, with validation and representation logic tied to the data type's semantics.",
      "description_length": 482,
      "index": 3462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Function",
      "library": "frama-c.kernel",
      "description": "This module provides operations to create and inspect function types with optional labeled parameters. It works with type values representing functions, allowing instantiation with a label and retrieving the argument and return types. Concrete use cases include building and analyzing ML function types with optional arguments in a type-safe manner.",
      "description_length": 349,
      "index": 3463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Set_ref",
      "library": "frama-c.kernel",
      "description": "This module manages dynamic collections of elements within Frama-C's state system, supporting addition, removal, membership checks, and iterative transformations on stateful references to sets. It enables analysis plugins to track evolving data, maintain intermediate results, and register change listeners for reactive updates, with support for custom state persistence through marshaling hooks. The child module provides a state builder for a set-like reference type, implementing structured descriptors for representation, equality, comparison, and pretty-printing, while encapsulating values of type `Datatype.t` for deep copies and hash-consing. Together, they support precise and efficient state tracking in static analysis plugins, such as building abstract states or querying set membership over project skeletons.",
      "description_length": 822,
      "index": 3464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadState",
      "library": "frama-c.kernel",
      "description": "The module manages structured project state representations during loading, offering equality, comparison, and deep copying operations for precise state handling. It defines the main data type `t` with support for hashing, pretty-printing, and membership checks over project skeletons. This enables kernel extensions and plugins to accurately track and compare loaded state configurations. Submodules extend these capabilities with additional utilities for state manipulation and analysis.",
      "description_length": 489,
      "index": 3465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Map",
      "library": "frama-c.kernel",
      "description": "This module manages ordered associations between emitters and arbitrary data, enabling efficient lookups, updates, and ordered traversals. It supports key operations like merge, filter, and partition, along with conversion to ordered sequences for analysis or output. The key module handles comparison, hashing, and project membership for emitter keys, while the value module specializes in annotation and property status management with deep copying and project-based queries. Together, they enable precise tracking and transformation of emitter-associated data across static analysis workflows.",
      "description_length": 596,
      "index": 3466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections",
      "library": "frama-c.kernel",
      "description": "This module defines a custom data type with support for string conversion, equality, comparison, and deep copying, along with associated set, map, and hash table modules. It enables the creation and manipulation of collection-based command-line parameters where each element can be converted to or from a string representation. Concrete use cases include parsing and managing multiple string-represented values as part of Frama-C's command-line interface.",
      "description_length": 455,
      "index": 3467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Lattice_Sum",
      "library": "frama-c.kernel",
      "description": "This module implements a lattice structure over a sum type combining two distinct abstract domains (`t1` and `t2`) with `Top`/`Bottom` extrema. It provides operations like `join` (least upper bound), `meet` (greatest lower bound), `narrow` (for convergence), and `intersects` (non-empty intersection checks), alongside domain-specific injections (`inject_t1`, `inject_t2`) to unify heterogeneous values. Designed for static analysis in Frama-C, it enables merging and comparing abstract states from different domains, such as numeric ranges and symbolic expressions, within a single lattice framework.",
      "description_length": 601,
      "index": 3468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Stmt",
      "library": "frama-c.kernel",
      "description": "This module provides a project-aware representation of C statement ASTs with support for deep copying, comparison, and project-specific rehashing. It includes operations for equality checking, hashing, and pretty printing, ensuring accurate handling of custom key types across project versions. Submodules extend functionality to diffing and analyzing statement changes, enabling tasks like tracking modifications in function bodies or control structures. Example uses include comparing statements across commits or identifying structural differences in C code during analysis.",
      "description_length": 577,
      "index": 3469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_set_and_map",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with support for sets and maps, providing operations like equality, comparison, hashing, and pretty-printing for values of type `t`. It includes structured representations, deep copying, and project membership checks, making it suitable for managing complex, structured data in analyses. The associated `Set` and `Map` modules enable efficient collection operations tailored to the extended type.",
      "description_length": 427,
      "index": 3470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Info_with_size",
      "library": "frama-c.kernel",
      "description": "Implements state builders with size configuration for internal state management. Works with abstract states and hash tables, initializing structures based on provided size and dependencies. Useful for managing analysis states in static code analysis, where initial resource allocation impacts performance and accuracy.",
      "description_length": 318,
      "index": 3471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Nativeint",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with native integers, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and type handling. Its submodules build on this foundation to offer high-performance key-value mappings, ordered immutable sets, and typed maps that support efficient lookups, traversal, and transformations. These structures enable concrete use cases such as caching numeric identifiers, tracking memory sizes, and performing set operations in static analysis. Specific capabilities include bulk updates from sequences, nearest-value queries, and type-safe manipulation of native integer-indexed collections with integrated printing and comparison.",
      "description_length": 719,
      "index": 3472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports state management tasks such as deep copying, membership testing within projects, and type representation for integration with Frama-C's state system. Concrete use cases include tracking and managing collections of analysis-specific data values during static analysis.",
      "description_length": 463,
      "index": 3473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Map-Category",
      "library": "frama-c.kernel",
      "description": "This module organizes command-line option categories, managing predefined categories like `@none`, `@default`, and `@all`. It supports creating custom categories with names, accessors, and dependencies, and controls how the `@all` category behaves in different contexts. Use it to structure and control groups of related command-line parameters in Frama-C plugins or extensions.",
      "description_length": 378,
      "index": 3474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice_with_cardinality",
      "library": "frama-c.kernel",
      "description": "This module provides operations to reason about the cardinality of maps with a complete lattice structure. It includes functions to check if a map has zero or one element, safely extract singleton bindings, and fold over elements when finite. These operations are used to analyze or constrain the size of abstract values represented as maps in static analysis contexts.",
      "description_length": 369,
      "index": 3475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.DoCollapseCallCast",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls whether CIL enforces strict type matching for function call destinations or allows implicit casts between return types and their assigned variables. It includes a data type for representing this behavior, supporting operations like equality checks, pretty-printing, and project-based predicates, while providing hooks and serialization for integration with analysis tools. Enabling the flag preserves call instructions involving `malloc` without intermediate temporaries, simplifying allocation tracking, and replicates legacy CIL behavior prior to version 1.4. It is used internally during CIL transformation to influence call site handling, ensuring flexibility in type coercion rules across different analysis scenarios.",
      "description_length": 786,
      "index": 3476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppGnuLike",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls C preprocessor compliance behavior, providing operations to set, retrieve, and monitor its value. It integrates with the `Datatype` module to handle project-specific state, default values, and marshaling, enabling features like enabling or disabling compliance during static analysis. The child module extends this functionality by defining a data type `t` with equality, comparison, and pretty-printing operations, supporting structured manipulation of C++-like data under the compliance flag. Together, they facilitate analysis and transformation of C++ code elements in Frama-C, such as tracking type definitions and ensuring consistent data handling across analysis passes.",
      "description_length": 735,
      "index": 3477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based operations for managing memory states represented as maps from bases to offset maps, supporting precision tracking through join, widen, and merge operations. It works with structured memory abstractions that associate bases with offset maps, enabling precise or imprecise updates, sub-byte range manipulations, and synchronized traversal via shape-based patterns. Key applications include static analysis tasks requiring memory state merging, caching transformations, and base-centric memory modeling for programs with complex pointer arithmetic.",
      "description_length": 581,
      "index": 3478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise.With_default",
      "library": "frama-c.kernel",
      "description": "Implements lattice operations over zone-indexed maps with a default value, supporting bitwise operations and inclusion checks. Works with abstract data types representing memory zones and their associated values in static analysis. Useful for tracking memory states in program analysis, where each zone's value combines with others via join and meet operations.",
      "description_length": 361,
      "index": 3479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log",
      "library": "frama-c.kernel",
      "description": "This module defines services for managing command-line groups and message handling in a Frama-C plugin. It provides functions to create named option groups, add output aliases for plugin-specific options, and access predefined groups for help and messaging. It works directly with `Frama_c_kernel.Cmdline.Group.t` and string identifiers, primarily used during plugin initialization to configure command-line interfaces and logging behavior.",
      "description_length": 440,
      "index": 3480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.S",
      "library": "frama-c.kernel",
      "description": "This module handles type-checking and coercion for logic expressions, including terms, predicates, and annotations, working with logic types and terms in the context of formal verification. It supports operations like field typing, conditional type conversion, and casting, ensuring correctness during analysis of C code with embedded logic specifications. Concrete use cases include validating function contracts, resolving logic expressions in annotations, and managing type consistency in static analysis.",
      "description_length": 508,
      "index": 3481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval.Make",
      "library": "frama-c.kernel",
      "description": "This module provides operations for constructing and analyzing floating-point intervals with configurable precision (single/double), supporting arithmetic operations, lattice manipulations (join/widen/narrow), and constraint propagation. It works with interval types (`t`) that encapsulate bounds using a specified floating-point representation, including special values like NaN and infinities. These capabilities are applied in static analysis for abstract interpretation, enabling precise handling of floating-point computations in program verification tasks such as value refinement and overflow detection.",
      "description_length": 610,
      "index": 3482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Builtin_functions",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific mapping of built-in compiler functions, associating string keys with C type signatures and vararg flags, supporting operations like insertion, lookup, iteration, and change tracking. It includes utilities for comparing, hashing, and pretty-printing function specifications, as well as deep copying and project membership checks. Built-in entries correspond to compiler intrinsics like GCC or MSVC functions, enabling semantic analysis and type-consistent translation of low-level code. Example uses include resolving compiler-specific functions during CIL translation and maintaining type metadata across analysis sessions.",
      "description_length": 662,
      "index": 3483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Join_Semi_Lattice",
      "library": "frama-c.kernel",
      "description": "This module defines a join semi-lattice structure with operations for combining and comparing elements using a partial order. It provides concrete functions for equality, comparison, hashing, pretty-printing, deep copying, and lattice-specific operations such as `join` and `is_included`. The module works with a specific data type `t` that represents lattice elements, supporting precise dataflow analysis tasks such as value merging and inclusion checks in static analysis plugins.",
      "description_length": 483,
      "index": 3484,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Make",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing operations for CIL (C Intermediate Language) and Frama-C kernel data structures, focusing on converting structured elements like variables, expressions, statements, types, logic predicates, and annotations into human-readable text. It operates on types from `Frama_c_kernel.Cil_types`, including memory allocation constructs, loop annotations, and ACSL specifications, using OCaml's `Format.formatter` for customizable output formatting. These utilities are primarily used for debugging, static analysis reporting, and generating source code or documentation with precise control over presentation details like brace placement and annotation visibility.",
      "description_length": 690,
      "index": 3485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_api.S-module-type-PrinterClass",
      "library": "frama-c.kernel",
      "description": "This module defines the interface for pretty-printing abstract syntax trees (ASTs) in a customizable and extensible manner. It includes operations for formatting and rendering AST nodes, handling indentation, and managing output streams. Concrete use cases include generating human-readable C code from parsed ASTs and producing formatted debugging output during analysis.",
      "description_length": 372,
      "index": 3486,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and manipulating a specific CIL data type, including equality checks, comparison, hashing, and pretty-printing. It supports working with a list of representative values, deep copying, and project-based membership testing. The associated Set, Map, and Hashtbl submodules enable efficient collection handling with standard container operations tailored to this data type.",
      "description_length": 414,
      "index": 3487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Action",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean command-line parameters, including setting values via explicit `on`/`off` actions, registering change hooks, and handling aliases or serialization constraints. It works with boolean state variables (`t`) and associated parameter metadata to control how options interact with parsing, project state, and dynamic behavior. These capabilities are used to implement configurable analysis settings that respond to user input or internal state changes in Frama-C's command-line interface.",
      "description_length": 535,
      "index": 3488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-Service_graph-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for representing service graphs, providing operations to compare, hash, and pretty-print service graph nodes. It supports concrete use cases such as checking membership of project elements within a service graph and performing deep copies to ensure data isolation. The module works directly with `Service_graph.t` and integrates with Frama-C's project and structural description systems for analysis and transformation tasks.",
      "description_length": 456,
      "index": 3489,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Machdep",
      "library": "frama-c.kernel",
      "description": "This module manages machine-dependent configuration state through string options, file path resolution, and validation, ensuring proper AST preparation when loading machdep files. It supports operations for tracking changes, registering hooks, and validating function names, while its child module provides a structured type `t` with introspection and deep copy capabilities for representing machine-specific data during static analysis and AST processing. You can use it to manage project-specific machdep directories, serialize configuration changes, and define aliases or validation rules for machine-dependent settings. The combined interface enables robust handling of abstract data types and state tracking across different machine environments.",
      "description_length": 751,
      "index": 3490,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTO",
      "library": "frama-c.kernel",
      "description": "This module implements the Bourdoncle algorithm to compute a weak topological order (WTO) for a control flow graph represented as interpreted automata. It provides functions to partition the graph into strongly connected components, compare and print these components, and manage node ordering based on graph traversal preferences. Concrete use cases include optimizing abstract interpretation by structuring the analysis according to the control flow hierarchy, enabling efficient fixpoint computations in static analysis.",
      "description_length": 523,
      "index": 3491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing parameters in a plugin, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and uses accessors to link categories to parameter interpretations. Concrete use cases include setting up plugin command-line options grouped under specific categories and controlling how the `@all` category behaves when enabling or disabling sets of parameters.",
      "description_length": 520,
      "index": 3492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Monad.S_with_product-Option",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operations for handling optional values, specifically `iter` and `map`, which apply functions within a monadic context to values wrapped in `option`. It works with data types involving `'a option` and monadic results of type `'a t`. Concrete use cases include chaining computations that may fail or return no result, such as parsing optional fields or conditional state updates in analysis passes.",
      "description_length": 426,
      "index": 3493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.CardinalEstimate",
      "library": "frama-c.kernel",
      "description": "This module estimates the cardinality of abstract memory states or values, providing operations to represent and display these estimates. It defines a type `t` for cardinal estimates and includes values like `one` for unit estimation, along with pretty-printing functions for concise or detailed log10-based output. It is used to quantify the possible concrete states represented by abstract values in memory analysis.",
      "description_length": 418,
      "index": 3494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Shape",
      "library": "frama-c.kernel",
      "description": "This module provides read-only operations for inspecting and analyzing maps with hash-consed tree keys, supporting efficient membership checks, value lookups, and structural queries like cardinality or emptiness tests. It enables advanced traversal and comparison between maps through customizable folds, bilateral iteration, and predicates for inclusion or intersection, particularly useful for analyzing relationships between key-value pairs in static analysis contexts. The operations leverage big-endian Patricia trees for optimized path-based access and cache-aware aggregation over hierarchical data.",
      "description_length": 606,
      "index": 3495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and validating string-based plugin parameters, including setting and retrieving values, enforcing allowed value constraints, and triggering hooks on modifications. It operates on string and string list data structures, supporting use cases such as handling file paths, function names, or configurable options that require validation, dynamic state synchronization, or serialization during plugin execution.",
      "description_length": 451,
      "index": 3496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.List",
      "library": "frama-c.kernel",
      "description": "This module implements operations for lists of values of type `T.t`, including equality, comparison, hashing, and pretty-printing. It provides list-specific functionality such as deep copying, membership checking with project functions, and type descriptors for structural handling. Concrete use cases include managing collections of typed values in Frama-C plugins, such as tracking sets of variables or expressions with associated types.",
      "description_length": 439,
      "index": 3497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter.Make",
      "library": "frama-c.kernel",
      "description": "This module computes invariants for linear filters by analyzing the asymptotic behavior of state dimensions through matrix norms, constructing filters from matrices and vectors over a scalar field to verify convergence and derive precise bounds. It provides core data types such as vectors and matrices with fixed dimensions, supporting operations like addition, multiplication, inversion, and norm calculation, while its submodules enable element-wise vector manipulation and advanced matrix analysis, including power computation and linear recurrence solving. Examples include determining long-term state bounds of recursive systems and analyzing filter stability through spectral norms.",
      "description_length": 689,
      "index": 3498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Unicode",
      "library": "frama-c.kernel",
      "description": "This module manages Unicode handling in the kernel through a configuration flag, providing operations to set, query, and temporarily override Unicode behavior, with integration into project state management for persistence and notifications. It defines the `t` type to represent flag values, supporting equality, comparison, and pretty-printing, while enabling deep copying and structural integrity checks for Unicode data. Submodules extend this functionality to manage descriptors, character sets, and project-specific validations, ensuring consistent Unicode processing across analysis phases. Example uses include enabling Unicode-aware parsing in specific contexts or serializing Unicode data while preserving project membership constraints.",
      "description_length": 746,
      "index": 3499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic4-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype combining four parameter modules, supporting operations like equality, comparison, hashing, and pretty printing. It works with structured data composed of four distinct types, enabling precise representation and manipulation of complex values. Concrete use cases include defining and managing multi-component analysis states or structured intermediate representations in static analysis plugins.",
      "description_length": 438,
      "index": 3500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing string-based plugin parameters with validation, including setting allowed values, handling aliases, and tracking changes via hooks. It works with strings and string lists to enforce constraints, distinguish function names from literals, and support command-line configuration or persistent state across projects. Specific use cases include parameter validation during plugin setup, dynamic configuration updates, and ensuring safe serialization of string values.",
      "description_length": 520,
      "index": 3501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_user_dir",
      "library": "frama-c.kernel",
      "description": "This module constructs a user directory within an existing parent directory. It provides `get_dir` and `get_file` functions to retrieve or create directories and files, ensuring paths exist if `create_path` is set. It operates on strings and returns `Filepath.t` values, handling path resolution and creation. Use it when setting up user-specific directories and files during tool initialization or configuration.",
      "description_length": 413,
      "index": 3502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.MapSet_Lattice-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map lattice structure, including equality, comparison, hashing, and pretty-printing functions. It works with the `Map.Key.t` type, providing deep copy capabilities and membership checks over project skeletons. Concrete use cases include managing and manipulating keys in a lattice-aware map with precise semantic representations and efficient lookups.",
      "description_length": 416,
      "index": 3503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Int-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a concrete implementation of a datatype with support for equality, comparison, hashing, and pretty-printing operations. It works with a specific type `t` that represents values of the datatype, along with associated project-aware operations. It is used to define and manipulate structured data within Frama-C plugins, particularly for tracking and copying values across analysis states.",
      "description_length": 406,
      "index": 3504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages category definitions and configurations for plugin parameters, providing operations to create, modify, and query categories with specific accessors and dependencies. It works with category types and state lists, enabling precise control over parameter behavior in different contexts. Concrete use cases include defining default and special categories like `@all` and `@none`, and setting up parameter interpretations that govern how options are processed and enabled across plugin functionalities.",
      "description_length": 517,
      "index": 3505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL global variables, including equality, comparison, hashing, and pretty-printing, along with metadata access for location, attributes, and project membership. It supports deep copying and standard collection interfaces such as sets, maps, and hash tables, enabling efficient manipulation and organization of global variables during C code analysis. The set module offers operations for union, intersection, and ordered traversal, ideal for tracking variable interactions and dependencies, while the hash table module enables efficient mapping of global identifiers to arbitrary values, supporting memoization and caching of analysis results. The map module provides ordered associative storage with advanced transformations and custom printing, facilitating structured management of CIL entities and analysis data indexed by global variables.",
      "description_length": 898,
      "index": 3506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_label",
      "library": "frama-c.kernel",
      "description": "This module manages logic labels in CIL with operations for equality, comparison, hashing, and pretty-printing, while integrating sets, maps, and hash tables for structured label handling. Its core supports efficient collections through ordered sets for membership and transformation, maps for label-value associations with lookup and iteration, and hash tables for memoization and metadata tracking. You can use it to analyze C code by mapping labels to expressions, merging verification conditions, or filtering label sets during static analysis. Submodules enhance these capabilities with project-aware operations, deep copying, and customizable key-value behaviors for incremental and symbolic processing.",
      "description_length": 709,
      "index": 3507,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Custom-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line option handling. It supports structured data representation with a descriptor, type information, and project membership checks. Concrete use cases include defining and managing configuration parameters with complex internal state in Frama-C plugins.",
      "description_length": 392,
      "index": 3508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Verbose",
      "library": "frama-c.kernel",
      "description": "This component manages verbosity levels for kernel operations, providing functions to set and retrieve integer-based levels, register change hooks, enforce value ranges, and handle command-line configuration. It supports structured verbosity data types with serialization, deep copying, and comparison operations, enabling precise control over log output granularity and user-defined settings via CLI or project configurations. The module allows for introspection and manipulation of verbosity states, including membership queries and pretty-printing, particularly for analysis and transformation tasks involving complex project data. Example uses include persisting verbosity settings across sessions and dynamically adjusting logging detail during kernel execution.",
      "description_length": 767,
      "index": 3509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic3",
      "library": "frama-c.kernel",
      "description": "This module manages polymorphic type constructors with three parameters, enabling creation, inspection, and matching of structured types. It supports operations like instantiation from concrete types, schema checking, and extraction of component types, with applications in static analysis plugins for tuples, variants, and parameterized structures. The child module enhances this by providing equality, comparison, and serialization for polymorphic combinations of any three types conforming to the `t` interface. Together, they allow precise manipulation of complex datatypes with deep copying and structural analysis.",
      "description_length": 620,
      "index": 3510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes property-centric data around a key type that uniquely identifies Frama-C kernel properties, supporting ordered storage and functional transformations like `add`, `merge`, and `filter_map`. It combines polymorphic value handling with strict key ordering and integrates pretty-printing, sequence conversions, and deep-copy operations for managing analysis metadata across codebases. A child module defines the key structure with equality, comparison, and projection checks, while another provides typed maps for concrete data modules, enabling use cases such as tracking value states at program points or aggregating structured analysis results keyed by property identifiers. Together, they form a cohesive system for precise, scalable property tracking and transformation in formal verification workflows.",
      "description_length": 826,
      "index": 3511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.FloatRelative",
      "library": "frama-c.kernel",
      "description": "This module manages a global mutable boolean flag that controls floating-point relative behavior, offering functions to set, retrieve, and reset its state, along with mechanisms for alias registration, custom serialization, and change notifications. It defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, enabling precise handling of `-float-relative` settings across analysis contexts. The module supports project-specific persistence and integration with state management systems, allowing components to react to changes or maintain consistent configurations. Use cases include analyzing, transforming, or serializing floating-point relative settings during static analysis.",
      "description_length": 720,
      "index": 3512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.S",
      "library": "frama-c.kernel",
      "description": "This module defines a hook mechanism for registering and applying functions that take a `param` and return a `result`. It supports adding functions with `extend`, conditional addition with `extend_once`, and applying all registered functions in registration order. Use it to manage extensible callback chains, such as for analysis extensions or event handlers in static analysis plugins.",
      "description_length": 387,
      "index": 3513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Make_table",
      "library": "frama-c.kernel",
      "description": "This module implements a specialized table structure that maps keys to emitter-specific data with efficient lookup, insertion, and removal. It supports operations like `add`, `find`, `mem`, and `remove` for managing bindings, along with iteration and folding over keys in arbitrary or sorted order. The table handles cleanup correctly by allowing hooks to be registered and invoked when bindings are removed, ensuring proper resource management during analysis.",
      "description_length": 461,
      "index": 3514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SafeArrays",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that enables or disables array safety checks, providing operations to set, query, and track changes to the flag's state while supporting project-specific configurations and serialization. It defines a data type `t` with equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership checks over project skeletons. The core functionality controls whether Frama-C performs runtime bounds checking on array accesses during static analysis, enabling safety guarantees or precision tuning based on context. Plugins can use these capabilities to manipulate and reason about array data structures with safety assurances.",
      "description_length": 695,
      "index": 3515,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Polymorphic3-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a polymorphic datatype combining three other datatypes, supporting operations like equality, comparison, hashing, and pretty-printing. It works with any three datatypes that conform to the `Frama_c_kernel.Datatype` interface, allowing structured representation and manipulation of heterogeneous data. Concrete use cases include defining composite data structures for static analysis plugins, such as abstract values combining multiple analysis dimensions.",
      "description_length": 475,
      "index": 3516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State.Set",
      "library": "frama-c.kernel",
      "description": "This module provides ordered set operations for managing state elements, including union, intersection, difference, and element insertion/removal, while preserving physical equality for unchanged sets. It supports ordered traversal, predicate-based searches, and transformations like mapping and filtering, with utilities to convert sets to ordered sequences or lists and test membership. These capabilities are used in static analysis to track program states, perform efficient state-set comparisons, and implement algorithms requiring ordered state processing during code verification.",
      "description_length": 587,
      "index": 3517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides specialized hash table operations for managing alarm keys and associated values, with support for efficient insertion, lookup, filtering, and in-place modifications. It includes a key module that defines structured keys with equality, comparison, and hashing, enabling type-safe indexing of alarm data, and a value module that specializes hash tables for specific data types, offering efficient storage and integrity checks. Together, they enable use cases such as tracking alarm states with structured keys, caching alarm-related computations, and generating ordered summaries using customizable comparison logic. The interface supports sorted iteration, memoization, and conversion to sequences for structured data processing.",
      "description_length": 749,
      "index": 3518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S-Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a single function `only_if` that conditionally executes a monadic action based on a boolean value. It operates on boolean values and unit-returning monadic actions (`unit t`). A concrete use case is selectively running a logging or side-effecting operation only when a condition is true, within a monadic context.",
      "description_length": 334,
      "index": 3519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Fundec_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for function declarations (`Fundec`) with operations for membership, comparison, and pretty-printing. It supports efficient set operations such as union, intersection, and difference, along with project-aware filtering via `mem_project`. Typical use cases include tracking and manipulating collections of functions during static analysis, such as collecting callees or filtering functions based on project-specific criteria.",
      "description_length": 468,
      "index": 3520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage command-line options storing lists of filepaths, with functionality for value updates, default retrieval, serialization, and handling aliases or deprecation. It works with collections of filepaths (`Frama_c_kernel.Filepath.t`), supporting element addition, iteration, folding, and list appending, while submodules enable categorization and contextual metadata. It is particularly useful for configuring project-specific file paths, tracking state changes, or implementing options that require ordered file lists (e.g., include paths or input sources).",
      "description_length": 593,
      "index": 3521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for file paths represented as strings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with `As_string.Datatype.t` values, which encapsulate string-based data for Frama-C's internal structures. Concrete use cases include defining and manipulating file path options in Frama-C plugins, such as specifying input files or output directories via the command line.",
      "description_length": 451,
      "index": 3522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for kernel functions with multiple values per key, supporting operations like adding, finding, and iterating over entries. It works with kernel function identifiers as keys and lists of arbitrary values as mapped data. It is used to associate multiple pieces of analysis or plugin-specific metadata with functions in the C abstract syntax tree.",
      "description_length": 383,
      "index": 3523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Kernel_function_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines operations for a set of kernel functions represented as strings, including equality, comparison, hashing, and pretty-printing. It works with the `As_string.Datatype.t` type, which encapsulates values that can be represented as strings. Concrete use cases include managing and manipulating sets of function names or identifiers in a type-safe manner, particularly during analysis or transformation tasks in the Frama-C framework.",
      "description_length": 448,
      "index": 3524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for use in hashtables, including equality, comparison, hashing, and pretty-printing functions. It supports concrete data types like `Hashtbl.Key.t` with utilities for deep copying, membership testing within projects, and type descriptors for serialization. Use cases include managing and manipulating keys in a hashtbl-based registry or context-specific storage.",
      "description_length": 421,
      "index": 3525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Empty_string",
      "library": "frama-c.kernel",
      "description": "This module enables managing string-valued configuration parameters for Frama-C plugins, including setting and retrieving values, validating user inputs against allowed patterns, and maintaining state persistence. It operates on string data with support for command-line interface integration and value change notifications, facilitating tasks like option parsing, function name resolution, and session state management. Specific use cases include enforcing valid command-line argument formats, propagating configuration changes across plugin components, and preserving state between analysis sessions.",
      "description_length": 602,
      "index": 3526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Sid",
      "library": "frama-c.kernel",
      "description": "This module generates unique integer identifiers, providing the `next` function to obtain a new identifier each time it is called. It maintains an internal counter that increments with each invocation, ensuring that identifiers are unique and sequential. This is useful for assigning distinct labels or indices to elements in analyses or transformations that require fresh, non-repeating numeric tags.",
      "description_length": 401,
      "index": 3527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.User_dir_opt",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manage a user directory path that can be overridden. It supports retrieving and setting directory or file paths with optional path creation, working with `Frama_c_kernel.Filepath.t` values. It is used to handle user-specified directories during analysis, ensuring paths exist or accessing predefined locations.",
      "description_length": 344,
      "index": 3528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintConfigJson",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls JSON serialization behavior, enabling or disabling output generation via the `-print-config-json` command-line option. It provides operations to set, retrieve, and monitor changes to the flag, integrating with project state tracking and parameter parsing. The child module enhances this functionality by defining rich configuration data structures that support comparison, hashing, and pretty-printing, allowing precise control over JSON output for kernel plugins. Together, they enable state-aware configuration management and structured data manipulation for projects using JSON-based serialization.",
      "description_length": 664,
      "index": 3529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with `Category.t` values, which represent parameter categories, and interacts with `State.t` lists to control behavior. Concrete use cases include setting up default parameter behaviors, enabling all parameters under a specific interpretation, and defining how categories respond to command-line flags.",
      "description_length": 475,
      "index": 3530,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements hash tables optimized for managing key-value associations where keys represent memory base identifiers, supporting ordered traversal with custom comparisons and in-place transformations such as filtering and memoization. The main data types include keys with rich structural operations and typed values enabling deep copying, equality, and projection-based queries. It allows safe value retrieval with defaults, making it suitable for tracking memory zone validity, caching analysis results, and processing addressable memory regions deterministically. Submodules specialize in key management and typed value storage, enabling precise and scalable static analysis of memory structures.",
      "description_length": 708,
      "index": 3531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_list",
      "library": "frama-c.kernel",
      "description": "This module provides functionality for managing command-line options represented as string lists, supporting operations to set and retrieve values, register change hooks, define aliases, and generate help messages. It works with string lists as the core data type, offering utilities for appending elements, iterating, folding, and checking emptiness, alongside project-specific state tracking and serialization. It is particularly suited for scenarios requiring dynamic configuration through command-line arguments, with nested categorization structures to organize related options.",
      "description_length": 583,
      "index": 3532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing string-based command-line parameters with support for value validation, alias handling, and state change notifications. It works with string collections and function name registries to enforce constraints, allowing parameters to accept only predefined values or dynamically resolved identifiers. Typical use cases include parsing validated options like configuration switches or plugin-selecting identifiers while maintaining extensibility and project-specific state tracking.",
      "description_length": 534,
      "index": 3533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module offers hash table operations specialized for keys adhering to a mathematical field structure, enabling efficient insertion, lookup, and iteration with both functional and imperative interfaces. It supports ordered traversal by keys or values, conversion to sequences, and memoization with default values, operating on hashtables that map field elements to arbitrary data. These capabilities are particularly useful in symbolic computation and floating-point analysis where algebraic precision and ordered data manipulation are critical.",
      "description_length": 548,
      "index": 3534,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.With_Narrow",
      "library": "frama-c.kernel",
      "description": "Implements a narrowing operator for lattice elements, computing an over-approximation of the intersection of two values of type `t`. Works directly with lattice structures defined in the parent module, supporting analysis refinement in static analysis contexts. Useful for improving precision in abstract interpretation by iteratively tightening approximations.",
      "description_length": 361,
      "index": 3535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Collection-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based command-line parameters with validation, aliasing, and state tracking capabilities. It works with string values, validated against predefined allowed values or function name constraints, and supports custom marshaling and dynamic state computation through hooks. Typical use cases include parsing and validating configuration options that require strict value checks, dynamic default resolution, or cross-referencing with other system components via function names.",
      "description_length": 523,
      "index": 3536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-E",
      "library": "frama-c.kernel",
      "description": "This module defines operations for constructing and manipulating directed edges in a control flow graph, where each edge has a source and destination vertex along with a label. It supports concrete operations like creating edges with specified labels and vertices, comparing edges, and retrieving edge labels and endpoints. This structure is used to represent transitions between control points in an interpreted automaton, capturing guards and actions derived from CIL code.",
      "description_length": 475,
      "index": 3537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.Backwards",
      "library": "frama-c.kernel",
      "description": "Implements backward data flow analysis by computing transfer functions from a list of initial statements (sinks) and populating statement start data. Works with CIL statements (`Cil_types.stmt`) and user-defined data domains via the parameter module. Useful for analyses like liveness or constant propagation where information flows from uses to definitions.",
      "description_length": 358,
      "index": 3538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Fundec_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type with operations for managing a set of function declarations (`Fundec_set`) represented as strings. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Concrete use cases include tracking and manipulating sets of functions during static analysis, such as in Frama-C plugins for C code verification.",
      "description_length": 409,
      "index": 3539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-based command-line parameters with support for validation, alias handling, and state synchronization. It works with string values that can be constrained to predefined allowed sets or validated against function name patterns, while tracking modifications through hooks and persisting state across projects. Typical use cases include configuring analysis settings in static analysis tools where dynamic parameter updates, input validation, or cross-component state consistency are required.",
      "description_length": 538,
      "index": 3540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_map",
      "library": "frama-c.kernel",
      "description": "This module provides map-based parameter management for configuration values, supporting key-value associations with unique bindings, atomic updates, and change monitoring via hooks. It operates on typed maps using key (`K.t`) and value (`V.t`) representations, offering iteration, folding, membership checks, and custom serialization through a structured state type (`Datatype.t`). Designed for command-line interface configuration, it enables dynamic parameter updates, alias definitions, and introspection for use cases like persistent settings or interactive option parsing.",
      "description_length": 578,
      "index": 3541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes a family of components centered around maps with rational-number keys and rich value manipulation. It provides core operations for creating, querying, and transforming maps, along with key-specific utilities for equality, comparison, and hashing. The main data types include map structures and rational keys, supporting operations like insertion, lookup, iteration, and deep copying. Examples include tracking symbolic analysis states with precise key comparisons and serializing maps for checkpointing or inter-process communication.",
      "description_length": 556,
      "index": 3542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior.Unset",
      "library": "frama-c.kernel",
      "description": "This module provides functions to remove entries for specific AST elements from a visitor's state, ensuring they are not revisited in the same context. It operates on data types like `varinfo`, `compinfo`, `stmt`, and various logic and type information structures. Use these functions to explicitly unset tracked elements during AST traversal when they should no longer be processed.",
      "description_length": 383,
      "index": 3543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Float-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a float-based data type with operations for equality, comparison, hashing, and pretty-printing. It supports integration into Frama-C's plugin system by providing structural descriptions and project membership checks. Concrete use cases include representing and manipulating floating-point values in static analysis plugins, such as tracking numerical ranges or abstract values.",
      "description_length": 397,
      "index": 3544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AsmContractsAutoValidate",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls automatic validation of assembly contracts during analysis, with support for project-specific persistence and dynamic toggling via `on`/`off` operations. It provides a data type `t` with equality, comparison, and pretty-printing operations to represent and manipulate validation states, enabling precise handling of per-project settings. Observers can register for change notifications, ensuring external systems stay synchronized with the current validation policy. Use cases include enforcing conditional contract validation and preserving analysis settings across sessions for different assembly codebases.",
      "description_length": 672,
      "index": 3545,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.AI_Lattice_with_cardinal_one",
      "library": "frama-c.kernel",
      "description": "This module defines a lattice structure with cardinality at most one, supporting operations like equality checks, inclusion tests, join/meet combinations, and intersection analysis for abstract interpretation elements. It works with a polymorphic type `t` representing abstract values that may include top and bottom elements, alongside specialized functions for project membership (`mem_project`) and under-approximated unions (`link`). The `intersects` function enables static analysis of program properties by verifying non-empty overlaps between abstract domains, useful in scenarios like value range analysis or program verification.",
      "description_length": 638,
      "index": 3546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Global_annotation",
      "library": "frama-c.kernel",
      "description": "This module handles global annotations in CIL with core operations for equality, comparison, hashing, and pretty-printing, while organizing annotations through attributes and source locations. It includes set, map, and hash table modules for managing collections, enabling tasks like tracking function annotations or aggregating metadata across C programs. The set module supports union, intersection, and filtering, the map module associates annotations with values using physical equality optimizations, and the hash table module enables imperative updates and safe lookups. These components collectively support static analysis plugins that analyze or transform C code based on attached metadata.",
      "description_length": 699,
      "index": 3547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Register",
      "library": "frama-c.kernel",
      "description": "Registers a new state with a specified data type, providing operations to mark the state as computed, check its computed status, add update hooks, and define custom marshaling. Works with the `State.t` type and a user-defined `Datatype` module. Used to manage and persist analysis states within a Frama-C plugin, such as tracking analysis progress or serializing intermediate results.",
      "description_length": 384,
      "index": 3548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypByName",
      "library": "frama-c.kernel",
      "description": "This module represents CIL types with structural comparison based on type names, supporting equality, hashing, comparison, and pretty printing, along with deep copying and standard container operations. Its hash table submodule enables imperative management of type-to-data mappings with efficient lookup and memoization, useful for caching analysis results or aggregating type-based metadata. The map submodule organizes ordered associations between CIL types and arbitrary values, supporting transformations, ordered traversal, and project-aware operations for tracking type-specific properties across codebases. Together, these components provide a coherent toolkit for handling type-based data structures with name-sensitive equivalence in static analysis.",
      "description_length": 760,
      "index": 3549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Action-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a polymorphic type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with descriptors, type information, and project membership checks. Concrete use cases include managing plugin-specific data types with strong identity and structural consistency across analysis sessions.",
      "description_length": 398,
      "index": 3550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintPluginPath",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls the output of plugin path information during execution, offering operations to toggle its state, query its value, and bind it to command-line arguments. It integrates with project state management to persist changes and supports serialization for distributed or scripted workflows, operating primarily on a simple boolean type. The child module defines a structured, type-safe representation of plugin paths with support for equality checks, comparison, hashing, pretty-printing, and deep copying, enabling precise inspection and filtering based on project data. Together, they allow users to enable diagnostic output for plugin loading issues or automate environment setup by controlling path visibility programmatically.",
      "description_length": 785,
      "index": 3551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.Plugins",
      "library": "frama-c.kernel",
      "description": "This module manages the discovery and loading of Frama-C plugins. It provides access to plugin directories, a search path, and functions to load individual or all plugins, respecting GUI mode constraints. It works with file paths and string-based plugin names, targeting plugin initialization during Frama-C startup or on-demand execution.",
      "description_length": 339,
      "index": 3552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Debug-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured data type with support for equality, comparison, hashing, and pretty-printing operations. It works with a custom `t` type that represents debug data, including descriptors, project membership checks, and deep copying. Concrete use cases include managing and comparing debug information within static analysis plugins, such as tracking and serializing analysis states or debugging artifacts.",
      "description_length": 423,
      "index": 3553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Time",
      "library": "frama-c.kernel",
      "description": "This module handles string-based option parsing and validation for a `-time` parameter, providing operations to set and retrieve values, enforce allowed inputs, and register hooks for dynamic state updates. It defines a core data type `t` with support for equality, comparison, hashing, and pretty-printing, along with structured representations for introspection and serialization. Submodules extend this functionality to manage time-related data across analysis contexts, enabling use cases such as configuring analysis settings, validating user input, and tracking state mutations. It integrates with kernel systems to support persistence, aliases, and deep copying, ensuring consistent handling of time values in plugins and command-line interfaces.",
      "description_length": 753,
      "index": 3554,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Stmt_Id",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and comparing statement identifiers in CIL, including equality checks, comparison, hashing, and pretty printing. It works with the `stmt` type from CIL, offering functions to retrieve identity keys, perform deep copies, and check project membership. Concrete use cases include tracking and comparing CIL statements within analysis plugins, ensuring unique identification and efficient storage in data structures like hash tables.",
      "description_length": 474,
      "index": 3555,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.BACKWARD_MONOTONE_PARAMETER",
      "library": "frama-c.kernel",
      "description": "Implements a backward dataflow analysis framework for statement-level transformations using a monotonic lattice structure. It provides operations to merge states (`join`), compare them (`is_included`), and apply statement-specific logic to propagate information backward through code. This module is used to analyze properties that depend on post-execution states, such as liveness or postconditions, by computing fixpoints starting from specified initial statements.",
      "description_length": 467,
      "index": 3556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific cache directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Concrete use cases include storing temporary analysis results or persistent plugin data in a structured and isolated location.",
      "description_length": 390,
      "index": 3557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Session",
      "library": "frama-c.kernel",
      "description": "Handles plugin-specific session directories and files within Frama-C. It provides operations to retrieve or create session directories and files, set or query the user directory, and check if the user directory has been configured. This module is used when plugins need to manage per-session storage, such as caching analysis results or storing plugin-specific configuration files.",
      "description_length": 381,
      "index": 3558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Binary_Predicate",
      "library": "frama-c.kernel",
      "description": "Implements a binary cache for storing and querying boolean results based on two input values from distinct types. Uses two underlying hash tables to efficiently track and retrieve computed results of a given predicate function. Useful for avoiding redundant comparisons between pairs of elements from separate domains, such as checking relationships between abstract values in static analysis.",
      "description_length": 393,
      "index": 3559,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_set_and_map-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for map keys, providing equality, comparison, hashing, and pretty-printing operations. It works with the `Map.Key.t` type, offering functions to check membership in projects, create deep copies, and describe key values. Concrete use cases include managing and comparing keys in maps used for project analysis and value tracking.",
      "description_length": 359,
      "index": 3560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Exp",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL expressions, including structural manipulation, comparison, and transformation. It supports key data types like expressions with `eid`-based identity, and offers utilities for deep copying, hashing, and pretty-printing. You can analyze or modify C code expressions during static analysis, such as tracking variable uses or evaluating constants. Combined with its submodules, it enables efficient expression indexing via hash tables, ordered set operations, and structural map transformations, supporting tasks like memoization, dependency tracking, and structured traversal in analysis pipelines.",
      "description_length": 654,
      "index": 3561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filter.RemoveInfo",
      "library": "frama-c.kernel",
      "description": "This module provides visibility control operations for filtering elements within CIL functions during program analysis or transformation. It works with CIL data structures such as functions, statements, and control-flow edges, enabling selective exposure or hiding of components like parameters, variables, annotations, and contracts. Specific use cases include conditional branch simplification via `cond_edge_visible` and generating optimized or domain-specific program variants by removing irrelevant elements.",
      "description_length": 513,
      "index": 3562,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table with values structured as a lattice, enabling operations like equality, comparison, and pretty-printing. It supports deep copying, hashing, and project-based membership checks, tailored for lattice-structured data analysis. Concrete use cases include managing abstract values in static analysis where lattice properties are essential for fixpoint computations.",
      "description_length": 396,
      "index": 3563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages file paths for a plugin's state directory, providing functions to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing plugins to store and access persistent data. Concrete use cases include saving intermediate analysis results or configuration files in a plugin-specific directory during static analysis.",
      "description_length": 405,
      "index": 3564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a command-line parameter that holds a set of strings, including adding elements, checking membership, iteration, folding, handling aliases, and customizing serialization. It operates on a set-based data structure and is used for configuring parameters that collect multiple string values, such as include paths or plugin identifiers, while supporting dynamic updates and value observation.",
      "description_length": 434,
      "index": 3565,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Predicate",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL predicates, including equality, comparison, hashing, and pretty-printing. It supports data types related to logical conditions in CIL, such as expressions and annotations. Use cases include analyzing and transforming C code assertions, managing predicate-based specifications during static analysis, and integrating with Frama-C's internal logic for verification tasks.",
      "description_length": 421,
      "index": 3566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Fundec_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories for plugin configurations, providing operations to define, modify, and query category states. It works with category types and state lists, enabling precise control over plugin behavior through named categories like '@none', '@default', and '@all'. Concrete use cases include setting default parameter interpretations, enabling all parameters with specific accessors, and defining dependencies for custom categories.",
      "description_length": 457,
      "index": 3567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LogicalOperators",
      "library": "frama-c.kernel",
      "description": "This module manages the preservation of logical operators (`&&`, `||`) in their original form within the AST, avoiding their conversion into conditional statements. It maintains a global state flag with operations to enable, disable, and query this behavior, along with support for serialization, default values, and project-specific configurations. A dedicated data type represents logical operators, enabling equality checks, comparison, hashing, pretty-printing, deep copying, and membership testing. This functionality is essential for analyses requiring precise tracking of logical expressions, such as value analysis or source-to-source transformations, while ensuring structural integrity across different processing stages.",
      "description_length": 731,
      "index": 3568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins.Gcc_builtin_templates_loaded",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean state indicating whether GCC built-in templates are loaded in a Frama-C project, offering operations to set, get, and clear the state, along with hooks for reacting to state changes. It ensures state immutability once marked as computed for a given project and supports custom serialization via marshaling functions. The child module defines a concrete type `t` representing individual GCC built-in templates, providing equality, comparison, hashing, and pretty-printing operations, along with accessors for metadata such as name, type, and descriptor. Together, they enable precise tracking and manipulation of GCC-specific constructs during static analysis, allowing plugins to conditionally execute logic based on template availability and analyze template properties in a project-specific context.",
      "description_length": 831,
      "index": 3569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_ref",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and inspection of monomorphic instantiations of polymorphic types, supporting operations such as type instantiation, parameter extraction, and type representation generation. It works directly with type values and polymorphic constructors, allowing concrete manipulations like checking type arguments or building specific type instances. The child module extends this by generating monomorphic datatypes with standard operations\u2014equality, comparison, hashing, and pretty printing\u2014supporting deep copies and membership checks within a structured type environment. Together, they facilitate tasks such as tracking typed references in static analysis, where polymorphic types must be concretized and manipulated with precision across program states.",
      "description_length": 779,
      "index": 3570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage command-line parameters represented as string lists, supporting dynamic updates via hooks, default value handling, and alias resolution. It works with list-based collections integrated into the Frama_c_kernel project system, enabling state tracking and serialization. Typical use cases include parsing ordered string sequences (e.g., include paths, source files) with support for concatenation, emptiness checks, and categorized grouping through its submodules.",
      "description_length": 503,
      "index": 3571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Symmetric_Binary",
      "library": "frama-c.kernel",
      "description": "Implements symmetric binary operations over cached values using a merge function that combines two `H.t` values into an `R.t`. It supports efficient caching of results for pairs of inputs where the order does not matter, such as equality checks or commutative operations. Useful for memoizing relationships or comparisons between abstract values where duplicates would be redundant.",
      "description_length": 382,
      "index": 3572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEq",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality, comparison, and hashing for CIL expressions, enabling their use in sets, maps, and hash tables. It supports deep copying, pretty printing, and membership checks based on embedded project values, facilitating analysis and transformation of C code by structure. Hash tables allow keyed lookups and memoization, sets enable union and ordered traversal operations, and maps support aggregation and filtering by expression keys. Examples include caching transformation results, tracking structurally equivalent expressions, and building analysis state mappings with precise key handling.",
      "description_length": 623,
      "index": 3573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports managing string command-line parameters with operations to set and validate values against allowed lists, handle aliases, and track state changes via hooks. It works with string parameters that may reference function names or constrained string sets, enabling use cases like enforcing valid file paths, restricting inputs to predefined options, or dynamically validating user-provided strings against custom criteria. The design emphasizes integration with project-specific state management and serialization workflows.",
      "description_length": 540,
      "index": 3574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Empty_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling empty strings within Frama-C's plugin system. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to represent and manipulate string values that are guaranteed to be empty in static analysis contexts.",
      "description_length": 352,
      "index": 3575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table data structure where keys are associated with values of type `Data.t`. It provides standard operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to manage and manipulate collections of values tied to a specific project analysis context in Frama-C.",
      "description_length": 377,
      "index": 3576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list of file paths as a command-line parameter type, supporting operations like equality checking, comparison, hashing, and pretty-printing for user-friendly display. It works with a custom `t` type representing the list of file paths, along with standard types like `Project_skeleton.t` for project-specific filtering. Concrete use cases include parsing and managing input file lists from command-line arguments, ensuring deep copying and project-aware membership checks.",
      "description_length": 497,
      "index": 3577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module provides command-line parameter management for kernel function sets, supporting operations like value assignment, update hook registration, default retrieval, and serialization. It works with `Frama_c_kernel.Cil_datatype.Kf.Set.t` collections and individual `kernel_function` elements, enabling customization through aliases, visibility flags, and deprecation warnings. Use cases include configuring analysis tools to handle dynamic sets of functions while maintaining compatibility with legacy options or conditional visibility rules.",
      "description_length": 547,
      "index": 3578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Fundec_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents a set of function declarations (`Fundec`) with string-based identifiers, providing operations for equality, comparison, hashing, and pretty-printing. It supports command-line option handling by managing sets of function names as values of type `As_string.Datatype.t`. Concrete use cases include tracking and manipulating collections of functions for analysis plugins, such as specifying entry points or filtering targets during static analysis.",
      "description_length": 467,
      "index": 3579,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Block",
      "library": "frama-c.kernel",
      "description": "This module defines operations for working with CIL block data structures, including equality, comparison, hashing, and pretty-printing functions. It provides utilities to check membership within projects, create deep copies, and access block representations and descriptors. Concrete use cases include analyzing and transforming C code blocks during static analysis, such as tracking memory layouts or control flow constructs in Frama-C plugins.",
      "description_length": 446,
      "index": 3580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.MainFunction",
      "library": "frama-c.kernel",
      "description": "This module manages command-line configuration and behavior for selecting and validating the entry point function in Frama-C, coordinating between string-based function names and structured data representations. It provides operations to set, retrieve, and validate the main function, enforcing correctness through hooks and supporting state changes during analysis. The child module introduces a dedicated type for entry points with equality, comparison, and project membership checks, enabling robust tracking and manipulation during static analysis. Together, they support use cases like custom entry point selection, plugin-driven validation, and consistent handling of main function aliases or state transitions.",
      "description_length": 717,
      "index": 3581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl_weak",
      "library": "frama-c.kernel",
      "description": "This module provides a weak hash table optimized for hashconsing immutable data, ensuring equivalent values share the same physical representation to improve memory efficiency and comparison speed. It supports key operations like `add`, `find`, `mem`, and `merge`, while allowing entries to be garbage-collected when no longer referenced externally. The child module extends this functionality by adding type-specific handling for equality, hashing, deep copying, and pretty printing, making it suitable for managing interned structures like AST nodes or symbolic expressions. Together, they enable efficient value-based deduplication and manipulation of large sets of immutable data without manual memory management.",
      "description_length": 717,
      "index": 3582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Enum-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugins. It supports structured data representation with a list of representative values, a unique name, and a descriptor for type handling. Concrete use cases include defining plugin-specific data types that require serialization, comparison, or integration with Frama-C's analysis frameworks.",
      "description_length": 425,
      "index": 3583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Zero",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing mutable integer parameters with change tracking and constrained integer values with range enforcement. It works with project state tracking systems and typed parameter structures to support dynamic configuration, including setting default values, handling command-line input, and serializing state changes. These capabilities are particularly useful for plugin developers implementing interactive analysis tools that require validated numeric inputs or persistent state management within Frama-C's analysis framework.",
      "description_length": 562,
      "index": 3584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LoadLibrary",
      "library": "frama-c.kernel",
      "description": "This module orchestrates command-line handling for library loading by combining string list manipulation with stateful hooks and category-based filtering, enabling transformations like concatenation and marshaling for persistent configurations. It supports core operations such as alias resolution, value setting, and validation, while submodules refine behavior through category management, typed parameter definitions, and structured library descriptors. Users can define custom load paths, group options under named categories like `@default`, and ensure correctness via equality checks and pretty-printing. It powers Frama-C's `-load-library` interface by enabling plugin-specific parsing, dynamic configuration tracking, and structured representation of loadable modules.",
      "description_length": 776,
      "index": 3585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure where keys are of type `Data.t` and values are structured according to the enclosing module's specifications. It provides standard map operations including comparison, equality, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is suitable for managing collections of structured values in static analysis plugins where precise data representation and efficient value comparison are required.",
      "description_length": 476,
      "index": 3586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cmdline.Group",
      "library": "frama-c.kernel",
      "description": "This module manages groups of command line options, providing access to their names and a default group instance. It works with the abstract type `t` representing a group. Concrete use cases include organizing related command line flags under named groups for better user documentation and grouping options logically for plugins or analysis modules.",
      "description_length": 349,
      "index": 3587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Fval.F",
      "library": "frama-c.kernel",
      "description": "This module implements precise floating-point interval arithmetic, supporting operations like conversion to and from floats, comparison, and pretty-printing. It works with a private type `t` representing floating-point intervals, including special values like \u00b10 and infinities. Concrete use cases include static analysis of floating-point computations in C code, where precise handling of rounding and overflow is required.",
      "description_length": 424,
      "index": 3588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_array",
      "library": "frama-c.kernel",
      "description": "This module provides operations to instantiate, check, and retrieve monomorphic array types from polymorphic representations, enabling precise handling of typed arrays with fixed element types. It supports key operations such as type creation, equality, comparison, hashing, and pretty printing, facilitating use cases like static analysis and structured data manipulation. For example, it allows defining an `int list` type from a polymorphic `'a list` and verifying or extracting element types for analysis in Frama-C plugins. Submodules focus on concrete array instantiations, enhancing type precision and data representation for fixed-type elements.",
      "description_length": 653,
      "index": 3589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Session",
      "library": "frama-c.kernel",
      "description": "This module manages file paths within a plugin's session directory, providing direct access to directories and files specific to the current analysis session. It supports operations to retrieve or create session directories and files, and allows setting or checking the session directory path. Concrete use cases include storing and retrieving plugin-specific configuration files, analysis results, or temporary data within Frama-C's session structure during static analysis.",
      "description_length": 475,
      "index": 3590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for string lists with operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to handle string list parameters in Frama-C plugins, ensuring deep copying and project membership checks. Concrete use cases include defining and managing lists of file paths, include directories, or preprocessor definitions as plugin command-line arguments.",
      "description_length": 420,
      "index": 3591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic",
      "library": "frama-c.kernel",
      "description": "This module provides functions to create and manipulate monomorphic instances of polymorphic types. It works with type values representing polymorphic data structures, such as lists or options, and allows instantiating them with specific types, checking if a type is an instance, or retrieving the base type used for instantiation. Concrete use cases include handling type representations for polymorphic containers in static analysis plugins.",
      "description_length": 443,
      "index": 3592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Position",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates source code positions with file, line, and column information, offering equality, comparison, hashing, and pretty-printing operations. It supports conversions to and from Lexing.position and enables tracking of source locations during parsing, error reporting, and AST transformations. The module's submodules provide hash tables, maps, and sets for associating typed data with positions, supporting operations like insertion, lookup, filtering, and ordered traversal. Examples include storing analysis results per line, tracking error locations, or performing set operations to support static analysis tasks like code slicing and error tracing.",
      "description_length": 684,
      "index": 3593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map for file paths as strings, supporting operations like equality, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type to represent file paths and provides deep copying, membership testing, and project-specific queries. Concrete use cases include managing and comparing file path options in command-line interfaces or configuration systems.",
      "description_length": 402,
      "index": 3594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Location",
      "library": "frama-c.kernel",
      "description": "This module handles source code location information in CIL with utilities for equality, comparison, and hashing based on normalized file, line, and column data. It includes sets, maps, and hash tables for efficient storage and manipulation of locations, supporting operations like union, insertion, lookup, and ordered traversal. You can use it to track error locations, associate metadata with code regions, or aggregate analysis results across multiple projects. Specific capabilities include converting locations to lexing positions, performing set algebra on location ranges, and mapping locations to arbitrary data for caching or annotation purposes.",
      "description_length": 656,
      "index": 3595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Lattice_Product",
      "library": "frama-c.kernel",
      "description": "This module combines two lattice structures into a product lattice with explicit handling of Bottom, enabling lattice operations like join, meet, and narrowing that compute under-approximations of unions and intersections. It supports structural manipulations such as projections (`fst`, `snd`), injections, and cardinality checks, while providing comparison, hashing, and pretty-printing utilities. It is used in abstract interpretation to model complex program properties by pairing complementary lattices, such as tracking numerical ranges and pointer relationships simultaneously.",
      "description_length": 584,
      "index": 3596,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.TypeCheck",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration flag that controls type checking behavior, enabling dynamic activation or deactivation of type validation during analysis. It provides operations to modify, query, and monitor changes to this state, integrating with command-line options, project contexts, and serialization mechanisms. The child module defines structured data types for representing type-checking entities, supporting equality, comparison, and pretty-printing to facilitate precise semantic analysis. Together, they enable use cases such as enforcing type consistency in C code and extending type validation logic in plugins.",
      "description_length": 636,
      "index": 3597,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_multiple_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-based command-line parameters with support for value validation, alias resolution, and state persistence. It works with string data (`As_string.t`) and structured configurations that distinguish between plain strings and function names, enabling use cases like validating user-provided values against predefined options or dynamically triggering callbacks when parameter values change. The module also supports custom serialization and integration with larger parameter state management systems.",
      "description_length": 544,
      "index": 3598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_collections-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for map keys, including equality, comparison, and hashing operations. It supports structured values of type `Map.Key.t` with functionalities for pretty-printing, deep copying, and checking membership based on project projections. It is used to manage key-based data in maps with precise type handling and structural operations.",
      "description_length": 358,
      "index": 3599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports configuration, validation, and state management of string-based plugin parameters, including operations to define allowed values, register change hooks, and resolve aliases. It works with string data and associated metadata structures to enforce constraints, track function name validity, and persist parameter states. Commonly used in Frama-C kernel plugins to handle command-line argument parsing, ensure safe parameter updates, and maintain consistent plugin configurations during analysis.",
      "description_length": 514,
      "index": 3600,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module defines a map data structure where keys are of a specific type and values are of type `Data.t`. It provides standard operations including comparison, equality, hashing, pretty printing, and deep copying, along with support for checking membership based on project conditions. It is used to manage and manipulate maps of values with rich structural properties in a way that integrates with Frama-C's internal type and descriptor system.",
      "description_length": 447,
      "index": 3601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line options, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with strings, state lists, and accessor functions to map categories to option behaviors. Concrete use cases include setting up default and \"all\" categories for option groups, enabling collective option handling, and defining how categories interact with command-line flags.",
      "description_length": 456,
      "index": 3602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Comp",
      "library": "frama-c.kernel",
      "description": "This module defines comparison operators (`Lt`, `Gt`, `Eq`, etc.) and their result type (`True`, `False`, `Unknown`) for abstract interpretation. It includes functions to invert and swap comparison relations, enabling precise relational reasoning in static analysis. Concrete use cases involve modeling conditionals and loop guards in program analysis.",
      "description_length": 352,
      "index": 3603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Int",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing integer parameters with configurable range constraints, supporting value updates through direct assignment, incrementing, and bound validation. It works with integer values encapsulated in a stateful parameter type, integrating with project-specific state management and typed parameter interfaces. Typical use cases include command-line configuration options requiring value sanitization, such as setting timeouts or thresholds with enforced limits, while allowing value change hooks and marshaling for persistence.",
      "description_length": 561,
      "index": 3604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.With_output",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a boolean state that controls conditional output generation, with support for dependency tracking and persistence. It works with boolean values and project state serialization, enabling use cases like command-line flags that enable/disable logging or analysis outputs based on dynamic conditions. Key features include state toggling, dependency-based output triggers, and integration with project state management for saved configurations.",
      "description_length": 481,
      "index": 3605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Rational",
      "library": "frama-c.kernel",
      "description": "This module represents rational numbers with the `Q.t` type, supporting precise arithmetic, equality, comparison, hashing, and pretty printing, ideal for static analysis tasks like value approximation and constraint solving. Its submodules Set, Map, and Hashtbl provide efficient collections keyed by rationals, enabling operations such as ordered traversal, mapping, filtering, and memoization. You can compute program invariants with sets, cache analysis results using hash tables, or build ordered maps with arbitrary values, all while preserving key stability and precise arithmetic. Child modules enhance these structures with custom data handling, comparison logic, and utilities for symbolic computation and plugin integration.",
      "description_length": 734,
      "index": 3606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear.Space",
      "library": "frama-c.kernel",
      "description": "This module provides a foundation for linear algebra computations in static analysis, offering scalar values, vectors, and matrices that support precise manipulation of linear spaces over a field. Its core functionality enables operations such as vector addition, matrix inversion, and norm computation, while ensuring dimension correctness through static typing. The matrix submodule handles transformations like multiplication and exponentiation, used to model linear filters, while the vector submodule supports point representation and comparison in finite-dimensional spaces. Examples include constructing identity matrices for linear transformations or computing maximum norms of state vectors in analysis algorithms.",
      "description_length": 723,
      "index": 3607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a list of elements (`E.t list`) with support for dynamic modification, state serialization, and project-specific persistence. It includes functionality to add elements, iterate over the list, fold values, and handle command-line interactions, while supporting hooks for state updates and category-based configuration. Typical use cases involve maintaining plugin options that require list-based data aggregation, such as collecting analysis targets or configurable parameters with multiple entries.",
      "description_length": 540,
      "index": 3608,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Make_ordered",
      "library": "frama-c.kernel",
      "description": "This module implements an ordered hook system where functions are applied in a specific sequence, supporting dependencies between hooks to enforce execution order. It works with hooks identified by unique keys and maintains a registry of ordered callback functions that take no parameters and return no value. Concrete use cases include managing analysis extensions in static analysis tools, where plugins must execute in a defined order or depend on other plugins' results.",
      "description_length": 474,
      "index": 3609,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module offers utilities for managing string-based plugin parameters in Frama-C, supporting operations like value assignment, validation against allowed lists, retrieval with contextual resolution, and lifecycle management via change hooks. It works directly with string data (`type t = string`) and string lists for defining valid value sets, enabling use cases such as command-line option parsing, plugin state synchronization, and project-specific configuration validation. The module also facilitates alias handling and serialization control for integrating plugin settings into Frama-C's analysis workflows.",
      "description_length": 616,
      "index": 3610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag.Localizable",
      "library": "frama-c.kernel",
      "description": "This module handles source code locations with rich operations for comparison, storage, and transformation, supporting sets, maps, and hash tables keyed by location-aware values. It enables precise manipulation of annotated code regions through membership checks, deep copies, and structured traversal, with set operations for filtering and aggregating metadata, hash tables for efficient keyed storage with memoization, and ordered maps for AST node tracking and project-wide queries. Use cases include static analysis tasks like tracking localized AST elements, transforming source code with positional accuracy, and generating structured output based on tagged regions. Key types include `Localizable.t` for location-aware keys, set and map variants for structured storage, and hash tables for imperative and functional data manipulation.",
      "description_length": 841,
      "index": 3611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type.Lattice_UProduct",
      "library": "frama-c.kernel",
      "description": "This module implements a product lattice combining two abstract domains (t1 and t2) with standard lattice operations such as join, meet, and inclusion, along with utilities for under-approximating unions (link), intersection checks (intersects), and project-based membership. It supports static analysis scenarios requiring simultaneous tracking of multiple properties, such as numerical ranges paired with value sets or memory states, enabling precise abstract interpretation across combined domains.",
      "description_length": 501,
      "index": 3612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.LibEntry",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls library entry behavior in Frama-C, allowing the state to be enabled, disabled, or modified directly, with support for project-specific persistence and validation. It provides operations to register callbacks on state changes, handle command-line aliases, and serialize settings, ensuring correct entry point handling in kernel extensions by coordinating with higher-level resolution logic. The child module defines a structured data type `t` with comparison, copying, and project membership operations, enabling precise manipulation of abstract data in plugins and supporting queries on entry point logic. Together, they allow developers to enforce valid entry point configurations and manage complex data representations across different project states.",
      "description_length": 819,
      "index": 3613,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a set of operations for managing a specific abstract data type, including equality, comparison, hashing, and pretty-printing functions. It works with a polymorphic type `Datatype.t` and provides deep copying, membership testing within projects, and structural representation. Concrete use cases include handling and manipulating abstract values in static analysis plugins, such as tracking program states or analyzing memory models.",
      "description_length": 452,
      "index": 3614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecCustom",
      "library": "frama-c.kernel",
      "description": "This module orchestrates the customization of generated specifications through string parameters, structured data, and category-based configuration. It centers on the core type `t` for manipulating string-based options with constraints, supporting operations like equality, comparison, and pretty-printing, while integrating with submodules for structured data handling and category management. Users can define valid function identifiers, enforce analysis settings, and control specification behaviors via command-line categories like `@default` and `@all`. It enables structured customization of analysis artifacts, with support for persistence, validation, and session consistency.",
      "description_length": 684,
      "index": 3615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line parameters for string-based data types with support for equality, comparison, and pretty-printing. It handles operations like deep copying, hashing, and project membership checks for analysis projects. Concrete use cases include defining configurable options that accept string inputs and require structured handling during static analysis.",
      "description_length": 376,
      "index": 3616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneratedSpecMode",
      "library": "frama-c.kernel",
      "description": "This module governs the behavior of the `-generated-spec-mode` option, managing string-based configuration values with validation, aliases, and state synchronization. It defines a core type `t` with comparison, hashing, and pretty-printing operations, supporting membership checks, deep copies, and serialization for analysis configuration. Use it to enforce valid specification modes, validate function names against patterns, and maintain consistent state across plugins and analysis components. Submodules provide structured utilities for type descriptors and project integration, enabling precise control over generated specifications.",
      "description_length": 639,
      "index": 3617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Kernel_function",
      "library": "frama-c.kernel",
      "description": "This module provides a project-specific, mutable hash table that maps kernel function identifiers to code correspondence data, supporting insertion, retrieval, and sorted iteration with memoization and serialization. It includes update hooks for tracking state changes and formatting utilities for display, enabling cross-project function analysis and incremental data synchronization. The child module enhances this functionality by defining comparison, hashing, and pretty-printing operations for kernel functions, facilitating accurate handling during AST differencing and project version transitions. Together, they support efficient, versioned lookups and transformations of function-level data across projects.",
      "description_length": 716,
      "index": 3618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Poly_option",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and manipulation of monomorphic instantiations of polymorphic types, centered around the `poly` type that represents polymorphic structures. It supports operations to check if a type is an instance of a polymorphic type and to retrieve the original instantiation type, facilitating type analysis and manipulation in Frama-C's kernel. A child module specializes in generating monomorphic option-like types with full support for equality, comparison, hashing, and pretty printing, enabling rich introspection and serialization of optional values. For example, it can represent optional analysis results with type-safe wrappers that preserve structural information during static analysis.",
      "description_length": 718,
      "index": 3619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_set",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage kernel function collections through command-line configuration, state persistence, and dynamic update hooks, supporting structured manipulation of `kernel_function` elements and their set representations. It includes utilities for iteration, membership checks, categorized string conversions, and state synchronization across project lifecycles. These capabilities are used in plugin development to track function sets, enforce custom marshaling, and handle context-sensitive updates with minimal overhead.",
      "description_length": 548,
      "index": 3620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage a map linking kernel functions to arbitrary values, with support for change-tracking hooks that trigger before or after updates, project-specific state management, and customizable marshaling for serialization. It works with key-value pairs where keys are kernel functions (or prototypes if configured) and values are user-defined, enabling use cases like analysis result caching, plugin configuration with deprecated aliases, or dependency tracking across codebase changes. The module also includes utilities for iteration, folding, and visibility-controlled parameter handling.",
      "description_length": 621,
      "index": 3621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Fundec_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-based command-line parameters with support for validation, change tracking, and state management. It operates on string values, enforcing allowed function names or plain text inputs through customizable constraints. Typically used to handle options requiring validated string input in analysis tools, such as specifying function targets or maintaining configurable settings with dynamic defaults and serialized state.",
      "description_length": 444,
      "index": 3622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of operations for managing kernel functions as first-class values, supporting creation, comparison, and introspection. It works with function types that conform to a specific signature, enabling dynamic handling of functions within the kernel. Concrete use cases include registering and dispatching analysis functions, and building extensible function tables for plugins.",
      "description_length": 400,
      "index": 3623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.Option",
      "library": "frama-c.kernel",
      "description": "This module extends the standard `option` type with monadic operations, providing `iter` and `map` functions that chain computations returning optional values. It works directly with `option` values, allowing sequential composition of functions that may fail or return nothing. Use this to handle sequences of operations where each step depends on the previous result, such as parsing optional fields in a data structure or conditional computations that may abort.",
      "description_length": 464,
      "index": 3624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.Default_offsetmap",
      "library": "frama-c.kernel",
      "description": "This module computes a default offset map for a given base, representing memory bindings when no explicit value is assigned. It operates on abstract memory bases and offset maps, providing a lattice-bound value or bottom. Use it to initialize or model memory states in static analysis where variables lack explicit values.",
      "description_length": 322,
      "index": 3625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Funbehavior",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling function behaviors in CIL, including equality, comparison, hashing, and pretty-printing. It works with the `funbehavior` type, representing function specifications and behaviors in C code analysis. Use cases include analyzing or transforming function contracts, managing behavioral specifications during static analysis, and supporting plugin logic that depends on precise function semantics.",
      "description_length": 436,
      "index": 3626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap.Make_LOffset",
      "library": "frama-c.kernel",
      "description": "This module organizes hierarchical memory representations through base and offset associations, enabling lattice operations like join, meet, widening, and narrowing over memory maps. It supports precise memory modeling with operations for copying, filtering, and merging memory regions, structured around base-to-offset mappings that allow iterative analysis and state transitions. Child modules enhance this functionality with narrowing strategies, ordered offset sets, hash-based memory storage, and list-backed memory entries, enabling tasks like tracking heap allocations, validating access patterns, and merging memory states during static analysis. Specific uses include modeling disjoint memory regions, caching analysis results, and verifying memory transitions in low-level code.",
      "description_length": 788,
      "index": 3627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Float",
      "library": "frama-c.kernel",
      "description": "This module provides a structured framework for handling floating-point values with precise equality, comparison, and hashing, supporting efficient data structures like sets, maps, and hash tables. It enables operations such as insertion, lookup, and iteration over float keys with custom key behavior, deep copying, and project-aware membership, tailored for static analysis and semantic modeling. Developers can perform numerical data aggregation, symbolic expression manipulation, and ordered traversal using persistent maps or specialized hash tables. The integration of custom key modules ensures accurate handling of floating-point representations in analysis tasks requiring exact ordering and equivalence.",
      "description_length": 713,
      "index": 3628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Build_ordered",
      "library": "frama-c.kernel",
      "description": "This module manages ordered execution of hook functions with dependency tracking. It allows registering functions with unique keys, extending hooks with new actions, and enforcing execution order through dependencies. Use it to sequence analysis phases or ensure correct application of interdependent transformations in program analysis.",
      "description_length": 337,
      "index": 3629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for kernel functions, providing operations to associate, retrieve, and compare entries based on a custom datatype. It supports key-based lookups, equality checks, and pretty-printing for user-friendly output, all tailored to the analysis context of Frama-C's kernel functions. Concrete use cases include managing and querying function-specific analysis data during static analysis runs.",
      "description_length": 442,
      "index": 3630,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module represents a set of strings as a single string, providing operations to manipulate comma-separated values. It supports parsing, pretty-printing, and comparing string sets, along with checking membership and performing deep copies. Concrete use cases include handling command-line options that accept multiple string values in a single argument.",
      "description_length": 356,
      "index": 3631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashconsing_tbl-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements hash-consed state management with strong equality and memory efficiency. Operates on custom datatypes via `equal`, `compare`, and `hash`, ensuring unique representation for equivalent values. Useful for maintaining canonical forms of complex analysis states in static analysis plugins.",
      "description_length": 296,
      "index": 3632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.EagerLoadSources",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls eager source loading behavior, allowing users to set, query, and track changes to the state of source loading strategies. It integrates structured value handling through its Datatype submodule, which defines a data type `t` with operations for equality, comparison, and pretty-printing, enabling precise manipulation and querying of source descriptors. Developers can use this combination to customize how source files are preloaded during analysis, with support for project-specific state tracking and serialization. Example usage includes enabling eager loading for specific projects or analysis phases, and inspecting current loading policies through structured queries.",
      "description_length": 738,
      "index": 3633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.List-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list-based string datatype with operations for equality, comparison, hashing, and pretty-printing. It works with `As_string.Datatype.t` values, providing concrete functionality for managing lists of strings as command-line parameters. Use cases include parsing and handling string lists in Frama-C plugins, such as storing multiple file paths or user-defined string identifiers.",
      "description_length": 403,
      "index": 3634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V_Or_Uninitialized",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manipulate abstract values tagged with initialization and escaping address states, supporting bit-level transformations, lattice operations, and equality checks. It works with values built atop `Cvalue.V`, incorporating flags to track uninitialized data and memory escaping properties. These capabilities are used in static analysis to model C program behavior, refine value states, and handle imprecise representations of memory during abstract interpretation.",
      "description_length": 496,
      "index": 3635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepSwitch",
      "library": "frama-c.kernel",
      "description": "This module manages the boolean state of the `-keep-switch` kernel option, providing operations to toggle its value, register callbacks for state changes, handle command-line aliases, and control serialization. It supports a `bool` type with default values, computed state tracking, and custom marshaling logic, enabling consistent handling of switch-preserving behavior across sessions or project configurations. The child module enhances this by defining a data type for representing `-keep-switch` values with support for equality, comparison, hashing, and pretty-printing, along with deep copying and project-based membership testing. Together, they allow fine-grained control over switch statement preservation during analysis, with robust mechanisms for value manipulation and project-specific tracking.",
      "description_length": 809,
      "index": 3636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-True-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a structured data type with support for equality, comparison, hashing, and pretty printing. It works with a specific datatype `t` that represents values with associated type information, descriptors, and representants. Concrete use cases include managing and manipulating typed values in a type-safe manner, such as handling command-line options with rich metadata, ensuring deep copies, and checking project membership constraints.",
      "description_length": 452,
      "index": 3637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic4_input",
      "library": "frama-c.kernel",
      "description": "This module provides functions to handle polymorphic type values with four type parameters. It supports operations to retrieve type names, describe structural representations, and generate lists of combined values. It is used for managing complex type information in Frama-C's kernel, particularly when working with four distinct type arguments in a polymorphic context.",
      "description_length": 370,
      "index": 3638,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a datatype for handling lists of strings with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership testing over project skeletons, ensuring structural integrity and uniqueness. It is used to manage string lists in Frama-C plugins, particularly for configuration, logging, or intermediate data representation.",
      "description_length": 385,
      "index": 3639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables optimized for use with `Frama_c_kernel.Emitter.t` keys, offering imperative operations such as creation, insertion, lookup, and in-place filtering, along with ordered traversal and memoization capabilities. It supports value-based lookups with defaults, bulk updates from sequences, and structured data handling through two specialized submodules: one for emitter-associated key types with comparison and introspection features, and another for managing typed emitter values with unique naming and analysis tracking. Together, they enable precise handling of annotated program properties, lazy computation, and aggregation of analysis metadata. Example uses include tracking emitter-specific data, storing analysis results per project, and emitting annotations based on computed states.",
      "description_length": 819,
      "index": 3640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_printer.PrinterExtension",
      "library": "frama-c.kernel",
      "description": "This module defines a functor-based interface for extending an existing pretty-printer, enabling customization of output generation. It operates on abstract syntax trees and formatting rules, allowing insertion of custom printing logic at specific nodes. Use it to adapt the pretty-printer for domain-specific syntax or formatting requirements without modifying its core implementation.",
      "description_length": 386,
      "index": 3641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Map",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based map operations for combining, transforming, and querying polymorphic maps with ordered keys. It supports merging maps using lattice join operations, ordered key traversal, and physically equal value updates, while enabling conversions to sequences/lists and customizable pretty-printing. These capabilities are particularly useful in static analysis for managing abstract environments or dependency graphs where ordered key processing and lattice-structured state merging are critical.",
      "description_length": 520,
      "index": 3642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Formatter",
      "library": "frama-c.kernel",
      "description": "This module handles formatting operations for user-defined datatypes, specifically working with `Stdlib.Format.formatter` values. It supports equality checks, comparison, hashing, pretty printing, and deep copying of formatter objects. Concrete use cases include custom value representation in user interfaces and ensuring correct value manipulation during analysis passes.",
      "description_length": 373,
      "index": 3643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-WithOutput",
      "library": "frama-c.kernel",
      "description": "This module enables managing plugin configuration options and output behavior through boolean parameters, supporting operations like value setting, change hooks, serialization, and command-line interaction. It works with boolean values, project-specific state, and dependency tracking mechanisms to control output triggers and option persistence. Use cases include customizing plugin behavior via command-line flags, managing state across projects, and defining output dependencies for analysis tools.",
      "description_length": 501,
      "index": 3644,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Fundec_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for function declarations (`Fundec`) with string-based representations, supporting operations such as membership testing, comparison, and pretty printing. It works with `As_string.Datatype.t`, which wraps string values to represent function declarations, and integrates with Frama-C's project system through `mem_project`. Concrete use cases include tracking and comparing sets of functions affected by analyses or transformations, and displaying them in a human-readable format during command-line interaction or logging.",
      "description_length": 566,
      "index": 3645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a polymorphic map data structure with multiple keys, supporting operations like insertion, lookup, and deletion for each key type. It works with arbitrary data types that conform to the required equality, comparison, and hashing functions, enabling efficient storage and retrieval of values indexed by multiple key types. Concrete use cases include managing analysis results indexed by both function names and control-flow nodes, or tracking variable states across different program points using distinct key types for each dimension.",
      "description_length": 557,
      "index": 3646,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Build",
      "library": "frama-c.kernel",
      "description": "This module creates and manages hooks that accept parameters of type `P.t` and execute registered functions in order of registration. It supports adding functions, applying them to parameters, checking registration status, and clearing or counting functions. Concrete use cases include dynamically extending analysis phases in static analysis tools with custom logic that reacts to program points.",
      "description_length": 397,
      "index": 3647,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set-like structure for string-based data types with support for equality, comparison, hashing, and pretty printing. It provides operations to check membership within project contexts, create deep copies, and manage representational values. Concrete use cases include tracking and manipulating string identifiers across different analysis states in Frama-C plugins.",
      "description_length": 389,
      "index": 3648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Map-As_string",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line string options with support for setting and retrieving values, defining change hooks, handling aliases, and customizing serialization. It operates on individual strings and string lists, enforcing validation rules or restriction patterns such as allowed values and function name checks. Typical applications include tracking parameter state changes, validating restricted inputs, and integrating with project-specific state management systems.",
      "description_length": 485,
      "index": 3649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S-Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for monadic composition and transformation, enabling chaining of computations that produce values within a monadic context. It works with any type `'a t` that implements a monad, allowing operations like binding with `>>-` and `let*`, and mapping with `>>-:` and `let+`. Concrete use cases include sequencing stateful or effectful computations, such as parsing, error handling, or incremental analysis steps in program verification.",
      "description_length": 468,
      "index": 3650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages the resolution of configuration directories and files within the Frama-C kernel environment. It provides operations to retrieve directory and file paths, with optional path creation, based on given names. Concrete use cases include locating plugin-specific configuration files or directories during analysis setup.",
      "description_length": 334,
      "index": 3651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filled_string_set",
      "library": "frama-c.kernel",
      "description": "This module type provides operations for managing command-line string sets with dynamic updates, including hooks for value changes, alias handling, and serialization controls. It works with `Frama_c_kernel.Datatype.String.Set.t` and string collections, supporting set-like operations such as membership checks, iteration, and folding. These features enable use cases like tracking analysis targets, configuring persistent project settings, and managing dynamic option states across Frama-C sessions.",
      "description_length": 499,
      "index": 3652,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_printer.PrinterClass",
      "library": "frama-c.kernel",
      "description": "This module defines a pretty-printer for CIL (C Intermediate Language) structures, specifically handling the formatting and output of CIL AST nodes. It provides operations to customize the printing of types, expressions, statements, and other CIL constructs. Concrete use cases include generating human-readable CIL dumps and debugging CIL transformations during analysis phases.",
      "description_length": 379,
      "index": 3653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-TP-E",
      "library": "frama-c.kernel",
      "description": "This module represents directed edges in a service graph, where each edge connects two vertices and carries a label. It provides operations to create edges, retrieve their source and destination vertices, and access their labels. Concrete use cases include modeling call relationships between functions in a program, where edges represent calls and labels capture metadata like call conditions or parameters.",
      "description_length": 408,
      "index": 3654,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.List_ref-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements stateful list references with value semantics for analysis extensions. Provides operations to create, modify, and query lists of arbitrary elements, including equality, comparison, and pretty-printing. Useful for tracking sequences of values in static analysis, such as function call histories or data flow paths.",
      "description_length": 324,
      "index": 3655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintLibc",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean configuration option that controls the printing of libc-related information during analysis, providing operations to toggle the state, observe changes via hooks, and persist the setting across sessions. It works with a boolean value to represent the option's current state and integrates with abstract data structures defined in its child module, which support equality, comparison, hashing, and pretty-printing for C library function representations. Developers can use this module to customize output in analysis tools or conditionally control libc visibility in automated workflows. Specific examples include enabling libc output for debugging or suppressing it in production scripts.",
      "description_length": 717,
      "index": 3656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Model_info",
      "library": "frama-c.kernel",
      "description": "This module manages a stateful, project-specific mapping from keys to structured data, supporting dynamic modification, lazy evaluation, and persistence using hashtables where keys associate with lists of values. It enables efficient queries, membership checks, and change tracking while handling custom rehashing through the Datatype submodule, which defines abstract data types for computing AST differences with equality, comparison, and pretty-printing functions. You can use it to track changes in project state, maintain structured data with custom serialization, or orchestrate event hooks for data updates. The type `t` in the submodule captures structural information for diff computation, particularly when standard hashtables are unsuitable due to custom rehashing.",
      "description_length": 776,
      "index": 3657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Fundec_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module enables defining and managing string-based command-line parameters with support for value constraints, validation, and dynamic hooks for state changes. It operates on string parameters augmented with validation logic, aliases, and serialization rules, allowing use cases like restricting inputs to predefined function names, enforcing parameter consistency across project sessions, or implementing custom string filtering workflows. Key patterns include parameter initialization with default/sanitized values, alias resolution, and conditional state persistence.",
      "description_length": 574,
      "index": 3658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Config_dir",
      "library": "frama-c.kernel",
      "description": "This module manages plugin-specific configuration directories and files within Frama-C. It provides operations to retrieve or create directories and files, set or query the user directory, and check if the directory has been initialized. Concrete use cases include storing plugin-specific settings, caching analysis results, or managing per-project configuration files.",
      "description_length": 369,
      "index": 3659,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Action-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type for command-line parameters with operations for equality, comparison, hashing, and pretty-printing. It supports structured data through a descriptor and representants, enabling type-safe handling of parameter values. Concrete use cases include defining and managing configurable options in static analysis tools, such as setting analysis modes or output formats via command-line arguments.",
      "description_length": 421,
      "index": 3660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrictSized",
      "library": "frama-c.kernel",
      "description": "This module implements structural equality for CIL expressions, comparing constants strictly and using structural comparison inside `sizeof` expressions instead of identifier-based checks. It provides core operations like `equal`, `compare`, and `hash`, along with deep copying, pretty printing, and container modules such as sets, maps, and hash tables that leverage structural identity for precise equivalence. The set and map modules support ordered traversal, union, intersection, and filtering based on expression structure and size, enabling tasks like tracking equivalent expressions across contexts or optimizing symbolic evaluations. The hash table module enables efficient memoization and canonical representation using structural keys, with ordered iteration and custom folding over keys or values.",
      "description_length": 809,
      "index": 3661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.Forwards",
      "library": "frama-c.kernel",
      "description": "Implements forwards dataflow analysis by propagating domain information through control flow graphs using customizable strategies. It operates on statements annotated with dataflow facts, leveraging worklists or weak topological orderings for efficient fixpoint computation. Useful for implementing analyses like constant propagation or liveness analysis over CIL code.",
      "description_length": 369,
      "index": 3662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Zero",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing integer-based command-line parameters with support for value constraints, default settings, and state-aware persistence. It works with integers (`t = int`) and their bounded ranges, integrating project-specific state management through `Frama_c_kernel.State.t` to track changes and enforce validity. Typical use cases include configuring numeric options (e.g., verbosity levels, timeout thresholds) that require validation, incremental adjustments, or serialization across tool sessions.",
      "description_length": 545,
      "index": 3663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder.Make",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive framework for defining and managing command-line parameters with rich data types, validation, and integration into Frama-C's configuration system. It supports boolean flags, integers, strings, lists, sets, maps, and custom types, each with operations for parsing, comparison, hashing, and pretty-printing, alongside features like default values, change tracking, and marshaling for persistent state. Submodules extend this foundation to manage structured data such as function mappings, file paths, and enumerated values, enabling precise configuration of analysis tools through use cases like setting thresholds, filtering functions, or organizing options into activation-controlled categories. Together, the module and its hierarchy support complex, type-safe command-line interfaces with robust input validation, dynamic updates, and structured configuration management across plugins and analysis sessions.",
      "description_length": 947,
      "index": 3664,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppCommand",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration and validation of the string-based kernel option for the C preprocessor command, ensuring safe integration with Frama-C's analysis pipeline. It defines a core data type `t` with operations for equality, comparison, hashing, and pretty-printing, enabling type-safe manipulation of `-cpp-command` values. The module supports value assignment, constraint enforcement, command-line parsing, and deep copying, while allowing checks against project predicates and function name validity. It is used to set and validate custom preprocessor commands during kernel development and state synchronization.",
      "description_length": 632,
      "index": 3665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph.Map",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure with standard operations for empty initialization, key-based lookup, and insertion. It works with associative data where keys of a specific type are mapped to arbitrary values. Concrete use cases include tracking node relationships in a control flow graph or managing symbol tables during static analysis.",
      "description_length": 349,
      "index": 3666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Orig_name",
      "library": "frama-c.kernel",
      "description": "This module manages the `-orig-name` boolean option, controlling whether original names are preserved during analysis, with operations to set, track, and serialize its state. It integrates a data type `t` that supports equality, comparison, and pretty-printing, enabling precise manipulation of structured data such as abstract syntax trees. The module allows checking data membership within projects, creating deep copies, and accessing type descriptors, facilitating transformations that maintain structural integrity. Use cases include preserving identifier semantics across analysis sessions and implementing plugins that rely on consistent name handling and data identity tracking.",
      "description_length": 686,
      "index": 3667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string-based command-line parameters with support for validation, dynamic value handling, and state management. It works with string values and structured collections of allowed values, enabling use cases like configurable tool options that require validated input (e.g., function names or restricted string sets) and reactive updates via change hooks. Key features include alias resolution, project-specific state serialization, and context-dependent value retrieval.",
      "description_length": 513,
      "index": 3668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph.S-TP-V",
      "library": "frama-c.kernel",
      "description": "This module represents vertices in a callgraph, where each vertex is labeled and supports comparison, hashing, and equality checks. It operates on vertex labels of type `TP.V.label` and vertices of type `TP.V.t`, ensuring they can be used in graph algorithms requiring ordering. Concrete use cases include tracking function nodes in static analysis, where labeled vertices represent program functions and support efficient graph traversal and service computation.",
      "description_length": 463,
      "index": 3669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoAttrs",
      "library": "frama-c.kernel",
      "description": "This module represents CIL types with structural comparison that ignores attributes, supporting equality, comparison, hashing, deep copying, and pretty-printing. It enables efficient management of type collections through\u914d\u5957\u5b50\u6a21\u5757 for sets, maps, and hash tables, all using attribute-agnostic structural identity. These submodules allow operations like union, intersection, ordered traversal, and memoization, useful for tracking type equivalence or associating metadata in analysis plugins. Example uses include comparing struct definitions without annotations or aggregating type properties across different code contexts.",
      "description_length": 620,
      "index": 3670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Map",
      "library": "frama-c.kernel",
      "description": "This module manages maps with integer set keys and arbitrary values, automatically converting large sets to intervals for efficiency. It supports ordered traversal, bulk transformations, and operations like merge, filter, and custom serialization, particularly useful in static analysis for tracking variable ranges or control flow. The key module provides set-based key handling with comparison and conversion, while the data module implements map operations including deep copy and predicate-based queries. Example uses include abstract interpretation tasks like analyzing integer range dependencies or representing program states as mappings from sets to analysis data.",
      "description_length": 672,
      "index": 3671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for representing kernel functions as strings, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with `As_string.Datatype.t` values, which encapsulate string representations of kernel functions, and includes functionality for deep copying and project membership testing. Concrete use cases include managing and manipulating string-based identifiers for kernel functions in a type-safe manner during static analysis.",
      "description_length": 499,
      "index": 3672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table management with operations for insertion, deletion, lookup, and in-place transformations on `'a Hashtbl.t` structures, using keys of type `t`. It supports advanced workflows like sorted iteration over key-value pairs, safe value retrieval with optional defaults, and function memoization, while enabling conversions between hashtables and sequences. Typical applications include efficient state management, caching computed results, and structured data processing requiring ordered traversal or custom key semantics via the `Make` functor.",
      "description_length": 582,
      "index": 3673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module performs backward dataflow analysis over control flow graphs by computing abstract states before transitions using a provided domain. It enables reasoning about program properties flowing backward through control flow, such as determining necessary preconditions for reaching a specific point. The analysis results module gives access to computed states at function entries, returns, and around statements, supporting queries and traversal in various orders. It also allows exporting results to DOT format for visualization, using a custom state pretty printer.",
      "description_length": 573,
      "index": 3674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a set of string-based command-line parameters with support for equality, comparison, hashing, and pretty-printing operations. It works with a custom abstract data type `t` representing parameter values, alongside project-specific types like `Project_skeleton.t`. It is used to define and manage command-line options that store string sets, ensuring deep copying and project-aware membership checks.",
      "description_length": 421,
      "index": 3675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a list-based data type with operations for equality, comparison, hashing, and pretty-printing. It supports list values through a structured descriptor, enabling deep copying and membership checks over project skeletons. Concrete use cases include managing collections of analysis states or transformation rules in static analysis plugins.",
      "description_length": 361,
      "index": 3676,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.With_set_and_map",
      "library": "frama-c.kernel",
      "description": "This module extends a datatype with set and map operations, enabling efficient membership testing, union, intersection, and value mapping, provided the underlying type supports equality and comparison. It includes a set submodule for immutable ordered sets with operations like `add`, `mem`, `union`, and ordered traversal, and a map submodule for persistent key-value maps with `insert`, `merge`, and transformations over structured data. These components support tasks such as tracking program elements like variables, analyzing symbolic expressions, and building type-safe symbol tables with rich metadata associations. Example uses include static analysis plugins for managing sets of functions or mapping variables to their inferred types.",
      "description_length": 744,
      "index": 3677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Input_collection",
      "library": "frama-c.kernel",
      "description": "This module defines a minimal interface for command-line option collections, specifying the option name, help description, argument name, and dependencies on other states. It works with custom data types that represent command-line parameters and their associated metadata. Concrete use cases include defining structured command-line arguments for analysis tools, ensuring consistent parsing and documentation integration.",
      "description_length": 422,
      "index": 3678,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map for kernel functions with string keys, supporting operations like lookup, insertion, and iteration. It works with abstract data types representing kernel functions and their associated string identifiers. It is used to manage and dispatch function calls within the Frama-C kernel, particularly for plugins registering and retrieving named functionalities.",
      "description_length": 384,
      "index": 3679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make_with_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module builds comparable and hashable datatypes from a parameter module `X`, providing `equal`, `compare`, and `hash` operations that enable efficient use in hash tables and other data structures. Its child module extends this with hash tables supporting ordered traversal, memoization, and sequence conversion, offering operations like `find_opt`, `memo`, and `iter_sorted` for managing structured values in analyses. Together, they support defining stable data representations\u2014such as abstract program states\u2014and efficiently manipulating them with customizable hashing, comparison, and deep copying. Use cases include caching analysis results, tracking memory, and implementing deterministic stateful traversals in static analysis plugins.",
      "description_length": 746,
      "index": 3680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Domain",
      "library": "frama-c.kernel",
      "description": "This module defines a dataflow analysis domain with operations to merge states (`join`), compute widening for loop convergence (`widen`), and apply edge transitions to states (`transfer`). It works with an abstract state type `t` and automaton structures involving vertices and edges that carry CIL-based guards and actions. It is used to model and analyze program behavior through abstract interpretation, specifically tracking reachable states across control flow transitions in an interpreted automaton.",
      "description_length": 506,
      "index": 3681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides hash tables for efficiently managing values indexed by ACSL-comparable properties, supporting insertion, deletion, lookup, and in-place modification with filtering or folding. It works with parameterized hash tables (`t`) using `Frama_c_kernel.Property.t` as keys and arbitrary values, enabling ordered traversal over keys, entries, or values\u2014useful for static analysis plugins requiring property-indexed data management or memoization. The first child module defines a key type with equality, comparison, and hashing tailored to property keys, supporting structured data types and project-aware membership checks for precise key manipulation. The second child module specializes hash tables for specific data types, offering equality, comparison, hashing, and pretty printing, with support for deep copying and project-aware tracking of data like function specifications or variable annotations across analysis phases.",
      "description_length": 940,
      "index": 3682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Ordered_by_function",
      "library": "frama-c.kernel",
      "description": "This module organizes ACSL properties using a custom ordering based on kernel function name, instruction, property kind, and identifier, enabling deterministic sorting and structured manipulation. It provides core operations for comparison, equality, hashing, and pretty printing, along with set, map, and hash table modules that support efficient insertion, traversal, and aggregation. The map module manages property-keyed associations with range queries and ordered iteration, while the hash table module enables imperative updates and project-aware value handling. These tools facilitate static analysis tasks like proof obligation tracking, invariant management, and ordered property propagation across Frama-C passes.",
      "description_length": 723,
      "index": 3683,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_set_and_map-Map",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set of map manipulation operations, including functional updates, ordered traversal, and higher-order transformations like merging, filtering, and partitioning. It works with ordered maps from polymorphic keys to arbitrary values, supporting both partial and safe access patterns (e.g., `find` vs. `find_opt`) and conversions to and from lists, sequences, and custom-formatted strings. Typical use cases include managing associative data with sorted keys, safely combining or transforming map entries, and debugging structured key-value relationships through customizable pretty-printing.",
      "description_length": 625,
      "index": 3684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Bool_ref",
      "library": "frama-c.kernel",
      "description": "This module provides a boolean reference type with project-scoped state management, supporting operations such as setting, getting, and persisting boolean values across analysis phases. It includes type descriptors, equality checks, hashing, and pretty printing, enabling integration with analysis frameworks and custom serialization. Submodules extend functionality with standard data operations and metadata handling, allowing for deep copies and presence checks on project values. Example uses include tracking analysis flags, caching boolean results, and managing state with registered update hooks.",
      "description_length": 603,
      "index": 3685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AstDiff",
      "library": "frama-c.kernel",
      "description": "This module manages the state of the `-ast-diff` command-line flag, enabling and disabling AST difference tracking with support for serialization, alias handling, and integration into Frama-C's project state system. It defines a core data type `t` with operations for comparison, hashing, and pretty-printing, optimized for AST differencing workflows during static analysis. Submodules provide utilities for deep copying, type representation, and project value membership checks, facilitating precise analysis of C code changes across analysis sessions. Use cases include tracking inter-procedural AST differences and transforming analysis results based on detected syntactic changes.",
      "description_length": 684,
      "index": 3686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a key type for maps with operations for comparison, hashing, and pretty-printing. It supports data types used in Frama-C's command-line parameter system, specifically for managing and querying key-value pairs tied to projects. Use cases include checking project membership, comparing and hashing keys, and serializing or displaying key values.",
      "description_length": 363,
      "index": 3687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling file paths within the Frama-C kernel, providing operations for equality, comparison, hashing, and pretty-printing. It supports structured representation and manipulation of file paths as values of type `t`, with capabilities for deep copying and project membership checks. Concrete use cases include managing source file references in Frama-C analyses and ensuring consistent handling of file paths across plugins.",
      "description_length": 458,
      "index": 3688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.GeneralDebug",
      "library": "frama-c.kernel",
      "description": "This module manages integer-based debugging configurations with operations to set, query, and constrain values, supporting range validation, incremental adjustments, and state change notifications. It works with stateful data structures to enforce validity, track modifications, and serialize settings, enabling dynamic debug verbosity controls and integration of kernel state with configuration interfaces. The core data type `t` provides equality, comparison, hashing, and pretty-printing, along with utilities for deep copying and project membership checks. These features support structured data introspection, internal state tracking, and readable diagnostic output during analysis.",
      "description_length": 687,
      "index": 3689,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module provides imperative hash table operations for in-place updates and functional transformations, including element insertion, removal, folding, and ordered traversal. It manipulates `'a Hashtbl.t` structures with keys of type `t` (aliased as `key`), supporting use cases like memoization, sequence conversion, and sorted iteration by keys or values. Additional utilities handle default value retrieval, structural descriptions, and type definitions for precise map manipulations.",
      "description_length": 489,
      "index": 3690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CppExtraArgs",
      "library": "frama-c.kernel",
      "description": "This module manages command-line arguments for the C preprocessor, combining direct manipulation of string lists with structured category handling and dynamic state updates. It supports operations to add, iterate, and order arguments, along with defining named categories like `@none` and `@default` to control argument grouping and interpretation. The core data types include string collections and category definitions, enabling precise configuration of preprocessor flags such as include paths and macro definitions. Use cases include customizing analysis workflows with project-specific settings and ensuring consistent handling of command-line parameters across different analysis stages.",
      "description_length": 693,
      "index": 3691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Make_with_compositional_bool",
      "library": "frama-c.kernel",
      "description": "This module builds a comprehensive map structure indexed by keys with an additional boolean flag per node, combining efficient key-based operations with compositional tracking for static analysis. It provides core data types including hash-consed keys and map values, supporting operations like insertion, deletion, ordered traversal, and set algebra through its submodules, all optimized using Patricia trees and big-endian bit ordering. The structure enables precise manipulation of hierarchical data, such as tracking value flow or managing structured state, with utilities for deep copying, comparison, and pretty-printing integrated throughout. Specific capabilities include efficient membership checks, nearest element queries, and boolean-guided transformations over immutable maps and sets.",
      "description_length": 798,
      "index": 3692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map-like structure for values of type `As_string.Datatype.t`, providing operations for equality, comparison, hashing, and pretty-printing. It supports data management tasks such as deep copying and project membership checks via `mem_project`. Concrete use cases include tracking and manipulating string-based identifiers in static analysis plugins, ensuring consistent handling across different analysis phases.",
      "description_length": 436,
      "index": 3693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array",
      "library": "frama-c.kernel",
      "description": "This module implements operations for arrays of a given type `T`, including equality, comparison, hashing, and pretty-printing. It supports working with array values in a way that ensures deep copying and proper handling of project-specific data through filtering and membership checks. Concrete use cases include managing collections of typed values in Frama-C plugins, such as storing and comparing analysis results or configuration settings.",
      "description_length": 444,
      "index": 3694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Copy",
      "library": "frama-c.kernel",
      "description": "This component manages a boolean kernel option that controls data duplication behavior in Frama-C's analysis pipeline, allowing clients to toggle, observe, and persist the state of copy semantics. It maintains a shared boolean variable enriched with metadata for alias tracking and change detection, supporting precise control over deep copying during inter-procedural analysis or memory optimization when redundant copies are unnecessary. The child module enhances this functionality by defining operations on structured data representations, including equality, comparison, deep copying, and pretty-printing, enabling rich manipulation of internal states during analysis. Together, they facilitate fine-grained duplication strategies while providing introspection and project-aware querying capabilities.",
      "description_length": 806,
      "index": 3695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Share",
      "library": "frama-c.kernel",
      "description": "This module manages access to a plugin's shared directory structure, providing operations to set and retrieve the root directory path. It includes functions to locate specific subdirectories or files within the shared directory, ensuring they exist and are of the correct type. Use cases include loading plugin-specific resources such as configuration files or auxiliary data from predefined locations.",
      "description_length": 402,
      "index": 3696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Identified_term",
      "library": "frama-c.kernel",
      "description": "This module manages identified terms in CIL with support for equality, comparison, hashing, and pretty-printing, enabling deep copies and identity checks for project-specific term handling. It provides core operations through submodules: one for immutable sets supporting union, intersection, and transformation; another for ordered maps with key-based access, merging, and range queries; and a third for hash tables enabling efficient lookups and ordered iteration. These tools facilitate static analysis tasks like term tracking, data-flow computation, and symbol table management, with concrete types such as `Identified_term.t` and `Data.t` underpinning term identity and value handling. Examples include caching term metadata, transforming CIL hierarchies, and implementing analysis passes over term-based keys with custom ordering and serialization.",
      "description_length": 855,
      "index": 3697,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Emitted_status",
      "library": "frama-c.kernel",
      "description": "This module defines operations for managing and comparing property status values, including equality, comparison, and hashing functions. It works with the `t` type representing emitted property statuses, supporting deep copies, membership checks over projects, and pretty-printing. Use cases include tracking and analyzing the status of properties during static analysis, such as determining if a property has been proven or invalidated in a given project context.",
      "description_length": 464,
      "index": 3698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_topological.Make",
      "library": "frama-c.kernel",
      "description": "This module provides `fold` and `iter` functions to traverse a graph in topological order, handling cycles by visiting each node exactly once in an unspecified order within the cycle. It operates on graphs defined by the parameter module `G`, where nodes are of type `Frama_c_kernel.State.t`. Use this module to process control flow graphs or dependency graphs where topological ordering is required, such as analyzing program states or resolving state dependencies in static analysis.",
      "description_length": 485,
      "index": 3699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Result.Operators",
      "library": "frama-c.kernel",
      "description": "This module defines infix operators for chaining and transforming `result` values in a pipeline-friendly way. It supports operations like flat mapping with `(>>-)`, mapping with `(>>-:)`, and combining multiple results with `(and*)` and `(and+)`. These functions simplify error propagation and value extraction when working with functions that return `Stdlib.result` types, particularly in scenarios involving sequential or parallel result computations.",
      "description_length": 453,
      "index": 3700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hook.Comparable",
      "library": "frama-c.kernel",
      "description": "This module defines comparison and equality operations for a hook type, enabling use in ordered collections like sets and maps. It provides `equal`, `hash`, and `compare` functions to support structural comparison and hashing of hook values. Concrete use cases include managing collections of hooks where uniqueness or ordering is required, such as tracking registered hooks or comparing their execution points.",
      "description_length": 411,
      "index": 3701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Enums",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-based kernel options with enumerated constraints, focusing on command-line interface interactions and state persistence. It supports operations on string values, lists, and state-tracking structures to enforce valid input sets, handle aliases, and customize serialization. The child module defines a core datatype `t` with equality, comparison, and pretty-printing functions, enabling precise analysis and manipulation of enumeration types in C code. Together, they support tasks like validating enum-style CLI arguments, maintaining configuration states, and analyzing enumeration data in static code contexts.",
      "description_length": 662,
      "index": 3702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue.V",
      "library": "frama-c.kernel",
      "description": "This module models abstract memory values as sets of location-offset pairs, supporting lattice operations, arithmetic, and bitwise manipulations for static analysis. It enables pointer arithmetic, value range estimation, and tracking of imprecise or unbounded states, with utilities for inclusion checks, cardinality analysis, and concrete-abstract conversions. Submodules organize key-value associations, set operations, hash tables, and integer-mapped locations, enabling structured memory state modeling, ordered transformations, and efficient lookups. Examples include merging memory states during abstract interpretation, tracking variable bindings, caching analysis results by address, and managing hierarchical memory regions.",
      "description_length": 733,
      "index": 3703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic_input",
      "library": "frama-c.kernel",
      "description": "This module handles the creation and manipulation of polymorphic type instances by defining how to derive names, structural descriptors, and representants for monomorphic instantiations. It operates on type values and structural descriptors, enabling the representation of polymorphic types through their monomorphic components. Concrete use cases include building type representations for generic data structures and managing type-specific operations in static analysis plugins.",
      "description_length": 479,
      "index": 3704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Triple",
      "library": "frama-c.kernel",
      "description": "This module defines a triple data structure composed of three elements of types `T1.t`, `T2.t`, and `T3.t`. It provides standard operations including equality, comparison, hashing, pretty printing, and deep copying, along with support for project membership checks. It is used when handling compound values that require structural consistency across all three components, such as combined analysis states or multi-part keys in maps or hashtables.",
      "description_length": 446,
      "index": 3705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map with support for multiple values per key, using `As_string.Datatype.t` as the value type. It provides standard map operations such as insertion, lookup, and iteration, with specialized handling for managing multiple values and ensuring key-based ordering and comparison. It is suitable for tracking and organizing analysis results or annotations in a plugin, where keys are string identifiers and values are structured data requiring serialization and comparison.",
      "description_length": 507,
      "index": 3706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations.Location",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling memory locations, including equality, comparison, hashing, and pretty-printing. It provides functions to check membership within projects, create deep copies, and manage type descriptors for location values. Use cases include analyzing and manipulating memory references in C code during static analysis, such as tracking variable addresses or function calls.",
      "description_length": 403,
      "index": 3707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filled_string_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage string-valued plugin parameters, including validation, filtering, and persistence of values, along with support for defining allowed value sets and associating update callbacks. It operates on string collections and individual strings, enabling use cases like command-line option parsing, project state synchronization, and enforcing domain-specific constraints on user-provided strings through predicate checks or whitelisted values.",
      "description_length": 476,
      "index": 3708,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Lemmas",
      "library": "frama-c.kernel",
      "description": "This module manages project-local state for logic lemmas using a projectified hash table that stores `global_annotation` data, supporting imperative operations like adding, replacing, and retrieving lemma bindings via custom key handling. It enables scoped updates, memoization, and custom marshaling, with direct use cases in persistent lemma storage and incremental management of verification artifacts. The child module defines a structured data type for logic entities with precise equality, comparison, and hashing, supporting deep copying and project-aware membership checks. Together, they facilitate efficient, semantically-aware manipulation of logic lemmas within static analysis plugins.",
      "description_length": 698,
      "index": 3709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Map",
      "library": "frama-c.kernel",
      "description": "This module provides polymorphic map operations supporting key-value associations with total ordering on keys, enabling creation, modification, and query functions like insertion, deletion, filtering, and merging. It works with ordered key-value structures where keys are of type 't' and values are arbitrary, offering ordered traversal (fold, iter), transformation (map, mapi), and conversion to/from lists or sequences. Specific use cases include managing hierarchical data, implementing symbol tables with ordered keys, and algorithms requiring ordered iteration or range-based queries.",
      "description_length": 589,
      "index": 3710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Verbose-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a data type with standard operations including equality, comparison, hashing, and pretty printing, tailored for handling verbose representations within a plugin framework. It supports structured data management with deep copying, membership testing over projects, and type descriptors for integration into analysis tools. Concrete use cases include tracking and manipulating analysis states or configurations that require detailed user feedback and persistence across different analysis phases.",
      "description_length": 514,
      "index": 3711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for string sets with operations for equality, comparison, hashing, and pretty-printing. It works with string sets represented via the `As_string.Datatype.t` type, supporting deep copying and membership checks over project skeletons. Concrete use cases include parsing and managing sets of strings as part of Frama-C's plugin configuration and analysis options.",
      "description_length": 404,
      "index": 3712,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Typ",
      "library": "frama-c.kernel",
      "description": "This module provides structural comparison, hashing, and manipulation of CIL types, centered around the `t` type representing C types with deep copying and project membership checks. It includes set, map, and hash table modules that leverage structural equivalence and typedef unrolling for precise type-based indexing and data management, supporting operations like union, ordered traversal, memoization, and type-aware transformations. These tools enable tasks such as tracking type-specific properties across a program, validating type constraints, and caching results from type-driven analysis. The submodules offer specialized structures for associative type-indexed data, ordered type collections, and efficient type-keyed storage with customizable equality handling.",
      "description_length": 773,
      "index": 3713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Type.Polymorphic2_input",
      "library": "frama-c.kernel",
      "description": "This module provides functions to handle polymorphic type values with two type variables. It supports operations to generate type names, describe structural representations, and retrieve type value lists for pairs of values. It works with type values and structural descriptors, primarily used when manipulating polymorphic data structures requiring two distinct type parameters. Concrete use cases include analyzing or transforming complex typed data in static analysis plugins.",
      "description_length": 479,
      "index": 3714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filled_string_set-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for string sets with string representations. It provides operations to compare, hash, and pretty-print string set values, along with deep copying and membership checks over project skeletons. It is used to manage sets of strings as command-line parameters, ensuring correct serialization, comparison, and user-friendly display.",
      "description_length": 379,
      "index": 3715,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.SharedCounter",
      "library": "frama-c.kernel",
      "description": "Implements a globally shared counter with marshalling support, allowing consistent state across projects. Provides operations to retrieve the current value, increment to a next value, and reset the counter. Useful for generating unique identifiers or tracking state changes persistently.",
      "description_length": 287,
      "index": 3716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.SaveState",
      "library": "frama-c.kernel",
      "description": "This module manages save-state file paths and coordinates with internal state data to support project-specific serialization and persistence. It provides operations to set and retrieve paths, register change hooks, and handle custom marshaling, while its child module defines trackable state values with equality, comparison, and project membership features. It enables use cases like implementing the `-save` command-line option, managing analysis state across sessions, and ensuring file path validity during serialization. Together, the module and its submodules support robust state tracking, deep copying of saved values, and structured handling of persistent analysis results.",
      "description_length": 682,
      "index": 3717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Varinfo",
      "library": "frama-c.kernel",
      "description": "This module manages variable metadata, including names and types, with support for equality, comparison, hashing, and pretty-printing. It enables tracking variable identities across AST versions, facilitating precise diff computation and correspondence analysis. Submodules extend this functionality to handle project-specific contexts and custom rehashing, ensuring accurate variable matching in complex scenarios. Example uses include comparing variable declarations across code revisions and mapping equivalent variables in different project versions.",
      "description_length": 554,
      "index": 3718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Kernel_function_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for managing string-typed configuration parameters, supporting operations like value assignment, validation against allowed sets, and dynamic value change notifications via hooks. It works with string data and symbolic function identifiers, enabling use cases such as command-line argument parsing, kernel function mapping, and persistent state management across project sessions. The interface also accommodates alias resolution and serialization control for integrating parameter settings with external systems.",
      "description_length": 544,
      "index": 3719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a string-based datatype with operations for equality, comparison, hashing, and pretty-printing. It supports command-line parameter handling by providing a unique name, type descriptor, and representants for the string type. Use cases include parsing and managing string-valued options in Frama-C plugins, such as file paths, identifiers, or configuration strings.",
      "description_length": 383,
      "index": 3720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.With_Narrow",
      "library": "frama-c.kernel",
      "description": "This module implements a narrowing operation for lattices that exclude a bottom element, returning a over-approximated intersection of two lattice elements. It operates on the type `t` and uses `Frama_c_kernel.Lattice_bounds.or_bottom` to represent results that may be undefined. Concrete use cases include refining abstract values during static analysis to converge toward a more precise result.",
      "description_length": 396,
      "index": 3721,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config.User_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve default directory paths for caching, configuration, and state files used by Frama-C. It operates on file path data types defined in the `Frama_c_kernel.Filepath` module. Concrete use cases include determining where to store persistent data such as saved analysis states or user settings.",
      "description_length": 330,
      "index": 3722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Property_status.Consolidation",
      "library": "frama-c.kernel",
      "description": "This module consolidates the status of properties based on the status of their hypotheses, determining outcomes such as `Valid`, `Invalid`, or `Unknown` with context-specific details. It operates on property sets and emitters, tracking verification progress and dependencies. Use cases include determining final verification states in static analysis, handling conditional validity, and identifying bugs dependent on other unverified or invalid properties.",
      "description_length": 456,
      "index": 3723,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes data using normalized filepaths as keys, enabling ordered storage and retrieval of arbitrary values with operations like insertion, deletion, and ordered traversal. It supports advanced manipulation through predicates, transformations, and filters, while submodules handle key comparisons, equality, and structured filepath operations. You can use it to track file metadata, merge analysis results, or manage configurations across a project, with utilities for pretty-printing and sequence-based construction enhancing usability.",
      "description_length": 551,
      "index": 3724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Debug-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for debugging purposes. It supports structured data representation and deep copying, ensuring no shared references between original and copied values. It is used to manage and manipulate complex data structures within Frama-C plugins, particularly for tracking and comparing analysis states.",
      "description_length": 410,
      "index": 3725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a builder for creating multiple map structures with a specific data type, leveraging the provided type representation and comparison functions. It supports operations such as insertion, lookup, and iteration, tailored for use with Frama-C's internal project and datatype system. Concrete use cases include managing collections of analysis results or configuration settings indexed by structured keys during static analysis.",
      "description_length": 446,
      "index": 3726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_type_NoUnroll",
      "library": "frama-c.kernel",
      "description": "This module provides logic types without unrolling, with core operations for equality, comparison, hashing, and pretty-printing, alongside data structures like sets, maps, and hash tables for efficient static analysis of CIL code. It supports project-aware manipulation of structured logic type values, enabling tasks such as tracking type constraints, merging symbol tables, and ordered traversal of CIL constructs. Child modules specialize hash tables and maps for logic types, adding deep copy, filtering, and deterministic processing, while the set module enables ordered set algebra and element transformation. Examples include managing type-value mappings in Frama-C plugins, analyzing logic expressions with project-based filtering, and maintaining deduplicated, ordered collections of CIL types for constraint solving.",
      "description_length": 826,
      "index": 3727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashtbl-Datatype",
      "library": "frama-c.kernel",
      "description": "Implements state builders for hash tables with support for equality, comparison, hashing, and pretty printing. Works with arbitrary data types that conform to the `Datatype` signature, enabling structured state management and analysis. Useful for tracking and manipulating analysis states in static code analysis plugins.",
      "description_length": 321,
      "index": 3728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure for handling multiple instances of a datatype, providing operations for key-based storage and retrieval. It works with the `Datatype.t` type and supports equality, comparison, hashing, and pretty-printing. Concrete use cases include managing collections of values with unique keys, such as tracking analysis results across different program points or configurations.",
      "description_length": 410,
      "index": 3729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type.Heterogeneous_table",
      "library": "frama-c.kernel",
      "description": "This module implements a type-safe heterogeneous hash table for storing values of dynamically typed data. It supports operations to create, add, retrieve, and iterate over entries with keys and type-indexed values. Concrete use cases include managing dynamically typed plugin data and safely associating typed metadata with program elements in static analysis.",
      "description_length": 360,
      "index": 3730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.BackwardsTransfer-StmtStartData",
      "library": "frama-c.kernel",
      "description": "This module manages a mapping from statement identifiers to data values representing the state at the start of each statement. It provides operations to add, update, query, and iterate over this mapping, with support for checking existence and clearing all entries. It is used to store and retrieve pre-analysis or intermediate data for specific statements during data flow analysis.",
      "description_length": 383,
      "index": 3731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map with operations for key-value association, including insertion, lookup, and iteration. It works with string keys and arbitrary values, supporting efficient dictionary-like structures. Concrete use cases include managing named annotations, symbol tables for analysis, or configuration settings indexed by string identifiers.",
      "description_length": 359,
      "index": 3732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_multiple_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line options for string-based multiple map parameters with string representations. It supports operations for equality checking, comparison, hashing, and pretty-printing of map values, along with deep copying and project membership testing. Concrete use cases include parsing and managing multiple string-keyed configuration entries in Frama-C plugins.",
      "description_length": 383,
      "index": 3733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_map-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a data type for mapping file paths to string-based values, supporting operations for equality, comparison, hashing, and pretty-printing. It provides functionality for managing project-specific data representations with deep copying, membership testing across projects, and structural descriptions. Concrete use cases include tracking file annotations or analysis results across different project configurations in static analysis tools.",
      "description_length": 459,
      "index": 3734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind_with_product",
      "library": "frama-c.kernel",
      "description": "This module extends a minimal monad interface with a `product` operation, enabling parallel composition of monadic values into pairs, and provides standard monadic primitives like `return`, `bind`, `map`, and `flatten`. Its submodules support operator-based sequencing with `let*` and `and*`, handle optional values with `option` operations, process lists with effectful `map` and `fold_left`, and conditionally execute actions using `only_if`. You can use it to build custom monads that combine multiple effectful computations, process collections with monadic effects, or gate actions based on boolean conditions. Specific examples include chaining I/O operations with infix operators, mapping over lists of results while accumulating state, and conditionally executing analysis steps in a static analysis tool.",
      "description_length": 813,
      "index": 3735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing plugin options and dynamic collections of file paths (`Frama_c_kernel.Filepath.t`), supporting tasks like value registration, state tracking, and list transformations (e.g., appending, iteration, folding). It facilitates use cases such as configuring analysis targets through file lists, handling project-specific path sets with serialization, and dynamically updating file collections via hooks during plugin execution. Submodules enhance functionality with categorization and string-based representations.",
      "description_length": 552,
      "index": 3736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Edge",
      "library": "frama-c.kernel",
      "description": "This module represents transitions between control points in an interpreted automaton, capturing guards and actions as part of each edge's structure. It supports core operations such as equality checks, comparison, hashing, and pretty-printing, along with utilities for deep copying and project membership verification. The associated set module enables union, intersection, and filtering over edge collections, facilitating static analysis tasks like reachable state computation and control flow analysis. Hash table and map submodules provide efficient key-value storage and retrieval using edges as keys, enabling metadata tracking and semantic analysis of transitions with guards and actions.",
      "description_length": 696,
      "index": 3737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Lattice",
      "library": "frama-c.kernel",
      "description": "Implements a semi-bounded lattice with operations for over- and under-approximations, including join, meet, narrow, link, and diff. Works with a custom data type `t` representing lattice elements, supporting comparison, hashing, and pretty-printing. Used for abstract interpretation tasks such as tracking value ranges or memory states with precise inclusion and difference checks.",
      "description_length": 381,
      "index": 3738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Lattice_with_cardinality",
      "library": "frama-c.kernel",
      "description": "This module represents maps with a lattice structure and cardinality constraints. It provides operations to check if a value has cardinality zero or one, compute an over-approximation of the difference between two values, fold over elements if enumerable, and verify if the cardinality is less than a given integer. It is used in abstract interpretation to handle finite or bounded sets of values with lattice properties.",
      "description_length": 421,
      "index": 3739,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and operations for a map structure, including equality, comparison, hashing, and pretty-printing functions. It supports keys with deep copying, membership testing with projectors, and provides representants for the key type. Concrete use cases include managing symbolic keys in static analysis, ensuring unique identification and comparison for map entries in Frama-C's internal representations.",
      "description_length": 428,
      "index": 3740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.ExpStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and comparison for CIL expressions using strict constant comparison, enabling precise equivalence checks and deterministic ordering. It provides core operations `equal`, `compare`, `hash`, and `pretty`, along with specialized data structures `Set`, `Map`, and `Hashtbl` for managing collections of expressions in static analysis. The `Map` module supports key-based access and ordered traversal using expression structure, while the `Hashtbl` enables efficient memoization and value tracking based on exact expression identity. The `Set` module implements ordered set operations and functional transformations, useful for managing expression collections during CIL AST processing and analysis state propagation.",
      "description_length": 751,
      "index": 3741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Custom-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a custom abstract data type with operations for comparison, hashing, pretty printing, and deep copying. It works with a specific abstract type `t` and provides concrete functions to manipulate and inspect values of this type, including checking membership in projects and creating deep copies. Use cases include implementing command-line options that require structured data handling, such as parsing and representing complex configuration values.",
      "description_length": 467,
      "index": 3742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module defines and manages categories for parameter collections, providing operations to create, modify, and query named categories with associated accessors and dependencies. It works with the `Category.t` type, representing categories such as `@none`, `@default`, and `@all`, and supports enabling or configuring how these categories behave in different contexts. Concrete use cases include setting up plugin-specific parameter groups, defining default behaviors, and controlling global category interpretations like `@all` in command-line options.",
      "description_length": 555,
      "index": 3743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Verbose",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a configurable integer-based verbosity level in Frama-C plugins, including setting and retrieving values, defining valid ranges, and incrementing the level. It supports command-line option parsing, state persistence across projects, and hooks to react to changes in verbosity settings. These features are particularly useful for plugins requiring fine-grained control over logging output or user-configurable thresholds.",
      "description_length": 465,
      "index": 3744,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Fundec_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and selecting sets of functions or parameters, primarily used in command-line option handling. It provides operations to define, enable, and manipulate categories such as `@none`, `@default`, and `@all`, using accessors and state dependencies. Concrete use cases include grouping related command-line options and controlling their activation behavior in static analysis tools.",
      "description_length": 422,
      "index": 3745,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintComments",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean option that controls whether comments are preserved during code printing, providing functions to set, query, and customize its behavior through update hooks, aliases, and marshaling. It defines a structured data type for handling comment-related values, supporting equality checks, comparison, hashing, and pretty-printing, along with operations for deep copying and membership testing within projects. The module enables tracking of comment metadata across analysis phases, allowing Frama-C to retain or strip comments in generated outputs based on user configuration. Specific use cases include customizing comment persistence during code transformation and ensuring consistent handling of comment state across different projects.",
      "description_length": 762,
      "index": 3746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filled_string_set-Category",
      "library": "frama-c.kernel",
      "description": "This module manages category definitions and configurations for plugin parameters, supporting operations to create, enable, and modify categories with specific accessors and dependencies. It works with category types and state lists, enabling precise control over parameter interpretations in different contexts. Concrete use cases include defining the `@all` category to handle global parameter settings and configuring default category behaviors in Frama-C plugins.",
      "description_length": 467,
      "index": 3747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type.AI_Lattice_with_cardinal_one",
      "library": "frama-c.kernel",
      "description": "This module defines a lattice structure with elements of type `t` that supports standard lattice operations such as `join`, `meet`, `narrow`, and `link`, along with inclusion checks, equality, comparison, and pretty printing. It is designed for abstract interpretation in static analysis, where each element represents an abstract value with a unique name and type descriptor, and operations account for approximation directions (over and under). Concrete use cases include modeling abstract domains for program analysis, such as value ranges or pointer aliasing, where precise yet efficient merging and intersection of abstract states are required.",
      "description_length": 649,
      "index": 3748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_info",
      "library": "frama-c.kernel",
      "description": "This module manages a stateful mapping between logic keys and project-specific data, using hashtables optimized for keys with custom rehashing. It supports insertion, retrieval, and updates with memoization, serialization, and change notifications, while enabling efficient batch queries and iterative processing through associated data lists. The logic data type provides equality, comparison, and pretty-printing for diffing and tracking logical elements across project versions. Together, they facilitate AST differencing and persistent analysis of evolving logic structures.",
      "description_length": 578,
      "index": 3749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Indexer.Make",
      "library": "frama-c.kernel",
      "description": "This module manages an ordered collection of items with efficient random access and logarithmic-time membership, insertion, and removal. It supports operations like indexing, element lookup, and range updates, all while maintaining order. It is ideal for scenarios requiring fast access and dynamic updates, such as GUI list or tree widget backends.",
      "description_length": 349,
      "index": 3750,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure parameterized by a `Data` module, providing operations for creating, modifying, and comparing maps. It supports standard map operations such as insertion, deletion, filtering, and merging, along with deep copying, equality checks, and pretty printing. Concrete use cases include managing collections of values with unique keys, such as tracking variable bindings or analysis results in a static analysis tool.",
      "description_length": 448,
      "index": 3751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InvalidPointer",
      "library": "frama-c.kernel",
      "description": "This module manages a boolean kernel option that controls invalid pointer warnings, allowing users to set and retrieve values, register update hooks, and handle state serialization. It defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, supporting precise analysis of invalid pointer states during static analysis. Users can configure when to report invalid pointer usage based on command-line parameters and project state, enabling fine-grained control over warning generation in Frama-C's kernel.",
      "description_length": 542,
      "index": 3752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages category definitions and configurations for plugin parameters, providing operations to create, modify, and query categories with specific accessors and dependencies. It works with category types and state lists to define how parameters are grouped and interpreted. Concrete use cases include setting up default and special categories like `@all` and `@none`, and enabling categories with specific interpretations for plugin functionality.",
      "description_length": 458,
      "index": 3753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a map data structure specialized for a custom datatype, providing operations such as insertion, lookup, and traversal. It works with a polymorphic key type `t` that supports comparison, equality, and pretty printing, along with a corresponding descriptor for runtime type information. Concrete use cases include managing sets of analyzed functions or variables in static analysis plugins, where keys must be compared, stored, and displayed consistently across different analysis phases.",
      "description_length": 509,
      "index": 3754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Correspondence_table",
      "library": "frama-c.kernel",
      "description": "This module provides stateful, project-aware hash-table operations for managing key-data bindings with memoization, iteration, and serialization, supporting custom key hashing and lifecycle management through hooks. It handles custom key and data types requiring proper rehashing behavior, ensuring consistency across project-specific state changes. This enables tracking mappings between AST elements across project versions for tasks like diff computation, incremental analysis, and transformation passes, where accurate key rehashing and project-specific event handling are critical.",
      "description_length": 586,
      "index": 3755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Project_skeleton.Make_setter",
      "library": "frama-c.kernel",
      "description": "This module generates uniquely named project skeletons and updates their names. It operates on strings and project skeleton instances, providing direct construction and mutation operations. Useful for creating and renaming project structures in a consistent manner.",
      "description_length": 265,
      "index": 3756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base.SetLattice",
      "library": "frama-c.kernel",
      "description": "This module implements a set lattice structure for managing addressable memory zones, supporting operations like union, intersection, and inclusion checks. It operates on ordered elements, providing efficient set manipulations and queries about valid memory regions. This structure is utilized in static analysis to model and combine abstract memory states, facilitating tasks like validity tracking and region relationship analysis.",
      "description_length": 433,
      "index": 3757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_multiple_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string-indexed map for handling multiple values per key, supporting operations like insertion, lookup, and iteration. It works with string keys and abstract data values, maintaining a structured representation for analysis states or configuration settings. Concrete use cases include tracking multiple annotations per variable or managing keyed collections of analysis results.",
      "description_length": 402,
      "index": 3758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_type_info",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific mapping between logic type keys and their associated data during AST differencing, using a state-aware hash table that correctly handles keys with custom equality and rehashing logic. It provides operations for key-based lookup, update, and iteration, along with state change tracking hooks to maintain consistency across project versions. The child module defines a logic type data structure with deep copy, equality, and hashing operations, enabling precise representation and comparison of type information across different project states. Together, they support tasks like incremental analysis and diff computation by ensuring accurate, state-aware mapping and manipulation of logic type data.",
      "description_length": 736,
      "index": 3759,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath.Normalized",
      "library": "frama-c.kernel",
      "description": "This module handles normalized file paths with operations to construct, extend, and compare paths, ensuring consistent representation. It works with the `t` type representing normalized paths and supports string conversions, pretty printing, and checks for special path properties. Concrete use cases include managing absolute or relative file paths in a standardized form, comparing paths with case sensitivity options, and generating string representations for output or logging.",
      "description_length": 481,
      "index": 3760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_set-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string set data structure with operations for membership testing, comparison, hashing, and pretty-printing. It provides concrete functionality for managing sets of strings, including equality checks, set union and intersection, and project-aware value copying. Use cases include tracking collections of unique string identifiers and analyzing string-based data across different project contexts.",
      "description_length": 420,
      "index": 3761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Set",
      "library": "frama-c.kernel",
      "description": "This module implements set-theoretic operations on intervals used for abstract interpretation, supporting union, intersection, difference, and membership checks alongside ordered element traversal. It manipulates sets of interval values (Frama_c_kernel.Ival.t) with ordered comparisons, enabling efficient queries for nearest elements, subrange extraction, and monotonic predicate filtering. Typical applications include static analysis of program variable ranges, merging disjoint intervals, and transforming interval sets through abstraction-preserving mappings or partitions.",
      "description_length": 578,
      "index": 3762,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Map-Make",
      "library": "frama-c.kernel",
      "description": "This module creates a map datatype based on a given value type, supporting standard operations like equality, comparison, hashing, and pretty printing. It works with any data type provided by the `Data` module, maintaining unique type identity and structural description. Concrete use cases include managing collections of typed values with efficient lookups and ensuring type-safe, deep copies of map contents.",
      "description_length": 411,
      "index": 3763,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S",
      "library": "frama-c.kernel",
      "description": "This module offers utilities for logging, diagnostics, and warning management, operating on categorized message levels (e.g., debug, warning, error) and configurable command-line groups. It enables plugins to emit formatted messages with severity-based filtering, manage warning categories via enable/disable controls, and define CLI option groups with aliases. Specific use cases include runtime diagnostics, error propagation, and structuring plugin-specific command-line interfaces for user customization.",
      "description_length": 508,
      "index": 3764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_map",
      "library": "frama-c.kernel",
      "description": "This module provides a stateful map implementation for associating file paths with arbitrary values, supporting operations to set, retrieve, and monitor changes to entries via callback hooks. It works with string-based keys (file paths) and parameterized value types, offering specialized handling for command-line configuration, default value tracking, and project-specific state computation flags. The module is used in plugin development for managing persistent state across analysis sessions, handling option aliases with deprecation markers, and serializing configuration data through custom marshaling logic.",
      "description_length": 614,
      "index": 3765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.S",
      "library": "frama-c.kernel",
      "description": "This module implements a state dependency graph compatible with OcamlGraph's imperative graph interface. It provides operations to add or remove directed edges between states, either from a source state to a list of targets (`add_dependencies`, `remove_dependencies`) or from a list of sources to a target (`add_codependencies`, `remove_codependencies`). It directly works with `Frama_c_kernel.State.t` values, representing dependencies between analysis states in Frama-C's value analysis.",
      "description_length": 489,
      "index": 3766,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Value_int",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for integer values, providing functions to parse, compare, and display integers in a user-friendly way. It supports operations like string conversion, equality checks, and deep copying, tailored for use in Frama-C's plugin system. Concrete use cases include defining and validating integer-based configuration options during tool initialization.",
      "description_length": 397,
      "index": 3767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.S_with_product-Bool",
      "library": "frama-c.kernel",
      "description": "This module provides a monadic operation `only_if` that conditionally executes a monadic action based on a boolean flag. It works with monadic values of type `unit t`, allowing conditional sequencing of effects without branching in the control flow. A concrete use case is selectively running analysis-side effects in static analysis plugins when certain conditions are met.",
      "description_length": 374,
      "index": 3768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Action",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean configuration options in a plugin system, including state manipulation via `set` and `toggle` functions, lifecycle hooks for value changes, and metadata management for command-line integration and serialization. It works with boolean state variables tied to typed plugin parameters, along with associated metadata like names, help messages, and aliases. These features are particularly useful for implementing plugin configuration flags that require dynamic state updates, default value handling, or cross-component visibility in analysis tools.",
      "description_length": 598,
      "index": 3769,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.TypNoUnroll",
      "library": "frama-c.kernel",
      "description": "This module represents CIL types with structural comparison based on type keys, avoiding unrolling of typedefs and complex type definitions. It supports equality, hashing, comparison, deep copying, and pretty-printing for types, enabling precise type manipulation in static analysis without expanding composite structures. The Set, Map, and Hashtbl submodules provide efficient, ordered, and persistent or imperative collections keyed on these types, used for tracking type hierarchies, caching analysis results, and managing type metadata across translation units. Examples include mapping structs to analysis data, performing type-based constraint aggregation, or memoizing type-specific computations in Frama-C plugins.",
      "description_length": 722,
      "index": 3770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Result",
      "library": "frama-c.kernel",
      "description": "This module implements a binary cache for storing and retrieving serialized data associated with abstract cache entries. It provides operations to read from and write to the cache, using a sentinel value to mark invalid or uninitialized entries. The cache is designed for efficiency in scenarios where project-agnostic, low-level data persistence is required, such as caching analysis results across runs.",
      "description_length": 405,
      "index": 3771,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating sets of parameters within a plugin's state. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, each associated with a list of states and an accessor function. Use cases include configuring plugin behavior based on different parameter sets, enabling or disabling groups of parameters dynamically, and defining fallback or global behaviors through category inheritance.",
      "description_length": 486,
      "index": 3772,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued configuration parameters with controlled validation and state tracking, enabling plugins to define allowed values, enforce function name constraints, or extract raw strings. It operates on string-based inputs and Frama-C plugin state objects, supporting features like alias resolution, serialization, and project-specific value persistence. Typical use cases include defining command-line options with restricted string domains, validating user-provided function identifiers, and maintaining configurable settings across analysis sessions.",
      "description_length": 573,
      "index": 3773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Varinfo_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages a stateful hash table that maps `Varinfo` keys to arbitrary data values, supporting efficient insertion, lookup, and iteration while integrating with Frama-C's state management for serialization and change tracking. It enables dynamic reactions to updates through hooks, making it suitable for static analysis tasks like caching results or monitoring variable properties across program transformations. Submodules extend its core functionality with standard hash table operations such as `add`, `find`, and `iter`, directly usable for associating variables with metadata during CIL processing. Example uses include tracking analysis annotations or persisting computed values across analysis passes.",
      "description_length": 718,
      "index": 3774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing command-line string parameters in Frama-C plugins, including value validation against allowed sets, dynamic state updates via hooks, and customizable serialization. It works with global string parameters and associated metadata like allowed value lists, enforcing constraints such as valid C-ified function names or plain string retrieval. Typical use cases include configuring plugin options through validated string inputs, tracking parameter changes across analysis phases, and bridging command-line arguments with internal plugin state.",
      "description_length": 585,
      "index": 3775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ival.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module implements mutable hash tables optimized for interval keys from Frama-C's abstract interpretation framework, supporting ordered traversal, sorted iteration, and bulk operations like filtering and sequence conversion. It combines direct imperative operations for key-value management with specialized submodules that provide data and key types equipped with equality, comparison, hashing, and project-aware membership checks. The first submodule enables structured storage of arbitrary data through a `Data` parameter, supporting deep copying and precise equality for static analysis tasks, while the second defines key types tied to analysis projects, ensuring isolation and correctness in multi-project environments. Example uses include tracking abstract values across program points, memoizing analysis results, and managing project-specific value sets with efficient lookup and transformation.",
      "description_length": 909,
      "index": 3776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Caml_weak_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module builds a weak hash table for a specific data type, enabling keys to be reclaimed by the garbage collector when no longer referenced externally. It offers standard operations like `add`, `find`, `remove`, and `iter`, along with support for tracking finalized project states and registering serialization hooks. The child module enhances this functionality by providing type-specific equality, comparison, and hashing required for efficient table management. Use cases include caching program element metadata and managing transient, project-specific state without memory leaks.",
      "description_length": 588,
      "index": 3777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Zero-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a zero-initialized builder for command-line parameter datatypes, providing operations to construct and manipulate values with default initialization. It works with abstract data types conforming to the `Datatype.t` interface, supporting equality, comparison, hashing, and pretty-printing. Concrete use cases include creating fresh instances of parameter types with initial values, enabling safe and consistent handling of uninitialized or default states in command-line option processing.",
      "description_length": 508,
      "index": 3778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.WTOIndex",
      "library": "frama-c.kernel",
      "description": "This module organizes vertices of a control flow graph into a weak topological order, enabling efficient comparison of graph components across different states. It tracks indices for vertices and components, allowing precise detection of regions exited or entered during transitions, such as when analyzing program state changes in abstract interpretation. The module supports operations to determine loop heads, identify back edges, and compare indices to extract dynamic changes in the graph structure. For example, it can compute the list of components left when moving from one vertex to another, guiding fixpoint iteration in static analysis.",
      "description_length": 647,
      "index": 3779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2.BackwardsTransfer",
      "library": "frama-c.kernel",
      "description": "Implements backward dataflow analysis by defining operations to propagate and combine data across control-flow graph edges. It processes CIL statements and instructions to compute pre-state data from post-state information, using combination functions for merging successor states and determining worklist updates. Designed for static analysis tools that infer properties like value ranges or dependencies by traversing code in reverse, such as detecting uninitialized variables or computing liveness information.",
      "description_length": 513,
      "index": 3780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filled_string_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module supports configuration of command-line options with string values, offering operations to constrain acceptable inputs, bind values to functions, and manage state changes through hooks and serialization. It operates on string parameters that can be restricted to predefined sets or dynamically validated, enabling use cases like enforcing enumerated options (e.g., \"strict/permissive modes\") or resolving parameter values to executable functions in Frama-C plugins.",
      "description_length": 476,
      "index": 3781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-False",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing boolean command-line options, including setting and toggling binary states, registering hooks for value changes, and handling serialization for persistence. It operates on a boolean type `t` and a global state managed through `Frama_c_kernel.Typed_parameter.t`, supporting dynamic updates and project-wide configuration. Use cases include enabling/disabling analysis features via flags, tracking state transitions, and ensuring consistent serialization across sessions.",
      "description_length": 514,
      "index": 3782,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages file paths for a plugin's state directory, providing functions to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing plugins to store and access persistent data. Concrete use cases include saving intermediate analysis results or configuration files in a plugin-specific directory.",
      "description_length": 382,
      "index": 3783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Kernel_function_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module provides a map structure for associating kernel functions with values, supporting operations to set, retrieve, and modify entries while tracking state changes. It works with `Frama_c_kernel.Cil_types.kernel_function` keys and `V.t` values in a list-based map, offering serialization, equality checks, and category-based organization through submodules. It is used in Frama-C plugins to manage function-centric data, handle option persistence, and enable iterative analysis across codebases by leveraging customizable marshaling and categorization features.",
      "description_length": 568,
      "index": 3784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_list-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing string and string list parameters in Frama-C plugins, including value validation, alias handling, and lifecycle hooks for tracking changes. It supports command-line option parsing, plugin configuration, and persistent state management through serialization mechanisms. Key use cases involve defining restricted parameter domains, converting between string representations and functions, and synchronizing project-specific settings.",
      "description_length": 476,
      "index": 3785,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.S-G",
      "library": "frama-c.kernel",
      "description": "This module offers graph traversal and transformation capabilities, including vertex and edge iteration, folding over nodes, mapping operations, and querying vertex/edge existence, degree calculations, and neighbor relationships. It operates on directed and undirected graph structures composed of vertices and edges, with specialized functions for handling or ignoring edge labels during traversal. These operations are particularly useful in static analysis for modeling and analyzing state dependencies, control flow, or data flow relationships in programs.",
      "description_length": 560,
      "index": 3786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env.Logic_builtin_used",
      "library": "frama-c.kernel",
      "description": "This module tracks logic functions and predicates used within a project. It provides operations to add, check, and iterate over logic entities associated with a given string key. It is used to manage and query logic definitions during static analysis tasks such as value analysis or proof.",
      "description_length": 289,
      "index": 3787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_map-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations for defining and managing string-based command-line parameters with customizable validation, dynamic value resolution, and extensible state management. It works with string values (`As_string.t`) and associated metadata like allowed value sets, supporting use cases such as option parsing, runtime configuration updates via hooks, and serialization of parameter states. Specific applications include enforcing valid function name arguments, handling aliased options, and integrating with state-saving mechanisms through custom marshaling.",
      "description_length": 570,
      "index": 3788,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Value_datatype_with_collections-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash table key type with operations for equality, comparison, hashing, and pretty printing. It supports concrete data types that can be stored as keys in a hash table, including deep copying and project membership checks. Use cases include managing unique identifiers or structured keys in a hash table with custom equality and comparison logic.",
      "description_length": 367,
      "index": 3789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast.UntypedFiles",
      "library": "frama-c.kernel",
      "description": "This module manages a list of untyped CIL AST files parsed during analysis. It provides direct access to the list via `get` and `set` operations, where `set` is intended for internal use only. It is used to retrieve and manipulate raw AST structures before type checking in Frama-C's analysis pipeline.",
      "description_length": 302,
      "index": 3790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option.Operators",
      "library": "frama-c.kernel",
      "description": "This module provides monadic operators for working with `option` values, including bind, map, and product operations. It supports chaining computations that may fail, using infix operators like `>>-`, `let*`, and `and*`. Concrete use cases include safely composing functions that return optional results, such as parsing or lookup operations, without explicit pattern matching.",
      "description_length": 377,
      "index": 3791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Input_with_arg",
      "library": "frama-c.kernel",
      "description": "This module defines the interface for command-line parameters that require an associated argument. It includes operations to specify the option name, provide help documentation, and assign a standard name for the argument. It is used to structure how command-line arguments are parsed and displayed in help messages.",
      "description_length": 316,
      "index": 3792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_map-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a string map data structure with operations for binding, lookup, and iteration, specifically tailored for use with the `Frama_c_kernel`'s `Project_skeleton` and `Datatype` types. It supports concrete operations like `find`, `add`, and `iter`, and is used to manage named associations between strings and project-specific data values. Typical use cases include storing and retrieving analysis results or configuration settings indexed by string keys during static analysis phases.",
      "description_length": 502,
      "index": 3793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival.Map",
      "library": "frama-c.kernel",
      "description": "This module organizes key-value associations where keys are interval values (`Ival.t`), enabling ordered map operations such as insertion, deletion, merging, and traversal. It supports functional transformations and ordered processing, with utilities for filtering, partitioning, and comparing maps, as well as sequence-based construction and reverse iteration. The key module provides necessary operations for key comparison, hashing, and pretty-printing, while the value module enables typed map entries with support for deep copying and project-specific membership checks. Use cases include tracking program states across intervals, managing analysis results, and performing precise interval-based lookups in static analysis workflows.",
      "description_length": 738,
      "index": 3794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_multiple_map",
      "library": "frama-c.kernel",
      "description": "This module manages hierarchical configuration options with multi-value key bindings, supporting operations to set, observe, and transform state through customizable marshaling, update hooks, and alias resolution. It operates on a map structure associating keys (from module `K`) to lists of values (`V.t`), with additional capabilities for category-based organization, equality checks, and string serialization. Typical use cases include plugin configuration management with fallback defaults, tracking option changes via registered callbacks, and handling complex state relationships through aliased key-value associations.",
      "description_length": 625,
      "index": 3795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Debug",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage an integer-based debug parameter, enabling dynamic configuration through CLI interfaces, value constraints, and state tracking. It works with integer values and internal state structures to support features like range validation, change monitoring via hooks, and project-specific persistence. Useful for plugin developers needing fine-grained control over debugging levels, command-line integration, or cross-project state consistency in analysis tools.",
      "description_length": 495,
      "index": 3796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Hashtbl-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a hash table where keys are managed with a specified data type, providing operations for equality checks, comparison, hashing, and pretty-printing. It supports deep copying and includes functionality to check membership based on project conditions. Use cases include managing collections of values with unique keys, such as tracking variable states or analysis results in static code analysis.",
      "description_length": 416,
      "index": 3797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.DataflowAnalysis",
      "library": "frama-c.kernel",
      "description": "Performs fixed-point computation for dataflow analysis over control flow graphs. It processes states and transitions of interpreted automata, using a worklist algorithm to propagate dataflow information until stabilization. Useful for analyzing reachability and state transformations in C functions without direct manipulation of CIL statements.",
      "description_length": 345,
      "index": 3798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Cache_dir",
      "library": "frama-c.kernel",
      "description": "This module manages a plugin-specific cache directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached resources. Use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 379,
      "index": 3799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Map_Lattice-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines the key type and associated operations for a map with lattice structure support. It provides standard key manipulations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to manage keys in a lattice-equipped map, ensuring proper value representation and structural integrity during map operations.",
      "description_length": 394,
      "index": 3800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for command-line parameters, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with the `Category.t` type, representing parameter categories, and interacts with `Frama_c_kernel.State.t` lists for state dependencies. Concrete use cases include setting up the `@default` and `@all` categories, enabling all parameters with a specific interpretation, or mapping `@all` to an existing category.",
      "description_length": 497,
      "index": 3801,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Make",
      "library": "frama-c.kernel",
      "description": "This module creates a datatype with operations for equality, comparison, hashing, and pretty-printing, derived from a given module `X`. It works with values of type `X.t`, providing structural equality, ordering, and a human-readable string representation. It is used to define first-class datatypes with introspection capabilities, such as for representing abstract values or analysis domains in static analysis plugins.",
      "description_length": 421,
      "index": 3802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig.S-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module implements a map structure for associating bases with memory maps, where each value is of type `Data.t`. It provides standard operations including comparison, hashing, pretty printing, and deep copying, along with project-aware membership checks. It is used to manage and manipulate memory maps keyed by base addresses in a type-safe and structured way.",
      "description_length": 365,
      "index": 3803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.S_no_parameter-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a parameterless abstract data type with a unique name, equality, comparison, and hashing operations. It provides a descriptor for structural inspection, a pretty-printing function for user-friendly output, and a deep copy function to ensure no shared references. Concrete use cases include representing immutable configuration values or unique identifiers in analysis passes that require consistent, value-based semantics.",
      "description_length": 442,
      "index": 3804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.CodeOutput",
      "library": "frama-c.kernel",
      "description": "This module manages the configuration of code output filepaths through a kernel option, supporting operations to set and retrieve values, register change hooks, handle aliases, and customize serialization. It provides data structures for representing code output descriptors with support for equality, comparison, hashing, pretty printing, and deep copying, along with utilities for path validation, project membership inspection, and formatted file output. Submodules enhance this functionality by enabling structured manipulation of output descriptors during analysis and transformation tasks. Example uses include directing output to specific filepaths via `-ocode`, tracking output state across sessions, and generating analysis reports with validated file paths.",
      "description_length": 767,
      "index": 3805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows.FUNCTION_ENV",
      "library": "frama-c.kernel",
      "description": "This module provides functions to convert between ordered and unordered statement representations, determine the connected component of a statement, retrieve the total number of statements, and access the associated kernel function. It operates on data structures from `Cil_types` and `Ordered_stmt`, specifically working with statements and kernel functions. Concrete use cases include tracking statement ordering during data flow analysis and identifying control flow relationships within a function.",
      "description_length": 502,
      "index": 3806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project.Undo",
      "library": "frama-c.kernel",
      "description": "This module provides operations to manage project state snapshots, including setting breakpoints, restoring to the last breakpoint, and clearing breakpoints. It works with the internal state of projects, which encapsulate AST-dependent computations. Use cases include debugging analysis steps by rolling back to a prior state or managing state transitions during complex transformations.",
      "description_length": 387,
      "index": 3807,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_MapSet_Lattice",
      "library": "frama-c.kernel",
      "description": "This module builds a lattice structure that combines maps and sets, enabling precise and abstract representations of key-value data with operations like `join`, `meet`, inclusion checks, and cardinality analysis. It supports polymorphic maps with ordered keys and values forming a lattice, allowing transformations such as `add`, `merge`, and `union`, alongside imperative hash tables for efficient in-place modifications and lattice-based value combination. Functional set operations enable ordered traversal, filtering, and structural queries on lattice-ordered elements, useful for modeling program states with variable bindings and tracking control-flow dependencies. Specific capabilities include abstract memory tracking, symbolic key management, and bounded cardinality analysis for static analysis tasks like interval tracking and dataflow computation.",
      "description_length": 860,
      "index": 3808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.KeepUnusedFunctions",
      "library": "frama-c.kernel",
      "description": "This module controls the `-keep-unused-functions` kernel option, managing filters for function names as string lists and individual strings. It ensures valid C identifiers, supports marshaling, aliasing, and synchronization with project state, and provides operations to set, retrieve, and validate these filters. The child module enhances this by defining a data type to represent the option's state, enabling equality checks, comparison, hashing, and pretty-printing, along with deep copying and membership checks over project skeletons. Together, they allow kernel developers to selectively preserve functions from removal during static analysis, ensuring correctness in dead code elimination and inter-procedural analysis.",
      "description_length": 726,
      "index": 3809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Hashcons-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a hash-consed hashtbl key type with standard operations including equality, comparison, hashing, and pretty printing. It supports working with `Hashtbl.Key.t` values, providing deep copies, membership checks over projects, and a structured descriptor for type representation. Concrete use cases include managing interned keys in stateful analyses and ensuring canonical representations for efficient comparison and storage.",
      "description_length": 443,
      "index": 3810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.String_set-As_string",
      "library": "frama-c.kernel",
      "description": "This component offers functionality for managing string-based command-line parameters with support for value validation, alias resolution, and stateful tracking across projects. It operates on string collections and individual string values, enabling use cases like configurable option parsing, dynamic value coercion to function identifiers, and maintaining consistent parameter states during serialization. Key features include hook registration for value changes, restricted value sets, and context-aware retrieval mechanisms.",
      "description_length": 529,
      "index": 3811,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_map",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing a stateful string-to-value mapping with support for dynamic value updates, project state synchronization, and command-line interface integration. It works with string-keyed collections storing values of a polymorphic type `V.t`, offering functionality for iteration, folding, custom serialization, and handling aliased or deprecated keys with visibility controls. Typical use cases include configuring plugin parameters through command-line options, tracking runtime state changes, and maintaining structured data with version-aware deprecation handling.",
      "description_length": 599,
      "index": 3812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Varinfo",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL variable information, including equality, comparison, hashing, and pretty-printing, along with utilities for deep copying, project membership checks, and representative value access. It supports manipulation of variable sets through efficient, ordered, and immutable set structures, enabling union, intersection, and traversal operations for tracking variable dependencies and scoping. Key-value associations and hash tables built on `Varinfo` keys allow mapping variables to arbitrary data, facilitating analysis state management, metadata tracking, and memoization across program points. Example uses include static analysis passes that track variable properties, compare program states, or perform dataflow analysis with precise variable set manipulations and ordered processing.",
      "description_length": 840,
      "index": 3813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field.S-Map",
      "library": "frama-c.kernel",
      "description": "This module provides ordered map operations with keys derived from a mathematical field structure and arbitrary value types, supporting functional updates, ordered traversal, and sequence-based transformations. It includes specialized functions for key-based queries, extremal binding selection, and bidirectional iteration, with utilities for merging, filtering, and pretty-printing maps. These capabilities are particularly useful in numerical analysis and formal verification contexts requiring precise handling of ordered data and algebraic properties.",
      "description_length": 556,
      "index": 3814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function.Make_Table",
      "library": "frama-c.kernel",
      "description": "This module implements a memoizing hash table that maps kernel functions to arbitrary data values, enabling efficient storage and retrieval of function-specific information within a project context. It provides operations for insertion, lookup, iteration, and change tracking, while supporting state persistence and custom serialization across analyses. The child module enhances this functionality by offering hash-based collections with equality, comparison, and pretty printing capabilities, allowing precise manipulation of per-function data and project-scoped values. Together, they enable use cases such as caching analysis results per function, synchronizing data changes with external tools, and maintaining type-safe, project-aware metadata throughout static analysis workflows.",
      "description_length": 787,
      "index": 3815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Keep_unused_types",
      "library": "frama-c.kernel",
      "description": "This module controls whether unused types are retained during analysis through a boolean kernel option, with support for serialization, state management, and project-level configuration. It defines a data type `t` and operations for equality, comparison, hashing, pretty-printing, and deep copying, enabling precise handling of structured data. These capabilities allow users to preserve type definitions for debugging or analysis completeness, and to manipulate complex data structures independently, such as in custom Frama-C plugins or dataflow analyses.",
      "description_length": 557,
      "index": 3816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp.Make_Lattice_Set",
      "library": "frama-c.kernel",
      "description": "This module implements a lattice structure for set-based abstract domains, supporting operations like union (join), intersection (meet), element injection (inject_singleton), and membership checks (mem). It manages sets of elements from type `O.elt` with a top element representing all possible values, alongside standard set traversals (fold, iter) and lattice transformations (apply1, apply2). Designed for static analysis contexts, it enables merging or narrowing value ranges, such as tracking possible memory locations or symbolic values in program analysis.",
      "description_length": 563,
      "index": 3817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Filepath",
      "library": "frama-c.kernel",
      "description": "This module provides command-line option parsing and state management for file paths, supporting operations like value registration, change hooks, alias resolution, and serialization customization. It works with typed file path values (`Filepath.t`) and configuration parameters to handle path validation, emptiness checks, and integration with Frama-C's kernel framework. Use cases include processing user-provided file paths during analysis setup and ensuring consistent path handling across plugins.",
      "description_length": 502,
      "index": 3818,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.OffsetStructEqStrict",
      "library": "frama-c.kernel",
      "description": "This module defines structural equality and strict constant comparison for CIL offset types, supporting operations like equality checking, comparison, hashing, and pretty printing for `offset` values that represent field offsets in C structures. It enables precise analysis of memory layouts through direct manipulation of offsets and underpins submodules that implement ordered maps, hash tables, and sets with strict structural consistency. These submodules support operations such as insertion, merging, ordered traversal, filtering, bulk updates, set algebra, and nearest-element queries, all using keys or elements based on the strict equality of CIL offsets. Use cases include tracking dataflow values, analyzing memory layouts, validating data flow constraints, and memoizing structural comparisons during static analysis.",
      "description_length": 829,
      "index": 3819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Session",
      "library": "frama-c.kernel",
      "description": "This module manages file paths within a plugin's session directory, providing functions to retrieve or create directories and files relative to that location. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing plugins to store and access session-specific data. Concrete use cases include setting up temporary storage for analysis results or retrieving plugin-specific configuration files during static code analysis.",
      "description_length": 446,
      "index": 3820,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap.Make_bitwise",
      "library": "frama-c.kernel",
      "description": "This module supports bitwise operations on interval mappings, merging adjacent intervals with identical values and enabling efficient queries and lattice joins. It manipulates intervals (type `itv`) associated with values (type `v`), suitable for static analysis tasks like memory state abstraction where contiguous regions with uniform properties must be compactly represented and combined. Operations include cache-aware traversals and fusion of overlapping intervals, optimizing scenarios requiring precise tracking of memory ranges or register values under bitwise transformations.",
      "description_length": 585,
      "index": 3821,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S-Map-Make",
      "library": "frama-c.kernel",
      "description": "This module defines a map data structure parameterized by a `Data` module, supporting operations like equality, comparison, hashing, and pretty-printing. It works with maps where keys and values are of types defined in the `Data` module, ensuring deep copies and providing descriptors for type representation. Concrete use cases include managing typed mappings in static analysis contexts, such as tracking variable associations across different program states.",
      "description_length": 461,
      "index": 3822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing.Lenv",
      "library": "frama-c.kernel",
      "description": "This module manages a local logic environment by mapping identifiers to logic variables, type variables, logic information, and logic labels. It supports operations to add and retrieve these entities, maintaining scope-specific bindings. It is used during logic typing to track declared symbols and their associated logical properties within a given context.",
      "description_length": 358,
      "index": 3823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-State_dir",
      "library": "frama-c.kernel",
      "description": "This module manages file paths for a plugin's state directory, providing functions to retrieve or create directories and files within it. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, allowing plugins to store and access persistent data. Concrete use cases include saving intermediate analysis results or configuration files in a plugin-specific directory during static analysis.",
      "description_length": 405,
      "index": 3824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-False-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a parameter builder for a false datatype, primarily used to handle command-line options related to a specific abstract data type. It provides operations for equality checking, comparison, hashing, pretty-printing, and deep copying of values of type `Datatype.t`, along with utilities for project membership testing. Concrete use cases include defining and manipulating abstract data types within Frama-C plugins, particularly for tracking and serializing analysis states or configuration settings.",
      "description_length": 517,
      "index": 3825,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.List",
      "library": "frama-c.kernel",
      "description": "This module enables managing list-valued command-line parameters through operations like element addition, iteration, folding, and state-aware manipulations (e.g., pre/appending lists). It works with list data structures (`t`) and supports dynamic behavior via change hooks, alias resolution, and serialization, while integrating with project-specific state tracking. Typical use cases include handling options that accumulate values (e.g., include paths) or require synchronized updates with side effects, such as configuration toggles with validation callbacks.",
      "description_length": 563,
      "index": 3826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder.Kernel_function_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module manages a stateful hash table for kernel functions, enabling insertion, lookup, and iteration over function-associated metadata with support for project-scoped persistence and change tracking via hooks. It directly provides operations to manipulate `Datatype.t` values representing kernel functions and integrates pretty printing, equality, and comparison functionality from its child module. Use it to memoize function-specific analyses, track property changes during static analysis, or monitor data flow tied to Frama-C's project lifecycle. The combined interface supports both direct hash table manipulation and structured comparison or serialization of stored function data.",
      "description_length": 691,
      "index": 3827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Fieldinfo",
      "library": "frama-c.kernel",
      "description": "This module manages a project-specific hash table that maps `fieldinfo` keys to structured correspondence data, supporting custom marshaling, state persistence, and change tracking. It enables operations such as adding, updating, and querying bindings, with facilities for iteration, pretty-printing, and triggering modification hooks. The associated submodule defines a data type for structured project diff computation, offering equality, comparison, and deep copy operations, making it suitable for tracking field-level changes across project versions. Together, they enable precise analysis and transformation of abstract syntax trees in contexts like program diffing and inter-procedural analysis.",
      "description_length": 702,
      "index": 3828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Array_with_collections",
      "library": "frama-c.kernel",
      "description": "This module provides a parameterized array type with standard operations like equality, comparison, hashing, and deep copying, designed for use in static analysis plugins requiring structured collections. Its submodules enable rich map and set manipulations, supporting key-value associations with ordered traversal, integer-indexed data management, and set operations with union, intersection, and filtering. Hash table extensions allow in-place filtering, memoization, and structured value handling, with support for deep copies and project-aware queries. Example uses include tracking variable states across analysis phases, managing symbol tables with ordered iteration, and handling structured configurations with customizable equality.",
      "description_length": 741,
      "index": 3829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths, providing operations to compare, hash, and pretty-print them. It supports file path resolution and project-specific filtering through deep copy and membership checks. Concrete use cases include managing source file dependencies and analyzing project-specific configurations in static analysis plugins.",
      "description_length": 366,
      "index": 3830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_sig.S",
      "library": "frama-c.kernel",
      "description": "This module enables precise manipulation of floating-point numbers through operations like rounding, comparison, classification (e.g., NaN, infinity), and arithmetic with explicit rounding modes. It operates on an abstract type `t` that represents floating-point values, supporting conversions to OCaml floats and advanced mathematical functions such as logarithms and trigonometric operations. These features are tailored for static analysis and formal verification where accurate handling of floating-point precision and behavior is critical.",
      "description_length": 544,
      "index": 3831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.Register",
      "library": "frama-c.kernel",
      "description": "This module structures plugin configuration and diagnostic control in Frama-C through typed parameter registration, command-line integration, and categorized logging. It defines core data types such as warning categories, log levels, and structured values like integers, strings, enums, and file paths, supporting operations for validation, persistence, and dynamic updates. Child modules extend this foundation by enabling complex configurations\u2014such as string lists, function sets, key-value maps, and custom data types\u2014with features like change hooks, project-aware state, and marshaling. Examples include defining analysis options with constraints, tracking function-specific metadata, organizing file path configurations, and managing session-persistent plugin state with scoped directories and caches.",
      "description_length": 807,
      "index": 3832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Logic_var",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for logic variables in CIL, including equality, comparison, hashing, and pretty-printing, with support for deep copying and project membership checks. Its set submodule enables efficient set operations like union and intersection, along with ordered traversal and transformations, ideal for tracking and analyzing logic variables during static analysis. The hash table submodule offers imperative and functional mappings from logic variables to arbitrary values, supporting memoization, safe retrieval, and bulk updates, which are essential for managing variable bindings and caching analysis results. The map submodule extends this with ordered, transformable associative structures, enabling structured property tracking and binding management across analysis phases.",
      "description_length": 806,
      "index": 3833,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.AutoLoadPlugins",
      "library": "frama-c.kernel",
      "description": "This module controls the behavior of the `-autoload-plugins` option, managing its state transitions, value change hooks, and synchronization with project data. It works with internal flags and structured plugin representations to support operations like initializing plugin dependencies or dynamically adjusting autoloading during analysis. The module enables marshaling state changes and resolving aliases, ensuring consistent handling of the option across different contexts. Its child module enhances plugin data management through type-safe structures that support comparison, hashing, pretty-printing, and membership checks based on project properties.",
      "description_length": 657,
      "index": 3834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Make_multiple_map-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for organizing and manipulating parameter collections. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, and control their behavior in the context of state dependencies and command-line interpretations. Use cases include configuring plugin parameters with named categories, enabling global behavior through `@all`, and setting default parameter interpretations.",
      "description_length": 449,
      "index": 3835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad.Make_based_on_bind",
      "library": "frama-c.kernel",
      "description": "This module builds on a minimal monad defined via `bind` to offer standard operations like `return`, `map`, and `flatten`, supporting types such as `Bool`, `Option`, `List`, and custom monads through the `M` parameter. It enables structured composition of effectful computations, such as handling optional values, branching logic, or collections, with direct APIs and submodules enhancing usability. The submodules provide targeted utilities: sequencing monadic actions over lists, conditional execution via `only_if`, infix operators for chaining and mapping, and specialized handling of `option` values with effectful transformations. Together, these components support concise, composable code for managing effects in contexts like error handling, state, or optional data.",
      "description_length": 775,
      "index": 3836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Lexpr",
      "library": "frama-c.kernel",
      "description": "This module implements operations for logic expressions in CIL, including equality, comparison, hashing, and deep copying. It works with logic expressions represented as `Frama_c_kernel.Logic_ptree.lexpr`. It supports analyzing and manipulating logic expressions in static analysis plugins, such as checking project membership or generating representative values.",
      "description_length": 363,
      "index": 3837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph-BackwardAnalysis",
      "library": "frama-c.kernel",
      "description": "Implements backward dataflow analysis on control flow graphs, computing dataflow values for nodes using a widening threshold object (WTO) to ensure convergence. It operates on graphs where nodes represent control points and edges encode CIL-based guards and actions. This module is used to infer preconditions or propagate constraints from program exits to entry points, such as in nullness analysis or interval inference.",
      "description_length": 422,
      "index": 3838,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset.S-Map-Key",
      "library": "frama-c.kernel",
      "description": "This module defines a data type `t` representing keys for a map, equipped with standard operations including comparison, equality, hashing, and pretty-printing. It provides utilities to inspect and manipulate key values, such as checking membership in projects and performing deep copies. Use cases include managing symbolic keys in map structures and supporting serialization or comparison logic in analysis plugins.",
      "description_length": 417,
      "index": 3839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set.Hashtbl",
      "library": "frama-c.kernel",
      "description": "This module combines hash table functionality with specialized handling for integer sets as keys, enabling efficient storage and retrieval of values associated with small sets of integers. It defines a key type for integer sets with equality, comparison, hashing, and pretty printing operations, and implements hash tables indexed by these keys for direct lookups, insertions, and iterations. For example, it can map integer ranges to abstract states in static analysis plugins or track variable bindings over dynamic sets. The integration of key operations and hash table logic supports seamless manipulation of set-based mappings within constrained cardinality limits.",
      "description_length": 670,
      "index": 3840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval.Map",
      "library": "frama-c.kernel",
      "description": "This module manages associations between integer intervals with congruence constraints and arbitrary values, enabling key-based transformations, bounded searches, and sequence-driven construction while preserving interval ordering. It uses a key type representing intervals with min, max, rem, and modu fields\u2014supporting equality, comparison, hashing, and pretty printing\u2014ideal for tracking symbolic integer ranges and arithmetic properties in static analysis. The map implementation allows storing and querying values under these structured keys, facilitating tasks like program verification where modular constraints and bounded domains are critical. Specific operations include inserting, removing, and querying intervals, transforming values based on key properties, and traversing the map in key order.",
      "description_length": 807,
      "index": 3841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Float",
      "library": "frama-c.kernel",
      "description": "This module enables managing command-line parameters as floating-point values with optional decimal precision, supporting operations to set and retrieve values, enforce configurable numeric ranges, and trigger callbacks on modifications. It works with float data types augmented by metadata for state tracking, default values, and command-line aliases, while integrating serialization for project-specific persistence. Typical use cases include configuring numerical thresholds in static analysis tools or enforcing bounded input constraints for compiler options.",
      "description_length": 563,
      "index": 3842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Fundec_set",
      "library": "frama-c.kernel",
      "description": "This module provides set-like manipulation of C function definitions (fundec elements), supporting operations such as addition, membership checks, iteration, folding, and predicate-based queries. It utilizes `Fundec.Set.t` data structures to store and manage these functions, with capabilities for state persistence, command-line option handling, and change notification via hooks. These features are particularly useful for plugins that need to track subsets of functions during analysis, dynamically update their scope based on user input, or maintain consistent state across different phases of execution.",
      "description_length": 608,
      "index": 3843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S_no_log-Share",
      "library": "frama-c.kernel",
      "description": "This module manages access to a plugin's shared directory structure, providing operations to set and retrieve the directory path, check its existence, and locate specific files or subdirectories within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports direct lookups by name for files and directories. Concrete use cases include loading plugin-specific resources such as configuration files or auxiliary data from predefined locations within the Frama-C environment.",
      "description_length": 501,
      "index": 3844,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook.Make",
      "library": "frama-c.kernel",
      "description": "This module creates and manages an extensible hook that stores a collection of functions with no parameters or return values. It supports adding functions, checking existence by reference, applying all functions in registration order, and querying or modifying the hook's state. Use cases include orchestrating side-effecting actions at specific program points, such as initializing components, triggering analysis phases, or collecting results in a controlled sequence.",
      "description_length": 470,
      "index": 3845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option",
      "library": "frama-c.kernel",
      "description": "This module defines operations for an option type built over a parameterized type T, including standard equality, comparison, hashing, and pretty-printing. It provides utilities to manipulate optional values with deep copying, membership checks over projects, and type descriptors for integration with Frama-C's typing system. Concrete use cases include handling optional configuration parameters and managing project-specific data in Frama-C plugins.",
      "description_length": 451,
      "index": 3846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_list-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line option handling for list-valued parameters with custom data types. It provides functions to define, parse, and manipulate list-based options, supporting operations like equality checking, comparison, hashing, and pretty printing. It is used to configure and manage analysis settings that accept multiple values, such as lists of file paths or analysis targets.",
      "description_length": 396,
      "index": 3847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.ForwardAnalysis",
      "library": "frama-c.kernel",
      "description": "This module performs forward dataflow analysis over interpreted automata by propagating abstract states through control flow using a domain-specific transfer function. It computes the state after each transition, incorporating edge guards and actions, and enables tracking of program properties such as value ranges or reachability from function entry points. The analysis results module provides access to computed states at control points like function entry, return, and individual statements, supporting iteration and visualization in DOT format. Use it to inspect abstract states, annotate control-flow graphs with analysis data, or validate the effects of abstract interpretation passes.",
      "description_length": 693,
      "index": 3848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const.Vid",
      "library": "frama-c.kernel",
      "description": "This module manages unique identifier generation for CIL variables. It provides the `next` function to create fresh integer identifiers, ensuring each variable has a distinct ID. Useful during CIL AST manipulation to avoid naming conflicts when introducing new variables.",
      "description_length": 271,
      "index": 3849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.S-Set",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set interface for ordered, immutable sets with elements of type `elt`, supporting efficient membership checks, subset relations, and ordered traversal. It includes operations for set creation, modification (union, intersection, difference), transformation (map, filter, partition), and iterative processing (folding, sequence conversion), along with utilities for finding extremal elements, nearest values, and safe access via optional returns. Designed for functional purity, it integrates serialization, comparison, and project-aware introspection, making it suitable for static analysis tasks requiring precise set semantics and ordered data manipulation.",
      "description_length": 695,
      "index": 3850,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise.Make_bitwise",
      "library": "frama-c.kernel",
      "description": "This module combines lattice-theoretic and bitwise operations over interval maps indexed by memory zones, supporting precise abstraction and manipulation of memory states through hierarchical data structures. It provides core data types such as intervals, base addresses, and lattice elements (`Bottom`, `Map`, `Top`), with operations for merging, splitting, and filtering memory regions based on bitwise constraints and validity states. The child module enhances this with interval-to-value mappings, customizable merging strategies, and consistency checks, enabling efficient handling of sparse data and validation of memory accesses. Together, they support advanced static analysis tasks like abstract state merging, cache invalidation, and size-aware memory modeling.",
      "description_length": 771,
      "index": 3851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Filepath_list",
      "library": "frama-c.kernel",
      "description": "This module supports operations for handling command-line parameters that represent ordered collections of file paths, enabling dynamic modification through addition, iteration, and folding while maintaining integration with application state management. It works with mutable lists of file path objects (`Frama_c_kernel.Filepath.t`) and includes utilities for string serialization, categorization, and alias resolution. This is particularly useful in static analysis workflows where input files or library paths need to be dynamically configured and tracked during tool execution.",
      "description_length": 581,
      "index": 3852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice.Make_Map_Lattice",
      "library": "frama-c.kernel",
      "description": "This module equips Hptmaps with lattice operations over values, enabling structural manipulations like merge, filter, and diff, along with traversal and lattice-specific computations such as join, meet, and widening. It supports ordered keys and lattice-equipped value types, allowing efficient combination and approximation of map states in static analysis tasks like abstract interpretation. Child modules extend this with hash tables for structured key-value storage, ordered set operations maintaining lattice consistency, and cardinality constraints on map bindings. Specific uses include merging divergent program states, tracking project-specific keys across analysis passes, and modeling hierarchical or summarized abstract values with precise size reasoning.",
      "description_length": 767,
      "index": 3853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.S_with_collections_pretty-Hashtbl-Key",
      "library": "frama-c.kernel",
      "description": "This module defines operations for handling hash table keys, including equality, comparison, hashing, and pretty-printing. It supports data types compatible with `Hashtbl.Key.t`, providing utilities for deep copying, membership testing within projects, and generating representative values. Concrete use cases include managing and manipulating keys in hash tables for CIL-based analyses, such as tracking project-specific identifiers or caching intermediate results.",
      "description_length": 466,
      "index": 3854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Zero-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a zero-initialized datatype with operations for equality, comparison, hashing, and pretty printing. It provides a structured way to handle values of type `t` through standard functions like `equal`, `compare`, and `hash`, along with deep copying and membership testing over project skeletons. It is suitable for representing and manipulating immutable data structures within Frama-C plugins that require value tracking and comparison.",
      "description_length": 454,
      "index": 3855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.User_dir",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve user-specific directories and files, such as session, cache, config, and state directories. It works with string identifiers and returns paths as `Filepath.t` values, optionally creating the path if it doesn't exist. Concrete use cases include locating plugin-specific storage locations for persistent data or configuration files during analysis.",
      "description_length": 389,
      "index": 3856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Queue",
      "library": "frama-c.kernel",
      "description": "This module implements a queue data structure parameterized over a base type `T`, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports concrete use cases such as tracking and comparing sequences of values in static analysis plugins, particularly when deep copying or checking project membership is required. The queue is integrated with Frama-C's type and descriptor system for use in plugin-specific data representations.",
      "description_length": 468,
      "index": 3857,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache.Arity_Three",
      "library": "frama-c.kernel",
      "description": "This module implements a ternary cache for memoizing functions that take three arguments of types `H0.t`, `H1.t`, and `H2.t`, and return a result of type `R.t`. It supports `clear` to reset the cache and `merge` to apply a function with caching. It is used to efficiently store and retrieve results of pure functions with three inputs, such as combining three abstract values into a computed result.",
      "description_length": 399,
      "index": 3858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.S-Share",
      "library": "frama-c.kernel",
      "description": "This module manages paths within a plugin's share directory, providing operations to set and retrieve the directory location, check its existence, and resolve specific files or subdirectories within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, ensuring correct resolution or aborting on invalid paths. Concrete use cases include locating plugin-specific resources such as configuration files or auxiliary data stored in a predefined share directory.",
      "description_length": 477,
      "index": 3859,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Base.Hptset",
      "library": "frama-c.kernel",
      "description": "This module enables functional manipulation of polymorphic sets containing memory base-validity pairs, supporting operations like union, intersection, and predicate-based filtering, with an emphasis on hash-preserving transformations and cache-aware folding. It provides core data types for memory zones and supports advanced static analysis tasks such as merging memory states, validating regions, and tracking data flow. The first child module offers a specialized hash table for memory base addresses with imperative operations and utilities for memoization, while the second extends it for structured data management with deep copying and metadata handling. Additional submodules provide ordered sets and maps for precise memory region tracking, enabling efficient queries, ordered traversal, and functional updates tied to static analysis workflows.",
      "description_length": 854,
      "index": 3860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph.G",
      "library": "frama-c.kernel",
      "description": "This module implements a directed graph structure for modeling dependencies between program states, with support for querying vertex and edge relationships, traversing successor and predecessor links, and transforming graph elements. It works with labeled vertices and labeled edges, each representing a directed transition between states, and provides operations to analyze state transitions and dependencies in static analysis tasks. The module allows processing graphs while either preserving or ignoring edge labels, enabling tasks like control flow reconstruction or data dependency tracking. Submodules provide concrete representations for edges and vertices, supporting creation, comparison, and label access, which are essential for building and analyzing state transition graphs.",
      "description_length": 788,
      "index": 3861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap.Info",
      "library": "frama-c.kernel",
      "description": "This module defines the required metadata for ensuring correctness of maps built on hash-consed trees. It specifies the key and value types, initial shared map bindings, and dependencies that control cache invalidation. Used to manage stateful interactions between hash-consed trees and persistent map instances in static analysis contexts.",
      "description_length": 340,
      "index": 3862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata.Graph",
      "library": "frama-c.kernel",
      "description": "This module supports the analysis and transformation of imperative control flow graphs with typed vertices and edges, enabling operations like querying graph properties, modifying edges, and computing weak topological orderings. It works with structured representations of vertices (V), edges (E), and domain-specific tables (VTable), while integrating forward/backward analysis frameworks and DOT-based visualization. Designed for abstract interpretation workflows, it facilitates tasks such as reachable state computation, operational semantics modeling, and static analysis of CIL-derived programs through graph traversal and imperative manipulation.",
      "description_length": 653,
      "index": 3863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals.Types",
      "library": "frama-c.kernel",
      "description": "This module provides operations to query and manipulate type-related information in the AST, including checking existence and retrieving definitions for enum constants and named types. It works with CIL types, expressions, and global declarations, organized within type namespaces. Concrete use cases include resolving enum values during logic typing and iterating over defined types for analysis or transformation tasks.",
      "description_length": 421,
      "index": 3864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property.Set",
      "library": "frama-c.kernel",
      "description": "This module implements an immutable functional set interface for managing collections of ACSL properties, supporting operations like union, intersection, difference, and ordered element queries. It works with sets of `Frama_c_kernel.Property.t` elements, enabling ordered traversal, filtering, mapping, and sequence-based transformations while maintaining a total ordering. Typical use cases involve analyzing or transforming property sets during static analysis, such as aggregating verification conditions or processing property dependencies with precise control over element ordering and set algebra.",
      "description_length": 603,
      "index": 3865,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Proxy",
      "library": "frama-c.kernel",
      "description": "This module creates and manages state proxies to control dependencies between groups of states. It supports three dependency kinds\u2014backward, forward, and mutual\u2014and allows adding states to a proxy or retrieving the proxy's state. Concrete use cases include structuring complex state relationships in static analysis plugins to enforce correct evaluation order or limit unnecessary dependencies.",
      "description_length": 394,
      "index": 3866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel.PrintShare",
      "library": "frama-c.kernel",
      "description": "This module manages a configuration flag that controls the printing of shared path information during execution, with support for toggling the flag, registering change listeners, and persisting values across sessions. It uses a custom data type `t` for structured representation of project-specific data, providing operations for comparison, hashing, pretty-printing, and checking project membership, along with utilities for deep copying and atomic updates. The module enables command-line integration through aliases and serialization, making it suitable for debugging path resolution in static analysis or interfacing with external tools requiring path metadata. Example uses include tracking shared paths during analysis runs and synchronizing configuration state across different project scopes.",
      "description_length": 800,
      "index": 3867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder.Float_ref",
      "library": "frama-c.kernel",
      "description": "This module creates and manages a reference to a float value, enabling operations to set, get, and reset the value while supporting hooks for change notifications and custom serialization. It defines a float reference type with functions for equality, comparison, hashing, and pretty-printing, along with deep copy and project membership checks for state management. You can use it to track and observe dynamic floating-point values across static analysis stages, such as monitoring variable values during Frama-C plugin execution. The combination of direct mutation and state-aware operations makes it suitable for integrating float data into Frama-C's project system with full serialization and observation capabilities.",
      "description_length": 722,
      "index": 3868,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_topological.G",
      "library": "frama-c.kernel",
      "description": "This module defines a minimal graph interface for iterating over state vertices and their successors in topological order, specifically handling state clusters. It includes operations to traverse all vertices, iterate through successors of a given state, and determine the in-degree of a state. Concrete use cases include analyzing dependencies between program states during static analysis, ensuring correct processing order based on state relationships.",
      "description_length": 455,
      "index": 3869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-String_list-Category",
      "library": "frama-c.kernel",
      "description": "This module manages categories for parameter classification, providing operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types represented as `t` and `elt`, and interacts with plugin states through `Frama_c_kernel.State.t`. Use cases include configuring plugin parameters with custom categories, enabling global behavior through the `@all` category, and setting default category interpretations.",
      "description_length": 472,
      "index": 3870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.InlineStmtContracts",
      "library": "frama-c.kernel",
      "description": "This module controls the inlining of statement contracts through a boolean kernel option, allowing the feature to be toggled, queried, and reset dynamically. It maintains an internal state integrated with the project system for persistence and scoped modifications, with change hooks to react to updates. The child module enhances this by defining a data type `t` with comparison, hashing, and pretty-printing operations, supporting structured data handling for project-specific contract logic. Together, they enable precise control over contract inlining behavior and structured data manipulation during static analysis.",
      "description_length": 621,
      "index": 3871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig.Shape",
      "library": "frama-c.kernel",
      "description": "The module provides read-only operations for structural analysis and comparison of heterogeneous map structures with fixed key types, supporting element lookup (`find`, `mem`), traversal (`fold`, `iter`), and equality checks (`for_all`, `exists`). It enables advanced operations like reverse-order folding with caching, symmetric inclusion tests, and custom predicate-based comparisons between maps, often used for non-destructive inspection in static analysis or data integrity verification. The design emphasizes efficient traversal and structural equivalence checks without modifying underlying map contents.",
      "description_length": 611,
      "index": 3872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Set-As_string",
      "library": "frama-c.kernel",
      "description": "This module provides operations to configure and validate string-based command-line parameters, including setting allowed values, managing update hooks, and serializing state. It works with string values (`As_string.t`) and string lists, supporting use cases like restricting parameter inputs to predefined options or function names and ensuring consistency across plugin configurations. Key functionality includes validation against allowed values, dynamic value updates via hooks, and integration with Frama-C's project state management.",
      "description_length": 539,
      "index": 3873,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-String_set",
      "library": "frama-c.kernel",
      "description": "This module supports managing a command-line interface configuration option that stores a mutable set of strings, enabling operations like adding elements, checking membership, iterating over contents, and determining emptiness. It handles state management through global variables, with support for default values, dynamic update hooks, and serialization mechanisms to persist or parse configurations. Typical applications include handling multi-value command-line flags, such as specifying sets of files, plugins, or analysis targets, while allowing aliases and custom string representations for flexibility.",
      "description_length": 610,
      "index": 3874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel.Quiet",
      "library": "frama-c.kernel",
      "description": "This module manages a global silent execution flag with support for state changes, listeners, and command-line integration, while its child module defines a structured data type `t` with rich comparison and transformation operations. The parent module provides direct control over quiet mode through setting, querying, and persisting its boolean state, and the child module enables manipulation and inspection of data values within analysis workflows. Together, they support use cases such as suppressing output during batch processing and managing abstract data transformations in Frama-C's kernel. The combined functionality allows for fine-grained control over execution behavior and structured data handling across sessions.",
      "description_length": 728,
      "index": 3875,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Filepath_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type to represent file paths and provides deep copying, membership testing, and project-specific filtering. Concrete use cases include managing and comparing file path configurations within Frama-C plugins, such as tracking source file dependencies or analyzing include paths.",
      "description_length": 472,
      "index": 3876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.Option_with_collections",
      "library": "frama-c.kernel",
      "description": "This module structures optional values with rich collection types, offering equality, comparison, and pretty-printing for `T` and its optional variants. It includes a map for immutable, project-aware key-value associations, a set for ordered element manipulation with safe option returns, and hash tables supporting efficient lookups and ordered iteration over optional keys. Use it to track variable mappings with missing data, perform safe set operations with ordered elements, or memoize analysis results keyed by optional identifiers. Examples include filtering project-specific map entries, computing set intersections with `None` handling, and building hash tables that store analysis metadata under optional keys.",
      "description_length": 720,
      "index": 3877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Attribute",
      "library": "frama-c.kernel",
      "description": "This module provides core operations for working with CIL attributes, including equality, comparison, hashing, and pretty-printing, along with utilities for handling lists, sets, maps, and hashtables of attributes. Its submodules enable ordered manipulation of attribute sets, ordered associative maps keyed by attributes, and imperative hash tables optimized for attribute keys, supporting operations like union, filtering, traversal, and memoization. Key data types include sets, maps, and hashtables with associated operations for membership, transformation, and structured data handling, particularly useful for static analysis tasks like tracking and transforming C code annotations. Specific uses include managing function attributes across analysis contexts, aggregating type qualifiers, and optimizing attribute-based metadata in CIL representations.",
      "description_length": 858,
      "index": 3878,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Make_list-As_string-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements command-line parameters for string-based data types with support for parsing, comparison, and pretty-printing. It handles operations like equality checks, hashing, and project membership testing for use in static analysis configurations. Concrete use cases include defining options for source file paths, output formats, or analysis targets in Frama-C plugins.",
      "description_length": 383,
      "index": 3879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype.S_with_hashtbl",
      "library": "frama-c.kernel",
      "description": "This module defines a datatype with support for hash tables, providing operations like equality, comparison, hashing, and pretty-printing for values of type `t`. It includes a `Hashtbl` submodule for creating and managing hash tables over `t`. Concrete use cases include efficiently storing and retrieving analyzed program elements, such as variable states or function summaries, during static analysis.",
      "description_length": 403,
      "index": 3880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Indexer.Elt",
      "library": "frama-c.kernel",
      "description": "Elt defines operations for managing elements within an ordered collection, supporting efficient random access and comparison. It works with items stored in an indexed structure, where each element is uniquely identified and ordered. This module is used to implement dynamic GUI components like trees and lists, where fast lookup and positional access are critical.",
      "description_length": 364,
      "index": 3881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff.Logic_var",
      "library": "frama-c.kernel",
      "description": "This module manages mappings between logic variables and their associated data, providing stateful operations like memoization, lookup, and iteration, along with custom serialization and change notifications. It supports efficient tracking and persistence of variable states across project versions, enabling cross-project analysis and incremental updates. The child module enhances this functionality with standard utilities for logic variables, including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. Together, they facilitate structured traversal, diff computation, and event-driven handling of logic variable data.",
      "description_length": 679,
      "index": 3882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services",
      "library": "frama-c.kernel",
      "description": "This module provides logging, diagnostics, and error-handling operations with support for structured message formatting, verbosity levels, and categorized output (e.g., warnings, errors). It works with types like `warn_category`, `Log.warn_status`, command-line groups (`Cmdline.Group.t`), and utility data structures such as string/file path sets, numeric abstractions, and function sets. Its features are used to implement plugin configuration interfaces, conditional diagnostic reporting, and robust error recovery mechanisms in static analysis tools.",
      "description_length": 554,
      "index": 3883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Plugin.General_services-Fundec_set-As_string",
      "library": "frama-c.kernel",
      "description": "This module manages string-valued plugin parameters with support for validation, value constraints, and runtime state tracking. It operates on string data and collections of allowed values, enabling use cases like configuring plugin behavior through validated options, handling function name references, and persisting parameter state across Frama-C project sessions. Key operations include setting default values, restricting inputs to predefined lists, and triggering callbacks on modifications.",
      "description_length": 497,
      "index": 3884,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.List-Category",
      "library": "frama-c.kernel",
      "description": "This module organizes command-line option categories, managing their activation and grouping. It supports operations to define, retrieve, and modify categories using names, accessors, and dependency lists. Use it to structure related options under named categories, set default behaviors, or enable/disable groups of options collectively.",
      "description_length": 338,
      "index": 3885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype.Term_lhost",
      "library": "frama-c.kernel",
      "description": "This module provides fundamental operations for working with term l-values in CIL, including equality, comparison, hashing, and pretty-printing, while supporting efficient data structures like sets, maps, and hash tables. It enables ordered storage and manipulation of term-indexed data through specialized submodules for heterogeneous maps, ordered sets, and hash tables, each offering insertion, traversal, transformation, and structured queries. Use cases include tracking memory locations, managing symbolic expressions, and organizing analysis results in Frama-C plugins, with support for operations like union, nearest-elt queries, memoization, and safe lookups. The combined interface allows precise static analysis and transformation of C code through rich, term-based data organization.",
      "description_length": 795,
      "index": 3886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig.Builder-Float-Datatype",
      "library": "frama-c.kernel",
      "description": "This module implements a float-based command-line parameter builder with support for equality checks, comparison, hashing, and pretty printing. It operates on float values and provides a structured way to define and manage command-line options with a focus on numeric configuration parameters. Concrete use cases include defining thresholds, numeric tolerances, or scaling factors in static analysis plugins.",
      "description_length": 408,
      "index": 3887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filepath",
      "library": "frama-c.kernel",
      "description": "This module manipulates normalized filepaths with path resolution, absolute/relative conversion, and case-insensitive comparison, centered around the private `t` type for consistent path representation. It supports path concatenation, suffix checks, and string conversion, enabling tasks like resolving project-relative paths or normalizing paths for deterministic comparison in analysis tools. Child modules build on this foundation by organizing paths into ordered sets, hash tables, and key-based maps, supporting set algebra, efficient lookups, and ordered traversal with project-aware utilities. These structures facilitate managing file metadata, caching analysis results, and handling complex file contexts with type-safe storage, filtering, and transformation operations.",
      "description_length": 779,
      "index": 3888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Infer_assigns",
      "library": "frama-c.kernel",
      "description": "This module generates possible assignment targets from a C function prototype. It provides the `from_prototype` function, which takes a kernel function and returns a list of `from` expressions representing potential assignments. This is used in static analysis to infer which memory locations a function may modify based on its prototype alone.",
      "description_length": 344,
      "index": 3889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Tr_offset",
      "library": "frama-c.kernel",
      "description": "This module represents and manipulates sets of bit-level offsets, supporting operations like trimming offset ranges based on memory validity. It works with integer values and intervals, using constructors like `Set`, `Interval`, and `Overlap` to capture precise or approximate valid offset regions. It is used to model memory access validity in static analysis, particularly for handling pointer arithmetic and ensuring safe memory reads or writes.",
      "description_length": 448,
      "index": 3890,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer",
      "library": "frama-c.kernel",
      "description": "The module integrates pretty-printing functionality for CIL-based abstract syntax trees with customizable extensions, supporting structural elements like variables, types, expressions, and annotations through operations tied to `Frama_c_kernel.Cil_types` and `Format.formatter`. Submodules enable the adaptation of printing behavior via functors and object-oriented extensions, allowing developers to inject custom formatting rules for new AST node types or adjust output styles for specific contexts. Examples include generating C code from ASTs, producing debug-oriented dumps, or suppressing annotations during visualization. While two submodules provide extension points for printers, the other two currently remain unused.",
      "description_length": 727,
      "index": 3891,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hpath",
      "library": "frama-c.kernel",
      "description": "This module represents hierarchical paths with support for absolute, relative, and named base paths, and provides operations to construct paths from strings, resolve them against known bases, and convert them to URIs. It tracks associations between Hpath values and strings, allowing mappings to be added, removed, or queried, with support for maintaining and resetting a registry of named path references. Main data types include the Hpath value itself and string-labeled mappings; operations span path resolution, base association, and registry management. Example uses include resolving file paths in static analysis, managing include paths, and labeling project-specific hierarchies for persistent reference across analysis phases.",
      "description_length": 735,
      "index": 3892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ghost_accesses",
      "library": "frama-c.kernel",
      "description": "Performs static checks to ensure memory accesses respect the \\ghost qualifier's constraints, verifying that only ghost code can declare or modify ghost memory. Works with the kernel's internal representation of C code and annotations. Used during analysis to catch invalid memory operations in ghost code.",
      "description_length": 305,
      "index": 3893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builtins",
      "library": "frama-c.kernel",
      "description": "This module manages built-in functions and attributes for C analysis, enabling registration, identification, and initialization of compiler-specific and custom built-ins. It works with CIL types like `varinfo`, `typ`, and location, and integrates with Frama-C's analysis plugins to model low-level operations and compiler extensions from GCC and MSVC. The module's submodules provide project-aware data structures for storing and manipulating built-in function templates, mappings of function names to type signatures, and state tracking for GCC built-in availability. These components support structured analysis data management, precise symbol resolution, and semantic translation of compiler-specific constructs across analysis phases.",
      "description_length": 738,
      "index": 3894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_interval_sig",
      "library": "frama-c.kernel",
      "description": "This module provides operations for representing and manipulating intervals of floating-point numbers with configurable precision, enabling precise static analysis of numerical computations. It includes core functionality for interval arithmetic, comparison, and precision control, working with abstract floating-point values and special cases like NaN and infinity. The child module extends this with lattice-based abstract interpretation support, offering inclusion checks, joins, widening, and constraint refinement through backward and forward comparisons. Together, they enable tasks such as detecting overflows, underflows, and precision loss in C code, refining value ranges using relational constraints, and modeling precision-sensitive behaviors in numerical programs.",
      "description_length": 777,
      "index": 3895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ordered_stmt",
      "library": "frama-c.kernel",
      "description": "This module converts between statement (`stmt`) and integer-ordered statement (`ordered_stmt`) representations within a function, using bidirectional mapping tables. It provides functions to translate individual statements or ordered indices using these mappings, and retrieves cached conversion tables for a given function, including a topologically sorted component index. It is used to analyze or transform control flow graphs by enabling efficient lookups and ordering operations on statements.",
      "description_length": 498,
      "index": 3896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Globals",
      "library": "frama-c.kernel",
      "description": "This module orchestrates the management of global variables, functions, and annotations within Frama-C's AST, enabling precise navigation and modification of global entities. It supports operations such as retrieving variable information, querying function definitions, performing syntactic variable searches, and accessing global symbols per source file, all while handling type-related data like enums and named types. Key data types include `varinfo`, `fundec`, `kernel_function`, and `syntactic_scope`, facilitating tasks like tracking variable initialization, resolving function declarations, and extracting type definitions. Example uses include analyzing global variable usage across translation units, iterating over all function definitions to apply transformations, and locating variables within specific syntactic scopes for targeted analysis.",
      "description_length": 854,
      "index": 3897,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Escape",
      "library": "frama-c.kernel",
      "description": "This module provides functions to escape characters and strings according to C lexical rules. It handles standard and wide characters and strings, including `wchar` (represented as `int64`) and `wstring` (a list of `wchar`). These functions are used to generate valid C string and character literals from raw data, suitable for code generation or pretty-printing purposes.",
      "description_length": 372,
      "index": 3898,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Visitor_behavior",
      "library": "frama-c.kernel",
      "description": "This module orchestrates visitor behaviors for modifying or duplicating mutable structures in a project, offering operations like `inplace`, `copy`, and `refresh` to control mutation strategies. It manages visitor state `t` alongside `Project.t`, enabling transformations that preserve or update AST element identities, such as rewriting CIL structures during static analysis or managing scoped variable copies with fresh identifiers. Submodules handle AST reference updates, pairwise iteration with side effects, memoization of transformed nodes, and selective state resets or removals, supporting tasks like change synchronization, referential consistency tracking, and scoped analysis passes. Specific operations include updating variable representatives, folding over transformed statements, and resetting function definition tables to ensure clean visitor reuse.",
      "description_length": 867,
      "index": 3899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Eva_lattice_type",
      "library": "frama-c.kernel",
      "description": "This module defines lattice signatures that use the `Bottom` type to represent the bottom element, omitting it from the lattice structure itself. It includes operations like narrowing, under-approximation, and difference tracking, tailored for static analysis contexts such as interval analysis and abstract interpretation. The child modules extend these capabilities with set operations, difference computation, and refinement strategies, all handling the absence of a bottom element explicitly through `Bottom`. Specific examples include tracking variable ranges, refining abstract values during fixpoint computations, and modeling disjunctive invariants with cardinality constraints.",
      "description_length": 686,
      "index": 3900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_builder",
      "library": "frama-c.kernel",
      "description": "This module provides functors for defining and integrating new command-line options, particularly for kernel-level extensions, with support for locating kernel functions, managing parameter categories, and controlling AST dependencies. It enables the creation of custom analysis options that interact with Frama-C's configuration system, using data types such as booleans, integers, strings, lists, and custom structures, each with parsing, validation, and state management operations. Submodules extend this functionality to handle structured configurations like function mappings, file paths, and enumerated values, supporting use cases such as setting analysis thresholds, filtering target functions, and grouping options under activation conditions. The combined hierarchy allows for type-safe, modular command-line interfaces with dynamic updates and persistent state handling across plugins and analysis runs.",
      "description_length": 915,
      "index": 3901,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Clexer",
      "library": "frama-c.kernel",
      "description": "This module implements a lexer for the C programming language, providing functions to initialize and process source code files. It includes operations for tokenizing input, managing lexical contexts, and identifying C keywords, types, and identifiers. Concrete use cases include parsing C source files, handling macro expansions, and supporting syntax analysis in a C compiler or static analysis tool.",
      "description_length": 401,
      "index": 3902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto_statement",
      "library": "frama-c.kernel",
      "description": "This module computes and manipulates weak topological orderings (WTOs) for CIL statement graphs, enabling analysis of control flow structure and transitions between components such as loops. It provides data types for WTO values and indices, supporting operations like equality, comparison, hashing, and pretty printing, along with functions to retrieve WTOs for kernel functions, generate indices for statements, and compute differences between indices to track component changes. The module facilitates tasks such as analyzing control flow dependencies, managing fixpoint computations, and traversing CFG components during static analysis. Specific use cases include detecting loop entry/exit points and comparing control flow positions across program transformations.",
      "description_length": 770,
      "index": 3903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap_sig",
      "library": "frama-c.kernel",
      "description": "This module organizes high-performance, persistent map operations into shape-preserving queries and structure-modifying actions, with support for caching strategies and precise control over map transformations. It defines core types like key-value pairs with ordered or hash-consed keys, and operations such as insertion, deletion, filtering, and merging, alongside read-only structural analysis and traversal. Submodules handle hierarchical keys, imperative hash tables, polymorphic ordered maps, and read-only shape inspection, enabling use cases like static analysis, symbol table management, and cached computation handling. Specific capabilities include symmetric merges of hierarchical maps, ordered iteration over key ranges, and non-destructive structural comparisons with custom predicates.",
      "description_length": 799,
      "index": 3904,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Frama_c_kernel.Logic_print",
      "library": "frama-c.kernel",
      "description": "This module provides functions to pretty-print various components of a parsed logic tree, including constants, types, quantifiers, expressions, and declarations. It operates on data structures like `constant`, `logic_type`, `lexpr`, `decl`, and `spec`, which represent elements of logic formulas and type definitions. Use cases include generating human-readable output for formal specifications, debugging logic expressions, and displaying annotated code constructs in a structured format.",
      "description_length": 489,
      "index": 3905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_dependency_graph",
      "library": "frama-c.kernel",
      "description": "This module manages a directed graph that models dependencies between analysis states, using labeled vertices and edges to represent states and their relationships. It supports adding or removing dependencies, co-dependencies, and persisting the graph in Dot format for visualization or analysis. Operations include traversal, transformation, and querying of graph elements, with utilities to map internal state objects to visual properties for rendering. Specific tasks include tracking control or data flow, analyzing state transitions, and generating diagrams to debug or report on inter-state dependencies.",
      "description_length": 610,
      "index": 3906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_set",
      "library": "frama-c.kernel",
      "description": "This module manages non-empty integer sets with bounded size, automatically converting to intervals when exceeding a cardinality threshold. It supports arithmetic and set operations, lattice joins and meets, and ordered iteration, returning `set_or_top` or `or_bottom` to preserve invariants during growth or reduction. The set algebra submodule handles union, intersection, and transformations while maintaining sorted order, the map submodule uses integer sets as keys for efficient mappings with automatic interval conversion, and the hash table submodule enables fast lookups using sets as keys with full support for equality, comparison, and hashing. Example uses include static analysis for tracking variable ranges, abstract interpretation with set-to-state mappings, and precise integer set manipulation under size constraints.",
      "description_length": 835,
      "index": 3907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Description",
      "library": "frama-c.kernel",
      "description": "This module implements functions to describe and format elements of C source code and analysis properties, such as statements, instructions, predicates, and regions. It supports structured and localized printing of properties, including their names, locations, and contexts, with options to control verbosity and formatting details. Use cases include generating human-readable output for analysis results, exporting property data to CSV, and customizing property display in tools or reports.",
      "description_length": 491,
      "index": 3908,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Result",
      "library": "frama-c.kernel",
      "description": "This module extends the standard `Result` type with utilities for error handling, value transformation, and integration with `option`, `list`, and `seq` types. It introduces `let+` and `and+` binding operators for clean, sequential composition of result-returning functions, and supports pipeline-style error propagation through infix operators like `(>>-)`, `(>>-:)`, `(and*)`, and `(and+)`. These features enable concise handling of workflows such as parsing, validation, and IO with potential failures, where multiple results must be combined or transformed while preserving error context. Direct APIs include mapping, flattening, and conversion functions, while submodules focus on operator-driven composition for both sequential and parallel result handling.",
      "description_length": 763,
      "index": 3909,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dump_config",
      "library": "frama-c.kernel",
      "description": "This module provides functions to serialize the Frama-C configuration into JSON format. It supports output to a JSON value or directly to standard output. Use it to inspect or externalize the current analysis configuration during Frama-C execution.",
      "description_length": 248,
      "index": 3910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_builder",
      "library": "frama-c.kernel",
      "description": "This module builds and manipulates C and logic expressions with a focus on static analysis, using CIL AST nodes like `exp`, `lval`, `stmt`, and `typ` to represent arithmetic, memory, and control-flow operations. It unifies type handling across OCaml and CIL, supporting primitive and composite types with qualifiers through \"prime\" types for low-level access and \"harden\" functions for unwrapping. You can construct typed expressions, model memory states, generate control flow like loops and conditionals, and create ACSL annotations for formal verification. Examples include building a conditional expression with type conversion, analyzing pointer validity, or generating a function call with memory access.",
      "description_length": 710,
      "index": 3911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_descriptive_printer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to print CIL expressions and lvalues using descriptive names instead of temporary variable names. It works with CIL's intermediate representation of C code, specifically expressions and lvalues. Use this module to generate user-friendly output for analysis results or error messages in tools built on Cabs2cil.",
      "description_length": 341,
      "index": 3912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Acsl_extension",
      "library": "frama-c.kernel",
      "description": "This module enables registration of custom ACSL extensions for Frama-C, supporting operations like preprocessing, typing, visiting, and printing of extended ACSL constructs. It works with logic expressions, typing contexts, CIL annotations, and module importers to integrate domain-specific annotations into Frama-C's analysis pipeline. Concrete use cases include defining new contract clauses, extending global and code annotations, and importing external logic modules.",
      "description_length": 471,
      "index": 3913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Config_data",
      "library": "frama-c.kernel",
      "description": "This module organizes configuration data for locating and loading plugins and resources at runtime. It provides data types like string lists for plugin paths and categorized location lists using `Dune_site.Private_.Helpers.Location.t` to manage libraries, plugins, and shared resources. Operations include retrieving plugin directories, listing and loading plugins, and initializing configured interfaces. Example usage includes loading a specific plugin by name or setting up all plugins during application startup.",
      "description_length": 516,
      "index": 3914,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Integer",
      "library": "frama-c.kernel",
      "description": "This module extends arbitrary-precision integer operations with mathematically precise arithmetic, bitwise logic, and division variants (Euclidean, C-style), supporting formal verification workflows. It manipulates unbounded integers through conversions to/from native types (int, float) and exposes utilities like GCD, modular rounding, and bit-level operations, ensuring consistency with Zarith's semantics. Designed for static analysis tools, it handles exact numerical computations, symbolic reasoning, and low-level bit manipulations in domains like program verification and compiler intermediate representations.",
      "description_length": 618,
      "index": 3915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Locations",
      "library": "frama-c.kernel",
      "description": "This component provides precise modeling of memory locations at both byte and bit levels, enabling operations like comparison, overlap detection, and conversion between granularities. It supports core data types such as `location`, `Location_Bytes.t`, `Location_Bits.t`, and `Zone.t`, used to represent and analyze memory regions in static analysis tasks like pointer tracking and memory safety verification. Submodules extend this foundation with set-theoretic and lattice operations, ordered and hashed collections, and transformations that support dynamic memory analysis, alias resolution, and symbolic execution. Examples include tracking pointer arithmetic in C programs, merging memory states during abstract interpretation, and verifying access patterns through precise region inclusion checks.",
      "description_length": 802,
      "index": 3916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_builder",
      "library": "frama-c.kernel",
      "description": "This module builds a dynamic printer that integrates pretty-printing for CIL and ACSL data structures, converting expressions, types, statements, and analysis results into customizable, human-readable output using OCaml's formatter. It supports core constructs like variables, loops, logic predicates, and kernel-specific elements such as behaviors and annotations, with options to control formatting details like brace visibility and annotation display. The class-based design allows extension with custom formatting rules, enabling tailored output for domain-specific data during debugging or verification. Examples include printing function definitions with optional braces or visualizing analysis states with custom formatting.",
      "description_length": 731,
      "index": 3917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_bounds",
      "library": "frama-c.kernel",
      "description": "This module structures computations over lattices with explicit top and bottom elements, enabling precise static analysis through monadic operations like `bind`, `map`, and lattice combinators such as `join`, `narrow`, and `is_included`. It supports data types like `'a t` for representing lattice values alongside submodules for list and option manipulations, product constructions, and conditional propagation of extremal values. Specific uses include composing abstract interpreters, analyzing sequences of values under lattice operations, and selectively propagating top or bottom through control-flow conditions. Examples range from merging abstract states using `join` to folding over lists while preserving undefined (bottom) states.",
      "description_length": 740,
      "index": 3918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Nat",
      "library": "frama-c.kernel",
      "description": "This module encodes Peano arithmetic at both the type and value levels, enabling compile-time and run-time enforcement of numeric properties such as zero, positivity, and strict positivity. It defines natural numbers using type constructors like `zero`, `succ`, and GADTs to represent values like `zero`, `one`, and their successors or predecessors. Concrete use cases include tracking vector and matrix dimensions in the Linear module, ensuring safe array accesses, and validating sizes in contexts where negative numbers are invalid.",
      "description_length": 535,
      "index": 3919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabs_debug",
      "library": "frama-c.kernel",
      "description": "This module provides pretty-printing functions for converting CABS abstract syntax trees into human-readable representations, primarily for debugging and logging. It operates on CABS data structures like statements, expressions, types, and attributes, using OCaml's `Format.formatter` to serialize their structural details. Typical use cases involve inspecting intermediate compiler representations during analysis or development to validate transformations and detect inconsistencies.",
      "description_length": 485,
      "index": 3920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_interval",
      "library": "frama-c.kernel",
      "description": "This module represents integer intervals with congruence constraints using min, max, rem, and modu fields, supporting arithmetic and bitwise operations on these intervals. Its first child module provides hash tables optimized for interval-based keys, enabling efficient insertion, lookup, and iteration with support for unbounded ranges and modular constraints such as even numbers or values \u22613 mod 5. The third child module implements maps associating these intervals with arbitrary values, supporting key-based transformations, bounded searches, and ordered traversal, ideal for symbolic range analysis and program verification. Examples include tracking variable bounds with periodicity, performing modular arithmetic on ranges, and mapping analysis results to structured integer domains.",
      "description_length": 791,
      "index": 3921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cmdline",
      "library": "frama-c.kernel",
      "description": "This module orchestrates command line parsing and execution stages in Frama-C, enabling registration of functions to run at specific points such as before plugin loading, after command line processing, or during exit. It supports operations like defining custom option parsers, initializing plugin state, and setting up cleanup routines on normal or error exit, using functions like `register` and `run`. The child module organizes command line options into named groups, providing structured access to related flags through an abstract type `t` and a default group instance. Together, they allow organizing and extending command line behavior, such as grouping plugin-specific options and executing setup or teardown logic at defined stages.",
      "description_length": 742,
      "index": 3922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Type",
      "library": "frama-c.kernel",
      "description": "This module manages static ML monomorphic type representations through low-level operations for registration, structural querying, equality, and hashing, working with abstract types, polymorphic definitions, and heterogeneous tables. It supports advanced manipulation of polymorphic types through functors and typed storage structures, enabling type-based data association and closure-aware registration. For example, it allows instantiating polymorphic types with multiple type parameters, storing and retrieving type-indexed metadata in heterogeneous tables, and inspecting function types with labeled parameters. Submodules extend this functionality to handle polymorphic types with two to four type variables, manage abstract type information, and implement type-safe heterogeneous storage keyed by strings or type values.",
      "description_length": 826,
      "index": 3923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lmap",
      "library": "frama-c.kernel",
      "description": "This module manages maps from bases to memory maps, where each base key is associated with an offset-based memory region. It provides operations to add, update, and query these mappings, with support for lattice-bound values and optimized insertion. Child modules enhance this functionality with hierarchical memory representations, lattice operations, and strategies for merging and narrowing memory states. Examples include modeling heap allocations, tracking disjoint memory regions, and verifying access patterns in static analysis.",
      "description_length": 536,
      "index": 3924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alarms",
      "library": "frama-c.kernel",
      "description": "This module manages structured alarm data through associative maps, ordered sets, and hash tables, integrating key-value operations with specialized submodules for data manipulation. It supports maps with ordered bindings, sets with membership validation, and hash tables with type-safe keys, enabling operations like merging, filtering, and traversal. Examples include tracking alarm dependencies with sets, organizing alarm states with maps, and caching computations using hash tables. Submodules provide comparison, equality, and hashing logic for keys and values, ensuring efficient and structured access to alarm entries.",
      "description_length": 626,
      "index": 3925,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_attributes",
      "library": "frama-c.kernel",
      "description": "This module provides operations for managing and manipulating C attribute lists, including adding, removing, filtering, and classifying attributes based on properties like qualifiers, storage modifiers, and array-specific semantics. It works with attributes from Cil_types, focusing on tracking properties such as constness, volatility, and ghost code, while supporting transformations through functions like partitioning, splitting, and filtering during CIL processing. Specific use cases include analyzing and transforming AST elements (e.g., types, variables) by handling standard and Frama-C-specific attributes to enforce scoping rules, optimize inlining, or manage bitfield declarations.",
      "description_length": 693,
      "index": 3926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_typing",
      "library": "frama-c.kernel",
      "description": "This module orchestrates logic typing and environment management for analyzing annotated C code, integrating type-checking, coercion, and environment scoping to translate logic expressions into CIL. It centers on typed CIL expressions, logic environments for scoped bindings of variables and labels, and structured logic types for validation, supporting operations like field typing, term casting, conditional conversion, and contract verification. Submodules refine type namespaces with equality and pretty-printing, manage local identifier mappings, and enforce structural consistency across logic type representations. Examples include resolving `Old` and `Post` labels in contracts, validating function preconditions, and translating logic terms into semantically correct CIL during static analysis.",
      "description_length": 803,
      "index": 3927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dynamic",
      "library": "frama-c.kernel",
      "description": "This module enables dynamic typing and cross-plugin communication by registering and retrieving abstract values through named, typed entries, supporting data sharing and runtime configuration. It provides core operations to manipulate typed parameters using string identifiers, with child modules offering specialized access for booleans, integers, strings, file paths, string lists, and sets. You can use it to configure analysis options, toggle features, load plugins dynamically, and exchange results between plugins during static analysis. Specific tasks include setting command-line options, managing input files, and tracking plugin states at runtime.",
      "description_length": 657,
      "index": 3928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parse_env",
      "library": "frama-c.kernel",
      "description": "Handles source file resolution and working directory configuration during parsing. It provides operations to open source files with reference scanning control, set and retrieve working directories for file paths. Used to manage file context and resolve include paths when processing C source files.",
      "description_length": 298,
      "index": 3929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Intervals_sig",
      "library": "frama-c.kernel",
      "description": "This module represents sets of integer intervals with a lattice structure, automatically merging consecutive or overlapping ranges. It supports interval arithmetic, set operations like union and intersection, and inclusion checks, while integrating with concrete integers and symbolic intervals for static analysis. Child modules extend its capabilities with advanced lattice operations, type-aware projections, and conversions that enable precise range tracking and safety property verification. Specific uses include analyzing program variables' possible values and approximating integer expressions within abstract interpretation frameworks.",
      "description_length": 644,
      "index": 3930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_lexer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to lexically analyze logic annotations in source code, converting character streams into tokens and parsing expressions, annotations, and specifications. It operates on lexing buffers and produces parsed structures like `lexpr`, `annot`, and `spec` for use in static analysis. Concrete use cases include parsing ACSL annotations in C code and handling extended specification files during plugin-driven analysis.",
      "description_length": 442,
      "index": 3931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_bitwise",
      "library": "frama-c.kernel",
      "description": "This module provides functors for constructing maps indexed by memory zones with efficient bitwise operations, enabling set-like manipulations of zones and default handling for absent keys. It supports lattice operations through submodules that allow join and meet combinations of zone-associated values, facilitating static analysis tasks such as memory state tracking and permission modeling. A key data type is the zone-indexed map with default, which can represent memory regions and their abstract values using hierarchies like intervals, base addresses, and lattice elements (`Bottom`, `Map`, `Top`). Operations include merging, splitting, and filtering memory regions based on bitwise logic and validity, supporting advanced analyses like abstract state combination and cache invalidation.",
      "description_length": 796,
      "index": 3932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_to_c",
      "library": "frama-c.kernel",
      "description": "This module converts logic-level constructs into their C-level counterparts, handling terms, lvalues, types, variables, and offsets. It translates logic types to C types, logic variables to C variable information, and resolves term-based structures into concrete C expressions or locations. Use cases include transforming formal specifications into executable C code, analyzing term validity for code generation, and mapping logical constructs to their runtime representations during static analysis.",
      "description_length": 500,
      "index": 3933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Origin",
      "library": "frama-c.kernel",
      "description": "This module provides operations to track and manage the provenance of imprecise values generated during static analysis, specifically handling descriptors that categorize origins such as misaligned memory accesses, merges of divergent data flows, or arithmetic operations on pointers. It works with an abstract type `t` to represent origin descriptors and associated base sets for contextual tracking, offering utilities to construct, compare, and visualize these descriptors. Its functionality is critical in analyses like Eva to diagnose and propagate imprecision sources arising from unsupported or ambiguous memory operations.",
      "description_length": 630,
      "index": 3934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Abstract_interp",
      "library": "frama-c.kernel",
      "description": "This module provides functors for constructing lattice structures used in abstract interpretation, enabling operations on approximated values, truth states with \"Unknown\", and integer abstractions. It supports building domains for static analysis, such as variable range tracking and boolean condition modeling, with utilities for comparison, relation, and manipulation of abstract values. Child modules refine these capabilities with difference-based integer representations, bounded lattice sets with hash-consed elements, ordered integer-keyed data structures, abstract comparison logic, and set-based lattice operations. These components together enable symbolic analysis, constraint solving, and efficient program state tracking through precise and optimized abstract domains.",
      "description_length": 781,
      "index": 3935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dotgraph",
      "library": "frama-c.kernel",
      "description": "This module enables the structured creation of DOT graphs using smart constructors that manage nodes, edges, and attributes, writing directly to a buffered `.dot` file. It supports advanced node structures like records and subgraphs, and integrates with map-based storage to visualize relationships such as control flow or abstract syntax trees. The module allows generating hierarchical layouts, annotated nodes, and complex interconnections, with support for deferred execution via continuations. Submodules handle key-to-node mapping, structured node composition, and associative data tracking for precise and customizable graph generation.",
      "description_length": 643,
      "index": 3936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Field",
      "library": "frama-c.kernel",
      "description": "This module defines a mathematical field signature with operations like addition, multiplication, and their inverses, supporting abstract field elements used in precise numerical computations. It includes submodules for key-based data structures, maps and sets over field elements, and hash tables with field keys or values, enabling structured manipulation of numeric data in static analysis contexts. The scalar submodule extends field operations with bounded arithmetic and conversions, while ordered sets and maps support typed, project-aware analysis with ordered traversal and structural transformations. Examples include modeling floating-point environments, verifying numeric abstractions, and tracking project-specific data through typed keys and hash tables.",
      "description_length": 768,
      "index": 3937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Log",
      "library": "frama-c.kernel",
      "description": "This module orchestrates logging and diagnostics across the Frama-C environment, structuring messages by severity, category, and source context while enabling runtime control over output behavior. It supports data types such as log levels, message buffers, and formatter listeners, allowing operations like delayed message emission, dynamic debug key activation, and warning status customization. With submodules handling categorized logging and plugin-specific diagnostics, it enables use cases such as suppressing transient messages, tracking deprecated features, and tailoring log output for analysis tools through structured formatting and conditional execution.",
      "description_length": 666,
      "index": 3938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rgmap",
      "library": "frama-c.kernel",
      "description": "This module implements associative maps from ranges to values, supporting efficient insertion and lookup of overlapping ranges. It provides operations to add entries with optional overlap handling, find the tightest matching entry for a given range, retrieve all overlapping entries, and iterate over stored entries in order of increasing width. It is specifically used for associating tags with AST nodes in GUIs, where nodes correspond to buffer offset ranges.",
      "description_length": 462,
      "index": 3939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_state_builder",
      "library": "frama-c.kernel",
      "description": "This module provides a suite of specialized hash tables for managing stateful data associated with CIL constructs such as expressions, statements, and variables, enabling efficient storage, retrieval, and traversal with support for project-scoped persistence and change tracking. It includes operations for memoization, dependency tracking, atomic updates, and custom serialization, along with equality checks, deep copying, and pretty-printing tailored for static analysis tasks. You can use it to cache analysis results per program point, track evolving variable or statement metadata, or maintain function-specific state across analysis passes in Frama-C plugins.",
      "description_length": 666,
      "index": 3940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project_output",
      "library": "frama-c.kernel",
      "description": "This module offers logging and diagnostic operations for kernel diagnostics, supporting verbose, debug, and diagnostic messaging with category-based filtering and exception handling. It manages structured log events, source positions, and warning categories (via `warn_category` and `warn_status`), enabling fine-grained control over message output. Key use cases include static analysis diagnostics, configurable error reporting, and conditional logging to filter output by severity or enabled keys during kernel execution.",
      "description_length": 524,
      "index": 3941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State",
      "library": "frama-c.kernel",
      "description": "This module manages project-compliant mutable states through creation, modification, and lifecycle control via serialization and update hooks, operating on `State.t` values. It includes set, map, and hash table modules for structured data handling, supporting use cases such as tracking program states during analysis and managing shared state information with consistent updates. The local state module enables initializing, resetting, and pruning state data based on project criteria, while the hash table module supports efficient memoization and caching with project-aware key comparisons. The map and set modules enable ordered traversal, keyed lookups, filtered transformations, and set operations, facilitating analysis state aggregation and comparison across execution contexts.",
      "description_length": 786,
      "index": 3942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machine",
      "library": "frama-c.kernel",
      "description": "This module exposes operations to query machine-specific details such as C type sizes, alignment values, compiler settings, and architecture properties. It interacts with project contexts and machine state data structures, returning primitives like integers and strings or structured types like Machdep objects, while also supporting initialization routines for platform-specific configurations and builtins. These capabilities enable target architecture abstraction, system limit handling, and compiler behavior configuration during C code analysis.",
      "description_length": 550,
      "index": 3943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear",
      "library": "frama-c.kernel",
      "description": "This module defines structures for linear algebra computations in static analysis, including scalars, vectors, and matrices over a field. It supports operations such as vector addition, matrix inversion, multiplication, and norm computation, with dimension safety ensured by static typing. The matrix submodule enables transformations like exponentiation for modeling linear filters, while the vector submodule allows representation and comparison of points in finite-dimensional spaces. Example uses include building identity matrices for linear transformations or calculating maximum norms of state vectors in analysis algorithms.",
      "description_length": 632,
      "index": 3944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Task",
      "library": "frama-c.kernel",
      "description": "This module enables structured concurrency through operations for creating, transforming, and managing asynchronous tasks, with support for cancellation, error handling, and resource management. It works with tasks, servers, and thread pools, facilitating process execution, shared task creation, and synchronized access via mutexes. Typical applications include coordinating concurrent computations, managing resource-intensive operations with progress tracking, and implementing command execution servers with controlled concurrency and task monitoring.",
      "description_length": 555,
      "index": 3945,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_sig",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive framework for defining and managing command-line parameters with support for primitive and composite data types such as booleans, integers, floats, strings, lists, sets, and maps. It enables hierarchical organization, value validation, dynamic state updates via hooks, and integration with project-specific state management, making it suitable for building structured command-line interfaces in static analysis tools. Key operations include setting and retrieving parameter values, enforcing constraints (e.g., allowed values or function names), handling aliases, and customizing serialization, with submodules offering specialized support for file paths, kernel functions, and category-based grouping of options. Examples include defining a string option that validates against a set of allowed values, tracking changes to a list of file paths, or grouping related parameters under a named category for collective enablement or help display.",
      "description_length": 979,
      "index": 3946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property",
      "library": "frama-c.kernel",
      "description": "This module enables the construction, manipulation, and analysis of ACSL properties by mapping specification elements to internal representations like `IPPredicate` and `IPAssigns`, tied to program points and behaviors. It provides core data types such as `t` for properties, along with sets, maps, and hash tables that support efficient storage, comparison, and transformation of property data during static analysis. Operations include property comparison, hashing, pretty-printing, and ordered traversal, with utilities for extracting property names, generating unique identifiers, and managing structured metadata across analysis phases. Specific use cases include tracking function specifications, aggregating proof obligations, validating postconditions, and managing invariant data keyed by property identifiers in formal verification workflows.",
      "description_length": 852,
      "index": 3947,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cparser",
      "library": "frama-c.kernel",
      "description": "Parses C source code into abstract syntax trees, handling tokens like keywords, operators, and literals. Processes lexed input using `interpret` and `file` functions to generate lists of parsed definitions. Used for analyzing or transforming C code into an AST for further processing, such as static analysis or code generation.",
      "description_length": 328,
      "index": 3948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Base",
      "library": "frama-c.kernel",
      "description": "This module provides operations for extended integers that can represent either concrete arbitrary-precision values or an abstract top element denoting unknown/undefined states. It supports arithmetic manipulations, comparisons, and conversions between these extended integers and standard integer representations, while handling cardinality checks and explicit error propagation for invalid projections. Such functionality is used in abstract interpretation frameworks to model integer ranges, track value uncertainty, and analyze programs with symbolic or imprecise integer values.",
      "description_length": 583,
      "index": 3949,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.State_topological",
      "library": "frama-c.kernel",
      "description": "This module enables topological traversal of state graphs while respecting dependencies between states and their clusters. It provides direct access to functions that process states in an order where each state is visited only after all its dependencies, using the graph structure defined by the `G` module type. The `fold` and `iter` functions allow processing control flow or dependency graphs, particularly in static analysis tasks where state relationships dictate evaluation order. Additionally, it includes operations to traverse vertices, inspect successors, and compute in-degrees, supporting precise analysis of clustered state structures.",
      "description_length": 648,
      "index": 3950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Pretty_utils",
      "library": "frama-c.kernel",
      "description": "This module offers functions for precise text formatting, including escaping characters, capturing output into strings, and structuring layouts with boxes and separators. It handles collections (lists, arrays), optional values, pairs, and custom data structures, enabling alignment, margin control, and dynamic text adjustment. These tools are used to generate readable, structured representations of complex data and adapt text presentation to constrained or variable display requirements.",
      "description_length": 490,
      "index": 3951,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cfg",
      "library": "frama-c.kernel",
      "description": "This module computes and manipulates control-flow graphs (CFGs) for C functions and files, primarily by populating predecessor and successor statement links in CIL function definitions. It provides operations to generate a CFG for an entire file or individual functions, simplify control structures into CFG-friendly forms, and clear CFG-related metadata. Use cases include analyzing function control flow during static analysis or transforming code for optimization and verification tasks.",
      "description_length": 490,
      "index": 3952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cvalue",
      "library": "frama-c.kernel",
      "description": "This module represents abstract memory values and their transformations for static analysis, modeling memory states with precision-aware structures that support operations like merging, narrowing, and cardinality estimation. It provides key data types including interval-based memory slices, offset maps, and tagged abstract values with metadata flags, enabling bit-level reasoning, pointer arithmetic, and lattice operations. You can use it to track memory bindings, refine states during symbolic execution, verify memory safety, and integrate analysis plugins for deterministic processing of abstract values. Examples include modeling uninitialized data, merging memory states at loop fixpoints, and estimating possible concrete states during analysis.",
      "description_length": 754,
      "index": 3953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_sig",
      "library": "frama-c.kernel",
      "description": "This module defines an interface for efficient maps from integer intervals to arbitrary values, enabling operations like adding, querying, and iterating over interval-value pairs. It supports advanced manipulation through submodules that implement directional traversal, value transformations, set operations, and narrowing functions for precise intersection of interval maps, including bitwise-aware reinterpretation. Concrete uses include static analysis tasks such as memory region tracking, cache management, and abstract interpretation with numeric ranges. Example operations include slicing intervals, joining overlapping ranges, and narrowing value mappings with or without bitwise normalization.",
      "description_length": 703,
      "index": 3954,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Undefined_sequence",
      "library": "frama-c.kernel",
      "description": "Performs semantic checks on sequences in CIL files to detect undefined behaviors. Works with CIL's abstract syntax tree structures, specifically function bodies and statement sequences. Validates that sequence points are properly respected in expressions to ensure well-defined evaluation order.",
      "description_length": 295,
      "index": 3955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_info",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for inspecting and analyzing CIL function structures, including retrieving formal arguments, checking variable roles, and accessing function metadata like name, ID, and definition status. It operates on CIL types such as `cil_function`, `fundec`, and `varinfo`, enabling precise queries on function prototypes and variable relationships. Submodules extend this functionality to support static analysis passes that identify parameters, determine variable scope, and distinguish function definitions from declarations. Specific capabilities include extracting function signatures, analyzing variable usage, and traversing function definitions in CIL-based tools.",
      "description_length": 691,
      "index": 3956,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Annotations",
      "library": "frama-c.kernel",
      "description": "This module enables querying, modifying, and managing annotations in Frama-C's abstract syntax tree (AST), focusing on ACSL specification elements like requires, ensures, assigns, and behaviors. It operates on AST nodes such as statements, kernel functions, and specs, supporting iteration, filtering, and transformation of annotations while handling dependencies like emitter ownership and clause consistency. Key use cases include static analysis of function contracts, program transformation tasks, and maintaining global annotation states during code verification.",
      "description_length": 568,
      "index": 3957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Fval",
      "library": "frama-c.kernel",
      "description": "This module provides precise floating-point interval arithmetic, supporting operations such as conversion to and from floats, comparisons, and pretty-printing. It centers around a private type `t` that represents intervals, including special values like \u00b10 and infinities, enabling accurate static analysis of floating-point computations in C code. Submodules extend this functionality to handle rounding, overflow, and lattice operations, making it suitable for constructing arithmetic lattices. Specific use cases include analyzing numerical precision and verifying correctness of floating-point transformations in compiled code.",
      "description_length": 631,
      "index": 3958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Binary_cache",
      "library": "frama-c.kernel",
      "description": "This module provides low-level functorial caches with configurable size, optimized for memoizing expensive binary and unary computations with strict control over equality and identity. It includes operations to set cache size, define cacheable types, and manage symmetric predicates, with child modules handling unary caching, binary combinations, ternary memoization, and symmetric predicate evaluation. Specific use cases include caching hash comparisons, memoizing abstract analysis states across domains, and storing serialized data with invalidation sentinels. The interface supports both direct cache configuration and specialized submodules for structured value pairing, symmetric operations, and low-level persistence.",
      "description_length": 726,
      "index": 3959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Printer_api",
      "library": "frama-c.kernel",
      "description": "This module organizes the extensible pretty-printing infrastructure for abstract syntax trees (ASTs), focusing on customizable output of CIL and kernel constructs. It defines core types and configurations for line directives, formatting, and wrapping, while submodules implement concrete printers for variables, expressions, statements, function definitions, logic terms, and annotations using `Format.formatter`. Operations allow precise control over brace placement, annotation display, and line numbering, supporting tasks like generating ACSL-annotated code, serializing analysis states, and preparing output for external tools. Functor-based extensions enable adding or modifying printing rules for new or existing AST nodes during static analysis.",
      "description_length": 753,
      "index": 3960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Utf8_logic",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for generating UTF-8 string representations of logical, set-theoretic, and mathematical symbols, including predefined constants for symbols like quantifiers, connectives, \u2124, \u211d, \u03c0, and \u221e. It operates on Unicode code points (as integers) and converts them to UTF-8 strings, enabling precise rendering of formal logic and mathematical notation in tools or interfaces requiring symbolic representation. The functionality supports use cases such as pretty-printing logical expressions or visualizing formal proofs with proper typographic symbols.",
      "description_length": 572,
      "index": 3961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_env",
      "library": "frama-c.kernel",
      "description": "This module coordinates logic definition management with a suite of state-aware storage systems for logic types, constructors, and annotations. It supports operations to register built-in logic objects, resolve dependencies, and extend definitions across analysis phases, while its child modules provide project-scoped hashtables for storing logic metadata with custom equality, comparison, and serialization. You can use it to parse and initialize logic expressions, track axiomatic rules by name, cache lemma bindings, and perform deep copies or membership checks on logic entities across different project contexts. Key data types include structured logic type descriptors, constructor info, and lemma bindings, all supporting precise manipulation and state transitions in formal verification workflows.",
      "description_length": 806,
      "index": 3962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Dominators",
      "library": "frama-c.kernel",
      "description": "This module computes dominators and postdominators for statements within a function, enabling precise control flow analysis. It provides operations to retrieve immediate dominators, common ancestors, and dominance relationships between statements, along with utilities to print dominance and postdominance graphs in DOT format. Concrete use cases include optimizing code by identifying control dependencies, analyzing unreachable code, and constructing control flow hierarchies for static analysis tools.",
      "description_length": 504,
      "index": 3963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_val",
      "library": "frama-c.kernel",
      "description": "This module represents integer sets with lattice-based abstractions, supporting arithmetic, bitwise, and set operations over intervals, congruences, and discrete elements. It enables controlled widening, fixed-point computations, and ordered traversal of abstract integer ranges, with core data types modeling integer semantics for static analysis. Submodules extend this foundation with polymorphic maps and imperative hash tables for lattice-aware key-value storage, set manipulation with union and intersection, and deterministic iteration over abstract integer keys. Example uses include merging value ranges during abstract interpretation, tracking variable bindings over integer domains, and performing precise or over-approximated set transformations in program analysis.",
      "description_length": 778,
      "index": 3964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Base",
      "library": "frama-c.kernel",
      "description": "This module abstracts memory zones and their validity in C programs, offering operations to manage bases like variables and dynamic allocations, validate offsets, and enforce access permissions. It includes memory base types with equality, comparison, and pretty-printing, alongside sets and maps for efficient querying and transformation of memory regions. Child modules provide ordered set operations for modeling validity regions, associative maps for tracking metadata across memory zones, and hash tables for caching and deterministic processing of addressable regions. It supports static analysis tasks such as abstract interpretation, pointer safety verification, and memory state merging using lattice structures and functional set manipulations.",
      "description_length": 754,
      "index": 3965,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hptset",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive set of purely functional operations for managing ordered sets, including union, intersection, difference, and membership checks, centered around the abstract data type `t` for sets of comparable elements. It integrates with child modules that extend functionality to imperative hash tables, maps, and project-aware operations, enabling efficient lookups, memoization, and analysis-specific set manipulations. The module supports concrete tasks such as tracking program variables, combining datasets, and converting between sets and lists, while submodules handle deep copying, custom hashing, and type-safe storage in static analysis contexts. Key data types include sets (`t`), hash tables indexed by ordered keys, and maps parameterized over data modules, all supporting operations like insertion, enumeration, and comparison-based folding.",
      "description_length": 879,
      "index": 3966,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Errorloc",
      "library": "frama-c.kernel",
      "description": "This module tracks and manipulates source code location information during parsing, providing functions to set and retrieve the current file, line, and working directory. It supports error reporting with contextual source snippets and location-aware messages, particularly for parsing-related errors. Use cases include handling preprocessor-generated line markers, displaying error contexts with surrounding code lines, and managing location state during file parsing.",
      "description_length": 468,
      "index": 3967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Service_graph",
      "library": "frama-c.kernel",
      "description": "This module computes service graphs from callgraphs, identifying service boundaries through graph traversal and transformation, supporting filtering and visualization. It provides core data types like `Service_graph.t`, `V.t` for labeled vertices, and `E.t` for directed, labeled edges, enabling operations such as reachability analysis, subgraph querying, and dynamic modification. Users can generate DOT visualizations, analyze function dependencies in Frama-C, or extract service units from entry points using graph algorithms. Submodules enhance this functionality with attribute handling, imperative graph updates, and precise vertex and edge manipulations for structured dependency analysis.",
      "description_length": 697,
      "index": 3968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Datatype",
      "library": "frama-c.kernel",
      "description": "This module provides foundational data types and operations for building structured, typed collections and mappings in static analysis plugins. It supports core functionalities such as equality, comparison, hashing, and pretty printing, enabling precise manipulation and representation of values like integers, characters, strings, pairs, triples, and more complex composites. Submodules extend these types with efficient collection structures\u2014ordered sets, persistent maps, and hash tables\u2014supporting operations like union, intersection, insertion, lookup, and ordered traversal. Examples include tracking variable bindings with maps, managing analysis states using sets, and caching results in hash tables with typed keys and values.",
      "description_length": 735,
      "index": 3969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Printer_tag",
      "library": "frama-c.kernel",
      "description": "This module converts abstract syntax tree elements like declarations, expressions, and statements into localizable values that map to source code locations, enabling precise location tracking and reverse lookups from file positions to program elements. It supports source-level navigation and pretty-printing with contextual location information, using child modules to handle string identifier associations, CIL and ACSL pretty-printing, structured declaration manipulation, and location-aware data structures. Specific capabilities include reconstructing source code from AST nodes, customizing output formatting for CIL constructs and annotations, and efficiently managing sets, maps, and hash tables keyed by location-aware values. These tools facilitate debugging, static analysis, and transformation tasks that require positional accuracy and structured navigation.",
      "description_length": 871,
      "index": 3970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Markdown",
      "library": "frama-c.kernel",
      "description": "This module enables programmatic construction of Markdown content through types representing inline elements, block elements, and structured documents. It supports operations for formatting text, organizing content into sections and tables, and manipulating document structure\u2014such as header promotion or element grouping\u2014with rendering handled via OCaml's Format module. These capabilities are particularly useful for automated documentation generation, report creation with embedded code blocks, and content aggregation workflows involving cross-references or external file inclusion.",
      "description_length": 586,
      "index": 3971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Clone",
      "library": "frama-c.kernel",
      "description": "Clones a kernel function and inserts the copy into the AST adjacent to the original. Works directly with `kernel_function` values from the Cil_types module. Useful for duplicating functions during analysis or transformation passes, ensuring the cloned function is properly registered in the abstract syntax tree.",
      "description_length": 312,
      "index": 3972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Float_sig",
      "library": "frama-c.kernel",
      "description": "This module provides a unified interface for working with floating-point numbers across multiple precisions, including single, double, and extended formats. It defines core operations such as arithmetic, comparison, and rounding with explicit control over rounding modes (up, down, near, zero), enabling precise numerical computations. The abstract type `t` supports classification (NaN, infinity), conversions to OCaml floats, and mathematical functions like logarithms and trigonometric operations. These capabilities are designed for applications in scientific computing, numerical analysis, and formal verification where exact floating-point behavior is essential.",
      "description_length": 668,
      "index": 3973,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Map_lattice",
      "library": "frama-c.kernel",
      "description": "This module organizes key-value structures with lattice semantics, enabling operations like join, meet, and widening over mapped values while supporting sets of maps with lattice properties. It provides data types for maps with lattice-typed values, sets represented as maps, and keys with precise comparison and hashing, allowing precise modeling of program states in static analysis. Operations include merging maps under lattice rules, extracting unique bindings under cardinality constraints, and approximating set differences for bounded abstract domains. Submodules enhance these capabilities with cardinality reasoning, ordered traversal, hash-based storage, and transformations tailored for abstract interpretation tasks like interval tracking and control-flow analysis.",
      "description_length": 778,
      "index": 3974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ast_diff",
      "library": "frama-c.kernel",
      "description": "This module computes structural and semantic differences between C projects by analyzing AST nodes and ACSL extensions, enabling fine-grained change detection across codebases. It supports comparing variables, types, statements, and logical constructs, with key operations for equality, comparison, hashing, and pretty-printing of AST elements. Data structures include project-scoped hashtables for enums, structs, functions, and logic variables, each supporting custom rehashing, versioned serialization, and change tracking. Example uses include detecting altered function signatures, tracking struct layout changes, and analyzing evolution of formal annotations across project versions.",
      "description_length": 689,
      "index": 3975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Populate_spec",
      "library": "frama-c.kernel",
      "description": "This module generates missing function specifications based on selected clauses such as `requires`, `assigns`, or `terminates`, using customizable generation modes. It operates on CIL types like `kernel_function`, `identified_predicate`, and `assigns`, allowing precise control over specification content and status. Concrete use cases include automatically filling in incomplete function contracts during static analysis or setting up default specifications for unannotated functions.",
      "description_length": 485,
      "index": 3976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_category",
      "library": "frama-c.kernel",
      "description": "This module manages parameter categories, each grouping values of a specific type. It supports creating, renaming, and reusing categories, as well as checking membership and folding over their elements. Concrete use cases include organizing and tracking parameter values in static analysis plugins based on shared states.",
      "description_length": 321,
      "index": 3977,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.System_config",
      "library": "frama-c.kernel",
      "description": "This module provides access to system-wide configuration settings and environment information for Frama-C, including paths to resource directories, plugin configurations, and preprocessing options. It supports operations to locate Frama-C libraries, determine GUI presence, and configure analysis plugins based on installed versions. The C preprocessor module exposes settings like the command path and architecture flags, ensuring correct preprocessing behavior, while the version module provides static metadata such as version numbers and codenames for compatibility checks. Submodules for paths and directories expose search paths and resource locations, and the plugin module manages plugin discovery and loading, supporting both startup and on-demand initialization.",
      "description_length": 772,
      "index": 3978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflows",
      "library": "frama-c.kernel",
      "description": "This module implements data flow analyses over customizable abstract domains, enabling precise propagation of information through control flow graphs using join semilattices and transfer functions. It supports both forward and backward analysis frameworks, allowing refinement of abstract states based on branching conditions or successor states, with concrete applications in constant propagation, liveness analysis, and taint tracking. The lattice module provides core operations for merging and comparing domain elements, while utilities for statement manipulation enable integration with CIL code. Specific analyses are built by defining domains with transfer functions and initializing from entry or exit points, iterating until fixpoint across reachable statements.",
      "description_length": 771,
      "index": 3979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Messages",
      "library": "frama-c.kernel",
      "description": "This module manages persistent storage of log messages, providing operations to iterate over, fold, and dump messages in the order they were emitted. It tracks counts of errors, warnings, and total messages, and allows resetting message flags to re-print previously shown messages. Use cases include auditing message history, implementing custom logging behaviors via hooks, and retrieving message statistics across analysis sessions.",
      "description_length": 434,
      "index": 3980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_monad",
      "library": "frama-c.kernel",
      "description": "The State monad enables functional management of global mutable state through computations that can retrieve, update, and propagate state across operations. It provides core data types representing stateful computations, along with operations like `return`, `bind`, and `map`, and supports advanced control flow with conditionals, list traversals, and optional values. This allows tasks such as tracking variable usage during static analysis, conditionally logging based on state, or transforming ASTs while maintaining shared context. Specific examples include accumulating analysis results across a list of expressions or modifying state only when certain conditions are met.",
      "description_length": 677,
      "index": 3981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_selection",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and manipulation of state sets through standard set operations like union, difference, and singleton construction, while offering dependency-aware transformations to include transitive dependencies or isolate co-dependent subsets. It supports efficient traversal via iteration and folding in either arbitrary or topologically ordered sequences, respecting state dependencies, which is crucial for static analysis tasks like program slicing or impact analysis where dependency chains dictate evaluation priorities.",
      "description_length": 546,
      "index": 3982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rmtmps",
      "library": "frama-c.kernel",
      "description": "This module manages the removal of unused global variables and labels in a CIL-processed program. It provides functions to determine which globals are roots for preservation, remove unused globals and labels based on customizable criteria, and control whether unused elements are retained. It operates directly on CIL types such as `global`, `label`, and `fundec`, making it suitable for optimizing intermediate representations during static analysis.",
      "description_length": 451,
      "index": 3983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Kernel_function",
      "library": "frama-c.kernel",
      "description": "This module provides tools to inspect and manipulate kernel functions, offering direct access to structural and semantic properties such as names, return types, variables, control flow, and attributes like `noreturn`. Its first child module manages sets of functions with efficient set operations, ordered traversal, and data association, enabling tasks like grouping functions by properties or tracking analysis results across project configurations. The second child module extends functionality with memoizing storage per function, supporting caching, state synchronization, and custom serialization within static analysis workflows. Together, they allow precise querying of function structure, set-based manipulation, and persistent, project-aware data attachment.",
      "description_length": 768,
      "index": 3984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Option",
      "library": "frama-c.kernel",
      "description": "This module enhances the `option` type with a comprehensive set of monadic operations, enabling clean and concise handling of optional values through chaining, filtering, and combining operations. It includes submodules that extend functionality to boolean conditions, list traversals, and infix operator-based composition, all while maintaining safe propagation of `None` results. Main data types center around `'a option`, with operations like `bind`, `map`, `only_if`, and operators such as `>>-` and `let*` facilitating sequential computation. Examples include validating input with conditional checks, parsing lists of fallible values, and composing lookups or conversions that may fail.",
      "description_length": 692,
      "index": 3985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabs",
      "library": "frama-c.kernel",
      "description": "This module represents the untyped Abstract Syntax Tree (AST) for C code, primarily used in parsing and analyzing C programs. It defines core data types such as `cabsloc` for source location tracking, `typeSpecifier` for C type representations including primitives, structs, unions, enums, and type queries. Concrete use cases include building custom C analyzers, implementing linters, or developing transformation passes that require direct access to the syntactic structure of C code.",
      "description_length": 486,
      "index": 3986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ival",
      "library": "frama-c.kernel",
      "description": "This module provides lattice-based arithmetic and bitwise operations on integer and floating-point intervals, represented as `Ival.t`, enabling precise static analysis of numeric program properties. It includes set-theoretic operations for merging and querying interval ranges, mutable hash tables for efficient interval-keyed storage with ordered traversal, and ordered maps for functional transformation of interval-associated data. You can perform union, intersection, widening, and bitwise operations on intervals, track abstract values across program points using hash tables, and manage structured state mappings with precise key comparisons and typed entries.",
      "description_length": 666,
      "index": 3987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project",
      "library": "frama-c.kernel",
      "description": "This module organizes and maintains internal states derived from AST-dependent computations, enabling multiple concurrent projects with structured state management. It offers core data types like maps, sets, and hash tables for organizing analysis results and metadata, with operations for comparison, hashing, and state-aware lookups. Child modules support state snapshots for debugging and rollback, and structured key-value tracking for hierarchical and imperative state transitions. Examples include restoring analysis states after failed transformations or tracking dependencies with ordered sets.",
      "description_length": 602,
      "index": 3988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Project_skeleton",
      "library": "frama-c.kernel",
      "description": "This module defines the core structure of a project skeleton, including a unique identifier, name, and mutable fields for managing project state. It supports creating dummy project instances and provides a setter module to configure properties like name and ID. The child module handles generation and renaming of project skeletons, allowing operations such as creating uniquely named instances and updating their names in a consistent way. Together, they enable internal management of project identity and structure within the library.",
      "description_length": 536,
      "index": 3989,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Oneret",
      "library": "frama-c.kernel",
      "description": "This module transforms function control flow to ensure a single return point, replacing multiple return statements with gotos and adding a final return if needed. It works with CIL function definitions, statements, and annotations, using custom types to track return clauses and goto annotations. A callback can be provided to process transformations, enabling analysis or instrumentation of function exits and gotos targeting return statements.",
      "description_length": 445,
      "index": 3990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Command",
      "library": "frama-c.kernel",
      "description": "This module handles file operations, process execution, and timing measurements. It provides functions for reading and writing files, interacting with system commands asynchronously or synchronously, and measuring execution time using `Sys.time`. Concrete use cases include copying files, running external processes with captured output, and profiling code performance with timers.",
      "description_length": 381,
      "index": 3991,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_float",
      "library": "frama-c.kernel",
      "description": "This module offers precise manipulation of floating-point values through typed operations, including format conversion with controlled rounding, arithmetic and transcendental computations, and property validation (e.g., NaN, infinity checks). It operates on typed float representations with explicit formats (single, double, long) and supports tasks like parsing from strings, bit-level encoding, and numerical algorithms requiring strict IEEE 754 compliance. Typical applications include static analysis tools needing rigorous floating-point semantics, numerical code verification, and cross-format computation where precision and overflow behavior must be explicitly managed.",
      "description_length": 677,
      "index": 3992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_datatype",
      "library": "frama-c.kernel",
      "description": "This module provides foundational data structures and operations for modeling and analyzing C programs through their CIL intermediate representation. It centers on precise manipulation of program elements like expressions, variables, types, functions, and logical constructs, offering structural equality, comparison, and hashing for accurate static analysis. Key data types include terms, l-values, offsets, predicates, attributes, and syntactic scopes, each equipped with utilities for deep copying, project-aware membership checks, and pretty-printing. Submodules provide ordered sets, maps, and hash tables tailored to these types, enabling efficient collection operations, deterministic traversal, and memoization for tasks such as code transformation, constraint solving, and analysis state management.",
      "description_length": 808,
      "index": 3993,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Hook",
      "library": "frama-c.kernel",
      "description": "This module provides a flexible system for defining and managing hooks\u2014collections of functions that can be dynamically extended and invoked at specific program points. It supports various hook types, including those with ordered execution based on priority or dependencies, transformation pipelines with shared input/output types, and simple side-effecting actions, enabling precise control over function application sequences. Operations include registering functions, defining dependencies, applying hooks in controlled order, and managing state, with concrete use cases like extending analysis phases, sequencing plugins, and injecting callbacks in static analysis tools. Submodules refine this behavior to handle parameterized hooks, ordered execution, and structural comparisons for use in sets and maps.",
      "description_length": 810,
      "index": 3994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Qstack",
      "library": "frama-c.kernel",
      "description": "This module provides a mutable double-linked list-based structure that supports efficient insertion at both ends, access to non-top elements, and in-place modifications. It allows operations like `push` to add elements at the end, `top` to access the first element, `idx` for index-based lookups, and `map` or `iter` for transformations and traversals. With support for membership checks, filtering, and positional queries, it enables dynamic manipulation of sequences such as program analysis states or processing pipelines where both stack-like and queue-like behavior is needed. The design combines direct stack manipulation with richer submodules for indexed access and bidirectional processing.",
      "description_length": 699,
      "index": 3995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Alpha",
      "library": "frama-c.kernel",
      "description": "This module manages alpha conversion by generating and tracking unique name variations with numeric suffixes. It operates on an alphaTable structure that maps name prefixes to suffix states, using strings for names and optional undo lists to revert changes. It is used to avoid name collisions during transformations, such as in variable renaming or symbol resolution tasks.",
      "description_length": 374,
      "index": 3996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_parser",
      "library": "frama-c.kernel",
      "description": "This module defines a comprehensive set of lexical tokens used to parse logic expressions and specifications in Frama-C's formal verification system. It includes functions to parse entire specifications, logical expressions, extension specifications, and annotations from annotated C code. These parsers are used directly on lexed input to construct abstract syntax trees for formal properties such as preconditions, postconditions, and invariants in Frama-C plugins like WP.",
      "description_length": 475,
      "index": 3997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Lmap_sig",
      "library": "frama-c.kernel",
      "description": "This module manages mappings from base values to memory maps, where each memory map associates offsets with values, enabling precise tracking and manipulation of memory states in static analysis. It provides operations to create, update, and query these nested maps, along with support for lattice-based merging, narrowing, and ordered set transformations to refine memory abstractions during analysis. Submodules handle key management, hash table operations, and type-safe memory map construction, enabling tasks like memoization, deterministic traversal, and precise intersection of memory layouts. Examples include tracking pointer-based memory accesses, merging memory states during fixpoint computation, and managing base-centric memory models with sub-byte precision.",
      "description_length": 773,
      "index": 3998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Sanitizer",
      "library": "frama-c.kernel",
      "description": "This module provides functions to construct and manipulate a buffer that sanitizes strings by retaining only alphanumeric characters and underscores. It ensures that leading, trailing, and consecutive underscores are removed, producing clean, identifier-friendly strings. Useful for generating valid variable names or identifiers from arbitrary strings.",
      "description_length": 353,
      "index": 3999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter",
      "library": "frama-c.kernel",
      "description": "This module computes asymptotic invariants for linear filters by analyzing state dimension bounds using matrix norms and spectral properties. It supports fixed-dimension vectors and matrices over a scalar field, with operations including addition, multiplication, inversion, norm calculation, and power computation. Submodules enable element-wise manipulation and advanced analysis of linear recurrences. Example uses include verifying filter stability and deriving long-term bounds on recursive system behavior.",
      "description_length": 512,
      "index": 4000,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Property_status",
      "library": "frama-c.kernel",
      "description": "This module manages property statuses in static analysis, orchestrating the emission, consolidation, and comparison of logical conclusions across analysis passes. It operates on hierarchical status types like `emitted_status` and `status`, supporting dependency resolution, consistency enforcement, and transitive consequence inference through directed acyclic graphs. The core type `t` represents property statuses such as `Valid`, `Invalid`, or `Unknown`, with functions to assess and report validation results, while a graph module captures dependencies for visualization and analysis. Operations for comparison, hashing, and status consolidation enable tracking, merging, and synchronization of property statuses across plugins and evolving program states.",
      "description_length": 760,
      "index": 4001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Machdep",
      "library": "frama-c.kernel",
      "description": "This module manages machine-dependent constants and type definitions, providing direct access to sizes and alignments of C types, endianness, and compiler-specific flags. It supports structured manipulation of architecture-specific configurations through the data type `t`, with operations for equality, comparison, hashing, and serialization to YAML, enabling precise tracking of platform-specific values across analysis phases. Submodules include hash tables, ordered maps, and sets keyed by machine configurations, allowing efficient storage, retrieval, and set-theoretic operations over unique architecture-dependent data. Use cases include generating platform-appropriate header files, configuring analysis backends for specific architectures, and managing platform-specific state in static analysis pipelines.",
      "description_length": 815,
      "index": 4002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filter",
      "library": "frama-c.kernel",
      "description": "This module enables the construction of new CIL files by selectively filtering and transforming elements such as functions and global variables from existing ones, supporting operations like removal, duplication, and renaming. It integrates the `build_cil_file` function for applying transformation rules defined in the `Info` submodule, allowing precise control over which code elements to retain or exclude. Visibility control functions let users manipulate the exposure of parameters, variables, and control-flow edges, with tools like `cond_edge_visible` enabling conditional branch simplification. Together, these capabilities support tasks like program slicing, test variant generation, and domain-specific optimization.",
      "description_length": 726,
      "index": 4003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parameter_state",
      "library": "frama-c.kernel",
      "description": "This module manages groups of parameters related to analysis configuration and state selection. It provides operations to retrieve selections of parameters based on their set status and role, such as those affecting analysis, being settable, or resettable during visitor copies. The module works with `State_selection.t` and `State.Set.t` to represent parameter selections and sets, particularly for controlling and tracking analysis options in Frama-C.",
      "description_length": 453,
      "index": 4004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Translate_lightweight",
      "library": "frama-c.kernel",
      "description": "This module provides a code transformation that interprets `__declspec` annotations in C files, converting them into appropriate semantic annotations. It operates on the abstract syntax tree (AST) of C code, specifically targeting lightweight annotations for specification purposes. A concrete use case is enabling the use of Microsoft-style `__declspec` attributes in Frama-C for function contracts or variable properties.",
      "description_length": 423,
      "index": 4005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Interpreted_automata",
      "library": "frama-c.kernel",
      "description": "The module models program control flow as labeled transition systems, where vertices represent control points annotated with semantic information and edges encode guarded transitions derived from CIL expressions and instructions. It provides data structures for control flow graphs, abstract domains with join and transfer operations, and algorithms for forward and backward dataflow analysis, loop normalization, and weak topological ordering using the Bourdoncle method. You can construct automata from C functions, perform reachability analysis, compute invariants through fixed-point iteration, and visualize analysis results in DOT format, all while avoiding direct CIL interpretation through the provided abstractions. Submodules handle graph construction, state propagation, loop restructuring, and efficient traversal strategies, enabling precise static analysis tasks such as constant propagation, liveness detection, and interval analysis over structured control flow.",
      "description_length": 978,
      "index": 4006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cil_const",
      "library": "frama-c.kernel",
      "description": "This module provides smart constructors and utilities for building and manipulating CIL's intermediate representation, including primitive and composite types, variable identifiers, and logic variables. It operates on core CIL AST elements like `typ`, `varinfo`, and identifier types (`vid`, `sid`, `eid`), supporting type construction, attribute handling, and AST transformations. The module includes submodules that generate unique integer identifiers via the `next` function, ensuring distinct IDs for variables, statements, and other elements during analysis or transformation tasks. Examples include constructing typed variables with unique IDs, defining structured types with metadata, and generating fresh identifiers for newly introduced expressions or symbols.",
      "description_length": 769,
      "index": 4007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Structural_descr",
      "library": "frama-c.kernel",
      "description": "This module provides first-class representations of OCaml types, enabling operations like packing, unpacking, and validating structural relationships for both primitive and complex types. It supports type-safe serialization, subtyping checks, and structured data handling through core types like `Structural_descr.t` and operations for tuples, sums, and containers. The recursive submodule allows creating and updating self-referential descriptors, useful for types like trees or linked lists. Examples include building a descriptor for a recursive variant type and validating its structure against a target type.",
      "description_length": 613,
      "index": 4008,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Frontc",
      "library": "frama-c.kernel",
      "description": "This module provides functions for parsing C files and applying syntactic transformations to the abstract syntax tree (AST). It operates on CABS (C Abstract Syntax) files and supports converting the AST to CIL (C Intermediate Language). A key use case is modifying the structure of parsed C code before further analysis or transformation steps.",
      "description_length": 344,
      "index": 4009,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil",
      "library": "frama-c.kernel",
      "description": "This API enables the construction and transformation of C abstract syntax trees through operations like function prototype manipulation, expression creation, type analysis, and visitor-based AST traversal. It works with data structures such as function definitions (`fundec`), variable declarations (`varinfo`), type descriptors (`typ`), and composite types, supporting tasks like static type checking, constant folding, and optimization in C code analysis. Key applications include formal verification of ACSL-annotated code, plugin-driven transformations, and architecture-specific size calculations for static analysis tools.",
      "description_length": 628,
      "index": 4010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Compression",
      "library": "frama-c.kernel",
      "description": "This module enables reading and writing Gzip-compressed data streams with support for raw bytes and strings, offering precise control over compression levels. It operates on `Gzip.in_channel` and `Gzip.out_channel` types, extending standard I/O primitives like `unsafe_really_input` and `output_value` to handle compressed serialization and efficient bulk data transfers. Typical applications include persisting large binary datasets with reduced storage overhead or interoperating with external Gzip-compatible tools through structured value serialization.",
      "description_length": 557,
      "index": 4011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Indexer",
      "library": "frama-c.kernel",
      "description": "This module organizes elements in a sorted structure with efficient indexing, enabling fast access and updates for GUI components like lists and trees. It supports key operations such as insertion, deletion, and lookup by position or value, maintaining order and uniqueness using the `Elt` module type. With logarithmic-time membership checks and range modifications, it handles dynamic collections where elements are frequently added, removed, or repositioned. Examples include backing stores for interactive UI elements that require responsive updates and positional queries.",
      "description_length": 577,
      "index": 4012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.File",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for preprocessing C source files, initializing and transforming abstract syntax trees (ASTs), and managing project configurations during code analysis. It operates on file paths, preprocessing directives, AST structures, and machine dependency data, enabling tasks like code reordering, constant folding, and visitor-based project creation. Key applications include applying transformation hooks before or after AST cleanup, generating structured output for dependencies, and setting up analysis pipelines with customizable preprocessing and project-specific manipulations.",
      "description_length": 604,
      "index": 4013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Bit_utils",
      "library": "frama-c.kernel",
      "description": "This module performs bit-level type analysis and memory layout computations, providing precise size queries, pointer and array element sizing, and offset-to-symbolic-type mapping. It operates on C types and lvalues, returning sizes in bits or bytes, determining type signs, and resolving pointed types. Concrete uses include analyzing struct field bit ranges, validating pointer arithmetic, and mapping memory offsets to symbolic CIL types during static analysis.",
      "description_length": 463,
      "index": 4014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Typed_parameter",
      "library": "frama-c.kernel",
      "description": "This module enables command-line configuration of typed parameters through a structured API that supports boolean, integer, float, and string values, with operations for access, comparison, and pretty-printing. It integrates with submodules that provide ordered maps and hash tables for managing typed parameter collections, supporting key-based lookup, merging, and traversal with project-aware metadata. These components allow developers to define, query, and persist plugin settings such as analysis thresholds or debug flags, while enforcing type safety and structured key hierarchies. Specific use cases include configuring Frama-C plugins via command-line options and maintaining analysis state across different phases using typed, project-specific parameter stores.",
      "description_length": 772,
      "index": 4015,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Bag",
      "library": "frama-c.kernel",
      "description": "The module implements a list-like collection optimized for efficient merging, supporting operations to combine sequences, transform elements via mapping and folding, filter content, and query properties like size. It maintains an abstract structure that preserves duplicate elements and order during sorting, enabling use cases like incremental accumulation of results or processing ordered data streams where frequent concatenation is required. Converting contents to standard lists is possible but discouraged for large datasets due to performance considerations.",
      "description_length": 565,
      "index": 4016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Exn_flow",
      "library": "frama-c.kernel",
      "description": "Handles exception flow analysis in the AST by tracking which exceptions each kernel function may throw. It provides functions to retrieve exception sets for functions, compute exception flow information, and transform functions to return union types that represent normal returns or exceptions. This supports precise exception handling during static analysis and code transformation workflows.",
      "description_length": 393,
      "index": 4017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inline_stmt_contracts",
      "library": "frama-c.kernel",
      "description": "Transforms statement contracts by converting `requires` and `ensures` clauses into `assert` statements after cleanup. Works with Frama-C's internal code representation to modify function contracts during analysis. Useful for integrating contract conditions directly into code for verification purposes.",
      "description_length": 302,
      "index": 4018,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Filesystem",
      "library": "frama-c.kernel",
      "description": "This module provides comprehensive file and directory management, supporting existence checks, content iteration, creation, removal, copying, and cryptographic digest computation. It operates on file paths with integrated compression handling, allowing seamless reading and writing of compressed files, and offers infix operators for concise error propagation and chaining of file operations. Main data types include file paths and result-aware channels, enabling tasks like directory traversal with path manipulation, safe file parsing with automatic decompression, and structured logging with inline error handling. Examples include verifying directory structures before writing binary files, reading compressed logs with automatic decompression, and composing file operations using `let*` for error-aware pipelines.",
      "description_length": 818,
      "index": 4019,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_types_debug",
      "library": "frama-c.kernel",
      "description": "This module offers utilities to format and output structured representations of CIL AST nodes, logic constructs, and CIL-specific types using OCaml's `Format.formatter`, supporting customizable delimiters and layouts. It handles data structures like expressions, statements, types, predicates, and program elements (e.g., enums, structs, annotations) to aid in debugging, logging, and visualizing complex CIL intermediate representations during static analysis or compiler development. The functions are designed for human-readable diagnostics, particularly for inspecting CIL's abstract syntax trees and logic definitions.",
      "description_length": 623,
      "index": 4020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inout_type",
      "library": "frama-c.kernel",
      "description": "This module defines a structured type for representing input and output zones in a program analysis context, with specific fields for different kinds of inputs and outputs, such as over_inputs, under_outputs_if_termination, and over_logic_inputs. It provides operations for equality, comparison, hashing, pretty printing, and transforming zone values, along with utilities for checking project membership and performing deep copies. Use cases include tracking data dependencies and analyzing termination-sensitive behavior in static code analysis.",
      "description_length": 547,
      "index": 4021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast",
      "library": "frama-c.kernel",
      "description": "This module provides access to the CIL abstract syntax tree (AST) used by Frama-C, enabling manipulation of parsed CIL files and global declarations. It supports operations such as marking AST changes, registering analysis states, and applying post-construction hooks, with direct access to raw AST files via `get` and internal-use-only `set`. You can use it to update the AST during analysis, synchronize plugins with AST modifications, or manage variable declarations and definitions. The child module extends this functionality by exposing the list of untyped CIL AST files, allowing retrieval and manipulation of raw structures before type checking.",
      "description_length": 653,
      "index": 4022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_printer",
      "library": "frama-c.kernel",
      "description": "This module provides low-level pretty-printing for CIL's intermediate representation, converting core constructs like variables, types, expressions, and statements into human-readable strings using `Format.formatter`. It directly supports CIL data structures such as `typ`, `exp`, `varinfo`, and control-flow entities, with specialized formatting for memory models, termination analysis, and function behaviors. The fourth child module enhances this by offering a customizable pretty-printer for CIL AST nodes, enabling tailored output of types, expressions, and statements\u2014useful for generating CIL dumps or inspecting transformations during analysis. The third child module further extends functionality through a functor-based interface, allowing insertion of custom printing logic at specific AST nodes without altering the core printer.",
      "description_length": 841,
      "index": 4023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Asm_contracts",
      "library": "frama-c.kernel",
      "description": "This module processes GNU extended assembly syntax to infer and generate code contracts during a post-annotation phase of analysis. It defines a code transformation category and uses an emitter to output the resulting annotations. It operates on assembly-level code structures and is used to enhance static analysis with inferred behavioral contracts from assembly hints.",
      "description_length": 371,
      "index": 4024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.FCHashtbl",
      "library": "frama-c.kernel",
      "description": "This module extends OCaml's `Hashtbl` with customizable hash and equality functions, enabling efficient handling of arbitrary key types and structured values. It supports imperative hash table operations such as insertion, deletion, iteration, and in-place filtering, along with advanced features like ordered traversal and sequence conversion. Users can create hash tables parameterized over key types with defined hashing behavior, then manipulate them using functional combinators or bulk updates from sequences. Example uses include memoizing function results, maintaining ordered mappings during static analysis, and transforming program state representations with custom hash policies.",
      "description_length": 691,
      "index": 4025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Kernel",
      "library": "frama-c.kernel",
      "description": "This module provides foundational services for Frama-C kernel development, enabling fine-grained control over diagnostics, logging, configuration, and low-level analysis behavior. It operates on key data structures such as abstract syntax trees, C metadata, warning categories, and configuration flags, supporting operations to customize static analysis through debug keys, semantic warnings, and version-aware extensions. Functionality is extended through child modules that manage specific kernel options\u2014such as memory range validation, code duplication, function unfolding, and command-line autocompletion\u2014each offering typed interfaces for setting, querying, serializing, and validating analysis parameters. Together, they enable kernel developers to build, configure, and extend Frama-C's core analysis capabilities with structured, project-aware state management and precise control over analysis precision and output behavior.",
      "description_length": 934,
      "index": 4026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Wto",
      "library": "frama-c.kernel",
      "description": "This module organizes graph nodes into hierarchical partitions, where each layer is topologically ordered and strongly connected components are recursively ordered. It provides core operations to extract the head of a partition, flatten partitions into node lists, and fold over partition heads to support fixed-point evaluation strategies. The child modules implement algorithms to construct these orderings: one computes WTOs using a customizable preference function, while the other implements the Bourdoncle algorithm to partition graphs from an initial node. Together, they enable efficient traversal and analysis of control flow graphs for dataflow analysis and program optimization.",
      "description_length": 689,
      "index": 4027,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Linear_filter_test",
      "library": "frama-c.kernel",
      "description": "This module tests the invariant computation of linear filters by applying them to predefined inputs and verifying the outputs. It works with linear filter structures and their associated data, ensuring correct behavior during filtering operations. A concrete use case includes validating the stability and accuracy of digital filter implementations used in signal processing applications.",
      "description_length": 388,
      "index": 4028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Ast_types",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for manipulating and analyzing type attributes, qualifiers, and structures in C and logic types. It operates on `typ` and `logic_type` data structures to perform tasks like unrolling nested type definitions, checking qualifiers (e.g., `const`, `volatile`), and classifying types (e.g., arrays, pointers, arithmetic types). These operations support static analysis of C code and logic expressions by enabling precise type inspection and transformation.",
      "description_length": 482,
      "index": 4029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Json_compilation_database",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve preprocessing flags, directory information, and existence checks for files in a JSON compilation database. It operates on file paths and returns structured data based on the database's contents. It is used to access compiler configuration per file when processing C code with Frama-C.",
      "description_length": 327,
      "index": 4030,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cprint",
      "library": "frama-c.kernel",
      "description": "This module provides functions to format and output Cabs AST components\u2014such as type specifiers, declarations, expressions, and statements\u2014into human-readable strings using OCaml's `Format.formatter`. It supports customizable output through control flags for aspects like comment inclusion or counter display, primarily aiding tasks like code generation and debugging. The operations focus on consistent pretty-printing of AST nodes to ensure structured and readable C code representation.",
      "description_length": 489,
      "index": 4031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Vector",
      "library": "frama-c.kernel",
      "description": "This module implements extensible arrays with dynamic resizing, supporting efficient element insertion, access, and iteration. It provides operations for adding elements, indexed access with optional defaults, mapping over elements, and converting to and from arrays. Use cases include accumulating data with variable size, implementing algorithms requiring indexed sequences, and interfacing with C code expecting array-like structures.",
      "description_length": 437,
      "index": 4032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unfold_loops",
      "library": "frama-c.kernel",
      "description": "Performs syntactic loop unfolding during the after-cleanup phase using the code transformation hook mechanism. Applies to C code by transforming loops into their expanded form based on a specified unfolding factor. Useful for improving precision in static analysis by reducing loop abstraction overhead.",
      "description_length": 303,
      "index": 4033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Temp_files",
      "library": "frama-c.kernel",
      "description": "This module creates and manages temporary files and directories that are automatically deleted upon program exit, unless explicitly preserved. It works with file paths and provides functions to generate unique temporary files or directories with specified prefixes and suffixes, controlling their retention with a `keep` flag or debug setting. Use it to safely handle transient files during analysis, ensuring cleanup while allowing debugging retention when needed.",
      "description_length": 465,
      "index": 4034,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cilconfig",
      "library": "frama-c.kernel",
      "description": "This module handles loading, saving, and managing hierarchical configuration data from files, using a variant type to represent values like integers, booleans, floats, strings, and lists. It provides direct access to configuration entries via key-based lookups and mutation functions, with specialized functions for extracting specific data types. It is used to persist and retrieve application settings in Frama-C's GUI, such as user preferences or interface states.",
      "description_length": 467,
      "index": 4035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap",
      "library": "frama-c.kernel",
      "description": "This module manages mappings from integer intervals to arbitrary values, supporting efficient insertion, removal, and query operations over potentially overlapping ranges. It enables structured manipulation of interval-bound data with operations like merge, slice, and lattice-aware narrowing, facilitating abstract interpretation tasks such as memory region tracking, value range analysis, and bitwise state modeling. Submodules control diagnostic feedback, manage interval construction and merging with lattice operations, and support bitwise transformations with interval fusion and cache-aware traversal. Example uses include static analysis of memory operations, abstract domain computations with widening, and compact representation of contiguous regions with uniform properties.",
      "description_length": 785,
      "index": 4036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Stmts_graph",
      "library": "frama-c.kernel",
      "description": "This module provides operations to analyze control flow relationships between statements in a function, including reachability checks, cycle detection, and edge traversal. It works with statements (`stmt`), blocks (`block`), and sets or lists of statements, enabling precise queries about control flow paths and graph structure. Concrete use cases include determining if one statement can reach another, finding all reachable statements from a starting point, identifying last statements in a block or statement, and analyzing loop predecessors or edges entering and exiting a statement's scope.",
      "description_length": 595,
      "index": 4037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Hptmap",
      "library": "frama-c.kernel",
      "description": "This module implements efficient maps over hash-consed tree keys using big-endian Patricia trees, enabling fast insertion, lookup, and modification of values based on structured keys derived from tree shapes. It supports advanced operations such as customizable merging, subtree manipulation, and heterogeneous comparisons, with concrete use cases including static analysis, program dependency tracking, and AST annotation. Submodules provide compositional boolean attributes, ordered set operations, imperative hash tables, and read-only inspection tools, all leveraging bitwise decomposition for performance. Key types include structured identifiers with structural equivalence and optional boolean flags, supporting workflows like tracking value flow, managing sparse state configurations, and cached transformations over hierarchical data.",
      "description_length": 843,
      "index": 4038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_bitwise_sig",
      "library": "frama-c.kernel",
      "description": "This module implements efficient interval maps with bitwise precision, where each interval is associated with a single value that is implicitly inherited by all its sub-intervals. It supports operations like `find`, `join`, and `fold` with interval fusion, enabling precise and efficient management of overlapping ranges over integer domains (`v`). Submodules extend this functionality with set-theoretic operations, project-aware membership checks, and iteration strategies tailored for static analysis tasks such as bit-level property tracking and memory region merging. Example uses include modeling sparse memory layouts and performing interval arithmetic with merged region semantics.",
      "description_length": 689,
      "index": 4039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_const",
      "library": "frama-c.kernel",
      "description": "This module enables the construction and manipulation of logic predicates, terms, and annotations for formal verification of C code, primarily working with `predicate` and `term` types alongside labels, offsets, and logic variables. It supports operations like creating memory-related predicates (`\\valid`, `\\separated`), logical expressions (quantifiers, implications), and type transformations, while handling set/list type manipulations and source-location tracking. Specific use cases include generating fresh identifiers for logic entities, modeling memory states via annotations like `\\at` and `\\old`, and constructing verification conditions with type-safe term coercions and offset arithmetic.",
      "description_length": 701,
      "index": 4040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Precise_locs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manipulate precise memory offsets and location bits, enabling accurate modeling of memory accesses during static analysis, especially for complex l-values like nested arrays or struct fields. It operates on transient structures such as `precise_offset` and `precise_location`, supporting operations like bit-level shifting, base replacement, and alignment-aware validity checks, which bridge the gap between precise and imprecise memory representations. These tools are critical for refining static analysis of semi-imprecise expressions where traditional abstract domains lose granularity, such as tracking individual bits in heap-allocated data structures.",
      "description_length": 692,
      "index": 4041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Statuses_by_call",
      "library": "frama-c.kernel",
      "description": "This module tracks and manages the status of function preconditions at specific call sites in the code. It allows creating, retrieving, and replacing specialized precondition properties for each call point of a given function, supporting both direct and indirect calls. Use cases include verifying that all call sites of a function satisfy its preconditions, or analyzing how preconditions are affected at different call locations.",
      "description_length": 431,
      "index": 4042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Json",
      "library": "frama-c.kernel",
      "description": "This module enables constructing, parsing, and serializing JSON data with strict output formatting, while supporting lenient input parsing. It operates on a `json` type representing JSON values, converting OCaml primitives (booleans, integers, strings, lists, options) and arbitrary-precision numbers (e.g., Zarith) to and from JSON, with utilities for filtering null fields, merging structures, and extracting typed values. Use cases include processing configuration files, exchanging data with external tools via strict JSON, and efficiently traversing or combining nested JSON objects and arrays with type-safe operations.",
      "description_length": 625,
      "index": 4043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Composition",
      "library": "frama-c.kernel",
      "description": "This module provides functors that compose two monads using a swap function to reorder nested layers, enabling correct monadic composition without reimplementing operations. It supports monads like State over Option, allowing stateful computations that may fail, with core operations return, bind, map, and flatten, along with child modules adding conditionals, infix operators, and list processing. Specific examples include error-tolerant stateful pipelines, selective logging, and processing optional data under combined effects. The main data types are composed monadic values `'a T.t S.t`, and key functions include `map`, `bind`, `only_if`, and operators like `>>-` and `let*`.",
      "description_length": 683,
      "index": 4044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabshelper",
      "library": "frama-c.kernel",
      "description": "This module provides utilities for constructing and manipulating Cabs AST elements, including identifiers, declarations, and source locations, with support for handling inline and static specifiers, string and digit processing, and precise source location tracking. Its child module manages comments linked to Cabs locations through a stateful store, enabling operations like adding, retrieving, and folding over comments associated with specific AST nodes. Together, they support tasks such as AST transformation, CIL-based analysis, and instrumentation that require both node construction and source annotation tracking. Example uses include rewriting function declarations with new specifiers, extracting source ranges from statements, and preserving comment metadata during code analysis.",
      "description_length": 792,
      "index": 4045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Descr",
      "library": "frama-c.kernel",
      "description": "This module provides operations to construct and transform type-safe descriptors for unmarshalling, supporting primitive types like integers and strings, as well as structured types such as pairs, lists, and options via combinators. These descriptors (`'a Descr.t`) enable safe parsing of dynamic data, conversion to structural representations, and handling of complex data transformations while ensuring type integrity during unmarshalling.",
      "description_length": 441,
      "index": 4046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabs2cil",
      "library": "frama-c.kernel",
      "description": "This module supports processing C code during translation to CIL through hooks and utilities that handle implicit prototypes, type conversion, and control flow adjustments, along with managing local environments and analyzing expressions and statements. It operates on CIL types such as expressions, statements, variables, and structs, ensuring compatibility with C99 semantics while enabling transformations like variable naming and field offset computation. Key applications include resolving side-effects in for loops, determining statement fall-through behavior, and validating address-of expressions during static analysis.",
      "description_length": 628,
      "index": 4047,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Finite",
      "library": "frama-c.kernel",
      "description": "This module encodes finite sets within the OCaml type system, offering operations to manipulate elements based on their position within a bounded set. It supports creation, traversal, and conversion of finite elements with precise cardinal constraints, using typed representations to enforce correctness. Concrete uses include managing fixed-size enumerations, safe index manipulation, and verified element relationships in bounded collections.",
      "description_length": 444,
      "index": 4048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Allocates",
      "library": "frama-c.kernel",
      "description": "This module provides functions to automatically add `allocates \\nothing` clauses to function specifications and loops in CIL code. It operates on CIL types, specifically targeting kernel functions and loop structures. Use cases include ensuring memory allocation safety in static analysis by defaulting to no allocations when no explicit clauses exist.",
      "description_length": 352,
      "index": 4049,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Parameter_customize",
      "library": "frama-c.kernel",
      "description": "This module configures how command-line options interact with plugin parameters, allowing fine-grained control over option stages, serialization, visibility, and function name handling. It supports boolean, string, and function-related parameters, enabling features like negative options, unset behavior, and function name mangling for better command-line usability. Concrete use cases include restricting when a parameter takes effect, hiding options from help, or mapping command-line function names to their mangled C identifiers.",
      "description_length": 533,
      "index": 4050,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Cil_types",
      "library": "frama-c.kernel",
      "description": "This module provides types and operations for representing C's abstract syntax and semantic constructs, including expressions, statements, functions, and global program structure, along with equality checks for these elements. It defines the `syntactic_scope` type to model visibility contexts like block-local, function-wide, or translation-unit scopes, which are critical for symbol resolution and analysis. These components enable static analysis, code transformation, and semantic verification tasks in C programs, such as tracking variable lifetimes or validating control flow.",
      "description_length": 582,
      "index": 4051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Async",
      "library": "frama-c.kernel",
      "description": "This module manages asynchronous tasks and periodic operations during analysis, using debounced triggers and daemon functions. It works with unit functions and boolean predicates, supporting temporary or persistent background actions. Concrete use cases include updating progress indicators, handling timeouts, and interleaving long-running computations with responsiveness in GUI or server modes.",
      "description_length": 397,
      "index": 4052,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Offsetmap_lattice_with_isotropy",
      "library": "frama-c.kernel",
      "description": "This module defines a lattice structure for offset maps with isotropy support, used in static analysis to model memory layout properties across program points. It provides operations to merge, compare, and abstract over bit-level data, including shifting, range extraction, and origin tracking, all while preserving isotropy in uniform memory regions. The core type `t` represents abstract memory offsets, enabling precise bitvector manipulations and lattice operations such as widening and inclusion checks. These capabilities support Frama-C's abstract interpretation by tracking low-level data transformations and memory state imprecision.",
      "description_length": 642,
      "index": 4053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Monad",
      "library": "frama-c.kernel",
      "description": "This module defines a monadic interface based on core operations like `return`, `bind`, `map`, and `flatten`, supporting parametric types `'a t` for effectful computations. It enables building and extending custom monads while ensuring adherence to monad laws, with concrete applications in handling optional values, sequencing stateful operations, and structuring parsers. Submodules provide specialized instances for `Option`, `List`, and `Bool`, along with infix operators for chaining and conditional execution via `only_if`, allowing tasks like mapping over lists of effectful values or conditionally logging within a monadic flow.",
      "description_length": 636,
      "index": 4054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Special_hooks",
      "library": "frama-c.kernel",
      "description": "Registers specialized hooks for Frama-C's internal event system, enabling custom behaviors during analysis phases. Works with Frama-C's plugin and kernel data structures to handle events like file loading, function calls, and analysis termination. Used to extend Frama-C's core functionality with domain-specific actions, such as initializing plugins or modifying analysis parameters.",
      "description_length": 384,
      "index": 4055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Rational",
      "library": "frama-c.kernel",
      "description": "This module implements a field structure for rational numbers, enabling arithmetic operations and comparisons over exact numeric values. It includes submodules for hash tables and maps optimized for rational keys, providing efficient storage, retrieval, and transformation of rational-indexed data. Key types include rational numbers and map structures with operations like insertion, lookup, iteration, and deep copying, supporting use cases such as symbolic analysis and state tracking. Example applications include caching rational-valued expressions and maintaining analysis state across project skeletons.",
      "description_length": 610,
      "index": 4056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unicode",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific Unicode string representations for set operations, such as inset, empty set, top, bottom, and union. It works with Unicode strings to support proper rendering of mathematical symbols. These functions are useful when displaying abstract interpretation results that require precise symbolic notation.",
      "description_length": 350,
      "index": 4057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Unix_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific directory paths such as the user's home directory, cache, configuration, and state directories. It works with string lists and environment variables to determine these paths, returning them as Filepath.t values. Concrete use cases include locating where to store user-specific data, configuration files, or temporary state information.",
      "description_length": 387,
      "index": 4058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Int_Intervals",
      "library": "frama-c.kernel",
      "description": "This module provides integer interval set operations with lattice semantics, supporting union, intersection, difference, and automatic merging of adjacent intervals. It works with an abstract interval set type that represents contiguous or disjoint integer ranges, along with conversion utilities for bounds, lists, and Frama-C kernel integer types. Designed for static analysis tasks, it enables efficient value approximation in abstract interpretation scenarios where interval fusion simplifies symbolic reasoning about program variables.",
      "description_length": 540,
      "index": 4059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.State_builder",
      "library": "frama-c.kernel",
      "description": "This module manages mutable state through typed references, hashconsing tables, and collection builders, supporting advanced patterns like size tracking, persistence, and thread-safe operations. It provides structured data types such as sets, queues, arrays, and hash tables with customizable equality, comparison, and serialization, enabling efficient state manipulation and dependency tracking. Submodules extend this functionality with project-aware weak hashtables, hash-consed values, versioned references, and state proxies, allowing precise control over memory, identity, and inter-state relationships. Example uses include tracking abstract states across program points, generating unique identifiers, caching analysis results, and managing plugin state with custom marshaling and update hooks.",
      "description_length": 802,
      "index": 4060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Macos_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve OS-specific directory paths such as user home, cache, configuration, and state directories. It works with string-based environment variables and file paths, returning them as `Filepath.t` values. Concrete use cases include locating user-specific storage locations or setting up application directories on macOS systems.",
      "description_length": 362,
      "index": 4061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Ghost_cfg",
      "library": "frama-c.kernel",
      "description": "This module defines a code transformation category that ensures the normal control flow graph (CFG) remains unaffected by ghost statements. It validates the structure of ghost CFGs during analysis, raising errors if inconsistencies are detected. Useful for verifying that ghost code does not inadvertently alter program behavior during static analysis.",
      "description_length": 352,
      "index": 4062,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Float_interval",
      "library": "frama-c.kernel",
      "description": "This module implements a domain for analyzing floating-point intervals with customizable precision, enabling precise tracking of value ranges through arithmetic and lattice operations. It centers around the `t` type, representing intervals bounded by single- or double-precision floats, including support for NaN and infinities, and provides operations like join, widen, and constraint propagation. Users can perform interval arithmetic, refine value ranges under constraints, and detect overflows or underflows during static analysis. Example use cases include verifying floating-point safety in numerical code and improving precision in abstract interpretation passes.",
      "description_length": 670,
      "index": 4063,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_preprocess",
      "library": "frama-c.kernel",
      "description": "Performs macro expansion in annotations by preprocessing source files with a specified directive. It handles file paths using `Frama_c_kernel.Filepath.t` and generates intermediate files with a given suffix. This function is used to preprocess C or C++ annotation files before analysis, ensuring macros are expanded correctly for subsequent stages.",
      "description_length": 348,
      "index": 4064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Substitute_const_globals",
      "library": "frama-c.kernel",
      "description": "This module provides a CIL visitor that replaces global variables marked with the `const` attribute with their initializer values during analysis. It operates directly on CIL's abstract syntax tree, targeting global variable declarations with constant initializers. Use this visitor to optimize or simplify code by inlining constant global values at their use sites.",
      "description_length": 366,
      "index": 4065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lattice_type",
      "library": "frama-c.kernel",
      "description": "This module defines lattice structures and operations for abstract interpretation in static analysis, supporting data types such as abstract values, sets, products, and sums with capabilities for over- and under-approximation, top and bottom elements, and cardinality tracking. It provides core operations including join, meet, widening, narrowing, and difference, with specialized submodules handling set-like structures, enumeration, intersection checks, and domain combinations such as sum and product lattices. Specific functionalities include modeling program states with intervals or bitsets, tracking memory regions, analyzing relational properties, and merging heterogeneous domains for combined analyses. Submodules enhance these capabilities with domain-specific operations like project-aware membership, controlled-precision difference computation, and bounded enumeration for finite abstract domains.",
      "description_length": 912,
      "index": 4066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Boot",
      "library": "frama-c.kernel",
      "description": "This module orchestrates the Frama-C kernel's execution lifecycle, starting the main loop, configuring the environment, and defining entry points for analyses and plugins. It manages internal state and initialization, coordinating core analysis phases and custom toplevel behaviors. The child module registers unit functions to inject setup logic during startup, such as initializing analysis modules or configuring command-line options. Together, they enable launching analyses, integrating custom scripts, and extending Frama-C's behavior at key execution points.",
      "description_length": 565,
      "index": 4067,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Rangemap",
      "library": "frama-c.kernel",
      "description": "This module implements purely functional association tables over ordered keys using balanced binary trees with cached hash values, enabling efficient insertion, lookup, and traversal in logarithmic time. It supports precise and fuzzy key comparisons, range-based queries, and interval-aware operations through its submodules, which extend functionality to interval semantics, cross-map analysis, and structured value representation. Main data types include maps with polymorphic key-value pairs and enhanced operations for introspection, comparison, and transformation. Examples include managing symbol tables with range queries, performing static analysis with interval merging, and tracking abstract values with precise equality checks.",
      "description_length": 738,
      "index": 4068,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_builtin",
      "library": "frama-c.kernel",
      "description": "This module manages the registration and initialization of logic builtins within a project's environment. It provides operations to register builtins globally for all projects or locally for the current project, and initializes kernel logic builtins internally. It works directly with `builtin_logic_info` structures to define and manage logic functions and predicates available in the analysis environment.",
      "description_length": 407,
      "index": 4069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_parse_string",
      "library": "frama-c.kernel",
      "description": "This module provides functions to parse logic expressions and annotations from strings within the context of a given kernel function. It supports parsing code annotations, term l-values, terms, and predicates, with optional location and environment parameters for contextual resolution. It is used to construct and integrate formal verification elements such as preconditions, postconditions, and assertions directly from string representations in source code analysis.",
      "description_length": 469,
      "index": 4070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Filecheck",
      "library": "frama-c.kernel",
      "description": "This module validates CIL abstract syntax trees for structural integrity and detects anomalies in parsed code, supporting optional input of an AST and filename for targeted validation. It enables extensible checking through dynamically registered modules, allowing custom rules to be integrated during analysis. Key operations include loading and checking CIL files, reporting inconsistencies, and managing validation extensions. Example uses include verifying correctness after parsing, enforcing coding standards, or detecting malformed constructs in the current project or specific files.",
      "description_length": 591,
      "index": 4071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dataflow2",
      "library": "frama-c.kernel",
      "description": "This module implements data flow analyses for user-defined domains over CIL code, supporting both forward and backward propagation strategies through control flow graphs. It provides core operations to compute transfer functions, manage statement-level state transitions, and combine data across branches, working with user-defined types and CIL statements. Child modules offer statement-indexed storage for analysis states, enabling precise tracking of properties like constant values, liveness, or dependencies at program points. Specific use cases include implementing constant propagation by maintaining per-statement data, performing liveness analysis through backward flow, and computing reaching definitions using customizable traversal strategies.",
      "description_length": 755,
      "index": 4072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Win_dirs",
      "library": "frama-c.kernel",
      "description": "This module provides functions to retrieve specific directory paths used by the Frama-C kernel, such as cache, configuration, and state directories. It operates on string and `Frama_c_kernel.Filepath.t` types, resolving paths based on environment variables or default values. Concrete use cases include locating the cache directory for temporary files, determining where to read configuration files, and identifying where to store persistent state data during analysis.",
      "description_length": 469,
      "index": 4073,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Unmarshal",
      "library": "frama-c.kernel",
      "description": "This module enables type-safe deserialization of structured data (records, tuples, lists, options) and primitive values (integers, strings, floats) from input channels, with support for applying transformations during unmarshaling. It provides low-level operations to handle architecture-specific details like endianness and word size, as well as utilities for managing hash tables and custom type representations. Its primary use case involves safely reconstructing complex values from marshaled byte streams while allowing runtime type validation and data adaptation.",
      "description_length": 569,
      "index": 4074,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Channel",
      "library": "frama-c.kernel",
      "description": "This module handles low-level binary input and output operations for structured values. It provides functions to open, read from, and write to binary files, supporting direct manipulation of bytes and serialized OCaml values. Concrete use cases include reading and writing Frama-C's internal data structures to disk for persistence or inter-process communication.",
      "description_length": 363,
      "index": 4075,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Plugin",
      "library": "frama-c.kernel",
      "description": "This module orchestrates plugin registration and configuration in Frama-C, enabling the definition, retrieval, and management of plugins through structured metadata and parameter handling. It supports core data types such as `As_string.Datatype.t` for kernel function representations, `float` and `int` wrappers for numeric parameters, and polymorphic maps and sets for organizing structured data like analysis results or function identifiers. Operations include CLI integration, state persistence, value validation, and dynamic change hooks, allowing plugins to expose configurable options, manage session-specific directories, and track analysis data across projects. For example, developers can define a plugin with command-line flags for verbosity levels, store function-specific metadata in maps, or validate user-provided strings against allowed values during analysis configuration.",
      "description_length": 889,
      "index": 4076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Emitter",
      "library": "frama-c.kernel",
      "description": "This module enables the creation and management of emitters for generating annotations and tracking property statuses in Frama-C, organizing them through sets, maps, and hash tables for efficient querying and transformation. It supports custom emitter definitions with parameterized behavior, structured data association via emitter-keyed maps and tables, and ordered traversal for analysis or output tasks. Core operations include adding, finding, and removing emitter bindings with optional cleanup hooks, along with typed memoization, nearest-element queries, and project-aware data aggregation. Example uses include defining domain-specific annotation systems, caching analysis results per emitter, and emitting property statuses based on computed states across Frama-C projects.",
      "description_length": 783,
      "index": 4077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Logic_deps",
      "library": "frama-c.kernel",
      "description": "This module computes dependencies for logic terms and predicates in C code annotations, determining which program elements influence their evaluation. It processes terms, predicates, and code annotations to extract control and data dependencies, returning sets of statements and variables involved. It is used for program slicing and impact analysis based on ACSL contracts and annotations.",
      "description_length": 390,
      "index": 4078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Frama_c_kernel.Logic_ptree",
      "library": "frama-c.kernel",
      "description": "This module provides facilities for modeling and verifying program properties using logic expressions, annotations, and specifications. It operates on arithmetic and logical expressions, constants, type definitions, and structured constructs like assertions, invariants, function specifications, and module extensions organized in list-based formats. Its design supports static analysis and formal verification by enabling precise representation of code behavior and compositional specification management.",
      "description_length": 506,
      "index": 4079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Mergecil",
      "library": "frama-c.kernel",
      "description": "Merges a list of CIL files into a single CIL file, resolving conflicts and combining global declarations. Operates on CIL file structures, handling symbol tables, global variables, and function definitions. Useful for combining multiple translation units into a unified analysis target.",
      "description_length": 286,
      "index": 4080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Widen_type",
      "library": "frama-c.kernel",
      "description": "This module defines and manipulates widening hints used during the Value Analysis phase to guide the approximation of program variables. It supports operations to create, combine, and query sets of hints for numeric, floating-point, and variable-based widening, using types like `t`, `Base.t`, and `Cil_types.stmt`. Concrete use cases include specifying which variables to prioritize during widening at specific program points or applying default widening strategies across functions.",
      "description_length": 484,
      "index": 4081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.List",
      "library": "frama-c.kernel",
      "description": "This module enhances lists with monadic operations to model non-deterministic computations, integrating transformations like `map`, `fold`, and `filter` with submodules that extend options, booleans, and list combinators. Key data types include lists paired with key-value associations, sorted sequences, and optional values, supporting operations such as merging sorted data, branching on conditions, and chaining multi-result functions. Use it to represent symbolic execution paths by combining lists with `bind`, filter outcomes using `only_if`, or integrate optional logic through `map` and `iter`. Specialized submodules enable combinatorial search, conditional inclusion, and non-deterministic sequencing with product and fold operations.",
      "description_length": 744,
      "index": 4082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Destructors",
      "library": "frama-c.kernel",
      "description": "This module identifies local variables annotated with the `__fc_destructor` attribute and inserts appropriate destructor calls when exiting their scope. It supports function calls with optional integer arguments and address-of semantics, handling both scalar and array types. It is used to manage resource cleanup in C++ code during static analysis.",
      "description_length": 349,
      "index": 4083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Loop",
      "library": "frama-c.kernel",
      "description": "This module analyzes control flow loops within a function, distinguishing natural loops from non-natural ones. It provides functions to check whether a statement is part of a natural loop, retrieve all natural loops in a function, and identify non-natural loops and their back edges. Use cases include static analysis of loop structures for optimization, verification, and code transformation tasks.",
      "description_length": 399,
      "index": 4084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Inline",
      "library": "frama-c.kernel",
      "description": "This module provides functions to inline logic definitions within CIL terms and predicates during analysis. It operates on CIL types such as `term`, `predicate`, and `logic_info`, allowing selective inlining based on a user-provided predicate. It is used to simplify or expand logic expressions by replacing function or predicate calls with their definitions, particularly in contexts like value analysis or proof obligations.",
      "description_length": 426,
      "index": 4085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Visitor",
      "library": "frama-c.kernel",
      "description": "This module enables AST traversal and transformation of CIL structures and Frama-C's intermediate representation elements, supporting operations on code components like functions, expressions, annotations, and ACSL extensions. It works with data structures such as `code_annotation`, `funspec`, `term`, and `acsl_extension`, facilitating tasks like static analysis, code refactoring, and semantic preservation during C program manipulation. Specific use cases include modifying function behaviors, analyzing memory allocations, and processing extended ACSL constructs for formal verification.",
      "description_length": 592,
      "index": 4086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Current_loc",
      "library": "frama-c.kernel",
      "description": "This module tracks and manages the current source code location during analysis, offering functions to set, get, and reset location data as pairs of file positions. It supports scoped modifications through `with_loc` and `with_loc_opt`, and integrates binding operators that temporarily set the location when calling functions, simplifying contextual logging and error reporting with precise source positions. The core data type `t` supports equality, comparison, and pretty-printing, enabling robust handling of location data in static analysis, including deep copying, project membership checks, and plugin integration. Example uses include synchronizing analysis tools with specific code regions and enhancing diagnostic messages with accurate location information.",
      "description_length": 768,
      "index": 4087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Dyncall",
      "library": "frama-c.kernel",
      "description": "This module handles dynamic call analysis in C code, providing functions to retrieve and print dynamic call information. It works with C statements and kernel functions, allowing inspection of dynamic call targets at specific program points. Use cases include analyzing function pointers and virtual method calls in C programs, particularly when combined with the `-wp-dynamic` option for precise dynamic dispatch resolution.",
      "description_length": 425,
      "index": 4088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Floating_point",
      "library": "frama-c.kernel",
      "description": "This module offers operations for manipulating floating-point representations, including rounding mode control, truncation to integers, classification of values (finite/infinite/NaN), and retrieval of format-specific properties like extremal exponents or denormalized values. It operates on single- and double-precision floating-point numbers and associated format descriptors, enabling precise numerical analysis. Typical applications include verifying floating-point arithmetic correctness, handling edge cases in scientific computations, and ensuring robustness in software that relies on IEEE 754 semantics.",
      "description_length": 611,
      "index": 4089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Parray",
      "library": "frama-c.kernel",
      "description": "This module implements a persistent array structure with indexed access, supporting efficient element updates and iterations. It provides operations for initializing arrays with a function, retrieving and updating elements by index, folding over indexed elements, and mapping functions across elements. Concrete use cases include managing stateful collections in analysis passes and representing indexed data structures in program analysis tasks.",
      "description_length": 446,
      "index": 4090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Cabsvisit",
      "library": "frama-c.kernel",
      "description": "This module enables traversal and transformation of CABS (C Abstract Syntax Binary) structures by defining visitors for specific elements like types, declarations, statements, and expressions. It supports operations such as rewriting variable names, modifying type specifiers, and transforming function definitions and blocks. Concrete use cases include implementing custom code transformations, performing static analysis passes, and rewriting C source code during parsing or preprocessing stages.",
      "description_length": 498,
      "index": 4091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel.Lexerhack",
      "library": "frama-c.kernel",
      "description": "This module provides functions to manipulate lexical contexts and identifiers during parsing, specifically supporting the handling of C-like syntax. It allows adding identifiers and types, managing context stacks, and controlling typedef state. Concrete use cases include extending the parser's symbol table and managing scope transitions in language frontends.",
      "description_length": 361,
      "index": 4092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Frama_c_kernel",
      "library": "frama-c.kernel",
      "description": "This module provides a comprehensive infrastructure for static analysis of C programs, centered around abstract syntax tree manipulation, semantic modeling, and program transformation. Core data types include CIL representations of expressions, statements, types, and functions, alongside logic constructs for formal verification and analysis domains for abstract interpretation. Operations span AST traversal and rewriting, control flow analysis, dataflow propagation, type checking, memory modeling, and pretty-printing, enabling tasks such as constant propagation, liveness analysis, interval tracking, and contract verification. Specific applications include transforming C code by inlining constants, analyzing memory safety with precise offset tracking, validating ACSL annotations, and performing dataflow-driven optimizations using customizable abstract domains.",
      "description_length": 870,
      "index": 4093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality, comparison, hashing, and pretty printing. It works with the `As_string.Datatype.t` type to represent file paths and provides utilities for checking membership in projects, deep copying, and generating descriptors. Concrete use cases include managing and analyzing collections of file paths within Frama-C's scope analysis, such as tracking source files or dependencies.",
      "description_length": 482,
      "index": 4094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations within a scope analysis context. It supports checking membership of project skeletons and provides deep copying to ensure no shared references. Used to manage and manipulate string identifiers in static analysis tasks, such as tracking variable scopes or data flow.",
      "description_length": 415,
      "index": 4095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing string-based values. It supports membership testing within projects and deep copying, tailored for use in static analysis tasks like tracking string values across program scopes. The type is integrated with Frama-C's project model and structural descriptors for analysis plugins.",
      "description_length": 382,
      "index": 4096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing and manipulating string-based values in the context of scope analysis. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, along with project membership queries. It is used to handle string identifiers linked to function declarations or prototypes in static analysis tasks.",
      "description_length": 371,
      "index": 4097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing and manipulating sets of strings within a scope analysis context. It provides operations for equality checking, comparison, hashing, and pretty-printing string set values, along with deep copying and project membership testing. The type `t` is used to model string sets that can be analyzed and compared during static analysis phases.",
      "description_length": 383,
      "index": 4098,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing and manipulating values as strings within a scope analysis context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to handle string-based data representations in static analysis tasks, such as tracking variable names or expressions.",
      "description_length": 390,
      "index": 4099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations in scope analysis. It supports set-like operations and deep copying, ensuring structural integrity and uniqueness of instances. It is used to manage and manipulate string identifiers within Frama-C's kernel, particularly for tracking and comparing scoped entities in static analysis.",
      "description_length": 433,
      "index": 4100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing and manipulating string-based identifiers in the context of scope analysis. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. These operations support precise tracking and analysis of function declarations and prototypes within a codebase.",
      "description_length": 400,
      "index": 4101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating string-based values within a scope analysis context. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to handle string identifiers in static analysis tasks, such as tracking variable names or annotations across different program scopes.",
      "description_length": 438,
      "index": 4102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It supports internal scope analysis tasks by providing deep copying, membership checks over project skeletons, and type descriptors for integration with Frama-C's kernel. Concrete use cases include representing and manipulating string lists in a memory-efficient, type-safe manner during static analysis.",
      "description_length": 458,
      "index": 4103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing sets of function declarations (`Fundec`) as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks based on project context and provides deep copying to ensure no shared references. Concrete use cases include tracking and manipulating sets of functions during scope analysis, particularly for static analysis tasks in Frama-C plugins.",
      "description_length": 443,
      "index": 4104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating string-based values within a scope analysis context. It includes standard functions such as equality, comparison, hashing, and pretty printing, along with support for project membership checks and deep copying. It is used to handle string data in a structured way, particularly when integrating with analysis components that require value tracking and representation.",
      "description_length": 461,
      "index": 4105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing file paths as strings, with operations for equality, comparison, hashing, and pretty-printing. It supports internal scope analysis by enabling deep copies, membership checks over project skeletons, and type-safe handling of file path data. Use cases include tracking and comparing source file paths during static analysis and storing file-related metadata in a structured, type-checked manner.",
      "description_length": 442,
      "index": 4106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating string-based values within a scope analysis context. It provides standard utilities such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to handle string identifiers in static analysis tasks such as value tracking or property checking.",
      "description_length": 402,
      "index": 4107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.As_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for handling sets of strings in the context of scope analysis, providing standard operations such as equality, comparison, hashing, and pretty printing. It supports internal representation and manipulation of string sets with deep copying and membership testing based on project-specific conditions. Concrete use cases include tracking and analyzing string identifiers within Frama-C's scope analysis framework.",
      "description_length": 443,
      "index": 4108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing sets of strings that are filled in a specific scope analysis context. It provides operations for equality checking, comparison, hashing, and pretty-printing values of this type, as well as deep copying and project membership testing. The type is used to track and manipulate string sets within Frama-C's scope analysis framework, particularly when analyzing or transforming C code with respect to specific project configurations.",
      "description_length": 478,
      "index": 4109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks and deep copying, ensuring no shared state between original and copied values. The type is integrated with Frama-C's project management system, allowing filtering based on project properties.",
      "description_length": 368,
      "index": 4110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, providing operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`. It works with category types derived from `Frama_c_kernel.Parameter_category.t` and supports adding named categories with accessors and dependencies. Concrete use cases include configuring analysis scopes where specific parameters are grouped and controlled through these categories.",
      "description_length": 447,
      "index": 4111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Int.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype with operations for structural comparison, hashing, and pretty-printing, tailored for use in Frama-C's scope analysis. It includes functions for checking membership within projects, deep copying values, and describing the type with a unique name and descriptor. It is used to represent and manipulate abstract values in static analysis plugins, particularly for tracking dataflows and effects within C programs.",
      "description_length": 442,
      "index": 4112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Debug.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for debugging scope analysis in Frama-C. It includes descriptors for type representation, a packed version of the descriptor, and functions to manage project membership checks and deep copies. Concrete use cases include analyzing and comparing scoped data structures during static analysis, ensuring accurate type representation and project-specific value tracking.",
      "description_length": 482,
      "index": 4113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements operations for managing lists of a specific datatype within a scope analysis context. It provides functions for equality checking, comparison, hashing, and pretty-printing list elements, along with deep copying and membership testing within projects. It works with `Datatype.t` values, supporting structural analysis and representation tasks in static code analysis.",
      "description_length": 389,
      "index": 4114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for organizing parameter scopes, using the `Frama_c_kernel.Parameter_category.t` type. It supports creating named categories with dependencies, setting default and \"all\" category behaviors, and enabling global category interpretations. Use cases include configuring analysis scopes with custom named categories, dynamically modifying scope defaults, and enabling unified handling of scope inclusion or exclusion through the \"all\" category.",
      "description_length": 482,
      "index": 4115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter grouping, using string names and associated accessors to define and manipulate category behavior. It supports operations to create, enable, and modify categories like `@none`, `@default`, and `@all`, with direct control over their interpretation and activation. Concrete use cases include defining analysis scopes with specific parameter sets and controlling default or global category behavior in static analysis configurations.",
      "description_length": 474,
      "index": 4116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.True.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis within Frama-C. It includes functions for deep copying values, checking membership of project skeletons, and exposing structural descriptors for type representation. The type is used to model and manipulate abstract values in a way that supports precise and efficient static analysis tasks.",
      "description_length": 439,
      "index": 4117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based configuration parameters with validation, tracking, and serialization capabilities, while its child module introduces a specialized string type for file paths with equality, comparison, and type-safe operations. Main data types include validated strings constrained by rules and structured file path representations supporting deep copies and membership checks. Operations allow setting and retrieving values, enforcing constraints, serializing state, and analyzing file paths within project structures. Example uses include managing configuration flags with validation hooks and tracking source file paths during static analysis with structured metadata.",
      "description_length": 688,
      "index": 4118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration parameters with support for multibinding, validation, and update hooks, enabling dynamic configuration in scope analysis. It provides operations to set and retrieve values, validate against predefined lists or function names, and register listeners for reactive updates, working with map-like structures that associate keys with multiple bindings. The integrated data type supports equality, comparison, hashing, and pretty-printing, along with membership testing and deep copying for use in static analysis tasks such as tracking string values across program scopes. Together, the module and its submodules facilitate version-specific behavior, alias management, and project-scoped state in analysis plugins.",
      "description_length": 757,
      "index": 4119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for grouping and organizing file paths in scope analysis. It provides operations to define, retrieve, and modify categories such as '@none', '@default', and '@all', along with custom named categories that include dependencies and accessors. These categories are used to control how file paths are interpreted and filtered during static analysis.",
      "description_length": 376,
      "index": 4120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for a parameter system, providing operations to define, retrieve, and configure named categories with associated accessors and dependencies. It works with category types that represent different parameter interpretations, such as `@none`, `@default`, and `@all`, and supports enabling or aliasing categories dynamically. Concrete use cases include setting up configurable analysis scopes with specific parameter behaviors and dependencies in static analysis tools.",
      "description_length": 495,
      "index": 4121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "Implements a map over file paths with efficient lookups, insertions, and deletions. Operates on a concrete file path type, supporting string-based keys with filesystem path semantics. Used to track and manipulate file-specific data during static analysis, such as per-file analysis states or metadata.",
      "description_length": 301,
      "index": 4122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Custom.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty printing, tailored for use in scope analysis. It provides a structured descriptor, a list of representatives, and a deep copy function to ensure value integrity. Concrete use cases include managing and analyzing abstract values in static analysis, where unique identification and structural inspection are required.",
      "description_length": 416,
      "index": 4123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued parameters with dynamic validation, serialization, and configuration handling, operating on individual strings and string lists. It supports value constraints, function name resolution, and alias registration for command-line interfaces, enabling tasks like configuring analysis options with fallbacks and validating identifiers. The child module enhances this functionality by providing structured manipulation of string-based values, including equality checks, comparison, hashing, and pretty-printing, specifically for use in scope analysis and static analysis of function declarations. Together, they allow for robust handling of string parameters across different project scopes with customizable behavior and deep integration into analysis workflows.",
      "description_length": 790,
      "index": 4124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Enum.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for representing a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations for checking membership in projects, deep copying values, and providing type information for integration with analysis frameworks. The module is used to model enumerated types with structural equality, enabling precise scope analysis for static analysis tools.",
      "description_length": 412,
      "index": 4125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a string map for the `Datatype.t` values used in scope analysis, providing standard operations like lookup, insertion, and iteration. It supports efficient key-based access and manipulation of scope-related data, such as variable bindings or environment mappings. Concrete use cases include tracking variable definitions and resolving references within a program's scope hierarchy.",
      "description_length": 404,
      "index": 4126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages category definitions and configurations for a scope analysis system. It provides operations to create, modify, and enable categories with specific accessors and dependencies, including special categories like `@none`, `@default`, and `@all`. It is used to control how different scope parameters are interpreted and activated during analysis.",
      "description_length": 361,
      "index": 4127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for handling file paths within a scope analysis context, including equality, comparison, hashing, and pretty-printing functions. It works with a concrete data type `t` representing file paths and supports deep copying and project membership checks. Use cases include analyzing and comparing file path data in static analysis tasks, such as tracking file access or inclusion paths in C codebases.",
      "description_length": 426,
      "index": 4128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a set-like structure for managing collections of `Datatype.t` values with operations for equality, comparison, hashing, and pretty printing. It supports efficient membership checks, deep copying, and project-based filtering through the `mem_project` function. Concrete use cases include analyzing and manipulating scoped data representations in static analysis tasks, such as tracking variable occurrences or evaluating type descriptors.",
      "description_length": 457,
      "index": 4129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for a collection with multibindings, supporting operations to define, retrieve, and modify named categories, including special handling for '@none', '@default', and '@all'. It works with `Category.t` values, which represent category instances, and interacts with `Frama_c_kernel.State.t` lists and accessors. Concrete use cases include configuring analysis scopes with custom category interpretations, enabling global category behaviors, and setting default or fallback category behaviors in scope analysis.",
      "description_length": 538,
      "index": 4130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for handling string values within a scope analysis framework, providing operations for equality, comparison, hashing, and pretty-printing. It works with a concrete type `t` that represents string data, along with standard structural descriptors and project membership checks. Use cases include analyzing string variables in C code during static analysis, tracking string values across different project contexts, and ensuring deep copying and structural consistency during manipulation.",
      "description_length": 517,
      "index": 4131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based configuration parameters with dynamic value handling, supporting validation, function resolution, and change tracking for use cases like plugin configuration. It works with string and string list data, allowing runtime updates, default fallbacks, and command-line integration, while its child module extends this functionality to file path lists with equality, comparison, and project membership checks. The core datatype represents configuration values that can be validated against allowed options or resolved to functions, and the file path module builds on this to manage source files and dependencies in analysis workflows. Examples include validating user-provided parameter values, resolving symbolic function names in a scoped configuration, and tracking file dependencies with membership tests.",
      "description_length": 836,
      "index": 4132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types tied to Frama-C's state and parameter handling, including special categories like `@none`, `@default`, and `@all`. Concrete use cases include configuring analysis scopes where categories determine which parameters are included or excluded, and setting up default or global behaviors for parameter processing in static analysis.",
      "description_length": 522,
      "index": 4133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued parameters with constrained values, supporting validation, alias resolution, and state change notifications. It works with both individual strings and string lists, offering operations for comparison, hashing, and pretty-printing, while integrating with analysis tools through type descriptors and deep copying. Use it to handle command-line options, validate configurations, or manage state in plugin systems where controlled string access is critical. Its submodules extend this functionality to list-based string representations, enabling efficient manipulation and analysis of structured string data.",
      "description_length": 638,
      "index": 4134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration options with constraint enforcement, function name validation, and command-line integration, working with `string` values constrained by allowed sets. It supports validation against known function names, dynamic alias resolution, and scoped parameter tracking, using operations for constraint checking, default value handling, and project state integration. The child module enhances this functionality by providing precise manipulation of string-based identifiers, including equality, comparison, and project membership checks for function declarations and prototypes. Together, they enable robust configuration systems that validate, track, and analyze scoped string parameters across codebases.",
      "description_length": 745,
      "index": 4135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type and associated operations for representing and manipulating function mappings in the context of scope analysis. It supports equality, comparison, hashing, and pretty-printing of function data, along with deep copying and project membership checks. It is used to track and analyze function declarations and prototypes within Frama-C's kernel.",
      "description_length": 373,
      "index": 4136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration parameters with support for validation, change tracking, and scoped analysis. It provides data types for representing string-based values with operations for comparison, hashing, and pretty printing, along with utilities to register aliases, set defaults, and enforce allowed value lists. You can use it to validate kernel function names, track string identifiers in static analysis, or manage scoped configuration parameters in analysis tools. Submodules extend its capabilities with deep copying and project membership checks for analysis workflows.",
      "description_length": 599,
      "index": 4137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued command-line parameters with support for validation, aliases, and dynamic state tracking across projects. It provides mutable string parameters paired with allowed value lists, enabling conditional validation and function name resolution, while generating contextual help messages. The child module enhances this functionality by offering utilities for representing, comparing, and manipulating string-based values within a scope analysis context. Together, they support tasks like configuring scope analysis tools, enforcing parameter rules during input parsing, and tracking variable names across program scopes.",
      "description_length": 648,
      "index": 4138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and uses accessors to link categories to state interpretations. It is used to configure how parameters are grouped and interpreted in scope analysis, particularly for setting default behaviors and enabling global category rules.",
      "description_length": 469,
      "index": 4139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages category definitions and configurations for a collection of string-based identifiers, using Frama-C's parameter category system. It provides operations to create, enable, and modify categories such as `@none`, `@default`, and `@all`, with support for accessors and state dependencies. Concrete use cases include defining analysis scopes with specific inclusion/exclusion rules and configuring default behaviors for category-based filtering.",
      "description_length": 460,
      "index": 4140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.WithOutput.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for structural comparison, hashing, and pretty-printing, tailored for use in scope analysis. It supports values of type `Datatype.t` with a descriptor, packed representation, and equality checks, enabling precise data manipulation and inspection. Concrete use cases include managing and comparing abstract data representations during static analysis, such as tracking variable scopes or analyzing type structures in C code.",
      "description_length": 471,
      "index": 4141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for managing a list of file paths within a scope analysis context. It provides standard data operations such as equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to represent and manipulate collections of file paths during static analysis, particularly when tracking scope-related data across different project configurations.",
      "description_length": 425,
      "index": 4142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Empty_string.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a datatype for representing empty strings within a scope analysis context. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to model and manipulate empty string values in static analysis plugins for Frama-C.",
      "description_length": 338,
      "index": 4143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter customization in scope analysis, providing operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with the `Category.t` type, which wraps a parameter category from the Frama-C kernel, and supports adding new categories with custom accessors and dependencies. Concrete use cases include enabling all parameters under a specific interpretation, setting a default category for unresolved keys, and defining how the `@all` category behaves in positive and negative contexts.",
      "description_length": 573,
      "index": 4144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for parameter classification, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with category types and state lists, enabling fine-grained control over parameter handling in scope analysis. Concrete use cases include configuring default and special categories like `@all` and `@none`, and dynamically enabling or disabling categories based on analysis requirements.",
      "description_length": 470,
      "index": 4145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module provides a data type for string-based representations with operations for equality, comparison, hashing, and pretty-printing, tailored for scope analysis. It supports membership checks in project skeletons and deep copying to avoid shared references. Submodules extend its use to static analysis tasks like tracking variable scopes and data flow. Example uses include managing identifiers during code analysis and ensuring structural integrity when copying string-based data.",
      "description_length": 487,
      "index": 4146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Bool.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for handling boolean values within a scope analysis context, including equality, comparison, hashing, and pretty-printing. It works with the abstract data type `Datatype.t` representing boolean states, and supports deep copying and membership checks over project skeletons. Concrete use cases include tracking and comparing boolean conditions during static analysis of C code properties.",
      "description_length": 418,
      "index": 4147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for a string set within a scope analysis framework, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types that represent named sets of parameters, using strings for identifiers and state lists for dependencies. Concrete use cases include configuring analysis scopes with custom categories, setting default behaviors, and enabling global category interpretations.",
      "description_length": 472,
      "index": 4148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration options with support for validation, default values, aliases, and command-line integration, operating on a string parameter paired with an allowed value list. It provides data types and operations for equality, comparison, hashing, and pretty-printing, enabling set-like manipulations and structural integrity checks on string-based identifiers. Specific uses include tracking scoped entities in static analysis, enforcing validation through function checks or string comparisons, and bridging runtime and command-line configuration logic. Submodules enhance this functionality by supporting deep copying and unique instance management, crucial for Frama-C's kernel operations.",
      "description_length": 725,
      "index": 4149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_list.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based parameters with strict validation and dynamic resolution, enabling workflows like scope analysis and configuration management. It provides data types for representing string values with associated metadata, supporting operations such as input validation, alias resolution, list conversion, and pretty-printing. Submodules extend this functionality to static analysis tasks, adding deep copying, comparison, hashing, and project membership checks for string-based data. Example uses include validating command-line inputs against allowed values, resolving function names during analysis, and serializing runtime parameter states.",
      "description_length": 661,
      "index": 4150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Action.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for managing and manipulating a specific datatype within a scope analysis framework. It provides functionality for equality checks, comparison, hashing, pretty-printing, and deep copying of values, along with utilities to inspect and query project-related properties. The module works with `Datatype.t` values, using descriptors and representants to ensure structural consistency and efficient handling in analysis contexts.",
      "description_length": 455,
      "index": 4151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It supports deep copying and membership testing within project skeletons, ensuring values can be uniquely identified and manipulated independently. The type is used to represent and manage scoped data in static analysis tasks, particularly where multi-binding maps are required.",
      "description_length": 418,
      "index": 4152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Verbose.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It includes representants, descriptors, and project membership checks, supporting precise type and structure manipulation. Use cases include analyzing and comparing complex data structures in static analysis tasks.",
      "description_length": 363,
      "index": 4153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type and associated operations for representing and manipulating function mappings in scope analysis. It supports equality, comparison, hashing, and pretty-printing of function data, along with deep copying and project membership checks. It is used to track and analyze function declarations and prototypes within Frama-C's kernel.",
      "description_length": 358,
      "index": 4154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements a map data structure keyed by strings, supporting multiple values per key. It provides operations to add, remove, and query entries, as well as iterate over keys, values, or bindings. Use cases include tracking multiple annotations or attributes associated with variable names during static analysis.",
      "description_length": 323,
      "index": 4155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based configuration parameters with validation, alias resolution, and lifecycle control, operating on single strings and string lists. It enforces constraints like allowed values and function name validation, while supporting custom serialization behavior during static analysis. The child module enhances it with a data type for sets of function declarations as strings, enabling set operations, membership checks, and deep copying for tasks like tracking functions during scope analysis. Together, they allow precise manipulation and validation of string parameters and function sets across analysis phases.",
      "description_length": 636,
      "index": 4156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.False.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a concrete data type `t` with standard operations including equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project values, and integrates with Frama-C's type and descriptor system for structural analysis. Use cases include representing and manipulating analysis data within Frama-C plugins, particularly for scope analysis where precise type handling and value comparison are required.",
      "description_length": 466,
      "index": 4157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration parameters with validation, change tracking, and command-line integration, supporting dynamic updates through hooks and aliases. It defines a data type for handling sets of strings, enabling operations like equality, comparison, hashing, and membership testing, particularly for tracking and analyzing string identifiers in scope analysis. It ensures type safety during serialization and supports static analysis tools validating inputs against predefined value sets. Example uses include managing function name whitelists and analyzing identifier scopes in Frama-C.",
      "description_length": 614,
      "index": 4158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string parameters with constrained value sets, supporting validation, command-line configuration, and state tracking. It works with individual strings and lists of allowed values, enabling alias resolution and serialization. The core type `t` represents constrained string values, while child modules extend functionality to handle string sets with operations like comparison, hashing, and project membership testing. Examples include validating user-provided configuration flags against allowed options or safely evaluating string-represented functions within a project context.",
      "description_length": 599,
      "index": 4159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Zero.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with metadata such as a unique name and type descriptor. It supports deep copying and membership queries over project skeletons, making it suitable for static analysis tasks where precise data representation and traversal are required. The type is used to model and manipulate abstract values in the context of Frama-C's scope analysis.",
      "description_length": 450,
      "index": 4160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module manages categories for grouping and organizing elements in a kernel function map. It provides operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`, each controlling how elements are interpreted in different analysis contexts. Use cases include configuring analysis behavior based on function categories and dynamically adjusting category interpretations during scope analysis.",
      "description_length": 427,
      "index": 4161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Float.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type for representing floating-point values with optional decimal precision, tailored for scope analysis in static code analysis. It provides standard operations including equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. It is used to model and manipulate floating-point parameters in the context of Frama-C's internal analysis framework.",
      "description_length": 423,
      "index": 4162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in scope analysis. It works with a specific type `t` that represents scoped entities, supporting deep copying and membership checks over project skeletons. Concrete use cases include managing and comparing symbolic representations of program elements within Frama-C's analysis framework.",
      "description_length": 408,
      "index": 4163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.String_map.As_string",
      "library": "frama-c-scope.core",
      "description": "This module manages string-based configuration parameters with constrained value sets, supporting validation, alias handling, and customizable serialization. It works with enriched string data that includes metadata like allowed values, validation rules, and change-tracking hooks, enabling use cases such as enforcing valid function names and implementing CLI parameter parsing with strict constraints. The child module enhances this functionality by providing structured manipulation of string values within a scope analysis context, supporting operations like comparison, hashing, and project membership checks. Together, they enable synchronized configuration management and deep analysis of string data across different components.",
      "description_length": 736,
      "index": 4164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a data type `t` and associated operations for representing and manipulating kernel function sets in the context of static analysis. It provides functions for equality testing, comparison, hashing, pretty-printing, and deep copying, as well as support for checking membership based on project projections. The type works with Frama-C's internal project and datatype structures, enabling precise handling of function sets in analysis plugins.",
      "description_length": 460,
      "index": 4165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_map.Category",
      "library": "frama-c-scope.core",
      "description": "This module defines and manages categories for a scope analysis framework, using a map structure that disallows multibindings. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, with support for setting accessors and dependencies. Concrete use cases include configuring analysis scopes with named categories and controlling default and global behaviors in static analysis settings.",
      "description_length": 434,
      "index": 4166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module defines a set of fundec-related operations for managing and comparing scoped data types, including equality, comparison, hashing, and pretty-printing. It works with `Datatype.t` values, supporting deep copies and membership checks over project skeletons. Concrete use cases include tracking function declarations within a scope and ensuring consistent representation across analyses.",
      "description_length": 395,
      "index": 4167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list.Datatype",
      "library": "frama-c-scope.core",
      "description": "This module implements operations for a list of strings as a scoped data type, supporting equality, comparison, hashing, and pretty-printing. It provides deep copying, membership checking within projects, and maintains representants and descriptors for type handling. Concrete use cases include managing string lists in static analysis contexts where project-specific values must be tracked and compared.",
      "description_length": 404,
      "index": 4168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath",
      "library": "frama-c-scope.core",
      "description": "This module manages file path state with support for dynamic updates, validation, and persistence, working with typed file path values to enable precise configuration and analysis. It provides operations for setting and monitoring file paths, checking emptiness, and integrating with command-line interfaces through visibility and alias controls. The child module enhances this functionality by defining core operations on concrete file path values, including comparison, hashing, pretty-printing, and project membership checks, making it suitable for static analysis tasks like tracking file inclusions in C code. Together, they support use cases such as configuring analysis tools, comparing file paths during scope analysis, and maintaining file path state across different project contexts.",
      "description_length": 794,
      "index": 4169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Int",
      "library": "frama-c-scope.core",
      "description": "This module provides a structured way to manage integer-based configuration options with support for scoped parameters, change tracking, and range constraints. It allows setting values with defaults, defining valid numeric bounds, registering update callbacks, and persisting state, while integrating command-line aliases for external configuration. The child module enhances this functionality by introducing a data type with comparison, hashing, and pretty-printing operations, enabling precise manipulation of abstract values in static analysis. Together, they support tasks like tracking dataflows and effects in C programs, with seamless integration between user-facing settings and internal analysis logic.",
      "description_length": 712,
      "index": 4170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Action",
      "library": "frama-c-scope.core",
      "description": "This module manages boolean parameters with dynamic state tracking, supporting operations to set values, register update hooks, and control command-line visibility. It centers on a boolean type `t` that encapsulates project-specific state, default values, and metadata for integration with Frama-C's configuration system. The child module extends this functionality by providing utilities for equality checks, comparison, hashing, and pretty-printing of `Datatype.t` values, ensuring structural consistency during analysis. Together, they enable use cases such as handling interactive CLI options, persisting parameter states, and synchronizing values with kernel-level settings in static analysis workflows.",
      "description_length": 708,
      "index": 4171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filled_string_set",
      "library": "frama-c-scope.core",
      "description": "This module manages configurable sets of strings with dynamic updates, pre/post-change hooks, command-line aliases, and custom marshaling, built around a mutable string set type integrated with Frama-C's state and project system. It supports standard set operations like membership checks, iteration, and predicate-based queries, while enabling side-effect handling during updates, making it suitable for project-specific configuration tracking and interactive command-line interfaces. The module's core type tracks string sets in scope analysis contexts, with support for category-based filtering through configurable parameter categories like `@none`, `@default`, and `@all`. It also includes validated string configuration parameters with change tracking and command-line integration, useful for managing function name whitelists and analyzing identifier scopes with type-safe serialization and validation.",
      "description_length": 909,
      "index": 4172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.State_dir",
      "library": "frama-c-scope.core",
      "description": "This module manages the state directory for a plugin, providing functions to retrieve, set, and check the existence of a specific directory path. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional directory creation during access. Concrete use cases include initializing plugin-specific storage locations and ensuring consistent access to runtime state directories.",
      "description_length": 401,
      "index": 4173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.True",
      "library": "frama-c-scope.core",
      "description": "This module manages a boolean parameter state with lifecycle controls, offering operations to set, retrieve, and observe value changes through hooks while supporting persistence, marshaling, and visibility settings. It works with global boolean state associated with Frama-C kernel parameters, integrating with project state management and command-line interface features. Specific use cases include enabling or disabling analysis options via `on` and `off` functions, configuring parameter behavior with aliases or scoped visibility, and synchronizing state changes with external systems using hook callbacks. The child module enhances this functionality by providing a concrete data type with equality, comparison, and pretty-printing operations, enabling precise modeling and manipulation of abstract values in static analysis workflows.",
      "description_length": 840,
      "index": 4174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a mutable key-value map with unique bindings, enabling insertion, retrieval, and iteration while supporting state tracking through hooks. It integrates key and value operations from its submodules, which provide structured representations for scope analysis, including scoped entities and categorical groupings. The map supports use cases like tracking identifiers during code analysis, managing symbolic program elements, and configuring analysis scopes with named categories such as `@default` or `@all`. Together, the module and its children enable precise, structured handling of mappings in static analysis and project state management.",
      "description_length": 661,
      "index": 4175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Cache_dir",
      "library": "frama-c-scope.core",
      "description": "This module manages a cache directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of cached data. Use cases include storing temporary analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 371,
      "index": 4176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_set",
      "library": "frama-c-scope.core",
      "description": "This module implements a stateful set abstraction for tracking collections of elements with metadata, supporting operations like membership checks, iteration, and folding, while integrating callbacks, serialization, and project-specific state computation. It manages element visibility and deprecation, enabling auditable mutations useful in configuration and dataset tracking, and works with structured categories to classify parameters under scopes like `@default` or `@all`. The module handles `Datatype.t` collections with efficient equality and comparison operations, supporting deep copies and project-based filtering via `mem_project`, ideal for static analysis tasks like variable tracking. It also manages string-based configuration options with validation, aliases, and command-line integration, ensuring structural integrity and enabling set-like manipulations for scoped identifiers in kernel operations.",
      "description_length": 916,
      "index": 4177,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Zero",
      "library": "frama-c-scope.core",
      "description": "This module manages integer configuration options with change tracking, scoped parameters, and bounded ranges, supporting stateful interactions through defaults, CLI sync, and project-specific state. It defines a core data type `t` with equality, comparison, hashing, and pretty-printing, along with unique naming and type descriptors for static analysis. Operations allow deep copying, membership queries over project skeletons, and incremental adjustments with range validation. Examples include configuring analysis settings dynamically and maintaining observable integer state across scopes with enforced constraints.",
      "description_length": 621,
      "index": 4178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Value_string",
      "library": "frama-c-scope.core",
      "description": "This module implements a string-based data type with operations for equality, comparison, hashing, and pretty-printing. It supports conversions to and from standard strings, along with deep copying and membership checks over project skeletons. Typical uses include representing and manipulating string values within a scope analysis framework, ensuring consistent handling across different analysis phases.",
      "description_length": 406,
      "index": 4179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Empty_string",
      "library": "frama-c-scope.core",
      "description": "This module manages mutable string values integrated into a global parameter state system, enabling operations like setting, retrieving, validating, and serializing strings. It supports use cases such as command-line configuration and function name validation, while its child module defines a data type for representing empty strings in scope analysis, offering equality, comparison, deep copying, and project membership checks. Together, they enable precise manipulation and analysis of string data within Frama-C plugins, particularly for tracking and validating empty string values in static analysis contexts.",
      "description_length": 614,
      "index": 4180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_user_dir",
      "library": "frama-c-scope.core",
      "description": "Implements directory and file path resolution within a scoped environment. Works with `Frama_c_kernel.Filepath.t` to manage hierarchical paths, supporting creation of intermediate directories when needed. Useful for organizing analysis outputs or resource files under a structured directory tree.",
      "description_length": 296,
      "index": 4181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_list",
      "library": "frama-c-scope.core",
      "description": "This module manages a mutable collection of file paths with atomic updates, supporting prepend/append semantics and state tracking for scope analysis tasks such as project configuration and dependency resolution. It works with `Filepath.t` elements and lists, offering iteration, transformation, and command-line integration, while its child modules extend functionality through categorized path grouping, dynamic configuration handling, and scoped file list operations. The categories module organizes paths under named scopes like '@default' and custom groups for filtering, the configuration module supports validated string parameters and file path extensions with equality and membership checks, and the scoped list module provides standard data operations for file path lists in analysis workflows. Examples include customizing path lists via CLI flags, validating plugin parameters against allowed values, and tracking file dependencies with scoped membership tests.",
      "description_length": 973,
      "index": 4182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_set",
      "library": "frama-c-scope.core",
      "description": "This module provides a dynamic, project-aware representation of string sets with support for efficient membership checks, functional iteration, and deep copying. It integrates reactive update hooks for tracking modifications and enables alias resolution and state persistence across projects. The core type allows filtering by project properties, while child modules extend functionality with categorized scope definitions, configurable string parameters, and validation mechanisms. Use cases include managing analysis scopes with custom categories, enforcing allowed configuration values, and tracking historical transitions of string set contents.",
      "description_length": 649,
      "index": 4183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_list",
      "library": "frama-c-scope.core",
      "description": "This module manages mutable lists of strings with dynamic updates, supporting element addition, list appending, and change tracking through hooks. It maintains global state, handles default values and aliases, and offers customizable serialization, making it ideal for configuration systems and CLI integration. Child modules extend this functionality with parameter validation, category classification, and scoped string list operations, enabling structured manipulation and analysis of string data in project-specific contexts. Examples include tracking command-line options, defining parameter groups for analysis, and managing persistent string lists across different scopes.",
      "description_length": 679,
      "index": 4184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_set",
      "library": "frama-c-scope.core",
      "description": "This module manages collections of kernel functions with operations for set manipulation, configuration, and classification, integrating change tracking and project-aware state management. It supports key data types like sets of function identifiers, categorized parameters, and string-valued options with validation, enabling tasks such as command-line configuration parsing, deprecation handling, and scoped analysis setup. You can use it to define function sets with custom equality, classify parameters under named categories, and manage validated string identifiers with scoped defaults and aliases. Submodules enhance these capabilities with deep copying, project membership checks, and dynamic category control for advanced static analysis workflows.",
      "description_length": 757,
      "index": 4185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Make_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a multibinding map where each key maps to a list of values, supporting operations to add, retrieve, and update entries with change notifications, alias management, custom marshaling, and metadata handling. It works with key and value modules to enable structured state tracking and configuration systems that require multiple values per key, such as scope analysis or project-scoped state management. The child modules extend this functionality with string-valued configuration parameters, category management for collections, and scoped data types supporting equality, comparison, and deep copying. These components together allow dynamic configuration with validation, category-based analysis scoping, and version-specific behavior in static analysis tasks.",
      "description_length": 779,
      "index": 4186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Bool",
      "library": "frama-c-scope.core",
      "description": "This module manages boolean configuration options with metadata and kernel integration, supporting operations like toggling, serialization, and aliasing. It handles state changes and persistence in kernel modules, while its child module provides analysis-specific functionality for comparing, copying, and printing boolean values during static analysis. Main data types include `Datatype.t` for abstract boolean states and structures for scoped analysis and project-wide tracking. Examples include dynamically updating boolean settings in Frama-C plugins and analyzing C code conditions across project skeletons.",
      "description_length": 612,
      "index": 4187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a map of string keys to multiple values, supporting operations to add, query, and manipulate entries, along with aliasing and custom serialization. It integrates with state systems through update hooks and computed state tracking, enabling synchronization across projects and scope analysis tasks. The first child module organizes parameters into configurable categories with dynamic dependencies, supporting annotations like `@none` and `@all`. The second child module handles command-line string parameters with validation, aliases, and cross-project state, while the third provides core multi-value map operations for tracking attributes such as variable annotations in static analysis.",
      "description_length": 709,
      "index": 4188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Verbose",
      "library": "frama-c-scope.core",
      "description": "This module manages integer parameters with dynamic tracking, range constraints, and lifecycle hooks, while integrating with metadata like bounds and persistent state. It supports runtime validation, interactive adjustments in REPLs, and synchronization across distributed systems through serialization. The core data type enables precise equality, comparison, and pretty-printing, facilitating scope analysis and structure manipulation in static analysis tasks. Together, the module and its submodule allow configuring, analyzing, and comparing numeric parameters within analysis frameworks.",
      "description_length": 592,
      "index": 4189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_user_dir_opt",
      "library": "frama-c-scope.core",
      "description": "This module constructs and manages a user directory option from an existing user directory configuration. It provides operations to retrieve or set a directory path, check if a directory is configured, and access associated files or subdirectories, all centered around the `Frama_c_kernel.Filepath.t` type. It is used to handle scoped directory options with configurable names and help messages, typically for plugin-specific storage or configuration paths.",
      "description_length": 457,
      "index": 4190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Float",
      "library": "frama-c-scope.core",
      "description": "This module handles floating-point parameters with optional decimal precision, managing numeric ranges, value change hooks, and custom serialization through a `Datatype.t` structure. It supports command-line integration with dynamic updates, help generation, and alias-based parsing, while its child module enhances static analysis with equality, comparison, and project membership operations. You can define bounded float values, track modifications with callbacks, and serialize configurations for external tools. Specific use cases include configuring analysis parameters in Frama-C and modeling floats during static code analysis.",
      "description_length": 634,
      "index": 4191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String",
      "library": "frama-c-scope.core",
      "description": "This module manages string-valued configuration options with dynamic updates, default values, and command-line integration, primarily for scope analysis parameters. It supports named string options with aliasing, validation, and state persistence, while its child module provides structural operations like comparison, hashing, and pretty-printing for string values in a static analysis context. You can define configurable analysis settings, validate function names and arguments, track string variables across project contexts, and ensure structural consistency during manipulation.",
      "description_length": 584,
      "index": 4192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_list",
      "library": "frama-c-scope.core",
      "description": "This module manages mutable lists of structured values with scoped state tracking, supporting dynamic modification, comparison, and serialization with hooks for observing changes. It works with `E.t` elements and integrates alias management with visibility controls, while submodules handle datatype-specific operations, category-based scope organization, and validated string parameters. You can use it to maintain project-specific lists with observable updates, define interdependent analysis scopes with custom categories, and manage string-based configurations with strict validation and alias resolution. Additional utilities for pretty-printing, hashing, and deep copying ensure compatibility with static analysis and persistent state workflows.",
      "description_length": 751,
      "index": 4193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Fundec_set",
      "library": "frama-c-scope.core",
      "description": "This module manages collections of CIL function declarations with set-like operations, supporting membership checks, iteration, and state integration for tracking function definitions during analysis. It combines with submodules to handle parameter categories, string configurations, and scoped fundec comparisons, enabling use cases like scope-based analysis and function set synchronization. The core provides fundec sets with efficient manipulation, while child modules extend functionality with category-based parameter control, validated string parameters, and scoped data operations. Specific capabilities include tracking function declarations across project skeletons, configuring analysis scopes with category filters, and validating function names in string-based parameters.",
      "description_length": 785,
      "index": 4194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Filepath_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a stateful mapping of file paths to values, combining core map operations like `find`, `add`, and `fold` with advanced features such as key aliases, category-based grouping, and custom serialization. It supports scoped state management with defaults and computed values, along with command-line integration for option parsing, enabling structured access to project configurations and file-specific metadata. The module organizes entries into logical categories for parameter grouping, enforces constraints on string and file path values, and provides efficient lookups and mutations over file paths with filesystem-aware semantics. Example uses include tracking analysis states per file, managing validated configuration parameters, and structuring access to serialized project data with custom formatting.",
      "description_length": 826,
      "index": 4195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.WithOutput",
      "library": "frama-c-scope.core",
      "description": "This module manages boolean state parameters with update hooks, default values, and command-line visibility, supporting marshaling, equality checks, and alias management for configuration persistence. It also provides controlled output functionality through state-dependent enable/disable switches and conditional output functions that dynamically determine emission behavior based on project lifecycle events. A child module defines a data type with structural comparison, hashing, and pretty-printing tailored for scope analysis, supporting values with descriptors and packed representations for precise data inspection. Together, they enable use cases like CLI tool configuration tracking, plugin output control, and static analysis of variable scopes or type structures in C code.",
      "description_length": 784,
      "index": 4196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Config_dir",
      "library": "frama-c-scope.core",
      "description": "This module handles operations related to a plugin's configuration directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include managing user-specific configuration storage, such as reading from or writing to plugin-specific files without relying on external setup.",
      "description_length": 419,
      "index": 4197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.String_map",
      "library": "frama-c-scope.core",
      "description": "This module implements a state-aware string map for managing hierarchical configuration data with typed values, supporting atomic updates, change tracking, and project-scoped persistence. It provides core operations for key-based access, value manipulation, and category-based organization, using `Frama_c_kernel.Datatype.String.Map` with values of type `V.t` that support custom marshaling and equality checks. The module integrates scope analysis functionality through a dedicated string map for `Datatype.t` values, enabling efficient tracking and resolution of variable bindings, while category management allows configuration of scope parameters with special accessors and dependencies. It also supports constrained string parameters with validation and serialization, enabling use cases like enforcing valid function names and synchronizing configuration state across analysis phases.",
      "description_length": 890,
      "index": 4198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Make_site_dir",
      "library": "frama-c-scope.core",
      "description": "This module provides functions to retrieve specific directories or files within a site structure. It works with string identifiers and file paths via the `Frama_c_kernel.Filepath.t` type. Concrete use cases include locating predefined directories or files in a project's scope analysis, ensuring correct path resolution or failing explicitly when paths are invalid.",
      "description_length": 365,
      "index": 4199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.False",
      "library": "frama-c-scope.core",
      "description": "This module manages boolean parameters with operations to set, retrieve, and track changes to values, supporting configuration and state management in static analysis workflows. It integrates with a child module defining a concrete type `t` that offers equality, comparison, hashing, and pretty-printing, along with deep copying and project membership testing. Together, they enable precise handling of boolean configurations through both direct API calls and structured data manipulation, such as synchronizing CLI inputs with internal state or tracking analysis phases across Frama-C plugins.",
      "description_length": 594,
      "index": 4200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Session",
      "library": "frama-c-scope.core",
      "description": "This module manages file paths for a session directory in a plug-in, providing operations to retrieve, set, and check the existence of a user directory. It works with string identifiers and `Frama_c_kernel.Filepath.t` paths, supporting creation flags for directories and files. Concrete use cases include initializing session-specific storage locations and ensuring consistent access to plug-in data directories during analysis.",
      "description_length": 428,
      "index": 4201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_multiple_map",
      "library": "frama-c-scope.core",
      "description": "This module manages a map associating kernel functions with lists of values, supporting operations to set, retrieve, and modify entries while integrating change tracking and state management. It works with `kernel_function` keys and `V.t` lists, enabling static analysis tasks like tracking function-specific data across program states or handling prototypes in scope analysis. The first child module enhances string parameter handling with dynamic validation and configuration, supporting constraints and command-line integration for analysis options. The second child module provides function mapping data types with equality, comparison, and pretty-printing, while the third manages parameter categories to control interpretation and defaults in scope analysis.",
      "description_length": 764,
      "index": 4202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Enum",
      "library": "frama-c-scope.core",
      "description": "This module manages scoped enumeration types with stateful operations, supporting get/set functionality, change tracking, and serialization for finite variant types. It provides `all_values`, `to_string`, and structural equality checks, enabling configuration management, CLI integration, and persistent state marshaling. Child modules enhance these enums with comparison, hashing, and pretty-printing, while supporting membership checks, deep copying, and type information for static analysis. Use cases include kernel extensions, project-specific settings, and analysis tools like Frama-C.",
      "description_length": 591,
      "index": 4203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Custom",
      "library": "frama-c-scope.core",
      "description": "This module enables parameter management for custom types, supporting operations like value setting, retrieval, comparison, and validation with state tracking, default values, and serialization. It integrates with the `V` module for algebraic data type handling, supports string lists and typed parameter structures, and enforces constraints such as allowed values and visibility. Use it to manage project-specific configurations, handle command-line arguments, or maintain persistent state with support for deprecation-aware aliases. The child module enhances this functionality by providing equality, comparison, and pretty printing operations for custom data types, facilitating static analysis tasks like abstract value management with structural inspection and unique identification.",
      "description_length": 788,
      "index": 4204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Value_int",
      "library": "frama-c-scope.core",
      "description": "This module defines operations for handling integer values within a scope analysis framework, including equality, comparison, hashing, and pretty-printing. It supports conversions to and from strings, deep copying, and checks for the presence of project-related data. These functions are used to manage and manipulate integer values in the context of static analysis, particularly for tracking and comparing values across different scopes.",
      "description_length": 439,
      "index": 4205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Share",
      "library": "frama-c-scope.core",
      "description": "This module manages the resolution of directories and files within a specific plugin directory structure. It provides functions to set and retrieve the base directory, check its initialization status, and resolve paths to specific files or directories within the structure. It is used to locate plugin resources such as configuration or data files without ambiguity.",
      "description_length": 366,
      "index": 4206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R.Kernel_function_map",
      "library": "frama-c-scope.core",
      "description": "This module tracks and reacts to changes in maps where kernel functions or prototypes are keys, supporting pre/post-update hooks, validity checks, and structured key-value collections with serialization, aliasing, and visibility controls. It works with string-valued configurations constrained by allowed sets, function mappings with equality and hashing, and categories for grouping elements, enabling dynamic state management for scope analysis. You can validate function names, track scoped parameters, define category-based analysis rules, and manage versioned symbol resolution in language pipelines. The combination of direct hooks and submodules for identifiers, function data, and categories supports incremental computation tracking and configurable analysis workflows.",
      "description_length": 778,
      "index": 4207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope.Datascope.R.Debug",
      "library": "frama-c-scope.core",
      "description": "This module manages stateful integer parameters with range constraints and change hooks, enabling dynamic behavior tracking and runtime validation. It supports metadata-rich integer states with help text and serialization directives, allowing operations like value manipulation, comparison, and pretty-printing through its core data type `t`. The child module enhances this functionality with type descriptors and project-specific analysis tools, facilitating scoped data comparison and deep copy operations. Together, they enable precise debugging and static analysis workflows, such as tracking numeric state changes across different project contexts and validating type representations during analysis.",
      "description_length": 705,
      "index": 4208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope.R",
      "library": "frama-c-scope.core",
      "description": "This module provides logging, diagnostic, and warning management capabilities tailored for scope analysis in Frama-C's Datascope plugin, with severity-level logging, category-based filtering, and warning configuration. It operates on structured log events, source positions, and typed configuration parameters such as strings, paths, and sets, enabling diagnostic output control, deprecation handling, and command-line interface integration. Submodules extend functionality to manage file paths, integers, booleans, string sets, and mappings with operations like comparison, hashing, and pretty-printing, supporting tasks such as tracking file inclusions, configuring analysis settings, and managing function declarations. Examples include enabling or disabling analysis options via boolean parameters, validating function names against string sets, and tracking file paths across different project contexts with scoped membership checks.",
      "description_length": 938,
      "index": 4209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Defs",
      "library": "frama-c-scope.core",
      "description": "This module provides functions to analyze variable definitions within a function's scope, specifically retrieving statements that define a given lvalue before a specified point in the code. It works with control flow statements, lvalues, and location zones, returning sets or maps of definition points along with possibly undefined zones. It is used to track direct and indirect modifications of variables for precise static analysis tasks such as dependency tracking or uninitialized variable detection.",
      "description_length": 504,
      "index": 4210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Datascope",
      "library": "frama-c-scope.core",
      "description": "This module analyzes data and property scopes in C code to determine statement sets where variables or annotations retain their values, supporting optimization and verification tasks such as removing redundant assertions or tracking value propagation through forward, backward, and bidirectional dependencies. It provides logging, diagnostic, and warning management capabilities tailored for scope analysis, with severity-level logging, category-based filtering, and warning configuration, operating on structured log events, source positions, and typed configuration parameters like strings, paths, and sets. Submodules extend functionality to manage file paths, integers, booleans, string sets, and mappings with operations including comparison, hashing, and pretty-printing, enabling tasks such as tracking file inclusions, validating function names, and configuring analysis settings across project contexts. Examples include enabling analysis options via boolean flags, validating function names against predefined sets, and managing file path inclusions with scoped membership checks.",
      "description_length": 1090,
      "index": 4211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope.Zones",
      "library": "frama-c-scope.core",
      "description": "Implements zone-based scope analysis for statements and lvals in CIL code. Builds and manages mappings from statements to location zones, enabling precise tracking of variable lifetimes and memory regions. Useful for static analysis passes requiring per-statement scope information, such as alias analysis or memory safety checks.",
      "description_length": 330,
      "index": 4212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope",
      "library": "frama-c-scope.core",
      "description": "This module performs scope analysis for variables and properties in C code, tracking definitions, usage, and value propagation across control flow. It provides data types such as statements, lvalues, location zones, and structured logs, with operations to retrieve definition points, analyze data dependencies, and configure analysis settings. You can use it to detect uninitialized variables, remove redundant assertions, validate function names, and manage file inclusions based on scope. It supports advanced static analysis tasks like alias detection, memory safety, and value tracking through forward and backward dependencies.",
      "description_length": 632,
      "index": 4213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing_gui.Register_gui",
      "library": "frama-c-slicing.gui",
      "description": "Implements GUI components and event handlers for visualizing program slicing within an interactive interface. Works with abstract syntax trees and slicing metadata to render dynamic views of code dependencies. Enables users to explore data and control flow relationships during program analysis sessions.",
      "description_length": 304,
      "index": 4214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing_gui",
      "library": "frama-c-slicing.gui",
      "description": "This module provides interactive visualizations for program slicing, rendering dynamic views of abstract syntax trees and slicing metadata. It supports exploration of data and control flow dependencies through event-driven GUI components. Users can navigate code relationships in real-time, highlighting sliced regions and tracing variable influences across program structures. Key operations include loading slicing data, selecting code elements, and updating views in response to user interactions.",
      "description_length": 500,
      "index": 4215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map.Key",
      "library": "Pdg_types",
      "description": "This module defines the key type used in maps with `NodeSet` values, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working directly with map keys through deep copying, membership checks over project skeletons, and type-level introspection via `ty`, `descr`, and `packed_descr`. Concrete use cases include managing and querying PDG node sets keyed by structured identifiers in analysis plugins.",
      "description_length": 446,
      "index": 4216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl.Make",
      "library": "Pdg_types",
      "description": "This module implements a hash table where keys are nodes from a program dependence graph (PDG) and values are of a specified data type. It provides standard operations for equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checking. It is used to manage and manipulate node-indexed data in static analysis plugins for Frama-C.",
      "description_length": 374,
      "index": 4217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl.Key",
      "library": "Pdg_types",
      "description": "This module defines a hash table key type for PDG nodes, providing equality, comparison, and hashing operations required for efficient storage and retrieval. It works with the `Pdg_types.PdgTypes.Node.Hashtbl.key` type, which represents nodes in a program dependence graph (PDG) and includes project-specific information. Concrete use cases include tracking dependencies between PDG nodes across different project contexts and enabling efficient lookups in PDG-based analyses.",
      "description_length": 476,
      "index": 4218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map.Key",
      "library": "Pdg_types",
      "description": "This module defines a key type for maps that uniquely identifies nodes in a program dependency graph (PDG). It provides standard operations like equality, comparison, hashing, and pretty-printing for these keys, ensuring they can be used efficiently in map structures. The keys encapsulate node-specific data such as project information and support deep copying and project membership checks.",
      "description_length": 392,
      "index": 4219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map.Make",
      "library": "Pdg_types",
      "description": "This module implements a map keyed by PDG nodes, where each node maps to a value of a specified data type. It provides standard map operations such as comparison, equality, hashing, and pretty printing, along with deep copying and project-aware membership checks. It is used to associate structured data with specific nodes in a program dependency graph for analysis and transformation tasks.",
      "description_length": 392,
      "index": 4220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map.Make",
      "library": "Pdg_types",
      "description": "This module implements a map indexed by `NodeSet` keys, where each map value is of type `Data.t`. It provides standard operations including comparison, equality, hashing, pretty-printing, and deep copying, along with project-aware membership checks. It is used to associate structured data with sets of nodes in a PDG, enabling precise analysis and transformation tasks such as slicing or dependency tracking.",
      "description_length": 409,
      "index": 4221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl.Key",
      "library": "Pdg_types",
      "description": "This module defines the key type used in a hash table for storing and retrieving node sets within a program dependency graph (PDG). It provides standard operations including equality checks, comparison, hashing, and pretty printing for these keys, which are essential for managing node set identities efficiently. The module also supports deep copying and project membership checks, enabling precise manipulation and querying of PDG data during analysis.",
      "description_length": 454,
      "index": 4222,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl.Make",
      "library": "Pdg_types",
      "description": "This module implements a hash table specialized for PDG nodes, where keys are nodes and values are of a specified `Data` type. It provides standard operations like equality, comparison, hashing, and pretty-printing, along with project-aware membership checks and deep copying. It is used to associate and manipulate node-indexed data in analyses building on the PDG structure.",
      "description_length": 376,
      "index": 4223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Pdg.Printer",
      "library": "Pdg_types",
      "description": "This module provides functions to generate Graphviz DOT attributes for visualizing program dependence graphs. It defines how nodes and edges are represented in the graph, including labels, colors, and shapes, based on the underlying PDG structure. It is used to customize the appearance of PDG nodes and edges when generating visualizations for analysis or debugging.",
      "description_length": 367,
      "index": 4224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.LocInfo.LOffset",
      "library": "Pdg_types",
      "description": "The module provides operations for managing location-based offset data in program dependency graphs, including lattice operations like join and inclusion checks, alongside interval arithmetic for tracking memory offsets. It works with a core type `t` representing offset information and interval-mapped structures for associating ranges with values, supporting cache-aware folding and binding. These tools are used in static analysis to model memory layout dependencies and optimize dataflow computations.",
      "description_length": 505,
      "index": 4225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Hashtbl",
      "library": "Pdg_types",
      "description": "This module implements a mutable hash table optimized for static analysis tasks, mapping program dependency graph (PDG) node sets to arbitrary values with efficient imperative operations for insertion, deletion, and lookup. It supports ordered iteration, bulk transformations, and memoization, while its child modules define key types and operations for PDG nodes and node sets, including equality, comparison, hashing, and pretty-printing. Specific use cases include tracking semantic relationships between code elements and managing node-indexed data with deep copying and project membership checks. Together, the module and its submodules enable precise and scalable PDG analysis within Frama-C plugins.",
      "description_length": 706,
      "index": 4226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Map",
      "library": "Pdg_types",
      "description": "This module manages maps keyed by sets of PDG nodes, supporting efficient insertion, traversal, and transformation with operations like merge, filter, and split. It enables functional updates and ordered queries over node groups, facilitating analysis tasks such as dependency tracking and slicing. The key module provides structured identifiers with comparison, hashing, and pretty-printing, while the data module associates these keys with structured values for deep copying, project-aware checks, and custom formatting. Together, they allow precise manipulation of hierarchical program dependencies, such as aggregating data across node subsets or maintaining ordered representations of control flow.",
      "description_length": 703,
      "index": 4227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Map",
      "library": "Pdg_types",
      "description": "This module manages ordered maps keyed by program dependency graph nodes, supporting polymorphic values and operations for creation, insertion, deletion, and ordered traversal. It combines node-specific key handling with map utilities for analysis tasks like dependency tracking and data aggregation, offering exception-safe lookups and custom output formatting. The key module provides equality, comparison, and pretty-printing for PDG nodes, while the value module associates structured data with nodes for analysis and transformation. Examples include tracking variable dependencies during compilation or aggregating metadata across project nodes.",
      "description_length": 650,
      "index": 4228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet.Set",
      "library": "Pdg_types",
      "description": "This module supports manipulation of sets of PDG nodes through standard operations like union, intersection, and difference, along with transformations such as mapping, filtering, and folding. It works with ordered sets of `NodeSet.t` elements, enabling efficient membership checks, subset comparisons, and traversal optimizations. Key use cases include PDG construction, dependency analysis, and static analysis tasks requiring precise control-flow or data-flow set manipulations.",
      "description_length": 481,
      "index": 4229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node.Hashtbl",
      "library": "Pdg_types",
      "description": "This module provides hash tables that map PDG nodes to arbitrary values, supporting imperative and functional operations such as insertion, lookup, ordered iteration, and folding with customizable key comparisons. It includes utilities for safe value retrieval, memoization, and conversions to and from sequences, along with statistical analysis and in-place filtering. The key module defines equality, comparison, and hashing for PDG nodes, enabling efficient storage and retrieval in project-specific contexts, while the data-specific submodule offers typed hash tables with deep copying, pretty-printing, and project-aware operations. Examples include caching analysis results per node, tracking inter-procedural dependencies, and performing deterministic traversals of program dependency graphs.",
      "description_length": 799,
      "index": 4230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.G.E",
      "library": "Pdg_types",
      "description": "This module defines edge types and operations for the program dependence graph (PDG). It provides accessors to retrieve the source and destination nodes of an edge, along with its label. These functions are used during PDG construction and traversal to analyze dependencies between computations in a function.",
      "description_length": 309,
      "index": 4231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSetLattice.O",
      "library": "Pdg_types",
      "description": "This module provides a lattice-based set abstraction for managing collections of PDG nodes with operations like membership testing, union, intersection, and project-specific membership checks. It supports element selection, list conversion, and structural comparisons while enabling efficient iteration and deep copying for analysis workflows. The structure is particularly useful in dataflow analysis scenarios requiring fixed-point computations over node sets, such as tracking dependencies or propagating constraints across program paths.",
      "description_length": 541,
      "index": 4232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgMarks.F_Fct",
      "library": "Pdg_types",
      "description": "This module implements mark propagation for function-level dependencies in a program dependence graph (PDG). It provides operations to create and manipulate marked PDG structures using a customizable mark type, along with functions to select, propagate, and track marks across function calls. Concrete use cases include tracking dataflow information such as taint or constant values through function boundaries in static analysis.",
      "description_length": 430,
      "index": 4233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex.Key",
      "library": "Pdg_types",
      "description": "This module supports creating and manipulating keys to uniquely identify elements within functions, such as parameters, statements, call sites, labels, and control-flow components. It operates on structured data like `stmt` (statements), function call contexts, and signature elements (inputs/outputs), enabling precise indexing in program analysis tasks. These keys are essential for mapping function elements to nodes in a Program Dependence Graph (PDG), tracking call-site relationships, and managing data-flow information across control-flow paths.",
      "description_length": 552,
      "index": 4234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgMarks.Fct",
      "library": "Pdg_types",
      "description": "This module implements operations to associate and propagate marks across PDG elements based on function call dependencies. It provides functions to create and manipulate marked PDG structures, select and update marks using propagation rules, and retrieve indexed call information. Concrete use cases include tracking data flow dependencies and annotating function calls with analysis metadata during static analysis.",
      "description_length": 417,
      "index": 4235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.G",
      "library": "Pdg_types",
      "description": "This module implements a directed graph structure to represent program dependence graphs (PDG), where nodes correspond to computations and edges represent dependencies between them. It provides core operations to create an empty graph, add nodes with keys, and establish dependence edges, optionally qualified with a zone. The child module defines edge labels and accessors to retrieve source and destination nodes, enabling precise dependency analysis during PDG traversal. Together, they support building and analyzing PDGs to capture data and control dependencies between program statements.",
      "description_length": 594,
      "index": 4236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSetLattice",
      "library": "Pdg_types",
      "description": "This module implements a lattice structure over sets of nodes, enabling abstract interpretation tasks through operations like join, meet, narrowing, and inclusion checks. It supports set manipulation via filtering, folding, and membership tests, while its child module extends this with PDG-specific abstractions, including union, intersection, and project-tailored membership checks. The combined interface allows for fixed-point computations in dataflow analysis, such as tracking dependencies or propagating constraints across program paths. Specific uses include converting node sets to lists, selecting elements based on predicates, and performing structural comparisons during static analysis.",
      "description_length": 699,
      "index": 4237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgMarks.Proj",
      "library": "Pdg_types",
      "description": "This module defines a functor for interprocedural propagation of marks across PDG elements. It provides operations to store, retrieve, and propagate marks through function calls, using types like `t`, `mark`, `call_info`, and `fct`. It is used to analyze and track data dependencies between functions in static analysis.",
      "description_length": 320,
      "index": 4238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgMarks.Config-M",
      "library": "Pdg_types",
      "description": "This module defines how to merge and combine mark information during propagation through PDG elements, using operations like `merge` and `combine`. It works with the abstract type `t` representing mark data and `call_info` related to function call context. Concrete use cases include tracking and propagating analysis results such as taint or dependency information across program elements.",
      "description_length": 390,
      "index": 4239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.NodeSet",
      "library": "Pdg_types",
      "description": "This module provides efficient manipulation of sets of PDG nodes with standard set operations, ordered traversal, and functional transformations such as union, intersection, and mapping. It supports imperative hash tables for node set-based keying, enabling memoization, deep copying, and project-aware data management with operations like insertion, deletion, and bulk transformation. Child modules define structured keys and values for dependency tracking, aggregation, and ordered queries, facilitating tasks like control-flow analysis, slicing, and semantic relationship tracking. Use cases include PDG construction, static analysis, and scalable plugin development requiring precise set-based reasoning over program elements.",
      "description_length": 730,
      "index": 4240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgTypes.Pdg",
      "library": "Pdg_types",
      "description": "The module supports the construction, analysis, and transformation of Program Dependence Graphs with operations like equality checks, node and edge traversal, dependency queries with source tracking, and hierarchical PDG management. It enables static analysis of program dependencies, visualization of control-flow relationships, and integration with CIL-based function representations through key functions such as folding over call nodes and iterating dependents. The child module enhances visualization capabilities by defining Graphviz DOT attributes for nodes and edges, allowing customization of labels, colors, and shapes based on PDG structure. Together, they support tasks like generating structured DOT output for debugging or analyzing dependencies in top-level functions.",
      "description_length": 783,
      "index": 4241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgMarks.Config",
      "library": "Pdg_types",
      "description": "This module defines how marks are transformed and propagated between function calls and their dependencies in a PDG. It specifies mappings for converting input marks into caller input marks and output marks into called function input marks. These transformations guide mark propagation across function boundaries, controlling how information flows through the PDG during analysis.",
      "description_length": 380,
      "index": 4242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex.FctIndex",
      "library": "Pdg_types",
      "description": "This module maps function elements to associated data, using keys to identify statements, labels, or calls. It supports operations to add, retrieve, and fold over entries, with specialized functions for handling call statements and their signatures. It is used to associate PDG nodes with function elements or track marks in program slices.",
      "description_length": 340,
      "index": 4243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Node",
      "library": "Pdg_types",
      "description": "This module represents nodes in a program dependency graph with identifiers and associated statements, supporting operations like equality checks, comparison, hashing, and pretty-printing. It integrates structured data handling through submodules that provide ordered maps and hash tables keyed by nodes, enabling dependency tracking, memoization, and analysis across project nodes. These submodules allow polymorphic and typed storage, ordered traversal, and custom formatting, with utilities for safe lookups and in-place transformations. Example uses include tracking variable dependencies, caching analysis results, and visualizing control flow by leveraging node-based mappings and structured iteration.",
      "description_length": 708,
      "index": 4244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgMarks.Mark",
      "library": "Pdg_types",
      "description": "This module defines a type `t` representing marks attached to PDG elements and operations for merging and combining these marks during propagation. It includes functions like `merge` for joining two marks, `combine` for determining updated marks during dependency traversal, and `pretty` for formatting output. It is used to track and propagate analysis data such as taint or control flow information through a program's dependency graph.",
      "description_length": 438,
      "index": 4245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.LocInfo",
      "library": "Pdg_types",
      "description": "This module provides lattice operations, map manipulation functions, and interval management tools for analyzing hierarchical location data and memory states. It supports data flow analysis and program dependence graph construction through core types like `lmap` and offset-based interval mappings. Operations include join, meet, filtering, and cache-aware folding, enabling precise tracking of memory layout dependencies and value ranges across execution paths. Specific uses include optimizing static analysis and modeling memory transitions using interval arithmetic and lattice-based bindings.",
      "description_length": 597,
      "index": 4246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes.Dpd",
      "library": "Pdg_types",
      "description": "This module provides set-like operations to manage composite dependency labels on PDG edges, supporting control, address, and data dependencies as distinct types. It works with a bitmask or algebraic data type (`Dpd.t`) to represent dependency combinations, enabling precise tracking of relationships like `Ctrl`, `Data`, or `Addr` (or their absence via \"bottom\"). Specific use cases include merging dependencies from divergent control flow paths, checking for overlapping dependency types between program elements, and constructing hierarchical PDG edges with mixed dependency semantics.",
      "description_length": 588,
      "index": 4247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgIndex",
      "library": "Pdg_types",
      "description": "This module provides a structured way to index and associate data with elements of a function, such as statements, labels, and call sites, using keys that uniquely identify these elements. It supports creating and manipulating these keys, as well as mapping them to data like PDG nodes or analysis marks through a central index structure. You can use it to track relationships between function elements and control-flow components, or to store and query data across different parts of a function's control-flow graph. For example, it can map a function's parameters to their corresponding PDG nodes or associate call sites with their data-flow information.",
      "description_length": 656,
      "index": 4248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types.PdgTypes",
      "library": "Pdg_types",
      "description": "This module defines the foundational data structures and operations for constructing and analyzing program dependency graphs (PDGs), where nodes represent program statements and edges capture dependencies such as control flow, data flow, and memory relationships. It provides core types for nodes, edges with labeled dependencies, and graph structures, along with operations to build, traverse, and manipulate PDGs, including adding nodes, establishing edges, and querying dependencies. Submodules extend this functionality with lattice-based analysis, set operations for node collections, and visualization support through Graphviz attributes, enabling tasks like static slicing, dataflow computation, and dependency visualization. Example uses include building PDGs for C functions, performing fixed-point analysis on node sets, and generating structured DOT output for debugging control-flow relationships.",
      "description_length": 909,
      "index": 4249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg_types.PdgMarks",
      "library": "Pdg_types",
      "description": "This module manages metadata attachment and propagation across program dependency graph elements, using marks to track analysis results like taint or constants. It supports node and location-based selection, custom metadata types, and interprocedural propagation through function calls using transformation rules and merge operations. Submodules handle function-level dependencies, call context tracking, and mark combination strategies. Example usage includes annotating PDG nodes with analysis values, propagating taint through function boundaries, and querying merged mark states during static analysis.",
      "description_length": 606,
      "index": 4250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg_types",
      "library": "Pdg_types",
      "description": "This module organizes function elements\u2014such as statements, labels, and call sites\u2014using unique keys that enable precise data association and dependency tracking. It builds and manipulates program dependency graphs (PDGs) with nodes representing statements and edges capturing control, data, and memory dependencies, supporting operations like graph construction, traversal, and analysis. Metadata such as taint or constant values can be attached to nodes and propagated across function calls using customizable rules and combination strategies. Example uses include mapping function parameters to PDG nodes, performing static slicing, and propagating taint information through call sites.",
      "description_length": 689,
      "index": 4251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Api.Marks.F_Proj",
      "library": "frama-c-pdg.core",
      "description": "This module manages the association between functions and their marks in a program dependence graph. It provides operations to retrieve function marks based on variable information and to apply and propagate marks across the graph according to a selection strategy. The module works with types such as `t` for the internal state, `mark` for marking information, and `fct` for indexed function data. It is used to track and propagate analysis results through the graph structure during static analysis.",
      "description_length": 501,
      "index": 4252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Marks.F_Proj",
      "library": "frama-c-pdg.core",
      "description": "This module manages the association between functions and their marks in a program dependence graph. It provides operations to retrieve function-specific marks and propagate marks across the graph based on a selection strategy. It works with types such as `varinfo`, `mark`, `call_info`, and `fct`, and is used to track and apply marks during analysis of function call dependencies.",
      "description_length": 382,
      "index": 4253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pdg.Api.Marks",
      "library": "frama-c-pdg.core",
      "description": "This module coordinates mark translation and propagation between functions in a program dependence graph, ensuring consistency across call boundaries. It maps input and output marks using variable information and propagates them through the graph using a selection strategy, working with core types like `mark`, `fct`, and `t` for state management. You can retrieve function marks based on variables, update caller nodes from callee outputs, and apply marks across the graph during static analysis. Its submodules handle function-mark associations and propagation mechanics, enabling precise tracking of analysis results through function calls.",
      "description_length": 644,
      "index": 4254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Api",
      "library": "frama-c-pdg.core",
      "description": "This module provides a comprehensive interface for analyzing and manipulating Program Dependence Graphs (PDGs) by connecting CIL elements to graph nodes and exposing operations to extract and traverse data and control dependencies. It supports interprocedural analysis through direct APIs that compute transitive relationships, inspect address dependencies in complex control flows, and enable debugging via graph traversal and visualization. The child module enhances this functionality by coordinating mark propagation between functions, allowing analysis results to be consistently translated across call boundaries using variable mappings and selection strategies. Together, they enable precise tracking of input/output dependencies, function-level mark updates, and whole-program analysis by combining graph navigation with stateful mark transformation.",
      "description_length": 858,
      "index": 4255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg.Marks",
      "library": "frama-c-pdg.core",
      "description": "This module coordinates the flow of marks through function calls in a program dependence graph, translating and propagating input and output marks between callers and callees. It maintains mappings between functions and their associated marks, supporting operations to retrieve, transform, and apply marks based on call context and selection strategies. Key data types include `varinfo`, `mark`, `call_info`, and `fct`, with transformations applied during interprocedural analysis. For example, it can propagate modified input marks from a callee back to its caller or map output marks from a caller to the appropriate nodes in a called function's PDG.",
      "description_length": 652,
      "index": 4256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pdg",
      "library": "frama-c-pdg.core",
      "description": "This module enables interprocedural analysis by connecting Program Dependence Graphs (PDGs) across function boundaries through mark propagation and variable mappings. It provides data types such as `varinfo`, `mark`, `call_info`, and `fct`, supporting operations to translate, retrieve, and apply marks based on call context and selection strategies. The module allows analysis results to flow between functions, enabling precise tracking of dependencies and stateful transformations across the call graph. For example, it can propagate modified input marks from a callee to a caller or map output marks to the correct nodes in a called function's PDG.",
      "description_length": 652,
      "index": 4257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling lists of strings as a single string parameter, with operations for equality, comparison, hashing, and pretty-printing. It provides a unique named type equipped with standard type representations, descriptors, and structural equality checks. Concrete use cases include managing string lists in contexts requiring single string inputs, such as configuration parameters or serialized data fields.",
      "description_length": 437,
      "index": 4258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling string-based file paths in a way that supports equality checks, comparison, hashing, and pretty printing. It provides operations to test membership within projects, create deep copies, and describe values using Frama-C's type and descriptor system. Concrete use cases include managing and comparing file paths during static analysis tasks, such as tracking source file origins or organizing analysis results per file.",
      "description_length": 461,
      "index": 4259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a string set data structure with operations for equality, comparison, hashing, and pretty-printing. It supports membership testing with project-specific predicates and deep copying of values. The module is used to represent and manipulate sets of strings in a way that integrates with Frama-C's plugin system for analysis and visualization tasks.",
      "description_length": 366,
      "index": 4260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality, comparison, hashing, and pretty-printing. It works with the `As_string.Datatype.t` type and includes functionality for checking membership in projects, deep copying, and generating descriptors. Concrete use cases include managing and comparing file path lists in static analysis tools that require precise data representation and project-specific filtering.",
      "description_length": 470,
      "index": 4261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling multiple kernel function maps with string keys, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with `Frama_c_kernel.Type.t`, `Project_skeleton.t`, and string-based representants for structured data handling. It is used to manage and manipulate function declarations and prototypes in static analysis contexts, particularly when tracking or comparing kernel function data across different projects.",
      "description_length": 490,
      "index": 4262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a data type for handling multiple string values with operations for comparison, hashing, and pretty printing. It supports string-based representations with a unique name and descriptors for integration with the Frama-C kernel. Use cases include managing string collections in Frama-C plugins, such as storing and comparing analysis results or configuration parameters.",
      "description_length": 391,
      "index": 4263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically for string-based representations. It supports structured data handling with functions like `mem_project` to check project membership and `copy` for deep cloning. Use cases include managing string identifiers with associated metadata in analysis tools or configuration systems.",
      "description_length": 393,
      "index": 4264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling sets of strings with operations for equality, comparison, hashing, and pretty-printing. It provides a structured way to manage string collections, including deep copying and membership checks based on project conditions. Concrete use cases include representing and manipulating string-based identifiers or configuration values within a larger analysis framework.",
      "description_length": 406,
      "index": 4265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a datatype used to represent string-based keys in a kernel function map. It provides equality, comparison, hashing, and pretty-printing functions for this datatype, along with deep copying and project membership checks. The module is used to manage and manipulate function keys that may include both defined functions and pure prototypes in the context of Frama-C's kernel.",
      "description_length": 408,
      "index": 4266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_list.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based datatype with support for equality, comparison, hashing, and pretty-printing. It works with lists of strings as a specific data structure, providing concrete functionality for managing representational values and descriptors. Use cases include handling string collections in analysis plugins, such as storing and comparing string identifiers or configuration values during static analysis.",
      "description_length": 439,
      "index": 4267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines operations for a string-based data type used to represent and manipulate function declarations in the context of static analysis. It provides standard utilities such as equality checks, comparison, hashing, and pretty printing, along with deep copying and project membership testing. Concrete use cases include managing sets of function declarations for analysis passes and persisting or comparing declaration data across different analysis states.",
      "description_length": 468,
      "index": 4268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling string-based multimap entries with support for equality, comparison, hashing, and pretty-printing operations. It provides a deep copy function, membership checks over project skeletons, and integrates representational values with Frama-C's type and descriptor system. It is used to manage multiple string bindings in a structured, type-safe manner within Frama-C plugins.",
      "description_length": 415,
      "index": 4269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a string map with operations for equality checking, comparison, hashing, and pretty printing. It works with string-based data types and provides a unique named type for use in Frama-C's plugin system. Concrete use cases include managing string-indexed data with strong type guarantees in static analysis tools.",
      "description_length": 333,
      "index": 4270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type and operations for representing and manipulating string-based kernel function sets in the Frama-C API. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. Use cases include managing and querying sets of string functions within Frama-C plugins, particularly for static analysis tasks requiring precise string function handling.",
      "description_length": 435,
      "index": 4271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map.As_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling string values with operations for equality, comparison, hashing, and pretty printing. It provides a unique named type with a list of representative values, a type descriptor, and a packed structural descriptor for integration with the Frama-C kernel. The module supports deep copying and project membership checks, making it suitable for representing and manipulating string-based data in Frama-C analyses.",
      "description_length": 450,
      "index": 4272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Int.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for structural comparison, hashing, and pretty-printing. It supports values of type `t` with deep copy, equality, and project membership checks. Used to manage and manipulate analysis data within Frama-C plugins, ensuring integrity and structural consistency.",
      "description_length": 306,
      "index": 4273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Bool.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a boolean datatype with operations for equality, comparison, hashing, and pretty-printing. It provides a structured descriptor, a list of representants, and utilities for project membership checks and deep copying. Concrete use cases include representing logical states in analysis plugins and managing boolean values within Frama-C's kernel structures.",
      "description_length": 373,
      "index": 4274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a string set data structure with operations for equality checking, comparison, hashing, and pretty printing. It supports set operations and deep copying, ensuring no shared references between original and copied values. It is used to manage collections of unique strings within Frama-C plugins, particularly for tracking and comparing sets of identifiers or labels in program analysis tasks.",
      "description_length": 411,
      "index": 4275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a string list collection, providing operations to define, retrieve, and configure category values such as `@none`, `@default`, and `@all`. It works with category types and state lists to control how elements are interpreted in different contexts. Concrete use cases include setting up default category behavior, enabling all elements with specific interpretations, or mapping `@all` to another category.",
      "description_length": 438,
      "index": 4276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Zero.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structured data representation with descriptors, packed representations, and deep copying to ensure value integrity. Concrete use cases include modeling abstract values, managing analysis states, and persisting or comparing analysis results across different program points.",
      "description_length": 434,
      "index": 4277,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for handling lists of file paths, providing operations for equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's type system through descriptors and type representations, enabling use in plugin development. Concrete use cases include managing and comparing file path collections within Frama-C analyses, particularly for tracking and serializing project-specific data.",
      "description_length": 436,
      "index": 4278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages command-line parameters with string values, supporting validation, alias resolution, and state tracking through callbacks. It works with strings enriched with metadata and constraints, allowing dynamic validation and integration with project-specific update logic. Its child module provides a string set structure with membership checks, comparison, and pretty-printing, used for analysis tasks in Frama-C plugins. Together, they enable building configurable, extensible command-line interfaces with rich string handling and set operations.",
      "description_length": 560,
      "index": 4279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a kernel function set, providing operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types and state lists, allowing precise control over category behavior in both positive and negative contexts. Concrete use cases include setting up default and \"all\" categories, enabling all functions under a specific interpretation, and defining custom categories with named accessors.",
      "description_length": 472,
      "index": 4280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Enum.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype for a fixed set of values with support for comparison, hashing, and pretty-printing. It includes operations to check membership in projects, perform deep copies, and provides structural descriptions for integration with analysis frameworks. It is used to represent and manipulate enumerated values in static analysis plugins where precise value tracking and project-specific filtering are required.",
      "description_length": 429,
      "index": 4281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module handles multiple string values with operations for comparison, hashing, and pretty printing, supporting string-based representations with unique names and descriptors. It integrates with the Frama-C kernel, enabling plugins to manage collections of strings for tasks like storing and comparing analysis results or configuration parameters. The main data types include named string collections and descriptors, while key operations support set-like manipulations and kernel interactions. Example uses include tracking analysis outputs or managing plugin-specific string data within Frama-C.",
      "description_length": 601,
      "index": 4282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a parameter map with multibindings, supporting operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and includes functions to add custom categories with accessors and dependencies, or enable `@all` with specific interpretations. Concrete use cases include organizing and controlling parameter visibility or behavior in a configuration system based on dynamic state conditions.",
      "description_length": 520,
      "index": 4283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a structured datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis tools. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. Concrete use cases include representing and manipulating analysis states or configurations in a Frama-C plugin.",
      "description_length": 378,
      "index": 4284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based command-line parameters with validation, alias resolution, and change tracking, operating through a structured type that enforces constraints like allowed values or patterns. It supports integration with project state for contextual behavior, enabling tasks like parsing plugin configuration options and restricting inputs to enums. The child module enhances this by defining operations for string function sets in Frama-C, including equality, comparison, and pretty-printing, facilitating static analysis tasks that require precise handling of string functions. Together, they allow managing both simple string parameters and complex string function sets within the same framework.",
      "description_length": 715,
      "index": 4285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-valued command-line parameters with support for change tracking, validation, and serialization, particularly for values constrained to predefined options or valid function names. It includes utilities for monitoring value changes, persisting values, and validating against allowed sets or naming conventions, enabling use cases like dynamic configuration systems and CLI tools. A child module extends this functionality by providing operations for representing and manipulating function declarations, supporting equality checks, comparison, pretty printing, and project membership testing. Together, they allow structured handling of string-based parameters and function declarations, with applications in static analysis and configuration management.",
      "description_length": 778,
      "index": 4286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based command-line parameters with support for value validation, alias resolution, and dynamic value handling through function name rules. It provides data types for structured string representations with operations like equality, comparison, hashing, and pretty-printing, along with utilities such as `mem_project` for project membership checks and `copy` for deep cloning. The core functionality enables strict value constraints, change tracking, and customizable serialization, integrating with project state systems via update hooks. Use cases include parsing and validating user options with restricted value sets, resolving string inputs against function patterns, and managing string identifiers with metadata in configuration or analysis tools.",
      "description_length": 779,
      "index": 4287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling multiple string maps, providing operations for equality, comparison, hashing, and pretty-printing. It supports structured representations with descriptors and allows deep copying and project membership checks. Concrete use cases include managing and manipulating string-based mappings in static analysis contexts, such as tracking variable associations across different program states.",
      "description_length": 430,
      "index": 4288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.True.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project values, and includes a list of representative values for the type. It is used to define and manipulate structured data types within static analysis plugins, particularly for representing and managing analysis states or configurations.",
      "description_length": 411,
      "index": 4289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to parameter collections, using accessors and state lists to control behavior. Use cases include configuring analysis parameters in Frama-C plugins, where categories determine which parameters are active or how they are interpreted across different analysis modes.",
      "description_length": 464,
      "index": 4290,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for organizing and manipulating collections of elements, particularly in relation to file paths. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with custom categories that have associated names, accessors, and dependencies. These categories are used to control the inclusion or exclusion of elements in static analysis contexts, such as enabling all elements by default or restricting them based on specific states.",
      "description_length": 512,
      "index": 4291,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for representing strings within the Frama-C kernel, providing operations for equality, comparison, hashing, and pretty-printing string values. It supports structural descriptions and deep copying, enabling precise handling of string data across different analysis contexts. Concrete use cases include managing string literals in abstract syntax trees and tracking string values during static analysis.",
      "description_length": 433,
      "index": 4292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.WithOutput.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis tools. It supports structured data representation with descriptors, packed descriptions, and a list of representatives for type inspection. The module enables deep copying, project membership checks, and provides a type-safe way to handle and manipulate complex data structures in the context of Frama-C's kernel.",
      "description_length": 453,
      "index": 4293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` representing a set of function declarations, along with operations for equality, comparison, hashing, and pretty printing. It provides access to type information, descriptors, and project membership checks, enabling precise manipulation and analysis of function declaration sets. Concrete use cases include tracking function definitions across translation units and performing semantic comparisons during static analysis.",
      "description_length": 457,
      "index": 4294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based command-line parameters with support for defaults, aliases, validation, and change tracking through the `As_string.t` type. It enables conditional logic, custom serialization, and state persistence, useful for integrating configuration with plugins or validating identifiers at runtime. A child module extends this functionality to file path lists, offering comparison, hashing, and project-aware operations for use in static analysis tools. Together, they provide a cohesive interface for handling string parameters and structured file path data in a type-safe, extensible way.",
      "description_length": 611,
      "index": 4295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` for representing file paths in a static analysis context, along with standard operations including equality, comparison, hashing, and pretty printing. It provides a deep copy function, a list of representative values, and a way to check membership of project-specific data through a predicate. The type integrates with Frama-C's kernel structures, supporting structural descriptions and project-aware queries.",
      "description_length": 445,
      "index": 4296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a map-based collection, supporting operations to define, retrieve, and configure named categories such as `@none`, `@default`, and `@all`. It works with `Category.t` values, which represent individual categories, and interacts with `Frama_c_kernel.State.t` and `Parameter_category.accessor` types to define behavior and dependencies. Concrete use cases include setting up default category behavior, enabling the `@all` category with specific interpretations, and creating custom categories with associated accessors and dependencies.",
      "description_length": 568,
      "index": 4297,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Api_generator.Self.Make_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string parameters with validation, aliases, marshaling, and state change hooks, operating over map structures that associate string keys with constrained values. It supports defining allowed value sets, custom validation, and normalized string representations, making it ideal for command-line configuration and dynamic parameter handling. The child module enhances this by introducing a typed structure for string values with equality, comparison, and pretty printing, along with integration capabilities for Frama-C analyses. Together, they enable precise manipulation of string data with strong typing, validation, and analysis support.",
      "description_length": 659,
      "index": 4298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, using `Category.t` as the main type, which wraps a parameter category with an associated name and behavior. It supports operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, and allows linking categories to accessors and dependencies. Use cases include organizing command-line options or configuration parameters into logical groups with customizable fallback and inclusion behavior.",
      "description_length": 479,
      "index": 4299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a string set collection, providing operations to define and manipulate named categories with accessors and dependencies. It works with types `elt` and `t`, where `t` represents parameter categories. Concrete use cases include setting up default and special categories like `@none`, `@default`, and `@all`, and enabling or aliasing these categories to control parameter behavior in static analysis plugins.",
      "description_length": 440,
      "index": 4300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Empty_string.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for handling empty string values within a specific analysis context. It provides a deep copy function, a membership test for project skeletons, and includes standard representational utilities like name, descriptor, and packed descriptor. Concrete use cases include managing and comparing empty string values during static analysis passes and ensuring correct data representation in Frama-C plugins.",
      "description_length": 511,
      "index": 4301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string command-line parameters with validation, aliasing, and dynamic state, operating on Datatype structures that define allowed values and function name rules. It supports setting valid values, validating inputs, and retrieving results based on function-specific criteria, such as in option parsing for the Frama-C kernel. A child module extends this functionality to handle lists of strings as a single parameter, offering equality, comparison, and pretty-printing operations. This enables managing configuration values or serialized data fields where multiple strings must be treated as a unified input.",
      "description_length": 627,
      "index": 4302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling sets of strings filled in a specific context, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with `Datatype.t` values, which represent structured data in the Frama-C framework, and includes functionality for checking membership based on project properties and performing deep copies. It is used in scenarios requiring precise manipulation and analysis of string sets within Frama-C's abstract interpretation plugins.",
      "description_length": 511,
      "index": 4303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module provides utilities for managing string-based configuration parameters with validation, including defining allowed values, enforcing function name constraints, and tracking state transitions. It supports operations on string values paired with metadata such as validation rules or hooks, enabling use cases like restricting inputs to predefined options and sanitizing C function identifiers. A child module implements a string map with equality, comparison, hashing, and pretty printing, offering a uniquely typed structure for managing string-indexed data in static analysis tools. Together, they support command-line configuration, plugin parameter management, and type-safe string handling in the Frama-C framework.",
      "description_length": 729,
      "index": 4304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based parameters for command-line options, supporting value assignment, retrieval, validation, and alias registration. It integrates with Frama-C's state system to track parameter updates and computed values, enabling dynamic configuration of analysis settings through string inputs. The child module enhances this functionality by defining a key type for function maps, offering equality, comparison, and pretty-printing operations to handle function identifiers, including defined functions and pure prototypes. Together, they support tasks like validating CLI arguments against allowed options, mapping string inputs to internal functions, and customizing parameter serialization.",
      "description_length": 710,
      "index": 4305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Custom.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty printing, tailored for integration with Frama-C's kernel. It supports deep copying, membership testing within projects, and provides descriptors for type representation and structural manipulation. Concrete use cases include defining and managing abstract syntax tree nodes or analysis-specific data in Frama-C plugins.",
      "description_length": 420,
      "index": 4306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for representing and manipulating abstract values in a Frama-C kernel, supporting operations like equality, comparison, hashing, and pretty-printing. It works with a list of representants and a packed descriptor to handle structural equivalence and project membership checks. Concrete use cases include managing function prototypes and their associated types in static analysis plugins.",
      "description_length": 418,
      "index": 4307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for type representation, comparison, hashing, and pretty printing, specifically tailored for use in Frama-C's kernel. It supports structural equality, deep copying, and project membership checks, making it suitable for analyzing and manipulating abstract syntax trees in static analysis tools. Concrete use cases include representing and comparing C function declarations and types within Frama-C plugins.",
      "description_length": 452,
      "index": 4308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.False.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis plugins. It supports structural manipulation and project membership checks, enabling precise data representation and transformation in analysis passes. Use cases include modeling abstract values, tracking program states, and implementing domain-specific analyses within Frama-C.",
      "description_length": 427,
      "index": 4309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module handles string-based multimap entries with support for equality, comparison, hashing, and pretty-printing. It includes operations for deep copying, membership checks over project skeletons, and integration with Frama-C's type and descriptor system. Child modules extend its capabilities to manage multiple string bindings in a structured, type-safe manner within Frama-C plugins. Example uses include tracking and manipulating string associations across different plugin components.",
      "description_length": 494,
      "index": 4310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module organizes categories for a parameter system, allowing creation, modification, and assignment of categories with specific accessors and dependencies. It works with `Category.t` values, which represent named categories like `@none`, `@default`, and `@all`, and supports enabling or aliasing the `@all` category. Concrete use cases include defining parameter groups with custom access logic, setting default behaviors, and managing global category states in a configuration system.",
      "description_length": 490,
      "index": 4311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Debug.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for type inspection, comparison, and memory management. It provides functions to check equality, compare and hash values, as well as deep copying and pretty-printing for debugging. The module supports structural analysis through descriptors and representants, and includes utilities for project-based filtering via `mem_project`.",
      "description_length": 381,
      "index": 4312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Verbose.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` representing structured data descriptors with operations for equality, comparison, hashing, and pretty-printing. It provides access to type information, named identifiers, and structural representations, supporting deep copying and project membership checks. Concrete use cases include analyzing and manipulating abstract data structures in static analysis tools, particularly for verifying properties of C code.",
      "description_length": 448,
      "index": 4313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter grouping, using `Category.t` as the main type, which wraps a parameter category with an element type `elt`. It supports operations like creating named categories with dependencies, setting default and \"all\" categories, and enabling the \"all\" category with specific interpretations. Use cases include organizing parameters into logical groups, defining default behaviors, and handling wildcard-like categories for dynamic parameter resolution.",
      "description_length": 487,
      "index": 4314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in a map structure that disallows multibindings. It supports values of type `Datatype.t` and provides functionality for checking membership based on project conditions, deep copying, and structural representation. Concrete use cases include managing unique, structured values in analysis tools where precise identity and comparison are required.",
      "description_length": 465,
      "index": 4315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter collections, providing operations to define, retrieve, and configure category values such as `@none`, `@default`, and `@all`. It works with category types tied to `Frama_c_kernel.Parameter_category.t` and supports adding named categories with accessors and dependencies. Concrete use cases include setting up analysis parameter groups and controlling default or global category behavior in Frama-C plugins.",
      "description_length": 451,
      "index": 4316,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_list.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for handling lists of strings with operations for equality, comparison, hashing, and pretty printing. It provides a structured way to manage string lists, including deep copying, membership testing, and project-based filtering. Use cases include representing and manipulating collections of string identifiers or configuration values in a type-safe manner.",
      "description_length": 388,
      "index": 4317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` and associated operations for managing a collection of `Datatype.t` values, including equality, comparison, hashing, and pretty-printing. It provides structural descriptions, representants, and utilities for project membership checks and deep copying. Concrete use cases include handling structured data in static analysis tools, where precise type information and value manipulation are required.",
      "description_length": 433,
      "index": 4318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Fundec_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for organizing and manipulating sets of function declarations in a static analysis context. It provides operations to define, enable, and modify categories such as `@none`, `@default`, and `@all`, each controlling how related analysis states are interpreted. Use cases include configuring analysis parameters and controlling the activation of specific function sets during static analysis.",
      "description_length": 420,
      "index": 4319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module processes command-line parameters with string values, enforcing valid inputs through predefined choices, aliases, and custom marshaling. It operates on string lists to validate identifiers and associate metadata such as defaults and help messages, enabling precise CLI option definitions. The child module enhances this functionality by providing structured operations for string sets, including equality checks, comparison, and membership tests, which support managing identifiers or configuration values. Together, they allow defining a CLI option that restricts input to a known set of values, transforms them via custom parsing, and displays structured help messages based on associated metadata.",
      "description_length": 712,
      "index": 4320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Filepath_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based command-line parameters with rich metadata, including defaults, validation rules, and deprecation, while supporting dynamic value marshaling and global state tracking for function names. It provides core operations for parameter validation, alias management, and configuration handling, with concrete use cases in enforcing valid function inputs and maintaining project-specific string options. The file path submodule extends this functionality by offering structured manipulation of file paths with equality, comparison, and pretty printing, enabling robust tracking and organization of source files during static analysis. Together, they support complex workflows such as validating command-line inputs and managing analysis results across different files.",
      "description_length": 792,
      "index": 4321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for a string set collection, providing operations to define, retrieve, and modify category values such as `@none`, `@default`, and `@all`. It works with category types that include accessors and dependencies on state values. Use this module to configure category behavior in parameter handling, such as setting default interpretations or enabling global category rules.",
      "description_length": 400,
      "index": 4322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a structured datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C kernel plugins. It supports deep copying, membership testing within projects, and provides representants for the type. Concrete use cases include managing and manipulating abstract syntax tree nodes or analysis-specific data structures in a type-safe manner.",
      "description_length": 400,
      "index": 4323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a string map data structure with operations for equality checking, comparison, hashing, and pretty printing. It provides a typed representation of string-keyed data, including support for deep copying and project membership checks. Concrete use cases include managing symbol tables, configuration settings, or any keyed collections within static analysis tools built on the Frama-C platform.",
      "description_length": 414,
      "index": 4324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Float.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type for representing floating-point numbers with optional decimal points, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the `Datatype.t` structure and includes functions for deep copying, membership testing in projects, and generating representants. Concrete use cases include handling floating-point parameters in Frama-C plugins, validating project-specific values, and formatting output for user display.",
      "description_length": 485,
      "index": 4325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Action.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` and associated operations for managing structured data representations, including equality, comparison, hashing, and pretty-printing. It provides access to type descriptors, packed representations, and a list of representative values for the data type. It supports deep copying, membership checks over project skeletons, and integrates with Frama-C's type and project systems for analysis extensions.",
      "description_length": 436,
      "index": 4326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for parameter configurations, supporting operations to define, retrieve, and modify named categories with associated accessors and dependencies. It works with `Category.t` values, which represent individual categories, and interacts with `Frama_c_kernel.State.t` lists for state management. Concrete use cases include setting up configurable parameter groups, enabling global category behaviors, and defining default or special-purpose categories like `@none`, `@default`, and `@all`.",
      "description_length": 515,
      "index": 4327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for handling multibindings in a map structure. It supports deep copying and provides representants along with a descriptor for structural manipulation. Concrete use cases include managing and querying complex data structures with multiple associated values per key, such as symbol tables or configuration settings with multiple entries.",
      "description_length": 449,
      "index": 4328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_list.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-based command-line parameters with constrained values, validation, and dynamic resolution, while also supporting operations on string collections with equality, comparison, and pretty-printing. It provides data types for parameter definitions with allowed values and marshaling rules, along with functions to resolve and validate user inputs against these constraints. The module enables use cases like building CLIs with strict input checks, handling configuration state, and analyzing string identifiers in plugins. For example, it can map user-provided strings to internal functions, validate them against predefined sets, and store or compare them using built-in operations.",
      "description_length": 705,
      "index": 4329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_set.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis tools. It supports structured data representation with descriptors, packed types, and project membership checks, enabling precise type handling and analysis. Concrete use cases include modeling program entities like variables or expressions with rich structural and semantic properties.",
      "description_length": 426,
      "index": 4330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_list.Category",
      "library": "frama-c-api-generator.core",
      "description": "This module manages categories for organizing and manipulating collections of file paths in a configuration or analysis context. It provides operations to define, retrieve, and modify categories such as `@none`, `@default`, and `@all`, along with custom categories that include accessors and dependencies. Use cases include setting up configurable groups of file paths for static analysis tools, where categories control how different path sets are interpreted or activated during analysis runs.",
      "description_length": 495,
      "index": 4331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map.As_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-valued command-line parameters with controlled value sets and validation logic, supporting operations to define allowed values, validate inputs against function names or literals, and track state changes through hooks. It defines a data type for handling multiple kernel function maps with string keys, supporting equality checks, comparison, hashing, and pretty-printing, working with types like `Frama_c_kernel.Type.t` and `Project_skeleton.t`. You can use it to manage and manipulate function declarations and prototypes in static analysis, particularly when tracking or comparing kernel function data across projects. The module enables strict input constraints and dynamic value updates, useful for Frama-C kernel configuration options or plugin-specific parameters.",
      "description_length": 798,
      "index": 4332,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String",
      "library": "frama-c-api-generator.core",
      "description": "This module provides utilities for handling string-based command-line options and project-specific configuration tasks, such as value validation, serialization, and hook management. It includes a core data type for representing strings with support for equality, comparison, hashing, and pretty-printing, enabling precise manipulation in static analysis and abstract syntax tree contexts. Operations allow defining aliases, setting values, and integrating with Frama-C's extension framework for plugin customization. Specific uses include tracking string literals during analysis and managing configurable parameters with validation callbacks.",
      "description_length": 643,
      "index": 4333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Value_int",
      "library": "frama-c-api-generator.core",
      "description": "This module defines an integer-based data type with standard operations including equality, comparison, hashing, and pretty printing. It provides utilities for deep copying values, checking membership based on project conditions, and converting values to and from strings. The type is used to represent and manipulate integer values within a structured framework, supporting precise data handling and transformation.",
      "description_length": 416,
      "index": 4334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath",
      "library": "frama-c-api-generator.core",
      "description": "This module manages file paths with support for dynamic state changes, command-line configuration, and serialization. It operates on `Frama_c_kernel.Filepath.t` values, offering mutation, validation, and query operations, along with integration hooks for project state updates. Child module `t` defines the core path data type with equality, comparison, and pretty printing, enabling structured analysis and project-aware path tracking. Examples include validating empty paths, dynamically updating paths with hooks, and serializing configurations for CLI-driven analysis.",
      "description_length": 572,
      "index": 4335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Zero",
      "library": "frama-c-api-generator.core",
      "description": "This module manages configurable integer parameters with constraints, project state integration, and customizable serialization, enabling validated input ranges, reactive updates, and persistent configuration. It provides data types for tracked integer values with metadata like names, help strings, and aliases, along with operations for setting bounds, attaching change hooks, and serializing values. The child module enhances this by defining structured data representations with support for equality, comparison, and deep copying, useful for modeling abstract values and managing analysis states. Together, they allow building robust, reactive configuration systems with rich data manipulation and static analysis capabilities.",
      "description_length": 731,
      "index": 4336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Custom",
      "library": "frama-c-api-generator.core",
      "description": "This module enables the use of custom types as parameters with robust state management, value serialization, and change tracking, centered around the types `t` and `Typed_parameter.t`. It supports operations like value setting/retrieval, hook registration, and marshaling control, allowing for parameterized CLI commands with deprecation and visibility flags, as well as structured state persistence. The child module enhances this by defining a custom data type with equality, comparison, and pretty printing operations, tailored for Frama-C integration with support for deep copying, project membership testing, and structural manipulation. Together, they facilitate the implementation of complex analysis components and customizable parameter handling in Frama-C plugins.",
      "description_length": 774,
      "index": 4337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Share",
      "library": "frama-c-api-generator.core",
      "description": "This module manages the configuration and retrieval of the `<dune-site-dir>` directory, providing functions to set, get, and check its existence. It supports operations to locate specific files and subdirectories within the site directory, ensuring correct type (file or directory) and existence. Useful for plugins needing to access shared resources or configuration files stored in a predefined site structure.",
      "description_length": 412,
      "index": 4338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Enum",
      "library": "frama-c-api-generator.core",
      "description": "This module manages enumeration-based state variables with support for tracking modifications, defining defaults, and customizing marshaling, while binding enum values to command-line options and persistence mechanisms. It operates on a comparable variant type `t` defined in submodule `X`, which represents a finite set of values with structural equality, supporting membership checks, deep copies, and integration with analysis frameworks. Specific uses include handling analysis parameters in Frama-C's kernel via `Typed_parameter.t` and implementing type-safe configuration options with controlled serialization. Submodule `X` enhances this functionality with comparison, hashing, and pretty-printing operations, enabling precise value tracking and project-specific filtering in static analysis plugins.",
      "description_length": 807,
      "index": 4339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-keyed data with support for dynamic updates, pre/post-change hooks, and default value handling, making it ideal for configuration systems and CLI-driven applications. It provides core operations like iteration, folding, and equality checks, along with utilities for parameter validation, category-based grouping, and typed string maps with rich metadata. You can define validated configuration parameters, group them into named categories with dependencies, and manipulate string-indexed data with strong typing and structural operations. The combined functionality supports advanced use cases like command-line option parsing, plugin parameter synchronization, and symbol table management in static analysis tools.",
      "description_length": 742,
      "index": 4340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_map",
      "library": "frama-c-api-generator.core",
      "description": "This module organizes key-value associations tied to filepaths, enabling state tracking, modification, and observation with support for custom serialization, equality, and category-based filtering. It integrates categories to manage element inclusion, structured data types for precise value manipulation, and command-line parameter handling with validation and file path utilities. You can define default behaviors per file, track analysis results across projects, or enforce configuration rules dynamically. Its combined API supports workflows like synchronizing analysis states, organizing structured data by file, and validating options with rich metadata.",
      "description_length": 660,
      "index": 4341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filled_string_set",
      "library": "frama-c-api-generator.core",
      "description": "This module manages configurable string sets with dynamic updates, serialization, and state tracking, operating on `Frama_c_kernel.Datatype.String.Set.t` for tasks like command-line parsing, project value management, and kernel parameter handling. It supports membership checks, iterative transformations, and state change callbacks, while child modules enhance its capabilities with structured data operations, CLI parameter validation, and category management. You can define CLI options that accept only predefined string values, associate metadata like help messages, and organize string sets into categories such as `@none`, `@default`, and `@all` for fine-grained configuration control. The module enables deep copies, equality checks, and pretty-printing, making it suitable for abstract interpretation plugins and state-aware analysis tools.",
      "description_length": 849,
      "index": 4342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.False",
      "library": "frama-c-api-generator.core",
      "description": "This module manages boolean parameters with project-specific state, offering functions like `on` and `off` to set values, register change hooks, and handle command-line interactions such as aliases and help messages. It integrates with typed boolean parameters in the Frama-C kernel, supporting serialization and state tracking for plugin configurations, enabling analysis plugins to be configured via command-line or API calls with state changes triggering updates or persistence. The child module provides a concrete data type with operations for equality, comparison, hashing, and pretty-printing, designed for static analysis plugins to model abstract values, track program states, and implement domain-specific analyses with structural manipulation and project membership checks. Together, they support precise configuration and data representation in Frama-C analyses, linking parameter management with analysis-specific data handling.",
      "description_length": 941,
      "index": 4343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Value_string",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a string-based data type with operations for equality, comparison, hashing, and pretty printing. It includes functions to convert between strings and the type's values, check membership based on project properties, and perform deep copies. It is used to represent and manipulate string values within a structured API framework, particularly for integration with analysis tools requiring typed and described data.",
      "description_length": 432,
      "index": 4344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_site_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a `Site_dir` from an existing directory structure. It provides `get_dir` and `get_file` operations to retrieve subdirectories and files by name, ensuring they exist and are of the correct type. Use it when building or validating a directory hierarchy, such as organizing project assets or managing configuration paths.",
      "description_length": 341,
      "index": 4345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.State_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a specific state directory for a plugin, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing controlled access and manipulation of the state directory structure. Concrete use cases include storing and retrieving plugin-specific configuration or output files in a structured manner.",
      "description_length": 403,
      "index": 4346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages mappings from kernel functions to value lists, supporting operations to set, retrieve, and modify entries with custom marshaling, equality checks, and iterative processing. It integrates with project state and change tracking mechanisms, enabling use cases such as managing function prototypes, configuring parameter groups, and validating command-line inputs against function names or literals. The main data types include key-value pairs tied to kernel functions, category descriptors, and string-based parameters with controlled value sets. Specific examples include tracking function declarations across projects, defining configurable parameter categories like `@default` or `@all`, and enforcing input constraints during static analysis configuration.",
      "description_length": 777,
      "index": 4347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.String_set",
      "library": "frama-c-api-generator.core",
      "description": "This module provides a comprehensive framework for managing string sets with advanced configuration, persistence, and extensibility features. It combines core set operations\u2014such as membership checks, union, and iteration\u2014with mechanisms for command-line integration, metadata handling, and category-based parameter organization. Users can define configurable string sets that respond to changes via callbacks, persist across projects, and interact with validation logic or category hierarchies. Example uses include tracking analysis targets in plugins, managing labeled program elements, and building extensible configuration interfaces with dynamic validation and category-based defaults.",
      "description_length": 691,
      "index": 4348,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_list",
      "library": "frama-c-api-generator.core",
      "description": "This module manages stateful lists of elements with support for modification, comparison, and change tracking, along with mechanisms to append or prepend lists relative to the current state. It includes structured data types for static analysis, category management for parameter grouping, and string-based command-line parameter handling with validation and dynamic resolution. Main data types include stateful lists, categories with associated parameters, and constrained string parameters with marshaling rules. Examples include managing analysis configurations in Frama-C plugins, building CLIs with strict input validation, and tracking hierarchical updates to parameter sets.",
      "description_length": 681,
      "index": 4349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.TSC.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` for representing structured values with associated type information, equality, comparison, and pretty-printing operations. It supports working with Frama-C's type and descriptor system, enabling deep copies, membership checks over project skeletons, and handling of structural representations. Concrete use cases include managing and manipulating abstract syntax tree nodes or semantic data structures in Frama-C plugins.",
      "description_length": 457,
      "index": 4350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages string-indexed maps of value lists with support for state tracking, default values, and structured data handling. It provides operations for key visibility control, alias management, custom marshaling, and iteration, along with utilities for marking and versioning entries. The child modules enhance this functionality by introducing named string collections with kernel integration, structured string maps with deep copying and project checks, and parameter categories for organizing and grouping keys with fallback behaviors. Examples include handling dynamic configuration options, tracking analysis results across program states, and structuring command-line parameters with categorized defaults.",
      "description_length": 720,
      "index": 4351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Action",
      "library": "frama-c-api-generator.core",
      "description": "This module manages boolean configuration options with state toggling, change observation, and metadata attachment, operating on shared mutable state and typed parameter descriptors. It supports use cases like feature flags, application settings with project-specific tracking, and CLI-driven configuration, with serialization and reactive hooks for integration in larger systems. The child module defines a structured data type `t` with operations for equality, comparison, hashing, and pretty-printing, along with type descriptors and integration with Frama-C's analysis systems. Together, they enable typed, observable configuration workflows with deep copying, membership checks, and persistent state management across projects.",
      "description_length": 732,
      "index": 4352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_user_dir_opt",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a configurable directory option from an existing directory setup. It provides operations to retrieve or set a directory path, create files within it, and check its existence, all centered around a user-defined directory structure. It is useful for managing plugin-specific storage directories in Frama-C, where directory paths need to be dynamically resolved and validated at runtime.",
      "description_length": 407,
      "index": 4353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a key-value map with single bindings, where keys map to customizable values with support for marshaling, aliasing, and category grouping. It enables structured configuration management through operations to set values, register change hooks, and track computed states, particularly for scenarios requiring state synchronization with side effects or hierarchical data organization. The module's child components enhance its functionality by introducing category management, string parameter validation with typed structures, and rich data operations for equality and comparison. Specific use cases include setting up configurable analysis parameters with validation, defining category behaviors for state tracking, and managing structured, unique values with precise identity semantics.",
      "description_length": 805,
      "index": 4354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_set",
      "library": "frama-c-api-generator.core",
      "description": "This module organizes and extends a set of kernel functions with structured category management, command-line interface integration, and custom datatype support. It enables developers to group functions into named categories, control their activation state, and define relationships between categories, while also supporting command-line configuration through validated string parameters and aliases. The module's core set operations interoperate with category definitions and dynamic state updates, allowing precise control over function visibility and behavior during analysis. Examples include defining an \"all\" category that activates every function, restricting command-line input to a predefined set of allowed values, or tracking changes to function sets across project states.",
      "description_length": 784,
      "index": 4355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Config_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages the creation, retrieval, and configuration of plugin-specific directories and files within a Frama-C environment. It provides direct operations to obtain directory and file paths, with optional path creation, and allows setting and querying a user directory. Concrete use cases include handling plugin configuration storage, ensuring proper file structure for analysis outputs, and managing per-user settings in Frama-C extensions.",
      "description_length": 451,
      "index": 4356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Make_user_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module constructs a user directory from an existing parent directory, providing `get_dir` and `get_file` functions to retrieve or create directories and files under it. It operates on file paths represented by `Frama_c_kernel.Filepath.t`, with optional path creation. Concrete use cases include setting up isolated working directories for user-specific data storage or temporary file management during analysis tasks.",
      "description_length": 422,
      "index": 4357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.WithOutput",
      "library": "frama-c-api-generator.core",
      "description": "This module manages boolean state with dynamic dependencies and output control, using `Typed_parameter` values and `State.t` dependency lists to track and transition project-specific state based on computed defaults and custom marshaling. It supports use cases like CLI configuration and plugin output behavior through monitored state changes and aliased transitions. The child module enhances this functionality by defining a data type with equality, comparison, and pretty-printing operations, enabling structured data representation and type-safe manipulation of complex structures in static analysis tools. Together, they allow deep copying, project membership checks, and inspection of type representatives, supporting both runtime state management and static analysis tasks.",
      "description_length": 780,
      "index": 4358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Float",
      "library": "frama-c-api-generator.core",
      "description": "This module handles floating-point numbers with optional decimal points, providing core operations like equality, comparison, hashing, and pretty printing. It integrates with `Datatype.t` for deep copying, membership testing, and representant generation, supporting use cases such as validating project-specific values and formatting output. Submodules extend functionality for structured data manipulation and plugin parameter handling. Examples include managing numeric configurations in Frama-C plugins and ensuring value consistency across project contexts.",
      "description_length": 561,
      "index": 4359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Int",
      "library": "frama-c-api-generator.core",
      "description": "This module manages integer parameters with configurable constraints, supporting operations like setting and retrieving values, enforcing ranges, and triggering update hooks. It includes advanced features such as CLI integration, persistent storage, and custom marshaling for type-safe integer handling across configurations and interactive controls. A child module provides structural operations for a typed `t` value, enabling deep copies, equality checks, and project membership tests to ensure data integrity in plugin analyses. Together, they support building validated numeric interfaces, synchronized state systems, and robust configuration tools with strong typing and extensible serialization.",
      "description_length": 702,
      "index": 4360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Cache_dir",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a plugin-specific cache directory, providing operations to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and allows setting and querying the cache directory location. Concrete use cases include storing transient analysis results or persistent plugin data in a structured directory hierarchy.",
      "description_length": 385,
      "index": 4361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.OUT.Datatype",
      "library": "frama-c-api-generator.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use with Frama-C's kernel structures. It includes descriptors and representants for structural manipulation, along with utilities for project membership checks and deep copying. Concrete use cases include managing and comparing abstract syntax tree nodes or analysis data within Frama-C plugins.",
      "description_length": 416,
      "index": 4362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Empty_string",
      "library": "frama-c-api-generator.core",
      "description": "This module manages optional string values with customizable behavior, integrating hooks for updates, default handling, and serialization, centered around the string type `t` and interacting with `Frama_c_kernel.Typed_parameter.t` for kernel extension configuration. It supports validation, alias registration, and command-line parsing, enabling controlled string parameter manipulation in Frama-C plugins. The child module enhances this by defining a data type with equality, comparison, and pretty-printing operations, along with deep copying and membership testing for project skeletons, aiding static analysis and data representation. Together, they allow precise handling of empty string values in analysis contexts, with concrete applications in plugin configuration and value comparison during static analysis.",
      "description_length": 817,
      "index": 4363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Verbose",
      "library": "frama-c-api-generator.core",
      "description": "This module manages integer command-line options with customizable hooks, default values, and marshaling, while enforcing bounded ranges and supporting internal state increments. It maintains mutable integer states alongside metadata such as min/max bounds and visibility flags, enabling constrained parameter manipulation in analysis tools like Frama-C. The child module introduces a structured data descriptor type `t` with operations for equality, comparison, hashing, and pretty-printing, facilitating deep copying and project membership checks. Together, they support advanced configuration and analysis of C code verification tools through both dynamic state management and static data structure manipulation.",
      "description_length": 715,
      "index": 4364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Session",
      "library": "frama-c-api-generator.core",
      "description": "This module manages session-specific directories and files within a plugin's user directory. It provides operations to retrieve or create directories and files, set or query the user directory path, and check if the directory has been initialized. Concrete use cases include storing and accessing plugin-specific configuration or output files during analysis sessions.",
      "description_length": 368,
      "index": 4365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Bool",
      "library": "frama-c-api-generator.core",
      "description": "This module manages boolean configuration options with state tracking, value toggling, and change notifications, integrating seamlessly with command-line interfaces and persistent storage. It defines a rich boolean data type supporting equality, comparison, hashing, and pretty-printing, along with structured descriptors and utilities for project membership checks and deep copying. You can use it to implement feature flags, API toggles, and persistent configuration systems, while its submodules enable precise boolean manipulation and analysis within larger systems like Frama-C's kernel structures.",
      "description_length": 603,
      "index": 4366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_set",
      "library": "frama-c-api-generator.core",
      "description": "This module suite provides stateful set operations for manipulating and observing `E.Set.t` values with change tracking, serialization, and element management through addition, membership checks, and iteration. It integrates submodules for string-based parameter handling with validation and alias resolution, category management for parameter collections with named categories and dependencies, and structured data representation with support for descriptors and packed types. Use cases include persistent state management across projects, parsing and validating user options with strict constraints, defining analysis parameter groups, and modeling program entities with rich semantic properties in static analysis tools. Key operations include `mem_project`, `copy`, category configuration, and custom serialization with deep cloning and dynamic value handling.",
      "description_length": 864,
      "index": 4367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.String_list",
      "library": "frama-c-api-generator.core",
      "description": "This module manages mutable string lists with dynamic modification, iteration, and folding, while integrating state management for default values, command-line visibility, and persistence. It supports categories through dedicated operations to define and configure special values like `@none`, `@default`, and `@all`, enabling context-specific interpretations such as enabling all elements under a specific category. It handles command-line parameters with validation, aliasing, and dynamic state, including support for list-based parameters with equality, comparison, and pretty-printing. The core data type provides structured operations for string lists, including membership testing, deep copying, and project-based filtering, suitable for managing configuration values or string identifiers in Frama-C's analysis framework.",
      "description_length": 828,
      "index": 4368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Debug",
      "library": "frama-c-api-generator.core",
      "description": "This module manages debug parameter states using integer values constrained by min/max bounds, supporting operations to increment, clamp, and persist changes. It defines a core data type `t` that enables equality checks, comparisons, hashing, deep copying, and pretty-printing, along with structural analysis and project-based filtering through `mem_project`. Child modules enhance this functionality with utilities for type inspection, memory management, and dynamic update callbacks. Examples include enforcing valid debug level ranges, tracking project-specific debug settings, and serializing state across configuration changes.",
      "description_length": 632,
      "index": 4369,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Fundec_set",
      "library": "frama-c-api-generator.core",
      "description": "This module manages collections of CIL function declarations with set-like operations, supporting membership checks, iteration, transformation, and state tracking for static analysis workflows. It provides the core data type `t` for representing function declaration sets, along with operations for comparison, hashing, pretty printing, and project membership checks, enabling precise semantic analysis across translation units. Submodules extend this functionality by introducing category-based organization, configuration hooks for string parameters, and utilities for validation and serialization, supporting use cases such as dynamic analysis configuration and selective function set activation. Together, these components enable structured manipulation, filtering, and traversal of function sets under varying analysis conditions.",
      "description_length": 835,
      "index": 4370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.Self.Make_multiple_map",
      "library": "frama-c-api-generator.core",
      "description": "This module implements a mutable multi-map structure where keys map to lists of values, supporting operations to set, retrieve, and reset entries while tracking default or computed states. It integrates hooks for state changes, CLI interactions, and category-based grouping, enabling use cases like configuration management with fallbacks or project-aware option parsing. Child modules extend this functionality by managing categories, handling string-based multimap entries with type safety, and defining data types for structural manipulation of multibindings. Specific examples include organizing configuration parameters by visibility, tracking string associations across plugin components, and managing symbol tables with multiple entries per key.",
      "description_length": 752,
      "index": 4371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Filepath_list",
      "library": "frama-c-api-generator.core",
      "description": "This module dynamically manages collections of filepaths through configuration, mutation, and categorization, supporting operations like setting values with lifecycle hooks, appending elements, and iterating over `Frama_c_kernel.Filepath.t` lists. It includes a core data type for handling filepath lists with equality, comparison, and pretty-printing, while an extension module integrates string-based command-line parameters with validation and state tracking. A categorization system allows organizing file paths into named groups such as `@none`, `@default`, and custom sets with dependencies, enabling structured configuration and analysis workflows. Examples include tracking source files with validation callbacks, dynamically updating include paths during analysis, and grouping filepaths into logical units for processing pipelines.",
      "description_length": 841,
      "index": 4372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.True",
      "library": "frama-c-api-generator.core",
      "description": "This module manages boolean state with support for lifecycle hooks, alias resolution, and serialization control, operating on `bool` and `Frama_c_kernel.Typed_parameter`. It allows direct mutation of typed parameters via `on`/`off` operations and maintains backward compatibility through alias management, enabling dynamic configuration in analysis tools. The child module introduces a concrete data type with equality, comparison, and pretty-printing operations, along with deep copying and membership testing, used to represent structured analysis states or configurations. Together, they support building flexible, state-aware plugins with robust data manipulation and consistent parameter handling.",
      "description_length": 702,
      "index": 4373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self.Kernel_function_map",
      "library": "frama-c-api-generator.core",
      "description": "This module manages mappings between kernel functions and values, supporting state tracking, project-specific computation monitoring, and command-line integration. It provides operations to set, retrieve, and update function associations, with custom marshaling, equality checks, aliasing, and iteration, enabling structured serialization and persistent function state management. The child modules enhance this by defining string-based parameters for CLI options, a datatype for function declarations with comparison and copying capabilities, and a category system for organizing parameter groups with access logic and dependencies. Together, they support tasks like validating command-line inputs, mapping strings to internal functions, analyzing C declarations, and managing global configuration states.",
      "description_length": 806,
      "index": 4374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.TSC",
      "library": "frama-c-api-generator.core",
      "description": "This module manages a shared boolean state with operations to set, retrieve, and monitor changes, integrating customizable CLI aliases and state transition hooks. It defines a core `bool` type extended with synchronization capabilities, command-line flag marshaling, and runtime configuration toggles, while the child module introduces a structured `t` type for representing and manipulating typed values with equality, comparison, and pretty-printing support. Together, they enable applications like feature flag systems, dynamic setting interfaces, and structured data management in interactive or plugin-based environments. Specific uses include tying boolean toggles to CLI commands, tracking state changes in project configurations, and handling semantic data structures with type-aware operations.",
      "description_length": 803,
      "index": 4375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_generator.Self",
      "library": "frama-c-api-generator.core",
      "description": "This module provides structured logging, diagnostic reporting, and error handling alongside configuration management and data type manipulation. It supports formatted messages, log categories, command-line options, and data structures like strings, integers, floats, enums, sets, and lists, with operations for parsing, comparison, conversion, and validation. Child modules extend this functionality to manage filepaths, boolean and integer parameters, string sets, function declarations, and stateful configuration options with support for serialization, change tracking, and CLI integration. Examples include defining validated CLI options, tracking analysis results across projects, managing plugin-specific directories, and implementing type-safe configuration systems with dynamic defaults and category-based grouping.",
      "description_length": 823,
      "index": 4376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator.OUT",
      "library": "frama-c-api-generator.core",
      "description": "This component manages stateful file path options with project-specific context tracking, offering operations to set, retrieve, and monitor changes to file paths. It supports command-line integration through custom parsing and help generation, while enabling serialization, equality comparisons, and alias management for file path values. A utility function checks whether a file path is empty, aiding in validation scenarios or conditional logic during file system operations. The internal data type `t` provides equality, comparison, hashing, and pretty-printing operations, with support for structural manipulation, project membership checks, and deep copying, making it suitable for managing and comparing abstract syntax tree nodes or analysis data in Frama-C plugins.",
      "description_length": 773,
      "index": 4377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Api_generator",
      "library": "frama-c-api-generator.core",
      "description": "This module generates API schemas, manages dependency graphs, and formats structured data, working with JSON type representations, identifier mappings, and package metadata to resolve recursive definitions and interdependencies. It supports automated API documentation, code scaffolding, and dependency analysis, while its child modules handle stateful boolean values, structured logging, and file path management with CLI integration. Core data types include JSON-like records and unions, typed values with comparison and serialization, and project-aware file paths, each supporting operations like parsing, validation, state transitions, and formatted output. Examples include tying feature flags to CLI commands, generating type-safe configurations, validating file paths in analysis tools, and managing structured data across plugin-based systems.",
      "description_length": 851,
      "index": 4378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scope_gui.Dpds_gui",
      "library": "frama-c-scope.gui",
      "description": "Implements custom GUI components and event handlers for interacting with the plugin's analysis features. Works with Frama-C's GUI framework, including widgets and event loops. Enables users to configure analysis parameters and visualize results directly within the Frama-C interface.",
      "description_length": 283,
      "index": 4379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scope_gui",
      "library": "frama-c-scope.gui",
      "description": "This module provides custom graphical interface elements and event management for plugin analysis features, integrating with Frama-C's GUI system. It supports configuration of analysis settings and visualization of results through interactive widgets and event loops. Key operations include creating custom controls, binding user actions to analysis functions, and updating displays based on analysis output. Example uses include adding parameter sliders, result viewers, and interactive buttons that trigger and monitor analysis tasks.",
      "description_length": 536,
      "index": 4380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "From_gui.From_register_gui",
      "library": "frama-c-from.gui",
      "description": "Handles GUI interactions specific to the from analysis, extending the base GUI with event handlers and input validation for register-related operations. Works with GUI components like input fields, buttons, and event streams. Used to capture and validate user input for register assignments during analysis setup.",
      "description_length": 313,
      "index": 4381,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "From_gui",
      "library": "frama-c-from.gui",
      "description": "This module extends the base GUI with event handlers and validation logic for register-related operations during analysis setup. It captures and validates user input through components like input fields and buttons, ensuring correct register assignments. Key operations include binding events to actions, validating input formats, and managing state changes in response to user interactions. For example, it can validate a register name input field in real-time and trigger an analysis update when a button is clicked.",
      "description_length": 518,
      "index": 4382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Report.Register",
      "library": "frama-c-report.core",
      "description": "Handles the registration and output of report data. Works with internal data structures to collect and format results. Used to generate final reports by printing accumulated data to standard output.",
      "description_length": 198,
      "index": 4383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Report",
      "library": "frama-c-report.core",
      "description": "This module manages the collection, formatting, and output of structured report data. It provides data types such as `Report.t` for storing entries and `Field.t` for defining report columns. Operations include registering new data rows, formatting values, and printing the final report. For example, users can accumulate test results and print them as a tabular summary to standard output.",
      "description_length": 389,
      "index": 4384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.As_string.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a datatype for handling string-based command-line parameters in a structured and type-safe manner. It supports operations like equality checks, comparison, hashing, and pretty printing, enabling robust manipulation of parameter values. It is used to manage and validate string inputs within the context of a larger configuration system.",
      "description_length": 356,
      "index": 4385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.As_string.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and operations for handling author information as a string parameter in the context of command-line arguments. It supports equality checks, comparison, hashing, and pretty-printing for author values, along with deep copying and project membership testing. It is used to represent and manipulate author metadata in a structured and standardized way within the analysis toolchain.",
      "description_length": 410,
      "index": 4386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Title.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete datatype for representing and manipulating values associated with the `-mdr-title` command-line parameter in a Markdown report generator. It provides standard operations such as equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. The datatype is used to store and manage structured values that represent report titles, supporting precise handling and serialization within the analysis framework.",
      "description_length": 481,
      "index": 4387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.SarifDeterministic.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and operations for handling deterministic SARIF report parameters in Frama-C. It supports equality checks, comparison, hashing, pretty-printing, and deep copying of values, along with querying based on project membership. The type `t` works with Frama-C's internal project structures and is used to manage and represent SARIF output configurations uniquely and persistently.",
      "description_length": 406,
      "index": 4388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.FlameGraph.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a polymorphic type `t` with operations for structural comparison, hashing, and pretty-printing, tailored for use in the `-mdr-flamegraph` parameter. It supports deep copying, membership testing on project values, and provides representants along with type and descriptor information for integration with Frama-C's kernel. Concrete use cases include managing and querying structured data representations in static analysis reports.",
      "description_length": 450,
      "index": 4389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.PrintLibc.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete data type and operations for handling structured data representations in the context of printing libc-related information. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. The type `t` is used to represent and manipulate structured values, particularly for reporting or analysis purposes within the plugin.",
      "description_length": 417,
      "index": 4390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in command-line parameters. It includes descriptors and representations for structured data handling, along with functions to check project membership and perform deep copies. It is used to manage and manipulate abstract data types in the context of stubs for analysis reports.",
      "description_length": 411,
      "index": 4391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.Category",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manages categories for command-line parameters related to a collection of stubs. It provides operations to create, enable, and modify categories such as `@none`, `@default`, and `@all`, using names, accessors, and dependency lists. These categories control how parameters are interpreted and grouped in the context of generating markdown reports.",
      "description_length": 370,
      "index": 4392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Date.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete data type for representing date values in the context of Markdown report parameters. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as functions for deep copying and checking membership based on project projections. The type is used to store and manipulate specific date configurations passed via the `-mdr-date` command-line option.",
      "description_length": 419,
      "index": 4393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponent.Contents",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a type `t` representing string-based content for SARIF tool components, with conversions to and from JSON using `of_yojson` and `to_yojson`. It includes predefined values `localizedData` and `nonLocalizedData` to indicate the kind of content stored. It is used to specify whether tool component data is localized or non-localized within a SARIF report.",
      "description_length": 372,
      "index": 4394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs.As_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages string-based command-line parameters with validation, alias handling, and state persistence, supporting dynamic updates through hooks. It operates on individual strings and string lists, enforcing allowed value constraints and distinguishing between plain strings and function name references. The child module introduces a structured, type-safe datatype for these parameters, enabling equality checks, comparison, hashing, and pretty printing to support robust validation and manipulation. Together, they allow configuring project settings via validated string inputs, persisting state across sessions, and bridging command-line arguments with internal logic.",
      "description_length": 680,
      "index": 4395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Remarks.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete data type for representing remark values in the context of Markdown report parameters. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and membership testing for project values. The type is used to manage and manipulate structured remark data within the analysis framework.",
      "description_length": 374,
      "index": 4396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Generate.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type for representing and manipulating structured values used in the generation of Markdown reports. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, along with utilities for inspecting and filtering based on project data. The type is used to model report elements such as sections, tables, and code blocks, enabling structured report assembly and customization.",
      "description_length": 442,
      "index": 4397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Debug.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and operations for representing and manipulating structured debug information in the context of Frama-C's Markdown reporting. It supports equality checks, comparison, hashing, pretty-printing, and deep copying of values, along with querying based on project membership. The type is used to capture and manage representational states for debugging purposes during report generation.",
      "description_length": 413,
      "index": 4398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.Category",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manages categories for author-related command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom names, accessors, and dependencies. Use cases include configuring how author information is interpreted and grouped in command-line arguments, particularly for tools like Frama-C that rely on structured parameter handling.",
      "description_length": 417,
      "index": 4399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Verbose.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in the Frama-C kernel's type system. It includes functions for checking membership of project values, deep copying, and exposing type descriptors for structural manipulation. The type is used to represent and manipulate verbose data structures within the Frama-C analysis framework, ensuring compatibility with the kernel's typing and description systems.",
      "description_length": 489,
      "index": 4400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Output.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type for representing output values with support for equality, comparison, hashing, and pretty-printing. It includes operations for checking membership in projects, deep copying, and provides descriptors for type information and structural representation. It is used to manage and manipulate structured output data in a way that ensures consistency and supports inspection or serialization.",
      "description_length": 417,
      "index": 4401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.As_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides utilities for managing string-based command-line parameters, particularly for author information, with support for validation, dynamic value computation, and alias resolution. It operates on string values and constrained string lists, offering hooks for state changes and marshaling for persistence, enabling configurations that include fallback defaults, function-derived values, or user-provided input. The child module enhances this functionality by defining a structured data type for author metadata with operations for comparison, copying, and project membership testing. Together, they allow precise manipulation and standardization of author information within analysis workflows.",
      "description_length": 709,
      "index": 4402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors.Datatype",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data type and operations for representing and manipulating author-related values in the context of command-line parameters. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, along with project membership testing. The type `t` works with lists of representants, descriptors, and project skeletons, enabling structured handling of author data in reports.",
      "description_length": 409,
      "index": 4403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.LogicalLocation",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of logical location data in the SARIF 2.1 schema. Works with `t` records containing metadata like name, fully qualified name, decorated name, parent key, and kind. Used to convert logical location information to and from JSON format for analysis reporting.",
      "description_length": 298,
      "index": 4404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Sarif_exception",
      "library": "frama-c-markdown-report.core",
      "description": "Handles structured exception data in SARIF 2.1 format with operations to create, serialize, and deserialize exceptions. Works with strings, stack traces, and nested exception lists. Used to represent and manipulate error information in static analysis reports.",
      "description_length": 260,
      "index": 4405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ExternalPropertyFileReferences",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of external property file references in SARIF format. Works with artifact locations, GUIDs, integers, and property objects. Used to manage metadata about external files referenced in SARIF reports, such as result file indices and associated properties.",
      "description_length": 294,
      "index": 4406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptorReference",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a reference to a reporting descriptor in the SARIF 2.1 schema, capturing metadata like `id`, `index`, `guid`, and links to a `toolComponent` and `properties`. It includes functions to serialize to and from JSON (`to_yojson`, `of_yojson`), construct instances (`create`), and retrieve a default instance (`default`). It is used to describe rules or descriptors that correspond to specific analysis results in a SARIF log.",
      "description_length": 440,
      "index": 4407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Generate",
      "library": "frama-c-markdown-report.core",
      "description": "This module orchestrates command-line configuration and validation for a string-based generator, managing value persistence, alias resolution, and state notifications. It defines and manipulates structured values representing Markdown report elements\u2014such as sections, tables, and code blocks\u2014supporting equality, comparison, pretty printing, and filtering based on project data. Operations allow parsing user settings, validating function names, transforming inputs, and assembling customizable reports with consistent state updates. Examples include generating parameterized reports from user-defined configurations and enforcing constraints during report assembly.",
      "description_length": 667,
      "index": 4408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ThreadFlow",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF thread flow data structures, specifically managing thread flow identifiers, messages, location sequences, and associated properties. Operates on the `t` record type containing strings, message objects, lists of thread flow locations, and property objects. Used to convert SARIF thread flow data to and from JSON representations for analysis and reporting tools.",
      "description_length": 412,
      "index": 4409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Json_string",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a string type for representing JSON content within the SARIF 2.1 schema. It provides serialization and deserialization functions to and from `Yojson.Safe.t` for this string type. This module is used to handle JSON-encoded strings in SARIF reports, ensuring proper formatting and structure during input and output operations.",
      "description_length": 344,
      "index": 4410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Config_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a user-specified directory path for plugin configuration, providing operations to retrieve, set, and check the existence of the directory. It works with file paths represented as `Frama_c_kernel.Filepath.t`, supporting both directory and file access under that path. Concrete use cases include initializing plugin-specific configuration storage and ensuring consistent access to user-defined directories during analysis.",
      "description_length": 440,
      "index": 4411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Graph",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF graph data structures to and from JSON. It operates on a `t` type that includes nodes, edges, descriptions, and properties conforming to the SARIF 2.1 schema. Used to convert SARIF graph representations to JSON format for storage or transmission, and to parse JSON input into structured graph data for analysis tools.",
      "description_length": 368,
      "index": 4412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Md_gen.Eva_info",
      "library": "frama-c-markdown-report.core",
      "description": "This module tracks Eva's loading state and provides functions to generate Markdown content for coverage and domain information. It works with boolean references and functions that produce Markdown elements or text pairs. Concrete use cases include dynamically generating reports on Eva's analysis coverage and domain configurations when Eva is active.",
      "description_length": 351,
      "index": 4413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_kind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of string-based constants representing result kinds in the SARIF 2.1 schema, such as `pass`, `fail`, and `review`. It provides functions to convert these result kinds to and from Yojson for serialization and deserialization. These values are used to categorize the outcomes of static analysis tools in a structured report format.",
      "description_length": 355,
      "index": 4414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingConfiguration",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the configuration for reporting rules in a SARIF (Static Analysis Results Interchange Format) document. It includes fields to enable or disable reporting, set the default severity level, assign a priority rank, and specify parameters and custom properties. It is used to customize how analysis results are reported, such as filtering output, assigning severity levels, and integrating metadata for tools consuming SARIF output.",
      "description_length": 447,
      "index": 4415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.JsonStringDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module implements a dictionary structure mapping string keys to JSON values, specifically for representing key-value metadata in SARIF reports. It provides conversion functions to and from Yojson.Safe.t for serialization and parsing. Use this module when handling custom properties in SARIF output that require structured JSON values indexed by strings.",
      "description_length": 358,
      "index": 4416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Debug",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages integer parameters with rich metadata, supporting operations to set, increment, and constrain values while tracking changes through observability hooks. It integrates structured debug information handling from its child module, enabling equality checks, pretty-printing, and project-based queries during Markdown report generation. The core type represents configurable debug settings with help text, aliases, and serialization rules, suitable for runtime monitoring in plugin systems. Example uses include dynamically adjusting log levels and capturing debug states for analysis in generated reports.",
      "description_length": 621,
      "index": 4417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Share",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages the configuration and retrieval of shared directories and files within a plugin's site directory. It provides functions to set and retrieve the site directory path, check if it has been set, and locate specific subdirectories or files within it. Concrete use cases include initializing plugin resources, loading configuration files, or accessing shared assets during analysis.",
      "description_length": 396,
      "index": 4418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.SarifDeterministic",
      "library": "frama-c-markdown-report.core",
      "description": "This module enforces deterministic SARIF report generation by managing a mutable configuration flag that controls serialization behavior. It provides operations to toggle the flag and register lifecycle hooks that respond to state changes, ensuring reproducibility in analysis pipelines. The core type `t` represents deterministic SARIF parameters, supporting equality, comparison, hashing, and pretty-printing, while integrating with Frama-C's project system for persistent configuration management. Users can query configurations based on project membership or generate consistent SARIF outputs across runs.",
      "description_length": 609,
      "index": 4419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Stl_importance",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of predefined string values representing levels of importance in a SARIF report, specifically `important`, `essential`, and `unimportant`. It provides functions to convert these values to and from JSON format using Yojson, ensuring compatibility with SARIF schema 2.1. These values are used to indicate the significance of analysis results in static code analysis reports.",
      "description_length": 398,
      "index": 4420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Remarks",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages file path options with support for state tracking, change hooks, alias resolution, and serialization control. It operates on a file path type (`t`) and includes a unit-based emptiness check to determine if a path contains data, enabling conditional logic and integration with command-line interfaces and project persistence systems. The child module defines a structured remark type with equality, comparison, and pretty-printing operations, allowing deep copying and membership testing for remark values within analysis workflows. Together, they support tasks like loading, modifying, and saving remark data based on file paths, with consistent handling across different contexts.",
      "description_length": 701,
      "index": 4421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Conversion",
      "library": "frama-c-markdown-report.core",
      "description": "Converts between an OCaml representation of SARIF 2.1 data and Yojson.Safe.t values. It handles serialization and deserialization of SARIF tool, invocation, and artifact location data. Useful for reading and writing SARIF-formatted analysis results to and from JSON files.",
      "description_length": 272,
      "index": 4422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Uri",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a type for URIs used in SARIF reports, ensuring valid string representations. It provides conversion functions to and from Yojson for serialization and deserialization. A predefined URI for referencing SARIF reports on GitHub is included for direct use in output generation.",
      "description_length": 294,
      "index": 4423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.FileChange",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF file change data structures. Works with artifact locations and replacement operations within a file. Used to represent and manipulate source code modifications in SARIF-compliant analysis reports.",
      "description_length": 247,
      "index": 4424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.CodeFlow",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF code flow data structures to and from JSON. Operates on the `t` type, which includes a description, a list of thread flows, and properties. Used to convert SARIF code flow information to JSON format for storage or transmission, and to parse JSON input into structured code flow data for analysis tools.",
      "description_length": 353,
      "index": 4425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.VersionControlDetails",
      "library": "frama-c-markdown-report.core",
      "description": "This module handles serialization and deserialization of version control metadata in the SARIF 2.1 format. It works with a record type containing fields like URI, revision ID, branch, tag, timestamp, and custom properties. Concrete use cases include converting version control details to and from JSON for reporting tools integrating with static analysis results.",
      "description_length": 363,
      "index": 4426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Json_type",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the OCaml type `t` representing the SARIF 2.1 schema and provides functions to convert between this type and `Yojson.Safe.t`. It enables parsing and generating SARIF-formatted JSON data directly from OCaml structures. Use cases include validating static analysis results against the SARIF schema and serializing analysis output for tools that consume SARIF.",
      "description_length": 377,
      "index": 4427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Edge_traversal",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for converting `Edge_traversal` values to and from JSON format using `Yojson`. It works with the `Edge_traversal` record type, which includes fields such as `edgeId`, `message`, `finalState`, `stepOverEdgeCount`, and `properties`. Use this module when serializing or deserializing edge traversal data for SARIF output in analysis tools.",
      "description_length": 367,
      "index": 4428,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.WebResponse",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and construction of SARIF web response objects. It supports creating structured web response data with fields like status code, headers, and body content, and converts between OCaml and JSON representations using Yojson. Useful for generating SARIF output that includes HTTP response details from tools like linters or static analyzers.",
      "description_length": 358,
      "index": 4429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Fix",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the `Fix` type for representing SARIF 2.1 fix data, including a message and a list of file changes. It provides JSON serialization and deserialization functions using `Yojson`. It is used to encode and decode fix information in SARIF-formatted static analysis reports.",
      "description_length": 288,
      "index": 4430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.GraphTraversal",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF graph traversal data structures to and from JSON. Operates on the `t` type, which includes graph identifiers, descriptions, initial states, edge traversals, and properties. Used to convert SARIF graph traversal information to JSON format for storage or transmission, and to parse such data from JSON input.",
      "description_length": 357,
      "index": 4431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Hash",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data structure for representing hash values and their algorithms in the SARIF 2.1 schema. It includes functions to serialize and deserialize hash data to and from JSON format. It is used to handle artifact hashes in SARIF reports, such as when recording file digests for source control or build outputs.",
      "description_length": 325,
      "index": 4432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Json_default",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides default values, JSON serialization, and deserialization for the SARIF 2.1 schema types. It operates on the `t` type representing SARIF data, using `Yojson.Safe.t` for JSON conversion. Concrete use cases include initializing SARIF structures with `default`, parsing JSON input with `of_yojson`, and generating JSON output with `to_yojson`.",
      "description_length": 359,
      "index": 4433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactLocation",
      "library": "frama-c-markdown-report.core",
      "description": "Handles conversion and creation of SARIF artifact location data from file paths or JSON representations. Works with SARIF schema artifact location records, including base URI resolution. Used to map source code locations to standardized artifact references in SARIF output files.",
      "description_length": 279,
      "index": 4434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.FlameGraph",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages string-based configuration parameters with validation, type-safe retrieval, and state change hooks, operating on strings and function identifiers to enforce constraints, support aliases, and enable serialization. It defines a polymorphic core type `t` with structural comparison, hashing, and pretty-printing for use in static analysis reports, supporting deep copies, membership tests, and integration with Frama-C's kernel. You can validate command-line inputs, generate parameterized reports, and track configuration changes in larger systems while maintaining type integrity and persistent state. Submodules enhance this functionality by providing structured data manipulation and querying capabilities tailored for analysis tools.",
      "description_length": 755,
      "index": 4435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_baselineState",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a string-based enumeration with three fixed values representing baseline states: `bs_new`, `bs_existing`, and `bs_absent`. It provides direct conversions to and from JSON using `Yojson.Safe.t`, ensuring compatibility with SARIF 2.1 schema representations. These values are used to indicate the state of a result when comparing against a baseline in static analysis reporting.",
      "description_length": 395,
      "index": 4436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponent",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents SARIF tool components with a record type `t` that captures metadata such as name, version, descriptions, and URIs, and provides constructors, JSON serialization, and access to a default instance. It integrates nested types like `MultiformatMessageString`, `ReportingDescriptor`, and `ArtifactLocation` to support structured output for static analysis tools. A child module handles string-based content with JSON conversions and predefined tags for localized or non-localized data. Together, these components enable building, serializing, and managing SARIF-compliant tool metadata with rich, structured messaging and localization support.",
      "description_length": 661,
      "index": 4437,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Markdown_report.Sarif.Sarif_result",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete SARIF result type with fields corresponding to the SARIF 2.1 schema, including identifiers, severity levels, messages, locations, and various analysis metadata. It provides functions to serialize and deserialize SARIF results to and from JSON, and a constructor function to build result instances with optional fields. It is used to represent and manipulate individual static analysis findings for output in SARIF format.",
      "description_length": 452,
      "index": 4438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.RuleConfigLevel",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines string-based constants representing SARIF rule configuration levels (`none`, `note`, `warning`, `error`) and provides JSON serialization/deserialization for these values. It works directly with `Yojson.Safe.t` for parsing and generating SARIF-compliant JSON output. These values are used to set or interpret the severity level of static analysis rules in SARIF-formatted reports.",
      "description_length": 399,
      "index": 4439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Region",
      "library": "frama-c-markdown-report.core",
      "description": "Handles region data in the SARIF 2.1 schema, including position, offset, length, and associated content. Works with integers, optional fields, and nested types like ArtifactContent and Message. Used to represent code snippet locations and their metadata in static analysis reports.",
      "description_length": 281,
      "index": 4440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.TranslationMetadata",
      "library": "frama-c-markdown-report.core",
      "description": "Handles translation metadata for SARIF reports, including creation, serialization, and default configuration. Works with strings, optional fields, and nested SARIF message structures. Used to define and exchange metadata such as tool names, descriptions, and URIs in SARIF-compliant formats.",
      "description_length": 291,
      "index": 4441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Run",
      "library": "frama-c-markdown-report.core",
      "description": "This module constructs and manipulates SARIF run objects that capture the execution details of a static analysis tool. It supports creating, serializing, and deserializing run data with rich metadata such as tool configuration, analysis results, source control provenance, and artifact references. Use it to generate structured SARIF output for integration with CI/CD pipelines or static analysis dashboards.",
      "description_length": 408,
      "index": 4442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Schema",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines the structure and serialization logic for SARIF 2.1 schema instances. It supports converting schema values to and from JSON using `Yojson.Safe.t`, and provides a function to construct schema instances with optional schema URI and version fields. It is used to generate and manipulate SARIF-formatted static analysis results.",
      "description_length": 344,
      "index": 4443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Address",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a data structure representing an address in binary code, with fields for absolute and relative memory addresses, length, kind, name, fully qualified name, offset from parent, index, parent index, and associated properties. It provides functions to serialize to Yojson, deserialize from Yojson, create instances with optional fields, and retrieve a default instance. Concrete use cases include representing function or instruction locations in binary analysis reports conforming to the SARIF 2.1 schema.",
      "description_length": 522,
      "index": 4444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactContent",
      "library": "frama-c-markdown-report.core",
      "description": "Handles content representation for artifacts in SARIF 2.1 reports, supporting text, binary, and formatted message content. It works with strings, binary data, and structured message types to capture artifact details. Used when generating or parsing SARIF output to describe source files, logs, or other embedded data.",
      "description_length": 317,
      "index": 4445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ToolComponentReference",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a SARIF tool component reference with fields for name, index, GUID, and custom properties. It provides functions to create instances, convert to and from JSON, and access default values. It is used to represent and serialize tool metadata in SARIF-formatted static analysis reports.",
      "description_length": 302,
      "index": 4446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Authors",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages command-line author parameters as ordered string collections, supporting operations like addition, iteration, and directional appending, while integrating with kernel state mechanisms for persistent configuration. It provides direct access to list-based values with alias handling, serialization, and state hooks, enabling use cases such as author list management with fallback defaults and dynamic value resolution. The child modules enhance this functionality by defining author categories, structured metadata types, and utilities for validation, comparison, and project membership testing. Together, they support precise author data manipulation, grouping, and reporting in analysis tools.",
      "description_length": 713,
      "index": 4447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ThreadFlowLocation",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a thread flow location in a SARIF report, capturing execution steps with location, stack, and state details. It includes serialization and deserialization functions for JSON representation. Used to model control flow within analysis results, tracking execution paths and their properties.",
      "description_length": 308,
      "index": 4448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Artifact",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for constructing and serializing artifact objects in the SARIF 2.1 schema, including fields like description, location, content, and metadata. It works with structured types such as message, artifact location, role, artifact content, and JSON string dictionaries. Concrete use cases include generating SARIF-compliant artifact records for static analysis results and converting them to and from JSON for storage or transmission.",
      "description_length": 459,
      "index": 4449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Message",
      "library": "frama-c-markdown-report.core",
      "description": "Handles message construction and serialization for SARIF 2.1 reports, supporting plain text and Markdown content. Works with strings, Markdown elements, and structured properties to represent diagnostic messages with optional formatting and localization. Used to create and parse SARIF message objects that include human-readable text, identifiers, and argument substitutions for reporting tools.",
      "description_length": 396,
      "index": 4450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Additional_properties",
      "library": "frama-c-markdown-report.core",
      "description": "This module handles additional properties in the SARIF 2.1 schema, specifically mapping string keys to JSON values. It provides functions to convert between JSON and OCaml representations, ensuring compatibility with SARIF's dictionary structure. Use this module to serialize or deserialize custom key-value metadata within SARIF reports.",
      "description_length": 338,
      "index": 4451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.MultiformatMessageString",
      "library": "frama-c-markdown-report.core",
      "description": "Handles structured message strings with optional Markdown formatting and metadata properties. Works with strings, optional Markdown content, and property dictionaries. Used to construct and parse SARIF messages that support both plain text and rich formatting.",
      "description_length": 260,
      "index": 4452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Title",
      "library": "frama-c-markdown-report.core",
      "description": "This module handles string-valued command-line parameters, supporting value management, validation against allowed sets, and serialization, with operations on individual strings and lists. It includes a dedicated datatype for representing `-mdr-title` values in a Markdown report generator, enabling structured manipulation, equality checks, comparison, and pretty-printing. The module supports use cases like restricting input to predefined options, handling aliased inputs, and serializing title values for reporting. Submodules extend this functionality with deep copying and project membership checks for structured title management.",
      "description_length": 637,
      "index": 4453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ExternalFiles",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF external file references to and from JSON. Works with `ArtifactLocation.t` records nested within the `ExternalFiles.t` structure. Used to manage file paths and artifact locations in SARIF reports when converting between OCaml and JSON formats.",
      "description_length": 294,
      "index": 4454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptorRelationship",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines relationships between reporting descriptors in the SARIF 2.1 schema, capturing target references, relationship kinds, optional descriptions, and metadata properties. It supports constructing, serializing, and deserializing these relationships to and from JSON using Yojson. Typical use cases include linking rule sets or diagnostic descriptors in static analysis reports.",
      "description_length": 391,
      "index": 4455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Cache_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a cache directory path for a plugin, providing functions to set, retrieve, and check the status of the directory. It works with file paths represented as `Frama_c_kernel.Filepath.t`, handling directory and file access with optional path creation. It is used to manage cached data in a specific directory, ensuring paths exist when needed and allowing controlled access to cached files.",
      "description_length": 405,
      "index": 4456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Node",
      "library": "frama-c-markdown-report.core",
      "description": "Handles the structure and serialization of SARIF node data, including identifiers, labels, locations, child nodes, and properties. Operates on recursive node trees that represent analysis results, with support for JSON conversion using Yojson. Used to build and manipulate hierarchical SARIF output for static analysis tools.",
      "description_length": 325,
      "index": 4457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Date",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a string-based date parameter, offering validation against predefined lists or function patterns, dynamic updates through hooks, and alias resolution. It includes a core data type for representing date values with support for equality, comparison, hashing, and pretty-printing, enabling precise configuration and state handling in Markdown reports. Operations allow setting and retrieving validated date values, serializing state, and checking membership based on project projections. Example uses include parsing command-line date options, enforcing valid date formats, and dynamically updating date settings during report generation.",
      "description_length": 655,
      "index": 4458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.StackFrame",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a stack frame in a SARIF (Static Analysis Results Interchange Format) report, representing a single frame in a call stack during an analysis result. It includes fields for location, module name, thread identifier, memory address, offset, function parameters, and custom properties, all specific to error tracing in static analysis tools. The module provides serialization to and from JSON using `Yojson`, enabling integration with tools that consume or generate SARIF-formatted reports.",
      "description_length": 506,
      "index": 4459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Properties",
      "library": "frama-c-markdown-report.core",
      "description": "Handles the creation and parsing of SARIF property objects, specifically managing tag lists and custom key-value pairs. Works with `Yojson.Safe.t` for JSON deserialization and interacts with `Custom_properties.t` for extensible property storage. Used to construct and validate SARIF-compliant property structures with predefined default values and user-defined extensions.",
      "description_length": 372,
      "index": 4460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.SpecialLocations",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manipulates special location data within a SARIF report, specifically handling artifact locations and associated properties. It supports creating, serializing, and deserializing special location records to and from JSON. It is used to represent base paths and metadata for artifacts referenced in SARIF output, such as source code files or build outputs.",
      "description_length": 378,
      "index": 4461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Role",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a set of string constants representing file roles in SARIF (Static Analysis Results Interchange Format) version 2.1. It provides direct values like `analysisTarget`, `attachment`, and `responseFile` to classify file roles in static analysis reports. These values are used to specify the purpose or context of files when generating or parsing SARIF output in static analysis tools.",
      "description_length": 400,
      "index": 4462,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Location",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines and manipulates SARIF location data, including physical locations, logical names, messages, annotations, and custom properties. It provides functions to construct, convert to JSON, and parse from JSON SARIF location objects, along with a default template and creation from Frama-C CIL locations. It is used to represent and report source code issue locations in SARIF output for static analysis tools.",
      "description_length": 421,
      "index": 4463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_level",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines string-based enumerated values representing result severities in a SARIF report, including `none`, `note`, `warning`, and `error`. It provides direct conversions to and from Yojson for JSON serialization and parsing. These values are used to classify the severity of analysis results in static code analysis tools.",
      "description_length": 334,
      "index": 4464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.RunAutomationDetails",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for constructing and serializing SARIF run automation details, including creating instances with optional fields like description, ID, GUID, and properties. It works with structured data types such as `Message.t`, `Properties.t`, and string identifiers to represent metadata about automated analysis runs. Concrete use cases include generating machine-readable reports for static analysis tools and integrating with CI/CD pipelines that consume SARIF-formatted output.",
      "description_length": 499,
      "index": 4465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.PhysicalLocation",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents the physical location information in a SARIF 2.1 report, including artifact reference, source region, and contextual region. It provides functions to construct, serialize, and convert physical location data from CIL locations. Use this module to map source code positions to structured SARIF output for static analysis tools.",
      "description_length": 348,
      "index": 4466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.PrintLibc",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a boolean configuration flag that controls the inclusion of libc-related details in reports, using a simple `t` type to represent the flag's state. It offers operations to toggle the flag, register update callbacks, and serialize its value, while integrating command-line parsing to let users control output generation. The flag directly affects Markdown report content by enabling or disabling libc-specific details. A child module complements this by defining structured data representations for libc-related information, providing `t` with equality, comparison, hashing, and pretty-printing functions to support detailed reporting and analysis.",
      "description_length": 667,
      "index": 4467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ReportingDescriptor",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete SARIF 2.1 reporting descriptor with support for serialization to and from JSON. It handles structured data including identifiers, descriptions, message strings, configurations, and relationships. Use this to construct and manipulate rule or result descriptors for static analysis reports in SARIF format.",
      "description_length": 335,
      "index": 4468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Custom_properties",
      "library": "frama-c-markdown-report.core",
      "description": "This module handles custom properties in the SARIF 2.1 schema, specifically mapping them to and from Yojson.Safe.t representations. It provides `of_yojson` and `to_yojson` functions for converting between JSON values and a dictionary structure of custom properties. Use this module when parsing or generating SARIF output that includes custom metadata, such as analysis extensions or tool-specific annotations.",
      "description_length": 410,
      "index": 4469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Notification",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a notification type aligned with the SARIF 2.1 schema, including structured fields for reporting analysis results. It supports serialization to and from JSON using `to_yojson` and `of_yojson`, enabling integration with JSON-based tooling. Concrete use cases include generating machine-readable error reports from static analysis tools and feeding diagnostic data into SARIF-compatible viewers.",
      "description_length": 413,
      "index": 4470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ArtifactLocationDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "Maps artifact locations by URI in a dictionary structure, enabling efficient lookups and management of file paths and descriptors in SARIF reports. Supports conversion to and from Yojson for serialization and parsing. Useful for tools that analyze or generate SARIF output, such as static analysis result aggregators or linters.",
      "description_length": 328,
      "index": 4471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Mdr_params.Verbose",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages integer command-line parameters with dynamic state control, supporting operations like incrementing, bounded updates, and customizable serialization, often used for configuring verbosity levels in analysis tools. It integrates with state management systems for cross-component synchronization and includes a child module that defines a rich data type for use in the Frama-C kernel, offering equality, comparison, hashing, and pretty-printing operations. The combined functionality allows for structured manipulation of verbose data, including runtime validation, deep copying, and type-safe interactions within Frama-C's analysis framework. Example uses include defining a verbosity parameter that enforces valid ranges and persists state across plugins while being displayed in user-facing reports.",
      "description_length": 819,
      "index": 4472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Version",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a single valid value `v2_1_0` representing the SARIF version 2.1.0 as a private string type, ensuring correct schema adherence. It provides serialization to and from Yojson for interoperability with JSON data. This module is used to specify and validate the version field in SARIF reports during JSON parsing and generation.",
      "description_length": 344,
      "index": 4473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Result_suppressionState",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a concrete type `t` representing the suppression state of a SARIF result, with values `suppressedInSource` and `suppressedExternally`. It provides serialization to and from JSON using `to_yojson` and `of_yojson`. This type is used to indicate whether a result was suppressed within the source code or by an external configuration in SARIF output.",
      "description_length": 366,
      "index": 4474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Rectangle",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for working with rectangular regions in a SARIF report, specifically handling floating-point coordinates and associated messages. It provides functions to convert these rectangles to and from JSON format using Yojson. Use cases include serializing and deserializing SARIF rectangles for storage or transmission.",
      "description_length": 342,
      "index": 4475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Invocation",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for constructing and serializing invocation records conforming to the SARIF 2.1 schema. It provides functions to create invocation values with optional fields such as command-line arguments, timestamps, exit codes, and artifact locations. Use cases include logging tool executions, capturing analysis environment details, and generating structured output for static analysis reporting.",
      "description_length": 416,
      "index": 4476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Driver",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides functions to construct and manipulate driver metadata compliant with the SARIF 2.1 schema. It supports creating driver records with optional fields such as version, download URI, and language, and includes serialization to and from JSON. It is used to represent analysis tool metadata in SARIF-formatted reports generated by OCaml-based static analysis tools.",
      "description_length": 380,
      "index": 4477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Output",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages output file paths using the `Frama_c_kernel.Filepath.t` type, offering operations to set, update, and validate paths while integrating with project state and command-line interfaces. It ensures valid output destinations for reports and supports project-specific customization. The child module introduces a structured data type for output values, enabling equality checks, comparison, hashing, and pretty-printing, which are used to maintain consistent, inspectable, and serializable output representations. Together, they provide a complete system for configuring, managing, and manipulating output paths and values within a project context.",
      "description_length": 662,
      "index": 4478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Replacement",
      "library": "frama-c-markdown-report.core",
      "description": "Handles replacements in SARIF output by specifying deleted regions and inserted content. Works with `Region.t` and `ArtifactContent.t` to represent code changes. Used to generate diff-like patches in static analysis reports.",
      "description_length": 224,
      "index": 4479,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Markdown_report.Sarif.Stack",
      "library": "frama-c-markdown-report.core",
      "description": "Handles structured representation of stack traces in SARIF 2.1 format. Operates on `t` records containing message, list of stack frames, and properties. Used to serialize and deserialize SARIF stack data to and from JSON, with default value construction.",
      "description_length": 254,
      "index": 4480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Session",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a specific session directory for a plugin, providing functions to retrieve or create directories and files within that session. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of the session directory. Concrete use cases include storing and accessing plugin-specific data during analysis, such as intermediate files or user configuration directories.",
      "description_length": 461,
      "index": 4481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Edge",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines operations for constructing and serializing SARIF edge objects, which represent directed connections between nodes in a graph structure. It provides functions to convert edge values to and from Yojson for data interchange. Use this module when building SARIF-compliant analysis reports that require graph-based representations of code paths or control flow.",
      "description_length": 377,
      "index": 4482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.Stubs",
      "library": "frama-c-markdown-report.core",
      "description": "This module organizes command-line parameters as mutable string lists, enabling value assignment, default tracking, alias registration, and synchronization with external systems like Frama-C. It supports structured data handling through customizable representations and deep copying, with submodules managing parameter categories, validation rules, and type-safe string operations. Users can define hierarchical parameter sets, group options under named categories like `@default`, enforce value constraints, and generate analysis reports with dynamically updated settings. Examples include configuring analysis pipelines, persisting user preferences, and bridging command-line inputs with internal logic through validated, aliased parameters.",
      "description_length": 743,
      "index": 4483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Notification_kind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a string-based enumerated type representing notification kinds in the SARIF 2.1 schema, specifically supporting values like `note`, `warning`, and `error`. It provides functions to convert between JSON representations and the module's type, ensuring compatibility with SARIF standards. This module is used to classify the severity of notifications in static analysis reports.",
      "description_length": 395,
      "index": 4484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Json_dictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module converts between a dictionary structure in the SARIF 2.1 schema and Yojson representations. It supports parsing and serializing dictionaries using the Yojson.Safe.t type, enabling integration with JSON-based SARIF reporting tools. Use cases include loading SARIF dictionaries from JSON files and exporting analysis results to SARIF-compliant JSON.",
      "description_length": 359,
      "index": 4485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.WebRequest",
      "library": "frama-c-markdown-report.core",
      "description": "Handles construction and serialization of SARIF web request data structures. It provides functions to create, convert to JSON, and parse from JSON SARIF-compliant web request objects that include fields like HTTP method, headers, parameters, and body content. Useful for generating SARIF output that represents HTTP interactions in static analysis tools.",
      "description_length": 354,
      "index": 4486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params.State_dir",
      "library": "frama-c-markdown-report.core",
      "description": "This module manages a user-defined directory path for storing state information, providing operations to set, retrieve, and check the directory status. It works with file paths represented as `Frama_c_kernel.Filepath.t`, supporting both directory and file access within that path. Concrete use cases include initializing a working directory for plugin-generated files and ensuring consistent access to state files across different parts of the plugin.",
      "description_length": 451,
      "index": 4487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.Tool",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a tool record that includes a driver component, providing functions to create, serialize, and deserialize tool instances. It works with the `Markdown_report.Sarif.Driver.t` type to represent static analysis tools in SARIF format. Use this module to construct and manipulate SARIF tool objects, such as when generating reports from code analysis tools.",
      "description_length": 371,
      "index": 4488,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Sarif.MultiformatMessageStringDictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module represents a dictionary mapping string keys to `MultiformatMessageString` values, adhering to the SARIF 2.1 schema. It provides functions to convert between JSON (`Yojson.Safe.t`) and the dictionary type, ensuring proper serialization and deserialization. It is used to handle multilingual or multi-format diagnostic messages in SARIF output.",
      "description_length": 354,
      "index": 4489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Graph_dictionary",
      "library": "frama-c-markdown-report.core",
      "description": "This module implements a dictionary mapping string keys to SARIF graph structures, supporting serialization and deserialization via YoJSON. It provides operations to convert between in-memory representations and JSON data using `of_yojson` and `to_yojson`. This is used to process and generate SARIF-formatted reports containing graph data, such as call graphs or data flow paths in static analysis tools.",
      "description_length": 405,
      "index": 4490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.Attachment",
      "library": "frama-c-markdown-report.core",
      "description": "Handles serialization and deserialization of SARIF attachment data to and from JSON. Works with SARIF message, artifact location, region, and rectangle types. Used for embedding supplementary diagnostic information in SARIF-formatted reports.",
      "description_length": 242,
      "index": 4491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif.ColumnKind",
      "library": "frama-c-markdown-report.core",
      "description": "This module defines a single type `t` representing the valid string values for column kinds in the SARIF 2.1 schema. It includes functions to convert values to and from JSON, ensuring compatibility with the schema's expected formats. The predefined values `utf16CodeUnits` and `unicodeCodePoints` correspond to specific column counting strategies used in SARIF output for source code analysis tools.",
      "description_length": 399,
      "index": 4492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif",
      "library": "frama-c-markdown-report.core",
      "description": "This module provides a comprehensive OCaml representation of the SARIF 2.1 schema, enabling creation, manipulation, and JSON serialization of static analysis reports. It defines core data types such as `result`, `run`, `tool`, `location`, and `codeFlow`, along with operations to construct, validate, and serialize these structures to and from JSON using `Yojson`. Submodules handle specialized data including logical locations, stack traces, graph traversals, and version control metadata, supporting detailed error reporting, code flow analysis, and integration with external tools. Examples include encoding analysis results with suppression states, representing file changes as structured replacements, and serializing thread flows for diagnostic tools.",
      "description_length": 757,
      "index": 4493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_register",
      "library": "frama-c-markdown-report.core",
      "description": "Registers the main entry point for a plug-in, handling initialization and activation. Works with plug-in modules and their associated metadata. Used to define and expose the core functionality of a plug-in when it is loaded into the system.",
      "description_length": 240,
      "index": 4494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markdown_report.Md_gen",
      "library": "frama-c-markdown-report.core",
      "description": "This module generates Markdown reports in either draft or final form based on a boolean flag, using internal data structures from the Eva_info submodule to collect and format evaluation data. It dynamically creates structured textual reports from analysis results, supporting use cases like summarizing Eva's coverage and domain configurations during active analysis. The module combines direct control over report generation with specialized functions for content creation, enabling precise and flexible report assembly. Specific examples include generating coverage summaries and domain reports based on Eva's current state.",
      "description_length": 626,
      "index": 4495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Sarif_gen",
      "library": "frama-c-markdown-report.core",
      "description": "Generates a SARIF JSON object representing analysis results. Works with internal data structures modeling code analysis findings and source locations. Useful for exporting static analysis output in a standardized format for integration with tools like GitHub Code Scanning.",
      "description_length": 273,
      "index": 4496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Parse_remarks",
      "library": "frama-c-markdown-report.core",
      "description": "This module parses skeleton files to extract manually written comments associated with specific sections of a report. It maps string identifiers (section anchors) to lists of Markdown elements, enabling structured insertion of custom content into generated reports. Use it to enrich automated reports with curated explanations or annotations tied to specific analysis points.",
      "description_length": 375,
      "index": 4497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report.Mdr_params",
      "library": "frama-c-markdown-report.core",
      "description": "This module coordinates command-line configuration and validation for a string-based generator, managing value persistence, alias resolution, and state notifications across structured Markdown report elements like sections, tables, and code blocks. It supports operations for parsing user settings, validating function names, transforming inputs, and assembling customizable reports with consistent state updates, while child modules handle specific concerns such as directory paths, integer parameters, file options, and boolean flags. Examples include dynamically adjusting log levels, enforcing valid date formats, restricting input to predefined options, and generating parameterized reports from user-defined configurations. Together, the module and its submodules provide a cohesive system for configuring, tracking, and serializing analysis parameters with rich metadata, observability hooks, and integration into Frama-C's project system.",
      "description_length": 946,
      "index": 4498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markdown_report",
      "library": "frama-c-markdown-report.core",
      "description": "This module assembles a structured reporting system that combines Markdown and SARIF 2.1 outputs for static analysis results. It supports creation and manipulation of analysis data through types like `result`, `run`, and `codeFlow`, and enables JSON serialization via `Yojson`, while also parsing skeleton files to inject custom Markdown content into reports. The system handles command-line configuration with validation and state management, dynamically generating coverage summaries, domain reports, or SARIF exports based on Eva's analysis state. Specific use cases include encoding suppression states, formatting file changes as structured replacements, and serializing thread flows for diagnostic tools.",
      "description_length": 709,
      "index": 4499,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values that represent string-based command-line parameters. It supports checking membership of project-related values and provides deep copying to ensure no shared state. Concrete use cases include managing and manipulating string parameters in a slicing context, such as handling user input or configuration settings.",
      "description_length": 410,
      "index": 4500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for comparing, hashing, and pretty-printing values that represent string parameters in a command-line interface. It supports checking membership based on project properties, deep copying, and provides descriptors for type and structural representation. Concrete use cases include managing and manipulating string-based configuration options that need to be compared, stored, or displayed in a user-friendly format.",
      "description_length": 462,
      "index": 4501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based selection parameters in a slicing context. It supports operations like equality checks, comparison, hashing, and pretty printing, along with deep copying and project membership testing. It is used to represent and manipulate string values that correspond to selection criteria in command-line interfaces or configuration systems.",
      "description_length": 386,
      "index": 4502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based loop variable selections in a slicing context. It provides standard operations like equality, comparison, hashing, and pretty-printing for this type, along with deep copying and project membership checks. It is used to represent and manipulate loop variable identifiers as string values within the slicing parameter framework.",
      "description_length": 383,
      "index": 4503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for string-based slicing parameters with operations for equality, comparison, hashing, and pretty printing. It supports checking membership within projects, deep copying, and provides descriptors for type representation. It is used to handle and manipulate string parameters in slicing configurations, particularly for static analysis tasks involving project-specific values.",
      "description_length": 407,
      "index": 4504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based loop invariant selection parameters in a slicing context. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of these parameters, along with descriptors for type and structure. It is used to manage and query string representations of loop invariants during static analysis.",
      "description_length": 378,
      "index": 4505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for handling string-based threat selection parameters in a slicing context. It supports operations for equality checking, comparison, hashing, pretty printing, and deep copying, ensuring robust manipulation of threat identifiers. It is used to represent and manage command-line parameters for slicing operations in static analysis tools like Frama-C.",
      "description_length": 382,
      "index": 4506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based collection parameters in command-line options, supporting operations like equality checks, comparison, hashing, and pretty printing. It works with string values representing collection elements, providing precise type handling for parameter parsing and validation. Concrete use cases include managing user-specified string sets for slicing criteria, ensuring correct parsing and consistent representation across different execution contexts.",
      "description_length": 498,
      "index": 4507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based command line parameters in a slicing context. It provides operations for equality checks, comparison, hashing, pretty printing, and deep copying of parameter values. It is used to manage and manipulate string representations of slicing options within the Frama-C framework.",
      "description_length": 330,
      "index": 4508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.As_string.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype for handling string-based collection parameters in command-line options, supporting operations like equality checks, comparison, hashing, and pretty-printing. It works with string values representing collections and includes functions for project membership testing and deep copying. Concrete use cases include parsing and manipulating command-line arguments that specify sets of string values.",
      "description_length": 425,
      "index": 4509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-valued command-line parameters with validation, value constraints, and dynamic behavior customization, working with `type t = string` to enforce validity, restrict inputs, and support alias handling. It allows defining parameters that accept only predefined values, validate against naming rules, or trigger actions on change, such as restricting function names or mapping user inputs to internal string representations. The child module enhances this by handling string-based collections, supporting operations like equality, comparison, and hashing, ensuring consistent parsing and representation of string sets used for filtering or grouping. Together, they enable building robust CLI interfaces that validate, transform, and integrate string parameters with program logic.",
      "description_length": 803,
      "index": 4510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for handling slicing parameters in command-line configurations. It supports deep copying and membership checks over project skeletons, ensuring values are uniquely named and described. The type is used to represent and manipulate parameter configurations in a structured and type-safe manner.",
      "description_length": 418,
      "index": 4511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl.Make",
      "library": "frama-c-slicing.core",
      "description": "This module implements a hash table data structure specialized for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty-printing. It supports deep copying, membership testing with project functions, and integrates structural descriptions for type representation. Concrete use cases include managing collections of annotated or marked values with efficient lookups and maintaining unique typed descriptors for analysis frameworks.",
      "description_length": 483,
      "index": 4512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically used to represent and manipulate values in a slicing context. It supports checking membership based on project conditions and provides deep copying to ensure value independence. Concrete use cases include managing loop variable selections during static analysis, where unique identification and structural comparison of data are required.",
      "description_length": 455,
      "index": 4513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-valued command-line parameters with support for validation, alias resolution, and state synchronization. It defines core operations for comparing, hashing, and pretty-printing string-based values, enabling use cases like dynamic argument parsing and configuration systems. The module supports checking membership in predefined sets, deep copying to avoid shared state, and change hooks for reactive updates. Example uses include validating user input against allowed values and synchronizing parameter state across different parts of an application.",
      "description_length": 576,
      "index": 4514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-valued command-line parameters with support for validation, aliases, and custom serialization, operating within a structured parameter system. It handles string collections through a dedicated data type, enabling operations like membership testing, comparison, and pretty-printing, while also supporting predefined value sets and dynamic configuration workflows. Users can define parameters that accept only specific strings, map inputs through aliases, or represent multi-value options like comma-separated lists. Example uses include validating user-provided options against function names and persisting string-based configurations with controlled formatting.",
      "description_length": 689,
      "index": 4515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters with validation, alias handling, and state change hooks, organizing them into structured configurations for tasks like CLI option parsing. It defines a core data type for string parameters with operations for comparison, hashing, and pretty printing, while supporting membership checks, deep copying, and type descriptors. Child modules extend this foundation to handle slicing parameters and project-specific validation logic, enabling use cases such as static analysis configurations and function identifier checks. Examples include registering allowed string values, validating inputs against project rules, and serializing parameters for logging or debugging.",
      "description_length": 720,
      "index": 4516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters with constrained value sets, supporting validation, alias resolution, and dynamic dispatch based on string inputs. It provides data types for selection parameters and operations for equality, comparison, hashing, and serialization, enabling use cases like whitelisted configuration options and runtime function mapping. The module handles both individual strings and string lists, with support for deep copying, project membership testing, and custom string representations. Submodules enhance these capabilities for specific contexts such as slicing and selection logic.",
      "description_length": 628,
      "index": 4517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl.Key",
      "library": "frama-c-slicing.core",
      "description": "This module defines a key type for a hash table used in a slicing context, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports data types involving project-specific values, allowing checks for project membership and deep copying to avoid shared references. Concrete use cases include managing and comparing keys that represent slicing marks within a hash table structure.",
      "description_length": 418,
      "index": 4518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map.Make",
      "library": "frama-c-slicing.core",
      "description": "This module implements a map structure for values of type `Data.t`, providing standard operations including equality, comparison, hashing, and pretty printing. It supports deep copying, membership checks over project skeletons, and exposes type descriptors for integration with Frama-C's kernel. Concrete use cases include managing and manipulating collections of analysis data indexed by marks, with efficient lookups and structural comparisons.",
      "description_length": 446,
      "index": 4519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map.Key",
      "library": "frama-c-slicing.core",
      "description": "This module defines a key type for maps used in a slicing context, providing standard operations like equality, comparison, hashing, and pretty-printing. It supports working with a specific key structure that includes project membership checks and deep copying. Concrete use cases include managing and comparing keys in map-based data structures for program slicing, where keys may contain project-specific information.",
      "description_length": 419,
      "index": 4520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with custom accessors and dependencies. Use cases include configuring how parameter collections behave in different contexts, such as enabling all parameters by default or restricting them to an explicit set.",
      "description_length": 401,
      "index": 4521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line parameters within a code analysis tool. It supports structured data representation with a descriptor and a list of representative values, enabling type-safe manipulation and inspection. The type is designed for deep copying and project membership checks, facilitating its use in configuration and analysis workflows where project-specific values must be validated or transformed.",
      "description_length": 516,
      "index": 4522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-valued command-line parameters with validation, state persistence, and metadata support, enabling controlled input for configuration flags and function identifiers. It provides data types and operations for defining allowed values, checking valid C-ified function names, and handling aliases or deprecation warnings, using string lists to enforce validation rules across projects. The child module extends this functionality to handle string-based loop invariant selection parameters, offering equality checks, comparison, hashing, and pretty printing for static analysis contexts. Together, they support precise string parameter management from command-line interfaces to low-level analysis routines.",
      "description_length": 728,
      "index": 4523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-valued command-line parameters with support for validation, aliases, and serialization. It provides data types for representing string parameters with operations for comparison, hashing, and pretty-printing, along with state management features like value change hooks and constraint enforcement. Submodules enhance these capabilities by enabling structural manipulation, type descriptors, and project-aware membership checks. Example uses include enforcing valid function names, tracking configuration options, and customizing how string parameters are displayed or stored.",
      "description_length": 601,
      "index": 4524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages parameter categories for a command-line collection, using `Frama_c_kernel.Parameter_category.t` as the underlying type. It supports operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with control over their behavior in positive and negative contexts. Use cases include configuring slicing parameters through named categories that influence how command-line options are interpreted and applied.",
      "description_length": 467,
      "index": 4525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages command-line parameters with string values, supporting validation, dynamic updates, and customizable serialization. It handles individual strings and string lists, enabling use cases like enum-like input restrictions and runtime argument transformations. A key data type represents string-based loop variable selections, offering equality checks, comparison, hashing, and pretty-printing for use in slicing contexts. Together, the module and its submodules provide a cohesive system for parsing, validating, and manipulating string parameters with rich metadata and extensible behavior.",
      "description_length": 606,
      "index": 4526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.SliceUndef.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for managing slicing parameters in the context of undefined behavior analysis. It supports equality checks, comparison, hashing, pretty printing, and deep copying of parameter values, along with membership testing for project skeletons. These capabilities enable precise configuration and manipulation of slicing modes within static analysis workflows.",
      "description_length": 399,
      "index": 4527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Calls.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for managing representable values within a slicing context, including equality, comparison, hashing, and pretty-printing. It works with structured descriptors and project skeletons to support precise data representation and traversal. Concrete use cases include tracking and comparing data structures during program slicing, ensuring deep copies and project-aware membership checks.",
      "description_length": 429,
      "index": 4528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based command-line parameters with validation, state tracking, and alias handling, operating on strings and string lists to support strict input validation and dynamic configuration in CLI tools. It provides data types and operations for defining allowed values, enforcing constraints, and serializing configurations, with support for update hooks and persistence control. The child module enhances this functionality by enabling equality checks, comparison, and pretty printing of parameter values, particularly in slicing contexts. Together, they allow defining a validated string option, tracking its changes, and serializing its state, such as handling command-line flags with restricted value sets and dynamic updates.",
      "description_length": 750,
      "index": 4529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically used to represent and manipulate values in a command line parameter context. It includes functions for checking membership in projects, creating deep copies, and exposing representants of the type's descriptor. The module is used to handle structured data passed as parameters in a static analysis tool, ensuring values are uniquely named, compared, and stored correctly.",
      "description_length": 488,
      "index": 4530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom accessors and dependencies. Use cases include configuring how different groups of parameters are interpreted and activated in command-line interfaces.",
      "description_length": 346,
      "index": 4531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, along with utilities for project membership checks and deep copying. It works with a structured type `t` that includes a name, descriptor, packed descriptor, and representants list. Concrete use cases include managing and manipulating structured data representations in static analysis tools, particularly for slicing operations in Frama-C.",
      "description_length": 444,
      "index": 4532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of loop variables used in slicing parameters. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with support for accessors and dependencies. Use cases include configuring how loop variables are selected and interpreted in slicing commands, particularly in relation to default and global behaviors.",
      "description_length": 412,
      "index": 4533,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with specific accessors and dependencies, allowing precise control over parameter behavior. Use cases include configuring how command-line options are interpreted and grouped, particularly for enabling or disabling sets of parameters collectively.",
      "description_length": 440,
      "index": 4534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages parameter categories for a command-line interface, specifically handling special categories like `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with custom accessors and dependencies, allowing precise control over parameter behavior in different contexts. Use cases include configuring slicing parameters with dynamic category logic and managing default or global parameter sets in analysis tools.",
      "description_length": 479,
      "index": 4535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Callers.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for representing and manipulating slicing parameters in a static analysis context. It includes functionality for checking membership within projects, deep copying values, and exposing type information through descriptors and representants. Concrete use cases include managing and comparing abstract representations of program elements during slicing, enabling precise data flow analysis and transformation.",
      "description_length": 532,
      "index": 4536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.KeepAnnotations.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing and comparing datatype representations, including equality, comparison, and hashing. It provides access to type descriptors, packed descriptors, and representants, along with utilities for pretty printing and deep copying. It is used to handle and query annotated datatypes in a slicing context, ensuring accurate type representation and project-specific membership checks.",
      "description_length": 417,
      "index": 4537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of threat selection parameters in slicing configurations. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, using names, accessors, and dependency lists. These categories control how threat parameters are interpreted and activated in command line configurations.",
      "description_length": 377,
      "index": 4538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of values used as command-line parameters. It provides operations to create, enable, and configure categories such as `@none`, `@default`, and `@all`, each controlling how selections are interpreted. These categories are tied to a specific element type and use accessors to link with internal states, allowing fine-grained control over parameter behavior in different contexts.",
      "description_length": 437,
      "index": 4539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for a specific data type used in command-line parameter handling, including equality, comparison, hashing, and pretty-printing. It works with a custom type `t` that represents parameter values, supporting deep copying and membership checks over project skeletons. Concrete use cases include managing and comparing parameter values in a slicing context, ensuring unique identification and structured representation.",
      "description_length": 445,
      "index": 4540,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat.As_string",
      "library": "frama-c-slicing.core",
      "description": "This module manages command-line string parameters with validation, default handling, and change tracking, operating on string data constrained by allowed values or function checks. It supports serialization hooks and dynamic updates, enabling integration with function dispatch systems and runtime configuration adjustments. The child module extends this functionality to handle threat selection parameters in slicing contexts, providing equality, comparison, and pretty printing for robust manipulation of threat identifiers. Together, they enable precise CLI-driven configuration in static analysis tools like Frama-C, where parameters require strict validation and structured representation.",
      "description_length": 695,
      "index": 4541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for managing annotated slice parameters in a slicing context. It supports equality checks, comparison, hashing, and pretty-printing for values of this type, along with deep copying and membership testing over project skeletons. It is used to represent and manipulate slice annotations in a way that ensures structural integrity and supports persistence across different slicing operations.",
      "description_length": 436,
      "index": 4542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in command-line parameters within a slicing context. It supports structured data representation with a descriptor, packed descriptor, and a list of representatives, enabling robust type handling. Concrete use cases include managing and validating parameter values in static analysis tools where deep copying and project membership checks are required.",
      "description_length": 472,
      "index": 4543,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It allows creating, enabling, and modifying categories with custom names, accessors, and dependencies, controlling how parameters are interpreted in different contexts. Use cases include configuring parameter behavior in static analysis tools, where categories determine which functions or options are activated based on command-line input.",
      "description_length": 469,
      "index": 4544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for use in command-line parameter handling. It includes utilities for checking membership within project skeletons and performing deep copies, ensuring no shared references. The type supports structured descriptors and representants, facilitating integration with Frama-C's kernel libraries for static analysis tools.",
      "description_length": 443,
      "index": 4545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess.Category",
      "library": "frama-c-slicing.core",
      "description": "This module defines and manages categories for a collection of command-line parameters, such as `@none`, `@default`, and `@all`. It provides operations to create, modify, and enable categories with custom accessors and dependencies, allowing precise control over parameter behavior. Use cases include configuring how groups of parameters are interpreted and activated in command-line interfaces.",
      "description_length": 395,
      "index": 4546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty printing, tailored for handling loop invariant selection parameters in a slicing context. It supports structured data manipulation with deep copying, membership testing over projects, and descriptors for type representation. Concrete use cases include managing and querying loop invariant selections during static analysis, ensuring precise handling of project-specific data within slicing operations.",
      "description_length": 494,
      "index": 4547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Debug.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type and operations for representing and manipulating slicing parameters in a debug context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and membership testing over project skeletons. The type is used to store and compare representants of a structured descriptor, supporting precise slicing operations in static analysis workflows.",
      "description_length": 412,
      "index": 4548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ProjectName.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a structured data type with operations for equality, comparison, hashing, and pretty printing, specifically tailored for representing and manipulating project-related data in static analysis. It includes functions to check membership of project values, perform deep copies, and work with type descriptors for serialization and introspection. Use cases include managing project configurations, analyzing program slices, and persisting structural data across analysis sessions.",
      "description_length": 495,
      "index": 4549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.WrAccess",
      "library": "frama-c-slicing.core",
      "description": "This module manages string sets through command-line parameters, supporting insertion, membership checks, iteration, and state persistence over `Frama_c_kernel.Datatype.String.Set.t`. It integrates parameter validation, aliases, and serialization with structured manipulation via submodules that handle type descriptors, project-aware operations, and category-based configuration. You can enforce valid function names, customize parameter display, activate parameter groups like `@all`, and perform slicing operations using structured data representations. The module enables dynamic configuration management and project-specific state tracking through both direct API calls and rich submodule extensions.",
      "description_length": 705,
      "index": 4550,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Assert",
      "library": "frama-c-slicing.core",
      "description": "This module coordinates state-aware command-line parameters using set-based operations on `kernel_function` elements, enabling dynamic curation of function collections aligned with project state. It integrates string-valued parameters with validation and alias resolution, supports structured slicing configurations with equality and comparison, and manages logical categories like `@none` and `@all` for contextual parameter control. You can define restricted function sets, validate and transform string inputs, enforce unique naming in slicing parameters, and activate category-specific behaviors in analysis workflows. The combination of direct set operations and submodule capabilities ensures precise, type-safe manipulation of complex CLI configurations.",
      "description_length": 761,
      "index": 4551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.KeepAnnotations",
      "library": "frama-c-slicing.core",
      "description": "This module manages a mutable boolean state to control annotation retention during code slicing, offering operations to set, retrieve, and observe changes to this flag alongside lifecycle hooks, default values, and command-line interface integration. It operates on slicing configurations and interacts with annotated data structures, such as abstract syntax trees, to preserve metadata during transformation. The child module enhances this functionality by providing operations for managing and comparing datatype representations, including equality, comparison, and hashing, which are used to handle and query annotated datatypes in a slicing context. Together, they enable selective annotation preservation, such as maintaining documentation comments or semantic markers in sliced code outputs, while ensuring accurate type representation and project-specific membership checks.",
      "description_length": 881,
      "index": 4552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Callers",
      "library": "frama-c-slicing.core",
      "description": "This module manages a boolean state with support for command-line flags, default values, and serialization, enabling dynamic configuration through hooks and aliases. It defines a boolean type `t` with operations to set, retrieve, and monitor changes, ensuring consistent slicing mode behavior across sessions. The child module enhances this system by introducing a rich data type for slicing parameters, supporting equality checks, comparison, hashing, and pretty printing, all tailored for static analysis. Together, they allow precise control and manipulation of analysis settings, such as enabling caller-sensitive slicing, while facilitating data flow analysis through structured, project-aware representations.",
      "description_length": 715,
      "index": 4553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Hashtbl",
      "library": "frama-c-slicing.core",
      "description": "This module provides a polymorphic hash table for key-value storage with `SlicingTypes.Sl_mark.t` keys, supporting imperative operations like insertion, deletion, and in-place filtering, along with ordered iteration using custom comparators. Its child modules specialize the hash table for `Data.t` values and define key types for slicing contexts, enabling efficient lookups, deep copying, and project-aware comparisons. It facilitates memoization, bulk sequence transformations, and statistics collection, with concrete applications in static analysis workflows for managing annotated values and unique typed descriptors. The combined interface supports both generic and type-specific operations, ensuring efficient value caching and ordered key processing in Frama-C's kernel.",
      "description_length": 779,
      "index": 4554,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Set",
      "library": "frama-c-slicing.core",
      "description": "This module offers a comprehensive ordered set abstraction for managing collections of `Sl_mark` elements, supporting efficient membership tests, ordered traversal, and set-theoretic operations like union and difference. It maintains elements in sorted order using a balanced tree representation, enabling range queries, nearest-element searches, and transformations like filtering or mapping while preserving uniqueness and order. Designed for applications in static analysis slicing, it facilitates tasks like tracking code annotations or dependency intervals where ordered, immutable sets with precise element comparison and sequence interconversion are required.",
      "description_length": 666,
      "index": 4555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Return",
      "library": "frama-c-slicing.core",
      "description": "This module manages set-valued command-line parameters with state tracking, value hooks, and serialization, centered around `Frama_c_kernel.Cil_datatype.Kf.Set.t` for precise function set manipulation. It supports membership checks, iteration, and folding over kernel functions, enabling dynamic configuration in static analysis tools. A child module enhances string-based CLI parameters with validation, aliases, and persistence, allowing for options like restricted-value flags with dynamic updates and tracked state changes. Another child module organizes parameters into categories such as `@none`, `@default`, and `@all`, supporting grouped activation and interpretation in CLI interfaces, while a third provides structured data handling with equality, comparison, and pretty-printing for robust parameter validation and representation in slicing contexts.",
      "description_length": 861,
      "index": 4556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Value",
      "library": "frama-c-slicing.core",
      "description": "This module manages string sets as command-line parameters with support for dynamic updates, default values, and project-specific state tracking. It centers around the string set type `t`, offering membership checks, iteration, and customizable serialization, while submodules extend its capabilities for constrained value sets, category management, and value comparison in slicing contexts. Operations include alias resolution, validation, category configuration, and deep copying, enabling structured argument parsing and dynamic configuration. Example uses include managing whitelisted options, mapping runtime functions, and controlling parameter behavior through `@none`, `@default`, and `@all` categories.",
      "description_length": 711,
      "index": 4557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Threat",
      "library": "frama-c-slicing.core",
      "description": "This module manages set-valued command-line parameters to control slicing behavior through threat selection, offering operations to manipulate, query, and serialize sets of `kernel_function` elements. It supports dynamic updates via hooks, alias resolution, and project-specific customization while integrating with Frama-C's kernel infrastructure for static analysis. The core data type represents structured command-line values with support for equality, comparison, hashing, and pretty-printing, enabling type-safe manipulation and deep copying. Submodules define threat categories like `@none`, `@default`, and `@all` for grouping and activating threat parameters, and manage string-based CLI inputs with validation, defaults, and change tracking, allowing precise configuration of analysis scope through command-line flags.",
      "description_length": 828,
      "index": 4558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Verbose.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type for representing slicing parameters with verbose output, supporting operations such as equality checking, comparison, hashing, and pretty printing. It works with structured data that includes type information, descriptors, and project-specific values, enabling precise slicing configurations. Concrete use cases include managing and manipulating slicing criteria in static analysis tools, particularly for tracking and comparing complex data structures across different analysis phases.",
      "description_length": 518,
      "index": 4559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.RdAccess",
      "library": "frama-c-slicing.core",
      "description": "This module manages string set options for command-line parameters, supporting assignment, default retrieval, change hooks, and serialization with alias resolution. It operates on a string set data type with standard operations like membership checks and iteration, and integrates with submodules for value validation, category management, and structured representation. The first submodule handles string-valued parameters with alias resolution and state synchronization, enabling input validation and reactive updates. The second submodule defines core data types with equality, comparison, and pretty-printing operations, while the third manages parameter categories for grouped behavior control, such as enabling or disabling sets of options.",
      "description_length": 746,
      "index": 4560,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.SliceUndef",
      "library": "frama-c-slicing.core",
      "description": "This module manages boolean flags within a state-tracking system, enabling dynamic control of analysis modes with support for change monitoring, serialization, and alias management. It provides operations to toggle flag states, register pre/post-update hooks, and synchronize transitions with external systems, such as Frama-C's project state manager. The associated data type allows precise manipulation of slicing parameters, supporting equality checks, comparison, hashing, and pretty printing. These features facilitate deep integration with static analysis workflows, enabling fine-grained control over undefined behavior analysis and project configuration.",
      "description_length": 662,
      "index": 4561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopInv",
      "library": "frama-c-slicing.core",
      "description": "This module manages set-based command-line parameters with change tracking, hook registration, and custom marshaling, supporting membership checks, element addition, and iteration for sets of `Kf.t` and `kernel_function` elements. Its category submodule handles parameter grouping and context-specific behavior, allowing creation and dependency management of categories like `@default` and `@all`. The string parameter submodule enforces validation and alias handling for configuration flags, while an extended variant supports loop invariant selection with equality checks and pretty printing. These components together enable structured configuration management from command-line input to static analysis routines, with support for serialization, dynamic state tracking, and project-specific queries.",
      "description_length": 802,
      "index": 4562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ExportedProjectPostfix.Datatype",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating structured data descriptors. It includes functions for equality checks, hashing, pretty printing, deep copying, and checking membership of project values within a data structure. The module is used to handle complex data representations in program analysis, particularly for slicing operations that require precise tracking and transformation of data structures.",
      "description_length": 456,
      "index": 4563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark.Map",
      "library": "frama-c-slicing.core",
      "description": "This module implements ordered associative maps keyed by slicing-specific mark types, supporting insertion, deletion, ordered traversal, and structural transformations. It provides efficient operations for range queries, reverse iteration, and merging, along with customizable pretty-printing and integration with analysis frameworks. The module includes a specialized data module for managing analysis values with equality, comparison, and deep copying, as well as a key module that defines slicing-aware keys with project membership checks and structural operations. Use cases include maintaining sorted indexed data, performing incremental updates, and reconstructing sequences in program slicing contexts.",
      "description_length": 709,
      "index": 4564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.SliceAnnot",
      "library": "frama-c-slicing.core",
      "description": "This module organizes string-based command-line parameters with structured validation, alias handling, and state change hooks, integrating category management and slicing-specific annotations. It provides core data types for string parameters and annotated slices, with operations for comparison, hashing, pretty printing, and membership checks, while supporting project-specific validation and configuration through categories like `@none`, `@default`, and `@all`. Child modules enable slicing parameter definitions, category manipulation via `Frama_c_kernel.Parameter_category.t`, and annotated slice management with structural integrity. Examples include registering allowed values, validating inputs against project rules, configuring slicing behavior through named categories, and serializing parameters for logging.",
      "description_length": 821,
      "index": 4565,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.LoopVar",
      "library": "frama-c-slicing.core",
      "description": "This module manages command-line parameters representing collections of loop variables for Frama-C's slicing plugin, combining set-based operations with category and string-based submodules for structured configuration. It supports adding, iterating, folding, and checking membership over loop variable sets, with utilities for serialization, aliasing, and persistent state. The first submodule provides core data types for slicing values with equality, comparison, and deep copy capabilities, while the second handles string parameters with validation and dynamic updates. The third submodule organizes loop variables into named categories like `@default` and `@all`, enabling fine-grained control over slicing behavior through parameter grouping and dependencies.",
      "description_length": 765,
      "index": 4566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select.Calls",
      "library": "frama-c-slicing.core",
      "description": "This module organizes command-line parameters as modifiable sets of `kernel_function` elements, supporting dynamic updates, membership checks, and predicate-based queries. It integrates string-valued parameters with validation and aliases, category-based parameter grouping with context-sensitive behavior, and a custom data type for structured descriptors with equality and hashing operations. Users can define parameters that accept only specific strings, group options into categories like `@default` or `@all`, and manage function sets with change hooks and custom serialization. Example workflows include tracking analysis targets, enforcing valid command-line inputs, and persisting configuration state with marshaled representations.",
      "description_length": 740,
      "index": 4567,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode.Calls",
      "library": "frama-c-slicing.core",
      "description": "This component manages a bounded integer parameter with support for dynamic validation, default values, and pre/post-update hooks, integrating with Frama-C's state management for session persistence and command-line exposure. It allows configuration of numeric values within a controlled range, with mechanisms for serialization, aliasing, and deprecation, making it suitable for tuning analysis parameters like iteration counts or slicing depths. The child module enhances this functionality by providing structured data representation with equality, comparison, and pretty-printing operations, enabling precise tracking and traversal of data structures during slicing. Together, they support project-aware configuration and deep data manipulation, ensuring consistency and extensibility in analysis workflows.",
      "description_length": 811,
      "index": 4568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Select",
      "library": "frama-c-slicing.core",
      "description": "This module manages set-based command-line parameters for static analysis tools, providing structured manipulation of string and function sets with support for membership checks, iteration, validation, and serialization. It centers around core data types like `Frama_c_kernel.Datatype.String.Set.t` and `Frama_c_kernel.Cil_datatype.Kf.Set.t`, enabling precise control over values through operations such as insertion, alias resolution, and category-based activation. Submodules handle parameter validation, category management, and state tracking, allowing use cases like restricting inputs to predefined options, grouping parameters under `@none` or `@all`, and dynamically updating configurations during analysis. Example applications include managing function whitelists, enforcing valid CLI inputs, and controlling slicing behavior through categorized threat sets.",
      "description_length": 868,
      "index": 4569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Request",
      "library": "frama-c-slicing.core",
      "description": "This module manages slicing operations in a program analysis context, providing functions to manipulate and combine slices, add call relationships, and handle selections. It works with data types such as `Slicing.Api.Slice.t` for slices, `Slicing.Api.Select.set` for selection sets, and `Frama_c_kernel.Cil_types.kernel_function` for function references. Concrete use cases include merging or splitting slices, propagating user-defined marks, adding call dependencies between slices, and maintaining persistent selections for analysis.",
      "description_length": 535,
      "index": 4570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Cache_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages a cache directory path for a plugin, providing functions to retrieve, set, and check the status of the directory. It works with file paths represented as `Frama_c_kernel.Filepath.t`, handling directory and file access with optional path creation. Concrete use cases include storing and retrieving cached analysis results or intermediate files in a structured directory.",
      "description_length": 389,
      "index": 4571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.Mode",
      "library": "frama-c-slicing.core",
      "description": "This module manages configurable analysis parameters using state-tracking types like booleans and bounded integers, supporting dynamic updates, command-line integration, and session persistence. It provides operations to set, retrieve, and observe changes to these parameters, along with data types that support equality, comparison, hashing, and pretty printing for precise analysis control. These capabilities enable use cases such as toggling annotation retention, adjusting slicing depth within valid ranges, and configuring caller-sensitive analysis modes while ensuring consistency across Frama-C's project state and static analysis pipelines.",
      "description_length": 649,
      "index": 4572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Verbose",
      "library": "frama-c-slicing.core",
      "description": "This module manages an integer parameter with adjustable min/max bounds, supporting incrementing values, range enforcement, and change monitoring through pre/post-update hooks. It integrates command-line metadata, default handling, and alias management for dynamic configuration, working with integer values constrained by range tuples. The child module defines a data type for slicing parameters with verbose output, supporting equality, comparison, hashing, and pretty printing, enabling precise configuration and manipulation of slicing criteria in static analysis tools. Together, they allow runtime adjustment and tracking of verbosity levels or thresholds while maintaining structured, comparable slicing configurations for interactive tools and analysis pipelines.",
      "description_length": 771,
      "index": 4573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.Api.Project",
      "library": "frama-c-slicing.core",
      "description": "This module manages slicing projects by providing operations to reset slicing state, modify slicing levels for functions, generate projects from existing slices, and visualize call graphs in DOT format. It works with kernel functions and projects, enabling precise control over slicing behavior and output. Use cases include rebuilding projects after slicing, customizing sliced function names, and debugging call relationships through direct or indirect invocation checks.",
      "description_length": 473,
      "index": 4574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Debug",
      "library": "frama-c-slicing.core",
      "description": "This module manages bounded integer parameters and structured slicing descriptors for debugging and configuration tasks. It supports operations like incrementing values within explicit min/max bounds, tracking state changes with customizable hooks, and defining structured parameter representations with comparison and persistence capabilities. The core integer parameters integrate with submodules that model slicing contexts, enabling precise static analysis workflows through typed descriptors with deep copying and membership testing. Example uses include enforcing CLI limits, configuring analysis thresholds, and maintaining project-specific state with structured, serializable parameters.",
      "description_length": 695,
      "index": 4575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_fct_slice",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for manipulating function slice data structures, including equality checks, comparison, hashing, and pretty-printing. It supports deep copying and provides utilities to inspect and traverse project-specific data within slices. Concrete use cases include analyzing and transforming function-level slices during static analysis, such as tracking dependencies or generating sliced call graphs.",
      "description_length": 421,
      "index": 4576,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingParameters.ExportedProjectPostfix",
      "library": "frama-c-slicing.core",
      "description": "This module provides utilities for managing string-valued parameters with validation and dynamic updates, supporting use cases such as command-line option parsing and project configuration tracking. It offers data types for strings and string lists, with operations for sanitization, function resolution, and serialization, along with hooks for callbacks on value changes. A child module enhances its capabilities by introducing structured data descriptors with equality, hashing, and membership operations, enabling precise data representation and transformation in program analysis. Together, they allow validated parameter handling combined with complex data structure manipulation, such as tracking and slicing structured project state during runtime.",
      "description_length": 755,
      "index": 4577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Share",
      "library": "frama-c-slicing.core",
      "description": "This module manages the configuration and retrieval of the `<dune-site-dir>` directory and its contained files and subdirectories. It provides functions to set, retrieve, and check the existence of the directory, as well as to locate specific files or subdirectories within it. Concrete use cases include resolving paths to plugin-specific resources stored under the site directory, such as configuration files or shared libraries.",
      "description_length": 431,
      "index": 4578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Session",
      "library": "frama-c-slicing.core",
      "description": "This module manages the session directory for a plugin, providing functions to retrieve or create directories and files within that session context. It works with file paths represented as `Frama_c_kernel.Filepath.t` and handles directory setup with optional path creation. Concrete use cases include storing and accessing session-specific data such as intermediate results or configuration files during plugin execution.",
      "description_length": 421,
      "index": 4579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_mark",
      "library": "frama-c-slicing.core",
      "description": "This module represents slicing marks with a core data type `t` that supports equality, comparison, hashing, and pretty printing, enabling precise tracking and manipulation of annotations during static analysis. It includes utilities for project membership checks, deep copying, and integration with set, map, and hash table structures for efficient storage and retrieval. The associated hash table module enables imperative key-value management with ordered iteration, while the set and map modules provide ordered collections and associative storage with slicing-aware keys, supporting operations like union, range queries, and custom traversal. Together, they facilitate tasks such as memoization, dependency tracking, and transformation of annotated code elements in slicing workflows.",
      "description_length": 788,
      "index": 4580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.ProjectName",
      "library": "frama-c-slicing.core",
      "description": "This module manages string-based project name configurations with validation, CLI parsing, and state mutation tracking, operating on strings and string lists to support dynamic updates and marshaling. It provides structured data representations with equality, comparison, and serialization operations, enabling precise manipulation and analysis of project values. You can use it to enforce naming constraints during slicing, handle user input with aliases, and maintain consistent project state across sessions. Submodules enhance these capabilities with type descriptors, deep copying, and membership checks for robust static analysis and data persistence.",
      "description_length": 657,
      "index": 4581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingSelect.Selections",
      "library": "frama-c-slicing.core",
      "description": "This module manages variable selection criteria in a slicing context using map-based structures keyed by variable identifiers. It provides operations to add selection entries, iterate over selections with side effects, and fold selections into aggregated values. Concrete use cases include tracking variables of interest during program slicing and accumulating slicing criteria across function calls.",
      "description_length": 400,
      "index": 4582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Mark",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions to construct, compare, and inspect mark values that represent the role of elements in slicing results, such as whether they are data, control, or address-related. It supports concrete use cases like filtering visible elements, determining dependency relationships in sliced code, and marking statements for GUI visualization based on their involvement in computations. The marks are used to control visibility and selection transparency in slicing output.",
      "description_length": 486,
      "index": 4583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.Config_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages the configuration directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of a user directory. Concrete use cases include initializing plugin-specific storage locations and accessing configuration files during analysis.",
      "description_length": 421,
      "index": 4584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Fct_user_crit",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for managing and comparing function user criteria in a slicing context. It provides equality, comparison, hashing, and pretty-printing functions for the `Fct_user_crit.t` type, along with utilities for checking membership based on project criteria and performing deep copies. It is used to handle criteria that determine how functions are treated during slicing operations.",
      "description_length": 404,
      "index": 4585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Select",
      "library": "frama-c-slicing.core",
      "description": "This module enables constructing and modifying selection sets to specify which program elements\u2014such as statements, variables, PDG nodes, annotations, and control dependencies\u2014persist during slicing, with options to retain surrounding context like control flow. It operates on structured data including functions, statements, labels, and dynamic type information (`dyn_t`, `dyn_set`), supporting use cases like isolating specific function returns, variable dependencies, or PDG nodes while preserving required contextual relationships.",
      "description_length": 535,
      "index": 4586,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_select",
      "library": "frama-c-slicing.core",
      "description": "This module defines operations for a specific data type used in slicing, including equality, comparison, hashing, and pretty-printing. It provides utilities to check membership based on project properties, perform deep copies, and manage type descriptors for structured values. Concrete use cases include representing and manipulating slice selection criteria in static analysis, such as filtering or comparing slice elements based on project-specific attributes.",
      "description_length": 463,
      "index": 4587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes.Sl_project",
      "library": "frama-c-slicing.core",
      "description": "This module defines a data type `t` representing project-related values with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project skeletons. Use cases include managing and manipulating project data with precise semantic comparisons and efficient storage.",
      "description_length": 327,
      "index": 4588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters.State_dir",
      "library": "frama-c-slicing.core",
      "description": "This module manages the state directory for a plugin, providing functions to retrieve, set, and check the existence of a specific directory path. It works with string identifiers and file paths represented by `Frama_c_kernel.Filepath.t`, handling directory and file access within the plugin's state context. Use cases include initializing plugin-specific storage, accessing persisted data, and ensuring directory structures exist before file operations.",
      "description_length": 453,
      "index": 4589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api.Slice",
      "library": "frama-c-slicing.core",
      "description": "This module manages function slices in a control flow graph, providing operations to create, remove, and query slices associated with kernel functions. It supports data types such as `t` for representing slices, and integrates with statements, labels, and variable information to retrieve associated marks. Concrete use cases include analyzing function dependencies, tracking control flow impacts, and debugging slice relationships in static analysis.",
      "description_length": 451,
      "index": 4590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingProject",
      "library": "frama-c-slicing.core",
      "description": "This module manages the creation, manipulation, and analysis of function slices within a slicing project. It provides operations to create, merge, split, and remove slices, as well as apply filters and traverse slice relationships. Key data types include `fct_slice` for representing slices and `criterion` for defining filtering conditions. Concrete use cases include slicing source code by function, refining slices through filtering, and visualizing slice structures via pretty-printing.",
      "description_length": 490,
      "index": 4591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingInternals",
      "library": "frama-c-slicing.core",
      "description": "This module defines internal data structures and operations for managing function slicing in a program analysis context. It handles types like `mark`, `pdg_mark`, and `fct_info` to track slicing metadata, including call dependencies and visibility. Concrete use cases include storing computed slices, determining slicing strategies, and maintaining call graph information for precise interprocedural analysis.",
      "description_length": 409,
      "index": 4592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingTypes",
      "library": "frama-c-slicing.core",
      "description": "This module provides core abstractions for program slicing in C analysis, centered around projects, function criteria, slicing marks, and slice data structures. It enables precise tracking of dependencies, variable usage, and function call relationships through typed representations that support equality, comparison, hashing, and pretty-printing. Functionality spans managing slice annotations with sets, maps, and hash tables, analyzing function-level slices with deep inspection, and defining project-specific criteria for slicing operations. Use cases include static analysis tasks like dependency tracking, sliced call graph generation, and transformation of annotated code elements using structured, slicing-aware data.",
      "description_length": 726,
      "index": 4593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingMacros",
      "library": "frama-c-slicing.core",
      "description": "This module provides utilities for manipulating and inspecting slicing data structures like `fct_info`, `fct_slice`, and `stmt`, enabling operations to extract variables, kernel functions, and PDGs, as well as compare call information across statements. It supports internal slicing infrastructure tasks such as level modification and analysis, with a focus on querying and transforming function call relationships. Specific use cases include normalizing slicing configurations and validating structural equivalences during analysis.",
      "description_length": 533,
      "index": 4594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Fct_slice",
      "library": "frama-c-slicing.core",
      "description": "This module enables analysis and transformation of function slices in program dependence graphs through operations like merging slices, applying dependency marks to statements, resolving call changes, and extracting slice metadata. It operates on structured representations of functions (`fct_slice`, `fct_info`), program statements (`stmt`), and dependency annotations (`pdg_mark`), supporting tasks such as impact analysis, code refactoring, and dependency tracking during software maintenance.",
      "description_length": 496,
      "index": 4595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingParameters",
      "library": "frama-c-slicing.core",
      "description": "This module orchestrates slicing parameter configuration through a suite of utilities for managing warnings, command-line interfaces, and session state, while coordinating with submodules that handle structured data, file paths, and bounded parameters. It centers on data types like `warn_category`, `Log.warn_status`, and `Cmdline.Group.t` for warning control, alongside submodules that manipulate sets, integers, strings, and file paths to enforce constraints, track changes, and persist configurations. You can use it to categorize and filter warnings, configure slicing depth with bounds-checked integers, manage project names with validation, and control session directories for storing intermediate results. Submodules extend this functionality with set-based CLI parameters, cache management, and structured descriptors that support dynamic updates, deep copying, and serialization for precise static analysis workflows.",
      "description_length": 927,
      "index": 4596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingActions",
      "library": "frama-c-slicing.core",
      "description": "This module provides operations for constructing slicing criteria (e.g., function entries, call sites, user-defined selections) and translating them into structured representations that capture data/control dependencies in program dependence graphs (PDGs). It manipulates PDG nodes, statement metadata, and selection markers (`sl_mark`, `select`) to define slicing boundaries, while also supporting diagnostic output for debugging criteria and selections. Key use cases include specifying program slicing targets and logging intermediate structures during analysis.",
      "description_length": 565,
      "index": 4597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Api",
      "library": "frama-c-slicing.core",
      "description": "This module configures slicing behavior through mode settings and provides core operations to manipulate slices\u2014such as splitting, merging, and copying\u2014while integrating project-specific parameters for precise analysis. It works with slice data structures and kernel functions, enabling tasks like refining analysis results by merging partial slices or isolating code paths through selective splitting. Submodules handle slice combination, selection persistence, mark construction, project management, and control flow integration, supporting use cases such as propagating marks, customizing sliced function names, filtering visible elements, preserving context during selection, and analyzing function dependencies in CFGs. Key data types include `Slice.t`, `Select.set`, `kernel_function`, and mark values that determine element roles in slicing output.",
      "description_length": 855,
      "index": 4598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingMarks",
      "library": "frama-c-slicing.core",
      "description": "This module handles metadata operations for program slicing, enabling creation and manipulation of marks that track dependencies like data flow, control, and visibility. It works with structured marks representing program elements and signature-level attributes, supporting set-like combinations, classification predicates, and analysis of input/output relationships. Key applications include static dependency analysis, code optimization through slice reduction, and debugging visibility constraints in program signatures.",
      "description_length": 523,
      "index": 4599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingState",
      "library": "frama-c-slicing.core",
      "description": "This module manages the internal state of a slicing project, providing access to the current slicing project data and allowing conditional execution of functions based on initialization status. It works with the `sl_project` type from `SlicingTypes` and supports operations like retrieving the state, applying closures conditionally, and mapping with a default value. Concrete use cases include checking if slicing is initialized before modifying its state or retrieving project-specific data during analysis.",
      "description_length": 509,
      "index": 4600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.PrintSlice",
      "library": "frama-c-slicing.core",
      "description": "This module provides functions to print formatted slices of C code, including function slices, marked control flow, and global variable definitions. It operates on data structures such as PDG graphs, kernel functions, and global declarations. Concrete use cases include generating human-readable output for sliced code sections and exporting slice visualizations in DOT format.",
      "description_length": 377,
      "index": 4601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Slicing.SlicingTransform",
      "library": "frama-c-slicing.core",
      "description": "Performs program transformation based on slicing results, extracting a CIL application from a slicing project. It works with CIL ASTs and project states, using kernel functions and slicing metadata to rename and isolate sliced functions. Useful for generating minimized, sliced C programs from annotated projects.",
      "description_length": 313,
      "index": 4602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.Register",
      "library": "frama-c-slicing.core",
      "description": "This module handles the registration of a plugin within the Frama-C kernel, ensuring it is properly initialized and available for use. It operates internally without exposing any functions or data types to external code. A typical use case involves invoking its registration routine during the plugin's setup phase to integrate with Frama-C's analysis framework.",
      "description_length": 362,
      "index": 4603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingSelect",
      "library": "frama-c-slicing.core",
      "description": "This module defines and combines selection criteria for program slicing, focusing on nodes like statements, variables, and function calls within dependence graphs. It supports precise control through call-site resolution, hierarchical slice merging, and memory context management, enabling optimized static analysis and compositional slicing. The variable selection submodule provides map-based structures for tracking and aggregating variables of interest, allowing operations like adding entries, side-effecting iterations, and value aggregation. Together, they facilitate tasks such as accumulating slicing criteria across function calls and refining analysis precision through dependency tracking.",
      "description_length": 701,
      "index": 4604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing.SlicingCmds",
      "library": "frama-c-slicing.core",
      "description": "This module enables static analysis workflows by supporting the incremental selection and propagation of slicing criteria, represented as sets of markers (`sl_mark`), across program elements like functions, statements, memory zones, and annotations. It provides",
      "description_length": 261,
      "index": 4605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Slicing",
      "library": "frama-c-slicing.core",
      "description": "This module enables program slicing by managing function slices, slicing criteria, and dependency tracking across code elements. It provides key data types such as `fct_slice`, `fct_info`, `stmt`, and `pdg_mark` to represent slices, metadata, and program statements, supporting operations like merging, splitting, filtering, and pretty-printing slices. You can use it to analyze dependencies, generate sliced call graphs, extract code sections based on criteria, and perform transformations like isolating functions or exporting visualizations. Specific workflows include static analysis for impact assessment, code refactoring with dependency tracking, and generating minimized C programs from annotated projects.",
      "description_length": 714,
      "index": 4606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Service_roots.As_string.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a datatype for handling service root options as strings within the Callgraph plugin. It supports operations like equality checking, comparison, hashing, and pretty printing for values of type `t`, along with deep copying and project membership testing. It is used to manage and manipulate string-based service root configurations in a type-safe manner.",
      "description_length": 372,
      "index": 4607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Roots.As_string.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a datatype for representing root options as strings in the callgraph plugin, supporting operations like equality, comparison, hashing, and pretty printing. It works with a custom type `t` that encapsulates string-based root specifications, along with standard data structures like lists and formatters. Concrete use cases include parsing and managing command-line root parameters, comparing and storing root values, and ensuring deep copies for project-specific configurations.",
      "description_length": 497,
      "index": 4608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type for representing root elements in a callgraph, supporting operations like equality, comparison, hashing, and pretty-printing. It works with structured data involving project skeletons and provides precise semantic checks through `mem_project`. Concrete use cases include managing and analyzing callgraph roots with deep copies and user-friendly output formatting.",
      "description_length": 395,
      "index": 4609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.As_string",
      "library": "frama-c-callgraph.core",
      "description": "This module manages string-based command-line parameters with support for assignment, validation, and event-driven updates, working primarily with string data types. It includes a child module that defines a custom type `t` for root options, enabling structured handling of string-based roots with equality checks, comparison, and pretty printing. Operations span direct value manipulation with validation rules, alongside structured parsing, comparison, and storage of root values using lists and formatters. Example uses include enforcing naming conventions at runtime, tracking configuration changes via callbacks, and serializing root parameters for command-line interfaces.",
      "description_length": 678,
      "index": 4610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Services.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating structured data within the Callgraph plugin. It includes functions for checking membership of project-related values, deep copying, and exposing type descriptors for integration with Frama-C's kernel. Concrete use cases include managing analysis configurations, tracking project-specific data, and enabling extensible data representations in plugin components.",
      "description_length": 511,
      "index": 4611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating callgraph analysis options related to uncalled functions. It supports deep copying and membership checks over project skeletons, enabling precise tracking and filtering of analysis states. Concrete use cases include managing configuration settings for callgraph analysis and ensuring consistent handling of uncalled function data across different analysis passes.",
      "description_length": 523,
      "index": 4612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.As_string",
      "library": "frama-c-callgraph.core",
      "description": "This module manages string-based command-line parameters with validation, state tracking, and dynamic interpretation, supporting alias resolution, update hooks, and customizable marshaling. It defines a core type `t` for representing string parameters, with operations for validation, comparison, and pretty printing, while its child module introduces a specialized type for service root options with equality, hashing, and project membership testing. You can use it to configure service roots in a callgraph analysis tool, ensuring parameter validity, handling deprecation, and generating contextual help messages. The module supports dynamic value interpretation, deep copying, and type-safe manipulation of string collections within a global parameter state.",
      "description_length": 761,
      "index": 4613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Roots.Category",
      "library": "frama-c-callgraph.core",
      "description": "This module defines and manages categories for a collection of elements in the Callgraph plugin, such as `@none`, `@default`, and `@all`. It supports operations to create, modify, and enable categories with custom accessors and dependencies. Concrete use cases include configuring root selection behavior through command-line parameters and controlling default or global category settings in analysis workflows.",
      "description_length": 411,
      "index": 4614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Filename.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a custom data type for handling filenames within a callgraph analysis context. It supports operations such as equality checking, comparison, hashing, and pretty printing, along with deep copying and project membership testing. The type is designed for use in option parsing and analysis state management, ensuring correct handling of filename values across different analysis runs and configurations.",
      "description_length": 420,
      "index": 4615,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Uncalled_leaf.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating callgraph analysis options related to uncalled leaf functions. It supports deep copying and membership checks over project skeletons, ensuring values can be uniquely identified and safely shared across different analysis contexts. Concrete use cases include storing and comparing analysis configurations, tracking project-specific properties, and enabling robust serialization through structural descriptors.",
      "description_length": 575,
      "index": 4616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Debug.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a concrete data type `t` with standard operations including equality, comparison, hashing, and pretty-printing. It provides structural metadata such as a type representation, descriptor, and packed descriptor, along with utilities for project membership checks and deep copying. This type supports analysis and debugging tasks in the context of Frama-C's callgraph plugin, particularly for handling and manipulating abstract representations of program elements.",
      "description_length": 481,
      "index": 4617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a datatype for representing service roots in a callgraph, supporting operations like equality, comparison, hashing, and pretty printing. It works with sets of service root values, providing deep copying and membership checks based on project properties. Concrete use cases include managing and querying service root configurations during static analysis of C code.",
      "description_length": 384,
      "index": 4618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Verbose.Datatype",
      "library": "frama-c-callgraph.core",
      "description": "This module defines a concrete data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in the callgraph plugin's verbose options. It supports structured data representation with descriptors, packed descriptions, and project membership checks, enabling precise type handling and introspection. Use cases include managing and comparing verbose output configurations during static analysis of C code.",
      "description_length": 440,
      "index": 4619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Service_roots.Category",
      "library": "frama-c-callgraph.core",
      "description": "This module defines and manages categories for a collection of service roots in the Callgraph plugin. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, using accessors and dependency lists. These categories control how service roots are interpreted and activated during command-line processing.",
      "description_length": 349,
      "index": 4620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Config_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the configuration directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing operations like setting, getting, and checking the existence of the directory. Concrete use cases include initializing plugin-specific storage locations and accessing configuration files during analysis.",
      "description_length": 418,
      "index": 4621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Services.Subgraph",
      "library": "frama-c-callgraph.core",
      "description": "Builds a subgraph of the callgraph starting from root nodes specified in the options. It provides the `get` function to compute and return the restricted graph structure. This module works directly with the callgraph representation type `G.t` and is used to isolate specific service components for analysis or visualization.",
      "description_length": 324,
      "index": 4622,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Cg.Subgraph",
      "library": "frama-c-callgraph.core",
      "description": "Computes a subgraph of the callgraph rooted at the functions specified by `Options.Roots.get ()`. It returns a graph structure (`G.t`) representing the subset of nodes and edges reachable from those root functions. This module is used to analyze or visualize specific portions of the full callgraph, such as entry points or isolated components.",
      "description_length": 344,
      "index": 4623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Session",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the session directory for the Callgraph plugin, providing functions to retrieve or create directories and files within the session path. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations like setting or checking the session directory. Concrete use cases include storing and accessing plugin-specific data during analysis, such as intermediate results or configuration files.",
      "description_length": 436,
      "index": 4624,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Cache_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the cache directory for the Callgraph plugin, providing functions to retrieve or create directories and files within the cache. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include storing intermediate analysis results or cached data in a plugin-specific directory.",
      "description_length": 361,
      "index": 4625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a shared boolean state to control whether uncalled functions are included in callgraph analysis, allowing dynamic configuration through direct operations, command-line integration, and serialization. It provides a data type with equality, comparison, and pretty-printing support to represent and manipulate analysis options, enabling precise tracking and filtering of uncalled function data across analysis passes. Operations include setting, retrieving, and monitoring state changes, with support for default values and deep copying to maintain consistency over project skeletons. The combined interface facilitates adaptive analysis precision tailored to project-specific requirements and user preferences.",
      "description_length": 728,
      "index": 4626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Verbose",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a bounded integer state for verbosity levels, with operations to increment, set, and validate values while tracking changes. It integrates with Frama-C's state system for serialization and project persistence, enabling dynamic control of analysis output detail and consistent parameter naming across plugins. The child module provides a concrete data type with equality, comparison, and pretty-printing support, specialized for the callgraph plugin's verbose options. Together, they allow structured representation and manipulation of verbosity settings, facilitating precise logging control and introspection during static analysis of C code.",
      "description_length": 663,
      "index": 4627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Service_roots",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a mutable set of kernel functions as configurable service roots, integrating command-line parameters and project state persistence. It provides operations for membership checks, iteration, and predicate-based queries over sets of `kernel_function` values, while supporting string-based parameter validation, category management, and dynamic interpretation through its submodules. You can use it to define analysis scopes, track entry points in C code analysis, and synchronize configuration changes with plugin events, leveraging category-based activation and type-safe manipulation of service root sets. The module combines low-level set operations with high-level configuration features, enabling use cases such as callgraph analysis with validated, categorized, and persistable service root definitions.",
      "description_length": 826,
      "index": 4628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Filename",
      "library": "frama-c-callgraph.core",
      "description": "This module manages filename configurations and path manipulations, working with structured file path values to support operations like path registration, change tracking, and command-line integration. It includes core functions for checking path validity and managing analysis state, while its child module introduces a specialized filename type for callgraph analysis, enabling precise equality, comparison, and pretty printing. Together, they facilitate tasks such as plugin configuration, file change monitoring, and consistent filename handling across analysis sessions. Example uses include parsing command-line filename options, tracking file state during analysis, and ensuring correct project membership checks.",
      "description_length": 720,
      "index": 4629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Roots",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a configurable set of kernel functions with support for CLI features like aliases and state persistence, offering set-like operations for membership, iteration, and aggregation. It defines root elements with equality, comparison, and pretty-printing, and supports structured data like project skeletons and semantic checks via `mem_project`. String-based command-line parameters are handled with validation, assignment, and event-driven updates, including a custom type for root options with comparison and formatting. It also supports categories like `@none`, `@default`, and `@all`, enabling configuration of root selection behavior through command-line parameters and analysis workflows. Example uses include defining analysis roots for callgraph construction, enforcing naming conventions at runtime, and serializing root parameters for CLI interaction.",
      "description_length": 877,
      "index": 4630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Uncalled_leaf",
      "library": "frama-c-callgraph.core",
      "description": "This module manages a boolean configuration state with `on` and `off` functions to toggle values, along with utilities for default setup, CLI integration, and change hooks. It works with a boolean type enriched with metadata for serialization, aliases, and project state tracking, enabling dynamic control of analysis features for uncalled leaf nodes in the callgraph. The child module enhances this by defining a custom data type for callgraph analysis options, supporting equality checks, comparison, hashing, and pretty-printing, with deep copying and membership checks over project skeletons. Together, they allow configuring, tracking, and persisting analysis settings while ensuring unique identification and safe sharing of values across contexts.",
      "description_length": 754,
      "index": 4631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Debug",
      "library": "frama-c-callgraph.core",
      "description": "The module manages an integer-based debug configuration system with dynamic adjustments, range constraints, and integration with command-line and persistent state interfaces. It supports a structured data type `t` with equality, comparison, and pretty-printing, enriched with metadata for validation, serialization, and project membership checks. Operations allow setting and querying debug levels with domain-specific constraints, attaching callbacks for value changes, and deep copying configurations for analysis in Frama-C's callgraph plugin. Example uses include tracking project-specific debug settings, enforcing numeric bounds during analysis, and synchronizing debug state across different subsystems.",
      "description_length": 710,
      "index": 4632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Callgraph.Options.Share",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the plugin's shared directory configuration by setting, retrieving, and validating directory paths. It provides operations to set a directory path, check its existence, and resolve specific files or subdirectories within it. It is used to locate plugin-specific resources stored in a shared directory structure during analysis.",
      "description_length": 347,
      "index": 4633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.Services",
      "library": "frama-c-callgraph.core",
      "description": "This module manages boolean state with support for change tracking, hook execution, and synchronization with project-level systems, while its child module defines a structured data type `t` with rich manipulation operations for use in analysis configurations and plugin data. The parent provides operations for boolean switches, command-line integration, and persistent serialization, while the child offers equality checks, type descriptors, and deep copying for complex data. Together, they enable dynamic configuration of plugin behavior, consistent state management across sessions, and extensible representation of project-specific values. Example uses include linking UI toggles to analysis parameters, reacting to configuration changes, and persisting structured options between runs.",
      "description_length": 791,
      "index": 4634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options.State_dir",
      "library": "frama-c-callgraph.core",
      "description": "This module manages the state directory for the Callgraph plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t`, allowing optional path creation. Concrete use cases include storing and accessing plugin-specific state files during analysis.",
      "description_length": 336,
      "index": 4635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Cg",
      "library": "frama-c-callgraph.core",
      "description": "The module manages the construction and manipulation of call graphs derived from the AST, enabling computation, retrieval, and dumping of graph structures. It provides core operations to register hooks for post-computation actions, generate Graphviz visualizations, and analyze function call relationships during static analysis. The `G` submodule defines the underlying graph structure used throughout, while the child module computes subgraphs rooted at specified entry points, returning reachable nodes and edges for focused analysis or visualization of specific components. Example uses include extracting call paths from entry functions, generating visual call hierarchies, and identifying isolated or unreachable code sections.",
      "description_length": 733,
      "index": 4636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Options",
      "library": "frama-c-callgraph.core",
      "description": "This module orchestrates diagnostic and configuration workflows for plugins through structured state management, logging, and control-flow logic. It provides core operations for handling verbosity, warnings, and conditional execution, while integrating submodules that manage file paths, directories, and typed configuration states such as boolean flags, integers, and function sets. You can control analysis precision via dynamic verbosity levels, define analysis scopes using configurable function roots, or manage session-specific storage paths with type-safe file operations. Submodules enable fine-grained control over features like uncalled function inclusion, debug levels, and service root sets, all while supporting command-line integration, serialization, and project persistence.",
      "description_length": 790,
      "index": 4637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Uses",
      "library": "frama-c-callgraph.core",
      "description": "This module provides functions to traverse and analyze the callgraph structure, specifically iterating over functions in caller-to-callee or callee-to-caller order, and exploring the direct and indirect callers or callees of a given function. It operates on the `Frama_c_kernel.Kernel_function.t` type, representing functions in the analyzed program. Concrete use cases include dependency analysis, impact assessment for function changes, and gathering call statistics across the call hierarchy.",
      "description_length": 495,
      "index": 4638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph.Services",
      "library": "frama-c-callgraph.core",
      "description": "This module organizes a graph of services derived from the callgraph, enabling operations to construct, analyze, and export subgraphs. It centers around the graph type `G.t`, with vertices representing functions and edges representing calls, and supports key operations like computing dependency graphs, retrieving subgraphs from root nodes, and dumping graph data for external use. The child module extends this by providing targeted subgraph extraction via the `get` function, allowing precise isolation of service components based on call relationships. Together, they enable concrete tasks such as visualizing service dependencies and analyzing call chains within a structured graph framework.",
      "description_length": 697,
      "index": 4639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Callgraph",
      "library": "frama-c-callgraph.core",
      "description": "This module analyzes and transforms call graphs derived from program code, supporting operations to build, traverse, and visualize function call relationships. It centers on a graph structure `G.t` where vertices represent functions and edges represent calls, enabling key operations such as subgraph extraction, dependency analysis, and Graphviz generation. You can compute reachable functions from entry points, explore caller-callee chains, or configure analysis scope and output paths through typed state management. Concrete uses include isolating unreachable code, visualizing call hierarchies, and assessing the impact of function changes across call chains.",
      "description_length": 665,
      "index": 4640,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map.Make",
      "library": "frama-c-metrics.core",
      "description": "This module implements a map structure where values are of the specified `Data` type, supporting operations like equality, comparison, hashing, and pretty-printing for user-friendly representation. It provides functionalities for deep copying, membership testing based on project skeletons, and type descriptors for integration with the Frama-C kernel. Concrete use cases include managing and comparing collections of analysis data indexed by keys in Frama-C plugins.",
      "description_length": 467,
      "index": 4641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl.Key",
      "library": "frama-c-metrics.core",
      "description": "This module defines a key type for a hash table that supports equality, comparison, and hashing operations tailored to the `Metrics_base.OptionKf.Hashtbl.key` structure. It includes functions for deep copying keys, checking membership based on project properties, and pretty-printing keys in a user-friendly format. The module is used to manage and manipulate keys in a hash table storing metrics-related data, ensuring efficient and consistent access and comparison.",
      "description_length": 467,
      "index": 4642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map.Key",
      "library": "frama-c-metrics.core",
      "description": "This module defines a key type for maps used in the metrics plugin, providing standard operations like equality, comparison, hashing, and pretty printing. It works with a specific key type derived from `Metrics_base.OptionKf.Map.key`, supporting deep copying, membership checks over projects, and type representation. Concrete use cases include managing and comparing keys in metric data structures that require project-specific tracking and serialization.",
      "description_length": 456,
      "index": 4643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl.Make",
      "library": "frama-c-metrics.core",
      "description": "This module implements a hash table where keys are of type `Data.t` and values are optional. It provides standard operations including equality, comparison, hashing, and pretty-printing, as well as deep copying and project membership checking. Use this module to manage sparse mappings with optional values, such as tracking the presence or absence of analysis results per key in a Frama-C plugin.",
      "description_length": 397,
      "index": 4644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Hashtbl",
      "library": "frama-c-metrics.core",
      "description": "This module provides a polymorphic hash table for efficient metrics tracking in Frama-C plugins, centered around keys of type `Metrics.Metrics_base.OptionKf.t`. It supports core operations like insertion, deletion, and lookup, along with advanced features such as ordered iteration, bulk updates from sequences, and in-place value transformations via `filter_map_inplace`, all configurable with custom comparators. Submodule 1 defines a key type with equality, comparison, and pretty-printing tailored to metrics-based keys, ensuring consistent access and membership checks tied to project properties. Submodule 2 extends the structure to handle optional values, enabling sparse mappings useful for tracking presence or absence of analysis results per key.",
      "description_length": 756,
      "index": 4645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Set",
      "library": "frama-c-metrics.core",
      "description": "This module implements **immutable ordered sets** for elements of type `Metrics.Metrics_base.OptionKf.t`, supporting functional transformations like union, intersection, difference, and predicate-based filtering, alongside ordered traversal via iteration and folding. It maintains elements in canonical order using `Ord.compare`, offering operations for membership checks, nearest-neighbor queries, and conversions to sequences or lists while preserving immutability. Designed for scenarios requiring precise metric aggregation or static analysis of key-associated data, it enables efficient set manipulation in functional workflows, such as tracking project-specific metrics or analyzing structured element hierarchies.",
      "description_length": 720,
      "index": 4646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf.Map",
      "library": "frama-c-metrics.core",
      "description": "This module implements a persistent ordered map for values indexed by keys with optional or hierarchical structure, supporting efficient insertion, lookup, and functional transformations like `map` and `fold`. It enables bidirectional conversion to sequences, bulk operations such as `merge` and `union`, and customizable string formatting for structured output. The data module specializes these maps for values with equality, comparison, and pretty-printing, used to manage analysis data in Frama-C plugins, while the key module defines project-aware keys with deep copying and membership checks, ideal for metric tracking and serialization. Together, they support building, transforming, and analyzing rich metric data indexed by structured keys.",
      "description_length": 749,
      "index": 4647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.OptionKf",
      "library": "frama-c-metrics.core",
      "description": "This module manages an optional `Kernel_function` type with operations for comparison, hashing, and pretty-printing, alongside utilities for project membership checks, deep copies, and collection management. It supports concrete use cases like tracking and comparing kernel functions in metrics analysis, storing them in sets, maps, and hash tables keyed by presence or absence. Submodules provide a polymorphic hash table with ordered iteration and in-place transformations, an immutable ordered set for functional set operations and nearest-neighbor queries, and a persistent ordered map with bidirectional sequence conversion and bulk merging. These components together enable efficient, structured handling of optional kernel functions in both mutable and immutable contexts, tailored for Frama-C plugin development and metric-based analysis.",
      "description_length": 846,
      "index": 4648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base.BasicMetrics",
      "library": "frama-c-metrics.core",
      "description": "This module tracks and quantifies structural elements of C code, such as function calls, assignments, loops, and decision points. It processes data types like file paths, kernel functions, and integer counters to compute metrics for static code analysis. Use cases include measuring code complexity, identifying high-risk functions, and enforcing coding standards in C projects.",
      "description_length": 378,
      "index": 4649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics.Metrics_base",
      "library": "frama-c-metrics.core",
      "description": "This module provides structured representations of C code elements and optional kernel functions, enabling precise static analysis through metrics tracking and comparison. It supports data types like function calls, loops, assignments, and decision points, combined with operations for hashing, comparison, and ordered collection management. These capabilities allow developers to measure code complexity, identify high-risk functions, and manage kernel function relationships using sets, maps, and hash tables. Specific use cases include enforcing coding standards and performing metrics-based analysis in Frama-C plugins.",
      "description_length": 623,
      "index": 4650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_cilast",
      "library": "frama-c-metrics.core",
      "description": "This module provides a function `get_metrics_map` that computes a nested map of basic metrics for functions in a C program, indexed by file paths and function keys. It works with abstract syntax trees of C code and supports filtering based on whether library code should be included. A concrete use case is analyzing source code to generate per-file, per-function metrics such as line count or cyclomatic complexity.",
      "description_length": 416,
      "index": 4651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics.Metrics_coverage",
      "library": "frama-c-metrics.core",
      "description": "Computes syntactic coverage for a given kernel function, returning a set of variable identifiers involved in the coverage analysis. It takes a boolean flag to include libc functions and processes control flow structures to identify reachable variables. This function is used to analyze code coverage in static analysis tools, specifically for identifying variables that are part of the syntactic reachability in a function's control flow.",
      "description_length": 438,
      "index": 4652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics",
      "library": "frama-c-metrics.core",
      "description": "This module analyzes C code structure and kernel functions to compute metrics and coverage data for static analysis. It provides data types representing code elements like function calls, loops, and decision points, along with operations for hashing, comparison, and managing ordered collections. Key functions include `get_metrics_map` for generating per-function metrics and syntactic coverage analysis for identifying reachable variables. Examples include measuring cyclomatic complexity, enforcing coding standards, and analyzing variable reachability in control flow.",
      "description_length": 572,
      "index": 4653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing string-based sets with operations for equality checking, comparison, hashing, and pretty printing. It supports set membership testing with `mem_project` and provides deep copying of values. The type is used to manage string identifiers in a way that ensures uniqueness and supports project-specific queries.",
      "description_length": 356,
      "index": 4654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling multiple string values with operations for equality, comparison, hashing, and pretty printing. It supports working with lists of strings as a collection, enabling deep copies, membership checks over project skeletons, and standard data manipulations. Concrete use cases include managing sets of string identifiers or configuration values in static analysis contexts.",
      "description_length": 410,
      "index": 4655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing string-based values. It supports working with lists of strings through standard type representations and provides deep copying and project membership checks. Concrete use cases include managing string collections in static analysis contexts where type consistency and value comparison are critical.",
      "description_length": 401,
      "index": 4656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for handling string-based values in a structured and comparable form. It supports equality checks, comparison, hashing, and pretty-printing, enabling efficient use in sets, maps, and user-facing representations. The type is designed for scenarios requiring unique named identifiers with rich structural operations, such as tracking and comparing function declarations or prototypes in static analysis contexts.",
      "description_length": 458,
      "index": 4657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling sets of strings with operations for equality, comparison, hashing, and pretty-printing. It supports set membership checks, deep copying, and project-based filtering of values. Concrete use cases include managing collections of string identifiers in static analysis tools where set semantics and value comparison are required.",
      "description_length": 369,
      "index": 4658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing and manipulating strings in the context of function declarations, providing operations for equality, comparison, hashing, and pretty-printing. It supports working with lists of these string values, enabling set-like operations and deep copying. Concrete use cases include tracking and analyzing function identifiers across different projects, ensuring unique representation and efficient comparison in static analysis tasks.",
      "description_length": 473,
      "index": 4659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling string-based file paths in a way that supports comparison, hashing, and pretty-printing. It provides operations to check equality, compare, hash, and display values, along with a function to filter based on project membership. The module is used to represent and manipulate file paths within a static analysis context, enabling tracking and differentiation of file-related data across analysis phases.",
      "description_length": 445,
      "index": 4660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for representing and manipulating string-based values in a structured analysis context. It supports equality checks, comparison, hashing, pretty-printing, and deep copying, ensuring values can be uniquely identified and safely duplicated. The type is used to handle string parameters within a kernel function map, enabling precise tracking and analysis of function-related string data across different projects.",
      "description_length": 459,
      "index": 4661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of strings as a single string, with operations for equality, comparison, hashing, and pretty-printing. It supports standard data structure manipulations such as deep copying and membership testing over project skeletons. Concrete use cases include representing and manipulating string lists in Frama-C analyses where a unified string form is required.",
      "description_length": 401,
      "index": 4662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling string-based representations within a static analysis context. It provides operations for equality, comparison, hashing, and pretty-printing string values, along with deep copying and project membership checks. It is used to manage string data in a way that integrates with Frama-C's analysis infrastructure, particularly for tracking and comparing string values across different analysis states.",
      "description_length": 440,
      "index": 4663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing and manipulating sets of strings in a way that supports equality checks, comparison, hashing, and pretty-printing. It provides operations to test membership within a project context, create deep copies, and describe the type with a unique name and descriptor. The type is used to handle string sets as parameters in Frama-C plugins, ensuring proper type representation and structural operations.",
      "description_length": 444,
      "index": 4664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for representing, comparing, and manipulating values as strings within a Frama-C plugin context. It provides standard functionalities such as equality checking, comparison, hashing, pretty printing, and deep copying, all specific to string-based data. It is used to handle string values in a structured and type-safe way, particularly for storing and processing representants and descriptors in static analysis plugins.",
      "description_length": 467,
      "index": 4665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of file paths as strings, supporting operations like equality checking, comparison, hashing, and pretty printing. It provides functionality for deep copying values and checking project membership within the list. The module is used to manage and manipulate file path lists in a type-safe manner, particularly in contexts requiring persistence or comparison across analysis runs.",
      "description_length": 428,
      "index": 4666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling string values within a map structure that disallows multibindings. It provides standard operations including equality, comparison, hashing, and pretty printing, along with deep copying and project membership checks. It is used to manage string-based keys or values in a map while ensuring strict uniqueness and supporting analysis-specific operations required by Frama-C's kernel.",
      "description_length": 424,
      "index": 4667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.As_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling lists of strings with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks for project skeletons within the list elements. Use this module to manage string lists as immutable values in analyses requiring structural comparisons and project-aware filtering.",
      "description_length": 360,
      "index": 4668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Int.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling integer lists with operations for equality, comparison, hashing, and pretty-printing. It supports deep copying and membership checks over projections, ensuring no shared structure between original and copied values. Concrete use cases include representing and manipulating integer sequences in static analysis plugins, such as tracking variable indices or abstract values.",
      "description_length": 416,
      "index": 4669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for a collection of string-based elements, using Frama-C's parameter category system. It provides operations to create, modify, and query categories such as '@none', '@default', and '@all', with support for accessors and dependencies. Concrete use cases include configuring analysis parameters with named categories and controlling their activation behavior in different analysis contexts.",
      "description_length": 432,
      "index": 4670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Empty_string.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom abstract data type `t` with operations for equality, comparison, hashing, and pretty-printing. It supports structured data representation through a descriptor and provides deep copying and project membership checks. Use cases include modeling domain-specific values in static analysis plugins requiring precise data manipulation and persistence.",
      "description_length": 374,
      "index": 4671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Zero.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype with operations for equality, comparison, hashing, and pretty-printing, tailored for use in Frama-C plugin development. It provides a deep copy function, a membership test for project skeletons, and includes representants along with a packed descriptor for structural manipulation. It is used to manage and manipulate analysis data within Frama-C plugins, ensuring consistency and integrity during static analysis tasks.",
      "description_length": 451,
      "index": 4672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in static analysis contexts. It supports structured data representation with capabilities for deep copying, membership testing within projects, and type description management. Concrete use cases include tracking and manipulating analysis states or configurations in Frama-C plugins.",
      "description_length": 417,
      "index": 4673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing filled string sets, including operations for equality, comparison, hashing, and pretty-printing. It provides functions for checking membership based on project conditions, deep copying values, and exposing type descriptors for integration with Frama-C's kernel. Concrete use cases include managing and analyzing sets of strings in static analysis plugins, particularly when tracking project-specific data through string set values.",
      "description_length": 480,
      "index": 4674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string parameters with validation, default handling, and lifecycle integration, supporting use cases like CLI configuration and dynamic value updates. It works with parameter objects that track state such as default or computed status, and includes operations for restricting values to whitelisted sets and validating function names. The child module enhances this by defining a string-based set type with membership testing via `mem_project`, ensuring uniqueness and supporting project-specific queries. Together, they enable structured handling of string values with customizable marshaling, state tracking, and set operations.",
      "description_length": 649,
      "index": 4675,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports structured data representation with a list of representative values and provides deep copying and project membership checks. Concrete use cases include managing analysis states or symbolic values in Frama-C plugins.",
      "description_length": 384,
      "index": 4676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports deep copying and membership checks over project skeletons, ensuring structural integrity. Concrete use cases include managing and analyzing collections of abstract values in Frama-C plugins.",
      "description_length": 352,
      "index": 4677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages parameter categories for string sets in Frama-C plugins. It provides operations to define, modify, and enable categories such as '@none', '@default', and '@all', with support for accessors and dependencies. Use cases include configuring analysis parameters with custom categories and controlling default or global behavior in plugin settings.",
      "description_length": 362,
      "index": 4678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.False.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing. It supports structured values that may contain embedded project skeletons, enabling membership checks and deep copying. Concrete use cases include representing and manipulating analysis data with project-specific attributes in a type-safe manner.",
      "description_length": 357,
      "index": 4679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in a map structure that disallows multibindings. It supports values of type `Datatype.t`, providing deep copy, membership testing by project, and representant management. Concrete use cases include managing unique, structured values in static analysis contexts where precise type handling and value identity are critical.",
      "description_length": 442,
      "index": 4680,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a string set data structure with operations for equality, comparison, hashing, and pretty-printing. It supports efficient membership checks, deep copying, and project-based filtering through the `mem_project` function. Concrete use cases include tracking sets of strings in static analysis plugins and managing project-specific data in Frama-C extensions.",
      "description_length": 375,
      "index": 4681,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for parameter classification, supporting operations to define, modify, and enable categories with specific accessors and dependencies. It works with category types and state lists, enabling precise control over category behavior in parameter handling. Concrete use cases include setting up default and global categories for analysis scripts with specific interpretation rules.",
      "description_length": 407,
      "index": 4682,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories used to group and control the behavior of analysis parameters. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each influencing how parameters are interpreted and enabled during analysis. Use cases include configuring analysis options dynamically, setting default behaviors, and enabling/disabling groups of parameters collectively.",
      "description_length": 431,
      "index": 4683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of file paths, providing operations to define, modify, and enable categories with specific behaviors. It works with category types and state lists, allowing the setup of default and \"all\" categories that control how parameters are interpreted. Concrete use cases include configuring analysis scripts where categories determine which file paths are included or excluded based on dynamic state conditions.",
      "description_length": 451,
      "index": 4684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for a parameter map with multibindings, supporting operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and uses accessors and state lists to define category behavior. Concrete use cases include setting up configurable analysis categories in static analysis tools, where categories control parameter activation and interpretation across different analysis passes.",
      "description_length": 507,
      "index": 4685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages command-line parameters with string values, offering validation, alias resolution, and dynamic value restriction through predefined lists. It supports string and string list operations to enforce allowed inputs, sanitize user-provided values, and synchronize state changes across Frama-C plugin components. The child module enhances this functionality by introducing a typed representation for string sets with equality, comparison, and pretty-printing capabilities. Together, they enable use cases such as restricting parameters to enumerated values, validating function names, and maintaining consistent option states within analysis plugins.",
      "description_length": 664,
      "index": 4686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Custom.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It includes a unique name, a type descriptor, and support for deep copying and project membership checks. Concrete use cases include representing analysis-specific values like abstract states or analysis results that require custom handling during comparison, storage, or display.",
      "description_length": 437,
      "index": 4687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Action.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports deep copying and membership checks over project skeletons, ensuring structural integrity during analysis. Concrete use cases include representing and manipulating analysis states or configurations within Frama-C plugins.",
      "description_length": 389,
      "index": 4688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string command-line parameters with support for defaults, allowed values, and input validation, while integrating set-based operations for handling collections of strings with equality, comparison, and membership checks. It enables defining aliases, attaching metadata like help messages, and maintaining state through global variables, facilitating dynamic parameter customization and configuration parsing. Use cases include validating argument values against predefined lists, managing sets of string identifiers in analysis tools, and filtering or copying string collections based on project-specific rules. The combined interface supports both direct parameter manipulation and set-oriented processing in development and tooling workflows.",
      "description_length": 764,
      "index": 4689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports deep copying and membership checks over project skeletons, ensuring values are fully independent. The type is used to represent and manipulate analysis-specific data structures with precise semantic identity and structural integrity.",
      "description_length": 402,
      "index": 4690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a datatype for handling file paths with operations for equality, comparison, hashing, and pretty printing. It supports deep copying and checks for the presence of project-related values through predicate functions. The type `t` represents file paths, and it integrates with Frama-C's kernel structures for analysis purposes.",
      "description_length": 344,
      "index": 4691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-valued command-line parameters with validation and state tracking, allowing operations such as setting allowed values, checking validity, and retrieving function names. It provides core data types for string parameters and supports integration with static analysis by enabling deep copying, comparison, hashing, and pretty-printing through its submodules. Users can define restricted CLI options, ensure identifiers match valid functions, or track string values across analysis states. Specific use cases include validating user input against predefined string sets and managing string-based identifiers in a static analysis pipeline.",
      "description_length": 661,
      "index": 4692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-based configuration parameters with validation, default handling, and command-line integration, supporting operations like constrained value updates, serialization, and strict parsing. It works with strings and string lists to enforce criteria such as valid function name patterns, enabling use cases like project state configuration and CLI argument parsing. A key data type represents string-based file paths, offering equality checks, comparison, hashing, and pretty-printing, along with filtering by project membership. These capabilities support static analysis workflows where file path tracking and controlled parameter updates are critical.",
      "description_length": 675,
      "index": 4693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter collections, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with `Category.t` values, which represent named categories, and interacts with `Frama_c_kernel.State.t` lists and accessors. Concrete use cases include setting up configurable analysis modes, enabling global category behaviors, and defining default or special-purpose categories like `@none`, `@default`, and `@all`.",
      "description_length": 500,
      "index": 4694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` representing a list of file paths, along with standard operations including equality, comparison, hashing, and pretty printing. It integrates with Frama-C's type system through a registered descriptor and type representation, enabling use in analysis plugins. The module supports deep copying, membership checks over project skeletons, and provides a unique name and description for the data type.",
      "description_length": 440,
      "index": 4695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis contexts. It supports structured data representation with a descriptor and a list of representatives, enabling deep copying and membership checks based on project-specific predicates. Concrete use cases include managing and comparing abstract values in Frama-C plugins, such as tracking dataflow results or symbolic expressions.",
      "description_length": 468,
      "index": 4696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter grouping, using the `Frama_c_kernel.Parameter_category.t` type. It provides operations to create, modify, and enable categories such as `@none`, `@default`, and `@all`, with support for accessors and dependencies. Use cases include organizing plugin parameters in Frama-C and controlling their activation behavior through named categories.",
      "description_length": 396,
      "index": 4697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for a parameter map, supporting operations to create, modify, and enable categories with specific accessors and dependencies. It works with category types tied to `Frama_c_kernel.Parameter_category.t` and includes predefined categories like `@none`, `@default`, and `@all`. Concrete use cases include setting up configurable analysis categories in Frama-C plugins, enabling or disabling groups of parameters, and defining default or global behaviors for parameter handling.",
      "description_length": 516,
      "index": 4698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter configurations, supporting operations to create, enable, and modify categories with specific accessors and dependencies. It works with `Category.t` values, which represent named categories, and interacts with `Frama_c_kernel.State.t` lists to define behavior. Concrete use cases include setting up configurable analysis modes, enabling global category behaviors, and defining default or special-purpose categories like `@none`, `@default`, and `@all`.",
      "description_length": 508,
      "index": 4699,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Float.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for representing floating-point numbers with optional decimal points, supporting operations such as equality, comparison, hashing, and pretty printing. It works with the `t` type, which encapsulates float values and integrates with Frama-C's type system via `Frama_c_kernel.Type.t` and `Frama_c_kernel.Descr.t`. Concrete use cases include analyzing and transforming C code where floating-point literals need precise representation and comparison during static analysis.",
      "description_length": 501,
      "index": 4700,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Verbose.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis scripts. It includes functions for deep copying values, checking membership based on project properties, and exposing representative values. The type is integrated with Frama-C's kernel structures, making it suitable for representing and manipulating analysis-specific data during program verification.",
      "description_length": 453,
      "index": 4701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for representing and manipulating file paths. It includes functionality for checking membership within projects and creating deep copies, ensuring no shared references. Concrete use cases include managing and analyzing collections of file paths in static analysis tools, where precise path handling and project scoping are required.",
      "description_length": 465,
      "index": 4702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type for handling lists of strings with operations for equality, comparison, hashing, and pretty-printing. It supports integration with Frama-C's type system through descriptors and provides deep copying and project membership checks. Use it to represent and manipulate string lists in Frama-C analyses requiring structured data handling.",
      "description_length": 365,
      "index": 4703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-based command-line options with support for value change hooks, default handling, serialization customization, and input validation against predefined sets or function name constraints. It operates on global string parameters and predefined value lists, enabling dynamic configuration management and strict input validation for project-specific state synchronization. The child module enhances this functionality by providing a data type with operations for equality, comparison, hashing, and pretty-printing, along with support for string lists, deep copying, and project membership checks. Together, they allow tasks like tracking string collections in static analysis tools while ensuring type consistency and value integrity.",
      "description_length": 756,
      "index": 4704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories used to group and control parameter behaviors within a configuration system. It supports operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, using a type `t` that wraps a parameter category. Concrete use cases include setting default parameter interpretations, enabling global behavior through `@all`, and defining custom categories with specific accessors and dependencies.",
      "description_length": 457,
      "index": 4705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.WithOutput.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` and associated operations for a specific analysis in Frama-C. It provides equality, comparison, hashing, and pretty-printing functions for values of type `t`, along with utilities for checking membership based on project properties and performing deep copies. It is used to represent and manipulate analysis-specific data during static analysis in Frama-C plugins.",
      "description_length": 400,
      "index": 4706,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-valued command-line parameters with validation, aliasing, and lifecycle hooks, supporting both single strings and string lists. It enforces constraints through predicates and marshaling functions, allowing for use cases like validating function identifiers or configuring project settings. The core type supports deep copying, comparison, and hashing, enabling structured analysis and tracking of string data across function maps. Submodules extend this functionality to provide precise handling and analysis of string-based values in kernel contexts.",
      "description_length": 578,
      "index": 4707,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Enum.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a finite enumerated type `t` with structural equality, comparison, and hashing capabilities. It includes operations for deep copying, membership testing within projects, and pretty-printing values. The type is used to represent fixed sets of values with associated metadata, suitable for analysis contexts requiring distinct, comparable states or categories.",
      "description_length": 378,
      "index": 4708,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type and associated operations for handling string-based multiple maps in a static analysis context. It provides equality, comparison, hashing, and pretty-printing functions, along with deep copying and project membership checks. It is used to represent and manipulate string-indexed map structures during program analysis.",
      "description_length": 350,
      "index": 4709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a concrete data type for representing and manipulating string values within a list analysis framework. It provides operations for equality checking, comparison, hashing, pretty-printing, and deep copying of string values, ensuring proper handling of project-specific data. The type `t` represents strings with associated metadata, supporting precise analysis of string-based data flows in static code analysis.",
      "description_length": 433,
      "index": 4710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of elements, providing operations to define, retrieve, and modify named categories such as '@none', '@default', and '@all'. It works with category types that encapsulate element types and state dependencies, supporting dynamic category creation with accessors and dependency tracking. Concrete use cases include configuring analysis parameters with named categories and controlling default and global behavior in static analysis scripts.",
      "description_length": 485,
      "index": 4711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides utilities for defining and managing string-based command-line parameters with advanced configuration features such as validation, default values, and transformation hooks. It supports operations on string values and lists, enabling tasks like parsing plugin options, enforcing allowed argument sets, and integrating command-line inputs with Frama-C's state management. A child module enhances this functionality by offering type-safe manipulation of string values with operations like comparison, hashing, and pretty printing, specifically tailored for use in Frama-C plugins. Together, they allow precise control over string-based parameters, from input parsing to internal representation and transformation.",
      "description_length": 730,
      "index": 4712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing. It provides a deep copy function, a membership test for project skeletons, and includes type descriptors for integration with Frama-C's kernel. Use this module to represent and manipulate structured data within Frama-C plugins, particularly when handling type-specific operations or persistent storage of values.",
      "description_length": 427,
      "index": 4713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides utilities for managing string-based command-line parameters with state tracking, validation, and alias resolution, operating on individual strings and string lists. It supports strict value constraints, such as restricting inputs to predefined options, and integrates with a child module that handles lists of file paths with type-safe operations like comparison, hashing, and project membership checks. You can use it to parse and validate CLI arguments, manage persistent settings, and manipulate file path collections across analysis sessions. The combined functionality enables robust handling of string parameters in both transient and persistent contexts.",
      "description_length": 682,
      "index": 4714,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-based command-line parameters with support for default values, aliases, serialization, and input validation, working with a global registry of permissible string values. It provides a map structure for handling string keys with strict uniqueness, supporting operations like equality, comparison, hashing, and project membership checks. You can use it to configure plugin settings, enforce valid function references in analysis tools, or manage string mappings with guaranteed single bindings. The combination of parameter handling and map operations enables both high-level configuration and low-level analysis tasks involving string data.",
      "description_length": 666,
      "index": 4715,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-based command-line parameters with support for multibinding, value validation, and state tracking through lifecycle hooks. It operates on string lists to enforce allowed values, handle repeatable options like multiple `--include` paths, and maintain global parameter state. The child module enhances this functionality by providing data structures for working with collections of strings, supporting operations like membership checks, comparison, and pretty printing. Together, they enable robust handling of dynamic, validated string configurations in CLI-driven and static analysis tools.",
      "description_length": 617,
      "index": 4716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories used to group and control the behavior of analysis parameters. It provides operations to create, modify, and query categories such as `@none`, `@default`, and `@all`, each influencing how parameters are interpreted and enabled during analysis. These categories are tied to a specific element type and interact with analysis states and accessors to determine parameter behavior in different contexts.",
      "description_length": 442,
      "index": 4717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Bool.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a boolean list data structure with operations for equality, comparison, hashing, and pretty-printing. It supports list values containing boolean elements, providing deep copy functionality and integration with Frama-C's project system through membership checks. Use cases include analyzing boolean state transitions in program logic and tracking binary properties across codebases.",
      "description_length": 401,
      "index": 4718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages command-line parameters with string values, supporting validation, change hooks, and persistent global state. It defines core operations for string and string list manipulation, including comparison, alias resolution, and validation against predefined or computed values. The child module enhances these capabilities by introducing structured representations for strings in function declarations, enabling efficient equality checks, hashing, and pretty-printing. Together, they allow configuring CLI options with dynamic defaults, tracking function identifiers across projects, and maintaining consistent string state with validation and transformation pipelines.",
      "description_length": 683,
      "index": 4719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages command-line string parameters with validation and state integration, allowing values to be set, retrieved, and restricted to predefined lists or validated as function names. It supports global string parameters and lists of allowed values, ensuring input constraints are enforced during analysis. A child module handles string lists as single entities, offering equality, comparison, and pretty-printing operations, enabling structured manipulation of string data across project skeletons. Together, they facilitate precise string handling in Frama-C analyses, from validating user inputs to representing complex string-based configurations.",
      "description_length": 662,
      "index": 4720,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Debug.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for use in static analysis scripts. It supports structured data representation with descriptors and provides deep copying and project membership checks. Concrete use cases include managing and analyzing program constructs during static analysis, such as tracking and comparing abstract values or project elements.",
      "description_length": 433,
      "index": 4721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines and manages categories for parameter grouping, using `Frama_c_kernel.Parameter_category.t` as the main type. It supports creating named categories with dependencies, setting default and \"all\" category behaviors, and enabling global category interpretations. Use cases include organizing analysis parameters into logical groups and controlling their activation in different contexts.",
      "description_length": 402,
      "index": 4722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.True.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines operations for a specific datatype used in static analysis, including equality, comparison, hashing, and pretty-printing. It works with values of type `Datatype.t`, which represents analysis data, and provides deep copying, membership checking over projects, and structural descriptors for serialization. Concrete use cases include managing and comparing analysis states, checking project membership during value traversal, and generating human-readable output for debugging.",
      "description_length": 495,
      "index": 4723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set.Category",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages categories for a collection of elements, providing operations to define, retrieve, and modify named categories such as `@none`, `@default`, and `@all`. It works with category types tied to a specific element type and includes functions to set default behaviors, enable all categories with specific interpretations, and define dependencies. Concrete use cases include configuring analysis parameters and controlling state propagation in static analysis workflows.",
      "description_length": 482,
      "index": 4724,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a global string parameter with validation, alias handling, and state synchronization, supporting operations to define allowed values, enforce function name correctness via external criteria, or retrieve raw strings unconditionally. It includes a structured string-based data type with equality, comparison, hashing, and pretty-printing for use in sets, maps, and user-facing displays, ideal for tracking and comparing named identifiers like function declarations. The module enables project-specific configuration parameters that reference valid functions or controlled values, with dynamic validation and cross-component consistency, while supporting Frama-C kernel interoperability and modification tracking through configurable hooks. Example uses include defining function name policies, maintaining synchronized string state across analysis components, and structuring identifiers for efficient comparison and display.",
      "description_length": 943,
      "index": 4725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, specifically tailored for use in Frama-C's analysis framework. It includes functionality for checking membership based on project properties and supports deep copying to avoid shared state. The type is used to represent and manipulate analysis-specific data structures within Frama-C plugins.",
      "description_length": 403,
      "index": 4726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list.As_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages command-line parameters with string values, validating inputs against predefined rules and enabling seamless integration with child modules for extended functionality. It supports operations like parsing, checking, and transforming string parameters, while the child module introduces a data type for immutable string lists with structural equality, comparison, and project-aware filtering. Use this combination to build robust command-line interfaces that handle complex string-based configurations and perform analyses on string collections with precise structural and semantic guarantees.",
      "description_length": 611,
      "index": 4727,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` and associated operations for managing kernel function maps, including equality, comparison, hashing, and pretty-printing functions. It works with `Datatype.t` values, which represent abstract data in the Frama-C kernel, and includes utilities for checking membership within projects and performing deep copies. Concrete use cases include tracking and comparing function declarations and prototypes within static analysis plugins.",
      "description_length": 466,
      "index": 4728,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.False",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a boolean state with support for change monitoring, CLI integration, and persistent configuration, working with a boolean type `t` and associated metadata. It allows state transitions via `on`/`off` functions, accommodating hooks, aliases, and serialization, useful for tracking Frama-C kernel parameters or project-specific settings. Its child module enhances this functionality by defining a custom data type with operations for equality, comparison, hashing, and pretty-printing, enabling structured values with project-specific attributes. Together, they support use cases like analysis data manipulation and state tracking with deep copying and membership checks.",
      "description_length": 688,
      "index": 4729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Output.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating structured analysis outputs. It supports deep copying and membership checks over embedded project values, ensuring no shared references. Concrete use cases include managing and querying analysis results in Frama-C plugins, particularly for tracking and comparing structured data across different analysis runs.",
      "description_length": 464,
      "index": 4730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages mutable string parameters with project-specific state, supporting operations like setting and retrieving values, validation, and update hooks. It integrates with command-line interfaces through metadata handling and marshaling, while its child module provides concrete representations of strings with metadata for analysis, enabling precise data flow tracking. You can enforce allowed values, validate function names, and dynamically update configurations with associated string metadata. Operations include equality checks, comparison, hashing, and pretty-printing for both direct use and analysis frameworks.",
      "description_length": 630,
      "index": 4731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.WithOutput",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean configuration options with change hooks, aliases, and custom serialization, while controlling plugin output through dependency tracking and conditional emission. It defines a core data type `t` with operations for equality, comparison, hashing, and pretty-printing, enabling analysis-specific data representation and manipulation during static analysis. Submodule utilities support project-based membership checks and deep copies, facilitating state-persistent plugins with cached results and dynamic configuration. Example uses include tracking analysis phases, enabling/disabling output sections based on project context, and serializing configuration changes for replay or debugging.",
      "description_length": 714,
      "index": 4732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Bool",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean state with advanced lifecycle handling, including mutation, change notifications, serialization, and integration with Frama-C's project system. It defines a boolean type `t` and supports operations like `on`, `off`, and value toggling, while maintaining default values and state consistency. The module also includes a boolean list structure with equality checks, comparison, and pretty-printing, enabling analysis of state transitions and tracking of binary properties across codebases. Use cases include synchronizing boolean options in command-line interfaces, managing project-specific state, and handling aliases for boolean values.",
      "description_length": 665,
      "index": 4733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintDeclarations.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a data type `t` representing abstract data structures with associated type information, names, and descriptors. It provides operations for equality checks, comparison, hashing, pretty-printing, and deep copying, along with utilities to inspect and filter based on embedded project values. It is used to manage and manipulate structured data representations in static analysis plugins, particularly for handling type declarations and their relationships.",
      "description_length": 473,
      "index": 4734,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Share",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages the `<dune-site-dir>` directory configuration, providing functions to set, retrieve, and check the directory's existence. It supports operations to locate specific subdirectories or files within the site directory, ensuring they exist and are of the correct type. Useful for plugin initialization and resource management tasks that depend on fixed directory structures.",
      "description_length": 389,
      "index": 4735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages stateful key-value mappings with dynamic resolution, change tracking, and serialization, using parameterized key and value modules `K` and `V`. It supports aliasing, category-based organization through predefined and custom categories, and command-line integration with validation and defaults. The core map structure enforces unique bindings, provides deep copy, equality, and project-based membership, making it suitable for static analysis and configuration tasks. Examples include managing analysis parameters in Frama-C plugins, implementing reactive models with custom hooks, and handling persistent, hierarchical state in interactive tools.",
      "description_length": 667,
      "index": 4736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module organizes key-value mappings with filepaths as keys, integrating state tracking, project scoping, and category-based configuration. It supports operations like membership checks, iteration, marshaling, and aliasing, with data grouped into categories that control behavior, such as `@default` or `@all`, and deprecation flags. The module works with a core data type representing file paths, enabling equality, comparison, and pretty-printing, while child modules handle string-based configuration with validation, category definitions, and scoped file path analysis. Use cases include tracking file states, managing structured configurations, and implementing static analysis tools with precise path and parameter handling.",
      "description_length": 734,
      "index": 4737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.State_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a specific directory path for storing state data, providing operations to retrieve, set, and check the existence of the directory. It works with string identifiers and handles paths using the `Frama_c_kernel.Filepath.t` type. Concrete use cases include setting up and accessing plugin-specific storage directories during analysis.",
      "description_length": 350,
      "index": 4738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath_list",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a dynamic list of file paths with support for runtime modifications, command-line integration, and custom serialization. It provides core operations for list manipulation\u2014such as adding, filtering, and folding\u2014alongside submodules that introduce category-based grouping, type-safe path lists with deep copying and membership checks, and utilities for handling string-based CLI parameters with validation and alias resolution. You can use it to configure analysis targets across projects, manage input dependencies with dynamic filtering, and persist path settings using domain-specific formats. The combination of direct list operations and submodules enables structured handling of file paths in both interactive and batch analysis scenarios.",
      "description_length": 763,
      "index": 4739,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Value_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a value type for strings with support for equality, comparison, hashing, and pretty-printing. It provides conversions to and from standard strings, with deep copying and membership checks over project skeletons. It is used to represent and manipulate string values within a larger analysis framework requiring structured data handling.",
      "description_length": 358,
      "index": 4740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_site_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module constructs a `Site_dir` from an existing parent directory and a target directory name. It provides `get_dir` and `get_file` functions to resolve subdirectories and files within the site, ensuring they exist and are of the correct type. Use this when building directory structures for analysis tools that require strict path validation and resolution.",
      "description_length": 362,
      "index": 4741,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_list",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages mutable string lists with change tracking, serialization, and dynamic extension via update hooks, supporting operations like insertion, iteration, and list composition. It integrates with Frama-C's analysis framework for auditable list modifications in configuration and data pipeline scenarios. The module organizes string elements into categories such as '@none', '@default', and '@all', enabling structured access and activation control across analysis contexts. It also includes command-line parameter handling with validation, allowing string lists to be set, retrieved, and constrained to predefined values or function names.",
      "description_length": 651,
      "index": 4742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filepath",
      "library": "frama-c.analysis-scripts",
      "description": "This module handles optional file paths with support for mutation, change hooks, and custom marshaling, enabling dynamic tracking and persistence in configuration systems. It provides operations to inspect, compare, and pretty-print file path values, including checks for emptiness and project-specific metadata. Child modules enhance this functionality with structured representations and kernel integration for analysis tasks. Example uses include synchronizing project state across sessions and reacting to file path updates through registered callbacks.",
      "description_length": 557,
      "index": 4743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages collections of kernel functions with set-like operations, supporting addition, iteration, and state synchronization through change notifications and project-specific contexts. It integrates metadata handling via submodules that organize parameter categories, define string-based command-line parameters with validation, and provide structured data representations with type descriptors. These components enable tasks like tracking function visibility, configuring plugin parameters through command-line interfaces, and persisting typed values in Frama-C analyses. Key data types include `Frama_c_kernel.Cil_datatype.Kf.Set.t` for function sets, `Frama_c_kernel.Parameter_category.t` for parameter grouping, and customizable string and typed value descriptors for configuration and serialization.",
      "description_length": 815,
      "index": 4744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Custom",
      "library": "frama-c.analysis-scripts",
      "description": "This module enables the definition and management of stateful options with customizable types, supporting operations like value comparison, update hooks, and serialization. It works with custom types defined via the `V` module and string lists for metadata, allowing configuration of command-line parameters with aliases, visibility controls, and constraints. It integrates with Frama-C kernel objects to track computed states and manage analysis-specific values such as abstract states or results. Use cases include building extensible command-line interfaces with deprecated or restricted options and maintaining project-specific state with custom comparison and storage behavior.",
      "description_length": 682,
      "index": 4745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Enum",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages enumeration parameters as variant types with structural equality, enabling value assignment, change tracking via hooks, and CLI integration, primarily interacting with `Frama_c_kernel.Typed_parameter.t` for typed parameter handling. It provides core operations such as serialization, default value setup, and project-persistent state management, while its child module enhances the enumerated type with comparison, membership testing, and pretty-printing. Specific uses include defining analysis configuration flags or tool modes with a fixed set of values, supporting both user-facing interfaces and internal state synchronization in verification workflows.",
      "description_length": 678,
      "index": 4746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Action",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean-valued state for command-line options and kernel parameters, with support for dynamic updates, serialization, and integration with Frama-C's project system. It allows defining flags with pre/post-update hooks, command-line aliases, and project-specific behavior, enabling precise control over analysis switches. The child module enhances this functionality by introducing a custom data type that supports equality, comparison, and pretty-printing, specifically designed for static analysis contexts. Together, they enable tasks such as tracking and persisting analysis configurations, or implementing complex state transitions in Frama-C plugins.",
      "description_length": 674,
      "index": 4747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a string-keyed map with dynamic values, supporting atomic updates, default resolution, and dependency-aware observation. It works with parameterized values via module V, which provides structured data with equality, comparison, and pretty-printing for static analysis, enabling deep copies and membership tracking. A sub-module handles category definitions for parameter classification, allowing setup of enabled states and dependencies, while another manages command-line string parameters with validation and function name tracking. Together, they enable hierarchical configuration systems with change tracking, CLI integration, and persistent, serialized state management.",
      "description_length": 695,
      "index": 4748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Filled_string_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages configurable string sets with support for dynamic updates, metadata, and custom marshaling, integrating change-tracking hooks and project-aware operations. It defines core data types for string sets and categories, enabling precise membership checks, set transformations, and parameter validation, while supporting aliases, defaults, and help messages. Child modules provide concrete implementations for filled string sets, command-line parameter handling, and category-based configuration, allowing use cases such as tracking analysis state, filtering string collections, and defining extensible parameter groups with validation. Together, they enable robust configuration management, static analysis extensions, and tooling workflows with fine-grained control over string data and categories.",
      "description_length": 814,
      "index": 4749,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a set-like collection of elements with change tracking, alias management, and visibility control, operating over elements of type `E.t` with support for serialization, command-line integration, and categorized state. It provides core operations for addition, membership testing, iteration, and metadata manipulation, while child modules extend its capabilities with string parameter validation, category-based grouping, and structured data comparison. The string parameter submodule enables project-specific set queries and value restrictions, the category submodule allows collective control of parameter behavior through named groups like `@default`, and the data type submodule supports deep equality and project-driven membership checks. Together, they enable fine-grained, dynamic set management in contexts such as configuration systems, extensible CLI parsers, and static analysis frameworks.",
      "description_length": 919,
      "index": 4750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Config_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages the plugin's configuration directory by providing functions to retrieve, set, and check the existence of directory and file paths. It operates on string identifiers and returns paths as `Frama_c_kernel.Filepath.t` values, supporting optional path creation. Concrete use cases include setting up plugin-specific storage locations and accessing configuration files during analysis.",
      "description_length": 399,
      "index": 4751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_user_dir_opt",
      "library": "frama-c.analysis-scripts",
      "description": "This module constructs and manages a user directory option from an existing directory structure. It provides operations to retrieve or create directories and files within the user-specified path, using configurable names and environment variables. Concrete use cases include setting up analysis-specific output directories or locating configuration files based on user-defined paths.",
      "description_length": 383,
      "index": 4752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Debug",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages mutable integer states with configurable range constraints, enabling operations to set, increment, and monitor values through hooks, serialization, and command-line integration. It supports structured data representation with custom types that allow equality checks, comparison, hashing, and pretty-printing, facilitating deep copying and project membership validation. You can use it to configure analysis parameters and track project-specific state in static analysis workflows, such as monitoring abstract values or managing program constructs during Frama-C analyses. The module combines direct state manipulation with rich data handling from its submodules to support complex analysis scripting.",
      "description_length": 720,
      "index": 4753,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_multiple_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a global, mutable string-keyed map of value lists with support for dynamic state updates, custom marshaling, and project-specific tracking. It provides core operations for key membership tests, value transformations, and lifecycle callbacks, along with utilities for string-based categorization and default value handling. The module's data types support equality checks, hashing, and pretty-printing, enabling integration with static analysis tools and command-line interfaces. Submodules enhance this functionality by structuring parameter groups, enforcing input validation, and representing string-indexed maps during program analysis.",
      "description_length": 659,
      "index": 4754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_list",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a list-based state with change tracking, supporting operations to set, compare, and retrieve values, register callbacks, and customize serialization. It provides data types for elements and state objects, enabling advanced manipulations like appending, folding, and handling element aliases with metadata. Child modules enhance functionality with structured data types for static analysis, categorized parameter control, and validated string parameter handling. Examples include building reactive configuration systems, managing symbolic analysis values, and constructing command-line interfaces with structured string validation.",
      "description_length": 650,
      "index": 4755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.String_set",
      "library": "frama-c.analysis-scripts",
      "description": "This component provides a string set type (`t`) with combined functional and imperative semantics, supporting operations like membership checks, iterative transformations, and emptiness verification, along with command-line integration, update hooks, and project state synchronization. Its submodules enable categorization of string sets with custom parameter groups, efficient equality and comparison operations, and typed command-line parameter management with validation and alias resolution. Use cases include parsing and restricting command-line arguments to predefined values, tracking dynamic configuration changes with update hooks, and maintaining analysis context across Frama-C sessions using project-aware filtering and serialization. The combination of direct API operations and modular extensions supports both standalone string set manipulation and deep integration with Frama-C's plugin architecture.",
      "description_length": 916,
      "index": 4756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.True",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean states with lifecycle and serialization support, integrating tightly with Frama-C kernel parameters for persistent configuration and dynamic updates. It allows setting and retrieving boolean values, registering callbacks on changes, and handling marshaling for project-specific state tracking. The child module enhances it with operations over a static analysis datatype, supporting equality, comparison, hashing, and pretty-printing of `Datatype.t` values. Together, they enable building analysis plugins that maintain synchronized, serializable configuration flags and manipulate structured analysis data with robust traversal and comparison capabilities.",
      "description_length": 685,
      "index": 4757,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Verbose",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages integer-based configuration options with range constraints, supporting operations like set, increment, and bound validation, while maintaining internal state synchronized with project data and change-tracking hooks. It defines a core data type `t` with rich structural operations, including equality, comparison, and pretty-printing, designed for use in static analysis scripts and integrated with Frama-C's kernel structures. You can use it to enforce numeric configuration limits in CLI tools, track value changes in analysis workflows, or persist validated state across sessions. Submodule functionality extends the type's utility in program verification contexts, enabling deep copying, membership checks, and representation of analysis-specific values.",
      "description_length": 777,
      "index": 4758,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Value_int",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines operations for handling integer values within a specific analysis framework, including equality checks, comparison, hashing, and pretty-printing. It works with the `int` type and provides functions to convert integers to and from strings, copy values, and check membership based on project conditions. Concrete use cases include representing and manipulating integer data in static analysis scripts, particularly when integrating with Frama-C's value analysis infrastructure.",
      "description_length": 495,
      "index": 4759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Int",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages integer values with rich state tracking and range constraints, supporting command-line options, project-specific state transitions, and bounded integer parameters. It provides core operations for modifying, querying, and validating integers, along with utilities for defining ranges and handling stateful changes. The child module extends this functionality by offering structured manipulation of integer lists, including equality checks, projections, and safe copying, which is useful for tracking sequences like variable indices in analysis plugins. Together, they enable precise control and customization of integer values and sequences in static analysis workflows.",
      "description_length": 689,
      "index": 4760,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Session",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages the user-specific session directory for a plugin, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports operations like setting or checking the session directory. Concrete use cases include storing plugin-specific data, logs, or temporary files in a structured and accessible way.",
      "description_length": 402,
      "index": 4761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_user_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module constructs a user directory from an existing parent directory and a target directory name. It provides `get_dir` and `get_file` functions to retrieve or create directories and files, with an optional `create_path` flag to control path creation. Use cases include managing user-specific directory structures and file paths in analysis workflows.",
      "description_length": 356,
      "index": 4762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Float",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages floating-point parameters with support for command-line configuration, validation constraints, and state persistence. It provides operations to set value ranges, register change hooks, and customize marshaling, working directly with `float` values. The child module enhances this functionality by defining a precise `t` type for representing floats with optional decimal points, enabling accurate comparison, hashing, and integration with Frama-C's type system. Together, they support building robust analysis tools that handle validated numerical inputs, enforce numeric bounds, and maintain session-persistent parameter states during static analysis.",
      "description_length": 672,
      "index": 4763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Make_multiple_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module organizes a parameterized map structure where keys map to lists of values, supporting multibindings, custom serialization, and update hooks for tracking state changes. It provides core operations to manipulate key-value associations, manage aliases, and monitor modifications, particularly useful for hierarchical configuration and dynamic state tracking in static analysis. The first child module enhances it with structured data types for abstract value analysis, offering equality, comparison, and deep copying for use in Frama-C plugins. The second extends it with category management for parameter control, enabling configurable activation states like `@none` and `@default`, while the third adds support for validated, multibound string parameters, ideal for CLI interfaces and analysis tools requiring repeatable, stateful options like `--include`.",
      "description_length": 867,
      "index": 4764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages mappings from kernel functions to arbitrary values, supporting addition, lookup, and stateful modifications with pre and post-update hooks. It structures data using key-value pairs with customizable categorization, string representation, and command-line integration, and provides iteration, equality checks, and marshaling. It enables static analysis tools to track function metadata, apply transformations, and aggregate results across program functions with project-scoped configuration. The module works with data types like `Category.t` for configurable analysis modes, string-valued parameters for validated command-line settings, and `Datatype.t` for abstract kernel data, supporting use cases such as enabling global analysis behaviors, validating function identifiers, and comparing function declarations across projects.",
      "description_length": 850,
      "index": 4765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintLibc.Datatype",
      "library": "frama-c.analysis-scripts",
      "description": "This module defines a custom data type `t` with operations for equality, comparison, hashing, and pretty-printing, tailored for representing and manipulating structured values in static analysis. It includes descriptors for type representation, a list of representants, and utilities for project membership checks and deep copying. Concrete use cases include modeling abstract values in Frama-C plugins, enabling precise dataflow analysis and value printing during program analysis.",
      "description_length": 482,
      "index": 4766,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Zero",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages configurable integer parameters with mutable state, allowing values to be set, retrieved, and adjusted within defined ranges, with support for change notifications and custom serialization. It integrates command-line features like alias resolution and contextual help, making it ideal for dynamic configuration in interactive tools. The child module enhances this functionality by providing structured data manipulation with equality, comparison, and pretty-printing operations, along with deep copying and membership testing for project skeletons. Together, they enable robust state management, validated input handling, and structural analysis in Frama-C plugins.",
      "description_length": 685,
      "index": 4767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Cache_dir",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages a plugin-specific cache directory, providing functions to retrieve or create directories and files within it. It works with file paths represented as `Frama_c_kernel.Filepath.t` and supports conditional path creation. Concrete use cases include storing and accessing cached analysis results or temporary files in a structured directory.",
      "description_length": 356,
      "index": 4768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Empty_string",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages string-valued configuration options with change tracking, using a validated string type `t` and `Frama_c_kernel.Typed_parameter.t` to enforce input constraints. It supports setting defaults, registering update hooks, and handling marshaled state, enabling robust command-line parsing and dynamic configuration in Frama-C plugins. The child module enhances `t` with equality, comparison, hashing, and pretty-printing, along with deep copying and project membership checks. Together, they model domain-specific strings that can be persisted, validated, and dynamically updated within analysis plugins.",
      "description_length": 619,
      "index": 4769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Fundec_set",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages sets of function declarations and definitions, supporting set operations like membership checks, iteration, and folding, along with CLI configuration features such as serialization and option aliases. It centers around `Fundec.Set.t` for structured state management and `Frama_c_kernel.Cil_types.fundec` for analyzing function definitions, enabling use cases like plugin state tracking and categorized function set processing. Submodules extend functionality with category-based organization, string parameter handling with validation and pretty-printing, and custom data types for analysis-specific structures, supporting dynamic configuration, efficient equality checks, and project-aware membership tests. Together, they enable workflows such as configuring analysis parameters with named categories, maintaining validated global string state, and representing complex data in Frama-C plugins.",
      "description_length": 916,
      "index": 4770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self.Kernel_function_multiple_map",
      "library": "frama-c.analysis-scripts",
      "description": "This module organizes a parameterized map that associates kernel functions with lists of values, supporting operations to set, update, and query entries while tracking state changes through hooks. It integrates custom marshaling, equality checks, and category-based representations, leveraging submodules for value serialization, category management, and string parameter handling. You can use it to define analysis configurations that track function-specific data, manage named categories with dependencies, or enforce validated string parameters across Frama-C plugins. Specific applications include synchronizing analysis modes, structuring identifiers with semantic identity, and maintaining project-wide function policies with dynamic validation.",
      "description_length": 751,
      "index": 4771,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.SemanticLocs",
      "library": "frama-c.analysis-scripts",
      "description": "This module implements a hash table-based structure for mapping source code locations to arbitrary data, supporting efficient insertion, lookup, and in-place modification with sequence-based batch operations. It works with `SemanticLocs.t` containers that associate `Cil_datatype.Location.t` keys with values, enabling transformations and queries over collections of semantic locations using lazy sequences. Typical use cases include analyzing or aggregating location-annotated program data, filtering sequences of key-value pairs, and computing statistics across mapped locations in static analysis workflows.",
      "description_length": 610,
      "index": 4772,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.Self",
      "library": "frama-c.analysis-scripts",
      "description": "This module provides utilities for logging, debugging, and configuration control in static analysis tools, manipulating structured data types such as strings, floats, filepaths, enums, and typed collections like `String_set` and `Filepath_list`. It enables tasks like suppressing warnings, formatting diagnostics, and maintaining stateful data structures, with support for command-line integration, change tracking, and persistent configuration across analysis sessions. Child modules extend these capabilities with specialized state management for booleans, integers, floats, strings, and collections, enabling fine-grained control over analysis parameters, function sets, and directory structures. Examples include tracking analysis phases, validating function names, configuring output sections, and managing session-specific storage with dynamic filtering and serialization.",
      "description_length": 878,
      "index": 4773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintLibc",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean parameter state with change tracking and lifecycle hooks, operating on a `t` type that supports equality, comparison, hashing, and pretty-printing. It integrates with Frama-C's project state system to enable command-line option parsing, persistent configuration, and conditional logging control. The child module enhances it with structured value manipulation, allowing analysis plugins to model abstract values, perform dataflow analysis, and print values during program analysis. Together, they support building configurable, state-aware static analysis tools with precise control over boolean and structured parameters.",
      "description_length": 650,
      "index": 4774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.Output",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages file path options with lifecycle hooks, CLI integration, and project state tracking, while also providing a utility to check if a file path points to an empty file. It works with `Frama_c_kernel.Filepath.t` and internal state markers to support configuration handling and input validation in static analysis tools. The child module enhances this functionality by introducing a custom data type for structured analysis outputs, enabling deep copying, equality checks, and comparison across analysis runs. Together, they allow managing file-based configurations and querying structured analysis results with precise tracking of project values.",
      "description_length": 661,
      "index": 4775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions.PrintDeclarations",
      "library": "frama-c.analysis-scripts",
      "description": "This module manages boolean parameter states with support for update hooks, default values, and command-line integration, using a boolean type alias `t` to track project-specific state. It enables feature toggles like output visibility control and synchronization across components, with direct operations to set, get, and monitor changes. The child module enhances this by defining a structured `t` type with equality, comparison, and pretty-printing capabilities, supporting deep inspection and manipulation of type declarations in static analysis plugins. Together, they allow precise control and extension of state-driven behaviors in both core logic and plugin ecosystems.",
      "description_length": 677,
      "index": 4776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts.List_functions",
      "library": "frama-c.analysis-scripts",
      "description": "This module processes and analyzes C function definitions, tracking their locations and sizes while providing JSON or plain text output formatting. It leverages semantic location mappings to enable filtering and inspection of function data, supporting tasks like generating reports on Frama-C libc files or analyzing code structure for static analysis. The module integrates with submodules for location-based data mapping, configuration control, and file path handling, enabling operations such as aggregating function statistics, validating file inputs, and managing stateful parameters via command-line interfaces. Specific capabilities include logging diagnostics, tracking boolean and numeric state changes, and serializing structured analysis outputs across multiple runs.",
      "description_length": 778,
      "index": 4777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Analysis_scripts",
      "library": "frama-c.analysis-scripts",
      "description": "This module analyzes C function definitions by extracting location and size metadata, supporting JSON or plain text output for reporting and static analysis tasks. It processes input files, tracks function metrics, and applies filters using semantic location mappings to generate structured outputs. Key operations include aggregating function statistics, validating file structures, and managing state through command-line parameters. Examples include generating size reports for Frama-C libc functions or serializing analysis results across multiple runs.",
      "description_length": 557,
      "index": 4778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Metrics_gui.Register_gui",
      "library": "frama-c-metrics.gui",
      "description": "Implements custom GUI components and event handlers for visualizing and interacting with metrics data in the Frama-C interface. Works with Frama-C's GUI framework and plugin-specific data structures to display metrics in a user-friendly format. Enables users to filter, sort, and inspect code metrics directly within the IDE.",
      "description_length": 325,
      "index": 4779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics_gui.Metrics_gui_panels",
      "library": "frama-c-metrics.gui",
      "description": "This module provides functions to create and manage GUI panels for displaying metrics in a LablGTK-based interface. It handles initialization of the main metrics panel, registration of metrics with associated display functions, and dynamic switching between metric views. Key data structures include LablGTK boxes and tables, with operations to reset panel content and register UI components for specific metrics.",
      "description_length": 413,
      "index": 4780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metrics_gui",
      "library": "frama-c-metrics.gui",
      "description": "This module integrates custom GUI components and event handlers to visualize and interact with code metrics within Frama-C's interface. It uses LablGTK to build and manage panels, allowing dynamic display, filtering, and switching between different metric views. Key operations include registering metrics with display functions, resetting panel content, and handling user interactions to inspect and sort metrics directly in the IDE. For example, users can dynamically switch between cyclomatic complexity and code coverage views or filter metrics by function name.",
      "description_length": 566,
      "index": 4781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence.Register",
      "library": "frama-c-occurrence.core",
      "description": "This module tracks and classifies variable occurrences in CIL code, providing functions to retrieve and print lists of variable uses. It works with CIL kernel functions, instructions, and lvalues to identify where variables are accessed. Concrete use cases include analyzing variable usage patterns for static analysis or debugging specific variable interactions in the code.",
      "description_length": 375,
      "index": 4782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence",
      "library": "frama-c-occurrence.core",
      "description": "This module analyzes variable occurrences in CIL code by tracking and classifying uses of variables across functions and instructions. It identifies access points using CIL kernel elements like lvalues, enabling precise retrieval and display of variable usage patterns. Key operations include listing variable uses, filtering by context, and printing structured reports. For example, it can isolate all read or write operations on a specific variable within a function, aiding in static analysis or debugging variable interactions.",
      "description_length": 531,
      "index": 4783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopAnalysis.Loop_analysis",
      "library": "frama-c-loop-analysis.core",
      "description": "This module analyzes loops within a function to estimate their maximum iteration count. It processes statements annotated with loop bounds, providing functions to retrieve and fold over these bounds. It is used to determine the worst-case execution time or resource usage of loops in C code.",
      "description_length": 291,
      "index": 4784,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LoopAnalysis",
      "library": "frama-c-loop-analysis.core",
      "description": "This module analyzes loops in C functions to estimate their maximum iteration count by processing statements annotated with loop bounds. It provides functions to retrieve and fold over these bounds, enabling the determination of worst-case execution time or resource usage. For example, it can extract a loop's upper bound from a `for` loop condition or accumulate bounds across nested loops to compute total iterations. Key data types include loop bound annotations and statement nodes representing loop structures.",
      "description_length": 516,
      "index": 4785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constant_Propagation.Api",
      "library": "frama-c-constant_propagation.core",
      "description": "Implements constant propagation analysis by computing and applying constant values across functions. Works with CIL fundec structures and project states, using sets of functions to guide propagation. Useful for optimizing code by replacing variables with known constants during static analysis.",
      "description_length": 294,
      "index": 4786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constant_Propagation",
      "library": "frama-c-constant_propagation.core",
      "description": "This module performs constant propagation analysis by computing and applying constant values across functions using CIL fundec structures and project states. It identifies variables with known constant values and replaces their occurrences to optimize code during static analysis. Key data types include sets of functions and constant value mappings, with operations to propagate and apply these constants. For example, it can replace a variable `x` with `5` throughout a function body if `x` is determined to be a constant.",
      "description_length": 524,
      "index": 4787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Aorai",
      "library": "frama-c-aorai.core",
      "description": "This module implements a plugin for translating LTL (Linear Temporal Logic) formulas into ACSL (ANSI/ISO C Specification Language) assertions. It operates on abstract syntax trees representing LTL formulas and generates corresponding ACSL annotations for use in formal verification of C programs. Concrete use cases include integrating temporal logic specifications into C code for runtime checking or static analysis.",
      "description_length": 418,
      "index": 4788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Occurrence_gui.Register_gui",
      "library": "frama-c-occurrence.gui",
      "description": "This module extends the graphical user interface to integrate controls and visual elements specific to the occurrence plugin. It works with GUI components and event handlers to display and manage occurrence-related data directly within the application's interface. Concrete use cases include rendering occurrence statistics, enabling user interaction with occurrence filters, and updating display elements in response to data changes.",
      "description_length": 434,
      "index": 4789,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Occurrence_gui",
      "library": "frama-c-occurrence.gui",
      "description": "The module enhances the application's GUI by adding occurrence-specific controls and visualizations. It manages user interactions with occurrence data through filters and dynamic display updates. Key data types include occurrence statistics and filter configurations, with operations for rendering, modifying, and responding to changes in this data. Example uses include displaying real-time occurrence counts and enabling interactive filtering within the interface.",
      "description_length": 466,
      "index": 4790,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 5011,
    "meaningful_modules": 4791,
    "filtered_empty_modules": 220,
    "retention_rate": 0.9560965875074835
  },
  "statistics": {
    "max_description_length": 1098,
    "min_description_length": 139,
    "avg_description_length": 527.4594030473805,
    "embedding_file_size_mb": 17.40207862854004
  }
}