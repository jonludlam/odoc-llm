{
  "package": "ego",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 18,
  "creation_timestamp": "2025-08-15T12:14:49.102844",
  "modules": [
    {
      "module_path": "Ego.Generic.Make.Rule",
      "library": "ego",
      "description": "This module defines rewrite rules for transforming expressions in an EGraph, supporting syntactic, conditional, and dynamic rewrites. It works with expression patterns and schemas represented via `L.op` and `Query.t`, along with EGraph structures like eclasses and analyses. Concrete use cases include defining optimization rules for symbolic expressions, such as constant folding, algebraic simplifications, or domain-specific transformations based on analysis data.",
      "description_length": 467,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ego.Generic.Scheduler.Simple",
      "library": "ego",
      "description": "This module implements a basic equality saturation scheduler that applies all rules in every iteration without any optimization. It tracks scheduler state using `data` and `t` types, supporting rule metadata creation and termination checks based on iteration count. It is suitable for small, finite rewrite systems where performance is not a concern.",
      "description_length": 350,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.Make.BuildRunner",
      "library": "ego",
      "description": "This module enables custom scheduling strategies for controlling equality saturation by repeatedly applying rewrites until saturation, a node limit, or a user-defined predicate is met. It operates on EGraphs parameterized by a language, analysis, and rewrite rules, supporting precise control over the saturation process. Concrete use cases include implementing domain-specific termination policies or prioritizing rule applications to optimize convergence.",
      "description_length": 457,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.Scheduler.Backoff",
      "library": "ego",
      "description": "The `Backoff` module implements an exponential backoff scheduler that tracks and limits rule applications during equality saturation. It maintains a maximum match limit per rule and bans rules that exceed this limit for a specified duration, using exponential backoff to reduce frequent rule firings. This helps prevent non-productive rules from dominating the search, improving convergence in complex rewrite scenarios.",
      "description_length": 420,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ego.Generic.MakeExtractor",
      "library": "ego",
      "description": "This module provides an `extract` function that computes a mapping from EClass identifiers to minimized-cost terms in a user-defined language, using a specified cost system. It operates on egraphs parameterized by a language and cost structure, producing concrete term extractions. Useful for retrieving optimized expressions after equality saturation.",
      "description_length": 352,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.Make",
      "library": "ego",
      "description": "This module constructs an EGraph engine for equality saturation, parameterized over user-defined languages and analyses. It supports operations like adding terms, merging equivalence classes, applying rewrite rules, and querying subgraphs, working with language operations (`L.op`), analysis states (`A.t`), and EGraph structures like eclasses and analyses. Concrete use cases include optimizing symbolic expressions through custom analyses\u2014such as tracking variable bounds or simplifying algebraic terms during program transformation.",
      "description_length": 535,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ego.Generic.Scheduler",
      "library": "ego",
      "description": "The module implements schedulers that control rule application during equality saturation. It works with EGraphs and rule sets, managing iteration strategies to optimize convergence. Concrete use cases include limiting rule firing with exponential backoff or applying all rules uniformly in simple systems.",
      "description_length": 306,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Basic.Rule",
      "library": "ego",
      "description": "This module represents syntactic rewrite rules over S-expressions using pattern matching and replacement. It provides operations to construct rules from query patterns, and to pretty-print or convert rules to strings. These rules are used to define transformations for equality saturation in an EGraph, specifically for syntactic rewriting without custom analyses.",
      "description_length": 364,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.MakePrinter",
      "library": "ego",
      "description": "This module provides a `to_dot` function that converts an EGraph into a Graphviz representation for debugging. It operates on EGraphs parameterized by a language and analysis, rendering their structure visually. Use it to inspect the internal state of an EGraph during equality saturation.",
      "description_length": 289,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.StringMap",
      "library": "ego",
      "description": "This module implements functional and bulk operations for managing string-keyed maps with ordered bindings, supporting associative manipulations like insertion, removal, and updates, alongside transformations such as filtering, partitioning, and sequence-based construction. It works with key-value pairs where keys are strings and values can be arbitrary types, emphasizing ordered traversal and lazy evaluation through sequence conversions. These capabilities are particularly useful in equality saturation workflows where maintaining key order is critical or integrating custom analyses that require efficient, functional transformations of symbolic mappings.",
      "description_length": 662,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic.Query",
      "library": "ego",
      "description": "This module provides functions to construct, convert, and pretty-print queries over expressions, primarily used for defining matching and transformation patterns in equality saturation. It operates on polymorphic query structures parameterized over operator types, supporting input/output via s-expressions and formatted printing. Concrete use cases include parsing and serializing rewrite rules, and displaying query patterns for debugging or inspection.",
      "description_length": 455,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Basic.Symbol",
      "library": "ego",
      "description": "This module provides string interning and symbol resolution via `intern` and `to_string`, mapping strings to unique integer identifiers and vice versa. It operates on the abstract type `t`, which represents interned strings as integers. This is used to efficiently manage and compare string-based identifiers within the EGraph implementation.",
      "description_length": 342,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Basic.EGraph",
      "library": "ego",
      "description": "This module manages an EGraph structure that supports adding S-expressions, merging equivalence classes, and extracting minimized terms based on a cost function. It provides operations for equality saturation via rule application, including running until saturation or a fuel limit is reached, and supports visualization through Graphviz output. Use cases include optimizing symbolic expressions, implementing term rewriting systems, and analyzing equivalence in syntactic structures.",
      "description_length": 484,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Basic.Query",
      "library": "ego",
      "description": "This module represents patterns over S-expressions for defining syntactic rewrites in an equality saturation engine. It supports parsing and pretty-printing patterns, converting between S-expressions and internal representation, and is used to specify rewrite rules over symbolic expressions. Concrete use cases include defining matchers and transformers for program optimization and term rewriting.",
      "description_length": 399,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Generic",
      "library": "ego",
      "description": "This module implements a customizable equality saturation engine parameterized over user-defined languages and analyses. It provides functions to build, modify, and query EGraphs through a set of interfaces that define language terms, analysis logic, and cost models. Concrete use cases include implementing domain-specific optimizers, theorem provers, and program synthesizers where custom analyses drive rewrite strategies and equivalence tracking.",
      "description_length": 450,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Id",
      "library": "ego",
      "description": "This module implements a union-find data structure for managing equivalence classes in an EGraph. It uses a private integer type to represent class identifiers and supports merging and querying equivalence relationships. It is used internally by the EGraph implementation to track and unify equivalent expressions during equality saturation.",
      "description_length": 341,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego.Basic",
      "library": "ego",
      "description": "This module implements a syntactic rewrite engine over S-expressions using an EGraph-based equality saturation approach. It supports defining and applying rewrite rules via pattern matching on symbolic expressions, with concrete use cases in program optimization and term rewriting. The engine operates on interned strings and S-expressions, enabling efficient equivalence class management and rule-driven transformation.",
      "description_length": 421,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ego",
      "library": "ego",
      "description": "This module implements an equality saturation engine for S-expressions with support for syntactic rewrites and custom analyses. It works with interned strings, symbolic expressions, and user-defined language terms, organizing them into equivalence classes using a union-find structure. Concrete use cases include program optimization, term rewriting, and building domain-specific optimizers or theorem provers.",
      "description_length": 410,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 18,
    "meaningful_modules": 18,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 662,
    "min_description_length": 289,
    "avg_description_length": 416.8888888888889,
    "embedding_file_size_mb": 0.2612943649291992
  }
}