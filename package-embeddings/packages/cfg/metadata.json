{
  "package": "cfg",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 30,
  "creation_timestamp": "2025-07-15T23:12:53.110747",
  "modules": [
    {
      "module_path": "Cfg.Cfg_impl.Make.NTSet",
      "library": "cfg",
      "description": "This module implements ordered collections of comparable elements with support for standard set operations like union, intersection, and difference, alongside element manipulation (insertion, removal, extremal queries). It provides ordered iteration, transformation via mapping and filtering, and conversion to and from lists and sequences while preserving element ordering. These operations are particularly useful for scenarios requiring efficient manipulation of sorted, unique-element structures, such as compiler intermediate representations or ordered data analysis pipelines.",
      "description_length": 582,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.TMap",
      "library": "cfg",
      "description": "This module provides ordered map operations for polymorphic key-value pairs where keys adhere to a total ordering. It supports efficient insertion, deletion, and lookup, along with transformations like mapping, filtering, and merging maps using custom combinators. Use cases include maintaining sorted associations, processing key-ordered sequences of data, and combining maps while preserving structural constraints.",
      "description_length": 417,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.NTMap",
      "library": "cfg",
      "description": "This module provides ordered map operations for key-value pairs where keys are of type `Spec.nt`, supporting insertion, deletion, merging, and ordered traversal. It emphasizes ordered key-based manipulation with functions like `find_first`, `fold`, and `to_seq`, while enabling bulk transformations, structural analysis, and sequence-driven construction. Use cases include managing sorted associative data, converting between maps and sequences, and performing key-range queries or conditional filtering with guaranteed ordering semantics.",
      "description_length": 539,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.NTMap",
      "library": "cfg",
      "description": "This module implements a persistent map structure for managing non-terminal symbols with ordered keys, supporting insertion, deletion, and combination of bindings alongside ordered traversal and range-based queries. It provides both standard associative operations and advanced ordered map functionality like bidirectional iteration, filtering, and sequence conversion, leveraging key ordering for deterministic behavior. Typical applications include representing hierarchical grammatical relationships where ordered non-terminals require efficient lookup, transformation, and analysis during parsing or compiler intermediate representation construction.",
      "description_length": 654,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.ProdMap",
      "library": "cfg",
      "description": "This module implements a sorted associative map for key-value pairs where keys are pairs of `Spec.prod` and `Spec.symbol list`, supporting insertion, deletion, ordered traversal, and sequence-based transformations. It provides ordered operations like merging, filtering, and bidirectional iteration while preserving key ordering through `Ord.compare`, with utilities for converting between maps, lists, and sequences. Typical applications include managing structured symbolic data requiring strict key ordering or processing configurations as ordered key-value streams.",
      "description_length": 569,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.ProdSet",
      "library": "cfg",
      "description": "This module provides ordered set operations for managing collections of production-symbol pairs, supporting efficient membership checks, transformations like mapping and filtering, and set algebra (union, intersection, difference). It works with ordered sets where elements are structured as a production paired with a list of symbols, ensuring deterministic traversal and monotonic predicate evaluation. Designed for scenarios requiring precise ordering guarantees, such as grammar analysis or syntax tree manipulation, it integrates sequence-based construction and iteration for seamless data flow integration.",
      "description_length": 612,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.ProdMap",
      "library": "cfg",
      "description": "This module provides associative map operations for key-value pairs where keys are composed of a production and a symbol list, supporting ordered traversal, predicate-based filtering, and transformations like merging, splitting, or mapping values. It works with polymorphic values and structured keys, enabling efficient lookups, ordered iteration (ascending/descending), and conversions between maps, sequences, and lists. Specific use cases include managing hierarchical grammatical structures with ordered keys, combining symbolic production rules, and processing list-valued entries with optional or conditional access patterns.",
      "description_length": 632,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.NTSet",
      "library": "cfg",
      "description": "This module implements ordered sets for non-terminal symbols (`Spec.nt`) with operations for union, intersection, subset checks, and ordered iteration, supporting transformations like mapping and filtering. It provides conversions to and from lists and sequences, enabling efficient analysis of BNF grammar structures, such as resolving symbol dependencies or validating production rules. The set maintains element uniqueness and ordering via a comparison function, offering both exception-safe and option-based variants for element access and manipulation.",
      "description_length": 557,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.ProdSet",
      "library": "cfg",
      "description": "This module provides a set implementation for elements composed of a production and a symbol list, supporting standard operations like insertion, deletion, union, and intersection, as well as higher-order transformations such as mapping, filtering, and partitioning. It works with sets and sequences, enabling ordered traversal via sequence conversion and efficient set construction from sequential data. This is particularly useful in grammar processing or scenarios requiring ordered iteration over structured elements paired with symbolic annotations.",
      "description_length": 554,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.TSet",
      "library": "cfg",
      "description": "This module provides ordered set operations with elements of type Spec.t, supporting creation, modification, algebraic operations, and ordered traversal. It works with sets, sequences (via Stdlib.Seq.t), and lists, enabling transformations and comparisons while preserving uniqueness and ordering. Use cases include filtering ordered data, converting between structured formats, and safely accessing extremal elements or arbitrary members in a controlled manner.",
      "description_length": 462,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.TMap",
      "library": "cfg",
      "description": "This module implements a polymorphic map with keys of type `Spec.t`, supporting insertion, deletion, and lookup operations that handle missing values via `option` types. It emphasizes ordered key traversal, aggregation through merging and union, and transformations like filtering, mapping, and partitioning, while enabling bulk modifications via sequences for ordered iteration and construction. These features are particularly useful for managing hierarchical configurations or processing ordered data where key ordering and structured manipulation are essential.",
      "description_length": 565,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-ProdSet",
      "library": "cfg",
      "description": "This module provides ordered set operations for managing collections of grammar production-symbol pairs, enabling efficient membership checks, transformations, and comparisons. It works with sets of tuples containing grammar productions and symbol lists, leveraging ordered traversal and functional manipulation patterns for tasks like filtering, mapping, and union operations. Designed for applications requiring precise control over context-free grammar elements, it supports use cases such as grammar analysis, optimization, and derivation path tracking where ordered, unique element handling is critical.",
      "description_length": 608,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Spec",
      "library": "cfg",
      "description": "This module defines core types for representing context-free grammars, including terminals, non-terminals, and production rules. It provides comparison functions for these types to support ordering and equality checks. Use this module when building or analyzing grammatical structures, such as in parsers or language processors.",
      "description_length": 328,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-TSet",
      "library": "cfg",
      "description": "This module provides ordered set operations for manipulating collections of grammar symbols or productions, supporting union, intersection, difference, and cardinality calculations alongside transformations like mapping, filtering, and sequence conversion. It organizes elements of type `Spec.t` in ordered structures using comparison logic from an external module, enabling efficient iteration, element selection, and bulk modifications. Typical applications include grammar analysis tasks requiring ordered set operations, such as computing reachable symbols, optimizing production rules, or processing sequences of grammar elements in sorted order.",
      "description_length": 651,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-ProdMap",
      "library": "cfg",
      "description": "This module provides ordered associative map operations for key-value pairs where keys combine grammar productions and symbol lists, supporting efficient insertion, conditional updates, ordered traversal, and bulk transformations. It enables use cases like tracking production-specific symbol associations, merging grammar rule mappings, and ordered processing of CFG-derived data. The structure maintains key ordering for deterministic iteration and offers sequence-based construction and bidirectional conversion with lists for flexible data manipulation.",
      "description_length": 557,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-NTSet",
      "library": "cfg",
      "description": "This module provides operations for manipulating sets of non-terminal symbols in context-free grammars, including union, intersection, difference, and transformations like mapping and filtering. It works with ordered sets (`NTSet.t`) and supports conversions to and from sequences, enabling efficient iteration and construction while preserving ordering guarantees. Specific use cases include grammar analysis tasks such as computing reachable symbols, determining dependencies, or modifying grammar rules through set operations.",
      "description_length": 529,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make",
      "library": "cfg",
      "description": "This module orchestrates grammar manipulation by integrating construction, transformation, and analysis operations with structured container modules for ordered data handling. It supports grammars composed of terminals, nonterminals, and productions, enabling set-theoretic combinations, pruning of unproductive elements, and derivation depth analysis, while leveraging submodules for efficient ordered sets and maps over symbols, productions, and structured keys. The containers provide insertion, deletion, ordered traversal, and transformation operations, with utilities for conversion between sets, maps, lists, and sequences\u2014facilitating tasks like grammar sanitization, symbolic configuration processing, and ordered key-value stream analysis. Specific applications include compiler intermediate representation management, structured data filtering, and bounded derivation generation with strict ordering and uniqueness guarantees.",
      "description_length": 937,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG",
      "library": "cfg",
      "description": "This interface provides operations for constructing, analyzing, and transforming context-free grammars through set/map manipulations of nonterminals, terminals, and productions. It supports tasks like pruning unproductive symbols, extracting grammar components, and computing derivation constraints using both standard and live grammar representations. Key applications include grammar normalization, reachability analysis, and bounded derivation generation for formal language processing.",
      "description_length": 489,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-NTMap",
      "library": "cfg",
      "description": "This module provides associative map operations for context-free grammar non-terminals, supporting functional and structural manipulation of key-value pairs with ordered traversal capabilities. It works with maps keyed by non-terminal symbols (`Spec.nt`) and arbitrary data types, offering ordered iteration, bulk updates from sequences, and efficient set-like operations. The ordered traversal and key monotonicity assumptions make it suitable for deterministic processing of grammar components like production rules or symbol attributes.",
      "description_length": 539,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf",
      "library": "cfg",
      "description": "This module orchestrates the construction and analysis of context-free grammars by integrating set-theoretic operations, symbol management, and production rule manipulation. It supports direct operations on grammars\u2014such as union, intersection, and derivation depth computation\u2014while leveraging submodules for ordered non-terminal maps, production-symbol sets, and structured key-value stores. These components enable precise grammar transformations, such as pruning unreachable symbols, analyzing production dependencies, and normalizing grammatical forms. With deterministic traversal, efficient lookups, and ordered set algebra, the module facilitates tasks like compiler intermediate representation construction and bounded-depth syntax analysis.",
      "description_length": 750,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-TMap",
      "library": "cfg",
      "description": "This module provides ordered key-value map operations with support for polymorphic transformations, ordered traversal, and list-valued aggregations. It works with maps parameterized over ordered keys (`Spec.t`) and associated values, emphasizing efficient querying, bulk updates from sequences, and ordered iteration. Specific use cases include grammar manipulation requiring key ordering guarantees, incremental map construction from sequential data, and ordered traversal for deterministic processing pipelines.",
      "description_length": 513,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.CFG-Spec",
      "library": "cfg",
      "description": "This module defines core data types for representing context-free grammars, including non-terminals, terminals, and production rules. It provides comparison functions for these types to enable ordering and equality checks. Use cases include building and analyzing grammar structures, such as parsing expressions or generating language constructs.",
      "description_length": 346,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf.SPEC",
      "library": "cfg",
      "description": "This module defines core data types for representing context-free grammars, including non-terminals (`nt`), terminals (`t`), production rules (`prod`), and symbols (`symbol`), which can be either terminals or non-terminals. It provides comparison functions for each type to support ordering and equality checks. These definitions are used to construct and manipulate grammar entities in parsing and language processing tasks.",
      "description_length": 425,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl",
      "library": "cfg",
      "description": "This module coordinates grammar manipulation through construction, transformation, and analysis, using structured containers for ordered data. It supports grammars with terminals, nonterminals, and productions, allowing set-theoretic combinations, pruning, and derivation depth analysis. Key operations include insertion, deletion, traversal, and conversion between sets, maps, lists, and sequences. Examples include sanitizing grammars, processing symbolic configurations, and generating bounded derivations with ordering and uniqueness guarantees.",
      "description_length": 549,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec",
      "library": "cfg",
      "description": "This module provides a comprehensive framework for defining and manipulating context-free grammars through core data types such as terminals, non-terminals, and production rules, along with structured operations for grammar analysis and transformation. It supports key operations including union, intersection, derivation depth computation, and grammar normalization, using ordered sets, maps, and key-value stores for efficient symbol and rule management. Specific use cases include building parsers, analyzing language structures, pruning unreachable grammar components, and constructing compiler intermediate representations with precise syntactic constraints.",
      "description_length": 663,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_parser",
      "library": "cfg",
      "description": "Parses BNF grammar definitions from token streams into structured grammar representations. It processes tokens like `ID`, `DEF`, `PIPE`, and brackets to build grammars following BNF syntax rules. Useful for implementing language parsers or interpreters that require formal grammar specifications.",
      "description_length": 296,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf",
      "library": "cfg",
      "description": "This module defines the core interfaces for manipulating context-free grammars, with data types representing grammars, nonterminals, terminals, and production rules. It supports operations to add or remove productions, query grammar components, and analyze properties, enabling tasks like parser construction and grammar transformation. Submodules provide ordered sets and maps for managing symbols, productions, and their associations, supporting efficient membership checks, transformations, and ordered traversal. Specific capabilities include computing reachable symbols, optimizing grammar rules, tracking production-symbol mappings, and performing deterministic iteration over grammar elements.",
      "description_length": 700,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_pp",
      "library": "cfg",
      "description": "This module provides functions to pretty-print BNF grammar components such as symbol lists, production sets, terminal sets, and nonterminal maps using OCaml's Format module. It supports detailed output of grammar elements including live productions, derivation information, and sets of terminals and nonterminals. Concrete use cases include debugging parser generators, visualizing grammar transformations, and logging analysis results during compiler development.",
      "description_length": 464,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_lexer",
      "library": "cfg",
      "description": "This module implements a lexer for parsing BNF grammars, handling tokenization of identifiers, escaped strings, and lexical start symbols. It operates on `Lexing.lexbuf` input, producing tokens consumed by the BNF parser and accumulating string fragments during escape processing. Concrete use cases include parsing BNF definitions from files or strings into an abstract syntax tree for further processing or validation.",
      "description_length": 420,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg",
      "library": "cfg",
      "description": "This module suite provides a comprehensive toolkit for defining, parsing, manipulating, and analyzing context-free grammars. It centers around core data types for terminals, nonterminals, and production rules, with structured containers like ordered sets and maps enabling efficient membership checks, transformations, and ordered traversal. Key operations include grammar construction, union, intersection, derivation depth analysis, normalization, and pruning of unreachable components, supporting applications such as parser generation, compiler intermediate representation, and language structure analysis. It includes a lexer and parser for BNF grammars, along with utilities for pretty-printing and debugging, enabling end-to-end workflows from grammar specification to visualization and transformation.",
      "description_length": 809,
      "index": 29,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 31,
    "meaningful_modules": 30,
    "filtered_empty_modules": 1,
    "retention_rate": 0.967741935483871
  },
  "statistics": {
    "max_description_length": 937,
    "min_description_length": 296,
    "avg_description_length": 557.2,
    "embedding_file_size_mb": 0.1093740463256836
  }
}