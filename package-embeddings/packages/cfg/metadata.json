{
  "package": "cfg",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 19,
  "creation_timestamp": "2025-08-15T12:22:10.119819",
  "modules": [
    {
      "module_path": "Cfg.Bnf_spec.Bnf.NTSet",
      "library": "cfg",
      "description": "This module offers a functional set abstraction for managing collections of non-terminal symbols (`Spec.nt`), supporting operations like union, intersection, difference, and ordered traversal. It provides transformation, filtering, and folding utilities while maintaining immutability, with utilities for conversion to lists and sequences. It is particularly useful in compiler-related tasks such as analyzing or transforming grammars, where precise set manipulation and ordered iteration over non-terminals are required.",
      "description_length": 521,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.NTMap",
      "library": "cfg",
      "description": "This module provides ordered map operations for key-value pairs with keys of type `Spec.nt`, supporting standard manipulations like insertion, deletion, lookup, and bulk transformations such as merging, filtering, and ordered traversal. It emphasizes sequence-driven workflows, enabling efficient iteration in ascending or descending key order, bulk updates from sequences, and map construction from sequential data. The structure is particularly suited for scenarios requiring strict key ordering guarantees, incremental map assembly from stream-like inputs, or algorithms leveraging monotonic predicates over ordered bindings.",
      "description_length": 628,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.ProdSet",
      "library": "cfg",
      "description": "This module provides ordered set operations for pairs of `Spec.prod` and `Spec.symbol list`, supporting efficient union, intersection, difference, and ordered iteration. It emphasizes directional queries (e.g., `find_first`, `find_last`), set transformations (`map`, `filter`), and sequence integration for ascending/descending traversal. Designed for scenarios requiring ordered element processing and structural sharing optimizations, it suits tasks like parsing or compilation where ordered production rules and incremental set manipulation are critical.",
      "description_length": 557,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.NTMap",
      "library": "cfg",
      "description": "This module provides map operations for non-terminal symbol keys, including functional updates, merging, and ordered iteration, with support for error-free lookups and sequence-based construction. It works with ordered maps that allow filtering, transformation, and structural queries, making it suitable for managing grammar definitions, combining grammar fragments, or processing sequential data in parsing workflows.",
      "description_length": 419,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.ProdMap",
      "library": "cfg",
      "description": "This module implements an ordered map structure for keys composed of grammar production and symbol list pairs, enabling efficient insertion, lookup, and custom merging operations tailored for list-valued bindings. It emphasizes ordered traversal, bulk sequence transformations, and predicate-driven searches, with key ordering constraints enabling optimized operations like `find_first_opt`. Designed for functional persistence, it serves scenarios requiring immutable, structured manipulation of grammar-related mappings, such as compiler intermediate representations or syntax tree analyses.",
      "description_length": 593,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.TSet",
      "library": "cfg",
      "description": "This module implements ordered sets of `Spec.t` elements, supporting insertion, deletion, union, intersection, and difference operations alongside transformations like `map`, `filter`, and `fold`. It maintains elements in a sorted structure using a total ordering, enabling efficient membership checks, ordered iteration, and conversions to/from sequences. It is particularly suited for managing ordered collections in grammar specification processing, where structured manipulation of terminals or symbols is required.",
      "description_length": 519,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.TSet",
      "library": "cfg",
      "description": "This module implements an ordered, persistent set abstraction with efficient set algebra operations, transformations, and ordered traversal capabilities. It works with elements of type `Spec.t` arranged using a parameterized total ordering, supporting use cases like symbolic analysis, sorted collection manipulation, and incremental set construction with structural sharing. Key operations include monotonic predicate search, ordered sequence conversion, and set-theoretic operations that preserve element uniqueness and ordering constraints.",
      "description_length": 543,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.ProdSet",
      "library": "cfg",
      "description": "This module manages ordered collections of production rules paired with symbol sequences, supporting set operations like union, intersection, and difference while preserving element ordering. It enables efficient membership checks, ordered traversal, and transformations through sequence conversions, with directional searches for extremum elements. Such functionality is particularly useful in formal grammar processing where ordered rule sets must be dynamically manipulated and analyzed during parsing or compiler design workflows.",
      "description_length": 534,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl.Make.TMap",
      "library": "cfg",
      "description": "This module implements ordered polymorphic maps with keys of type `Spec.t`, offering operations for insertion, deletion, merging, ordered traversal, and bulk updates from sequences. It supports transformations preserving key order, efficient lookups with optional returns, and complex manipulations like splitting or filtering bindings based on predicates. Designed for scenarios requiring consistent key ordering, it excels in maintaining sorted data collections, processing key-value pairs in ascending/descending order, and handling edge cases safely via optional types instead of exceptions.",
      "description_length": 595,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf.TMap",
      "library": "cfg",
      "description": "This module implements a polymorphic ordered map structure using `Spec.t` as keys, supporting insertion, deletion, merging, and ordered traversal operations like `find_first_opt`, `split`, and `to_seq_from`. It provides transformation functions for filtering, mapping, and folding over key-value pairs, along with sequence-based construction and iteration for efficient data processing. Typical applications include managing hierarchical configurations, processing ordered data streams, or implementing algorithms requiring stable key ordering and efficient lookup.",
      "description_length": 565,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_spec.Bnf",
      "library": "cfg",
      "description": "This module provides grammar manipulation capabilities through ordered, immutable collections of terminals, nonterminals, and productions (using `TSet`, `NTMap`, etc.), enabling operations like production addition, nonterminal removal, set-theoretic combinations, and pruning of unproductive or unreachable elements. It specializes in grammar analysis tasks such as extracting derivation components, computing depth bounds for productions, and generating bounded derivation levels, which are critical for optimizing parsing workflows and eliminating redundant constructs in compiler pipelines. The structured traversal mechanisms and derivation-focused transformations make it particularly suited for tasks like grammar normalization and reachability analysis in formal language processing.",
      "description_length": 790,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_spec.Spec",
      "library": "cfg",
      "description": "This module defines core types for representing context-free grammars, including terminals, non-terminals, and production rules. It provides comparison functions for these types to support ordered collections and structural analysis. Use cases include parsing expression grammars and implementing compiler front-ends.",
      "description_length": 317,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_pp",
      "library": "cfg",
      "description": "This module formats BNF grammar components for display, handling symbols, production sets, and nonterminal maps. It operates on data types like symbol lists, production maps, terminal and nonterminal sets, and derivation information pairs. Use it to print structured grammar details, such as individual productions, nonterminal rules, or terminal sets, with precise formatting via the standard pretty-printer.",
      "description_length": 409,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_parser",
      "library": "cfg",
      "description": "Parses BNF grammar definitions from token streams into structured grammar representations. It processes tokens like `ID`, `DEF`, and `PIPE` to build grammars with production rules. Used to convert lexed input into a BNF structure for further processing or analysis.",
      "description_length": 265,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_intf",
      "library": "cfg",
      "description": "This module defines the core interfaces for representing and manipulating context-free grammars. It includes operations for adding and removing productions, querying grammar symbols, and traversing derivation rules. It works with abstract data types representing nonterminals, terminals, and production rules, enabling concrete use cases such as parsing expression grammars and generating language derivations.",
      "description_length": 410,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Bnf_lexer",
      "library": "cfg",
      "description": "This module implements a lexer for parsing BNF grammars, handling tokenization of identifiers, escaped strings, and grammar symbols. It operates on `Lexing.lexbuf` input, producing tokens consumed by the BNF parser, and includes specialized functions for managing recursive lexing states and string escaping. Concrete use cases include lexing BNF rules from text files or interactive input streams, and extracting structured tokens for parser consumption.",
      "description_length": 455,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg.Bnf_spec",
      "library": "cfg",
      "description": "This module defines core types for context-free grammars, including terminals, non-terminals, and production rules, along with comparison functions for ordered collections. It supports grammar analysis and manipulation tasks such as adding productions, removing nonterminals, and pruning unproductive or unreachable elements. Concrete use cases include parsing expression grammars, compiler front-ends, and formal language processing tasks like grammar normalization and reachability analysis.",
      "description_length": 493,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cfg.Cfg_impl",
      "library": "cfg",
      "description": "Implements control flow graph construction and manipulation with labeled nodes and edges. Provides functions to create, traverse, and modify graphs, including node insertion, edge linking, and reachability analysis. Useful for compiler intermediate representations and static analysis tools.",
      "description_length": 291,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cfg",
      "library": "cfg",
      "description": "This module provides functionality for building and manipulating context-free grammars and control flow graphs. It includes lexing and parsing components for BNF grammars, structured grammar representation, pretty-printing, and graph construction with labeled nodes and edges. Concrete use cases include parsing and analyzing formal languages, generating compiler intermediate representations, and performing static analysis on control flow structures.",
      "description_length": 452,
      "index": 18,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 22,
    "meaningful_modules": 19,
    "filtered_empty_modules": 3,
    "retention_rate": 0.8636363636363636
  },
  "statistics": {
    "max_description_length": 790,
    "min_description_length": 265,
    "avg_description_length": 492.42105263157896,
    "embedding_file_size_mb": 0.2758016586303711
  }
}