{
  "package": "mula",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 36,
  "creation_timestamp": "2025-08-15T14:16:56.600708",
  "modules": [
    {
      "module_path": "Mula.Match.Make.Dem",
      "library": "mula",
      "description": "This module implements a Demarau-Levenshtein automaton for efficiently computing edit distances between strings with a bounded error limit. It provides functions to initialize the automaton with a reference string and error threshold, feed input characters incrementally, and query the current or final edit distance. It is used to determine if two strings are within a specified edit distance, particularly useful in fuzzy matching and spell checking scenarios.",
      "description_length": 462,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula.Match.Make.Lev",
      "library": "mula",
      "description": "This module implements a Levenshtein automaton for efficiently computing approximate string matches up to a given edit distance. It provides functions to initialize the automaton with a target string and maximum error count, feed input characters incrementally, and query the current or final edit distance. It is used for tasks like fuzzy string matching where partial matches within a bounded number of insertions, deletions, or substitutions are needed.",
      "description_length": 456,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mula.Strings.Dem",
      "library": "mula",
      "description": "This module implements an NFA-based algorithm for computing approximate string edit distances with a given threshold. It operates on a custom `nfa_state` type that tracks the current state of the automaton as characters are processed incrementally. The module is useful for efficiently checking if the edit distance between two strings is within a specified bound, particularly in applications like fuzzy string matching or similarity search where early termination is beneficial.",
      "description_length": 480,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula.Strings.Lev",
      "library": "mula",
      "description": "This module implements a non-deterministic finite automaton (NFA) for computing approximate string matches up to a given edit distance *k*. It processes input character by character or as whole strings, tracking possible error counts through states, and returns whether the edit distance between the original and processed string is within the specified limit. It is suitable for fuzzy matching tasks such as spell checking, approximate substring search, or input correction where exact matches are not guaranteed.",
      "description_length": 514,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula.Match.Make",
      "library": "mula",
      "description": "This module constructs Levenshtein and Demarau-Levenshtein automata for approximate string matching. It supports incremental character input and edit distance tracking against a reference string, up to a specified error bound. Concrete use cases include spell checking, fuzzy search, and string similarity detection where exact matches are not required.",
      "description_length": 353,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula.Strings",
      "library": "mula",
      "description": "This module implements Levenshtein automata for approximate string matching and edit distance computation. It provides functions to build and run NFAs that track error counts during character-by-character comparison, supporting operations like fuzzy matching and bounded edit distance checks. Concrete use cases include spell checking, approximate substring search, and similarity filtering where early termination improves performance.",
      "description_length": 436,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula.Match",
      "library": "mula",
      "description": "Constructs Levenshtein and Damerau-Levenshtein automata for approximate string matching. It supports incremental character input and tracks edit distance against a reference string up to a specified error bound. Used for spell checking, fuzzy search, and string similarity detection where exact matches are not required.",
      "description_length": 320,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mula",
      "library": "mula",
      "description": "This module provides algorithms for approximate string matching using Levenshtein and Damerau-Levenshtein distances. It supports incremental character input, tracks edit distance bounds, and enables fuzzy search, spell checking, and similarity detection without exact matches. The implementation uses automata-based techniques to efficiently handle bounded error matching and early termination during string comparison.",
      "description_length": 419,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DFA.Make.NFAStateSetSet",
      "library": "mula.internal",
      "description": "This module provides set operations for managing collections of NFA state sets, enabling functional transformations (map, filter), structural queries (union, intersection, subset checks), and sequence-based iteration. It works with elements of type `NFA.StateSet.t` as atomic values within a larger set structure, supporting use cases like automata state exploration, conversion algorithms, and debugging through pretty-printed state set visualizations. The design emphasizes efficient set manipulation and ordered traversal for finite automaton analysis tasks.",
      "description_length": 561,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.Matcher.Make.GBV",
      "library": "mula.internal",
      "description": "Implements character and bit vector operations for string matching tasks. Works with bit vectors, strings, and integer indices to support exact and approximate pattern matching. Used to generate bit representations of substrings and sentinel values for efficient comparison.",
      "description_length": 274,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DFA.Make.NFAStateSetMap",
      "library": "mula.internal",
      "description": "This module implements a map structure with keys as sets of NFA states, supporting ordered map operations like iterative transformations, value filtering, and structural queries, alongside polymorphic value handling. It provides utilities for bulk sequence conversions, reversible iteration, and formatted output generation, enabling efficient state mapping during automaton conversion algorithms (e.g., NFA-to-DFA construction) and bulk processing of state transitions. The design emphasizes both algorithmic efficiency for automata manipulation and readability for debugging through structured data visualization.",
      "description_length": 615,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DFA.Make.DFA",
      "library": "mula.internal",
      "description": "This module implements a deterministic finite automaton (DFA) construction and manipulation system using sets of NFA states and bitvector-based transitions. It provides operations to add states and transitions, build the DFA incrementally, and print the resulting structure. Concrete use cases include converting NFAs to DFAs for pattern matching and implementing state minimization algorithms.",
      "description_length": 394,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.DFA.Make.Transitions",
      "library": "mula.internal",
      "description": "This module provides map-like operations for managing transitions in a deterministic finite automaton, supporting key-based manipulations (insertion, removal, merging) and sequence conversions. It operates on transition maps (`'a Transitions.t`) that associate bit vectors (`Internal.BitVec.t`) with arbitrary data, enabling ordered traversal and functional transformations. These utilities are particularly useful for tasks like merging transition states, batch-loading transitions from sequences, or generating human-readable representations of transition structures for debugging.",
      "description_length": 583,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.LevNFA.StateSet",
      "library": "mula.internal",
      "description": "This module provides a comprehensive set of functional and imperative operations for manipulating sets of NFA states, including transformations (union, intersection, difference), queries (membership, subset checks), and traversals (iteration, folding, filtering). It works with sets of `Internal.LevNFA.State.t` elements, supporting conversions to and from lists, sequence handling, and state property evaluations. These operations are used for tasks like tracking active states during NFA transitions, identifying error states, and computing state set reductions for automata optimization.",
      "description_length": 590,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.DemarauNFA.Transitions",
      "library": "mula.internal",
      "description": "This module computes state transitions for a Demarau NFA by processing bit vectors representing character matches. It supports deletion, substitution, and insertion operations, returning reachable states given a current state and input. Functions like `transitions` and `all_transitions` are used to advance the NFA through the input string while tracking possible states at each step.",
      "description_length": 385,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.Matcher.Make",
      "library": "mula.internal",
      "description": "Implements efficient exact and approximate string matching using bit-parallel techniques. It operates on strings, bit vectors, and NFA state sets, providing functions to process input character by character or in bulk, track matching errors, and compute edit distances. Used for tasks like substring search with mismatches, pattern matching with sentinels, and dynamic evaluation of string similarity.",
      "description_length": 401,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DemarauNFA.State",
      "library": "mula.internal",
      "description": "This module defines two state types, `Std` and `Trans`, each carrying `lane` and `error` integer fields, representing states in a Demarau NFA. It provides `compare` for ordering states and `pp_state` for pretty-printing them. These states are used to model transitions and error handling in the NFA's execution logic.",
      "description_length": 317,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DFA.Make",
      "library": "mula.internal",
      "description": "This module implements a deterministic finite automaton (DFA) construction system using sets of NFA states and bitvector-based transitions. It provides operations to add states and transitions, build the DFA incrementally, and generate structured output for debugging. The module supports concrete use cases such as converting NFAs to DFAs for efficient pattern matching and implementing state minimization algorithms.",
      "description_length": 418,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DemarauBVNFA.Transitions",
      "library": "mula.internal",
      "description": "Computes all possible state transitions for a given state set, bitvector, and parameter `k`, returning the resulting state set. Works with state sets and bitvectors to model transitions in a Demarau BVNFA automaton. Used during automaton execution to determine reachable states after processing input.",
      "description_length": 301,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.LevBVNFA.StateSet",
      "library": "mula.internal",
      "description": "This module manages sets of states for a bounded-variable NFA, providing operations to initialize a state set with a given size, find the index of an element in an array using a predicate, and compute the minimum cost of a state set if non-empty. It works directly with arrays and a custom state set type representing collections of NFA states. Concrete use cases include tracking active NFA states during execution and determining optimal transitions based on cost.",
      "description_length": 466,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.StringOps.BitVecOps",
      "library": "mula.internal",
      "description": "This module provides operations for constructing and manipulating bit vectors derived from strings, including extracting bit representations of characters at specific indices. It works with string types from the `St` module and generates bit vectors used for low-level character analysis. Concrete use cases include building compact bit representations of string segments for efficient comparison and analysis, such as checking character presence or differences at specific positions.",
      "description_length": 484,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.LevNFA.Transitions",
      "library": "mula.internal",
      "description": "This module computes state transitions for a Levenshtein NFA, handling delete, substitute, and insert operations within a bounded edit distance. It operates on states and bit vectors, producing next possible states based on the input character and distance budget. Concrete use cases include efficiently generating reachable states during approximate string matching.",
      "description_length": 367,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.LevBVNFA.Transitions",
      "library": "mula.internal",
      "description": "Computes all possible state transitions from a given set of states under a specific input symbol and transition step count. Works with state sets represented as `Internal.LevBVNFA.StateSet.t` and bitvectors (`BV.t`) for encoding transitions. Useful for simulating automaton steps in regex matching or state machine traversal where transitions depend on both current state and input.",
      "description_length": 382,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DemarauBVNFA.StateSet",
      "library": "mula.internal",
      "description": "This module manages sets of states in a Demarau-Levenshtein automaton, providing operations to initialize a state set with a given start state, find the index of a matching element in an array, compute the minimum cost of a set of states, and pretty-print state sets. It works directly with arrays and a custom state set type representing active states during automaton transitions. Concrete use cases include tracking possible states during approximate string matching and determining the lowest edit cost during fuzzy search operations.",
      "description_length": 538,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DemarauNFA.StateSet",
      "library": "mula.internal",
      "description": "This module provides set manipulation capabilities for managing collections of NFA states, including union, intersection, difference, and transformations like mapping or filtering. It operates on sets of `State.t` elements, supporting membership checks, subset comparisons, and conversions to ordered sequences or lists. These operations are used to track active states during automaton simulation, merge state transitions, evaluate subsumption relationships, and optimize path exploration in Demarau NFA implementations.",
      "description_length": 521,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.LevNFA.State",
      "library": "mula.internal",
      "description": "This module defines a state representation as a pair of a lane and error count, supporting comparison and pretty-printing operations. It works directly with tuples of type `Internal.LevNFA.lane` and `Internal.LevNFA.errors`. It is used to track and compare states in a Levenshtein NFA computation, enabling efficient state management during automaton transitions.",
      "description_length": 363,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DFA",
      "library": "mula.internal",
      "description": "This module implements a deterministic finite automaton (DFA) construction system using sets of NFA states and bitvector-based transitions. It supports adding states and transitions, incremental DFA building, and structured output generation for debugging. Concrete use cases include converting NFAs to DFAs for efficient pattern matching and implementing state minimization algorithms.",
      "description_length": 386,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.DemarauNFA",
      "library": "mula.internal",
      "description": "This module implements a Demarau NFA for approximate string matching with operations to compute state transitions under insertions, deletions, and substitutions. It defines state types to represent execution lanes and error counts, set operations to manage active states during simulation, and transition logic to process input characters using bit vectors. Concrete use cases include fuzzy search, edit distance calculation, and error-tolerant pattern matching in text processing pipelines.",
      "description_length": 491,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.NFA",
      "library": "mula.internal",
      "description": "This module defines a non-deterministic finite automaton (NFA) interface with operations to transition between states, track active states, and evaluate input sequences. It works with states represented as integers and transitions stored as a map from states and optional symbols to sets of target states. Concrete use cases include pattern matching in text processing and implementing lexical analyzers for custom parsers.",
      "description_length": 423,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.StringOps",
      "library": "mula.internal",
      "description": "This module defines a set of low-level string manipulation functions, including character indexing, substring extraction, and byte-level operations. It works directly with OCaml's native string type and is optimized for performance-critical tasks such as parsing, binary data processing, and direct memory access. Concrete use cases include implementing custom string encoders, diff algorithms, and memory-efficient string transformations.",
      "description_length": 439,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.DemarauBVNFA",
      "library": "mula.internal",
      "description": "This module implements a Demarau-Levenshtein automaton using bitvectors to efficiently compute approximate string matches with transpositions. It provides operations to track and transition between active states, calculate minimum edit costs, and locate matching elements in arrays. Concrete use cases include fuzzy search algorithms and approximate string matching where edit distance with transpositions is required.",
      "description_length": 418,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.BitVec",
      "library": "mula.internal",
      "description": "This module implements a compact bit vector representation using integers, supporting bitwise operations like OR, AND, and logical shifts. It provides functions to inspect and manipulate individual bits or ranges of bits, such as retrieving a bit at a specific position, appending ones or zeros, and folding over set bit positions. Use cases include low-level bit manipulation, bitmask management, and efficient storage of binary data.",
      "description_length": 435,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.LevNFA",
      "library": "mula.internal",
      "description": "This module implements a Levenshtein NFA for approximate string matching with bounded edit distance. It provides state representations with lane and error tracking, set operations for managing active states, and transition logic for handling insertions, deletions, and substitutions. Used to efficiently compute reachable states during automaton traversal, particularly in scenarios requiring fuzzy pattern matching with controlled error tolerance.",
      "description_length": 448,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal.Matcher",
      "library": "mula.internal",
      "description": "This module defines core operations for pattern matching and non-deterministic finite automata (NFA) manipulation. It includes functions for compiling patterns into NFAs, simulating NFA transitions, and matching input streams against compiled patterns. The module works directly with NFA structures, input buffers, and pattern definitions, enabling efficient lexical analysis and custom parser implementations.",
      "description_length": 410,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Internal.LevBVNFA",
      "library": "mula.internal",
      "description": "This module implements a bounded-variable NFA with operations to manage state sets and compute transitions. It works with arrays of bitvectors to represent states and uses a custom state set type for tracking active states during execution. Concrete use cases include simulating NFA steps in regex matching and determining minimal-cost transitions between states under specific input symbols.",
      "description_length": 392,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Internal",
      "library": "mula.internal",
      "description": "This module implements a suite of automata-based string matching algorithms and bit-level data structures. It provides precise operations for constructing and simulating NFAs and DFAs, managing bitvector-encoded state transitions, and computing approximate matches under various edit distance models. Concrete use cases include high-performance fuzzy search, regex matching, and compact state representation for lexical analyzers.",
      "description_length": 430,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 36,
    "meaningful_modules": 36,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 615,
    "min_description_length": 274,
    "avg_description_length": 435.3333333333333,
    "embedding_file_size_mb": 0.5221071243286133
  }
}