{
  "package": "mugen",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 31,
  "creation_timestamp": "2025-08-15T12:37:37.475051",
  "modules": [
    {
      "module_path": "Mugen.Semantics.Free.Make.Infix",
      "library": "mugen",
      "description": "This module defines infix operators for comparing `level` values, providing direct syntactic support for equality and ordering checks. It implements standard comparison operations such as `=`, `<`, `<=`, `>`, and `>=` as aliases for corresponding semantic functions. These operations are specifically designed for use with universe levels in the context of free syntax expressions.",
      "description_length": 381,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Semantics.Free.Make",
      "library": "mugen",
      "description": "This module implements smart constructors for universe levels represented as free syntax expressions with displacements. It provides operations to create and manipulate `level` values using variables and shifts, with functions to compare levels for equality and ordering. Use cases include constructing and evaluating universe level expressions in type theory implementations where displacements must be normalized efficiently.",
      "description_length": 427,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Semantics.Endo.Make",
      "library": "mugen",
      "description": "This module provides optimized semantic operations for working with universe levels and displacements. It includes functions to collapse multiple shifts into a single displacement and retrieve the top universe level. It is used to simplify and normalize universe-level expressions during type checking or compilation passes.",
      "description_length": 324,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.NearlyConstant",
      "library": "mugen",
      "description": "This module represents infinite sequences where only finitely many elements differ from a fixed base displacement. It supports operations like composition and join, with equality, ordering checks, and conversions to and from based lists. Use cases include modeling transformations with mostly constant behavior and sparse variations, such as in certain algebraic structures or transformation systems.",
      "description_length": 400,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Lexicographic",
      "library": "mugen",
      "description": "This module implements lexicographic ordering on binary products of two types, supporting comparison operations like `lt` and `leq` and maintaining a unit element for composition. It provides functions to construct and deconstruct pairs (`pair`, `fst`, `snd`), along with injection functions (`inl`, `inr`) and equivalence checks (`equal`, `is_id`). Use this when combining two ordered types into a composite key where the first component takes precedence in comparisons, such as sorting tuples or managing hierarchical displacements.",
      "description_length": 534,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Product",
      "library": "mugen",
      "description": "This module implements displacement algebra operations for binary products, combining values from two underlying structures while supporting comparisons, composition, and identity checks. It pairs, projects, and composes elements from two parameter modules, each representing a displacement algebra. Concrete use cases include modeling combined transformations in multi-dimensional spaces and managing structured state changes in formal verification tasks.",
      "description_length": 456,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Opposite",
      "library": "mugen",
      "description": "This module implements displacement algebra operations for opposite shifts, providing identity, composition, and ordering checks. It works with a base type `Base.t` and its own type `t` representing opposite displacements. Concrete use cases include managing hierarchical level shifts in type theory or program analysis where opposite algebra transformations are required.",
      "description_length": 372,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.Int",
      "library": "mugen",
      "description": "This module implements displacement algebra over integers with addition, supporting operations like composition (addition), join (maximum), and identity checks. It provides comparison functions, conversions to and from integers, and handles displacements as total orders with join. Concrete use cases include managing offsets in sequences or coordinates where additive displacement and maximum bounds are needed, such as in layout engines or interval arithmetic.",
      "description_length": 462,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mugen.Shift.NonPositive",
      "library": "mugen",
      "description": "This module implements non-positive integers under addition, supporting equality checks, ordering comparisons (`lt`, `leq`), identity verification (`is_id`), and composition of shifts. It works with a single abstract type `t` representing non-positive integers, and provides conversions to and from OCaml's `int` type. Concrete use cases include modeling backward displacements in sequences or managing offsets that must not exceed zero, such as in certain parsing or traversal scenarios.",
      "description_length": 488,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.FiniteSupport",
      "library": "mugen",
      "description": "This module represents infinite products of base elements with finite support, enabling operations like composition and equivalence checking. It provides structured manipulation of sequences where only finitely many elements differ from the identity. Useful for modeling transformations that have localized changes within an otherwise uniform structure.",
      "description_length": 353,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Int",
      "library": "mugen",
      "description": "This module implements displacement algebra for integers under addition, supporting operations like composition of shifts, equality checks, and ordering comparisons. It works directly with integer values, providing concrete functionality for combining displacements and comparing their magnitudes. Use cases include managing positional offsets in sequences or handling additive transformations where overflow is not a concern.",
      "description_length": 426,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Syntax.Free",
      "library": "mugen",
      "description": "This module provides constructors and a printer for building and inspecting values that represent universe levels with shifts, variables, and top-level constants. It operates on a parameterized type `('s, 'v) t`, where `'s` represents level shifts and `'v` represents variables. Concrete use cases include constructing and debugging syntax trees for universe levels in a type checker or proof assistant.",
      "description_length": 403,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Semantics.Free",
      "library": "mugen",
      "description": "This module provides smart constructors and operations to create and manipulate universe level expressions using free syntax with displacements. It supports comparing levels for equality and ordering, enabling efficient normalization of displaced variables in type theory implementations. Concrete use cases include building and evaluating universe level terms in contexts requiring precise displacement handling.",
      "description_length": 413,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Prefix",
      "library": "mugen",
      "description": "This module implements prefix-based displacement operations using a base type, supporting composition, ordering comparisons, and list conversion. It works with sequences of symbols from the `Base` module, enabling concrete manipulations of displacement structures in algebraic contexts. Use cases include symbolic rewriting systems and algebraic effect handling where prefix orderings and composition are critical.",
      "description_length": 414,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.Product",
      "library": "mugen",
      "description": "This module implements binary product structures over two displacement algebras with joins, supporting operations such as pairing, projection, composition, and join. It works with elements formed from two underlying types `X.t` and `Y.t`, combining them into a product type `t` that preserves ordering and identity. Use cases include modeling compound displacements in structured data, such as tracking simultaneous transformations in two distinct dimensions or domains.",
      "description_length": 470,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.Nat",
      "library": "mugen",
      "description": "This module implements natural numbers with addition as the primary operation, supporting comparisons like equality, less-than, and less-than-or-equal, as well as composition and join (maximum). It works with a dedicated type `t` representing natural numbers, and includes conversions to and from `int`. Concrete use cases include modeling displacements or offsets in data structures where non-negative values and their combination are required, such as in index manipulations or algebraic operations in domain-specific languages.",
      "description_length": 530,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Nat",
      "library": "mugen",
      "description": "This module implements natural numbers with addition as the primary operation, providing equality checks, ordering comparisons, identity verification, and composition following McBride's operator notation. It works with a concrete type `t` representing natural numbers, using integers for conversion to and from external representations. Use this module to model non-negative displacements or indices where additive composition and ordering are essential, such as in algebraic data manipulation or formal verification tasks.",
      "description_length": 524,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Fractal",
      "library": "mugen",
      "description": "This module implements fractal displacement algebras with operations for composing and comparing structured displacements. It works with a base displacement type `Base.t` and an extended type `t` representing hierarchical displacements. Concrete use cases include managing nested transformations in tree-like structures and handling multi-level edits in version control systems.",
      "description_length": 378,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.NearlyConstant",
      "library": "mugen",
      "description": "This module represents infinite sequences of displacements where only finitely many differ from a fixed base value. It supports equivalence checking, ordering comparisons, identity testing, and composition of such sequences. Concrete use cases include modeling sparse infinite transformations and handling finite perturbations of infinite structures.",
      "description_length": 350,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.Lexicographic",
      "library": "mugen",
      "description": "This module implements lexicographic ordering on binary products of two types, where comparisons are determined first by the left component and then by the right. It supports operations like `lt`, `leq`, `join`, and `pair`, along with identity handling via `id` and `is_id`. Use cases include structured sorting and comparison of paired values where one component takes precedence over the other.",
      "description_length": 396,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.FiniteSupport",
      "library": "mugen",
      "description": "This module represents infinite products with finite support, using a base module to define the underlying data type. It supports operations like composition, join, and equality checks, along with conversions to and from lists. It is useful for working with sequences where only a finite number of elements are non-default, enabling efficient representation and manipulation.",
      "description_length": 375,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mugen.Semantics.Endo",
      "library": "mugen",
      "description": "This module implements optimized operations for collapsing chains of universe level shifts into single displacements and extracting the top universe level from nested structures. It works directly with universe levels and displacement representations in the syntax. It simplifies normalization of universe-level expressions during type checking or compilation passes.",
      "description_length": 367,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mugen.Syntax.Endo",
      "library": "mugen",
      "description": "This module provides direct constructors and a formatting function for working with endomorphisms in a syntax tree structure. It supports creating shifted and top-level endomorphism values, parameterized over syntax and atom types, and includes a printer for debugging purposes. Concrete use cases include building and inspecting displacement-based level expressions in a typechecker or interpreter.",
      "description_length": 399,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin.NonPositive",
      "library": "mugen",
      "description": "This module implements non-positive integers under addition, supporting comparisons, identity checks, composition, and joins. It works with a single abstract type `t` representing non-positive integers, providing operations like `compose` for additive combination and `join` for maximum selection. Use cases include displacement arithmetic in algebraic structures where negative shifts accumulate, such as tracking offsets in a constrained domain.",
      "description_length": 447,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Shift.Constant",
      "library": "mugen",
      "description": "This module implements displacement algebra for constant shifts, supporting composition, ordering checks, and conversion between action and constant types. It operates on a type `t` built from `Act.t` and `Const.t`, representing immutable displacement values. Concrete use cases include symbolic manipulation of shifts in McBride-style algebra and normalization of composed displacement operations.",
      "description_length": 398,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Semantics",
      "library": "mugen",
      "description": "This module provides operations for manipulating universe levels with displacements through two submodules. `Endo` optimizes collapsing chains of shifts into single displacements and extracts top levels from nested structures, working directly with level and displacement syntax. `Free` offers smart constructors for building and comparing displaced universe level expressions, supporting precise displacement handling in type theory implementations.",
      "description_length": 450,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.StructuredType",
      "library": "mugen",
      "description": "This module defines structured types for equality, partial ordering, and partial ordering with a right action. It provides interfaces for comparing values, determining order relationships, and applying actions in a structured way. These abstractions are used to implement generic data structures and algorithms that require customizable comparison and ordering logic.",
      "description_length": 367,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.Syntax",
      "library": "mugen",
      "description": "Handles syntax for universe levels with displacements using two core submodules. `Endo` provides constructors and formatting for endomorphisms in a syntax tree, supporting shifted and top-level values parameterized over syntax and atom types, used for building and inspecting displacement-based level expressions. `Free` offers constructors and a printer for universe level values including shifts, variables, and constants, used in constructing and debugging syntax trees within a typechecker or proof assistant.",
      "description_length": 513,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen.ShiftWithJoin",
      "library": "mugen",
      "description": "This module implements displacement algebras with join operations over various numeric domains, including natural numbers, integers, and non-positive integers, as well as structures for sequences with finite support or nearly constant behavior. It provides composition, join (maximum), comparison, and conversion operations tailored for modeling offsets, indices, and bounded or sparse transformations. Concrete use cases include index manipulation, layout engine calculations, interval arithmetic, and algebraic transformations with sparse or infinite structures.",
      "description_length": 564,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mugen.Shift",
      "library": "mugen",
      "description": "This module implements displacement algebras for various numeric and symbolic structures, supporting operations such as additive composition, equality, and ordering comparisons. It works with natural numbers, integers, non-positive integers, infinite sequences with finite support, prefix-based sequences, fractal structures, and opposite shifts. Concrete use cases include modeling positional offsets in sequences, managing sparse infinite transformations, handling localized changes in uniform structures, and implementing hierarchical or nested transformations in tree-like data or version control systems.",
      "description_length": 609,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mugen",
      "library": "mugen",
      "description": "Implements algebraic structures for displacement-based computations with numeric and symbolic types. Supports operations like additive composition, join (maximum), comparison, and syntax manipulation for shifts, sequences, and universe levels. Used for modeling positional offsets, sparse transformations, version control, typechecker syntax, and interval arithmetic.",
      "description_length": 367,
      "index": 30,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 31,
    "meaningful_modules": 31,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 609,
    "min_description_length": 324,
    "avg_description_length": 430.8709677419355,
    "embedding_file_size_mb": 0.4495735168457031
  }
}