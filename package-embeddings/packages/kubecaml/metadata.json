{
  "package": "kubecaml",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 1719,
  "creation_timestamp": "2025-07-16T02:14:16.648919",
  "modules": [
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch.Namespaces.By_namespace.Cronjobs.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific CronJob resources within a Kubernetes namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor lifecycle events of named CronJobs, such as updates or deletions, in a given namespace.",
      "description_length": 327,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Deployments.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes Deployments within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a Deployment using HTTP GET, PUT, and PATCH requests. The module works directly with Deployment resources and Patch objects, targeting use cases such as monitoring Deployment health, updating status conditions, or rolling back to a previous state.",
      "description_length": 427,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Time.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each key is a string and each value is a timestamp, typically used to track time-related metadata in Kubernetes resources. It provides functions to serialize and deserialize this list to and from JSON format. This structure is useful for handling time-stamped annotations or tracking events in Kubernetes objects.",
      "description_length": 368,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicasets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes ReplicaSets within a specific namespace and name. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the status of a ReplicaSet using HTTP requests. The module works directly with ReplicaSet definitions and patch objects, targeting use cases such as monitoring or modifying the observed state of ReplicaSets in a cluster.",
      "description_length": 421,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an `Api_service_condition.t`, used to track conditions associated with API services in Kubernetes. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is specifically used to manage and serialize the state of API registration conditions in Kubernetes' API registration process.",
      "description_length": 399,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Deployments.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations to retrieve, replace, or partially update the scale subresource of a Deployment in a specific namespace. It works with Kubernetes Deployment scale definitions and patch operations, using Cohttp for HTTP communication. Concrete use cases include adjusting replica counts and querying current scaling settings for Deployments in Kubernetes clusters.",
      "description_length": 391,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Label_selector.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of label selectors paired with string keys, used to filter Kubernetes resources based on label queries. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, working with the `Label_selector.t` type nested within a list structure. It is used when defining or interpreting Kubernetes API objects that require label-based selection logic, such as pod selectors in deployments or services.",
      "description_length": 466,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Custom_resource_definition_condition.t`. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to track multiple conditions associated with a Kubernetes custom resource definition, such as its current status and related metadata.",
      "description_length": 372,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Namespaces.By_namespace.Poddisruptionbudgets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for PodDisruptionBudget resources within a Kubernetes namespace. It provides functions to retrieve, replace, or partially update the status of a specific PodDisruptionBudget by name. The module works directly with PodDisruptionBudget definitions and Patch objects, making it suitable for managing disruption policies during cluster maintenance or deployment updates.",
      "description_length": 412,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Statefulsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes StatefulSets within a specific namespace. It operates on StatefulSet resources using standard HTTP verbs, returning result-wrapped StatefulSet objects or error strings. Concrete use cases include checking the current status of a StatefulSet, updating its status field, or applying selective status changes via patch operations.",
      "description_length": 418,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_condition.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of API service condition objects into JSON format. It works with a list of key-value pairs where each value is an API service condition. It is used to convert between in-memory representations and JSON data when interacting with Kubernetes API registration endpoints.",
      "description_length": 325,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Ingresses.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to Ingress objects in a specific namespace by name. It supports filtering with label and field selectors, limiting results, and configuring timeouts or resource versions. A concrete use case is monitoring an Ingress for updates in real-time to trigger configuration reloads in a service mesh.",
      "description_length": 320,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Deployments.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Deployments within a Kubernetes namespace, providing functions to retrieve, replace, or partially update a Deployment's status. It works with Kubernetes Deployment definitions and Patch objects, interacting directly with the API via HTTP requests. Concrete use cases include checking the current status of a Deployment, updating its status to reflect new conditions, or applying selective status changes without modifying the entire resource.",
      "description_length": 492,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Role resource within a namespace. It provides a `get` function to establish a watch stream with options like timeout, resource version, and selectors, returning a result with a watch event or error. Use this to monitor real-time updates to a Role in a given namespace.",
      "description_length": 321,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of API service objects used in Kubernetes aggregation, specifically working with lists of tuples containing strings and `Api_service.t` records. It provides `to_yojson` and `of_yojson` functions for converting these structures to and from JSON format. This is useful when interacting with Kubernetes API registration endpoints that require structured API service definitions.",
      "description_length": 429,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Replicasets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes ReplicaSets within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a ReplicaSet by name using HTTP requests. The module works directly with ReplicaSet objects and Patch structures, targeting use cases such as monitoring or modifying the operational state of workloads in a Kubernetes cluster.",
      "description_length": 405,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Proxy.By_path",
      "library": "kubecaml",
      "description": "This module routes HTTP requests to a specific path within a Kubernetes Pod's proxy. It supports standard HTTP methods like GET, PUT, POST, DELETE, and others, allowing direct interaction with services exposed through the Pod. The module works with Kubernetes Pod identifiers (namespace, name) and forwards requests to a specified path on the Pod's proxy endpoint.",
      "description_length": 364,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Deployments.By_name.Rollback",
      "library": "kubecaml",
      "description": "This module handles the rollback of a Deployment resource within a specific namespace by providing a `post` function that sends a rollback request to the Kubernetes API. It operates on Deployment rollback data structures defined in the `Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1` module and constructs requests using a predefined path template. A concrete use case is triggering a rollback to a previous revision of a Deployment when an update introduces issues.",
      "description_length": 469,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_spec.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of API service specification objects to and from JSON format. It works with a list of tuples, where each tuple consists of a string and an `Api_service_spec.t` record containing server location and communication details. It is used to persist or transmit API service configurations in JSON, such as when storing or retrieving Kubernetes API registration data.",
      "description_length": 413,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch.Namespaces.By_namespace.Podpresets.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific PodPreset object within a namespace by establishing a long-running HTTP connection. It supports filtering with label and field selectors, limiting results, and handling pagination with the `continue` parameter. Use this to monitor configuration updates for PodPresets in real-time, such as tracking changes to environment variables or volume mounts applied to pods.",
      "description_length": 407,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json.Object",
      "library": "kubecaml",
      "description": "This module represents JSON objects as lists of key-value pairs, where each value is a JSON type. It provides functions to convert these objects to and from `Yojson.Safe.t` representations. Use this module when constructing or parsing Kubernetes API extension JSON objects, such as validating arbitrary structured data in custom resource definitions.",
      "description_length": 350,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_validation.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a validation rule for custom resources. It provides functions to convert these validation objects to and from JSON format using `to_yojson` and `of_yojson`. It is used to define and manipulate validation schemas for Kubernetes custom resources in the v1beta1 API version.",
      "description_length": 340,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of labeled Kubernetes API service objects to and from JSON format. It works directly with associative lists where each entry pairs a string label with an `Api_service_list.t` value. This module is used when managing multiple versions or groupings of API services, such as during dynamic API registration or discovery in a Kubernetes cluster.",
      "description_length": 409,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to RoleBinding objects within a specific namespace in Kubernetes. It provides a `get` function to stream events for a named RoleBinding, supporting parameters like resource version, label selectors, and timeouts. Use it to monitor real-time updates or deletions of RoleBindings in a targeted namespace.",
      "description_length": 330,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status_cause.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Status_cause.t`, used to convey detailed error information in Kubernetes API responses. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is particularly useful for handling and inspecting multiple error causes returned by the Kubernetes API during failed operations.",
      "description_length": 394,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes Deployment resources within a given namespace. It provides a `get` function to establish a watch stream, accepting parameters like `namespace`, `name`, `watch`, and `timeout_seconds` to target the resource and control stream behavior. Use this module to monitor real-time updates to a Deployment, such as during rolling updates or health checks.",
      "description_length": 400,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_versions.Object",
      "library": "kubecaml",
      "description": "This module represents a list of API version entries, where each entry pairs a version string with its corresponding API versions data structure. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This module is used when interacting with the Kubernetes API discovery endpoints to process and serialize API version information returned by the server.",
      "description_length": 401,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_group_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API groups, where each group is a key-value pair consisting of a string and an `Api_group_list` structure. It provides functions to serialize and deserialize this list to and from JSON format using `Yojson`. This structure is used to process and expose the available API groups at the `/apis` endpoint in a Kubernetes cluster.",
      "description_length": 370,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Deployments.By_name.Rollback",
      "library": "kubecaml",
      "description": "This module handles the creation of rollbacks for Kubernetes Deployments within a specified namespace. It provides a `post` function to submit a rollback request to the Kubernetes API, using a deployment name and namespace, and returns the resulting Deployment rollback object or an error. The `request_path_template` function generates the API path for rollback operations.",
      "description_length": 374,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresources.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of custom resource subresource definitions to and from JSON. It works with a list of tuples pairing strings with custom resource subresource configurations. Concrete use cases include converting Kubernetes custom resource status and scale subresource settings to JSON for API communication or storage.",
      "description_length": 355,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific RoleBinding objects within a namespace in a Kubernetes cluster. It supports operations like `get` to retrieve and monitor RoleBinding resources with parameters for filtering, resource versioning, and request configuration. Use this module to observe real-time updates to RoleBinding objects, such as tracking role assignments for access control in multi-tenant environments.",
      "description_length": 418,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Networkpolicies.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific NetworkPolicy resources within a namespace in a Kubernetes cluster. It provides a `get` function to establish a watch stream, accepting parameters like namespace, name, and optional filters such as label or field selectors. Use this module to monitor real-time updates to network policies, enabling dynamic configuration adjustments in response to policy changes.",
      "description_length": 407,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Services.By_name.Proxy.By_path",
      "library": "kubecaml",
      "description": "This module handles proxying HTTP requests to specific Kubernetes services through a defined path. It supports standard HTTP methods like GET, PUT, POST, DELETE, OPTIONS, HEAD, and PATCH, directing them to a service endpoint identified by namespace and name. Concrete use cases include interacting with Kubernetes services via a proxy for operations like retrieving service data, sending updates, or triggering actions.",
      "description_length": 419,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Statefulsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes StatefulSets in a specific namespace. It provides functions to retrieve, replace, or partially update the status of a StatefulSet by name using HTTP requests. These operations work with StatefulSet and Patch data types, enabling direct interaction with Kubernetes API endpoints for state management.",
      "description_length": 360,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.External_documentation.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of external documentation objects used in Kubernetes API extensions. It works with associative lists mapping strings to external documentation definitions, converting them to and from JSON format. It is used when processing custom resource definitions that include links to external documentation resources.",
      "description_length": 361,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicationcontrollers.By_name.Scale",
      "library": "kubecaml",
      "description": "This module handles scaling operations for replication controllers in a Kubernetes cluster. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the scale of a specific replication controller within a given namespace. The module works directly with Kubernetes scale definitions and patch objects, targeting use cases such as programmatically adjusting workload replicas or integrating autoscaling logic.",
      "description_length": 440,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Replicasets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes ReplicaSets within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a ReplicaSet using HTTP GET, PUT, and PATCH requests. The module works directly with ReplicaSet definitions and patch objects, targeting use cases such as monitoring or modifying the operational state of ReplicaSets in a cluster.",
      "description_length": 409,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Watch_event.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes watch events into JSON format. It works with a list of key-value pairs where each value is a watch event, using `Yojson.Safe.t` for JSON representation. It is used to convert between structured watch event data and JSON for transmission or storage.",
      "description_length": 320,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Role resources within a specific namespace in the Kubernetes RBAC API. It provides a `get` function to establish a watch stream with customizable parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to a Role object, such as tracking role modifications for audit or synchronization purposes.",
      "description_length": 367,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicasets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, or partially update the scale subresource of a specific ReplicaSet within a namespace in the Kubernetes API. It operates on the `Scale` type from the Extensions V1beta1 API and uses standard HTTP verbs (GET, PUT, PATCH) against a predefined request path. Concrete use cases include programmatically adjusting the number of replicas in a ReplicaSet or querying the current scale status for monitoring purposes.",
      "description_length": 462,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific ReplicaSet in a given namespace by providing a `get` function that initiates a watch request with customizable parameters such as timeout, resource version, and selectors. It works with Kubernetes ReplicaSet objects and returns events as they occur, enabling real-time tracking of ReplicaSet updates. A concrete use case is monitoring a ReplicaSet's scaling events or status changes in a production environment to trigger automated responses or alerts.",
      "description_length": 494,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Kubernetes status object, primarily used to encode or decode status information in API responses. It provides functions to convert this list structure to and from JSON using the Yojson library. This is useful when handling Kubernetes API endpoints that return status details as part of error responses or operation outcomes.",
      "description_length": 395,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Initializer.Object",
      "library": "kubecaml",
      "description": "This module represents a list of initializers associated with Kubernetes objects, where each initializer is a tuple of a string and an `Initializer.t` type. It provides functions to convert this list structure to and from JSON format using `to_yojson` and `of_yojson`. This is used to serialize and deserialize initializer data when interacting with Kubernetes API resources that require tracking pending initialization steps.",
      "description_length": 426,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Deployments.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes Deployments within a specific namespace. It operates on Deployment resources using HTTP GET, PUT, and PATCH methods against a Kubernetes API server. Use this module to inspect or modify the observed state of a Deployment, such as checking rollout progress or updating its status subresource directly.",
      "description_length": 391,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Label_selector_requirement.Object",
      "library": "kubecaml",
      "description": "This module represents a list of label selector requirements, where each requirement consists of a key and a condition that relates the key to a set of values. It provides functions to convert this structure to and from JSON format using `to_yojson` and `of_yojson`. It is used to define filtering rules for Kubernetes resources based on labels, such as selecting pods or services that match specific label criteria.",
      "description_length": 416,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific ReplicaSet in a given namespace. It supports operations like `get` to retrieve the ReplicaSet and stream subsequent updates, with parameters for filtering and controlling the watch behavior. It works directly with Kubernetes ReplicaSet resources and WatchEvent data structures.",
      "description_length": 323,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes ControllerRevision objects within a namespace. It provides a `get` function to stream events for a named ControllerRevision, supporting parameters like resource version, label selectors, and timeouts. Use this to monitor updates or deletions of ControllerRevision resources in real time.",
      "description_length": 342,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes Deployment resources within a named namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to a Deployment object, such as during rolling updates or status changes.",
      "description_length": 340,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific StatefulSet resources within a Kubernetes cluster by namespace and name. It provides a `get` function to stream events matching the target resource, using parameters like resource version, label selector, and timeout. Use this to monitor real-time updates to a named StatefulSet, such as tracking pod creation or configuration changes.",
      "description_length": 379,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_bool.Object",
      "library": "kubecaml",
      "description": "This module handles JSON schema definitions for Kubernetes API extensions, specifically managing key-value pairs where values are either schema properties or boolean flags. It provides serialization and deserialization functions to and from JSON using `Yojson.Safe.t`, ensuring proper encoding of schema objects. Concrete use cases include validating and generating Kubernetes custom resource definitions (CRDs) with embedded JSON schemas.",
      "description_length": 439,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Namespaces.By_namespace.Cronjobs.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes CronJob resources within a specific namespace. It operates on `Cron_job.t` and `Patch.t` data types, interacting directly with the Kubernetes API via HTTP requests. Concrete use cases include checking the current status of a CronJob, updating its status in full, or applying a strategic merge or JSON patch to its status.",
      "description_length": 412,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_resource_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of API resource lists into JSON format. It works with a list of tuples, where each tuple contains a string and an `Api_resource_list` value. It is used to convert between in-memory representations of Kubernetes API resources and their JSON-encoded forms for storage or transmission.",
      "description_length": 340,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific Kubernetes RoleBinding within a namespace. It provides a `get` function to establish a watch stream with customizable parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to RoleBinding objects in a given namespace.",
      "description_length": 302,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Initializers.Object",
      "library": "kubecaml",
      "description": "This module represents a list of initializer entries, where each entry is a tuple of a string and an initializer object. It provides functions to convert this structure to and from JSON format using Yojson. It is used to serialize and deserialize initializer data for Kubernetes API objects during resource initialization tracking.",
      "description_length": 331,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Deployment resources within a namespace in a Kubernetes cluster. It supports operations to get and monitor Deployment objects by name, returning events that indicate changes to those deployments. The module works directly with Kubernetes Deployment definitions and watch event streams, targeting use cases like real-time monitoring of deployment status or rollout progress.",
      "description_length": 417,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of API service status objects into JSON format. It works with a list of tuples, where each tuple pairs a string key with an `Api_service_status.t` value. Concrete use cases include converting API service status data to JSON for storage or transmission, and parsing JSON input into structured status objects for inspection or further processing.",
      "description_length": 402,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Server_address_by_client_cidr.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of client CIDR-server address mappings. It works with associative lists pairing strings and server address records. It is used to interpret and generate JSON representations of routing configurations for Kubernetes API clients.",
      "description_length": 295,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status_details.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Status_details object, used to capture extended metadata from Kubernetes API responses. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. This structure is typically used to interpret detailed error information or supplementary data returned by the Kubernetes server in response to API requests.",
      "description_length": 414,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Namespaces.By_namespace.Horizontalpodautoscalers.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for HorizontalPodAutoscalers in a specific Kubernetes namespace. It provides functions to retrieve, replace, or partially update the status of a HorizontalPodAutoscaler using HTTP GET, PUT, and PATCH requests. The module works directly with HorizontalPodAutoscaler objects and Patch payloads, targeting use cases such as monitoring or modifying autoscaling behavior in real-time.",
      "description_length": 425,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific StatefulSet resources within a given namespace in a Kubernetes cluster. It supports operations like `get` to retrieve and monitor StatefulSet events, providing structured access to watch events as they occur. Use this module to track real-time updates or deletions of StatefulSets by name, namespace, and resource version.",
      "description_length": 366,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes custom resource definitions into JSON format. It works with a list-based structure pairing string keys with custom resource definition values. Use this module when converting custom resource definitions to and from JSON for API interactions or configuration management.",
      "description_length": 341,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Ingresses.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, and partially update the status of a Kubernetes Ingress resource within a specific namespace. It operates on Ingress objects defined in the `Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1` namespace and uses Cohttp for HTTP communication. Use this module to directly manipulate the status subresource of an Ingress, such as updating load balancer details or ingress rule statuses.",
      "description_length": 441,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific DaemonSet resources within a namespace in a Kubernetes cluster. It supports operations like `get` to retrieve and monitor DaemonSet events, with parameters for filtering and controlling the watch behavior. The module works directly with Kubernetes API objects such as Watch_event and interacts with the DaemonSet resource via HTTP requests.",
      "description_length": 384,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props.Object",
      "library": "kubecaml",
      "description": "This module represents a JSON schema object as defined in the Kubernetes API extensions v1beta1 specification, following JSON Schema Draft 4. It provides functions to convert between a list of key-schema pairs and Yojson representation, enabling validation and serialization of custom resource definitions. It is used specifically for defining and working with structured schema constraints in Kubernetes CRDs.",
      "description_length": 410,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Deployments.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Deployments in a specific Kubernetes namespace. It provides functions to retrieve, replace, or partially update the status of a Deployment using HTTP GET, PUT, and PATCH requests. The module works directly with Deployment resources and Patch objects, targeting use cases such as monitoring Deployment health, rolling back updates, or applying status changes without modifying the full resource.",
      "description_length": 444,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of custom resource definition status objects to and from JSON format. It works with a list of key-value pairs where each value is a custom resource definition status. It is used to persist or transmit Kubernetes CRD status information in a structured format.",
      "description_length": 316,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Group_version_for_discovery.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API group versions, where each entry pairs a string identifier with a structured group/version definition. It provides JSON serialization and deserialization functions (`to_yojson`, `of_yojson`) for working with this list structure. This module is used to process and represent API version discovery data returned by Kubernetes endpoints.",
      "description_length": 382,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes ControllerRevision objects within a namespace. It provides a `get` function to stream events based on name, namespace, and optional filtering parameters like label or field selectors. Use this to monitor updates or deletions of ControllerRevision resources in real time.",
      "description_length": 325,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Deployment resources within a namespace in a Kubernetes cluster. It supports operations to get and monitor events related to a Deployment identified by namespace and name, using parameters like resource version, timeout, and selectors. Concrete use cases include tracking Deployment status updates or rollouts in real-time for a specific application.",
      "description_length": 394,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Micro_time.Object",
      "library": "kubecaml",
      "description": "This module represents Kubernetes object metadata with a list of key-value pairs, where each value is a `Micro_time.t` instance, and provides functions to convert this structure to and from JSON. It works directly with associative lists mapping strings to `Micro_time.t` values, and uses `Yojson.Safe.t` for JSON serialization. Concrete use cases include parsing and emitting Kubernetes API objects that require precise time values, such as timestamps in resource definitions or status fields.",
      "description_length": 493,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific DaemonSet resources within a namespace in a Kubernetes cluster. It supports operations to get and monitor DaemonSet objects by name, returning events that indicate changes to those resources. The module works directly with Kubernetes API objects like Watch_event and DaemonSet definitions, using HTTP requests to stream updates from the cluster.",
      "description_length": 389,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresource_status.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of custom resource status subresource configurations to and from JSON. It works with associative lists mapping strings to `Custom_resource_subresource_status.t` values. Use this module when manipulating Kubernetes custom resource definitions that include status subresource settings, particularly for reading or writing JSON representations of those settings.",
      "description_length": 413,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_resource.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API resources, where each resource is a tuple of a string and an `Api_resource` type. It provides functions to convert this list to and from JSON format using `Yojson`. This structure is used to handle collections of Kubernetes resource definitions, such as those returned by API discovery endpoints.",
      "description_length": 344,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of API service objects into JSON format. It works with a list of tuples, where each tuple contains a string and an API service definition. Concrete use cases include converting API service configurations to JSON for storage or transmission, and parsing JSON input into structured API service data for processing.",
      "description_length": 366,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Service_reference.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Service_reference.t` values, representing service references in Kubernetes API registration. It provides JSON serialization and deserialization functions using `Yojson.Safe`. This structure is used to specify services that expose API endpoints in Kubernetes aggregator configurations.",
      "description_length": 351,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch.Namespaces.By_namespace.Horizontalpodautoscalers.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to specific Horizontal Pod Autoscaler resources within a namespace. It provides a `get` function to stream updates as events, using parameters like namespace, name, and optional filters. Use it to monitor scaling events for a named autoscaler in a given namespace.",
      "description_length": 292,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Patch.Object",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes Patch request body as a list of key-value pairs, where each value is a Patch type. It provides functions to convert this structure to and from Yojson for serialization and deserialization. It is used when constructing or interpreting patch operations sent to the Kubernetes API, such as applying strategic merge or JSON patches to resources.",
      "description_length": 377,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of API service status objects into JSON format. It works with a list of tuples, where each tuple pairs a string key with an API service status value. Concrete use cases include converting API service status data to JSON for storage or transmission, and parsing JSON input into structured API service status records for processing.",
      "description_length": 388,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Delete_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Delete_options instance, used to specify deletion parameters for Kubernetes API objects. It provides functions to convert this list to and from JSON format using Yojson. This structure is typically used when sending delete requests to the Kubernetes API, allowing granular control over deletion behavior for multiple resources.",
      "description_length": 398,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Statefulsets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations to retrieve, replace, or partially update the scale subresource of a specific StatefulSet within a Kubernetes namespace. It works with Kubernetes StatefulSet scale definitions using the Autoscaling/v1 API and supports standard HTTP methods with optional context and headers. Concrete use cases include programmatically adjusting the number of replicas in a StatefulSet or retrieving its current scaling configuration.",
      "description_length": 461,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Daemonsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes DaemonSets within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a DaemonSet by name using HTTP GET, PUT, and PATCH requests. The module works directly with DaemonSet objects and patch data structures defined in the Kubernetes API specifications.",
      "description_length": 360,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Daemonsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for DaemonSets in a Kubernetes cluster. It provides functions to retrieve, replace, or partially update the status of a specific DaemonSet within a given namespace. The module works directly with DaemonSet objects and Patch payloads, returning updated DaemonSet states from the API server.",
      "description_length": 335,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Namespaces.By_namespace.Cronjobs.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, or partially update the status of a specific Kubernetes CronJob within a namespace. It operates on CronJob resources using HTTP methods, returning result values wrapped in Lwt promises. Use this module to directly interact with the status subresource of a CronJob, such as inspecting or modifying its current state in a cluster.",
      "description_length": 381,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch.Namespaces.By_namespace.Jobs.By_name",
      "library": "kubecaml",
      "description": "Implements functions to watch for changes to specific Kubernetes Job resources within a namespace. It provides a `get` function that initiates a watch request, supporting parameters like `namespace`, `name`, `timeout_seconds`, and `resource_version`, returning a streamed result of watch events. Designed for real-time monitoring of Job status updates in a specified namespace.",
      "description_length": 377,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch.Namespaces.By_namespace.Cronjobs.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific CronJob resources within a Kubernetes namespace. It supports operations to get and monitor events related to a named CronJob, returning structured watch events or error information. Concrete use cases include tracking job status updates or observing job creation/deletion in real-time.",
      "description_length": 329,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Daemonsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for DaemonSets in a Kubernetes cluster. It provides functions to retrieve, replace, or partially update the status of a specific DaemonSet within a namespace using HTTP methods. The module works directly with DaemonSet objects and Patch payloads, returning result types that indicate success or failure of the operations.",
      "description_length": 367,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Statefulsets.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes StatefulSets within a specific namespace. It operates on StatefulSet resources using HTTP GET, PUT, and PATCH requests against a Kubernetes API server. Use cases include monitoring the current status of a StatefulSet, updating its status in bulk, or applying selective status changes without modifying the full resource.",
      "description_length": 411,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific ReplicaSet in a given namespace by providing a `get` function that establishes a watch connection with the Kubernetes API. It accepts parameters such as `namespace`, `name`, `watch`, and `timeout_seconds` to target the resource and control the watch behavior. Use this module to monitor real-time updates to a ReplicaSet, such as scaling events or status changes, within a specific namespace.",
      "description_length": 434,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes ControllerRevision objects within a namespace. It provides a `get` function to stream events for a named ControllerRevision, supporting parameters like resource version, label selectors, and timeouts. Use it to monitor updates or deletions of ControllerRevision resources in real time.",
      "description_length": 340,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific StatefulSet resources within a given namespace in a Kubernetes cluster. It provides a `get` function to establish a watch stream, accepting parameters like namespace, name, and optional query filters such as label or field selectors. Use this module to monitor real-time updates to a StatefulSet, such as during deployment rollouts or pod scaling events.",
      "description_length": 398,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Statefulsets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations to retrieve, replace, or partially update the scale subresource of a StatefulSet in a specific namespace. It works with Kubernetes API objects such as `Scale.t` and `Patch.t`, interacting directly with the Kubernetes API via URIs. Concrete use cases include adjusting the number of replicas in a StatefulSet and retrieving current scaling information for monitoring or autoscaling decisions.",
      "description_length": 435,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Service_reference.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Service_reference.t` values, representing service references in Kubernetes's API registration. It provides JSON serialization and deserialization functions for this structure using `Yojson`. This module is used to handle API registration service references in configuration or discovery workflows.",
      "description_length": 364,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of custom resource definition specifications to and from JSON format. It operates on a list-based structure pairing strings with custom resource definition spec values. Concrete use cases include converting Kubernetes CRD specs for storage or transmission, and parsing them from JSON input.",
      "description_length": 348,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresource_scale.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of custom resource scale subresource data to and from JSON format. It works with a list of tuples, where each tuple pairs a string with a custom resource scale definition. It is used to encode or decode scale subresource configurations for Kubernetes custom resources into JSON representations.",
      "description_length": 348,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_array.Object",
      "library": "kubecaml",
      "description": "This module handles JSON schema definitions by providing direct conversions to and from Yojson representations. It works specifically with lists of key-value pairs where values are either JSON schema properties or arrays of such properties. Use this module when serializing or deserializing Kubernetes API extension schema definitions, particularly for custom resource validation.",
      "description_length": 380,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_group.Object",
      "library": "kubecaml",
      "description": "This module represents a list of API groups, where each group is a tuple of a string and an `Api_group.t` type. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used when handling responses from Kubernetes API endpoints that list available API groups and their versions.",
      "description_length": 341,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Namespaces.By_namespace.Horizontalpodautoscalers.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for HorizontalPodAutoscalers within a specific Kubernetes namespace. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the status of a HorizontalPodAutoscaler resource using HTTP requests. These functions work with the HorizontalPodAutoscaler and Patch data types, targeting direct interaction with the Kubernetes API.",
      "description_length": 404,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Role resource within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. The function returns a result indicating success or failure of the watch request.",
      "description_length": 297,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_list.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of Api_service_list objects to and from JSON format using Yojson. It operates on a list of key-value pairs where each value is an Api_service_list. It is used to serialize and deserialize Kubernetes API service lists for storage or transmission.",
      "description_length": 280,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Namespaces.By_namespace.Poddisruptionbudgets.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to PodDisruptionBudget objects in a specific namespace by name. It provides a `get` function to stream events for a named PodDisruptionBudget, supporting parameters like `watch`, `timeout_seconds`, and `resource_version`. Use this module to monitor real-time updates or deletions of PodDisruptionBudget resources within a given namespace.",
      "description_length": 366,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Deployments.By_name.Scale",
      "library": "kubecaml",
      "description": "This module handles scaling operations for Kubernetes Deployments within a specific namespace. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the scale subresource of a Deployment, using the Kubernetes API. These operations work with the `Scale` type from the autoscaling/v1 API group, targeting Deployment resources identified by namespace and name.",
      "description_length": 393,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Statefulsets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module handles scaling operations for StatefulSets in a Kubernetes cluster. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the scale subresource of a StatefulSet identified by namespace and name. The functions work with `Scale.t` and `Patch.t` data types, interacting with the Kubernetes API via HTTP requests.",
      "description_length": 358,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_string_array.Object",
      "library": "kubecaml",
      "description": "This module handles JSON serialization and deserialization for a list-based structure where each element is a tuple of a string and a `Json_schema_props_or_string_array.t`. It works directly with `Yojson.Safe.t` for converting data to and from JSON representations. Concrete use cases include processing Kubernetes API extension schemas that involve either nested JSON schema properties or string arrays, such as validating and structuring custom resource definitions.",
      "description_length": 468,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Owner_reference.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value conforms to the `Owner_reference` type, used to track objects that own or control resources in Kubernetes. It provides JSON serialization and deserialization functions (`to_yojson`, `of_yojson`) for working with these references in API interactions. It is commonly used when managing resource ownership in custom controllers or operators that need to establish parent-child relationships between Kubernetes objects.",
      "description_length": 481,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.List_meta.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `List_meta` object, used to encode metadata for synthetic Kubernetes resources like lists and status objects. It provides `to_yojson` and `of_yojson` functions for serializing and deserializing these metadata structures to and from JSON. This is useful when working with Kubernetes API responses that include list metadata, such as when retrieving collections of resources.",
      "description_length": 444,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch.Namespaces.By_namespace.Events.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Event objects within a specified namespace and name. It supports filtering by label and field selectors, limiting results, and configuring timeouts and resource versions. Use it to monitor specific events in real-time, such as tracking event updates or deletions for a particular resource.",
      "description_length": 335,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_names.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of custom resource definition names into JSON format. It works with a list of tuples, where each tuple contains a string and a `Custom_resource_definition_names.t` value. This is used to convert between JSON representations and internal data structures when interacting with Kubernetes API extensions.",
      "description_length": 359,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Namespaces.By_namespace.Jobs.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes Jobs within a specific namespace. It operates on job status data using standard Kubernetes API request patterns. Concrete use cases include checking the execution state of batch jobs, updating job completion status, and applying selective status modifications without full replacement.",
      "description_length": 376,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Object_meta.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes object metadata into JSON format. It works with a list of tuples containing strings and metadata objects, using Yojson for safe JSON conversion. Concrete use cases include converting metadata for Kubernetes resources to and from JSON during API interactions or configuration file parsing.",
      "description_length": 356,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_spec.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of API service specification objects to and from JSON format. It works with a list of tuples containing strings and `Api_service_spec.t` records, representing configuration data for Kubernetes API services. It is used when reading or writing API service definitions to JSON, such as during configuration file parsing or API communication.",
      "description_length": 392,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch.Namespaces.By_namespace.Horizontalpodautoscalers.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific HorizontalPodAutoscaler object within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to a named autoscaler in a given namespace.",
      "description_length": 301,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving DaemonSet resources in a specific namespace by name, supporting operations like `get` to stream changes or fetch current state. Works with Kubernetes API parameters such as `watch`, `resource_version`, and `label_selector` to filter and track DaemonSet events. Useful for monitoring lifecycle events of node-level DaemonSets, such as tracking pod deployment status across cluster nodes.",
      "description_length": 421,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch.Namespaces.By_namespace.Networkpolicies.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving NetworkPolicy resources within a specific namespace in Kubernetes's Networking API. It supports operations like `get` to fetch events related to a named NetworkPolicy, including filtering by label and field selectors. This module is used to monitor changes to NetworkPolicy objects in real-time or retrieve their current state.",
      "description_length": 362,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of custom resource definitions in Kubernetes API extensions. It works with associative lists mapping strings to `Custom_resource_definition_list.t` values and supports conversion to and from JSON using `Yojson.Safe.t`. It is used to manage collections of custom resource definitions in API interactions, such as when retrieving or persisting cluster-level CRD configurations.",
      "description_length": 443,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Replicasets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, or partially update the scale subresource of a ReplicaSet in a specific namespace. It operates on Kubernetes ReplicaSet objects using standard HTTP methods, returning result values that indicate success or failure. Concrete use cases include programmatically adjusting the number of replicas in a ReplicaSet, checking the current scale, or applying partial updates to the scale configuration.",
      "description_length": 445,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Deployments.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations to retrieve, replace, or partially update the scale subresource of a Deployment in a specific namespace. It works with Kubernetes API objects such as `Scale` and `Patch`, interacting with the server via Cohttp requests. Concrete use cases include adjusting the number of replicas for a Deployment and fetching current scaling information for monitoring or autoscaling logic.",
      "description_length": 418,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Replicasets.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, or partially update the scale of a Kubernetes ReplicaSet within a specific namespace. It operates on the `Scale` type from the autoscaling/v1 API group and uses standard Kubernetes API request patterns. Concrete use cases include adjusting the number of replicas in a ReplicaSet and retrieving current scaling configuration for monitoring or debugging.",
      "description_length": 405,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Deployments.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations to retrieve, replace, or partially update the scale subresource of a Deployment in a specific namespace. It works with Kubernetes API types such as `Scale.t` for responses and `Patch.t` for partial updates, interacting directly with the Kubernetes REST API via Cohttp. Concrete use cases include programmatically adjusting the number of replicas in a Deployment or querying the current scaling state for monitoring purposes.",
      "description_length": 468,
      "index": 117,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Preconditions.Object",
      "library": "kubecaml",
      "description": "This module represents a list of preconditions for Kubernetes API operations, where each precondition is a tuple of a string key and a `Preconditions.t` value. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This is used to enforce conditions like resource version or UID matching before applying updates or deletions in the Kubernetes API.",
      "description_length": 394,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Serviceaccounts.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific ServiceAccount within a namespace by providing a `get` function that establishes a watch stream. It works with Kubernetes ServiceAccount resources, returning events that describe modifications to the account. Use this to monitor real-time updates to a ServiceAccount's state, such as when tokens or secrets are rotated.",
      "description_length": 365,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Util.Intstr.Int_or_string.Object",
      "library": "kubecaml",
      "description": "This module handles a list of key-value pairs where keys are strings and values are either integers or strings, specifically for encoding and decoding Kubernetes API objects. It provides direct conversions to and from JSON using `to_yojson` and `of_yojson`, ensuring compatibility with Kubernetes' `IntOrString` type. Use this module when interacting with Kubernetes resources that require flexible numeric or string-based field values, such as resource limits or selector match rules.",
      "description_length": 485,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_condition",
      "library": "kubecaml",
      "description": "This module manages API service condition records with fields like type, status, reason, and transition time, offering constructors, accessors, and Yojson serialization. It handles the representation and state transitions of conditions in Kubernetes API services, such as tracking when a service becomes available or encounters an error. The child module organizes these conditions into a list of key-value pairs, enabling structured serialization and deserialization for use in API registration workflows. Together, they support inspecting and persisting the dynamic state of API services in a Kubernetes cluster.",
      "description_length": 614,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of RoleBinding resources within a Kubernetes namespace, allowing changes to be observed as they occur. It supports filtering by labels and fields, limiting result sets, and configuring timeouts or resource versions for consistent watches. The child module extends this functionality by enabling direct retrieval and observation of specific RoleBinding objects, allowing operations like `get` to inspect current role assignments. Together, they enable dynamic access control and auditing by tracking role binding updates in real time, such as monitoring RBAC changes in multi-tenant clusters.",
      "description_length": 633,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Label_selector",
      "library": "kubecaml",
      "description": "This module represents a label selector for filtering Kubernetes resources based on labels, supporting both exact matches and complex selector expressions. It provides core operations to construct and evaluate label-based criteria, working directly with label selector types and expression lists. The nested module extends this functionality by handling collections of label selectors paired with string keys, including JSON serialization via `to_yojson` and `of_yojson`. Together, they enable precise resource selection and integration with Kubernetes API objects like pod selectors in deployments or services.",
      "description_length": 611,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_string_array",
      "library": "kubecaml",
      "description": "This module represents values that can be either a JSON schema object or a list of strings, enabling flexible modeling of validation rules that may specify either structured properties or simple name lists. It provides constructors, accessors, and conversion functions to work with both forms directly, along with Yojson integration for serialization and deserialization. The child module extends this capability to handle lists of key-value pairs where each value follows the same schema-or-string-array pattern, facilitating the processing of complex nested structures like Kubernetes CRD validation rules. Example uses include parsing and validating custom resource definitions that mix schema-referenced and string-based property declarations.",
      "description_length": 747,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module tracks changes to Kubernetes Role resources within a namespace, offering a `get` function to stream events with filtering and pagination. It enables real-time monitoring of role updates or deletions for either all roles in a namespace or a specific named role. The API returns watch events or errors, supporting use cases like security auditing or role synchronization. Key parameters include timeout, resource version, and label selectors for precise control over watched resources.",
      "description_length": 495,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes RoleBindings within a specific namespace using HTTP requests. It works with RoleBinding objects and related types like DeleteOptions and Patch. Use this module to manage role bindings in a namespace, such as retrieving, updating, or deleting a specific RoleBinding resource.",
      "description_length": 328,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresource_scale",
      "library": "kubecaml",
      "description": "This module configures the scale subresource for custom resources in Kubernetes, specifying JSON paths to replicas and label selectors. It supports creating and serializing scale definitions with required fields like `spec_replicas_path` and `status_replicas_path`, enabling horizontal pod autoscaling for custom resources. The child module handles JSON serialization and deserialization of these scale configurations, working with tuples of strings and scale definitions. For example, it can encode a custom resource's scale settings into JSON for Kubernetes API consumption or decode incoming configurations for processing.",
      "description_length": 625,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ReplicaSets within a namespace, offering direct operations to retrieve, replace, delete, and patch ReplicaSet configurations. It supports precise control over ReplicaSet resources, such as updating replicas or applying configuration changes, and includes submodules for handling ReplicaSet status and scale subresources. The status submodule allows retrieval and modification of operational state via GET, PUT, and PATCH requests, while the scale submodule enables programmatic adjustment and inspection of replica counts. Example uses include updating a ReplicaSet's desired state, monitoring its current status, or dynamically scaling its replica count.",
      "description_length": 686,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Ingresses",
      "library": "kubecaml",
      "description": "This module watches for changes to Ingress resources in a specific namespace, supporting label and field selectors, result limits, pagination with continuation, and configurable timeouts and resource versions. It provides direct access to filtered, paginated event streams and allows watching specific Ingress objects by name through its child module. Main data types include Ingress resources, selectors, and continuation tokens, with operations for initiating and managing watches. For example, it can monitor a specific Ingress for real-time updates or stream events across multiple Ingresses with custom filtering to trigger service mesh configuration reloads.",
      "description_length": 664,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Endpoints.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to specific Kubernetes Endpoints objects within a namespace. It provides a `get` function to establish a watch stream with options like timeout, resource version, and label selectors, returning a result with a Watch_event. Use it to monitor real-time updates to named Endpoints resources, such as tracking service endpoint changes in a cluster.",
      "description_length": 372,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Server_address_by_client_cidr",
      "library": "kubecaml",
      "description": "This module organizes client CIDR ranges and their associated server addresses into structured mappings, enabling dynamic selection of endpoints based on network configuration. It supports operations to create, access, and serialize mappings, with the child module handling JSON conversion of these associations as associative lists. Users can define routing rules that direct Kubernetes API clients to the correct cluster based on CIDR match. Example usage includes generating configuration files or interpreting routing policies from JSON input.",
      "description_length": 547,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module monitors Deployment resources in a Kubernetes namespace, enabling real-time observation of changes such as rollouts and scaling events. It supports filtering by label and field selectors, resource version constraints, and provides pagination and initialization status tracking. The `get` function from its child module establishes a watch stream with options like timeout and selectors, allowing precise control over the observed events. Together, these capabilities enable targeted, efficient monitoring of Deployment updates at both the namespace and individual resource levels.",
      "description_length": 592,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status",
      "library": "kubecaml",
      "description": "This module represents Kubernetes API status responses with structured data, including fields like `status`, `reason`, `message`, and `code`. It provides constructors, accessors, and JSON (de)serialization via Yojson to handle success or error outcomes from API operations, such as resource creation or deletion. The child module extends this by encoding and decoding lists of keyed status objects, enabling structured handling of complex API error responses. Together, they support precise status parsing, construction, and interchange with Kubernetes endpoints.",
      "description_length": 563,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes RoleBindings within a specific namespace, providing functions to get, put, delete, and patch RoleBinding resources using the Kubernetes API. It works with fully defined RoleBinding and DeleteOptions data types, handling serialization and HTTP communication. Concrete use cases include managing role bindings for service accounts in a namespace, updating access policies, and cleaning up role bindings during resource teardown.",
      "description_length": 480,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Initializers",
      "library": "kubecaml",
      "description": "This module manages initializer state for Kubernetes objects, tracking progress through a list of pending initializers and an optional failure result. It provides operations to construct initializer states, inspect pending initializers, and check initialization outcomes, ensuring resources are exposed only after successful completion. The child module handles structured initializer data by offering JSON (de)serialization via Yojson, enabling seamless integration with Kubernetes API object workflows. Together, they support creation-time initialization tracking with precise control over initializer execution and status reporting.",
      "description_length": 635,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch.Namespaces.By_namespace.Cronjobs",
      "library": "kubecaml",
      "description": "This module monitors CronJob resources in a Kubernetes namespace, enabling real-time reactions to changes with support for label and field selectors, resource version control, and pagination. It provides structured watch events for overall CronJob activity, while its child module focuses on named CronJobs, allowing detailed observation of specific job events like status updates, creations, and deletions. Operations include filtering by labels, tracking job lifecycle events, and handling errors during monitoring. Use it to build responsive systems that react to scheduled workload changes or maintain an up-to-date view of CronJob states.",
      "description_length": 643,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module monitors StatefulSet resources in a Kubernetes namespace, enabling real-time tracking of updates, deletions, and additions. It supports filtering by label and field selectors, custom resource versions, and configurable timeouts, allowing precise control over event streams. The child module extends this functionality by enabling per-resource observation through name-based targeting, using `get` to stream events for a specific StatefulSet. Together, they enable use cases like triggering autoscaling logic or health checks in response to observed StatefulSet changes.",
      "description_length": 581,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module monitors Deployment resources in a Kubernetes namespace, offering filters, pagination, and real-time updates through a `get` function that streams `Watch_event` values. It supports targeting specific deployments by name, watching for changes over time with configurable timeouts and selectors. Key operations include filtering by labels or fields, limiting results with `resource_version`, and handling large result sets via the `continue` parameter. Use it to track deployment status changes, manage rolling updates, or respond to health events in real time.",
      "description_length": 571,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ControllerRevision resources within a specific namespace. It provides functions to get, put, delete, and patch ControllerRevision objects using a specified URI, with support for common request parameters like namespace, name, and optional headers. The module works directly with Kubernetes API v1beta1 ControllerRevision and related types, enabling management of stateful application revisions in a cluster.",
      "description_length": 461,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module monitors DaemonSet resources in a namespace, streaming events based on criteria like resource version and label selectors. It offers a `get` function to observe real-time lifecycle changes, such as DaemonSet rollouts or node-level pod status updates. The child module enhances this by enabling per-DaemonSet tracking using Kubernetes API parameters like `watch` and `field_selector`. Together, they support precise, dynamic monitoring of DaemonSet behavior across cluster nodes.",
      "description_length": 490,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API service objects, each containing version, kind, metadata, and a list of items. It provides functions to construct, serialize, and access the list, enabling operations like retrieving or configuring groups of API services via cluster APIs. The accompanying JSON conversion module supports serializing and deserializing these lists using Yojson, facilitating storage or transmission. Specific uses include managing API service collections in Kubernetes, such as listing all services or extracting metadata from individual entries.",
      "description_length": 576,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Replicationcontrollers.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific ReplicationController within a given namespace. It supports filtering by label and field selectors, limiting results, and configuring timeouts or resource versions. Use this to monitor real-time updates for a ReplicationController in a Kubernetes cluster.",
      "description_length": 301,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch.Namespaces.By_namespace.Networkpolicies",
      "library": "kubecaml",
      "description": "This module watches for changes to NetworkPolicy resources in a Kubernetes namespace, streaming events with optional filters like label selectors, resource versions, and timeouts. It provides a `get` function to monitor dynamic updates or retrieve the current state of a specific NetworkPolicy. Use it to track when policies are created, updated, or deleted, enabling real-time adjustments to network configurations. The child module extends this functionality by implementing the core watching and retrieval logic, supporting field selectors and fine-grained event filtering.",
      "description_length": 576,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Object_meta",
      "library": "kubecaml",
      "description": "This module provides structured handling of Kubernetes object metadata, centered on the `Object_meta` record type with fields like name, namespace, labels, annotations, and ownership references. It supports creating, modifying, and serializing metadata, enabling tasks such as grouping resources by labels, attaching custom annotations, and managing parent-child relationships in cluster configurations. The child module handles JSON conversion using Yojson, transforming metadata to and from JSON during API calls or config file processing. Example uses include building metadata for new resources, extracting labels for filtering, and serializing metadata for storage or transmission.",
      "description_length": 686,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Namespaces.By_namespace.Poddisruptionbudgets",
      "library": "kubecaml",
      "description": "This module tracks changes to PodDisruptionBudget resources across a namespace, supporting filters via label and field selectors, and fine-grained control over resource version, timeout, and pagination. It enables real-time monitoring of disruption budgets during rolling updates or cluster maintenance, with the ability to stream events for specific budgets by name using the child module. The `get` function in the child module allows watching named PodDisruptionBudgets, making it possible to react to updates or deletions as they occur. Together, these capabilities facilitate dynamic management of disruption policies in evolving cluster environments.",
      "description_length": 656,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Resourcequotas.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes ResourceQuotas within a specific namespace. It provides `get`, `put`, and `patch` functions to retrieve, replace, or partially update the status of a ResourceQuota by name. These functions work with ResourceQuota and Patch data types, interacting directly with the Kubernetes API over HTTP using Cohttp.",
      "description_length": 364,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ReplicaSets within a namespace, offering direct access to core operations like retrieval, replacement, deletion, and partial updates using ReplicaSet definitions and structures like DeleteOptions and Patch. Its status submodule enables inspection and modification of ReplicaSet operational states, allowing adjustments to conditions or observed generations, while the scale submodule targets the `Scale` resource to dynamically change replica counts or retrieve scaling configuration. Use the main module to deploy or remove ReplicaSets, the status submodule to monitor health or update state metadata, and the scale submodule to control workload size programmatically. Together, they provide a complete interface for managing ReplicaSet resources, status, and scaling behavior through HTTP interactions with a Kubernetes cluster.",
      "description_length": 861,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Namespaces.By_namespace.Podpresets.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing PodPresets in a specific namespace, supporting get, put, delete, and patch methods to interact with Kubernetes API server. It works with PodPreset resources and related types like DeleteOptions and Patch. Concrete use cases include retrieving, creating, updating, or removing PodPresets to enforce pod configuration defaults in a namespace.",
      "description_length": 392,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Micro_time",
      "library": "kubecaml",
      "description": "This module represents timestamps with microsecond precision, primarily for Kubernetes API operations, and includes functions to convert values to and from JSON. It defines the core type `t` and supports direct manipulation of time values used in resource metadata, such as creation or update timestamps. The child module extends this functionality by handling collections of string-keyed timestamps, enabling structured metadata to be parsed and emitted in JSON format. Together, they allow precise time handling in Kubernetes object definitions, status fields, and API exchanges.",
      "description_length": 581,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_list",
      "library": "kubecaml",
      "description": "This module manages lists of Kubernetes Custom Resource Definitions (CRDs), providing structured access to their API version, kind, metadata, and item collections. It supports constructing, serializing, and parsing CRD lists, with direct operations for adding or retrieving items and converting to and from JSON using `Yojson.Safe.t`. The module includes submodules for handling nested structures and associative lists mapping strings to CRD lists, enabling efficient storage and retrieval of cluster-level CRD configurations. Example uses include persisting CRD collections to disk or transmitting them over an API.",
      "description_length": 616,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployment resources within a namespace, offering direct HTTP-based operations to retrieve, replace, delete, and patch deployments. It centers around deployment objects and associated metadata like delete options and patch data, enabling precise control over Deployment configurations. The status submodule targets health monitoring and condition updates through dedicated status manipulation functions, while the scale submodule allows programmatic adjustment and querying of replica counts using the Kubernetes scale subresource. Together, these components support comprehensive Deployment management, from configuration to scaling and status tracking.",
      "description_length": 685,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Deployment resources in a namespace, supporting filters by label and field selectors, and control over resource version, timeout, and pagination. It allows tracking of deployment updates such as rollouts and scaling events, with direct access to Kubernetes Deployment definitions and watch event streams. Specific operations include watching for changes by name, retrieving Deployment states, and observing status transitions as they occur. Together with its submodules, it enables detailed, targeted observation of deployment behavior within a cluster.",
      "description_length": 598,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props",
      "library": "kubecaml",
      "description": "This module provides tools to construct, serialize, and validate JSON Schema objects following Draft 4, with a focus on enforcing constraints like `required`, `enum`, and `minimum` for Kubernetes API resources. It centers around core types such as `t` for schemas and `Object.t` for object-specific properties, supporting logical combinators and nested validation rules. Functions allow conversion between key-schema pairs and Yojson, enabling precise schema definition and validation of Kubernetes Custom Resource Definitions (CRDs). Submodules enhance this functionality by mapping schema constructs to Kubernetes API structures, facilitating integration with CRD validation workflows.",
      "description_length": 687,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_spec",
      "library": "kubecaml",
      "description": "This module provides the core structure and operations for defining and managing API service endpoints in a Kubernetes aggregator, including server location, TLS settings, and priority configuration. It supports creating and modifying `Api_service_spec` values to register external API servers, define routing references, and control API discovery order. The child module handles JSON serialization and deserialization of these specifications, working with lists of string-`Api_service_spec.t` tuples for configuration parsing and API interactions. Together, they enable concrete tasks like loading API service configs from files, adjusting TLS verification, and exporting specs for cluster updates.",
      "description_length": 699,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes StatefulSets in a specific namespace, offering operations to retrieve, replace, delete, and partially update StatefulSets using HTTP requests. It works primarily with the StatefulSet and DeleteOptions data types, supporting tasks like rolling back configurations, updating replicas, and cleaning up resources. The status submodule handles StatefulSet status management through retrieval, replacement, and patching, using Patch data types to interact with Kubernetes API endpoints. The scale submodule provides HTTP operations to adjust or retrieve the scale of a StatefulSet, working with Scale.t and Patch.t to support autoscaling and replica adjustments.",
      "description_length": 687,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Namespaces.By_namespace.Horizontalpodautoscalers.By_name",
      "library": "kubecaml",
      "description": "This module manages Horizontal Pod Autoscalers in a Kubernetes cluster through REST operations, supporting get, put, delete, and patch actions within namespaces using fully-typed data structures. It integrates status-specific functionality through its child module, enabling retrieval, replacement, or partial updates of autoscaler statuses for real-time monitoring and adjustment. The API works directly with Kubernetes v2beta1 definitions and standard HTTP patterns, allowing precise control over autoscaling behavior. Example uses include fetching an autoscaler's current state, updating its configuration, or modifying its status in response to system load changes.",
      "description_length": 669,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch.Namespaces.By_namespace.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module watches for changes to Horizontal Pod Autoscaler resources within a Kubernetes namespace, streaming events that reflect updates to autoscaler configurations or scaling activities. It supports filtering by namespace, label selector, and resource version, enabling targeted monitoring of autoscaler behavior across a cluster. A `get` function streams these events in real time, allowing applications to react to scaling decisions or track autoscaler adjustments. For example, it can monitor a specific autoscaler by name to detect when it scales a deployment based on observed metrics.",
      "description_length": 595,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes StatefulSets within a specific namespace and cluster, supporting full CRUD operations\u2014retrieving, replacing, deleting, and partially updating StatefulSet resources. It works directly with StatefulSet definitions and metadata, enabling precise control over stateful application deployments. The status submodule handles monitoring and bulk or selective status updates via GET, PUT, and PATCH requests, while the scale submodule allows scaling operations using the `Scale.t` type to adjust replica counts dynamically. Examples include updating a StatefulSet's desired state, patching its status after a failure, or scaling the number of replicas in response to load changes.",
      "description_length": 703,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_status",
      "library": "kubecaml",
      "description": "This module represents and manipulates the status of an API service in Kubernetes, centered around the `t` type and a list of `Api_service_condition` entries that capture the service's health and availability. It supports constructing, inspecting, and transforming status data, with operations for adding or checking conditions and setting overall status fields. The child module handles JSON serialization and deserialization, converting between structured status objects and JSON representations using key-value tuples. Example uses include parsing API service status from JSON input, building status updates with specific conditions, and serializing current state for transmission or storage.",
      "description_length": 695,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Statefulsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes StatefulSets within a namespace and cluster context, supporting full CRUD operations\u2014read, replace, delete, and partial updates\u2014using HTTP methods over a Cohttp client. It works directly with Kubernetes API types like `Stateful_set.t` and `Delete_options.t`, enabling control over stateful workloads such as database clusters. The status submodule handles retrieval and modification of StatefulSet status fields, allowing for operations like checking rollout status or applying status patches. The scale submodule interacts with the Autoscaling/v1 API to adjust or inspect the number of replicas in a StatefulSet, supporting dynamic scaling of stateful applications.",
      "description_length": 697,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Owner_reference",
      "library": "kubecaml",
      "description": "This module represents owner references in Kubernetes, capturing fields like `api_version`, `kind`, `name`, and `uid` to uniquely identify owning objects within the same namespace. It supports constructing, accessing, and serializing these references using functions like `make`, `to_yojson`, and `of_yojson`, enabling integration with Kubernetes APIs. The child module extends this functionality to handle lists of owner references, facilitating the management of multiple ownership relationships in custom controllers or operators. Together, they enable precise control over resource ownership and garbage collection behavior in Kubernetes workloads.",
      "description_length": 652,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_spec",
      "library": "kubecaml",
      "description": "This module provides the core structure and utilities for defining and managing API service configurations, particularly for Kubernetes API aggregation. It includes data types like `t` for representing server connection details, TLS settings, and priority rules, along with operations to construct, extract, and serialize these configurations. The child module handles JSON conversion of these records, enabling storage or transmission of API service lists. You can use this module to set up secure or insecure API endpoints, manage version routing, and persist configurations in JSON format.",
      "description_length": 592,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Service_reference",
      "library": "kubecaml",
      "description": "This module represents a reference to a Kubernetes Service object, capturing its name and namespace, with functions to construct, access, and serialize service references using JSON. It directly supports configuring API registration endpoints that point to backing services in a Kubernetes cluster. The child module extends this by providing a list-based mapping from string keys to service references, enabling structured handling of multiple references. Together, they facilitate configuration and discovery workflows through JSON serialization and deserialization using `Yojson`.",
      "description_length": 582,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Label_selector_requirement",
      "library": "kubecaml",
      "description": "This module represents a label selector requirement, consisting of a key, an operator, and a list of values, with support for common operators like `In`, `Not_in`, `Exists`, and `Does_not_exist`. It provides functions to construct, access, and manipulate these components directly, enabling precise filtering of Kubernetes resources such as pods and services based on label criteria. The child module extends this by handling lists of such requirements, offering JSON serialization and deserialization via `to_yojson` and `of_yojson`. Together, they allow building complex label-based selectors and converting them to standard formats for integration with Kubernetes APIs.",
      "description_length": 672,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ControllerRevision resources within a specific namespace. It provides functions to get, put, delete, and patch ControllerRevision objects using a base URI, with support for common request parameters like `pretty`, `ctx`, and `headers`. The module works directly with Kubernetes API v1beta2 ControllerRevision definitions and related meta types, enabling management of stateful application revisions in a cluster.",
      "description_length": 466,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of ReplicaSet resources within a namespace, supporting label and field-based filtering, custom timeouts, and pagination. It enables tracking of all ReplicaSet changes or focusing on a specific ReplicaSet using submodules that expose operations like `get` and event streaming. Developers can implement deployment tracking or auto-scaling systems by reacting to ReplicaSet updates as they occur. The combined interface works directly with Kubernetes ReplicaSet and WatchEvent types to ensure integration with cluster state changes.",
      "description_length": 571,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of StatefulSet resources within a Kubernetes namespace, supporting filters by label and field selectors, and control over resource version, timeout, and pagination. It includes a `get` function to establish a watch stream on specific StatefulSets, enabling use cases like tracking deployment rollouts or reacting to scaling events. The main data types include watch streams and filter parameters, with operations to initiate and manage watches. Example usage includes triggering alerts or automation when a StatefulSet's desired or current state changes.",
      "description_length": 596,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch.Namespaces.By_namespace.Jobs",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Job resources within a namespace, supporting filters by label and field selectors, and configurable timeouts, resource versions, and pagination. It enables real-time monitoring of job status updates, creation, and deletion events, with the `get` function initiating a watch request on a specific job by name. The module handles streamed watch events, allowing precise tracking of job lifecycle changes in a namespace. Examples include tracking job completions or detecting failed jobs in real time.",
      "description_length": 544,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides functions to retrieve, replace, or partially update the status of a specific Pod within a given namespace. It operates on Pod and Patch data types, interacting directly with Kubernetes API endpoints. Use cases include monitoring Pod health, updating Pod state, or applying selective status modifications in cluster management workflows.",
      "description_length": 357,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Namespaces.By_namespace.Horizontalpodautoscalers.By_name",
      "library": "kubecaml",
      "description": "This module manages horizontal pod autoscalers in Kubernetes namespaces through REST operations, supporting full lifecycle actions like retrieval, replacement, deletion, and partial updates via GET, PUT, DELETE, and PATCH requests. It operates directly on Kubernetes API objects such as `Horizontal_pod_autoscaler` and `Delete_options`, enabling precise control over autoscaling configurations and cluster resource adjustments. The status submodule extends this functionality by allowing direct manipulation of autoscaler status fields, using dedicated `get`, `put`, and `patch` operations on the status resource. Together, they provide a complete interface for both configuration and status management of autoscaling resources within Kubernetes.",
      "description_length": 746,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicasets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ReplicaSets within a namespace, supporting direct manipulation via GET, PUT, DELETE, and PATCH operations to inspect or modify configurations. It works with core Kubernetes types such as ReplicaSet, DeleteOptions, and Patch, enabling tasks like updating deployment specs or removing outdated configurations. The status submodule offers targeted access to ReplicaSet status updates, allowing retrieval or modification of observed states, while the scale submodule handles scaling operations using the Extensions V1beta1 Scale type to adjust or monitor replica counts programmatically.",
      "description_length": 614,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployment resources in a specific namespace through direct HTTP-based CRUD operations, enabling tasks like deploying updated configurations or modifying existing resources. It includes submodules for scaling Deployments by adjusting replica counts, rolling back to previous revisions, and inspecting or updating Deployment status to monitor health. Main data types include Deployment definitions, scale subresources, and patch objects, with operations like `post`, `get`, `put`, and `patch` driving interactions. Specific examples include triggering a rollback on failure, scaling a Deployment in response to load, and checking Deployment status for readiness.",
      "description_length": 692,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch.Namespaces.By_namespace.Cronjobs",
      "library": "kubecaml",
      "description": "This module monitors CronJob resources in a Kubernetes namespace by establishing event streams that capture real-time changes such as creation, updates, or deletions. It supports filtering through label and field selectors, limiting results, and specifying resource versions for consistency. The child module enhances this functionality by allowing targeted watches on specific CronJob instances, enabling precise tracking of lifecycle events for individual scheduled jobs. For example, you can watch for status updates on a particular CronJob or receive notifications when new CronJobs matching certain criteria are created.",
      "description_length": 625,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Configmaps.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to specific Kubernetes ConfigMap resources within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to a named ConfigMap, such as tracking configuration changes in a running cluster.",
      "description_length": 342,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Namespaces.By_namespace.Cronjobs.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CronJob resources within a specific namespace, offering HTTP-based operations to retrieve, replace, delete, and partially update CronJobs by name. It works with data types like `Cron_job.t` and `Patch.t`, enabling direct manipulation of job configurations and metadata. The status submodule extends this functionality to handle CronJob status updates, allowing full replacements or strategic patches to reflect execution state changes. Together, they support precise control over CronJob lifecycle and status reporting through targeted API interactions.",
      "description_length": 584,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_versions",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes API version discovery by combining version metadata, routing rules, and client CIDR-based server selection into a structured format. It supports parsing and serializing version data from the `/api` endpoint, and includes types like version strings, server addresses, and CIDR mappings with operations to build, query, and transform these structures. The child module handles version lists, enabling JSON conversion for communication with Kubernetes discovery endpoints. Example usage includes selecting the appropriate API server based on client network or generating version discovery responses for legacy clients.",
      "description_length": 648,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition",
      "library": "kubecaml",
      "description": "This module defines and manipulates Kubernetes custom resource definitions, enabling the creation, serialization, and inspection of CRDs for custom API resources. It provides data types for metadata, spec, and status components, along with operations to construct and serialize these structures into JSON for API requests or configuration. The child module handles JSON conversion, mapping string keys to CRD values, allowing seamless integration with Kubernetes API interactions. Example uses include defining a CRD's group and name format, serializing it for cluster registration, and extracting status fields for resource monitoring.",
      "description_length": 636,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicationcontrollers.By_name",
      "library": "kubecaml",
      "description": "This module manages scaling operations for Kubernetes replication controllers using direct interactions with scale definitions and patch objects. It exposes `get`, `put`, and `patch` functions to retrieve, replace, or partially update replica counts for specific controllers within a namespace. These operations support dynamic workload adjustments and integration with autoscaling systems. For example, it can be used to programmatically increase replicas during traffic spikes or apply partial updates to scale settings without full replacement.",
      "description_length": 547,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Log",
      "library": "kubecaml",
      "description": "This module retrieves logs from a specific Pod in a given Namespace by making a GET request to the Kubernetes API. It supports parameters like `tail_lines`, `since_seconds`, `container`, and `follow` to customize log output. The module works directly with Pod names and namespace identifiers, returning log data as a string result in an Lwt async context.",
      "description_length": 355,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Pods.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Pod within a Namespace by name. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors, returning a result with a Watch_event. Use this to monitor real-time updates for a Pod, such as status or configuration changes.",
      "description_length": 331,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Services.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Service resources within a specified namespace. It provides a `get` function to establish a watch stream with optional parameters like resource version, label selectors, and timeouts, returning a result with a watch event or error. Use it to monitor real-time updates to a specific Service in a namespace, such as tracking pod status changes or configuration updates.",
      "description_length": 413,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_validation",
      "library": "kubecaml",
      "description": "This module defines validation rules for custom resources using an OpenAPI v3 schema, allowing creation, conversion, and enforcement of type-safe validation logic for Kubernetes CRDs. It directly supports operations like schema construction, JSON serialization, and validation rule application. The child module manages key-value pairs representing individual validation rules, providing JSON conversion via `to_yojson` and `of_yojson` for v1beta1 API schemas. Together, they enable precise definition and validation of custom resource structures in Kubernetes.",
      "description_length": 561,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of ReplicaSet resources within a specified namespace, supporting filters via label and field selectors, and configurable watch behavior such as timeout and resource version. It includes a submodule that focuses on tracking changes to a specific ReplicaSet by name, offering a `get` function to establish a watch connection with the Kubernetes API using parameters like `namespace`, `name`, and `timeout_seconds`. The main data types include ReplicaSet objects and watch events, with operations to initiate and manage watch connections. Example use cases include triggering autoscaling decisions based on observed ReplicaSet changes or validating deployment status in real-time.",
      "description_length": 719,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.External_documentation",
      "library": "kubecaml",
      "description": "This module manages external documentation references through a structured data type containing URLs and descriptions, with functions to construct, access, and serialize instances using `Yojson`. It supports handling mappings of string keys to documentation references, enabling conversion to and from JSON for use in Kubernetes API extensions. You can create documentation links, embed them in custom resource definitions, or process external guide references during API schema validation. The module integrates direct data manipulation with structured JSON conversion for seamless use in configuration and extension workflows.",
      "description_length": 628,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Service_reference",
      "library": "kubecaml",
      "description": "This module provides a structure to reference Kubernetes services, particularly for API registration and aggregation. It supports creating, accessing, and serializing service references with optional namespace and name fields. A list-based submodule maps string keys to service references, enabling structured configuration of API endpoints in aggregators. These tools are used to define backend services for Kubernetes API aggregation, with JSON support for persistence and interchange.",
      "description_length": 487,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_group_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API groups, primarily used to handle discovery responses from the `/apis` endpoint. It provides functions to construct, serialize, and access API group list data, including fields like `api_version`, `kind`, and the list of groups. Each group is a key-value pair consisting of a string and an `Api_group_list` structure, enabling hierarchical organization of API versions and resources. Use this module to query or build the aggregated API discovery document returned by Kubernetes API servers, and to serialize or deserialize group data using JSON with `Yojson`.",
      "description_length": 607,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Controllerrevisions.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ControllerRevision resources within a specific namespace, providing `get`, `put`, `delete`, and `patch` functions to interact with individual ControllerRevision objects by name. It works directly with Kubernetes API types such as `Controller_revision.t` for stateful set revisions and `Delete_options.t` for controlled deletion. Concrete use cases include retrieving, updating, or removing specific controller revisions to manage stateful application rollouts or rollbacks.",
      "description_length": 527,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Delete_options",
      "library": "kubecaml",
      "description": "This module defines delete options for Kubernetes API objects, allowing users to specify parameters like grace period, propagation policy, and preconditions during deletion. It includes operations to construct and manipulate these options directly, as well as a child module for handling lists of delete options in JSON format. Users can set a grace period for controlled termination, choose a propagation policy to manage dependent resources, and encode these settings for API requests using the child module\u2019s JSON conversion functions.",
      "description_length": 538,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Networkpolicies",
      "library": "kubecaml",
      "description": "This module monitors NetworkPolicy resources in a Kubernetes namespace, offering real-time updates through configurable watch streams. It supports filtering by label and field selectors, and allows setting timeouts, resource versions, and continuation tokens for precise control over watched resources. The child module extends this functionality by allowing observation of specific NetworkPolicy instances by name, using the `get` function to initiate watches with custom parameters. Together, they enable dynamic synchronization and reactive adjustments to network policies as they change in the cluster.",
      "description_length": 606,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for Kubernetes Role resources within a specific namespace. It supports CRUD actions including retrieving, replacing, deleting, and partially updating Roles using HTTP methods. The module works directly with Role definitions and Kubernetes API response types.",
      "description_length": 297,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates custom resource definitions for Kubernetes APIs, handling fields such as group, version, scope, and validation rules. It supports creating, accessing, and serializing these specifications to JSON, enabling storage or transmission of CRD configurations. Key data types include strings, validation schemas, and subresource settings, with operations to pair specs in lists for structured processing. Example uses include defining a CRD's API exposure and converting it to JSON for persistence or communication.",
      "description_length": 546,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module tracks changes to RoleBinding resources in a Kubernetes namespace, offering a `get` function to stream events filtered by label or field selectors, resource version, and namespace. It enables real-time monitoring of role binding updates for access control or auditing purposes. The child module extends this capability by focusing on a specific RoleBinding, allowing detailed observation of individual object changes with customizable watch parameters. Together, they support precise, dynamic tracking of RBAC policies within a cluster.",
      "description_length": 548,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module tracks changes to RoleBinding resources in a Kubernetes namespace, offering real-time event streaming with support for label and field selectors, pagination, and resource versioning. It provides a `get` function to monitor specific RoleBindings, allowing precise control over event streams using parameters like timeout and selector filters. You can use it to react dynamically to role binding updates or deletions as they occur. The combined functionality enables both broad and targeted observation of authorization policy changes in cluster namespaces.",
      "description_length": 567,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Time",
      "library": "kubecaml",
      "description": "This module represents time values, typically used for timestamps in Kubernetes API objects, with a `t` type and functions like `make`, `to_yojson`, and `of_yojson` for construction and JSON conversion. It supports handling timestamps in resource metadata such as creation or update times. A child module manages lists of string-keyed timestamps, providing JSON serialization and deserialization for tracking time-stamped annotations or events. Together, they enable precise time handling and metadata management in Kubernetes resources.",
      "description_length": 537,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module monitors DaemonSet resources in a Kubernetes namespace, streaming events based on selectors, resource versions, or timeouts. It supports direct queries for real-time updates and integrates submodules for named DaemonSet tracking using Kubernetes API objects like Watch_event and DaemonSet. You can use it to observe configuration changes, track rollout statuses, or trigger actions when DaemonSets update in a namespace. Submodules enhance this functionality by enabling per-DaemonSet monitoring and detailed inspection of changes via HTTP streams.",
      "description_length": 560,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Replicationcontrollers.By_name.Scale",
      "library": "kubecaml",
      "description": "This module provides direct access to scale operations for replication controllers within a Kubernetes cluster. It supports retrieving, replacing, and partially updating the scale resource using HTTP GET, PUT, and PATCH requests. The module works specifically with namespace and name identifiers, along with the scale and patch data types, to manage replication controller scaling.",
      "description_length": 381,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_resource_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes API resources for a specific group and version, capturing details such as resource names and whether they are namespaced. It supports constructing, accessing, and transforming these lists, with direct operations for adding or retrieving resources and checking their properties. The child module handles JSON serialization and deserialization, converting between in-memory lists of resources and their JSON representations, typically used when interacting with Kubernetes discovery endpoints. For example, you can create a resource list for the \"apps\" group version, mark deployments as namespaced, and serialize the list to JSON for API responses.",
      "description_length": 691,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Ingresses.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Ingress resources within a specific namespace, offering CRUD operations such as `get`, `put`, `delete`, and `patch` to manipulate routing rules, TLS settings, and resource configurations. It works directly with Ingress definitions and related types like Delete_options and Patch, enabling programmatic updates and deletions. The status submodule extends this functionality by allowing retrieval and modification of the Ingress status subresource, such as updating load balancer details or rule statuses. Together, these capabilities support full lifecycle management of Ingress objects using Cohttp for API server communication.",
      "description_length": 659,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch.Namespaces.By_namespace.Events",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes Event resources in a specific namespace, streaming updates through a `get` function that supports filtering by label or field selector, resource version constraints, and timeout settings. It enables real-time observation of cluster events, such as tracking event creation or deletion for debugging or automated responses. The child module extends this functionality by allowing fine-grained monitoring of events associated with a specific name, further supporting targeted inspection and reaction to event changes. Together, they provide tools to observe and respond to event streams at both namespace and resource-specific levels.",
      "description_length": 663,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Portforward",
      "library": "kubecaml",
      "description": "This module handles port-forwarding connections to Kubernetes Pods by namespace and name, providing `get` and `post` functions to establish connections using specified ports. It works with URIs and Cohttp client contexts, targeting specific Pod resources in a given namespace. Concrete use cases include connecting to a Pod's endpoints for debugging, monitoring, or interacting with services running inside the Pod.",
      "description_length": 415,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status_cause",
      "library": "kubecaml",
      "description": "This module represents detailed error information in Kubernetes API status responses, including machine-readable reasons, human-readable messages, and specific resource fields involved in the error. It supports serialization to and from JSON using Yojson, with constructors and accessors for building and inspecting error causes, particularly for validation failures or field-specific errors. The child module provides a list of key-value pairs where each value is a cause, enabling structured handling of multiple errors returned by the API. Example usage includes decoding API error responses into structured cause lists and extracting specific field errors for user feedback.",
      "description_length": 678,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Exec",
      "library": "kubecaml",
      "description": "This module handles execution of commands in a specific pod within a namespace using GET and POST requests. It supports configuring input/output streams and connecting to the pod's execution endpoint with customizable options like container name and command. Concrete use cases include running interactive shells or executing diagnostic commands in a containerized environment.",
      "description_length": 377,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module tracks changes to ControllerRevision resources within a namespace, streaming events through a `get` function that supports filters like label selectors and resource versions. It includes a child module for monitoring individual ControllerRevision objects, enabling real-time observation of updates or deletions for specific resources. The `request_path_template` shapes the structure of watch requests, allowing precise control over event streams. For example, you can watch all ControllerRevisions in a namespace or track changes to a specific revision by name and version.",
      "description_length": 586,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Namespaces.By_namespace.Events.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing Kubernetes Events within a specific namespace. It supports retrieving, replacing, deleting, and partially updating Event resources using standard HTTP methods. The module works directly with event objects and requires parameters like namespace, name, and optional query flags or patch bodies. Use this module to manipulate individual Events in a cluster, such as updating event status or removing outdated events.",
      "description_length": 465,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_group",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes API group, capturing its name, supported versions, preferred version, and server addresses indexed by client CIDR. It provides constructors, accessors, and serialization functions for working with API groups directly, such as parsing discovery documents or selecting the appropriate server based on client network location. The child module manages a list of these groups, offering JSON (de)serialization to support interactions with Kubernetes discovery endpoints. Together, they enable structured handling of API version negotiation and server routing in client communication.",
      "description_length": 614,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module monitors DaemonSet resources in a Kubernetes namespace, streaming WatchEvent updates in real time. It offers a `get` function to track lifecycle events like creation and modification, with support for filters such as `namespace`, `label_selector`, and `resource_version`. Built on Kubernetes API objects like Watch_event, it enables precise control over watch behavior and direct interaction with DaemonSet resources via HTTP. Use it to observe DaemonSet changes at a high level or integrate with submodules for detailed resource management.",
      "description_length": 553,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_list",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes API services with support for JSON serialization and deserialization. It provides constructors, accessors, and core operations for managing lists of API service objects, including fields such as `api_version`, `kind`, `metadata`, and `items`. The module handles labeled groupings of service lists, enabling structured management of multiple versions or categories of API services. Use it to retrieve, construct, or organize API service data for cluster management or service discovery in Kubernetes.",
      "description_length": 549,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Api.Resource.Quantity.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a resource quantity, such as CPU or memory. It provides functions to convert this structure to and from JSON format using `to_yojson` and `of_yojson`. It is used to handle resource specifications in Kubernetes API objects, enabling precise serialization and deserialization of resource requirements.",
      "description_length": 368,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_bool",
      "library": "kubecaml",
      "description": "This module combines JSON schema definitions with boolean flags to represent conditional validation rules, commonly used in Kubernetes CRDs. It supports constructing and deconstructing values that are either schema properties or a boolean, with direct conversions to and from JSON using `Yojson.Safe.t`. The main operations include creating schema-or-bool values, checking their boolean status, and serializing them for use in API definitions. For example, it enables defining a CRD validation rule that either enforces a full schema or skips validation based on a `true` or `false` flag.",
      "description_length": 588,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Limitranges.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific LimitRange object within a namespace in Kubernetes. It provides a `get` function to establish a watch stream, accepting parameters like namespace, name, and optional filters. The result is a stream of watch events that track modifications to the specified LimitRange resource.",
      "description_length": 322,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Proxy",
      "library": "kubecaml",
      "description": "This module manages HTTP proxy connections to Kubernetes pods using namespace and pod names, supporting standard HTTP methods to interact with pod-specific services. It provides direct APIs for routing requests to specific pod paths, enabling operations like monitoring, configuration updates, and API invocation. The core functionality includes asynchronous handling of GET, PUT, POST, DELETE, and similar requests, with concrete examples including proxying to a pod's /healthz endpoint or sending configuration data via /configure. Submodules extend this capability by allowing fine-grained routing to specific paths within a pod's proxy endpoint.",
      "description_length": 649,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module tracks changes to ControllerRevision resources in a namespace, streaming events filtered by version, label, or field selectors. It offers a `get` function to observe real-time lifecycle events of ControllerRevision objects, enabling reactions to updates or deletions. The child module extends this capability by allowing observation of specific named resources, adding granularity to event monitoring. Together, they support use cases like tracking configuration changes or managing rollbacks by watching versioned ControllerRevision data.",
      "description_length": 551,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service",
      "library": "kubecaml",
      "description": "This module manages API services representing servers for specific GroupVersions in Kubernetes, allowing construction, manipulation, and configuration of these services with support for metadata, specifications, and status. It includes operations to serialize and deserialize API service objects to and from JSON, enabling storage and transmission of configurations. The module works with tuples of service names and definitions, making it possible to process multiple services in a single operation. Example uses include registering backend servers in the Kubernetes aggregator layer and converting service definitions to JSON for persistence.",
      "description_length": 644,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Binding",
      "library": "kubecaml",
      "description": "This module handles the creation of Pod bindings within a specified namespace by providing a `post` function that sends a binding request with a given body. It works with Kubernetes Pod binding data structures, specifically the `V1.Binding.t` type, and requires parameters such as namespace, name, and request body. A concrete use case is programmatically assigning a Pod to a specific node in a Kubernetes cluster.",
      "description_length": 415,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresource_status",
      "library": "kubecaml",
      "description": "This module manages the status subresource for custom Kubernetes resources, ensuring that updates to the `.status` field occur exclusively through the `/status` endpoint while ignoring status changes in regular resource updates. It provides JSON serialization and deserialization functions for handling the status stanza, allowing precise manipulation of status data in custom resource definitions. The child module works with associative lists to read and write JSON representations of status subresource configurations, enabling structured access to per-resource status settings. Together, they support fine-grained control over custom resource status updates in a Kubernetes API.",
      "description_length": 682,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Podtemplates.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific PodTemplate resource within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and label selectors. Use it to monitor real-time updates to a PodTemplate object in a Kubernetes cluster.",
      "description_length": 302,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Namespaces.By_namespace.Poddisruptionbudgets.By_name",
      "library": "kubecaml",
      "description": "This module manages PodDisruptionBudget resources in Kubernetes namespaces, offering REST operations to get, put, delete, and patch budgets by name. It directly handles full resource definitions and supports partial updates through patch operations, enabling precise control over disruption policies. The child module extends this functionality to status-specific actions, allowing retrieval and modification of a budget's status field independently. Together, they provide a comprehensive interface for maintaining and updating PodDisruptionBudgets during cluster maintenance or application rollouts.",
      "description_length": 601,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Namespaces.By_namespace.Networkpolicies.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes NetworkPolicy resources within a specific namespace. It provides functions to get, put, delete, and patch network policies using a given URI, with support for standard Kubernetes API query parameters and request headers. The module works directly with NetworkPolicy definitions and handles responses as either parsed resource objects or error strings.",
      "description_length": 405,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Namespaces.By_namespace.Cronjobs.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CronJob resources within a namespace, supporting direct CRUD operations through `get`, `put`, `delete`, and `patch` functions. It enables tasks like scheduling periodic jobs or modifying existing CronJob configurations. The status submodule extends this functionality by allowing retrieval and updates to a CronJob's status subresource, facilitating inspection and state adjustments. Together, they provide a complete interface for both configuration and runtime state management of CronJobs via REST.",
      "description_length": 532,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Services.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes Services within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a Service using HTTP GET, PUT, and PATCH requests. The module works directly with Service and Patch data types, targeting scenarios such as monitoring Service health or updating Service status in coordination with controller logic.",
      "description_length": 408,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Status_details",
      "library": "kubecaml",
      "description": "This module organizes detailed error metadata from Kubernetes API responses, combining structured fields like `name`, `kind`, and `retry_after_seconds` with flexible handling of extended attributes. It supports parsing and serializing these details to and from JSON, enabling precise interpretation of server responses such as validation failures or rate-limiting indicators. The child module enhances this by managing collections of these details, allowing bulk processing of multiple error contexts returned in a single response. Together, they enable robust handling of rich error payloads while maintaining compatibility with evolving server-defined schemas.",
      "description_length": 662,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Deployment resources within a Kubernetes namespace, supporting filters by label and field selectors, customizable timeouts, resource versions, and pagination. It enables tracking of deployment updates and rollouts, with the ability to observe changes either broadly across the namespace or for specific deployments by name. The child module extends this functionality by allowing detailed inspection and event monitoring of individual Deployment resources, using the same configuration parameters. For example, you can watch all deployments in a namespace for status changes or focus on a single deployment to track its rollout progress in real time.",
      "description_length": 695,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module tracks changes to ReplicaSet resources in a namespace, supporting filters via label and field selectors, and customizable watch parameters like timeout and resource version. It enables real-time monitoring of ReplicaSet events such as scaling or status updates, with a concrete use case being automated alerting or response to deployment changes. The child module focuses on watching a specific ReplicaSet, offering a `get` function to initiate targeted watches and return events as they occur. Together, they provide both broad and fine-grained visibility into ReplicaSet dynamics within a cluster.",
      "description_length": 611,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces.By_namespace.Rolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes RoleBindings within a specific namespace, providing functions to get, put, delete, and patch RoleBinding resources using the RBAC v1alpha1 API. It works with structured data types such as `Role_binding.t` for full representations and `Delete_options.t`, `Patch.t` for modifications. Use this module to manage role-based access control bindings programmatically in a Kubernetes cluster, such as updating permissions or removing deprecated bindings.",
      "description_length": 501,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_subresources",
      "library": "kubecaml",
      "description": "This module manages the definition and manipulation of custom resource subresources, focusing on status and scale extensions in Kubernetes. It provides data types to represent subresource configurations and operations to construct, access, and serialize them, including handling optional fields. The module supports converting lists of subresource configurations to and from JSON, enabling seamless integration with API interactions and persistent storage. Use it to define custom resources with extended capabilities such as status tracking or scalable replicas.",
      "description_length": 563,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service_condition",
      "library": "kubecaml",
      "description": "This module represents API service conditions in Kubernetes, capturing state details like type, status, reason, message, and transition time. It supports creating, accessing, and converting condition records, with JSON handling provided by its child module for use with Kubernetes registration endpoints. You can construct a condition with `make`, extract its status with `get_status`, or serialize a list of conditions to JSON for API transmission. The child module enables working with JSON key-value pairs where each value is a condition, facilitating direct interaction with Kubernetes registration endpoints.",
      "description_length": 613,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployments within a namespace, offering direct operations to retrieve, replace, delete, and patch deployments, as well as manipulate their status and scale subresources. It centers around the Deployment type, with core operations like `get`, `put`, `patch`, and `delete`, while submodules handle status updates and scaling via the `Scale` type from autoscaling/v1. Use it to deploy new configurations, roll back changes, inspect rollout progress, or adjust replica counts programmatically. The API combines direct resource manipulation with targeted subresource updates for full lifecycle management.",
      "description_length": 632,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Networkpolicies.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes NetworkPolicy resources within a specific namespace, providing `get`, `put`, `delete`, and `patch` functions to interact with individual NetworkPolicy objects by name. It works directly with NetworkPolicy definitions and handles HTTP communication using Cohttp, returning parsed responses or error messages. Concrete use cases include retrieving, updating, deleting, or patching a specific network policy in a namespace, such as applying new ingress rules or removing outdated policies.",
      "description_length": 540,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch.Namespaces.By_namespace.Podpresets",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of PodPreset resources within a namespace, allowing filtering by labels and fields, and control over resource versions, timeouts, and pagination. It supports dynamic configuration adjustments by tracking changes to environment variables and volume mounts across all PodPresets or a specific object. The child module enables watching individual PodPreset objects over long-lived connections, offering fine-grained control with limit and continue parameters for efficient result handling. Together, they facilitate scalable and responsive configuration management in Kubernetes clusters.",
      "description_length": 627,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module watches for changes to StatefulSet resources across a namespace, supporting filtering by label or field selectors, resource version, and timeout settings. It produces a stream of watch events signaling additions, updates, or deletions of StatefulSets, integrating Kubernetes event types with structured access to resource changes. The child module focuses on tracking specific StatefulSet instances by name, enabling fine-grained monitoring of named resources using `get` operations and real-time event retrieval. Together, they support use cases like monitoring rollout progress, inspecting stateful application scaling events, or reacting to configuration changes in watched StatefulSets.",
      "description_length": 702,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Events.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Event objects within a specific namespace and name. It supports filtering by label and field selectors, limiting results, and controlling the watch behavior with options like timeout and resource version. A concrete use case is monitoring the creation or deletion of Kubernetes events related to a specific resource in real time.",
      "description_length": 364,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module observes changes to Role resources in a Kubernetes namespace, streaming events via a `get` function that supports filtering by label or field selector, resource version, and timeout. It defines the request path structure through `request_path_template`, enabling precise control over watch requests. Use it to monitor real-time role updates, such as detecting permission changes for audit logging or synchronizing role definitions across systems. The child module extends this functionality with additional customization options for watch streams, enhancing flexibility in tracking Role modifications.",
      "description_length": 613,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Persistentvolumeclaims.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes persistent volume claims within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a persistent volume claim by name. These operations are performed via HTTP requests using Cohttp, targeting a Kubernetes API server.",
      "description_length": 325,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json",
      "library": "kubecaml",
      "description": "This module represents and manipulates JSON values using a custom type that includes boolean, integer, float, string, array, object, and nil. It provides direct functions to convert between this custom type and `Yojson.Safe.t`, enabling structured JSON processing in OCaml, particularly for Kubernetes API extensions. The child module handles JSON objects as key-value lists, supporting conversion to and from `Yojson.Safe.t` for tasks like validating and serializing structured data in custom resource definitions. Example uses include parsing JSON input into typed values, building complex JSON structures for API requests, and validating custom resource schemas against expected formats.",
      "description_length": 690,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Patch",
      "library": "kubecaml",
      "description": "This module models Kubernetes patch operations as structured data, allowing developers to create, modify, and interpret patch payloads using concrete types and JSON representations. It supports serialization and deserialization via Yojson, enabling seamless integration with Kubernetes API requests. The module is particularly useful for applying strategic merge or JSON patches to cluster resources, such as updating deployment configurations or service definitions. By combining direct type definitions with list-based patch representations, it offers a flexible interface for both constructing and parsing patch operations.",
      "description_length": 626,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module monitors Role resources in a Kubernetes namespace, streaming events for real-time access control adjustments. It supports filtering by label or field selector, resource version, and timeout through its `get` function. A child module focuses on watching individual Role resources with similar parameters. Together, they enable precise, dynamic tracking of RBAC changes at both the namespace and specific resource levels.",
      "description_length": 431,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch.Namespaces.By_namespace.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module watches Horizontal Pod Autoscaler resources in a specific namespace, streaming events for lifecycle changes like scaling actions or config updates. It supports filtering with `label_selector`, synchronization via `resource_version`, and named autoscaler monitoring. The child module focuses on tracking a specific autoscaler by name, adding parameters like timeout to refine watch streams. Together, they enable real-time observation of autoscaler behavior at both broad and granular levels.",
      "description_length": 503,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Eviction",
      "library": "kubecaml",
      "description": "This module handles eviction operations for Kubernetes Pods by providing a function to create an eviction request for a specific Pod in a given namespace. It works with the `Eviction` type from the `Api.Policy.V1beta1` definitions and interacts with Kubernetes via HTTP POST requests. A concrete use case is programmatically evicting a Pod to trigger its graceful termination and rescheduling.",
      "description_length": 393,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing Kubernetes Role resources within a specific namespace. It supports get, put, delete, and patch methods to retrieve, replace, remove, or partially update a Role by name. The module works directly with Role definitions and standard Kubernetes delete and patch options.",
      "description_length": 318,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1.Api_service_status",
      "library": "kubecaml",
      "description": "This module manages the status of an API service in a Kubernetes cluster, providing functions to create, access, and serialize a list of conditions that represent the service's state. It centers around the `t` type, which captures derived status information, and supports operations to convert between in-memory representations and JSON format. The child module extends this by handling structured JSON conversion, enabling tasks like persisting status data or decoding external inputs into typed status objects. Together, they facilitate tracking and reporting the health and availability of API services within the Kubernetes aggregator layer.",
      "description_length": 645,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Secrets.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Secret resource within a given namespace. It provides a `get` function to establish a watch stream with options like timeout, resource version, and selectors, returning a result with a watch event or error. Use it to monitor real-time updates to Secrets, such as tracking configuration changes or observing credential updates in a cluster.",
      "description_length": 392,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_condition",
      "library": "kubecaml",
      "description": "This module models the state of custom resource definitions in Kubernetes by capturing condition details like type, status, and transition time, while also supporting construction, access, and JSON serialization of these conditions. It handles both individual condition values and collections of conditions through its main type and list submodule. You can create a condition with `make`, inspect its status with `status`, or convert a list of conditions to JSON with `to_yojson`. The module enables precise tracking and communication of resource health and changes within a cluster.",
      "description_length": 583,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes DaemonSets in a namespace, offering `get`, `put`, `delete`, and `patch` operations to manipulate their configuration via Cohttp. It works with core types like DaemonSet, DeleteOptions, and Patch, enabling tasks such as updating pod specs or removing deployments. The status submodule extends this functionality by allowing retrieval and modification of DaemonSet status fields, such as observed generation and pod counts, using similar HTTP interactions. Together, they provide a complete interface for both managing DaemonSet resources and inspecting or updating their runtime state within a cluster.",
      "description_length": 632,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Watch_event",
      "library": "kubecaml",
      "description": "This module represents events in a Kubernetes watch stream, capturing changes to resources with string-based event types like \"Added\", \"Modified\", \"Deleted\", and \"Error\". It provides functions to construct events, access their type and associated object, and serialize or deserialize events using JSON. The child module handles conversion between structured watch event data and JSON using `Yojson.Safe.t`, supporting transmission or storage. For example, you can create an event with a specific type and resource object, then serialize it to JSON for sending over a stream or later retrieval.",
      "description_length": 593,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Namespaces.By_namespace.Jobs.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Jobs within a namespace, offering operations to retrieve, replace, delete, and partially update Job configurations and status. It centers around Job definitions and metadata, enabling precise control over Job state and execution. The child module extends this by focusing on status-specific operations, allowing inspection and modification of Job execution states without altering the full configuration. Use cases include automating Job lifecycle tasks, monitoring batch job progress, and applying targeted status updates through standard Kubernetes API patterns.",
      "description_length": 595,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Json_schema_props_or_array",
      "library": "kubecaml",
      "description": "This module represents values that can be either a single JSON schema definition or an array of such definitions, primarily for use in Kubernetes CRD validation rules. It provides constructors, destructors, and JSON serialization functions for handling these schema definitions, supporting both direct API usage and integration with submodules. The main data types are `t`, which encapsulates the schema or array of schemas, and `key_value_list`, representing lists of key-value pairs used in schema definitions. You can use it to serialize a schema definition to JSON, deserialize a JSON array of schemas, or check whether a value is a single schema or an array.",
      "description_length": 663,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_status",
      "library": "kubecaml",
      "description": "This module captures the runtime status of a Kubernetes custom resource definition, providing access to key fields like `conditions` for health tracking and `accepted_names` for resource naming in discovery. It enables construction and inspection of status objects that reflect the current state and configuration of a CRD. The child module handles JSON serialization and deserialization of these status objects, allowing structured persistence or transmission of CRD status data. Together, they support managing and exchanging CRD status information within Kubernetes API extensions.",
      "description_length": 584,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Persistentvolumeclaims.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific PersistentVolumeClaim resource within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor real-time updates for a named PersistentVolumeClaim in a Kubernetes cluster.",
      "description_length": 316,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module tracks changes to ControllerRevision resources in a namespace, streaming events for all or specific ControllerRevisions with support for resource versions, label selectors, and timeouts. It offers direct access to watch and query ControllerRevision objects, enabling real-time monitoring of their creation, modification, or deletion. The child module extends this functionality by allowing fine-grained observation of individual named ControllerRevision instances. For example, you can use `get` to stream update events for a specific ControllerRevision or watch for deletions across all ControllerRevisions in a namespace.",
      "description_length": 635,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Deployments.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployments in a specific namespace through HTTP operations, allowing retrieval, replacement, deletion, and partial updates. It provides direct access to Deployment resources while coordinating with submodules for status management, scaling, and rollbacks. The main data types include Deployment specifications, Patch objects, and Scale subresources, with operations like `get`, `replace`, `patch`, and `delete`. Specific examples include applying configuration updates, checking deployment conditions, scaling replicas, and initiating rollbacks using dedicated functions from its submodules.",
      "description_length": 623,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Preconditions",
      "library": "kubecaml",
      "description": "This module enforces conditions that must be satisfied before Kubernetes API operations, such as updates or deletions, can proceed. It defines a type `t` representing preconditions based on resource UIDs and includes functions to construct and inspect these conditions. The child module extends this by managing a list of preconditions, each associating a string key with a `t` value, and supports JSON serialization and deserialization for integration with API requests. For example, it can verify that a resource's UID matches before deletion or ensure a specific version is present before applying an update.",
      "description_length": 611,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1.Custom_resource_definition_names",
      "library": "kubecaml",
      "description": "This module manages the naming conventions for custom resources in a Kubernetes API, providing a record type `t` with fields like `kind`, `plural`, `singular`, and `short_names` to define how resources are identified and grouped. It supports converting these naming schemas to and from JSON, enabling integration with API servers. The child module extends this by handling lists of named custom resource definitions, allowing bulk serialization and deserialization of multiple resources. You can use it to configure resource aliases, specify groupings, or map internal types to API-visible names.",
      "description_length": 596,
      "index": 252,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.List_meta",
      "library": "kubecaml",
      "description": "This module defines metadata for synthetic Kubernetes list resources, including fields like `continue`, `resource_version`, and `self_link`, with support for JSON serialization via Yojson. It provides constructors, accessors, and functions to parse and serialize list metadata, enabling consistent handling of paginated API responses. The child module extends this by representing lists of key-value pairs where each value is a `List_meta` object, allowing structured encoding of complex metadata in Kubernetes resource collections. Example uses include tracking continuation tokens during pagination and maintaining resource version consistency in client-server interactions.",
      "description_length": 676,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Resourcequotas.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific Kubernetes ResourceQuota object within a namespace. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to a named ResourceQuota, such as tracking quota usage changes in a production namespace.",
      "description_length": 352,
      "index": 254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes DaemonSets within a namespace using standard HTTP methods like `get`, `put`, `delete`, and `patch`, enabling full lifecycle operations on DaemonSet resources via their path template. It includes a submodule focused on status updates, allowing retrieval, replacement, or patching of a DaemonSet's status to reflect its current observed state. Key data types include DaemonSet definitions, Patch payloads, and DeleteOptions, with operations that support both full and partial updates. Example uses include fetching a DaemonSet's current configuration, applying a revised spec, or updating its status to match observed cluster conditions.",
      "description_length": 666,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Services.By_name.Proxy",
      "library": "kubecaml",
      "description": "This module forwards HTTP requests to Kubernetes services within a specific namespace by name, supporting standard methods like GET, PUT, POST, DELETE, OPTIONS, HEAD, and PATCH. It enables direct interaction with Kubernetes service endpoints for operations such as retrieving data, modifying configurations, or triggering actions. The child module extends this functionality by allowing path-based routing to specific service endpoints, using namespace and name to direct requests. Together, they provide a structured way to proxy client requests through HTTP to Kubernetes services, aligning with the Kubernetes API's proxying capabilities.",
      "description_length": 641,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Daemonsets.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes DaemonSets within a specific namespace and name context, supporting get, put, delete, and patch operations to retrieve, replace, remove, or partially update DaemonSet resources. It works directly with DaemonSet objects and related types such as DeleteOptions and Patch, enabling precise control over DaemonSet configurations. The status submodule extends this functionality by allowing retrieval, replacement, or partial updates of a DaemonSet's status using the same namespace and name context. For example, you can update a DaemonSet's desired pod template or update its observed status after a rolling update.",
      "description_length": 643,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Group_version_for_discovery",
      "library": "kubecaml",
      "description": "This module structures Kubernetes API version information using a custom type `t` that captures group/version strings and supports parsing and serialization. It enables operations like extracting version components, constructing versioned resource paths, and integrating with discovery endpoints. The child module enhances this functionality by representing multiple group versions as a list, with JSON support for encoding and decoding discovery responses. Together, they facilitate working with Kubernetes API discovery data, from individual version handling to list-level manipulations.",
      "description_length": 589,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Initializer",
      "library": "kubecaml",
      "description": "This module tracks Kubernetes initializers before they complete, capturing the responsible process name and providing creation, retrieval, and JSON (de)serialization operations. It represents initializer lists as tuples of strings and initializer values, enabling structured coordination of initialization steps during object creation. Functions like `create`, `name`, `to_yojson`, and `of_yojson` support constructing and manipulating initializer data, while the child module handles list-level serialization for Kubernetes API interactions. Example usage includes encoding pending initializers in custom resource definitions or decoding initializer lists from API server responses.",
      "description_length": 683,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1.Api_service",
      "library": "kubecaml",
      "description": "This module manages API services for Kubernetes aggregation layers, providing functions to construct and modify API service objects with structured data types like `Api_service_spec` and `Api_service_status`. It supports setting metadata, spec, and status fields, and handles serialization of API service configurations to and from JSON using `to_yojson` and `of_yojson`. The module works with lists of tuples containing strings and `Api_service.t` records, enabling precise API service definitions for Kubernetes registration endpoints. Use cases include building and serializing API service objects for Kubernetes group versions like \"v1.group\".",
      "description_length": 647,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name.Attach",
      "library": "kubecaml",
      "description": "This module handles attaching to a running Pod in a specific namespace by establishing a connection for streaming input/output. It provides `get` and `post` functions to initiate an attach session, supporting options like `tty`, `stdout`, `stdin`, and `stderr`, along with container selection. Use cases include interacting with containers in real-time, such as running shell commands or viewing logs directly from a Pod.",
      "description_length": 421,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Replicationcontrollers.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes replication controllers within a specific namespace. It provides functions to retrieve, replace, or partially update the status of a replication controller by name. These operations are performed via HTTP requests using the Cohttp library, targeting a Kubernetes API server.",
      "description_length": 335,
      "index": 262,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1.Api_resource",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes API resource, capturing its name, namespace status, kind, supported verbs, and metadata, with direct accessors and JSON (de)serialization via Yojson. It supports inspecting API endpoints, generating client code, and managing resource discovery in Kubernetes tooling. The child module handles collections of these resources, representing them as lists of name-resource pairs, with JSON conversion functions for working with API discovery responses. Together, they enable structured interaction with Kubernetes API definitions, both individually and in bulk.",
      "description_length": 592,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces.By_namespace.Roles.By_name",
      "library": "kubecaml",
      "description": "This module implements direct REST operations for managing Kubernetes RBAC Roles within a specific namespace. It provides functions to retrieve, replace, delete, and partially update Role resources using their namespace and name. These operations are intended for interacting with a Kubernetes API server to administer role-based access control policies.",
      "description_length": 354,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes workloads by tracking changes to StatefulSet, Deployment, and ControllerRevision resources within a namespace. It supports filtering by label and field selectors, custom resource versions, and configurable timeouts, enabling precise control over event streams. You can observe changes across all resources or target specific instances by name using `get` to stream events for individual StatefulSets, Deployments, or ControllerRevisions. Examples include triggering autoscaling based on StatefulSet updates, tracking Deployment rollout progress, or monitoring deletion events for ControllerRevisions.",
      "description_length": 656,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_rules_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes authorization rule review data to and from JSON. It works with lists of string-authorization review pairs, representing user permissions within a namespace. Concrete use cases include converting rule review responses for API communication or storage, and parsing incoming JSON data into structured rule sets for inspection.",
      "description_length": 391,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module tracks changes to PodDisruptionBudget resources across namespaces, supporting filters via label and field selectors, with fine-grained control over resource version, timeout, and pagination. It enables real-time monitoring of disruption budgets during rolling updates or cluster maintenance and allows streaming events for specific budgets by name. The `get` function watches named PodDisruptionBudgets, reacting to updates or deletions as they occur. This facilitates dynamic management of disruption policies in evolving cluster environments.",
      "description_length": 556,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Kubernetes event, enabling structured handling of multiple events with associated identifiers. It provides JSON serialization and deserialization functions for converting event data to and from JSON format. This structure is useful for processing and transmitting event streams in a typed manner, particularly when working with cluster-level events that need to be grouped or indexed.",
      "description_length": 452,
      "index": 268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes workloads within a namespace, including Deployments, DaemonSets, ReplicaSets, StatefulSets, and ControllerRevisions. It offers a unified interface to stream `Watch_event` values for these resources, with support for filtering by labels, fields, and resource versions, as well as pagination and timeouts. Key operations include tracking rollout progress, detecting scaling events, and reacting to configuration changes or health updates. For example, you can watch a specific Deployment for update events, monitor a DaemonSet across nodes, or trigger actions based on StatefulSet scaling changes.",
      "description_length": 651,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Controller_revision_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Controller_revision objects, represented as an associative list mapping strings to Controller_revision_list instances. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON format. This is used when interacting with Kubernetes API endpoints that return or require Controller_revision list data in JSON, such as retrieving historical controller revisions for a stateful set.",
      "description_length": 487,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_from_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of environment variable sources backed by ConfigMaps. It operates on a list of key-value pairs where each value is an `Env_from_source` type, representing configuration data from Kubernetes. Use this module when constructing or parsing environment configurations from ConfigMaps in Kubernetes manifests.",
      "description_length": 361,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Deployment objects into JSON format. It works with a list of key-value pairs where each value is a Deployment_list.t. It is used to convert Deployment data to and from JSON representations for storage or transmission.",
      "description_length": 299,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Cross_version_object_reference.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of cross-version object references in Kubernetes autoscaling configurations. It works with tuples of strings and structured reference types, enabling precise identification of referred resources. Concrete use cases include converting resource references to and from JSON format for storage or transmission.",
      "description_length": 360,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_requirements.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to `Resource_requirements.t` values, used to specify compute resource constraints for Kubernetes objects. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is commonly used when defining resource limits and requests for containers in Kubernetes deployments.",
      "description_length": 377,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to deployment strategy configurations, specifically used to define how Kubernetes replaces pods during deployments. It provides serialization and deserialization functions to convert between JSON and OCaml representations using Yojson. This structure is essential when configuring deployment update strategies such as RollingUpdate or Recreate in Kubernetes manifests.",
      "description_length": 433,
      "index": 275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Iscsi_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Iscsi persistent volume source objects to and from JSON format. It works with a list of tuples, where each tuple consists of a string and an Iscsi persistent volume source configuration. Concrete use cases include converting Iscsi volume definitions to JSON for API requests and parsing JSON responses into structured volume configurations.",
      "description_length": 401,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Replica_set objects from the deprecated `extensions/v1beta1` API version to and from JSON format. It works with a list-based structure pairing string keys with Replica_set records, aligning with Kubernetes object definitions. Concrete use cases include reading Replica_set configurations from JSON input and converting in-memory Replica_set data to JSON for output or transmission.",
      "description_length": 442,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_volume_file.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to downward API volume file configurations, enabling precise specification of pod field data injection into volumes. It provides JSON serialization and deserialization capabilities for these mappings using `to_yojson` and `of_yojson`. This is used when configuring Kubernetes pods to expose metadata or resource information directly into container-mounted files.",
      "description_length": 425,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs mapping strings to Deployment_spec values, enabling structured configuration of Kubernetes Deployments. It provides serialization and deserialization to and from JSON using Yojson, ensuring compatibility with Kubernetes API expectations. Use this module to define or manipulate Deployment specifications programmatically, such as when generating or parsing Deployment manifests.",
      "description_length": 433,
      "index": 279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Pod specification, enabling grouping multiple Pod configurations under distinct identifiers. It provides direct serialization to and from JSON using `to_yojson` and `of_yojson`, ensuring compatibility with JSON-based Kubernetes APIs. This structure is useful when managing multiple named Pod instances, such as in multi-tenant environments or when organizing related workloads.",
      "description_length": 445,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_terminated.Object",
      "library": "kubecaml",
      "description": "This module represents the terminated state of a container in Kubernetes, specifically encoding and decoding its attributes as a list of key-value pairs. It provides direct serialization to and from JSON format using `to_yojson` and `of_yojson`, ensuring compatibility with Kubernetes API expectations. This module is used when inspecting or constructing container termination statuses within a pod's lifecycle management.",
      "description_length": 422,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flex_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list-based representation of FlexPersistentVolumeSource objects to and from JSON format. It works with associative lists mapping strings to FlexPersistentVolumeSource records. It is used to convert Kubernetes volume source configurations to JSON for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 387,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each value is a `Persistent_volume_claim_condition.t`, used to track the state of persistent volume claims. It provides `to_yojson` and `of_yojson` functions for converting between JSON and OCaml representations. This module is useful when handling Kubernetes API responses that include lists of persistent volume claim conditions, such as reporting the status of PVCs in a cluster.",
      "description_length": 443,
      "index": 283,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_condition.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of certificate signing request conditions to and from JSON format. It operates on a list of key-value pairs where values are of type `Certificate_signing_request_condition.t`. It is used to serialize and deserialize Kubernetes certificate signing request condition objects for API interactions.",
      "description_length": 329,
      "index": 284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of StatefulSet update strategy objects to and from JSON. It works with a list of key-value pairs where each value is a Stateful_set_update_strategy.t. It is used to convert update strategy configurations to JSON format for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 355,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module manages Role resources in a Kubernetes namespace, offering operations to list, create, and delete Roles using the RBAC v1beta1 API. It works with Role and RoleList data types, supporting label-based filtering and resource versioning. The module enables concrete actions like listing roles matching a label selector or creating a new role in a specific namespace. Its REST submodule handles low-level CRUD operations, including retrieving, replacing, and deleting Roles via HTTP methods, working directly with Kubernetes API responses.",
      "description_length": 546,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes RBAC cluster role bindings, where each binding is paired with a string identifier. It provides functions to convert the list to and from JSON format using `Yojson.Safe`. This structure is used to manage and serialize collections of cluster role bindings in Kubernetes RBAC configurations.",
      "description_length": 332,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_rollback.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of deployment rollback data structures to and from JSON format. It works with a list of key-value pairs where each value is a deployment rollback configuration. It is used to convert deployment rollback objects to JSON for storage or transmission, and to parse such objects from JSON input.",
      "description_length": 348,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_ref.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of role reference objects into JSON format. It operates on a list of tuples, each containing a string and a role reference structure. Concrete use cases include converting role reference data to and from JSON for storage or transmission in Kubernetes RBAC configurations.",
      "description_length": 329,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes RBAC cluster roles as a collection of key-value pairs, where each key is a string identifier and the value is a cluster role object. It provides functions to serialize the collection to JSON (`to_yojson`) and deserialize it from JSON (`of_yojson`). This structure is used when managing or querying multiple cluster roles in a Kubernetes system, particularly during configuration or policy enforcement tasks.",
      "description_length": 451,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Replica_set_status objects into JSON format. It works with a list of key-value pairs where each value is a Replica_set_status record. Use this module when converting Replica_set_status data to or from JSON, such as when interacting with Kubernetes APIs or storing configuration data.",
      "description_length": 344,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a stateful set condition, providing serialization to and from JSON. It works with lists of tuples pairing strings with stateful set condition records. Use this module to handle collections of stateful set conditions when interacting with Kubernetes API endpoints or processing stateful set status information.",
      "description_length": 378,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Se_linux_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an Se_linux strategy option, used to define security policies for Kubernetes pods. It provides functions to convert the list to and from JSON format, enabling serialization and deserialization for configuration and storage. This structure is typically used when specifying SELinux context constraints in pod security policies.",
      "description_length": 395,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_status.Object",
      "library": "kubecaml",
      "description": "This module represents the current state of a StatefulSet in Kubernetes, specifically encoding and decoding its status information to and from JSON. It works with a list of key-value pairs where each value is a Stateful_set_status type, capturing details like observed generation, replicas, and persistent volume claims. Concrete use cases include serializing StatefulSet status data for storage or transmission and deserializing it for inspection or further processing.",
      "description_length": 470,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Persistent Volume Claim (PVC) volume source objects into JSON format. It works with a list-based structure where each element is a tuple of a string and a PVC volume source definition. Concrete use cases include converting PVC volume source configurations to JSON for storage or transmission, and parsing JSON input into structured PVC volume source data for use in Kubernetes pod specifications.",
      "description_length": 457,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_port.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of container port definitions to and from JSON format. It works with a list of tuples, where each tuple pairs a string identifier with a container port configuration. Concrete use cases include converting container port data to JSON for API requests and parsing JSON responses into structured container port objects.",
      "description_length": 374,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Daemon_set_spec.t` record, primarily used for parsing and serializing daemon set specifications to and from JSON. It provides `to_yojson` and `of_yojson` functions for converting these lists to JSON and validating JSON input against the expected structure. This is useful when interacting with Kubernetes API endpoints that require or return collections of daemon set specifications, such as retrieving or updating multiple daemon sets in a cluster.",
      "description_length": 521,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_access_review_spec.Object",
      "library": "kubecaml",
      "description": "This module represents the object specification for an access review request in the Kubernetes authorization API. It provides serialization and deserialization functions to and from JSON format using `to_yojson` and `of_yojson`. It is used to define structured access control checks for subjects attempting to perform actions within a Kubernetes cluster.",
      "description_length": 354,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1beta1",
      "library": "kubecaml",
      "description": "This module provides structures and operations for managing Kubernetes API services, including their conditions, specifications, and status. It defines key data types like API service conditions with status and transition time, service references with optional namespace and name, and API service specs with TLS and priority settings. These types support constructing, serializing, and inspecting API services and their state, enabling tasks like registering backend servers, tracking service availability, and exporting configurations in JSON format. Specific operations include loading API service definitions from files, updating TLS settings, and querying service conditions for health reporting.",
      "description_length": 700,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Replica_set_spec objects into JSON format. It works with a list-based structure where each element is a tuple of a string and a Replica_set_spec.t value. Use this module when converting Replica_set specifications to and from JSON, such as when interacting with Kubernetes APIs or storing configuration data.",
      "description_length": 368,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration.V1",
      "library": "kubecaml",
      "description": "This module suite provides a comprehensive interface for managing Kubernetes API services, focusing on configuration, status tracking, and service references. Core data types include `t` for API service specifications, `Api_service_condition` for health states, and service references with namespace details, all supporting JSON serialization. Operations allow constructing and modifying service configurations, inspecting status conditions, and mapping services by labels or versions. Example uses include building secure API endpoints, tracking service health with conditions, and organizing API service lists for cluster management or versioned routing.",
      "description_length": 656,
      "index": 301,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Namespaces.By_namespace.Networkpolicies",
      "library": "kubecaml",
      "description": "This module manages Kubernetes network policies in a specific namespace, offering core operations to list, watch, create, and delete policies via HTTP with customizable queries and headers. It directly handles NetworkPolicy and NetworkPolicyList data types, enabling precise interaction with the Kubernetes API. The child module extends this functionality with fine-grained CRUD actions, allowing operations like get, put, delete, and patch on individual network policies using specific URIs. Together, they support tasks such as synchronizing policy states, applying updates, and handling API responses with structured error handling.",
      "description_length": 635,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_binding.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Role_binding objects to and from JSON format. It operates on a list of tuples, where each tuple consists of a string and a Role_binding type, representing named Role_binding entries. It is used to convert Role_binding data to JSON for storage or transmission and parse JSON back into structured Role_binding objects for configuration or API interaction.",
      "description_length": 414,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Daemon_set_status.t` values, representing a collection of daemon set statuses. It provides functions to convert this structure to and from JSON format using `Yojson.Safe.t`. This is used to serialize and deserialize groups of daemon set status objects, typically for storage or transmission in a Kubernetes environment.",
      "description_length": 386,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a daemon set specification. It provides functions to convert this list to and from JSON format. It is used to manage and serialize daemon set configurations in Kubernetes.",
      "description_length": 240,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes Event objects grouped by namespace, providing functions to convert the structure to and from JSON format. It works with a list of tuples, where each tuple consists of a namespace string and an Event_list value. This module is used when handling multi-namespace event data, such as aggregating and serializing events for output or transmission.",
      "description_length": 393,
      "index": 306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job.Object",
      "library": "kubecaml",
      "description": "This module defines a list of cron job configurations paired with their metadata names, supporting JSON serialization and deserialization. It works with cron job objects structured as key-value pairs, where each value conforms to the v2alpha1 cron job specification. Concrete use cases include reading and writing cron job definitions to and from JSON, such as when interacting with Kubernetes API endpoints or processing configuration files.",
      "description_length": 442,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review_spec.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of access review specifications for Kubernetes authorization requests. It works with associative lists mapping strings to access review spec objects, supporting JSON conversion via Yojson. Concrete use cases include processing and validating subject access requests in Kubernetes API interactions.",
      "description_length": 351,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Namespaces.By_namespace.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module manages Horizontal Pod Autoscaler resources in a Kubernetes namespace, handling HTTP requests to list, create, and delete autoscalers using the Kubernetes API. It works directly with `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list` data types, supporting full lifecycle operations like retrieval, replacement, and partial updates via REST methods such as GET, PUT, and PATCH. The status submodule extends this functionality by enabling direct manipulation of autoscaler status fields through dedicated `get`, `put`, and `patch` operations. Examples include programmatically scaling deployments based on metrics and adjusting autoscaling configurations dynamically in response to cluster load.",
      "description_length": 720,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_source.Object",
      "library": "kubecaml",
      "description": "This module represents structured data for Kubernetes event sources, specifically mapping string keys to event source definitions. It provides serialization and deserialization functions to and from JSON format, enabling direct interaction with Kubernetes API payloads. Use this module to process or construct event source information within Kubernetes events, such as identifying the origin of an event within a cluster.",
      "description_length": 421,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Volume_attachment_spec objects into JSON format. It works with a list of tuples containing strings and Volume_attachment_spec records. Use this module when converting volume attachment specifications to and from JSON for API communication or configuration storage.",
      "description_length": 325,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Deployments in the Kubernetes API, where each Deployment is paired with a string identifier. It provides functions to convert this list to and from JSON format using the `to_yojson` and `of_yojson` functions. This structure is used when managing multiple Deployments in apps/v1beta2, particularly during configuration or serialization tasks.",
      "description_length": 374,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module provides functions to convert Role_binding_list objects to and from JSON format. It operates on a list of key-value pairs where each value is a Role_binding_list. Use this module when serializing or deserializing Role_binding_list data for API communication or storage.",
      "description_length": 281,
      "index": 313,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Subject.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of RBAC subject objects to and from JSON, specifically for role bindings targeting direct API object references. It operates on a list of tuples pairing strings with subject definitions, aligning with Kubernetes RBAC structures. It is used when managing role bindings that apply to specific Kubernetes resources like service accounts or nodes.",
      "description_length": 397,
      "index": 314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Host_port_range.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of host port range configurations into JSON format. It works with a list of tuples, where each tuple contains a string key and a host port range value. It is used to define and manage allowed host port ranges in Kubernetes network policies.",
      "description_length": 298,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes scale status objects into JSON format. It works with a list of key-value pairs where each value is a scale status, using `Yojson.Safe.t` for JSON representation. It is used to convert scale status data to and from JSON for API interactions or storage.",
      "description_length": 323,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each value is a `Replica_set_condition.t`, used to track the state of replica sets in Kubernetes. It provides functions to convert the collection to and from JSON format using `Yojson.Safe.t`. This structure is useful for serializing and deserializing replica set conditions when interacting with Kubernetes APIs or storing cluster state.",
      "description_length": 399,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of persistent volume claim objects to and from JSON format. It works with a list of tuples, where each tuple consists of a string and a persistent volume claim structure. Concrete use cases include converting Kubernetes persistent volume claim list data for storage or transmission, and parsing such data from JSON input.",
      "description_length": 389,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Pod_disruption_budget_spec.t`, and it provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used to model structured collections of pod disruption budget specifications, typically for configuration or API interaction. A concrete use case includes parsing and generating Kubernetes policy definitions in JSON format for cluster management.",
      "description_length": 457,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of cron job status objects into JSON format. It works with a list of key-value pairs where each value is a cron job status. It is used to convert cron job status data to and from JSON representations for storage or transmission.",
      "description_length": 286,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Events",
      "library": "kubecaml",
      "description": "This module monitors Event resources in a specific Kubernetes namespace, streaming updates in real time with support for label and field selectors, resource version control, and timeouts. It provides a `get` function to retrieve and filter events, enabling use cases like tracking pod creation or failure events as they occur. The child module extends this functionality by allowing fine-grained monitoring of events tied to a specific resource name, enhancing precision when observing lifecycle changes. Together, they enable detailed, real-time observation of Kubernetes event streams with customizable filtering and watch behavior.",
      "description_length": 634,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Namespaces.By_namespace.Localsubjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles creation of LocalSubjectAccessReview resources within a specific Kubernetes namespace. It provides a `post` function to submit access review requests and a `request_path_template` for path generation. The module works directly with Kubernetes authorization v1 LocalSubjectAccessReview definitions, targeting namespace-scoped access control evaluations.",
      "description_length": 372,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Scale_status.t` record, representing the current state of scalable Kubernetes resources. It provides functions to serialize and deserialize this list structure to and from JSON format using `Yojson.Safe`. This is used to handle the status of scale subresources in Kubernetes API responses, particularly for versioned API definitions.",
      "description_length": 402,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_list.Object",
      "library": "kubecaml",
      "description": "This module handles JSON serialization and deserialization for a list of volume attachment objects, where each entry pairs a string identifier with a volume attachment structure. It operates on the `t` type, which is a list of tuples containing a string and a volume attachment definition. Use this module when converting volume attachment collections to or from JSON representations, such as during API communication or configuration file parsing.",
      "description_length": 448,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Cross_version_object_reference.Object",
      "library": "kubecaml",
      "description": "This module defines and serializes cross-version object references for Kubernetes autoscaling, specifically targeting the V2beta1 API version. It works with tuples of strings and structured reference types to map Kubernetes resource identifiers to their API versions. It supports direct conversion to and from JSON, enabling seamless integration with Kubernetes API clients and configuration tools.",
      "description_length": 398,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1.Watch.Priorityclasses.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to Kubernetes PriorityClass objects by name, providing a `get` function to stream events for specific instances. It uses standard Kubernetes API query parameters like `resource_version`, `timeout_seconds`, and `watch` to control observation behavior. Concrete use cases include monitoring priority class updates in real-time for dynamic scheduling adjustments or cluster state tracking.",
      "description_length": 414,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Controller_revision.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Controller_revision objects, which are used to represent immutable snapshots of state data for Kubernetes controllers like Daemon_set and Stateful_set. It operates on a list of tuples, each containing a string and a Controller_revision value. Concrete use cases include converting Controller_revision data to and from JSON format for storage or transmission, specifically supporting Kubernetes API interactions where state snapshots must be created once and not modified.",
      "description_length": 532,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_spec.Object",
      "library": "kubecaml",
      "description": "This module represents the object structure of a Horizontal Pod Autoscaler specification in Kubernetes's Autoscaling API. It provides functions to convert the specification to and from JSON format, specifically using the Yojson library for serialization and deserialization. The module works with a list of key-value pairs where each value is a Horizontal_pod_autoscaler_spec.t, enabling precise modeling of autoscaler configurations.",
      "description_length": 434,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Deployment objects into Yojson format. It works with a list of tuples, each containing a string and a Deployment_list structure, representing multiple Deployments. It is used to convert Deployment data to and from JSON for storage or transmission, such as when interacting with Kubernetes API endpoints or generating configuration files.",
      "description_length": 419,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_binding.Object",
      "library": "kubecaml",
      "description": "This module defines a list of tuples mapping string identifiers to Role_binding values, enabling structured representation of role bindings within a namespace. It provides JSON serialization and deserialization functions for handling role binding configurations in API interactions. This structure is used to manage access control policies by associating roles or cluster roles with subjects in specific namespaces.",
      "description_length": 415,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Replica_set object, used to manage groups of identical pods in a Kubernetes cluster. It provides serialization and deserialization functions to and from JSON format, enabling integration with Kubernetes API operations. This structure is essential for handling multiple Replica_set resources in bulk operations or configurations.",
      "description_length": 396,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each key is a string and the value is a `Deployment_condition.t` type, used to capture the state of a Kubernetes deployment. It provides functions `to_yojson` and `of_yojson` for converting this collection to and from JSON format, specifically using the `Yojson.Safe.t` type. This is useful when serializing or deserializing deployment condition data for API interactions or storage.",
      "description_length": 444,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes daemon sets as key-value pairs, where each key is a string identifier and each value is a daemon set definition. It provides functions to convert the list to and from JSON format using Yojson. This structure is used to manage and serialize collections of daemon set objects in Kubernetes API interactions.",
      "description_length": 349,
      "index": 333,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of StatefulSet objects in Kubernetes API version v1beta2. It provides functions to convert the list to and from JSON format using Yojson, enabling serialization and deserialization for storage or transmission. The primary use case is handling collections of StatefulSet resources when interacting with Kubernetes clusters or processing configuration files.",
      "description_length": 386,
      "index": 334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Resource_metric_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes resource metric source objects to and from JSON. It works with a list of key-value pairs where each value is a resource metric source definition. It is used to configure horizontal pod autoscalers based on built-in Kubernetes resource metrics like CPU or memory usage.",
      "description_length": 336,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a deployment condition, providing functions to serialize and deserialize this list to and from JSON. It works with string keys and deployment condition values, specifically capturing details like the status and reason for each condition. It is used to track and persist the state transitions of a deployment, such as when a deployment becomes available or encounters an error.",
      "description_length": 445,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of subject access review status objects into JSON format. It works with a list of tuples, where each tuple contains a string key and a subject access review status value. This module is used to convert access review data to and from JSON for transmission or storage, specifically within Kubernetes authorization workflows.",
      "description_length": 380,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of subject access review objects to and from JSON. It works with lists of tuples containing strings and subject access review data structures. It is used to convert authorization review data for API requests into a format suitable for transmission or storage.",
      "description_length": 313,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of cron job status data in Kubernetes API batch v1beta1. It works with associative lists mapping strings to cron job status values. Use this module when converting cron job status objects to and from JSON representations, such as during API communication or configuration parsing.",
      "description_length": 338,
      "index": 339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_projection.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to downward API projection values, enabling precise configuration of projected volumes in Kubernetes. It provides JSON serialization and deserialization functions for handling these mappings in API interactions. Useful for constructing and validating volume projections that expose pod and container fields to mounted volumes.",
      "description_length": 389,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_dns_config.Object",
      "library": "kubecaml",
      "description": "This module represents DNS configuration settings for Kubernetes pods, specifically handling the parsing and serialization of DNS-related fields. It operates on a list of tuples pairing strings with `Pod_dns_config.t` values, corresponding to pod DNS settings beyond the base policy. Concrete use cases include converting DNS configurations to and from JSON format for deployment or inspection tools.",
      "description_length": 400,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_file_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Azure File Service volume source configurations in Kubernetes. It works with a list of string and Azure_file_persistent_volume_source records to represent volume parameters. Concrete use cases include converting Azure file volume definitions to and from JSON for deployment configuration and API communication.",
      "description_length": 371,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Supplemental_groups_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of supplemental group strategy options in Kubernetes policy definitions. It works with a list of tuples, where each tuple contains a string key and a corresponding strategy option value. Concrete use cases include converting policy configurations to and from JSON format for storage or transmission.",
      "description_length": 357,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named scaling requests for Kubernetes resources, specifically working with lists of string-annotated Scale values. It provides direct serialization and deserialization to and from JSON using Yojson, ensuring structured handling of scaling configurations. Concrete use cases include processing and persisting scaling state in Kubernetes deployment workflows.",
      "description_length": 396,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and the value represents the status of a persistent volume claim. It provides functions to convert this structure to and from JSON format using `to_yojson` and `of_yojson`. This is used to serialize and deserialize the status information of Kubernetes persistent volume claims for storage or transmission.",
      "description_length": 378,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_running.Object",
      "library": "kubecaml",
      "description": "This module represents the running state of a container as a list of key-value pairs, where each pair consists of a string and a corresponding `Container_state_running.t` value. It provides functions to convert this structured data to and from JSON format using `Yojson.Safe.t`. This module is used to serialize and deserialize container runtime metadata, such as start times or status flags, for use in Kubernetes API interactions.",
      "description_length": 432,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Host_port_range.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of key-value pairs, where each value is a host port range definition. It provides `to_yojson` and `of_yojson` functions to convert between JSON representations and OCaml values. Use this module when working with Kubernetes extension v1beta1 policies that specify allowed host port ranges in JSON format.",
      "description_length": 371,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes daemon set resources within a namespace, supporting full lifecycle operations such as listing, creating, and deleting daemon sets based on label and field selectors. It exposes HTTP methods like `get`, `put`, `delete`, and `patch` for manipulating daemon set definitions and includes a submodule dedicated to status updates, allowing precise control over observed state reporting. Key data types include DaemonSet specifications, JSON patch payloads, and deletion options, enabling tasks like deploying system-level pods across nodes or synchronizing status updates after configuration changes. Example operations include fetching a daemon set's current spec, applying a rolling update via patch, or removing outdated daemon sets based on selector criteria.",
      "description_length": 788,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to `Persistent_volume_claim_spec` values, enabling structured association of storage configuration attributes. It provides `to_yojson` and `of_yojson` functions for converting these mappings to and from JSON format, ensuring compatibility with Kubernetes API serialization requirements. It is used to define and manipulate storage claims with provider-specific configurations in Kubernetes deployments.",
      "description_length": 467,
      "index": 349,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_mount.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of volume mounts, where each mount is a tuple of a string key and a volume mount configuration. It provides functions to serialize and deserialize this collection to and from JSON format. This structure is used to define how volumes are mounted into containers within a Kubernetes pod specification.",
      "description_length": 335,
      "index": 350,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Mutating_webhook_configuration_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of mutating webhook configurations, represented as a list of key-value pairs where each value is a `Mutating_webhook_configuration_list.t`. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON format. This is used when interacting with Kubernetes API endpoints that require or return lists of mutating webhook configurations in JSON.",
      "description_length": 445,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Network_policy objects, where each entry is a tuple of a string and a Network_policy structure. It provides `to_yojson` and `of_yojson` functions to convert between JSON representations and the internal OCaml data structure. It is used when interacting with Kubernetes API endpoints that return or expect a collection of network policies, such as retrieving or updating multiple network policies in a single API call.",
      "description_length": 488,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Deployment_status, providing functions to convert the list to and from JSON format. It works with string keys and Deployment_status values to capture additional properties of a Deployment's status. This structure is used to encode extended or custom status information in a Kubernetes Deployment object.",
      "description_length": 374,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Watch.Validatingwebhookconfigurations.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving ValidatingWebhookConfiguration resources by name in Kubernetes's admissionregistration v1beta1 API. It provides a `get` function to stream changes to a specific ValidatingWebhookConfiguration object using watch semantics, accepting parameters like name, resource version, and timeout. Uses Cohttp for HTTP transport and handles responses as Watch_event results.",
      "description_length": 396,
      "index": 354,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes services indexed by namespace, providing serialization and deserialization to and from JSON format. It works with a list of tuples where each tuple pairs a namespace string with a `Service_list.t` value. Concrete use cases include handling service data retrieved from a Kubernetes cluster and preparing it for storage or transmission in JSON format.",
      "description_length": 399,
      "index": 355,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Namespaces.By_namespace.Cronjobs",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CronJob resources within a namespace through HTTP operations, supporting list, create, and delete actions on CronJob and CronJobList data types. It enables filtering job lists, submitting new job definitions, and removing existing jobs, while the child module adds fine-grained manipulation via replace, partial update, and status-modification capabilities. The status submodule specifically handles execution state updates using full replacements or strategic patches on `Cron_job.t` and `Patch.t` types. Together, they provide a complete interface for managing CronJob lifecycle and runtime status through targeted API interactions.",
      "description_length": 665,
      "index": 356,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_error.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each key is a string and each value is a `Volume_error` type, used to capture errors from volume operations. It provides functions `to_yojson` and `of_yojson` for converting this list-based structure to and from JSON format. This module is useful when handling and serializing multiple volume-related errors in Kubernetes storage operations.",
      "description_length": 402,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time tracking of Kubernetes RBAC resources within a namespace, focusing on Role and RoleBinding changes. It offers `get` functions to stream events with filters like label or field selectors, resource versions, and timeouts, enabling precise monitoring of access control updates. The module supports detailed observation of individual RoleBinding objects and customizable watch parameters for dynamic tracking. Examples include auditing permission changes, synchronizing role definitions, and monitoring RBAC policy updates across a cluster.",
      "description_length": 567,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Deployment_condition.t` type, capturing the state of a deployment at specific points. It provides functions `to_yojson` and `of_yojson` to serialize and deserialize this list structure to and from JSON format. It is used when managing or inspecting the conditions of Kubernetes deployments, such as tracking deployment progress or health status.",
      "description_length": 417,
      "index": 359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Webhook_client_config.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of webhook client configuration objects used for establishing TLS connections with Kubernetes admission webhooks. It works with a list of tuples, where each tuple pairs a string key with a webhook client configuration value. Concrete use cases include converting webhook configurations to and from JSON format for storage or transmission during Kubernetes API interactions.",
      "description_length": 431,
      "index": 360,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module monitors PodPreset resources in real time, enabling label and field filtering, version control, and pagination. It tracks changes to environment variables and volume mounts across namespaces, supporting dynamic configuration updates. You can watch individual PodPreset objects, apply limits and continuation tokens for efficient querying, and manage configurations at scale in Kubernetes clusters.",
      "description_length": 409,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod Security Policy objects into JSON format. It works with a list of tuples, each containing a string and a Pod Security Policy definition. It is used to convert Pod Security Policy data to and from JSON representations, specifically for handling Kubernetes API requests and responses.",
      "description_length": 347,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Apiservices.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides a `put` function to update the status of a specific Kubernetes API service by name, using a fully defined `Api_service.t` object. It requires the name of the service and constructs the appropriate request path internally. A common use case is updating the observed state of an API service after a configuration change or health check.",
      "description_length": 355,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_projection.Object",
      "library": "kubecaml",
      "description": "Handles the conversion of secret projection objects to and from JSON format. Works with lists of tuples containing strings and secret projection values. Used to serialize and deserialize Kubernetes secret projections for use in configuration files or API interactions.",
      "description_length": 268,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module observes RBAC changes in Kubernetes namespaces by tracking Role and RoleBinding resources with real-time event streams. It supports filtering with label and field selectors, resource versioning, and timeouts through `get` functions that allow dynamic monitoring of both broad and specific authorization policy updates. You can use it to react to role or role binding changes, such as detecting new bindings or revoked permissions, as they happen in a namespace.",
      "description_length": 473,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions.V1beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive toolkit for defining, validating, and serializing Kubernetes Custom Resource Definitions (CRDs) and related API structures. It centers on data types such as JSON schemas, validation rules, subresource configurations (like scale and status), and CRD metadata, offering operations to construct, inspect, and convert these structures to and from JSON using `Yojson`. You can define complex validation logic with schema-or-list types, configure autoscaling behavior via JSON paths, track CRD status conditions, and manage custom resource naming conventions. Example uses include serializing CRDs for cluster registration, validating custom resource schemas against OpenAPI rules, and configuring status and scale subresources for Kubernetes API extensions.",
      "description_length": 789,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of StatefulSet update strategy objects to and from JSON format. It works with a list of key-value pairs where each value is a Stateful_set_update_strategy.t. This module is used when interacting with Kubernetes APIs to apply or retrieve update strategies for StatefulSets.",
      "description_length": 330,
      "index": 367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes service status objects to and from JSON format. It operates on a list of tuples, where each tuple consists of a string key and a service status value. It is used to convert service status data for storage, transmission, or inspection in JSON format, such as when interacting with Kubernetes APIs or logging service states.",
      "description_length": 394,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Iscsi_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is an `Iscsi_volume_source` configuration. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. This structure is used to represent multiple named iSCSI volume sources in Kubernetes pod specifications.",
      "description_length": 311,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review_spec.Object",
      "library": "kubecaml",
      "description": "This module represents the object structure for authorization attributes in a subject access review request. It works with key-value pairs mapping strings to authorization specification types, supporting JSON serialization and deserialization. It is used to define and process access control requests in Kubernetes API authorization workflows.",
      "description_length": 343,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service.Object",
      "library": "kubecaml",
      "description": "This module defines a list of named Kubernetes Service objects, each consisting of a string identifier and a Service definition. It provides functions to convert this list to and from JSON format using the Yojson library. This structure is used to manage multiple named services in configurations or API responses where each service requires a distinct identifier.",
      "description_length": 364,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1.Storage_class.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of storage class objects to and from JSON format. It works with a list of key-value pairs where each value represents a storage class configuration. Use this module when converting storage class definitions to JSON for API requests or when parsing JSON responses into structured storage class data.",
      "description_length": 356,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_rules_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of a list of subject rule review statuses, where each entry pairs a string identifier with a `Subject_rules_review_status.t` value. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. This is used to interface with Kubernetes authorization APIs that return rule evaluation results, enabling inspection of permissions granted to subjects.",
      "description_length": 439,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Ingress rules, where each rule maps a string identifier to an Ingress configuration. It provides functions to convert this list to and from JSON format using Yojson, enabling serialization and deserialization for storage or transmission. This structure is used when defining or parsing Ingress resources that expose services externally with routing rules.",
      "description_length": 399,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of volume attachment objects to and from JSON format. It works with a list of string and volume attachment pairs, enabling direct conversion to and from Yojson representations. Concrete use cases include persisting volume attachment state to disk or transmitting it over a network.",
      "description_length": 335,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Fs_group_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an Fs_group_strategy_options object, used to define filesystem group strategy configurations. It provides functions to convert the list to and from JSON format using Yojson. This structure is typically used when configuring Kubernetes pod security policies to specify how filesystem groups are assigned to containers.",
      "description_length": 386,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Pods",
      "library": "kubecaml",
      "description": "This module watches for changes to Pod resources within a namespace, supporting filters by label and field selectors, and control over resource version and watch duration. It enables real-time monitoring of Pod events for operational visibility or automated responses, with a `get` function that establishes a watch stream on a specific Pod by name. The combined interface allows tracking of both individual Pod updates and broader namespace-level Pod events, returning structured results with `Watch_event` data for inspection or reaction. Example usage includes detecting Pod status transitions or configuration updates as they occur in the cluster.",
      "description_length": 651,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_status.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of node status entries in a Kubernetes cluster, where each entry maps a node identifier to its corresponding status information. It provides functions to serialize and deserialize this collection to and from JSON format using `Yojson`. This structure is used to retrieve and process the current state of nodes within a cluster, such as checking node availability or health.",
      "description_length": 409,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each key is a string and each value is a Daemon_set_condition, capturing the state of a DaemonSet. It provides functions to convert this collection to and from JSON format. This is used to serialize and deserialize DaemonSet condition data for storage or transmission.",
      "description_length": 329,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of persistent volume objects to and from JSON format. It works with a list of key-value pairs where each value is a persistent volume definition. It is used to convert persistent volume data to a JSON representation for storage or transmission, and to parse such data from JSON input.",
      "description_length": 342,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Id_range.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named ID ranges, where each entry maps a string identifier to an ID range with minimum and maximum values. It provides functions to serialize and deserialize this collection to and from JSON format. It is used to define constraints on allowable ID ranges for entities like users or groups in policy configurations.",
      "description_length": 353,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Local_subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of local subject access review objects to and from JSON. It works with lists of tuples containing strings and access review objects. It is used to convert access review data to a format suitable for storage or transmission, and to parse such data back into structured form for evaluation.",
      "description_length": 342,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module enables real-time tracking and inspection of Kubernetes RBAC resources within a namespace, focusing on Role and RoleBinding changes as they happen. It provides `get` and `watch` operations with support for label and field filtering, resource versions, timeouts, and pagination. These capabilities allow for dynamic access control, security auditing, and synchronization of role-based permissions. For example, it can monitor RBAC updates in a multi-tenant cluster or stream role changes for audit logging.",
      "description_length": 517,
      "index": 383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_var_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of environment variable sources in Kubernetes API v1 objects. It works with associative lists mapping strings to `Env_var_source.t` values. Use this module when converting environment variable configurations to and from JSON format for deployment or configuration management.",
      "description_length": 333,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job.Object",
      "library": "kubecaml",
      "description": "This module defines a list of cron job configurations, where each entry is a tuple consisting of a string identifier and a cron job specification. It provides functions to serialize and deserialize these configurations to and from JSON format. This structure is used to manage multiple named cron jobs within a Kubernetes batch API context.",
      "description_length": 340,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rolling_update_deployment.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of rolling update deployment configurations to and from JSON. It works with a list of key-value pairs where each value is a rolling update deployment specification. It is used to convert between in-memory representations and JSON formats for storage or transmission.",
      "description_length": 320,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rolling_update_deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Rolling_update_deployment.t` structure, used to define rolling update strategies for Kubernetes deployments. It provides `to_yojson` and `of_yojson` functions for serializing and deserializing these structures to and from JSON. This is specifically used when configuring deployment update policies in Kubernetes API interactions.",
      "description_length": 401,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_spec.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to `Cron_job_spec` values, representing named configurations for job execution schedules. It provides `to_yojson` and `of_yojson` functions for converting these configurations to and from JSON format. This is used to serialize and deserialize named cron job specifications, typically for storage or transmission in Kubernetes API interactions.",
      "description_length": 405,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of replication controller configurations to and from JSON format. It works with a list of tuples, where each tuple consists of a string identifier and a replication controller configuration. Concrete use cases include converting replication controller data for storage, transmission, or further processing in JSON-based workflows.",
      "description_length": 388,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure where each element is a tuple of a string and a node selector, enabling the representation of node selection criteria as a collection of label queries. It provides functions to convert this structure to and from JSON format, specifically using the Yojson library. This is used to serialize and deserialize node selector terms for Kubernetes scheduling policies.",
      "description_length": 404,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Scale_status.t` values, representing the current state of scalable Kubernetes resources. It provides JSON serialization and deserialization functions for interacting with Kubernetes API responses. This structure is used when retrieving or updating the observed number of replicas and their statuses for deployments or replica sets.",
      "description_length": 398,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of key-value pairs, where each value is a `Self_subject_access_review.t`, to and from JSON format. It provides `to_yojson` and `of_yojson` functions for converting data to and from `Yojson.Safe.t` representation. This is used when interacting with Kubernetes' authorization API to process access review responses in JSON format.",
      "description_length": 396,
      "index": 392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Horizontal_pod_autoscaler_condition, used to track the state of horizontal pod autoscalers in Kubernetes. It provides functions to convert this list to and from JSON format using Yojson. This structure is useful when managing or inspecting the conditions affecting autoscaling behavior in a Kubernetes cluster.",
      "description_length": 381,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of role bindings in the Kubernetes RBAC API, where each entry is a tuple of a string and a role binding structure. It provides functions to convert this list to and from JSON format using Yojson. This module is used to serialize and deserialize collections of role bindings for storage or transmission in Kubernetes configurations.",
      "description_length": 361,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Watch.Customresourcedefinitions.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Custom Resource Definition by name. It provides a `get` function to stream events for a named CRD, using parameters like resource version, label selector, and timeout. The function returns a result with a watch event or an error, suitable for monitoring CRD lifecycle changes in real time.",
      "description_length": 342,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module defines a list of role bindings in the Kubernetes RBAC v1beta1 API, represented as an associative list mapping strings to role binding values. It provides functions to convert this structure to and from JSON using the `Yojson.Safe` format. This is used to serialize and deserialize role binding lists for API communication or storage.",
      "description_length": 346,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Configmaps.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ConfigMaps within a specific namespace. It provides functions to get, put, delete, and patch ConfigMap resources using HTTP requests with customizable headers and contexts. The module works directly with Kubernetes API objects like `Config_map.t` and `Delete_options.t`, targeting concrete resource management scenarios in cluster configuration.",
      "description_length": 399,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each value is a `Replica_set_condition.t`, encoding the state of a Kubernetes replica set. It provides `to_yojson` and `of_yojson` functions for converting the collection to and from JSON format. Use this module when serializing or deserializing replica set condition data for API interactions or storage.",
      "description_length": 366,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_ingress_rule.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of network policy ingress rule objects to and from JSON format. It works with lists of string-annotated network policy ingress rule values, supporting structured data exchange for policy definitions. Concrete use cases include reading and writing ingress rule configurations in Kubernetes API interactions, specifically for deprecated extensions/v1beta1 network policies.",
      "description_length": 425,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Replica_set objects into JSON format. It works with a list of tuples, where each tuple consists of a string and a Replica_set_list type. Concrete use cases include converting Replica_set data for API communication and persisting Replica_set configurations in JSON format.",
      "description_length": 342,
      "index": 400,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_peer.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of network policy peer objects to and from JSON format. It works with a list of key-value pairs where each value is a network policy peer definition. It is used when configuring Kubernetes network policies to specify allowed traffic sources in a structured and JSON-compatible way.",
      "description_length": 335,
      "index": 401,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Replicationcontrollers.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ReplicationControllers in a specific namespace, offering `get`, `put`, `delete`, and `patch` operations to manipulate their state via the Kubernetes API using Cohttp. It supports standard API parameters like `pretty`, `ctx`, and `headers`, enabling tasks such as fetching configurations or updating replica counts. A child module focuses on scale operations, allowing retrieval, replacement, and partial updates of scaling information using dedicated scale and patch types. Another child module provides status-specific functions, enabling direct manipulation of replication controller statuses through HTTP-based get, put, and patch operations.",
      "description_length": 676,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_dns_config_option.Object",
      "library": "kubecaml",
      "description": "This module represents DNS resolver options for Kubernetes pods, specifically mapping string keys to DNS configuration option values. It provides serialization and deserialization functions to and from JSON using `to_yojson` and `of_yojson`. This structure is used when configuring custom DNS settings for a pod, such as specifying DNS servers, search domains, or resolver options like timeout and attempts.",
      "description_length": 407,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Glusterfs_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Glusterfs volume source objects to and from JSON format. It works with a list of tuples, each containing a string and a Glusterfs_volume_source.t record. It is used to convert Glusterfs volume configurations to JSON for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 355,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod Security Policy Spec objects to and from JSON format. It works with associative lists mapping strings to Pod Security Policy Spec values. It is used when interacting with Kubernetes API endpoints that require converting policy specs to JSON for transmission or parsing received JSON responses into structured policy data.",
      "description_length": 386,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of Config_map volume source data to and from JSON format. It operates on a list of tuples pairing strings with Config_map volume source definitions. Concrete use cases include serializing and deserializing volume configurations for Kubernetes pods that reference Config_map data as files.",
      "description_length": 323,
      "index": 406,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Resourcequotas",
      "library": "kubecaml",
      "description": "This module monitors changes to ResourceQuota objects in a namespace, offering real-time tracking of quota usage with support for label and field selectors, timeout controls, and resource versioning. It provides a `get` function to establish a watch stream on a specific quota, enabling dynamic enforcement of resource constraints based on live usage data. You can use it to observe quota updates in a production environment, reacting to changes as they occur. The combination of broad namespace monitoring and targeted quota observation allows for both system-wide and specific resource management strategies.",
      "description_length": 610,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes resources within a specific namespace, supporting label and field selectors, pagination, timeouts, and resource version control. It offers typed watches for Ingress, Deployment, ReplicaSet, NetworkPolicy, and DaemonSet resources, enabling precise tracking of changes such as rollouts, scaling events, and configuration updates. Each resource type includes operations to watch all matching instances or focus on specific named resources, with data types like watch events, selectors, and continuation tokens. Example uses include triggering service mesh reloads on Ingress changes, autoscaling based on ReplicaSet updates, or validating DaemonSet rollouts in real time.",
      "description_length": 724,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes scaling request objects to and from JSON format. It works with a list of key-value pairs where each value is a scaling request definition. It is used to convert scaling specifications to JSON for storage or transmission, and to parse such specifications from JSON input.",
      "description_length": 338,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and each value is a `Replica_set_status` type, representing metadata associated with a Replica_set's status. It provides functions `to_yojson` and `of_yojson` for converting this structured data to and from JSON format. This is used to serialize and deserialize Replica_set status objects for storage or transmission, such as when interacting with Kubernetes API endpoints or persisting state information.",
      "description_length": 478,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_binding.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes RBAC ClusterRoleBinding objects to and from JSON. It works with a list of tuples pairing strings with ClusterRoleBinding records. Concrete use cases include converting ClusterRoleBinding data for storage, transmission, or interaction with external systems requiring JSON format.",
      "description_length": 350,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to deployment strategy configurations, used to define how Kubernetes replaces pods during deployments. It provides serialization and deserialization functions to and from JSON using Yojson, ensuring compatibility with Kubernetes API specifications. It is specifically used when configuring deployment strategies in Kubernetes manifests, such as specifying rolling update parameters.",
      "description_length": 447,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Stateful_set_spec, enabling structured configuration of stateful sets in Kubernetes. It provides functions to convert this list to and from JSON format, facilitating integration with Kubernetes APIs. Concrete use cases include defining and serializing stateful set specifications for deployment or inspection.",
      "description_length": 380,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Util.Intstr.Int_or_string",
      "library": "kubecaml",
      "description": "This module represents values that can be either integers or strings, commonly used in Kubernetes API definitions where fields like container ports or resource limits may be specified numerically or as named strings. It provides a `make` function to construct these values from strings, along with JSON serialization and deserialization through `to_yojson` and `of_yojson`. The child module extends this functionality to handle lists of key-value pairs with `Int_or_string` values, enabling structured encoding and decoding of Kubernetes objects such as selector rules or annotations. Example uses include parsing container port configurations and converting resource constraints to JSON for API requests.",
      "description_length": 705,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_binding.Object",
      "library": "kubecaml",
      "description": "This module represents a list of cluster role bindings, where each binding associates a subject (such as a user or group) with a cluster role reference. It provides functions to serialize and deserialize these bindings to and from JSON format using Yojson. This structure is used to define role-based access control policies at the cluster level in Kubernetes.",
      "description_length": 360,
      "index": 415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_ref.Object",
      "library": "kubecaml",
      "description": "This module represents Kubernetes RBAC role references as associative lists mapping strings to role reference configurations. It provides JSON serialization and deserialization for these role reference objects. Use this module to manage and convert RBAC role reference data structures when interacting with Kubernetes API resources.",
      "description_length": 332,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a StatefulSet specification. It provides functions to convert the list to and from JSON format. This module is used to manage collections of StatefulSet configurations, such as when handling multiple StatefulSets in a single file or API response.",
      "description_length": 315,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rollback_config.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of key-value pairs, where each value is a `Rollback_config.t`, to and from JSON format. It provides `to_yojson` and `of_yojson` functions for converting this list structure to and from `Yojson.Safe.t` representations. This is used when working with Kubernetes API objects that require structured configuration data to be encoded or decoded in JSON, particularly for handling rollback configurations in deployments.",
      "description_length": 482,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_port.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of network policy port objects into JSON format. It works with a list of tuples, each containing a string and a network policy port definition. It is used to convert network policy port data to and from JSON representations for API interactions.",
      "description_length": 303,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_status.Object",
      "library": "kubecaml",
      "description": "This module represents the observed status of a Kubernetes Deployment as a list of key-value pairs, where each value is a Deployment_status type. It provides functions to convert this structure to and from JSON format using Yojson. This module is used to serialize and deserialize Deployment status information for storage or transmission.",
      "description_length": 339,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module provides Kubernetes API operations for managing ControllerRevision resources within a namespace, including listing, creating, and deleting revisions using types like `Controller_revision` and `Controller_revision_list`. It supports standard query parameters such as `label_selector` and `resource_version` for filtering and synchronization. The child module extends this functionality with `get`, `put`, `delete`, and `patch` operations on individual ControllerRevision objects, enabling precise control over stateful application rollouts. Together, they allow tasks like retrieving specific revisions, applying updates, or rolling back to previous states using the Kubernetes Apps V1 API.",
      "description_length": 701,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_status.Object",
      "library": "kubecaml",
      "description": "This module represents the status of a horizontal pod autoscaler as a list of key-value pairs, where each value is an instance of the horizontal pod autoscaler status type. It provides functions to serialize and deserialize this structure to and from JSON using `Yojson`. This is used to interface with Kubernetes API endpoints that return or expect the status of autoscalers in a JSON format.",
      "description_length": 393,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_daemon_set.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a rolling update specification for daemon sets in Kubernetes. It provides functions to convert this list to and from JSON format using the Yojson library. This data structure is used when configuring or serializing daemon set update strategies in Kubernetes API interactions.",
      "description_length": 344,
      "index": 423,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes ClusterRole resources by name. It provides a `get` function to establish a watch stream with options like timeout, resource version, and label selectors, returning a result with a watch event or error. Use it to monitor real-time updates to specific ClusterRoles in a cluster.",
      "description_length": 322,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a deployment strategy, providing functions to convert the list to and from JSON format. It works with lists of tuples containing strings and deployment strategy types. This module is used to serialize and deserialize deployment strategy configurations for Kubernetes deployments.",
      "description_length": 348,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Photon_persistent_disk_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Photon Controller persistent disk volume source objects to and from JSON format. It works with a list-based structure pairing string keys with Photon persistent disk volume source configurations. It is used to convert between in-memory representations and JSON payloads when interacting with Kubernetes APIs or storing configuration data.",
      "description_length": 395,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Nodes.By_name.Proxy.By_path",
      "library": "kubecaml",
      "description": "This module implements direct HTTP proxying operations to Kubernetes nodes by name and path. It supports standard HTTP methods (GET, PUT, POST, DELETE, OPTIONS, HEAD, PATCH) for interacting with node-level endpoints through a proxy. The module works with raw strings for paths and node names, producing Cohttp requests that return string-based result values. Concrete use cases include proxying API requests to specific Kubernetes nodes for diagnostics, configuration updates, or low-level resource management.",
      "description_length": 510,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod Security Policy objects into JSON format. It works with a list of tuples, each containing a string and a Pod Security Policy definition. It is used to convert policy configurations to and from JSON for storage or transmission.",
      "description_length": 291,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_access_review_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Self_subject_access_review_spec` type, used to define authorization requests in Kubernetes. It provides functions to convert this list structure to and from JSON format using `to_yojson` and `of_yojson`. This structure is typically used to bundle multiple access review specifications under distinct keys for API communication.",
      "description_length": 399,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of subject access review status objects to and from JSON. It works with lists of string and subject access review status type pairs. Use this module when interacting with Kubernetes API endpoints that require or return subject access review status data in JSON format.",
      "description_length": 322,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module provides HTTP-based operations for managing Kubernetes StatefulSets within a namespace, supporting creation, deletion, and listing of stateful workloads such as database clusters. It works with core types like `Stateful_set.t`, `Stateful_set_list.t`, and `Status.t`, using Cohttp for communication with the Kubernetes API server. The status submodule enables retrieval and patching of StatefulSet status fields, useful for checking rollout progress, while the scale submodule allows dynamic adjustment of replica counts through the Autoscaling/v1 API. Example operations include listing all StatefulSets in a namespace, scaling a StatefulSet to a desired number of replicas, or deleting all StatefulSets to clean up stateful resources.",
      "description_length": 747,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Scale_spec.t` record, used to define scaling configurations for Kubernetes resources. It provides serialization and deserialization functions to and from JSON using `Yojson.Safe.t`. This structure is specifically used to handle multiple named scale specifications in Kubernetes API interactions.",
      "description_length": 367,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_daemon_endpoints.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Node daemon endpoints data structures to and from JSON format. It works with lists of tuples pairing strings with Node_daemon_endpoints records, typically representing named endpoints and their associated port configurations. Concrete use cases include converting Node daemon endpoint data to JSON for API responses or storage, and parsing JSON input into structured data for Node configuration processing.",
      "description_length": 463,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ip_block.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an `Ip_block` structure, used to define CIDR ranges for network policy rules in Kubernetes. It provides functions to serialize and deserialize these structures to and from JSON format. This module is specifically used to configure network policies by specifying IP blocks that are allowed or excluded for pods selected by a network policy.",
      "description_length": 408,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Deployments into Yojson format. It operates on a list of key-value pairs where each value is a Deployment_list.t. It is used to convert Deployment data to and from JSON for storage or transmission.",
      "description_length": 279,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a replication controller specification. It provides functions to convert this list structure to and from JSON format. It is used to serialize and deserialize collections of replication controller configurations for storage or transmission.",
      "description_length": 308,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_ref.Object",
      "library": "kubecaml",
      "description": "This module represents a list of role references in the Kubernetes RBAC v1beta1 API, where each entry associates a string key with a role reference object. It provides functions to convert this structure to and from JSON using `to_yojson` and `of_yojson`. This is used when defining role bindings that link subjects to roles by name within a namespace.",
      "description_length": 352,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Local_subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of namespace-scoped subject access reviews, specifically mapping string identifiers to access review configurations. It operates on lists of tuples containing strings and `Local_subject_access_review.t` values, converting them to and from JSON format using `Yojson.Safe.t`. This is used to enforce and validate user or group permissions within specific Kubernetes namespaces during authorization checks.",
      "description_length": 457,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Aggregation_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of labeled Aggregation_rule objects, where each entry pairs a string label with an Aggregation_rule value. It provides functions to convert the list to and from JSON format using Yojson. This structure is used to define sets of rules that locate and combine ClusterRoles in Kubernetes RBAC configurations.",
      "description_length": 335,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_status_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes component statuses, where each status is represented as a tuple of a string and a `Component_status_list.t` value. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. This is used when interacting with Kubernetes API endpoints that return component status information in JSON, enabling direct parsing and generation of status responses.",
      "description_length": 466,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Binding.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Kubernetes Binding object, representing associations between resources like pods and nodes. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. This structure is useful for handling deprecated direct bindings in pre-1.7 Kubernetes APIs, particularly when working with raw JSON data from cluster state snapshots.",
      "description_length": 425,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Handler.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of handlers, where each handler is a named action associated with a specific Kubernetes event or lifecycle hook. It provides functions to serialize and deserialize handler objects to and from JSON format, enabling integration with Kubernetes API operations. It is used to define callback actions, such as pre-stop or post-start hooks, for container lifecycle management.",
      "description_length": 406,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1.Storage_class_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of storage class list objects to and from JSON format. It works with a list of key-value pairs where each value is a storage class list structure. It is used to convert raw JSON data into typed OCaml representations and vice versa for configuration or API interaction purposes.",
      "description_length": 335,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of initializer objects used in Kubernetes admission registration. It works with a list of tuples pairing strings with initializer configurations, converting them to and from JSON format. It is used to manage the structured representation of initializer settings during API interactions.",
      "description_length": 344,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module manages RoleBinding resources in a Kubernetes namespace, combining core operations for listing and monitoring with child module support for detailed CRUD actions. It centers on RoleBinding and RoleBindingList data types, enabling tasks like creating, updating, and deleting specific role bindings using the Rbac V1beta1 API. You can list all role bindings in a namespace, watch for changes to manage access control dynamically, or use submodules to perform precise updates or deletions with options like Patch or DeleteOptions.",
      "description_length": 539,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes daemon sets within a namespace, offering operations to list, create, and delete daemon sets via HTTP requests. It works with daemon set objects, lists, and Kubernetes metadata types for resource management. The submodule provides finer control with get, put, delete, and patch operations on specific daemon sets, while the status submodule allows updating or retrieving a daemon set's status. For example, you can create a new daemon set, update its pod template, or modify its status after deployment.",
      "description_length": 533,
      "index": 446,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Stateful_set_status objects into JSON format. It works with a list of key-value pairs where each value is a Stateful_set_status record. It is used to convert Stateful_set status data to and from JSON representations for API interactions.",
      "description_length": 298,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Replicationcontrollers",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of replication controllers in a Kubernetes namespace, allowing event streaming with support for label and field selectors, result limits, and custom timeouts or resource versions. It enables tracking of all replication controllers in a namespace or focusing on a specific controller using child modules. Main data types include event streams and replication controller objects, with operations for filtering, limiting, and configuring watch parameters. For example, it can trigger autoscaling decisions or validate deployments by reacting to replication controller updates as they occur.",
      "description_length": 629,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Secrets",
      "library": "kubecaml",
      "description": "This module monitors changes to Kubernetes Secret resources in a specified namespace, supporting filters via label and field selectors, pagination with `resource_version` and `continue`, and real-time updates. It provides a `get` function to establish a watch stream with options like timeout and resource version, returning events or errors as they occur. You can use it to track dynamic configuration changes or credential updates in real time, such as watching for modifications to a specific Secret or streaming updates across a set of Secrets. The module enables both broad and targeted observation of Secret changes, combining direct API controls with focused monitoring capabilities.",
      "description_length": 690,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Watch.Apiservices.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes API service by name, providing a function to construct the request path and another to perform the watch operation with customizable parameters like timeout, resource version, and selectors. It works with Kubernetes API service objects and watch events, enabling real-time monitoring of service state changes. A concrete use case is tracking the availability or configuration updates of a specific Kubernetes API service in a cluster.",
      "description_length": 487,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of token review status objects used in Kubernetes API authentication. It works with lists of string and token review status pairs, converting them to and from JSON format. It is used to process authentication token validation responses in Kubernetes API clients.",
      "description_length": 320,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes Deployment objects as key-value pairs, where each key is a string and the value is a Deployment configuration. It provides functions to convert this collection to and from JSON format using the Yojson library. This module is used to manage multiple Deployment resources in a serialized format, typically for storage or transmission.",
      "description_length": 382,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Run_as_user_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each pair consists of a string and a `Run_as_user_strategy_options.t` value. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is used to define user identity options for Kubernetes pod security policies, specifically when configuring run-as-user strategies.",
      "description_length": 368,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Services",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes Service resources in a specified namespace, enabling real-time tracking of creation, deletion, and update events. It supports filtering through label and field selectors, resource version, and timeout controls, with a `get` function that streams watch events for specific Services. Operations include establishing a watch stream to detect configuration changes or status updates, and reacting to those changes programmatically. Submodules extend this functionality to handle detailed event processing and error handling within the watch stream.",
      "description_length": 576,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_status.Object",
      "library": "kubecaml",
      "description": "This module represents the status of persistent volumes in a Kubernetes cluster, specifically mapping string identifiers to persistent volume status information. It provides functions to convert this status data to and from JSON format using `to_yojson` and `of_yojson`. This is used when interacting with Kubernetes APIs to retrieve or update the current state of persistent volumes.",
      "description_length": 384,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Resource_quota items, represented as a list of key-value pairs where each value is a Resource_quota structure. It provides `to_yojson` and `of_yojson` functions for converting between the internal OCaml representation and JSON format. It is used when interacting with Kubernetes API endpoints that return or require collections of resource quota definitions, such as querying or updating multiple resource quotas in a cluster.",
      "description_length": 508,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Ceph_fs_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of CephFS persistent volume source objects into JSON format. It works with a list of key-value pairs where each value is a CephFS persistent volume source configuration. It is used to convert between in-memory representations and JSON data for storage or transmission, specifically for Kubernetes volume configurations involving CephFS.",
      "description_length": 394,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Podtemplates.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes PodTemplates within a specific namespace, providing `get`, `put`, `delete`, and `patch` functions to interact with individual PodTemplate resources. It works directly with PodTemplate and DeleteOptions data types, handling serialization and HTTP communication. Concrete use cases include retrieving, updating, deleting, or partially modifying a PodTemplate resource in a namespace by name, such as when managing workload templates in a cluster.",
      "description_length": 498,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Portworx_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Portworx volume source objects to and from JSON format. It works with a list of tuples, where each tuple pairs a string identifier with a Portworx_volume_source.t value. Concrete use cases include converting Portworx volume configurations to JSON for API requests and parsing JSON responses into structured data for cluster management operations.",
      "description_length": 407,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Stateful_set_status, enabling structured representation of stateful set statuses in Kubernetes. It provides serialization to and from JSON using Yojson, ensuring compatibility with JSON-based APIs. This structure is used to track and manage the current state of StatefulSets, including details like observed generation, replicas, and persistent volume claims.",
      "description_length": 427,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node.Object",
      "library": "kubecaml",
      "description": "This module defines a list of Kubernetes node objects, where each node is represented as a tuple of a string identifier and a node definition. It provides functions to convert the list to and from JSON format using the Yojson library. This structure is used to serialize and deserialize collections of Kubernetes node data for storage or transmission.",
      "description_length": 351,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of downward API volume source objects into JSON format. It works with a list of key-value pairs where each value is a downward API volume source configuration. It is used to define volumes in Kubernetes pods that expose metadata such as pod IP, namespace, or labels as files.",
      "description_length": 333,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_item.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of key-value pairs, where each value is a `Limit_range_item.t`, to and from JSON format. It works specifically with `Yojson.Safe.t` for JSON representation and operates on lists of tuples pairing strings with `Limit_range_item.t` values. It is used to convert limit range item data to JSON for storage or transmission, and to parse such data from JSON input.",
      "description_length": 426,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_env_source.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of environment variable data from a list of string pairs into JSON format and vice versa. It operates on a list structure where each element is a key-value pair representing an environment variable. This functionality is used when serializing or deserializing environment variable configurations for Kubernetes ConfigMap sources.",
      "description_length": 364,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_list.Object",
      "library": "kubecaml",
      "description": "This module defines a list of pod disruption budgets, where each entry is a tuple of a string and a Pod_disruption_budget_list value. It provides functions to convert this structure to and from JSON using Yojson. This module is used to serialize and deserialize collections of pod disruption budget objects for API interactions.",
      "description_length": 328,
      "index": 465,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes Secret objects grouped by namespace. It provides functions to convert this collection to and from JSON format, specifically using the Yojson library for serialization and deserialization. This structure is used when managing or deploying multiple secrets across different namespaces in a Kubernetes cluster.",
      "description_length": 357,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.User_info.Object",
      "library": "kubecaml",
      "description": "This module represents a list of user information entries, where each entry pairs a string identifier with a `User_info` value. It provides serialization and deserialization to and from JSON using `Yojson.Safe.t`. This structure is used to handle collections of authenticated user data in Kubernetes API interactions, specifically for the `user.info` interface implementation.",
      "description_length": 376,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module provides functions to convert a list of cluster role bindings into JSON format and parse JSON into a list of cluster role bindings. It operates on a list of tuples, each containing a string and a `Cluster_role_binding_list.t` value. Use this module when serializing or deserializing cluster role binding data for API interactions or storage.",
      "description_length": 353,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector_requirement.Object",
      "library": "kubecaml",
      "description": "This module represents a list of node selector requirements, where each requirement consists of a key and a corresponding constraint on its values. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. It is used to define constraints on node labels when scheduling Kubernetes pods, ensuring they run on nodes that match specified criteria.",
      "description_length": 388,
      "index": 469,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_key_selector.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Secret_key_selector`, used to reference specific keys within Kubernetes Secrets. It provides functions to convert the structure to and from JSON format, enabling integration with Kubernetes API operations. This is useful when configuring workloads that require secure access to specific secret keys, such as database credentials or API tokens.",
      "description_length": 415,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rolling_update_stateful_set_strategy.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of rolling update strategy configurations for StatefulSets in Kubernetes. It works with associative lists mapping strings to rolling update parameters. Concrete use cases include converting between JSON representations and OCaml values when deploying or modifying StatefulSet update strategies.",
      "description_length": 348,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to persistent volume specifications. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to define multiple named persistent volume configurations, typically for managing storage resources in Kubernetes deployments.",
      "description_length": 353,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Configmaps",
      "library": "kubecaml",
      "description": "This module watches for changes to ConfigMap resources in a namespace, supporting filters by label, field selectors, resource version, and namespace. It provides a `get` function that streams `WatchEvent` results for additions, updates, or deletions of ConfigMap entries, enabling real-time synchronization in operator frameworks or dynamic configuration reloaders. The child module focuses on watching specific named ConfigMaps, allowing fine-grained monitoring of individual configuration resources with optional timeouts and selectors. Together, they support use cases like tracking configuration changes in a running cluster or maintaining synchronized application state.",
      "description_length": 675,
      "index": 473,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of volume attachment objects to and from JSON format. It works with a list of tuples pairing strings with volume attachment definitions. Concrete use cases include converting volume attachment data for API transmission or storage and parsing incoming JSON data into structured volume attachment objects.",
      "description_length": 357,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_rules_review_spec.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to authorization review specifications, enabling representation of access control rules for Kubernetes API resources. It provides serialization and deserialization functions to convert between this structure and JSON format. This is used to evaluate the permissions a subject has on specific Kubernetes API objects.",
      "description_length": 378,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure of tuples mapping strings to `Cluster_role` values, primarily used for representing collections of named cluster roles. It provides functions to convert this structure to and from JSON format using `Yojson.Safe.t`. This module is useful when managing multiple cluster roles in configurations or when serializing/deserializing cluster role data for storage or transmission.",
      "description_length": 415,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1.Watch.Initializerconfigurations.By_name",
      "library": "kubecaml",
      "description": "Performs watch operations on Kubernetes InitializerConfiguration resources by name, supporting event streaming with optional parameters like timeout, resource version, and label selectors. Works with watch events and InitializerConfiguration objects. Use to monitor changes to specific initializer configurations in real time.",
      "description_length": 326,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of node specifications keyed by string identifiers, providing serialization and deserialization to and from JSON format. It works with lists of tuples pairing strings with `Node_spec.t` values, enabling structured configuration handling for Kubernetes node definitions. Concrete use cases include parsing and generating node configuration data in JSON for cluster management operations.",
      "description_length": 422,
      "index": 478,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of token review objects used for authenticating tokens in Kubernetes. It works with lists of string-token review pairs and supports conversion to and from JSON using Yojson. It is used to process and validate authentication tokens within Kubernetes API interactions.",
      "description_length": 324,
      "index": 479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_port.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of service port data structures to and from JSON format. It works with a list of tuples, where each tuple consists of a string and a service port definition, representing multiple service ports. Concrete use cases include converting service port configurations to JSON for storage or transmission and parsing JSON input into structured service port data for further processing.",
      "description_length": 435,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Watch.Storageclasses.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes StorageClass resources by name. It provides a `get` function to establish a watch stream with customizable parameters like timeout, resource version, and selectors. Use it to monitor real-time updates to specific storage classes in a cluster.",
      "description_length": 288,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployment resources within a namespace, offering direct HTTP-based operations to create, list, update, and delete Deployments. It centers around the Deployment and Deployment_list data types, supporting actions like rolling out new configurations, scaling replicas, and rolling back to previous versions through submodules. Operations such as `post`, `get`, `put`, and `patch` enable concrete use cases like adjusting Deployment scale in response to traffic, inspecting Deployment status for health checks, and programmatically triggering rollbacks. Submodules extend functionality to fine-grained control over Deployment subresources, including status and scale.",
      "description_length": 695,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Namespace objects with their associated metadata. It provides functions to convert the list to and from JSON format using Yojson, enabling serialization and deserialization for API interactions. The primary use case is handling collections of Namespace resources when communicating with a Kubernetes cluster.",
      "description_length": 352,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Rule_with_operations.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes admission registration rules with operations and resources. It works with tuples of strings and `Rule_with_operations` types, converting them to and from JSON format. Concrete use cases include processing Kubernetes API configurations for admission controllers, specifically dealing with rule validation and data interchange.",
      "description_length": 393,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_affinity.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of node affinity rules mapped to keys, used to define scheduling constraints for Kubernetes pods based on node labels. It provides functions to serialize and deserialize these mappings to and from JSON format. This structure is used when configuring pod scheduling policies that require specific node attributes, such as in deployment or daemon set specifications.",
      "description_length": 400,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Quobyte_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Quobyte volume source configuration. It provides serialization and deserialization functions to convert between JSON representations and OCaml values. It is used to manage Quobyte volumes in Kubernetes pod specifications, specifically for handling volume mounts that persist for the pod's lifetime.",
      "description_length": 366,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Storage_class_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of storage classes, where each entry is a tuple of a string and a storage class structure. It provides `to_yojson` and `of_yojson` functions for converting between JSON representations and OCaml values. It is used when interacting with Kubernetes API endpoints that return or expect lists of storage classes in JSON format.",
      "description_length": 391,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to `Cron_job_spec` values, used to define multiple cron job configurations. It provides `to_yojson` and `of_yojson` functions for converting between JSON and OCaml representations. It is typically used when managing collections of cron job specifications in JSON format, such as during configuration parsing or serialization.",
      "description_length": 390,
      "index": 488,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Preferred_scheduling_term.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a preferred scheduling term, used to define scheduling preferences for Kubernetes objects. It provides functions to convert this list to and from JSON format using Yojson. This structure is specifically used to serialize and deserialize scheduling preferences when interacting with Kubernetes APIs or configuration files.",
      "description_length": 390,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Subject.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of RBAC subject objects to and from JSON, specifically for role bindings targeting direct API objects. It works with a list of tuples pairing strings with subject definitions, aligning with Kubernetes RBAC v1beta1 schema. Use this module when converting subject data to JSON for storage or transmission, or when parsing incoming JSON into subject structures.",
      "description_length": 412,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Certificatesigningrequests.By_name.Approval",
      "library": "kubecaml",
      "description": "This module handles the approval of certificate signing requests by name in the Kubernetes API. It provides a `put` function to update the approval status of a `Certificate_signing_request` resource, using a request path template to target the specific resource instance. The module works directly with Kubernetes certificate signing request definitions and is used to issue approvals programmatically within a PKI workflow.",
      "description_length": 424,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Limitranges.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes LimitRange resources within a specific namespace. It provides `get`, `put`, `delete`, and `patch` functions to retrieve, replace, remove, and partially update LimitRange objects by name. The module works directly with structured types such as `Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range.t` and `Delete_options.t`, making it suitable for managing resource constraints in Kubernetes environments.",
      "description_length": 461,
      "index": 492,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Supplemental_groups_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Supplemental_groups_strategy_options.t` type, used to define strategies for supplemental group configurations. It provides `to_yojson` and `of_yojson` functions for converting between JSON and the in-memory representation. This module is used when working with Kubernetes pod security policies that require specifying supplemental group strategy options.",
      "description_length": 426,
      "index": 493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_binding_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes RBAC cluster role bindings, where each binding is paired with a string identifier. It provides functions to convert the list to and from JSON format using `Yojson.Safe.t`. The structure is used to serialize and deserialize collections of cluster role bindings for API interactions or configuration management.",
      "description_length": 353,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Daemon_endpoint.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Daemon_endpoint.t` record, representing endpoints exposed by a Kubernetes DaemonSet. It provides functions to serialize and deserialize these endpoint objects to and from JSON format using Yojson. This structure is used to manage and expose network endpoints for DaemonSet pods in a Kubernetes cluster.",
      "description_length": 371,
      "index": 495,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Rule.Object",
      "library": "kubecaml",
      "description": "This module defines and manipulates rule objects used for specifying admission control policies in Kubernetes. It works with tuples containing API groups and rule definitions, supporting serialization to and from JSON format. It is used to configure validation or mutation rules for Kubernetes resources during API requests.",
      "description_length": 324,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.External_metric_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to external metric source configurations, enabling specification of metrics external to Kubernetes for autoscaling. It provides serialization and deserialization functions to and from JSON format, ensuring compatibility with external systems and APIs. This structure is used to configure custom metrics for horizontal pod autoscalers based on external data sources like cloud services or external load balancers.",
      "description_length": 475,
      "index": 497,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Podsecuritypolicies.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving PodSecurityPolicy resources by name in a Kubernetes cluster. It provides a `get` function to stream changes to a specific PodSecurityPolicy object using watch semantics, supporting parameters like resource version, label selectors, and timeouts. Works directly with Kubernetes API types such as Watch_event and Pod_security_policy, targeting use cases like real-time policy monitoring and dynamic access control updates.",
      "description_length": 455,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Policy_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of policy rules in the Kubernetes RBAC API, where each rule is associated with a string identifier. It provides functions to convert the list to and from JSON format using the Yojson library. This module is used to define collections of access control rules for Kubernetes resources, such as specifying which actions are allowed on specific resource types.",
      "description_length": 386,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Namespaces.By_namespace.Events",
      "library": "kubecaml",
      "description": "This module manages Kubernetes events in a specific namespace, offering operations to list, create, update, and delete events either in bulk or individually. It works directly with event objects and metadata, supporting filters for listing and partial updates through HTTP methods like PATCH. Use it to track or modify event status, remove outdated events, or retrieve event streams with custom query parameters. Key data types include event objects, namespace identifiers, and patch payloads.",
      "description_length": 493,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes daemon sets, where each entry is a tuple of a string identifier and a daemon set structure. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This module is used when retrieving or serializing multiple daemon sets, such as when interacting with the Kubernetes API to list all daemon sets in a namespace.",
      "description_length": 399,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to deployment strategy configurations, specifically used for defining how Kubernetes replaces pods during deployments. It provides serialization and deserialization functions to and from JSON using `to_yojson` and `of_yojson`, ensuring compatibility with Kubernetes API expectations. This structure is used when configuring deployment strategies in Kubernetes manifests programmatically.",
      "description_length": 452,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy_spec.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Pod Security Policy Spec objects to and from JSON. It works with associative lists mapping strings to Pod_security_policy_spec.t values. It is used to convert policy specifications to JSON format for storage or transmission, and to parse such specifications from JSON input.",
      "description_length": 331,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module observes Kubernetes events within a namespace, offering real-time updates through a configurable `get` function that supports label and field-based filtering, resource version constraints, and timeouts. It provides fine-grained monitoring for events tied to specific resources by name, enabling targeted debugging and automated reactions. Key data types include event streams and filter configurations, with operations to subscribe, filter, and retrieve event data. For example, it can track pod-related events in a namespace or monitor changes to a specific service's event stream.",
      "description_length": 594,
      "index": 504,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod template specifications into JSON format. It works with a list of key-value pairs where each value is a Pod template specification. It is used to convert Pod template data to and from JSON representations, typically for storage or transmission.",
      "description_length": 309,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Customresourcedefinitions.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides a `put` function to update the status of a specific Custom Resource Definition (CRD) by name, using a predefined request path template. It operates on CRD objects and interacts with the Kubernetes API via HTTP requests, allowing for direct modification of CRD status fields. A concrete use case is updating the observed state of a CRD after a reconciliation process in a Kubernetes operator.",
      "description_length": 412,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_system_info.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of node system information objects to and from JSON format. It works with a list of string-Node_system_info pairs, enabling structured data exchange for node identification. Use this module when converting node metadata to JSON for storage or transmission, or when parsing JSON input into typed node system info structures.",
      "description_length": 377,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Http_ingress_rule_value.Object",
      "library": "kubecaml",
      "description": "This module represents a list of HTTP ingress rule mappings, where each rule consists of a string key and a corresponding backend definition. It provides functions to convert these rule lists to and from JSON format using `to_yojson` and `of_yojson`. This structure is used when defining routing rules for Kubernetes ingress resources, specifically for directing HTTP traffic to the appropriate backend services based on path and host matches.",
      "description_length": 443,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs mapping strings to `Scale_spec` values, primarily used for defining Kubernetes scale subresource configurations. It provides functions `to_yojson` and `of_yojson` for converting between JSON and the internal OCaml representation. This structure is useful when working with Kubernetes API objects that require serialization or deserialization, such as when interacting with the Apps V1beta2 API during deployment scaling operations.",
      "description_length": 486,
      "index": 509,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Se_linux_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an Se_linux strategy option. It provides functions to convert the list to and from JSON format. This module is used to manage Se_linux strategy configurations in Kubernetes extensions.",
      "description_length": 253,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Volume_attachment_status objects into JSON format. It works with a list of key-value pairs where each value is a Volume_attachment_status.t. It is used to convert Volume_attachment_status data to and from JSON representations for storage or transmission.",
      "description_length": 315,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoints_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes endpoint objects, where each endpoint is identified by a string key and associated with its corresponding data structure. It provides functions to serialize and deserialize these endpoint objects to and from JSON format using the Yojson library. This module is used when managing network endpoints in Kubernetes, such as tracking pods backing a service, and requires precise JSON encoding/decoding for API interactions.",
      "description_length": 469,
      "index": 512,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event_series.Object",
      "library": "kubecaml",
      "description": "This module defines a list of event series entries, where each entry pairs a string key with an `Event_series.t` value. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to represent and persist collections of related event series data, such as grouping events by source or category in a Kubernetes system.",
      "description_length": 381,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_security_context.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Pod_security_context` record, used to represent and manage pod-level security settings in Kubernetes. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is useful for serializing and deserializing Kubernetes pod security configurations when interacting with the API or storing configuration data.",
      "description_length": 419,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_key_selector.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Config_map_key_selector, used to reference specific keys within Kubernetes ConfigMaps. It provides functions to convert the list to and from JSON format, enabling serialization and deserialization for use in Kubernetes API interactions. This structure is useful when defining configurations that pull values from ConfigMaps in Kubernetes resources like Pods or Deployments.",
      "description_length": 444,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of deployment conditions as key-value pairs, where each key is a string identifier and the value is a deployment condition object. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson` functions. This structure is used to track and exchange the status of Kubernetes deployments, capturing conditions like availability or readiness in a structured format.",
      "description_length": 433,
      "index": 516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Policy_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of policy rules indexed by string keys, used to define role-based access control policies in Kubernetes. It provides functions to convert the collection to and from JSON format, facilitating serialization and deserialization for configuration and API interaction. Concrete use cases include managing RBAC policies programmatically and integrating with Kubernetes API clients or configuration tools.",
      "description_length": 434,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_list.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Volume_attachment_list objects to and from JSON. It works with lists of tuples pairing strings with Volume_attachment_list values. Concrete use cases include converting Kubernetes storage volume attachment data to JSON format for API transmission or configuration files, and parsing such data from JSON input.",
      "description_length": 366,
      "index": 518,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Endpoints",
      "library": "kubecaml",
      "description": "This module monitors changes to Kubernetes Endpoint resources within a namespace, supporting filters via label and field selectors, and configurable watch behavior such as timeout and resource version. It provides a `get` function that initiates a watch stream and returns a result with a `Watch_event`, enabling real-time tracking of endpoint updates. Specific uses include maintaining up-to-date service discovery state by reacting to changes in named Endpoints objects. The module combines direct API control with structured event handling from its submodules.",
      "description_length": 563,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_disk_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to Azure disk volume source configurations, enabling precise representation of Azure disk mounts. It provides JSON serialization and deserialization functions for converting between object representations and JSON values. This is used to configure Azure disk volumes in Kubernetes pod specifications, specifically for integrating Azure storage with container workloads.",
      "description_length": 432,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes ResourceQuotaSpec objects to and from JSON format. It works with associative lists mapping strings to Resource_quota_spec.t values. It is used when interacting with Kubernetes APIs to enforce resource quotas, such as setting CPU or memory limits in a cluster.",
      "description_length": 331,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to daemon set status values, enabling direct access to individual status entries. It provides JSON serialization and deserialization functions for converting between native OCaml representations and JSON data. This is used to process and persist the runtime state of Kubernetes daemon sets within an extension API.",
      "description_length": 377,
      "index": 522,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_status.Object",
      "library": "kubecaml",
      "description": "This module represents the observed status of a Kubernetes Deployment as a list of key-value pairs, where each value is a Deployment_status instance. It provides functions to convert this structure to and from JSON format using Yojson. This module is used to serialize and deserialize Deployment status data when interacting with the Kubernetes API or storing cluster state.",
      "description_length": 374,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Load_balancer_ingress.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of load balancer ingress data structures to and from JSON format. It works with a list of tuples, where each tuple consists of a string identifier and a load balancer ingress status object. Concrete use cases include converting ingress status information to JSON for API responses and parsing JSON input into structured data for service configuration updates.",
      "description_length": 417,
      "index": 524,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Api.Resource.Quantity",
      "library": "kubecaml",
      "description": "This module handles Kubernetes resource quantities like CPU and memory, using a custom type `t` that supports parsing from strings and conversion to and from JSON. It includes a submodule for managing collections of these quantities as key-value pairs, providing `to_yojson` and `of_yojson` for structured serialization. You can use `make` to create quantity values from strings, and the submodule to represent resource specifications in API objects. Together, they enable precise resource management and API interaction with Kubernetes clusters.",
      "description_length": 546,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Non_resource_attributes.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Non_resource_attributes.t` type, used to define authorization attributes for non-resource requests. It provides `to_yojson` and `of_yojson` functions for converting between JSON and the internal OCaml representation. It is used when handling authorization policies that apply to non-resource endpoints in Kubernetes, such as API health checks or version information.",
      "description_length": 438,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Ip_block.Object",
      "library": "kubecaml",
      "description": "This module represents a list of IP block rules used in Kubernetes network policies, where each rule consists of a CIDR range and an `Ip_block` definition that may include exceptions. It provides serialization and deserialization to and from JSON using `Yojson`, ensuring compatibility with Kubernetes API specifications. It is used when defining or parsing network policy ingress/egress rules that restrict pod communication based on IP ranges.",
      "description_length": 445,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Http_header.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an HTTP header configuration for Kubernetes probes. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used to configure custom headers in liveness or readiness probes within Kubernetes pod specifications.",
      "description_length": 327,
      "index": 528,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named Role objects in the RBAC API, providing functions to convert the list of roles to and from JSON format. It works with a list of tuples, where each tuple contains a string identifier and a Role definition. This structure is used to manage and serialize multiple roles within a Kubernetes namespace.",
      "description_length": 342,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes Deployment specification as a list of key-value pairs, where each value is a Deployment specification object. It provides functions to convert this structure to and from JSON format using the Yojson library. This module is used to define and manipulate the desired state of a Deployment resource in a Kubernetes cluster, such as setting replica counts, update strategies, and pod templates.",
      "description_length": 426,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of StatefulSet objects in the Kubernetes API, where each entry is a tuple of a string and a StatefulSet structure. It provides functions to convert this list to and from JSON format using the Yojson library. This module is used to serialize and deserialize collections of StatefulSet resources for storage or transmission in a Kubernetes context.",
      "description_length": 376,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes RBAC roles keyed by string identifiers, providing functions to convert the collection to and from JSON format. It works with lists of tuples containing strings and role definitions. This module is used to serialize and deserialize role data for storage or transmission in a Kubernetes RBAC system.",
      "description_length": 347,
      "index": 532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and each value is a `Replication_controller_status` record. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to represent and manipulate the status information of multiple replication controllers in JSON format, particularly during serialization and deserialization in Kubernetes API interactions.",
      "description_length": 446,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Metric_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of metric specifications for autoscaling, where each entry pairs a string identifier with a metric specification. It provides functions to convert the list to and from JSON format using Yojson. This structure is used to define multiple scaling metrics in Kubernetes autoscaling configurations, such as CPU or memory usage thresholds for horizontal pod autoscalers.",
      "description_length": 394,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer_configuration_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of initializer configurations in Kubernetes's admission registration API. It provides functions to convert the list to and from JSON format using `to_yojson` and `of_yojson`. It is used when managing dynamic admission control policies that enforce initialization logic on resources before they are persisted.",
      "description_length": 338,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_projection.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a volume projection, used to define projected volumes in Kubernetes configurations. It provides functions to convert this list to and from JSON format using the Yojson library. This structure is specifically used when configuring pod volumes that combine multiple projection sources, such as secrets, config maps, or downward API data.",
      "description_length": 404,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Fc_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Fibre Channel volume source configuration. It provides serialization and deserialization functions to convert between JSON representations and OCaml values. It is used to handle Fibre Channel volume configurations in Kubernetes API objects, specifically for managing storage volumes in a cluster.",
      "description_length": 364,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1.Watch.Storageclasses.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving Kubernetes storage class resources by name, supporting operations like `get` with optional parameters for filtering and streaming updates. Works with storage class objects and watch events, handling responses as labeled results. Useful for monitoring specific storage class configurations in real time or querying their state with custom filters.",
      "description_length": 381,
      "index": 538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_daemon_set.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value conforms to the rolling update specification for daemon sets. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used when defining or parsing Kubernetes daemon set configurations that require custom rolling update strategies.",
      "description_length": 361,
      "index": 539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Capabilities.Object",
      "library": "kubecaml",
      "description": "This module represents a list of container capabilities, where each entry associates a container name with its configured Posix capabilities. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. It is used to define or modify capabilities for specific containers within a Kubernetes pod specification.",
      "description_length": 350,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes ReplicaSet objects as key-value pairs, where each key is a string identifier and the value is a ReplicaSet structure. It provides serialization to and from JSON using `to_yojson` and `of_yojson`, enabling direct interaction with Kubernetes API responses. It is used when retrieving or manipulating groups of ReplicaSets, such as during cluster state inspection or batch operations.",
      "description_length": 425,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Replica_set objects into JSON format. It works with a list-based structure where each element is a tuple of a string and a Replica_set definition. It is used to convert Replica_set data to and from JSON representations, primarily for interacting with Kubernetes APIs or storing configuration data.",
      "description_length": 358,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Podsecuritypolicies.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving PodSecurityPolicy resources by name, supporting operations like `get` with optional parameters for filtering and resource versioning. Works directly with Kubernetes API types, including Watch_event and Pod_security_policy. Useful for monitoring specific PodSecurityPolicy changes in a cluster, such as tracking policy updates or deletions.",
      "description_length": 374,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_rules_review_spec.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Self_subject_rules_review_spec.t` values, primarily used for representing authorization rule sets in Kubernetes API requests. It provides functions to convert this structure to and from JSON format, enabling serialization and deserialization for API interactions. Concrete use cases include constructing and parsing self-subject rules review requests in Kubernetes authorization workflows.",
      "description_length": 456,
      "index": 544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of persistent volume claim objects to and from JSON format. It works with a list of tuples, each containing a string and a persistent volume claim definition, enabling structured data exchange. It is used to convert Kubernetes persistent volume claim configurations to JSON for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 410,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Validating_webhook_configuration.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of validating webhook configurations in Kubernetes's admissionregistration v1beta1 API. It works with a list of key-value pairs where each value is a validating webhook configuration record. It is used to convert between OCaml representations and JSON format for storing or transmitting webhook settings.",
      "description_length": 362,
      "index": 546,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_ingress_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Network_policy_ingress_rule`, used to define allowed network traffic rules for Kubernetes pods. It provides functions to serialize and deserialize these rules to and from JSON format. This module is used when defining or parsing network policies in Kubernetes manifests, particularly for specifying ingress rules based on ports and source selectors.",
      "description_length": 421,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of persistent volume objects to and from JSON format. It works with a list of tuples, each containing a string and a `Persistent_volume_list.t` value. It is used to convert between in-memory representations of persistent volume lists and their JSON-encoded forms for storage or transmission.",
      "description_length": 359,
      "index": 548,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes DaemonSet update strategy objects into JSON format. It works with a list of key-value pairs where each value is a DaemonSet update strategy. It is used to convert between in-memory representations and JSON data when interacting with Kubernetes APIs or storing configuration data.",
      "description_length": 351,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Stateful_set objects into JSON format. It works with a list of key-value pairs where each value is a Stateful_set definition, allowing structured representation and parsing. Concrete use cases include reading Stateful_set configurations from JSON input and converting them to OCaml data structures for further processing or validation.",
      "description_length": 396,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Empty_dir_volume_source.Object",
      "library": "kubecaml",
      "description": "This module serializes and deserializes empty directory volume source objects to and from JSON. It works with associative lists mapping strings to empty directory volume source configurations. Use this module when converting Kubernetes pod specifications to JSON format or parsing them from JSON input.",
      "description_length": 302,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes autoscaling v1 scale status objects to and from JSON format. It works with a list of key-value pairs where each value is a `Scale_status.t` type. It is used to interpret or generate JSON data representing the current state of Kubernetes scale subresources, such as those retrieved from or sent to a Kubernetes API server.",
      "description_length": 393,
      "index": 552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes nodes as a list of key-value pairs, where each key is a string identifier and the value is a Node_list structure. It provides functions to convert this node data to and from JSON format using Yojson. This module is used to serialize and deserialize node lists for storage or transmission, such as when interacting with Kubernetes API responses or configuration files.",
      "description_length": 417,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of certificate signing request objects to and from JSON format. It works with a list of key-value pairs where each value is a certificate signing request. It is used to convert raw JSON data into structured certificate signing request objects and vice versa for processing and storage.",
      "description_length": 343,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module manages ReplicaSet resources within a Kubernetes namespace, offering operations to list, create, and delete ReplicaSets with filtering options. It works directly with Kubernetes ReplicaSet definitions and interacts with the API via URIs, returning typed results in Lwt promises. The status submodule provides access to ReplicaSet status updates, allowing inspection and modification of observed states, while the scale submodule enables programmatic scaling using the Extensions V1beta1 Scale type. With support for GET, PUT, DELETE, and PATCH operations, it facilitates tasks like updating deployment specs, removing outdated configurations, or adjusting replica counts dynamically.",
      "description_length": 695,
      "index": 555,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of cron jobs, represented as a list of key-value pairs where each value is a cron job structure. It provides `to_yojson` and `of_yojson` functions for converting between the internal OCaml representation and JSON format. It is used when interacting with Kubernetes API endpoints that return or expect cron job lists in JSON, enabling direct parsing and generation of API responses.",
      "description_length": 449,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Replica_set_spec, enabling structured configuration of replica sets in Kubernetes. It provides serialization and deserialization to and from JSON using Yojson, ensuring compatibility with Kubernetes API expectations. Use this module when defining or manipulating replica set configurations programmatically, such as in deployment tools or cluster management systems.",
      "description_length": 437,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of replica set conditions, where each condition is a key-value pair describing the state of a replica set at a specific point. It provides functions to convert the collection to and from JSON format, enabling serialization and deserialization for storage or transmission. This structure is used to track and exchange the status of Kubernetes replica sets in a versioned API context.",
      "description_length": 418,
      "index": 558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of cluster roles, represented as a list of key-value pairs where each value is a `Cluster_role_list.t`. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON format. This is used when interacting with Kubernetes API endpoints that return or require cluster role list data in JSON, such as retrieving or updating cluster-level RBAC policies.",
      "description_length": 451,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.User_info.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to User_info values, providing serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It works with the `User_info.t` type to store and retrieve user authentication data in a structured format. Concrete use cases include handling user identity information within Kubernetes API authentication workflows, particularly when encoding or decoding JSON payloads during API requests and responses.",
      "description_length": 487,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Fs_group_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an Fs_group_strategy_options instance, used to define filesystem group strategies in Kubernetes API extensions. It provides serialization and deserialization to and from JSON using Yojson, enabling integration with Kubernetes configuration files. This structure is specifically used to configure pod security policies related to filesystem group settings in a Kubernetes cluster.",
      "description_length": 448,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes batch v1 jobs in a structured format, providing serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It works with job collections, specifically handling lists of job objects paired with string identifiers. It is used when managing or processing multiple batch jobs, such as retrieving or persisting job states in a Kubernetes environment.",
      "description_length": 416,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module manages RoleBinding resources in a Kubernetes namespace, supporting list, create, and delete operations through HTTP interactions with the Kubernetes API. It works directly with RoleBinding and RoleBindingList objects, using query parameters like label_selector and resource_version to filter and track resources. The module enables programmatic configuration of role-based access control, allowing precise management of permissions for users and service accounts. Submodules extend this functionality with fine-grained CRUD operations, including get, put, delete, and patch, which support advanced use cases such as updating access policies and cleaning up role bindings during namespace teardown.",
      "description_length": 710,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Services.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Services within a namespace, offering CRUD operations via HTTP to create, retrieve, update, or delete Service resources using Cohttp. It centers around the Service and Delete_options types, enabling precise control over Service configurations and deletion behavior. The status submodule extends this by allowing direct manipulation of Service status conditions, useful for controllers updating health or state. The proxy submodule forwards arbitrary HTTP requests to running Services, supporting path-based routing to specific endpoints for actions like querying metrics or invoking service-specific APIs.",
      "description_length": 636,
      "index": 564,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of volume attachment source objects to and from JSON format. It works with a list of key-value pairs where each value is a volume attachment source. It is used to convert volume attachment data to JSON for API communication and back from JSON responses into typed OCaml values.",
      "description_length": 331,
      "index": 565,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Volume_attachment_status objects into JSON format. It works with a list of key-value pairs where each value is a Volume_attachment_status.t. It is used to convert Volume_attachment_status data to and from JSON representations for storage or transmission.",
      "description_length": 315,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set.Object",
      "library": "kubecaml",
      "description": "This module serializes and deserializes stateful set objects to and from JSON format. It works with a list of tuples pairing strings with stateful set definitions, supporting structured data exchange for Kubernetes stateful sets. Use this module when persisting or transmitting stateful set configurations in JSON, such as saving to a file or sending to an API server.",
      "description_length": 368,
      "index": 567,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Resource_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of resource rules for Kubernetes authorization, where each rule pairs a resource name with its associated permissions. It provides serialization and deserialization to and from JSON using `Yojson.Safe.t`, enabling direct interaction with Kubernetes API payloads. Concrete use cases include constructing and parsing authorization policies for Kubernetes API server requests.",
      "description_length": 409,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Validating_webhook_configuration_list.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of a list of validating webhook configurations to and from JSON format. It works with a list type where each element is a tuple of a string and a validating webhook configuration. Concrete use cases include serializing and deserializing webhook configurations for storage or transmission in a Kubernetes admission controller setup.",
      "description_length": 366,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Job_template_spec.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to `Job_template_spec` values, enabling structured association of job templates with identifiers. It provides JSON serialization and deserialization functions for converting these mappings to and from JSON representations. This is used to manage and persist multiple job templates with distinct names in a Kubernetes Batch v2alpha1 context.",
      "description_length": 402,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a horizontal pod autoscaler specification. It provides functions to convert the list structure to and from JSON format. It is used to manage collections of named horizontal pod autoscaler configurations in Kubernetes.",
      "description_length": 286,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Stateful_set_spec. It provides functions to convert this list to and from JSON format using Yojson. This structure is used to manage multiple Stateful_set specifications, such as when organizing or serializing different configurations for deployment in Kubernetes.",
      "description_length": 335,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container.Object",
      "library": "kubecaml",
      "description": "This module represents a list of containers in a Kubernetes Pod specification, where each container is paired with a name. It provides functions to convert the list to and from JSON format using Yojson, ensuring proper serialization and deserialization for use in Kubernetes API interactions. It is used when constructing or parsing Pod definitions that include multiple named containers.",
      "description_length": 388,
      "index": 573,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Scale_spec.t` type, primarily used for defining Kubernetes scale subresource configurations. It provides functions `to_yojson` and `of_yojson` for converting these configurations to and from JSON format. This module is used when serializing or deserializing Kubernetes scale specifications for storage or transmission.",
      "description_length": 390,
      "index": 574,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_binding.Object",
      "library": "kubecaml",
      "description": "This module defines a list of tuples where each tuple pairs a string with a `Cluster_role_binding` value, representing a collection of cluster role bindings. It provides functions to convert this list structure to and from JSON format using `Yojson.Safe.t`. This structure is used to manage and serialize multiple cluster role bindings, typically for configuration or API interaction purposes.",
      "description_length": 393,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of cluster roles keyed by name, providing functions to serialize and deserialize the collection to and from JSON. It works with lists of tuples containing string keys and cluster role definitions. This module is used to manage and persist cluster-level role configurations in Kubernetes RBAC systems.",
      "description_length": 336,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of job specifications keyed by string identifiers, supporting serialization and deserialization to and from JSON. It works with lists of tuples pairing strings with `Job_spec.t` values, enabling structured configuration handling. Concrete use cases include parsing and generating Kubernetes batch job definitions from JSON input, such as when loading configuration files or interfacing with Kubernetes APIs.",
      "description_length": 443,
      "index": 577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to Kubernetes ClusterRoleBinding resources by name. It provides a `get` function to stream ClusterRoleBinding events with options like resource version, label selectors, and timeouts, returning a result with a Watch_event. Use it to monitor specific ClusterRoleBinding updates in real time.",
      "description_length": 318,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Exec_action.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named `Exec_action` definitions, where each entry corresponds to a command executed within a container. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, enabling configuration handling for Kubernetes pod execution actions. It is used to define and manage per-container command execution policies in pod specs.",
      "description_length": 397,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a deprecated version of Kubernetes network policy specifications, specifically handling a list of key-value pairs where each value is a network policy. It provides functions to convert these policies to and from JSON format using `to_yojson` and `of_yojson`. This module is used for backward compatibility with Kubernetes versions prior to 1.9, where network policies were part of the extensions/v1beta1 API.",
      "description_length": 431,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Certificatesigningrequests.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles updating the status of a specific CertificateSigningRequest resource by name. It provides a `put` function to replace the status of a certificate signing request with a new body, using a predefined request path template. The module works directly with Kubernetes v1beta1 certificate signing request definitions, targeting operations where certificate approval or denial needs to be programmatically set.",
      "description_length": 423,
      "index": 581,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes StatefulSets within a specific namespace, handling core HTTP operations like GET (list/watch), POST (create), and DELETE (collection deletion) on StatefulSet and StatefulSetList data types. It supports standard Kubernetes API parameters such as namespace, label selector, and resource version, enabling tasks like listing existing StatefulSets, creating new ones, or deleting all matching a selector. Submodules extend this functionality with fine-grained operations to replace, delete, or patch individual StatefulSets, adjust their scale using Scale.t, or manage status updates via Patch.t. Specific use cases include rolling back configurations, updating replica counts, and autoscaling StatefulSets based on load.",
      "description_length": 748,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Volume_attachment_spec objects into JSON format. It works with a list of tuples, where each tuple consists of a string and a Volume_attachment_spec.t value. It is used to convert volume attachment specifications to and from JSON representations for API communication.",
      "description_length": 328,
      "index": 583,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Controller_revision_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Controller_revision objects, represented as an associative list mapping strings to Controller_revision_list values. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON format. This is used when interacting with Kubernetes API endpoints that require or return Controller_revision data in JSON, such as retrieving or updating stateful set revisions.",
      "description_length": 463,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of horizontal pod autoscaler configurations to and from JSON format. It works with a list of tuples, where each tuple consists of a string and a horizontal pod autoscaler configuration object. This module is used when reading or writing autoscaler definitions to JSON files or APIs, ensuring correct data format conversion.",
      "description_length": 381,
      "index": 585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a scaling request for a Kubernetes resource. It provides functions to convert this list to and from JSON format using the Yojson library. This structure is typically used to handle multiple scaling requests in Kubernetes API interactions.",
      "description_length": 304,
      "index": 586,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Watch.Apiservices.By_name",
      "library": "kubecaml",
      "description": "Implements watching changes to Kubernetes API services by name, providing a `get` function to stream events for a specific API service. Operates on `Watch_event.t` values tied to the `Api_service` resource, supporting parameters like `watch`, `timeout_seconds`, and `resource_version`. Useful for monitoring lifecycle changes or status updates of registered Kubernetes API services in real time.",
      "description_length": 395,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_binding.Object",
      "library": "kubecaml",
      "description": "This module defines a list of tuples mapping string identifiers to Role_binding values, enabling structured associations between role bindings and their named references. It provides JSON serialization and deserialization functions for handling role binding configurations in a Kubernetes RBAC context. This structure is used to manage access control policies by linking subjects to roles within specific namespaces.",
      "description_length": 416,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_list.Object",
      "library": "kubecaml",
      "description": "Handles serialization and deserialization of Kubernetes certificate signing request lists to and from JSON. Works with lists of tuples containing strings and certificate signing request data. Used for interacting with Kubernetes API v1beta1 certificate endpoints using JSON format.",
      "description_length": 281,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_stateful_set_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Rolling_update_stateful_set_strategy.t` type, used to define parameters for rolling updates in StatefulSets. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. This is specifically used when configuring or serializing StatefulSet update strategies in Kubernetes manifests.",
      "description_length": 393,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_egress_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a network policy egress rule, used to define allowed outbound traffic from pods in Kubernetes. It provides functions to convert this list to and from JSON format using Yojson, enabling serialization and deserialization for configuration and API interaction. This structure is useful when constructing or parsing Kubernetes network policy specifications that control pod egress traffic based on ports and target destinations.",
      "description_length": 493,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Key_to_path.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-path mappings used to project keys from a volume into specific file paths within a container. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, ensuring compatibility with Kubernetes configuration formats. It is used when configuring projected volumes in pod specifications, where each entry maps a key from a ConfigMap or Secret to a desired path in the filesystem.",
      "description_length": 451,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module enables interaction with Kubernetes ControllerRevision resources through HTTP, supporting operations like listing, watching, creating, and deleting revisions in a specific namespace. It provides direct access to Cohttp-based asynchronous requests and integrates with child modules that implement CRUD functionality for ControllerRevision objects using the Kubernetes API v1beta1. Main data types include ControllerRevision and related metadata, with operations allowing retrieval, update, and deletion by name or namespace. Example uses include tracking stateful application revisions and managing rollouts through programmatic access to Kubernetes' revision history.",
      "description_length": 679,
      "index": 593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Statefulsets",
      "library": "kubecaml",
      "description": "This module provides HTTP operations for managing Kubernetes StatefulSets within a namespace, supporting retrieval, creation, and deletion. It works with StatefulSet and StatefulSetList data types, enabling direct interaction with stateful application deployments. The status submodule monitors and updates StatefulSet statuses via GET, PUT, and PATCH, while the scale submodule adjusts replica counts dynamically using `Scale.t`. Examples include deploying new StatefulSets, patching statuses after failures, or scaling replicas in response to load changes.",
      "description_length": 558,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Policy_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of policy rules paired with string identifiers, primarily used for defining access control policies in Kubernetes RBAC v1beta1. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. This structure is useful when working with role-based access control configurations, such as defining permissions for roles or cluster roles.",
      "description_length": 397,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Tcp_socket_action.Object",
      "library": "kubecaml",
      "description": "This module handles TCP socket actions by encoding and decoding JSON representations of socket configurations. It works with lists of string-socket action pairs, converting them to and from Yojson format. Use this module when serializing or deserializing TCP socket action data for Kubernetes API interactions.",
      "description_length": 310,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_list.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes Deployment objects, where each Deployment is associated with a string identifier. It provides functions to convert the collection to and from JSON format using the Yojson library, enabling serialization and deserialization for storage or transmission. This structure is used when managing multiple Deployments in a single unit, such as when retrieving or updating a group of Deployments from a cluster.",
      "description_length": 452,
      "index": 597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to `Limit_range.t` values, representing resource usage limits for Kubernetes namespaces. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is used to enforce resource constraints, such as memory and CPU limits, on containers within a Kubernetes cluster.",
      "description_length": 370,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Weighted_pod_affinity_term.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Weighted_pod_affinity_term, used to define pod affinity rules in Kubernetes scheduling. It provides functions to serialize and deserialize this structure to and from JSON using Yojson. This data is used to influence node selection by assigning weights to affinity terms based on pod labels and topology.",
      "description_length": 374,
      "index": 599,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_spec.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and each value is a `Replica_set_spec.t` record, representing a collection of replica set specifications. It provides functions to convert this list structure to and from JSON format using `Yojson.Safe.t`. This structure is typically used to manage multiple named replica set configurations in Kubernetes API interactions.",
      "description_length": 395,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of horizontal pod autoscaler configurations to and from JSON format. It works with a list of string and horizontal pod autoscaler pairs, enabling structured storage and retrieval of autoscaling policies. It is used when persisting or transmitting Kubernetes autoscaling configurations in JSON, such as during API interactions or configuration file handling.",
      "description_length": 415,
      "index": 601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Vsphere_virtual_disk_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of vSphere virtual disk volume source objects to and from JSON format. It operates on a list-based structure pairing strings with `Vsphere_virtual_disk_volume_source.t` values. Use this module when converting vSphere volume configurations to JSON for API requests or parsing them from API responses.",
      "description_length": 357,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module observes CronJob resources within a Kubernetes namespace, offering real-time tracking of job lifecycle events, status updates, and deletions. It supports filtering with label and field selectors, maintains resource versions for consistency, and handles pagination for large datasets. Developers can monitor overall CronJob activity or focus on specific named jobs to trigger actions based on creation, updates, or removals. Example uses include auto-scaling systems reacting to scheduled job loads or dashboards displaying live CronJob status changes.",
      "description_length": 563,
      "index": 603,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Role_list objects to and from JSON format. It operates on a list of key-value pairs where each value is a Role_list structure. It is used to convert Role_list data for storage, transmission, or integration with JSON-based APIs.",
      "description_length": 288,
      "index": 604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Non_resource_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of non-resource rules in the Kubernetes authorization API, where each rule is a tuple of a string and a `Non_resource_rule.t` value. It provides functions to convert this list structure to and from JSON format using `Yojson.Safe.t`. This module is used to serialize and deserialize non-resource authorization rules for Kubernetes API interactions.",
      "description_length": 377,
      "index": 605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Daemon_set_update_strategy objects into JSON format. It works with a list of key-value pairs where each value is a Daemon_set_update_strategy.t. It is used to convert between in-memory strategy configurations and their JSON representations, typically for storage or transmission.",
      "description_length": 340,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Id_range.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value defines a range of numeric IDs, using the `Id_range.t` type. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is typically used to specify allowed ID ranges for Kubernetes resources like replicas or pods in extension APIs.",
      "description_length": 356,
      "index": 607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Nfs_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is an NFS volume source configuration. It provides functions to serialize and deserialize these configurations to and from JSON. This module is used to represent NFS mounts in Kubernetes pod specifications, where each entry corresponds to a named NFS volume source.",
      "description_length": 328,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Replica_set_status` values, enabling representation of Kubernetes ReplicaSet status objects. It provides JSON serialization and deserialization functions via `to_yojson` and `of_yojson` for interacting with Kubernetes API responses. This structure is used to decode or encode ReplicaSet status information, such as observed generation, replica counts, and conditions, during cluster state inspection or reconciliation loops.",
      "description_length": 491,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Controller_revision.Object",
      "library": "kubecaml",
      "description": "This module provides functions to convert a list of string and Controller_revision pairs to and from Yojson format. It works with lists of tuples containing strings and Controller_revision records, enabling serialization and deserialization for storage or transmission. Concrete use cases include persisting controller revision data to disk or sending it over a network in a structured format.",
      "description_length": 393,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_tls.Object",
      "library": "kubecaml",
      "description": "This module represents a list of TLS configurations for Ingress resources, where each entry pairs a string identifier with an Ingress_tls.t value. It provides serialization and deserialization to and from JSON using Yojson, enabling direct interaction with Kubernetes API payloads. It is used when configuring or parsing TLS settings for Ingress objects in Kubernetes extensions v1beta1.",
      "description_length": 387,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Toleration.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Toleration, used to define how a pod tolerates node taints in Kubernetes. It provides functions to convert this list to and from JSON format using Yojson. A concrete use case is serializing and deserializing pod specifications that include tolerations for node scheduling.",
      "description_length": 343,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_field_selector.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to resource field selectors, enabling precise CPU and memory resource queries. It provides JSON serialization and deserialization for interacting with Kubernetes API objects. Use this module to construct and manipulate resource field selectors for pod or container resource constraints in Kubernetes manifests.",
      "description_length": 373,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_projection.Object",
      "library": "kubecaml",
      "description": "This module handles the conversion of Config_map projection data structures to and from JSON format. It works with lists of string and Config_map_projection tuples, using Yojson for serialization and deserialization. Concrete use cases include encoding Config_map projections into JSON for API requests and decoding JSON responses into structured data for further processing.",
      "description_length": 375,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces.By_namespace.Rolebindings",
      "library": "kubecaml",
      "description": "This module manages RoleBinding resources in a Kubernetes namespace, combining core operations for listing and filtering with submodules that implement detailed CRUD functionality. It centers around data types like `Role_binding.t` and `Role_binding_list.t`, enabling dynamic access control management such as granting user permissions or revoking outdated bindings. The API supports standard Kubernetes query parameters for filtering and watching, while child modules handle concrete actions like creating, updating, or deleting specific RoleBinding objects using the RBAC v1alpha1 API.",
      "description_length": 587,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of token review objects used for authenticating tokens in Kubernetes. It works with lists of string and token review type pairs, converting them to and from JSON format. Concrete use cases include processing authentication requests in webhook token authenticators and validating user identities in API server integrations.",
      "description_length": 380,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_file_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to Azure File volume source configurations, enabling representation of multiple Azure File mounts. It provides JSON serialization and deserialization functions for converting between native OCaml and JSON formats. This structure is used when configuring Kubernetes pod volumes that reference Azure File Service storage, allowing pods to access persistent storage during orchestration.",
      "description_length": 447,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Pod objects with operations to serialize and deserialize them to and from JSON. It works with Pod definitions structured as key-value pairs, where each key is a string identifier and the value is a Pod specification. Concrete use cases include parsing and generating JSON representations of Pod lists for API interactions or configuration files.",
      "description_length": 389,
      "index": 618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Resource_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of resource rules for Kubernetes authorization, where each rule pairs a resource name with its associated permissions. It provides serialization and deserialization to and from JSON using `Yojson`, enabling direct interaction with Kubernetes API payloads. It is used when defining or parsing role-based access control (RBAC) policies for API resources in a cluster.",
      "description_length": 401,
      "index": 619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes LimitRange objects, where each entry is a tuple of a string and a LimitRange list. It provides functions to convert this structure to and from JSON format using Yojson. This module is used to handle collections of LimitRange definitions in Kubernetes API interactions.",
      "description_length": 312,
      "index": 620,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of PodDisruptionBudget objects to and from JSON. It works with a list of key-value pairs where each value is a PodDisruptionBudget definition. It is used to persist or transmit Kubernetes policy configurations in JSON format.",
      "description_length": 279,
      "index": 621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes ClusterRoleBinding resource by name. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and label selectors, returning a result indicating success or failure of the watch event. The module works directly with Kubernetes API objects like Watch_event and ClusterRoleBinding, handling streaming updates over HTTP using Cohttp.",
      "description_length": 439,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Subject.Object",
      "library": "kubecaml",
      "description": "This module serializes and deserializes subject objects to and from JSON format, specifically handling mappings of string keys to subject definitions. It operates on the `t` type, which is a list of tuples pairing strings with subject references. Use this module when converting RBAC role bindings to JSON for storage or transmission, or when parsing incoming JSON into subject data structures for policy evaluation.",
      "description_length": 416,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Load_balancer_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of load balancer status data structured as a list of key-value pairs, where each value conforms to the load balancer status definition. It provides `to_yojson` and `of_yojson` functions for converting between JSON representations and OCaml values. This module is used when interacting with Kubernetes API responses that describe the status of load balancer resources.",
      "description_length": 425,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module watches for changes to a specific Kubernetes ClusterRole by name, using a streaming HTTP request. It supports operations like `get` to initiate or continue watching, with parameters for filtering events by resource version, labels, or fields. Concrete use cases include monitoring role updates in real-time for security auditing or dynamic access control adjustments.",
      "description_length": 379,
      "index": 625,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes events keyed by strings, providing serialization and deserialization to and from JSON. It works with lists of event objects, where each event captures a state change in the cluster. Use this module when handling event streams from the Kubernetes API, particularly for structured logging, monitoring, or debugging cluster activity.",
      "description_length": 380,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_peer.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of network policy peer data structures to and from JSON format. It works with a list of key-value pairs where each value conforms to the Network_policy_peer type. It is used to convert network policy peer configurations to JSON for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 360,
      "index": 627,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module tracks changes to NetworkPolicy resources within a Kubernetes namespace, enabling real-time monitoring and event-driven responses. It supports filtering by label selectors, field selectors, and resource versions, with a `get` function to retrieve current policy states or stream updates. Developers can use it to detect and react to policy creation, modification, or deletion, facilitating dynamic network configuration adjustments. Example usage includes triggering security rule updates or auditing policy changes as they occur.",
      "description_length": 542,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Watch.Mutatingwebhookconfigurations.By_name",
      "library": "kubecaml",
      "description": "Implements watching changes to MutatingWebhookConfiguration resources by name, supporting operations like `get` with parameters for filtering and streaming updates. Works directly with Kubernetes API request paths and Cohttp for handling HTTP requests and responses. Useful for monitoring specific mutating webhook configurations in real time, such as tracking updates or deletions of a particular configuration in a cluster.",
      "description_length": 425,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Resource_attributes.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of resource authorization attributes into JSON format. It works with a list of tuples, where each tuple contains a string key and a resource attributes record. It is used to convert authorization data to and from JSON representations when interacting with Kubernetes API authorization endpoints.",
      "description_length": 349,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module manages Kubernetes RBAC roles within a namespace, offering direct HTTP operations to list, create, and delete Role resources. It structures interactions using types like `Role`, `Role_list`, and `Status`, and supports fine-grained control through submodules that implement REST-level actions such as partial updates and deletions by namespace and name. Use it to automate role creation for access control or audit existing roles in a cluster.",
      "description_length": 454,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_port.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of network policy port objects to and from JSON format. It works with a list of tuples, where each tuple contains a string and a network policy port type. Use this module when converting network policy port data for API communication or storage.",
      "description_length": 303,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_subset.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each key is a string and the value is an `Endpoint_subset` structure, commonly used to define groups of network endpoints in Kubernetes. It provides functions `to_yojson` and `of_yojson` for converting this list to and from JSON format, facilitating serialization and deserialization of endpoint data. A typical use case involves processing Kubernetes API responses that include named endpoint subsets for services.",
      "description_length": 470,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Persistentvolumeclaims",
      "library": "kubecaml",
      "description": "This module monitors changes to PersistentVolumeClaims in a namespace, supporting label and field selectors, timeout controls, and resource version tracking to enable dynamic provisioning or alerting workflows. It provides a `watch` function for broad namespace-level monitoring and a child module for watching a specific named claim. The child module's `get` function allows detailed, real-time tracking of individual PersistentVolumeClaim updates with customizable parameters. Together, they offer both broad and targeted visibility into storage claim activity within a Kubernetes cluster.",
      "description_length": 591,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Session_affinity_config.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of session affinity configuration objects to and from JSON format. It works with a list of tuples pairing strings with session affinity configuration values. Use this module when converting session affinity settings to JSON for storage or transmission, or when parsing such configurations from JSON input.",
      "description_length": 363,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Aggregation_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of labeled ClusterRole references used to aggregate roles in Kubernetes RBAC. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used to define which ClusterRoles should be combined into a single ClusterRole based on label selectors.",
      "description_length": 316,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Host_path_volume_source.Object",
      "library": "kubecaml",
      "description": "This module serializes and deserializes host path volume source objects to and from JSON. It works with lists of string and host path volume source pairs. Use this module when persisting or parsing Kubernetes pod specifications that include host path volumes.",
      "description_length": 259,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes Pod specification as a list of key-value pairs, where each value is a Pod_spec.t. It provides functions to convert the structure to and from JSON format, specifically using the Yojson library. This module is used to serialize or deserialize Kubernetes Pod definitions for configuration or API interaction.",
      "description_length": 341,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Namespaces.By_namespace.Podpresets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes PodPreset resources within a namespace, offering operations to list, create, and delete collections of PodPreset objects using types like PodPresetList and standard API parameters such as namespace and label selector. Its REST submodule supports fine-grained interactions including get, put, delete, and patch for individual PodPresets, enabling tasks like enforcing default pod configurations or updating presets dynamically. You can use it to deploy or clean up presets programmatically before launching pods. Specific operations include applying a new preset, retrieving existing ones by label, or removing outdated configurations.",
      "description_length": 665,
      "index": 639,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_volume_source.Object",
      "library": "kubecaml",
      "description": "This module serializes and deserializes a list of key-value pairs, where each value is a `Secret_volume_source`, to and from JSON format. It works with `Yojson.Safe.t` for JSON representation and processes data structures that map string keys to secret volume configurations. It is used to convert Kubernetes secret volume definitions to JSON for API interactions or configuration files.",
      "description_length": 387,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of cluster roles, where each entry is a tuple of a string and a cluster role structure. It provides `to_yojson` and `of_yojson` functions for converting between the internal representation and JSON format. It is used when interacting with Kubernetes RBAC APIs to manage and transfer cluster role data in JSON.",
      "description_length": 377,
      "index": 641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Resource_metric_status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each key is a string and each value conforms to the `Resource_metric_status.t` type, enabling structured handling of Kubernetes resource metric statuses. It provides functions to serialize (`to_yojson`) and deserialize (`of_yojson`) these metric status objects to and from JSON format. It is used to interpret or generate Kubernetes API responses related to resource-based autoscaling metrics like CPU or memory usage.",
      "description_length": 473,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Object_reference.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes object references to and from JSON format. It works with a list of tuples containing strings and object reference structures. Use this module when converting object reference data for API communication or storage.",
      "description_length": 281,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flex_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Flex_volume_source` type, representing a generic volume configuration for Kubernetes. It provides `to_yojson` and `of_yojson` functions to serialize and deserialize this list structure to and from JSON. This is used when configuring flexible storage volumes in Kubernetes that are managed by external plugins, allowing dynamic attachment and provisioning of storage resources.",
      "description_length": 445,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module tracks changes to Horizontal Pod Autoscaler resources within a Kubernetes namespace, streaming real-time events for autoscaler configuration updates and scaling actions. It provides filtering by namespace, label selector, and resource version, allowing precise monitoring of autoscaler behavior. The `get` function streams events for targeted autoscalers, such as detecting when an autoscaler adjusts a deployment based on metric thresholds. For example, it can monitor a specific autoscaler by name to observe scaling decisions as they occur.",
      "description_length": 555,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Watch.Volumeattachments.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving VolumeAttachment resources by name in Kubernetes's storage v1beta1 API. It supports operations like `get` with parameters for filtering, resource versioning, and streaming updates via watch. This module handles detailed queries on VolumeAttachment objects, returning structured watch events or error information.",
      "description_length": 347,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_node_affinity.Object",
      "library": "kubecaml",
      "description": "This module represents a list of node affinity constraints for volume accessibility, where each constraint is a key-value pair. It provides functions to convert the structure to and from JSON format using `to_yojson` and `of_yojson`. This module is used to define which nodes can access a particular volume based on node labels.",
      "description_length": 328,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time observation of Kubernetes workload resources within a namespace, tracking changes to Deployments, ControllerRevisions, DaemonSets, ReplicaSets, and StatefulSets. It supports filtering via label and field selectors, resource versioning, and customizable timeouts, with operations to watch specific resources by name or capture broad event streams. Examples include monitoring Deployment rollouts, tracking ControllerRevision updates, observing DaemonSet lifecycle events, triggering alerts on ReplicaSet scaling, and inspecting StatefulSet configuration changes as they occur. Each resource type offers both high-level and targeted tracking through dedicated submodules and `get` functions.",
      "description_length": 720,
      "index": 648,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Rbd_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and each value represents a Rados Block Device (RBD) volume configuration. It provides functions to serialize (`to_yojson`) and deserialize (`of_yojson`) this list structure to and from JSON format. It is used to manage RBD volume sources in Kubernetes pod specifications, enabling integration with Ceph storage systems through concrete JSON representations.",
      "description_length": 431,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Namespaces.By_namespace.Jobs",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Job resources within a namespace, offering operations to list, watch, create, and delete jobs using standard API types like `Job`, `Job_list`, and `Status`. It supports precise control over job configurations and execution states, enabling automation of lifecycle tasks and batch job monitoring. The child module extends this functionality by focusing on status-specific operations, allowing inspection and targeted updates to job execution states without modifying the full configuration. Together, they support use cases such as real-time job tracking and automated state adjustments via Kubernetes API patterns.",
      "description_length": 645,
      "index": 650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Scale_spec.t` type, used to define scaling configurations for Kubernetes extensions. It provides `to_yojson` and `of_yojson` functions for converting between JSON and the internal OCaml representation. This structure is typically used when working with Kubernetes custom resources that require scaling logic, such as horizontal pod autoscalers.",
      "description_length": 416,
      "index": 651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_status.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to daemon set status values, enabling direct manipulation of key-value pairs representing node-specific statuses. It provides JSON serialization and deserialization functions for converting between in-memory representations and external JSON formats. This is used to process and persist the distributed state of daemon sets across cluster nodes.",
      "description_length": 408,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Taint.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of taints associated with Kubernetes nodes, where each taint is a key-value pair combined with a taint effect. It provides functions to serialize and deserialize these taints to and from JSON format, specifically using the Yojson library. This structure is used when managing node taints to control pod scheduling in a Kubernetes cluster.",
      "description_length": 374,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Resourcequotas.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ResourceQuotas in a specific namespace, supporting core REST operations\u2014get, put, delete, and patch\u2014for full lifecycle control. It operates directly on Resource_quota and Delete_options types, enabling precise interactions with the Kubernetes API. The status submodule extends this functionality by offering get, put, and patch operations specifically for updating and retrieving ResourceQuota status information. Together, they allow tasks like creating a quota, modifying its constraints, or updating its observed state in the cluster.",
      "description_length": 568,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of cron jobs into JSON format. It works with a list of key-value pairs where each value is a cron job structure. Use this module when converting cron job collections to and from JSON for storage or transmission.",
      "description_length": 279,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of StatefulSet objects in Kubernetes API version v1beta1. It provides functions to convert the list to and from JSON format using Yojson, enabling serialization and deserialization for storage or transmission. The module works directly with lists of StatefulSet objects, supporting operations needed for interacting with Kubernetes' stateful workload management system.",
      "description_length": 399,
      "index": 656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod Security Policy List objects to and from JSON format. It works with a list of tuples, each containing a string and a Pod Security Policy List value. It is used to convert Kubernetes policy data to a wire format for API communication or storage.",
      "description_length": 309,
      "index": 657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_device.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping raw block devices within containers, where each value is a `Volume_device.t`. It provides `to_yojson` and `of_yojson` functions for converting between JSON and the list-based device mapping structure. This is used when defining or parsing device mappings in Kubernetes pod specifications.",
      "description_length": 345,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to Pod_template.t values, representing a collection of named pod templates. It provides functions to convert this list to and from JSON format using Yojson, ensuring structured serialization and deserialization. This module is used to manage multiple pod template definitions within Kubernetes configurations, such as when handling deployments or replica sets that require reusable pod specifications.",
      "description_length": 463,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Http_ingress_path.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of HTTP ingress path objects to and from JSON format. It works with a list of tuples, where each tuple consists of a string and an HTTP ingress path structure. Concrete use cases include converting ingress path configurations to JSON for storage or transmission, and parsing JSON input into structured data for processing ingress rules.",
      "description_length": 394,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Host_alias.Object",
      "library": "kubecaml",
      "description": "This module represents a list of hostname-to-IP mappings for Kubernetes pod hosts files. It provides JSON serialization and deserialization for the list type. Use this module when configuring pod networking with custom host entries in Kubernetes manifests.",
      "description_length": 256,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Scale_io_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Scale_io volume source objects to and from JSON format. It works with a list of tuples containing strings and Scale_io volume source records. It is used to convert Scale_io volume configurations to JSON for storage or transmission, and to parse such configurations from JSON input.",
      "description_length": 338,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Resource_quota_status, providing serialization and deserialization to and from JSON. It works with lists of tuples pairing strings with Resource_quota_status records, enabling structured handling of Kubernetes resource quota data. Use this module when parsing or generating Kubernetes API responses involving resource quota statuses in JSON format.",
      "description_length": 419,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Namespaces.By_namespace.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module manages Horizontal Pod Autoscaler resources within a Kubernetes namespace, providing HTTP operations to list, create, and delete autoscalers using the V2beta1 API version. It works directly with `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list` data types, supporting full CRUD operations and status-specific updates through its child module. You can use it to programmatically adjust autoscaling policies for deployments or stateful sets, retrieve current autoscaler states, or update scaling thresholds in response to system load. The integration with typed REST operations enables precise, real-time control over autoscaling behavior using standard Kubernetes API patterns.",
      "description_length": 703,
      "index": 664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_egress_rule.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of network policy egress rule objects to and from JSON format. It works with associative lists mapping strings to network policy egress rule values. Concrete use cases include converting egress rule configurations to JSON for storage or transmission and parsing JSON-encoded egress rules from Kubernetes API responses.",
      "description_length": 372,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each key is a string and each value is a `Pod_preset_spec.t`. It provides functions `to_yojson` and `of_yojson` for converting this list to and from JSON format. This structure is used to group and serialize pod preset specifications under string identifiers, typically for configuration or API serialization purposes.",
      "description_length": 373,
      "index": 666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_account.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of service account objects into JSON format. It works with a list of tuples, each containing a string and a service account definition, enabling structured data exchange. It is used to convert service account configurations to and from JSON for storage or transmission.",
      "description_length": 327,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_anti_affinity.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of pod anti-affinity rule lists to and from JSON. It works with lists of tuples containing strings and pod anti-affinity rule values. Use this module when converting pod anti-affinity configurations to JSON for storage or transmission, or when parsing such configurations from JSON input.",
      "description_length": 342,
      "index": 668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Lifecycle.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of lifecycle event handlers for containers, mapping event names to their corresponding lifecycle actions. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used to define behavior such as actions to execute when a container starts or stops, specifically in Kubernetes pod specifications.",
      "description_length": 377,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes daemon sets, where each daemon set is stored as a key-value pair with a string identifier. It provides functions to convert the list to and from JSON format using the `Yojson` library, enabling serialization and deserialization for storage or transmission. This structure is used when retrieving or updating multiple daemon sets through the Kubernetes API.",
      "description_length": 400,
      "index": 670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Pods_metric_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes autoscaling metric source definitions for per-pod metrics. It works with associative lists mapping strings to `Pods_metric_source.t` values, converting them to and from JSON format. It is used to configure horizontal pod autoscalers based on metrics like requests per second per pod.",
      "description_length": 351,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_affinity.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of pod affinity rules mapped to keys, used for defining scheduling constraints in Kubernetes. It provides functions to convert the structure to and from JSON format, specifically for serializing and deserializing affinity configurations. It is used when configuring pod scheduling policies that depend on the presence or absence of other pods on nodes.",
      "description_length": 388,
      "index": 672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Serviceaccounts.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes service accounts within a specific namespace. It handles HTTP requests to get, put, delete, and patch service account resources using Cohttp for communication and Kubernetes API definitions for serialization. Concrete use cases include managing service account identities and access controls in a cluster by directly interacting with the API server.",
      "description_length": 403,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module manages ReplicaSet resources within a Kubernetes namespace, supporting lifecycle operations like listing, creating, and deleting ReplicaSets via HTTP requests. It works with core Kubernetes API objects such as ReplicaSet and ReplicaSetList, enabling direct interaction with the API for deployment and cleanup tasks. The module also includes submodules for fine-grained control, allowing retrieval, replacement, and patching of ReplicaSet configurations, as well as managing status and scale subresources. Specific operations include updating replica counts, inspecting operational state, and applying configuration changes programmatically.",
      "description_length": 652,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of PodDisruptionBudget status objects into JSON format. It works with a list of key-value pairs where each value is a PodDisruptionBudget status. It is used to convert raw JSON data from Kubernetes API responses into a structured OCaml representation and vice versa.",
      "description_length": 324,
      "index": 675,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Daemonsets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes DaemonSet resources within a namespace, supporting operations like listing existing DaemonSets, creating new ones, and deleting them through HTTP requests. It works directly with types such as `Daemon_set`, `Daemon_set_list`, and `Status`, and allows filtering and control via query parameters. The status submodule extends this by enabling inspection and modification of runtime state, such as observed generation and pod counts. Combined, they support full lifecycle management of DaemonSets, from deployment to status tracking and cleanup.",
      "description_length": 573,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Stateful_set objects into JSON format. It works with a list-based structure where each element is a tuple of a string and a Stateful_set record. Concrete use cases include converting Stateful_set configurations to JSON for storage or transmission, and parsing JSON input into typed Stateful_set data for programmatic manipulation.",
      "description_length": 391,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_env_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Secret_env_source` used to inject secret data as environment variables. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON representations. It is used when configuring Kubernetes Pods to source environment variables from Secrets.",
      "description_length": 344,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named ConfigMap objects as a list of key-value pairs, where each value conforms to the ConfigMap specification. It provides functions to serialize and deserialize this collection to and from JSON format using Yojson. This structure is used to manage multiple ConfigMap definitions in a Kubernetes API context, such as when handling configuration data for deployment in a cluster.",
      "description_length": 418,
      "index": 679,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of volume attachment source objects into JSON format. It works with a list of string and volume attachment source pairs, using Yojson for conversion. Concrete use cases include encoding and decoding volume attachment configurations for Kubernetes storage operations.",
      "description_length": 324,
      "index": 680,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module provides HTTP operations for managing Kubernetes ControllerRevision resources in a specific namespace, supporting list, create, and delete-collection actions with customizable query parameters and structured type handling. Its child module extends this functionality with full CRUD support, allowing get, put, patch, and delete operations on individual ControllerRevisions using a base URI and common parameters like `pretty`, `ctx`, and `headers`. Together, they enable detailed management of stateful application revisions in a cluster, using Kubernetes API v1beta2 types. For example, you can list all ControllerRevisions with label filters, create a new revision for a stateful application, or delete outdated revisions to manage versioned states.",
      "description_length": 763,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Endpoints.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing Kubernetes Endpoints resources within a specific namespace. It supports get, put, delete, and patch methods to retrieve, replace, remove, or update Endpoints objects by name. The module works directly with Kubernetes API V1 Endpoints definitions and standard HTTP request parameters like namespace, name, and headers.",
      "description_length": 369,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_address.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is an `Endpoint_address.t` tuple representing an IP address. It provides functions to serialize and deserialize these pairs to and from JSON format. This structure is used to manage network endpoint addresses in Kubernetes API interactions, specifically handling IP address representations within resource definitions.",
      "description_length": 381,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Security_context.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to security context configurations, used to define container-level security settings in Kubernetes. It provides functions to convert these mappings to and from JSON format using Yojson. This structure is typically used when specifying security policies for containers within Kubernetes pods, where each entry corresponds to a named container's security configuration.",
      "description_length": 432,
      "index": 684,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_rules_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of SelfSubjectRulesReview objects to and from JSON. It works with lists of tuples pairing strings with SelfSubjectRulesReview values. Concrete use cases include converting authorization rule review data for transmission over HTTP or storage in JSON format.",
      "description_length": 310,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of self-subject access review objects to and from JSON. It works with a list of key-value pairs where each value is a self-subject access review structure containing user action permissions across namespaces. It is used to encode or decode access review responses for API interactions, ensuring correct JSON formatting during transmission.",
      "description_length": 393,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_stateful_set_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Rolling_update_stateful_set_strategy.t` type, used to define parameters for rolling updates in StatefulSets. It provides `to_yojson` and `of_yojson` functions for serializing and deserializing these strategy objects to and from JSON. This is specifically used when configuring or parsing rolling update strategies in Kubernetes StatefulSet specifications.",
      "description_length": 427,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role.Object",
      "library": "kubecaml",
      "description": "This module defines a list of cluster role objects, where each element is a tuple of a string and a cluster role. It provides functions to convert this list to and from JSON format using Yojson. This structure is used to manage collections of cluster roles, typically for serialization and deserialization during API interactions.",
      "description_length": 330,
      "index": 688,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of pod status objects into JSON format. It works with a list of key-value pairs where each value is a pod status. It is used to convert pod status data to and from JSON representations for storage or transmission.",
      "description_length": 271,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of node conditions in a Kubernetes cluster, where each condition is a key-value pair with a string identifier and a structured node condition value. It provides functions to serialize and deserialize these collections to and from JSON format using Yojson. This module is used to manage and persist node state information, such as health or readiness, in a structured and type-safe way.",
      "description_length": 421,
      "index": 690,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes ConfigMap objects paired with string keys. It operates on the type `t`, which is a list of tuples containing a string and a ConfigMap list structure. It provides direct conversion to and from JSON using `to_yojson` and `of_yojson`, enabling straightforward persistence and retrieval of grouped ConfigMap data.",
      "description_length": 391,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Object_metric_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes object metric source definitions used for horizontal pod autoscaling. It works with associative lists mapping strings to object metric source configurations, using Yojson for JSON encoding and decoding. Concrete use cases include converting between in-memory representations and JSON payloads when interacting with Kubernetes API for autoscaling based on object metrics like Ingress throughput.",
      "description_length": 462,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes Secret objects to and from JSON format. It operates on a list of tuples, each containing a string key and a Secret value. It is used to convert Secret data structures to JSON for storage or transmission, and to parse JSON input into structured Secret objects.",
      "description_length": 331,
      "index": 693,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of certificate signing request specifications into JSON format. It works with a list of tuples, each containing a string key and a certificate signing request specification value. It is used to convert between in-memory representations of Kubernetes CSR specs and their JSON-encoded forms for storage or transmission.",
      "description_length": 375,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Kubernetes Job configuration. It provides functions to convert this list to and from JSON format using Yojson. This structure is used to manage multiple named Job configurations in a serializable form, suitable for storage or transmission.",
      "description_length": 307,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs mapping string identifiers to StatefulSet condition records, capturing the state of Kubernetes StatefulSets at specific points. It provides functions to convert this structured data to and from JSON format, using `to_yojson` and `of_yojson`. This is used when serializing or deserializing StatefulSet status information for storage or transmission in Kubernetes API interactions.",
      "description_length": 434,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Secrets.By_name",
      "library": "kubecaml",
      "description": "This module implements direct access to Kubernetes Secret resources within a specific namespace. It supports CRUD operations through `get`, `put`, `delete`, and `patch` functions, each interacting with the Kubernetes API via Cohttp requests. The module handles Secret objects and related control structures like Delete_options and Patch, enabling precise management of secrets in a cluster.",
      "description_length": 390,
      "index": 697,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes Namespace_spec objects to and from JSON format. It operates on a list-based structure where each element is a tuple of a string and a Namespace_spec value. It is used to convert Namespace_spec data to JSON for storage or transmission, and to parse JSON input into structured Namespace_spec objects for further processing.",
      "description_length": 393,
      "index": 698,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of container states keyed by strings, used to manage and manipulate the state of containers in a Kubernetes environment. It provides functions to convert this collection to and from JSON format, ensuring proper serialization and deserialization for use in API interactions. Concrete use cases include handling container lifecycle events and state transitions within Kubernetes pods.",
      "description_length": 418,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Client_ip_config.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and each value is a `Client_ip_config` configuration. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to represent and manipulate session affinity configurations based on client IP in Kubernetes services.",
      "description_length": 354,
      "index": 700,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_status.Object",
      "library": "kubecaml",
      "description": "This module represents the observed status of a Kubernetes Deployment as a list of key-value pairs, where each value is a Deployment_status type. It provides functions to convert this structure to and from JSON format using Yojson. This module is used to serialize and deserialize Deployment status information for interaction with Kubernetes APIs or storage systems.",
      "description_length": 367,
      "index": 701,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Pod_preset objects into JSON format. It works with a list of key-value pairs where each value is a Pod_preset definition. It is used to convert Pod_preset configurations to and from JSON for storage or transmission.",
      "description_length": 276,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes ReplicaSet objects in version v1beta2 of the Apps API. It provides functions to convert the list to and from JSON format using the Yojson library. This module is used to manage collections of ReplicaSet resources when interacting with Kubernetes clusters programmatically.",
      "description_length": 316,
      "index": 703,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume.Object",
      "library": "kubecaml",
      "description": "This module defines a list of named volumes for use in Kubernetes pod specifications, where each volume is associated with a name. It provides functions to convert the list to and from JSON format, specifically using the `Yojson.Safe.t` type for serialization and deserialization. This structure is used when defining pod configurations that require multiple named volumes to be referenced by containers.",
      "description_length": 404,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Controller_revision_list.Object",
      "library": "kubecaml",
      "description": "This module handles JSON serialization and deserialization for a list of Controller_revision objects, represented as an associative list mapping strings to Controller_revision_list values. It provides `to_yojson` and `of_yojson` functions to convert between the structured data type and JSON format. This is used when interacting with Kubernetes API endpoints that return or require Controller_revision list data in JSON.",
      "description_length": 421,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Rbd_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of RBD persistent volume source objects to and from JSON format. It works with a list of tuples, where each tuple contains a string and an RBD persistent volume source configuration. It is used to convert RBD volume specifications to JSON for storage or transmission, and to parse such specifications from JSON input.",
      "description_length": 375,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module tracks CronJob resources in Kubernetes namespaces, providing real-time event streams for creation, update, and deletion events. It supports filtering with label and field selectors, resource versioning, and limit controls for efficient monitoring. Specific CronJobs can be targeted for detailed lifecycle tracking, allowing actions like detecting status changes or alerting on new matching CronJobs. For example, it can trigger notifications when a CronJob's schedule changes or when a job fails to schedule.",
      "description_length": 520,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Apiservices.By_name.Status",
      "library": "kubecaml",
      "description": "This module provides a `put` function to update the status of a specific Kubernetes API service by name, using a predefined request path template. It operates on `Api_service.t` data structures, which represent the state and configuration of API services in the Kubernetes aggregator layer. A concrete use case is updating the availability or endpoints of a registered API service during dynamic reconfiguration.",
      "description_length": 412,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Local_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a `Local_volume_source.t` instance, representing storage configurations with node affinity. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. This is used when serializing or deserializing Kubernetes pod specifications that reference locally attached storage volumes.",
      "description_length": 383,
      "index": 709,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes namespace objects as key-value pairs, where each key is a namespace name and the value is the corresponding namespace configuration. It provides functions to serialize and deserialize this collection to and from JSON format using Yojson. This structure is used to manage and persist multiple namespace definitions in a Kubernetes cluster context.",
      "description_length": 396,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_port.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of endpoint port objects to and from JSON format. It works with a list of tuples where each tuple consists of a string and an endpoint port type. Concrete use cases include converting endpoint port data for API communication and persisting endpoint configurations in a structured format.",
      "description_length": 345,
      "index": 711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes Job resources in a namespace, enabling real-time tracking of job creation, updates, and deletions. It supports filtering by labels and fields, with configurable timeouts, resource versions, and pagination. Key operations include `get`, which starts a watch on a specific job, and event stream handling for lifecycle tracking. Use cases include detecting failed jobs immediately or monitoring job completion status in real time.",
      "description_length": 459,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1.Watch.Volumeattachments.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving VolumeAttachment resources by name in Kubernetes's storage API. It supports operations like `get` with parameters for filtering, timeouts, and resource versions, returning watch events for changes to specific VolumeAttachment objects. Useful for monitoring lifecycle events of storage volume attachments in cluster management tools.",
      "description_length": 367,
      "index": 713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of network policy objects to and from JSON format. It works with a list of tuples pairing strings with network policy definitions. Concrete use cases include converting network policy configurations to JSON for storage or transmission and parsing JSON input into structured network policy data.",
      "description_length": 352,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Ceph_fs_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of CephFS volume source objects into JSON format. It works with a list of key-value pairs where each value is a CephFS volume source configuration. It is used to convert Kubernetes pod specifications with CephFS mounts to and from JSON for storage or transmission.",
      "description_length": 322,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Affinity.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping string keys to `Affinity` values, used to define scheduling constraints for Kubernetes pods. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is typically used when specifying node or pod affinity rules in Kubernetes deployment configurations.",
      "description_length": 356,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Metric_status.Object",
      "library": "kubecaml",
      "description": "This module represents metric status information as a list of key-value pairs, where each key is a string identifier and the value is a metric status object. It provides functions to convert this structure to and from JSON format using Yojson. It is used to serialize and deserialize metric status data for autoscaling operations in Kubernetes.",
      "description_length": 344,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a `Component_status.t` record, used to store and manage cluster validation information in Kubernetes. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is specifically used to serialize and deserialize component status data when interacting with Kubernetes APIs or persisting cluster state.",
      "description_length": 426,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Horizontal Pod Autoscaler resources within a specific namespace, supporting event streaming for lifecycle changes such as scaling actions and configuration updates. It provides filtering via `label_selector`, synchronization using `resource_version`, and the ability to track specific autoscalers by name with optional timeout parameters. Main data types include autoscaler configurations and event streams, with operations for establishing and refining watch connections. For example, it can stream scaling events for all autoscalers in a namespace or focus on a single autoscaler with custom timeout settings.",
      "description_length": 655,
      "index": 719,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a component condition, used to describe the state of Kubernetes system components. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is typically used for unmarshaling and marshaling component status data when interacting with the Kubernetes API.",
      "description_length": 382,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling.V1alpha1.Priority_class.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of priority class objects into JSON format. It works with a list of tuples, each containing a string and a priority class value. It is used to convert priority class data to and from JSON representations for storage or transmission.",
      "description_length": 290,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Non_resource_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of non-resource rules in the Kubernetes authorization API, where each rule is a tuple of a string and a `Non_resource_rule.t` value. It provides functions to convert this list structure to and from JSON format using `Yojson.Safe.t`. This module is used to define authorization policies for non-resource endpoints in Kubernetes, such as API paths and HTTP verbs.",
      "description_length": 391,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs mapping string identifiers to Daemon_set_condition values, describing the state of DaemonSets at specific points. It provides functions to convert this collection to and from JSON format using Yojson, enabling serialization and deserialization for storage or transmission. This structure is used when managing or inspecting the conditions of DaemonSets within a Kubernetes cluster, particularly during status reporting or reconciliation processes.",
      "description_length": 502,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer_configuration.Object",
      "library": "kubecaml",
      "description": "This module handles JSON serialization and deserialization for initializer configurations in the Kubernetes API. It works with lists of key-value pairs where values are initializer configuration objects. Use this module when interacting with Kubernetes admission registration APIs that require structured configuration data in JSON format.",
      "description_length": 339,
      "index": 724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_status.Object",
      "library": "kubecaml",
      "description": "This module represents the status of containers within a Kubernetes pod, providing serialization and deserialization to and from JSON format. It works with a list of tuples, each associating a string key with a `Container_status.t` value. Use this module to interpret or generate container status data when interacting with Kubernetes API responses or when persisting state information in a JSON-based format.",
      "description_length": 409,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of certificate signing request status objects into JSON format. It operates on a list of key-value pairs where each value is a certificate signing request status. It is used to convert between in-memory representations and JSON data for storage or transmission.",
      "description_length": 319,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Non_resource_attributes.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Non_resource_attributes.t` values, used to represent contextual metadata for non-resource authorization checks. It provides JSON serialization and deserialization functions via `to_yojson` and `of_yojson` for interacting with external systems or storage. Concrete use cases include handling authorization context data in Kubernetes API requests, particularly for non-resource endpoints like `/api` or `/healthz`.",
      "description_length": 479,
      "index": 727,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of job status objects in the Kubernetes API, specifically converting between JSON representations and OCaml values. It works with a list of string-job status pairs and uses Yojson for JSON encoding and decoding. Concrete use cases include parsing job status responses from Kubernetes API servers and generating JSON payloads for status updates.",
      "description_length": 402,
      "index": 728,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a rolling update specification for Kubernetes deployments. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This module is used to serialize and deserialize rolling update configurations for deployment management in Kubernetes.",
      "description_length": 349,
      "index": 729,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Ingress objects into JSON format. It works with a list of tuples, where each tuple consists of a string and an Ingress_list.t value, representing structured Kubernetes ingress data. It is used to convert ingress configurations to and from JSON for storage or transmission, specifically within the Kubernetes API extensions v1beta1 context.",
      "description_length": 421,
      "index": 730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_image.Object",
      "library": "kubecaml",
      "description": "This module represents a list of container image definitions, where each entry is a tuple of a string and a container image configuration. It provides serialization and deserialization functions to convert between JSON format and the internal OCaml representation. This structure is used to manage multiple container images within Kubernetes resource specifications, such as pod or deployment configurations.",
      "description_length": 408,
      "index": 731,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_status.Object",
      "library": "kubecaml",
      "description": "This module represents the object structure of a horizontal pod autoscaler's status in Kubernetes, specifically mapping string keys to corresponding status values. It provides serialization and deserialization functions to and from JSON using `Yojson.Safe.t`, ensuring compatibility with Kubernetes API expectations. This module is used when interacting with Kubernetes API endpoints to retrieve or update the current state of horizontal pod autoscalers.",
      "description_length": 454,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes Resource_quota objects to and from JSON format. It works with a list of key-value pairs where each value is a Resource_quota.t, representing namespace-specific resource constraints. It is used to convert resource quota specifications to JSON for storage or transmission, and to parse such specifications from JSON input.",
      "description_length": 388,
      "index": 733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Git_repo_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure where each element is a tuple of a string and a Git repository volume source configuration. It provides functions to convert this structure to and from JSON format using Yojson. This is specifically used to handle multiple named Git repository volume definitions within Kubernetes pod specifications.",
      "description_length": 343,
      "index": 734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_status.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes Namespace status entries as key-value pairs, where each key is a string identifier and the value holds detailed status information. It provides functions to serialize and deserialize this collection to and from JSON format using Yojson. This structure is used to process or inspect the current state of multiple Kubernetes Namespaces in a cluster.",
      "description_length": 397,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Deployments with their associated metadata, providing serialization and deserialization to and from JSON format. It works with Deployment objects structured as pairs of strings and Deployment records. Use this module when managing multiple Deployments, such as when retrieving or persisting Deployment configurations in a JSON-based storage system.",
      "description_length": 381,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_backend.Object",
      "library": "kubecaml",
      "description": "This module defines a list of tuples where each tuple pairs a string with an `Ingress_backend.t` value, representing service endpoints for routing traffic. It provides functions to convert this list structure to and from JSON format using `Yojson.Safe.t`. This structure is used to configure ingress routing rules by mapping service names to their respective backend configurations.",
      "description_length": 382,
      "index": 737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Namespaces.By_namespace.Cronjobs",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CronJob resources within a namespace, offering functions to list, create, and delete CronJobs through HTTP requests. It operates on CronJob and CronJobList data types, supporting use cases like scheduling periodic jobs and managing batch processing workflows. The module includes a status submodule for inspecting and updating a CronJob's runtime state, enabling precise control over both configuration and execution. Together, these components provide a full interface for managing CronJobs via REST, allowing tasks such as scheduling workloads and modifying job policies.",
      "description_length": 604,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of network policy objects into JSON format, specifically working with a list of string and network policy tuples. It provides `to_yojson` and `of_yojson` functions for converting between in-memory representations and JSON data. Concrete use cases include persisting network policy configurations to disk or transmitting them over a network in a serialized form.",
      "description_length": 419,
      "index": 739,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Job_template_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of job template specifications into JSON format. It works with a list of tuples, each containing a string and a job template spec, using the Yojson library for JSON manipulation. It is used to convert job template data to and from JSON representations, typically for storage or transmission purposes.",
      "description_length": 358,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_spec.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of key-value pairs, where each value is a `Limit_range_spec.t`, to and from JSON format. It provides `to_yojson` and `of_yojson` functions for converting this list structure to and from `Yojson.Safe.t` representations. This is used when working with Kubernetes API objects that need to be persisted or transmitted as JSON, ensuring correct encoding and decoding of resource limit specifications.",
      "description_length": 463,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a rolling update specification for Kubernetes deployments. It provides functions to convert this list to and from JSON format using the Yojson library. This structure is used to define and serialize deployment update strategies in Kubernetes API interactions.",
      "description_length": 328,
      "index": 742,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_list.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of a list of horizontal pod autoscaler objects to and from JSON format. It works with associative lists mapping strings to horizontal pod autoscaler list values. Concrete use cases include converting configuration data for Kubernetes horizontal pod autoscalers to JSON for storage or transmission, and parsing such JSON back into structured data for programmatic manipulation.",
      "description_length": 430,
      "index": 743,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes RBAC roles as an associative list mapping strings to role lists. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. This structure is used to manage and persist collections of RBAC roles in a Kubernetes configuration.",
      "description_length": 308,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods.By_name",
      "library": "kubecaml",
      "description": "This module provides direct access to Pod resources within a namespace, supporting CRUD operations through `get`, `put`, `delete`, and `patch` functions. It works with core Kubernetes types such as Pod, DeleteOptions, and Patch, enabling tasks like retrieving Pod details, applying configuration updates, and managing deletion grace periods. The module's submodules extend this functionality with specialized operations: retrieving and modifying Pod status, streaming logs with custom filters, forwarding ports for debugging, executing commands interactively, proxying HTTP requests to pod endpoints, creating bindings to assign Pods to nodes, evicting Pods for rescheduling, and attaching to running containers for real-time interaction. Together, these capabilities allow fine-grained control over Pod lifecycle and communication in cluster management workflows.",
      "description_length": 864,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Aggregation_rule.Object",
      "library": "kubecaml",
      "description": "This module represents a list of labeled ClusterRole references used to aggregate roles in Kubernetes RBAC. It provides JSON serialization and deserialization for the list structure. Use this module when building or processing ClusterRole aggregation rules that include labeled selectors.",
      "description_length": 288,
      "index": 746,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Service_reference.Object",
      "library": "kubecaml",
      "description": "This module defines a list of tuples where each tuple pairs a string with a `Service_reference` type, representing named service references in Kubernetes admission registration configurations. It provides functions to convert this list structure to and from JSON format using the Yojson library. This is used specifically for serializing and deserializing service reference data when interacting with Kubernetes API objects.",
      "description_length": 424,
      "index": 747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Se_linux_options.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each key is a string and the value is an Se_linux_options object, used to apply SELinux labels to containers. It provides functions to convert this structure to and from JSON format. This is specifically used when configuring Kubernetes pod security policies with SELinux options.",
      "description_length": 332,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to `Scale.t` values, representing multiple scaling requests for different resources. It provides functions to convert this list to and from JSON format using `Yojson.Safe.t`. This structure is used to handle batch scaling operations across various resources in an autoscaling context.",
      "description_length": 346,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Namespaces.By_namespace.Poddisruptionbudgets",
      "library": "kubecaml",
      "description": "This module manages PodDisruptionBudget resources in a Kubernetes namespace, supporting retrieval, creation, and deletion of budgets to enforce availability constraints during maintenance or failures. It works with PodDisruptionBudget and PodDisruptionBudgetList data types, offering operations to list all budgets, create new ones, and delete multiple budgets at once. The child module adds fine-grained REST operations including get, put, delete, and patch by name, along with status-specific actions to independently retrieve and update a budget's status field. Together, they enable both broad and precise control over disruption policies, such as applying a new budget during a deployment or adjusting an existing budget's status during cluster maintenance.",
      "description_length": 762,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to Kubernetes ClusterRole objects by name, providing a `get` function to stream events for a specific ClusterRole. It supports filtering with label and field selectors, resource versioning, and timeout controls. Use this to monitor real-time updates to a ClusterRole in a Kubernetes cluster.",
      "description_length": 319,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review_spec.Object",
      "library": "kubecaml",
      "description": "This module represents the object structure for a token review specification in the Kubernetes authentication API. It provides serialization and deserialization functions to convert between JSON and OCaml data structures. It is used to validate and process token authentication requests in Kubernetes API interactions.",
      "description_length": 318,
      "index": 752,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Deployment objects from the deprecated `extensions/v1beta1` Kubernetes API version, where each entry is a tuple of a string and a Deployment configuration. It provides functions to serialize the list to JSON (`to_yojson`) and deserialize it from JSON (`of_yojson`). This module is used when working with legacy Kubernetes Deployment definitions, particularly for reading from or writing to YAML/JSON manifests that follow the older API schema.",
      "description_length": 476,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_var.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of environment variable objects used in Kubernetes container definitions. It operates on a list of tuples where each tuple contains a string key and an environment variable definition. It is used to convert between OCaml representations and JSON formats when configuring container environments in Kubernetes manifests.",
      "description_length": 376,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_account_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Kubernetes Service_account objects, represented as a list of key-value pairs where each value is a Service_account. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. Use this module when working with Kubernetes service account data in JSON, such as when interacting with the Kubernetes API or storing configuration files.",
      "description_length": 442,
      "index": 755,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Gce_persistent_disk_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of GCE Persistent Disk volume source objects to and from JSON format. It works with a list-based structure where each entry pairs a string key with a `Gce_persistent_disk_volume_source.t` value. It is used when configuring Kubernetes volumes that reference existing GCE PDs, ensuring proper formatting for API interactions.",
      "description_length": 381,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Run_as_user_strategy_options.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each pair consists of a string and a `Run_as_user_strategy_options` value. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to define user identity settings for Kubernetes pod security policies, specifically in extension API versions.",
      "description_length": 365,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Serviceaccounts",
      "library": "kubecaml",
      "description": "This module monitors ServiceAccount resources across a namespace, enabling real-time tracking of changes with support for label and field selectors, custom resource versions, and pagination. It provides a `watch` function for dynamic updates and includes a child module that focuses on individual ServiceAccounts through a `get` function, which streams events for specific accounts. The primary data types are ServiceAccount resources and event streams, with operations allowing filtering, retrieval, and real-time monitoring. You can use it to detect when a ServiceAccount's secrets are updated or to track access changes across multiple accounts in a namespace.",
      "description_length": 663,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of pod conditions as key-value pairs, where each key is a string identifier and the value is a pod condition object. It provides functions to convert this collection to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to track and serialize the current state of conditions affecting a pod, such as readiness or scheduling status, for use in monitoring and orchestration workflows.",
      "description_length": 446,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Cinder_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Cinder volume source configuration. It provides functions to convert this list to and from JSON format using Yojson. This structure is used to specify multiple Cinder volumes in Kubernetes pod specifications, enabling their attachment and configuration in OpenStack environments.",
      "description_length": 347,
      "index": 760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Deployment specification. It provides functions to convert this list to and from JSON format. It is used to manage multiple Deployment configurations in a structured way, such as when handling grouped Deployments in a Kubernetes cluster.",
      "description_length": 308,
      "index": 761,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_affinity_term.Object",
      "library": "kubecaml",
      "description": "This module represents a list of labeled pod affinity terms, each defining co-location constraints for pods based on label selectors and topology keys. It provides functions to serialize and deserialize these constraints to and from JSON format. It is used to enforce scheduling rules that ensure pods run on the same or different nodes based on specified label matches.",
      "description_length": 370,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rollback_config.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of rollback configuration entries, where each entry is a tuple of a string and a rollback configuration value. It provides `to_yojson` and `of_yojson` functions for converting between JSON and OCaml representations. Use this module when working with Kubernetes extension v1beta1 rollback configurations in JSON format, particularly for parsing or generating configuration data.",
      "description_length": 445,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_reference.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list mapping between string keys and secret reference definitions. It works with associative lists pairing strings with `Secret_reference.t` values, converting them to and from JSON format using `to_yojson` and `of_yojson`. This is used to persist or transmit configurations that link named identifiers to Kubernetes secrets across namespaces.",
      "description_length": 406,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Role_list objects to and from JSON format. It operates on a list of key-value pairs where each value is a Role_list.t. It is used to convert Role_list data to JSON for storage or transmission, and to parse JSON back into structured Role_list objects.",
      "description_length": 311,
      "index": 765,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of horizontal pod autoscaler objects, where each entry is a tuple of a string and a corresponding autoscaler structure. It provides `to_yojson` and `of_yojson` functions for converting between the internal OCaml representation and the JSON format used in Kubernetes API interactions. It is used when managing or transmitting collections of horizontal pod autoscaler configurations in a Kubernetes cluster.",
      "description_length": 473,
      "index": 766,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to `Network_policy_spec` values, providing direct serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used to handle collections of network policy specifications in a structured format. A concrete use case is parsing and generating Kubernetes network policy lists from JSON input, such as when loading configuration files or interacting with the Kubernetes API.",
      "description_length": 466,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Pods_metric_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes autoscaling metric status data, specifically for per-pod metrics. It works with a list of tuples, where each tuple pairs a string identifier with a `Pods_metric_status.t` value. This module is used to convert metric status data to and from JSON format, enabling integration with Kubernetes API operations that require structured metric reporting.",
      "description_length": 418,
      "index": 768,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes events as a collection of key-value pairs, where each key is a string and the value is an `Event_list` structure. It provides functions to convert this event list to and from JSON format using the Yojson library. This module is used to handle event data returned by the Kubernetes API, such as listing events related to a specific resource or namespace.",
      "description_length": 397,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Allowed_flex_volume.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Allowed_flex_volume` values, enabling representation and manipulation of allowed Flexvolume configurations. It provides JSON serialization and deserialization functions for working with these configurations in external formats. Use this module to manage policy definitions that specify permitted Flexvolume drivers and their parameters within Kubernetes.",
      "description_length": 421,
      "index": 770,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template_list.Object",
      "library": "kubecaml",
      "description": "This module defines a list of Pod templates, where each template is associated with a string identifier. It provides functions to serialize and deserialize these template lists to and from JSON format. This structure is used to manage multiple Pod template configurations within Kubernetes API interactions.",
      "description_length": 307,
      "index": 771,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Watch.Certificatesigningrequests.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving CertificateSigningRequest resources by name in Kubernetes's certificates v1beta1 API. It provides `get` to stream changes using watch parameters and path construction via `request_path_template`. Useful for monitoring specific certificate signing requests with customizable timeouts, resource versions, and selectors.",
      "description_length": 352,
      "index": 772,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of token review status objects used in Kubernetes API authentication. It works with a list of tuples containing strings and token review status values, converting them to and from JSON format. This is specifically used for processing authentication token reviews in Kubernetes API interactions.",
      "description_length": 352,
      "index": 773,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to Kubernetes ClusterRoleBinding resources by name. It provides a `get` function to stream ClusterRoleBinding events with options like resource version, label selectors, and timeouts, returning a result with a Watch_event. Use it to monitor specific ClusterRoleBinding updates in real time, such as tracking role binding changes for audit or synchronization tasks.",
      "description_length": 392,
      "index": 774,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling.V1alpha1.Priority_class_list.Object",
      "library": "kubecaml",
      "description": "This module handles JSON serialization and deserialization for a list of priority classes, represented as an associative list mapping strings to priority class data. It operates on the `t` type, which pairs string keys with priority class structures. Use this module when converting priority class collections to and from JSON format, such as when interacting with Kubernetes API endpoints or storing configuration data.",
      "description_length": 420,
      "index": 775,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Pod Security Policy objects, represented as a list of key-value pairs where each value is a Pod Security Policy. It provides `to_yojson` and `of_yojson` functions for converting this list to and from JSON format. It is used when interacting with Kubernetes API endpoints that require or return Pod Security Policy List resources in JSON.",
      "description_length": 408,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a StatefulSet update strategy definition. It provides functions to convert this list to and from JSON format using Yojson. This module is used to serialize and deserialize StatefulSet update strategy configurations for storage or transmission.",
      "description_length": 312,
      "index": 777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module provides comprehensive management of Kubernetes Deployment resources within a namespace, combining direct operations like `get`, `put`, `patch`, and `delete` with subresource manipulation for status and scaling. It centers on the `Deployment` type and supports full lifecycle control, such as deploying new configurations, rolling back revisions, and programmatically adjusting replica counts using the `Scale` type from autoscaling/v1. The API enables precise interaction with Kubernetes endpoints via customizable HTTP requests, returning typed results in Lwt promises. Specific use cases include inspecting rollout progress, replacing existing deployments, and managing scaling subresources directly through structured operations.",
      "description_length": 745,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Ingress_status objects into JSON format. It works with a list of key-value pairs where each value is an Ingress_status type, representing the current state of Kubernetes Ingress resources. It is used to convert Ingress_status data to and from JSON for storage, transmission, or inspection.",
      "description_length": 350,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Csi_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to Csi_persistent_volume_source values, enabling representation of multiple CSI volume sources. It provides serialization and deserialization functions to and from JSON using Yojson, ensuring compatibility with Kubernetes API expectations. This structure is used when configuring persistent volumes backed by external CSI drivers in Kubernetes manifests.",
      "description_length": 417,
      "index": 780,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Aws_elastic_block_store_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of AWS EBS volume source objects to and from JSON format. It works with a list of key-value pairs where each value conforms to the AWS EBS volume source definition. Use this module when converting AWS EBS volume configurations to JSON for storage or transmission, or when parsing such configurations from JSON input.",
      "description_length": 374,
      "index": 781,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Controller_revision.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Controller_revision objects into JSON format, specifically working with lists of string and Controller_revision pairs. It provides `to_yojson` and `of_yojson` functions for converting these objects to and from `Yojson.Safe.t` representations. This is used when interacting with Kubernetes APIs that require JSON encoding, such as storing or retrieving Controller_revision data in etcd or during API requests.",
      "description_length": 469,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Ingresses",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Ingress resources within a specific namespace, providing functions to list, create, and delete Ingress objects with support for filtering and configuration via query parameters. It works with core types like Ingress and Ingress_list, and includes submodules for fine-grained operations such as `get`, `put`, `delete`, and `patch` on routing rules, TLS settings, and resource configurations. The status submodule enables retrieval and modification of Ingress status subresources, such as load balancer details. These capabilities support full lifecycle management of Ingress objects using Cohttp for API server communication.",
      "description_length": 655,
      "index": 783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_config_source.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of node configuration source objects to and from JSON format. It works with lists of string-Node_config_source pairs, enabling structured representation and parsing of node configuration data. Concrete use cases include converting node configuration sources for API communication and persisting node configuration state in a structured format.",
      "description_length": 397,
      "index": 784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Storage_os_volume_source.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value conforms to the Storage_os_volume_source specification, enabling structured representation of StorageOS volumes in Kubernetes. It provides functions to serialize and deserialize this list structure to and from JSON format. This module is used to configure StorageOS volumes within Kubernetes persistent volume claims by mapping volume parameters to a structured format consumable by the API.",
      "description_length": 454,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Networkpolicies",
      "library": "kubecaml",
      "description": "This module manages Kubernetes NetworkPolicy resources within a namespace, supporting REST operations like list, create, and delete over HTTP with customizable parameters. It handles v1beta1 network policy definitions directly, returning results as either parsed responses or watch streams. The child module extends this with fine-grained CRUD actions\u2014such as `get`, `put`, and `patch`\u2014to manipulate individual policies by name, enabling tasks like modifying ingress rules or removing deprecated policies. Together, they provide a complete interface for network policy management using Cohttp for communication and structured Kubernetes API interactions.",
      "description_length": 654,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_address.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of node addresses in a Kubernetes cluster, where each address is associated with a string key. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, handling structured data of type `(string * Node_address.t) list`. It is used to manage and exchange node address information, such as IP addresses or hostnames, in a format compatible with Kubernetes API interactions.",
      "description_length": 447,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rolling_update_daemon_set.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes daemon set rolling update specifications to and from JSON format. It works with a list of key-value pairs where each value is a rolling update configuration. Concrete use cases include converting daemon set update policies to JSON for API requests and parsing JSON responses into typed OCaml values for safe manipulation.",
      "description_length": 389,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Replicationcontrollers",
      "library": "kubecaml",
      "description": "This module provides scaling capabilities for Kubernetes replication controllers by interacting directly with scale definitions and patch objects. It supports retrieving, replacing, or partially updating replica counts within a namespace through `get`, `put`, and `patch` operations. These functions enable dynamic adjustments to workloads, such as increasing replicas during traffic surges or modifying scale settings incrementally. Example uses include automating replica changes in response to metrics or integrating with custom autoscaling logic.",
      "description_length": 550,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Probe.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of named probes used to define health checks for containers in Kubernetes. It provides functions to convert the list of probes to and from JSON format, enabling integration with Kubernetes API operations. It is used when configuring pod specifications to determine container readiness and liveness.",
      "description_length": 334,
      "index": 790,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Namespaces.By_namespace.Localsubjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles creation of LocalSubjectAccessReview resources within a specific Kubernetes namespace. It provides a `post` function to submit access review requests and a `request_path_template` for path generation. The module works directly with LocalSubjectAccessReview objects, targeting use cases like checking user or group permissions for specific resources in a namespace.",
      "description_length": 384,
      "index": 791,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_rules_review_status.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of subject rules review status data structured as a list of tuples, each containing a string and a subject rules review status value. It provides `to_yojson` and `of_yojson` functions for converting this data to and from JSON format. This is used to interface with Kubernetes authorization APIs, specifically when evaluating access rules for subjects in a cluster.",
      "description_length": 418,
      "index": 792,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Eviction.Object",
      "library": "kubecaml",
      "description": "This module defines a list of eviction requests associated with specific pods, where each request is a tuple of a pod name and an eviction policy. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, enabling interaction with Kubernetes API endpoints that handle eviction subresources. It is used when managing pod evictions programmatically, such as triggering or validating evictions under policy constraints.",
      "description_length": 456,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_list.Object",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes replication controllers, where each controller is paired with a string identifier. It provides functions to convert the list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used when managing or serializing groups of replication controllers in a Kubernetes system.",
      "description_length": 337,
      "index": 794,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Attached_volume.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to `Attached_volume` values, where each entry corresponds to a storage volume attached to a node in a Kubernetes cluster. It provides functions `to_yojson` and `of_yojson` for converting this list to and from JSON format, enabling serialization and deserialization for use in API interactions or configuration files. A concrete use case is managing node-level volume attachments during cluster state synchronization or persistent storage operations.",
      "description_length": 514,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review_spec.Object",
      "library": "kubecaml",
      "description": "This module represents the object structure for a token authentication request in the Kubernetes API. It provides functions to convert the structure to and from JSON format using `to_yojson` and `of_yojson`. It is used to validate and process token-based authentication reviews in Kubernetes authentication flows.",
      "description_length": 313,
      "index": 796,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Allowed_host_path.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each key is a string and the value is an `Allowed_host_path` definition, used to specify allowed host volume paths in Kubernetes policies. It provides functions to convert this list to and from JSON format using `Yojson`. This structure is used when defining pod security policies that restrict host volume mounts to specific paths.",
      "description_length": 387,
      "index": 797,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Allowed_flex_volume.Object",
      "library": "kubecaml",
      "description": "This module defines a list-based structure mapping string keys to `Allowed_flex_volume` values, enabling representation and manipulation of Flexvolume configurations. It provides JSON serialization and deserialization functions for working with these configurations in external formats. Use this module to manage allowed Flexvolume entries in Kubernetes extension settings, particularly when integrating with storage plugins requiring flexible volume support.",
      "description_length": 459,
      "index": 798,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a replication controller condition. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to track and serialize the conditions affecting the state of replication controllers in Kubernetes.",
      "description_length": 329,
      "index": 799,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Webhook.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of webhook objects into JSON format. It works with a list of tuples, each containing a string and a webhook definition. Concrete use cases include converting webhook configurations to JSON for storage or transmission and parsing incoming JSON data into structured webhook objects for processing.",
      "description_length": 353,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of daemon set objects into JSON format. It works with a list of key-value pairs where each value is a daemon set configuration. It is used to convert daemon set data to and from JSON representations for storage or transmission.",
      "description_length": 281,
      "index": 801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Object_field_selector.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an `Object_field_selector`, used to select specific API-versioned fields from Kubernetes objects. It provides functions to convert the structure to and from JSON format, enabling integration with Kubernetes API interactions that require field selection. Concrete use cases include constructing and parsing field selectors for Kubernetes object metadata or status fields in API requests.",
      "description_length": 455,
      "index": 802,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_rule.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping hostnames to Ingress rule values, enabling the routing of incoming requests based on host and path matches. It provides functions to serialize and deserialize these rule sets to and from JSON format. This structure is used when defining ingress controllers to direct traffic to specific backend services based on the request host and path.",
      "description_length": 393,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Events.By_name",
      "library": "kubecaml",
      "description": "This module provides functions to manage Kubernetes Events within a specific namespace by name, supporting get, put, delete, and patch operations. It works with Event and Delete_options data types defined in the Kubernetes API specifications. Use this module to retrieve, update, delete, or partially modify individual Events in a given namespace.",
      "description_length": 347,
      "index": 804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoints.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of endpoint subsets for a Kubernetes service, where each subset contains IP addresses and ports. It provides functions to serialize and deserialize endpoint data to and from JSON format. It is used to define network endpoints that back a service, enabling service discovery and routing within a cluster.",
      "description_length": 339,
      "index": 805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_error.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a Volume_error, capturing errors from volume operations. It provides functions to convert this list to and from Yojson for serialization and parsing. This structure is used to handle and transmit detailed error information in storage-related Kubernetes API interactions.",
      "description_length": 339,
      "index": 806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes Deployment specification as a list of key-value pairs, where each value is a Deployment specification object. It provides functions to convert this structure to and from JSON format using the Yojson library. This module is used to define and manipulate the desired state of a Kubernetes Deployment resource in a structured and serializable way.",
      "description_length": 380,
      "index": 807,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Runtime.Raw_extension.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of Kubernetes API objects with embedded raw extensions, specifically working with lists of string and raw extension pairs. It provides `to_yojson` and `of_yojson` functions to convert these structures to and from JSON format, ensuring proper handling of plugin types during encoding and decoding. Concrete use cases include working with versioned Kubernetes resources that contain inline, typed extensions such as custom resource definitions or plugin configurations.",
      "description_length": 521,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs where each key is a string and each value is a Daemon_set_condition, capturing the state of a DaemonSet at a specific point. It provides functions to convert the collection to and from JSON format using Yojson. This structure is used to serialize and deserialize DaemonSet condition data for storage or transmission.",
      "description_length": 371,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a daemon set specification. It provides functions to convert this list to and from JSON format. It is used to serialize and deserialize collections of daemon set configurations for storage or transmission.",
      "description_length": 274,
      "index": 810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Resource_attributes.Object",
      "library": "kubecaml",
      "description": "This module represents a list of resource attributes for authorization requests, where each attribute is a tuple of a string and a resource attribute value. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. This structure is used when making authorization decisions based on resource access attributes in Kubernetes API requests.",
      "description_length": 377,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Storage_os_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list-based representation of Storage_os persistent volume resources. It works with associative lists mapping strings to Storage_os persistent volume source configurations. Concrete use cases include converting these configurations to and from JSON format for storage or transmission.",
      "description_length": 346,
      "index": 812,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is a Daemon_set configuration, enabling structured representation and manipulation of multiple daemon sets. It provides serialization to and from JSON using Yojson, ensuring compatibility with JSON-based APIs or storage formats. This is useful when managing multiple daemon set configurations in a Kubernetes environment, such as during deployment or configuration validation.",
      "description_length": 439,
      "index": 813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector_term.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where values are node selector terms, used to define node selection constraints in Kubernetes pod scheduling. It provides functions to convert the structure to and from Yojson for serialization and deserialization. This is specifically used when constructing or parsing Kubernetes pod specifications that require precise node affinity rules.",
      "description_length": 390,
      "index": 814,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace.Replicasets",
      "library": "kubecaml",
      "description": "This module manages ReplicaSet resources in a Kubernetes namespace, supporting retrieval, creation, deletion, and filtering with customizable API requests. It provides direct operations for ReplicaSet definitions using DeleteOptions, Patch, and Lwt promises for typed results. The status submodule allows inspection and modification of operational states, such as updating conditions or observed generations, while the scale submodule controls scaling behavior by adjusting replica counts or retrieving scaling configurations. You can deploy ReplicaSets, monitor their health, and dynamically scale workloads using HTTP interactions with the Kubernetes API.",
      "description_length": 657,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Persistentvolumeclaims.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes PersistentVolumeClaims in a specific namespace, offering direct REST operations to get, put, delete, and patch claims with support for standard parameters like pretty-printing and context configuration. It works with Kubernetes API v1 objects to enable precise control over storage resources in cluster workflows. The status submodule extends this functionality by allowing retrieval, replacement, or partial updates to the status of a claim by name using Cohttp-backed HTTP requests. Together, they provide a focused interface for both full and status-specific management of persistent volume claims.",
      "description_length": 632,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Projected_volume_source.Object",
      "library": "kubecaml",
      "description": "Handles serialization and deserialization of projected volume source objects to and from JSON. Works with lists of key-value pairs where values are projected volume sources. Used for converting Kubernetes volume source configurations to JSON format for API interactions or storage.",
      "description_length": 281,
      "index": 817,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployments within a namespace, offering core operations like listing, creating, and deleting Deployments using standard API objects such as Deployment, Deployment_list, and Status. It supports direct HTTP-based interactions for retrieving, updating, and deleting individual Deployments, along with submodules that handle status checks, scaling, and rollbacks. Key data types include Deployment specifications, Patch objects, and Scale subresources, with operations like `get`, `replace`, `patch`, and `delete`. Examples include deploying new applications, scaling replicas, checking deployment conditions, and initiating rollbacks.",
      "description_length": 663,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to Ingress_spec.t values, used to define ingress configurations in Kubernetes. It provides functions to convert this list to and from JSON format using Yojson. This structure is specifically used to serialize or deserialize ingress specifications for deployment or inspection in Kubernetes environments.",
      "description_length": 368,
      "index": 819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Allowed_host_path.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of a list mapping strings to `Allowed_host_path` values, specifically for representing allowed host volume paths in Kubernetes policies. It works with associative lists where each key is a string and the value defines path constraints. Concrete use cases include converting policy configurations to and from JSON format for storage or transmission.",
      "description_length": 402,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Scale_io_persistent_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Scale_io persistent volume source objects to and from JSON format. It operates on a list of key-value pairs where each value is a Scale_io persistent volume source configuration. It is used to convert raw JSON data into typed OCaml structures for interacting with Kubernetes Scale_io volumes, and vice versa for exporting configurations.",
      "description_length": 398,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of job conditions as key-value pairs, where each value describes the state of a Kubernetes job. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It is used when managing or inspecting the status of batch jobs in a Kubernetes cluster, particularly for tracking conditions like completion or failure.",
      "description_length": 383,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset_list.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of a list of Pod_preset objects, represented as an associative list mapping strings to Pod_preset_list values. It provides `to_yojson` and `of_yojson` functions for converting this structure to and from JSON format. This is used when interacting with Kubernetes API endpoints that require or return PodPresetList resources in JSON.",
      "description_length": 389,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flocker_volume_source.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Flocker volume source objects to and from JSON format. It works with a list of key-value pairs where each value is a Flocker volume source definition. It is used when configuring Kubernetes pod volumes that reference Flocker datasets by name or UUID.",
      "description_length": 311,
      "index": 824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_condition.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a stateful set condition, providing functions to convert the list to and from JSON format. It works with lists of tuples pairing strings with stateful set condition objects, enabling structured data serialization. Concrete use cases include encoding and decoding stateful set condition data for Kubernetes API interactions.",
      "description_length": 392,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_update_strategy.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs mapping strings to Daemon_set_update_strategy values, enabling structured configuration of daemon set update policies. It provides serialization and deserialization functions to and from JSON using Yojson, ensuring compatibility with Kubernetes API specifications. This structure is used when defining or modifying daemon set update strategies in cluster management workflows.",
      "description_length": 422,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_waiting.Object",
      "library": "kubecaml",
      "description": "This module represents the waiting state of a container in the Kubernetes API, specifically handling a list of key-value pairs where each value is a container waiting state. It provides functions to convert this structure to and from Yojson for serialization and deserialization. This is used when interacting with Kubernetes API endpoints to interpret or construct container state information during cluster operations.",
      "description_length": 420,
      "index": 827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta.V1",
      "library": "kubecaml",
      "description": "This module provides structured representations and operations for Kubernetes API interactions, covering resource metadata, selection criteria, status handling, and API discovery. Core data types include label selectors, owner references, timestamps, status responses, and initializer states, with operations to construct, inspect, and serialize these values. Users can filter resources by labels, manage initialization workflows, encode and decode API errors, and handle versioned API groups with network-based routing. Specific examples include building pod selectors for deployments, interpreting API status codes, serializing metadata for resource creation, and directing API clients based on CIDR ranges.",
      "description_length": 709,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of subject access review objects to and from JSON format. It works with lists of tuples containing strings and subject access review structures. It is used to convert access review data for API communication or storage.",
      "description_length": 273,
      "index": 829,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.External_metric_status.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an external metric status. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. It is used to handle external metric data in Kubernetes autoscaling configurations, such as tracking and serializing metrics like queue length or request rate from external sources.",
      "description_length": 379,
      "index": 830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace.Deployments",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Deployment resources within a namespace, providing operations to list, create, and delete Deployments via HTTP requests. It works with data types such as Deployment, Deployment_list, and supports parameters like namespace, label_selector, and resource_version. The status submodule enables health monitoring and condition updates, while the scale submodule allows programmatic adjustment and querying of replica counts. Together, they enable full lifecycle management of Deployments, from configuration and scaling to status tracking.",
      "description_length": 565,
      "index": 831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Local_object_reference.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of local object references within a Kubernetes namespace. It works with a list of tuples pairing strings and `Local_object_reference.t` records, using Yojson for JSON conversion. It is used to manage references to Kubernetes resources like secrets or config maps by name within the same namespace.",
      "description_length": 351,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes RBAC roles indexed by string identifiers, providing serialization and deserialization to and from JSON format. It works with lists of tuples pairing strings with `Role.t` values, aligning with Kubernetes RBAC v1 role definitions. It is used to manage and persist role configurations in a JSON-compatible structure.",
      "description_length": 364,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of daemon set objects into JSON format. It works with a list of key-value pairs where each value is a daemon set configuration. It is used to convert daemon set data to and from JSON representations for storage or transmission.",
      "description_length": 285,
      "index": 834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_series.Object",
      "library": "kubecaml",
      "description": "This module defines a list of key-value pairs where each value is an `Event_series.t` record, representing ongoing events in Kubernetes. It provides functions to serialize and deserialize these event series to and from JSON format using Yojson. This structure is used to track and manage sequences of related events within the Kubernetes API.",
      "description_length": 342,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Limitranges",
      "library": "kubecaml",
      "description": "This module monitors LimitRange resources in a Kubernetes namespace, enabling real-time tracking of quota limits across pods. It supports filtering by labels and fields, and allows control over resource version, timeout, and pagination. The `get` function in the child module establishes a watch stream for a specific LimitRange, returning events for modifications to that resource. Users can observe changes to a named LimitRange, such as tracking updates to memory or CPU limits in a specific namespace.",
      "description_length": 505,
      "index": 836,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace.Podtemplates",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of PodTemplate resources within a namespace, allowing filtered views using label and field selectors, and configurable watch parameters like timeout and resource version. It enables tracking of all PodTemplates or focusing on a specific one through its child module, which offers a `get` function to initiate a watch stream. The core data types include PodTemplate objects and watch configuration parameters, with operations to establish and manage streaming connections. For example, it can trigger configuration reloads or auto-scaling logic based on observed PodTemplate changes in a Kubernetes cluster.",
      "description_length": 648,
      "index": 837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Http_get_action.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is an `Http_get_action` configuration, primarily used for defining HTTP GET probes in Kubernetes pod specifications. It provides serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`, ensuring compatibility with Kubernetes API expectations. Concrete use cases include configuring liveness or readiness probes in container definitions within Kubernetes deployments.",
      "description_length": 461,
      "index": 838,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Storage_class.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of storage class objects to and from JSON format. It works with a list of key-value pairs where each value is a storage class definition. It is used to convert storage class configurations to JSON for storage or transmission and to parse such configurations from JSON input.",
      "description_length": 332,
      "index": 839,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Version.Info.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of version information objects to and from JSON format. It works with a list of tuples, where each tuple contains a string key and a version info value. It is used to encode or decode version metadata structures for storage or transmission in JSON.",
      "description_length": 302,
      "index": 840,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_spec.Object",
      "library": "kubecaml",
      "description": "This module represents a collection of key-value pairs mapping strings to `Service_spec.t` values, enabling structured association of service specifications with identifiers. It provides serialization to and from JSON format using `to_yojson` and `of_yojson`, ensuring compatibility with JSON-based data interchange workflows. This structure is particularly useful for managing multiple named service configurations within Kubernetes deployment contexts.",
      "description_length": 454,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_list.Object",
      "library": "kubecaml",
      "description": "This module handles serialization and deserialization of a list of network policy objects to and from JSON format. It works with a list of tuples, each containing a string and a network policy structure. It is used to convert network policy data for storage or transmission, and to parse such data back into structured form.",
      "description_length": 324,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Object_metric_status.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of Kubernetes object metric status data, specifically mapping string keys to metric status values. It works with associative lists where each entry pairs a string identifier with an object metric status value. This module is used to convert metric status data to and from JSON format, enabling integration with Kubernetes APIs that require structured metric representations.",
      "description_length": 432,
      "index": 843,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_rollback.Object",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs where each value is a deployment rollback configuration. It provides functions to convert this list to and from JSON format using `to_yojson` and `of_yojson`. This structure is used to handle the serialization and deserialization of deployment rollback data when interacting with Kubernetes API versions that support rollback operations.",
      "description_length": 386,
      "index": 844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Mutating_webhook_configuration.Object",
      "library": "kubecaml",
      "description": "This module handles the serialization and deserialization of mutating webhook configurations into JSON format. It works with a list of key-value pairs where each value is a mutating webhook configuration. It is used to convert between in-memory representations and JSON payloads when interacting with Kubernetes admission controllers.",
      "description_length": 334,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces.By_namespace.Roles",
      "library": "kubecaml",
      "description": "This module manages Kubernetes RBAC roles within a namespace, offering operations to list, create, and delete Role resources using the Kubernetes API. It supports filtering and resource control through standard query parameters and works directly with API objects like Role, RoleList, and Status. The REST submodule provides fine-grained access to individual roles via get, put, delete, and patch methods, enabling precise updates and management of role definitions. Examples include synchronizing namespace roles with cluster-wide policies, enforcing access controls, and automating RBAC cleanup during namespace teardown.",
      "description_length": 623,
      "index": 846,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ClusterRoleBindings by name, providing functions to get, put, delete, and patch cluster role bindings using a URI path template. It works with cluster role binding definitions and delete/patch options from the Kubernetes RBAC and meta APIs. This module is used to manage cluster-level role bindings programmatically, such as retrieving or updating a specific binding or removing one during resource cleanup.",
      "description_length": 461,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Limitranges",
      "library": "kubecaml",
      "description": "This module manages Kubernetes LimitRange resources within a namespace, supporting listing, creation, and deletion of LimitRanges using standard Kubernetes API parameters over HTTP. It operates on `Limit_range_list` and `Limit_range` data types and includes functions to retrieve, replace, remove, and partially update individual LimitRange objects by name. Specific operations include fetching all LimitRanges in a namespace, creating a new resource constraint, and deleting a collection of LimitRanges. It directly integrates with the Kubernetes API and provides structured access through types like `Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range.t` and `Delete_options.t`.",
      "description_length": 685,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_list",
      "library": "kubecaml",
      "description": "This module manages collections of volume attachment objects in the Kubernetes API, offering accessors for metadata, kind, and API version while providing operations to construct and convert these collections to and from JSON. The primary type `t` represents a list of tuples pairing string identifiers with volume attachment definitions, enabling structured handling of multiple attachments. Use this module to serialize volume attachment lists for API requests or to parse and manipulate collections from configuration files. The JSON submodule extends this functionality by implementing custom serialization and deserialization logic for these structured lists.",
      "description_length": 664,
      "index": 849,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes daemon sets, handling their construction, access, and serialization. It works with daemon set objects, list metadata, and string fields like API version and kind, enabling operations such as converting lists to and from JSON using Yojson. The module supports managing node-level workloads across clusters, such as log collection and node monitoring, by associating daemon sets with string identifiers in a key-value structure.",
      "description_length": 472,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_account",
      "library": "kubecaml",
      "description": "This module manages Kubernetes service accounts by combining user-facing names, authentication principals, and secret configurations into structured objects. It supports creating and modifying service accounts with metadata, secrets, and image pull policies using types like `Object_meta` and `Local_object_reference`, such as assigning specific tokens or defining container image access. The child module handles JSON serialization and deserialization of service account definitions, enabling data exchange and persistence through structured formats. Together, they allow developers to programmatically configure, store, and retrieve service account settings in a Kubernetes environment.",
      "description_length": 688,
      "index": 851,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale",
      "library": "kubecaml",
      "description": "This module represents scaling requests for Kubernetes resources, providing functions to construct and manipulate scale objects with metadata, API version, and scaling specifications. It supports conversion to and from JSON and includes accessors for fields like status and spec, enabling programmatic scaling of deployments or replicasets via the Kubernetes API. The child module handles multiple scaling requests as a list of key-value pairs, offering JSON serialization and deserialization for use in batched API interactions. Together, they facilitate precise and bulk scaling operations in Kubernetes environments.",
      "description_length": 619,
      "index": 852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_daemon_set",
      "library": "kubecaml",
      "description": "This module defines the configuration for rolling updates of daemon sets in Kubernetes, centered around the `t` type that represents the update strategy. It allows specifying the maximum number of unavailable pods during an update using `Int_or_string` for flexible numeric or percentage-based thresholds, such as ensuring no more than 30% of pods are unavailable at once. The child module handles a list of key-value pairs mapping to rolling update specifications, supporting conversion to and from JSON with Yojson for Kubernetes API interactions. Together, they enable precise control and serialization of daemon set update strategies during deployment.",
      "description_length": 656,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Load_balancer_status",
      "library": "kubecaml",
      "description": "This module represents the status of a load balancer in a Kubernetes environment, providing operations to construct and access a list of ingress points that direct traffic to services. It includes direct functions for manipulating load balancer status data and integrates serialization through a child module that implements `to_yojson` and `of_yojson` for JSON conversion. For example, it can parse Kubernetes API responses into OCaml values or generate JSON payloads for status updates. The main data type is a list of ingress points, each containing key-value metadata such as IP addresses and ports.",
      "description_length": 603,
      "index": 854,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.External_metric_source",
      "library": "kubecaml",
      "description": "This module manages external metric sources for Kubernetes autoscaling, enabling scaling decisions based on non-Kubernetes metrics such as cloud queue lengths or external load balancer QPS. It provides data types to represent metric sources with fields for metric names, selectors, and target values, along with operations to construct, serialize, and access these sources. The child module extends this functionality by organizing multiple metric sources in a list-based structure, mapping string keys to configurations and supporting JSON serialization for integration with external systems. Together, they allow precise configuration of horizontal pod autoscalers using external metrics, enabling dynamic scaling based on real-time data from cloud services or off-cluster systems.",
      "description_length": 783,
      "index": 855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides a structured interface for managing PodDisruptionBudget resources within a Kubernetes namespace, enabling both high-level and fine-grained control. It supports key operations such as listing, creating, and bulk-deleting budgets, as well as REST-level get, put, delete, and patch actions by name. The primary data types are PodDisruptionBudget and PodDisruptionBudgetList, with additional functionality to retrieve and update the status field independently. For example, it can enforce availability constraints during deployments by applying new budgets or adjust existing ones during cluster maintenance.",
      "description_length": 625,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Clusterroles",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes ClusterRole resources, offering a `get` function to stream events with support for timeouts, selectors, and pagination. The `By_name` submodule extends this capability to monitor specific ClusterRoles by name, allowing fine-grained tracking of individual roles. Together, they enable real-time observation of role-based access control changes cluster-wide or per resource. Example use cases include tracking updates to default ClusterRoles or monitoring access policy changes in a multi-tenant environment.",
      "description_length": 552,
      "index": 857,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_status",
      "library": "kubecaml",
      "description": "This module represents the runtime state of a Kubernetes persistent volume claim, with fields like phase, conditions, and capacity. It provides functions to construct, inspect, and serialize status information, including support for JSON conversion via `to_yojson` and `of_yojson`. The child module handles a list of key-value pairs mapping string keys to status values, enabling structured serialization of claim states. Together, they allow developers to programmatically manage and persist the status of storage resources in a cluster.",
      "description_length": 538,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_from_source",
      "library": "kubecaml",
      "description": "This module provides a structured way to define environment variable sources from Kubernetes ConfigMaps and Secrets, with support for key prefixes and optional secret references. It includes operations to construct and access these sources, enabling precise configuration of pod environments from external data. The child module handles serialization and deserialization of these sources, working on lists of key-value pairs where each value is an `Env_from_source` type. Use this module to build and interpret environment configurations in Kubernetes manifests backed by ConfigMaps or Secrets.",
      "description_length": 594,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Daemonsets",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for DaemonSet resources in a Kubernetes cluster. Works with Kubernetes API parameters and returns structured watch events for DaemonSet objects. Useful for monitoring real-time changes to DaemonSets, such as during deployment rollouts or node updates.",
      "description_length": 312,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_status",
      "library": "kubecaml",
      "description": "This module tracks the status of a Pod Disruption Budget, including healthy and disrupted pod counts, allowed disruptions, and optional generation and timestamp data. It supports operations to inspect current health, validate disruption allowances, and check timestamps for deletion issues. The child module handles JSON serialization, converting between API responses and OCaml representations using key-value lists. Together, they enable status analysis and data interchange for Kubernetes PDBs.",
      "description_length": 497,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Storageclasses.By_name",
      "library": "kubecaml",
      "description": "This module implements RESTful operations for managing Kubernetes StorageClass resources by name, including retrieving, replacing, deleting, and patching individual storage classes. It works directly with StorageClass definitions and related metadata types, such as DeleteOptions and Patch. Concrete use cases include programmatically updating storage configurations, enforcing storage policies, and automating cleanup of storage resources in a Kubernetes cluster.",
      "description_length": 464,
      "index": 862,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_subset",
      "library": "kubecaml",
      "description": "This module organizes network endpoints by grouping IP addresses with associated ports, forming a structured representation of reachable service instances. It supports creating, accessing, and serializing endpoint subsets, including tracking readiness states, and provides operations to manipulate and query these groups. The child module extends this functionality by handling collections of named endpoint subsets, enabling structured serialization to JSON for integration with systems like Kubernetes. Example usage includes modeling service endpoints in a cluster, where each endpoint is a combination of an IP and a port, and querying ready endpoints for routing traffic.",
      "description_length": 676,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Volumeattachments.By_name",
      "library": "kubecaml",
      "description": "This module implements RESTful operations for managing Kubernetes VolumeAttachment resources by name. It supports get, put, delete, and patch methods to retrieve, replace, remove, or update VolumeAttachment objects in a Kubernetes cluster. The module works directly with Kubernetes API types such as Volume_attachment and Delete_options, and returns results asynchronously using Lwt.",
      "description_length": 383,
      "index": 864,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_condition",
      "library": "kubecaml",
      "description": "This module models the state of a horizontal pod autoscaler condition with fields like type, status, reason, message, and transition time, enabling precise tracking of Kubernetes autoscaling events. It supports creating, inspecting, and serializing individual conditions, as well as handling lists of conditions through its child module. Use it to programmatically evaluate autoscaler health, diagnose scaling issues, or log condition changes over time. The combination of direct access to condition properties and JSON serialization facilitates integration with monitoring tools and Kubernetes APIs.",
      "description_length": 600,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_spec",
      "library": "kubecaml",
      "description": "This module manages the structure and manipulation of certificate signing request specifications for Kubernetes, focusing on immutable data like username, groups, and usage constraints. It supports creating and parsing base64-encoded PKCS#10 CSRs, enabling integration with Kubernetes authentication workflows. The child module handles JSON serialization and deserialization, converting between in-memory CSR specs and their JSON representations using key-value tuples. Together, they allow users to construct, modify, and serialize certificate requests while enforcing Kubernetes' immutability constraints.",
      "description_length": 607,
      "index": 866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes Resource Quota objects, supporting operations like listing, creating, and updating quotas across namespaces. It provides direct manipulation of resource quota lists with metadata, kind, and API version, along with JSON serialization via `to_yojson` and `of_yojson` for integration with Kubernetes API interactions. The child module focuses on converting lists of resource quotas to and from JSON, representing each quota as a key-value pair. Together, they enable efficient handling and transmission of multiple resource quota definitions in a cluster environment.",
      "description_length": 610,
      "index": 867,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Persistentvolumes.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles status-related operations for Kubernetes PersistentVolumes by name. It provides functions to get, replace, and partially update the status of a PersistentVolume, using HTTP requests with configurable context and headers. The module works directly with Kubernetes API V1 PersistentVolume and Patch data types, targeting specific use cases such as retrieving or modifying the operational state of storage resources in a cluster.",
      "description_length": 446,
      "index": 868,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_binding",
      "library": "kubecaml",
      "description": "This module provides tools for creating and managing role bindings that associate subjects with roles or cluster roles in Kubernetes RBAC. It operates on data types like `Role_binding.t`, `Subject.t`, and `Role_ref.t`, allowing the construction of namespace-scoped bindings that link users or service accounts to permissions. The module supports JSON serialization and metadata access, enabling integration with Kubernetes systems for access control. A list of named role bindings can be managed using the child module, facilitating structured policy configuration and reference.",
      "description_length": 579,
      "index": 869,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Nodes.By_name.Proxy",
      "library": "kubecaml",
      "description": "This module provides direct HTTP access to Kubernetes Node resources through a proxy, supporting standard REST operations like GET, PUT, POST, and DELETE. It works with node names and paths, using `Cohttp` to perform asynchronous requests and returning raw string results. The main operations include querying node status, modifying node configurations, and proxying requests to specific nodes for diagnostics or resource management. Submodule functionality extends this by enabling fine-grained path-based proxying to node-level endpoints, allowing direct interaction with low-level Kubernetes node APIs.",
      "description_length": 605,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Git_repo_volume_source",
      "library": "kubecaml",
      "description": "This module defines a Git repository volume source for Kubernetes, specifying the repository URL, optional revision, and target directory. It supports creating and manipulating volume configurations that populate storage with Git repository contents, ensuring SE Linux relabeling compatibility. The module includes a child structure that handles multiple named Git volume definitions as a list of name-configuration pairs, with JSON serialization and deserialization via Yojson. Use this module to configure and manage Git-based volumes in Kubernetes pod specifications, such as mounting a specific branch or commit into a container's filesystem.",
      "description_length": 646,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_update_strategy",
      "library": "kubecaml",
      "description": "This module defines the update strategy for a DaemonSet, supporting two modes: \"rolling_update\" and \"on_delete\". It provides functions to construct and access the strategy type, including optional rolling update parameters when the strategy is set to rolling update. The child module handles structured configuration of daemon set update policies using key-value pairs and includes JSON serialization and deserialization with Yojson. Together, they enable precise control and persistence of DaemonSet update behaviors in deployment workflows.",
      "description_length": 542,
      "index": 872,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Secret objects, handling both their creation and manipulation through base64-encoded binary data, string-based data, and metadata. It defines the core `t` type for Secret instances and supports conversion to and from JSON via a child module that processes lists of key-value pairs. Operations include setting and retrieving data fields while enforcing size constraints on the total bytes stored. Example uses include securely handling API keys, passwords, and TLS certificates within Kubernetes clusters.",
      "description_length": 535,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and configuration options for Kubernetes services, including fields like cluster IP, ports, selectors, and service type. It supports creating and manipulating service specifications with optional parameters for load balancing, external IPs, and session affinity, enabling precise control over how applications are exposed within or outside a cluster. The child module manages collections of named service specifications, allowing structured association with identifiers and providing JSON serialization for integration with configuration workflows. Use this module to define internal cluster IPs, configure external load balancers, or set up node ports, while leveraging the child module to organize and serialize multiple service configurations.",
      "description_length": 780,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Non_resource_attributes",
      "library": "kubecaml",
      "description": "This module handles non-resource authorization attributes for Kubernetes API requests, capturing HTTP verbs and URL paths to provide authorization context for endpoints like `/api` or `/healthz`. It offers functions to construct, access, and serialize these attributes to and from JSON, enabling integration with external systems. A list-based child module maps string keys to attribute values, supporting structured metadata handling and direct interaction with Kubernetes API authorization checks. Example uses include evaluating access to non-resource URLs and persisting authorization context in serialized formats.",
      "description_length": 619,
      "index": 875,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy",
      "library": "kubecaml",
      "description": "This module defines and manipulates network policy objects that specify allowed network traffic for Kubernetes pods. It provides functions to construct, serialize, and access policies along with their metadata, API version, and specification. The included serialization submodule converts policies to and from JSON, supporting storage and transmission of configurations. Use this module to create and manage precise network access rules for Kubernetes clusters, such as allowing traffic only from specific pods or blocking external connections.",
      "description_length": 544,
      "index": 876,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Replicasets",
      "library": "kubecaml",
      "description": "This module watches for changes to ReplicaSet resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific ReplicaSet resource path, using optional parameters like `watch`, `timeout_seconds`, and `label_selector` to filter and control the event stream. The module works directly with ReplicaSet definitions and WatchEvent types, enabling real-time monitoring of ReplicaSet updates for deployment tracking or auto-scaling logic.",
      "description_length": 462,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector",
      "library": "kubecaml",
      "description": "A node selector represents a logical OR of label queries over nodes, used to define scheduling constraints for pods based on node labels in Kubernetes. It provides operations to construct, access, and serialize node selector terms, with the core data type being a list of tuples containing a string and a node selector. The module supports direct manipulation of these selectors and integrates with Yojson for JSON serialization and deserialization. For example, it enables defining and persisting scheduling policies that match pods to nodes based on label-based criteria.",
      "description_length": 573,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set",
      "library": "kubecaml",
      "description": "This module provides tools for constructing, manipulating, and serializing Kubernetes ReplicaSet objects, ensuring the correct number of pod replicas are maintained. It supports setting metadata, specifications, and status fields, and includes functions to convert ReplicaSet instances to and from JSON for API compatibility. The child module specializes in handling serialization for the deprecated `extensions/v1beta1` API version, enabling reading from and writing to JSON in a list-based structure. Use cases include creating ReplicaSet configurations for deployment management, converting them to JSON for storage, or reconstructing them from JSON input.",
      "description_length": 659,
      "index": 879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_condition",
      "library": "kubecaml",
      "description": "This module models the state of a Kubernetes deployment at a specific time, capturing condition type, status, timestamps, and metadata like reason and message. It provides constructors, accessors, and JSON (de)serialization for individual conditions, while its child module organizes these conditions into key-value mappings for structured serialization. Use it to track deployment health, report progress, or exchange condition data with external systems via JSON. Example: serialize a deployment's rollout status at intervals for auditing or real-time monitoring.",
      "description_length": 565,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time observation and interaction with Kubernetes workloads scoped to a namespace, aggregating events from Deployments, DaemonSets, ReplicaSets, StatefulSets, and ControllerRevisions. It centers around streaming `Watch_event` values, allowing precise filtering by labels, fields, and resource versions, with support for pagination and timeouts. You can track Deployment rollouts, monitor DaemonSet status across nodes, or react to StatefulSet scaling events. Specific operations include detecting configuration changes, observing health updates, and triggering actions based on resource modifications.",
      "description_length": 625,
      "index": 881,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_volume_source",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes volume source backed by a PersistentVolumeClaim (PVC) in the same namespace, enabling pods to mount storage by referencing an existing PVC. It defines a type `t` with fields `claim_name` and `read_only`, and provides operations to construct, access, and serialize instances to and from JSON. The module supports defining pod volumes that dynamically bind to persistent storage, such as mounting a read-only data volume for batch processing. Its JSON handling facilitates integration with Kubernetes APIs by converting PVC volume configurations to structured data or serializing them for transmission.",
      "description_length": 636,
      "index": 882,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_status",
      "library": "kubecaml",
      "description": "This module captures the runtime status of a container in a Kubernetes pod, offering structured access to its operational state, restart count, readiness, and image metadata through types like `t` and `Container_state.t`. It supports inspecting container health, tracking restart events, and retrieving image details for monitoring and debugging. The module includes utilities for converting container status data to and from JSON, enabling seamless interaction with Kubernetes API responses and state persistence. These capabilities allow developers to programmatically assess container conditions and serialize status information for external processing or storage.",
      "description_length": 667,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes list resource containing multiple volume attachment objects, used to manage storage attachments in a cluster. It provides operations to construct, serialize, and access list-level metadata, API version, and individual items, enabling tasks like retrieving or updating collections of volume attachments via the API. The JSON submodule handles conversion between volume attachment lists and JSON format, supporting serialization to transmit data over the API or store configurations, and parsing incoming JSON responses into typed structures for processing.",
      "description_length": 591,
      "index": 884,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Persistentvolumes.By_name",
      "library": "kubecaml",
      "description": "Implements watching and retrieving Kubernetes persistent volume resources by name, supporting operations like `get` with optional parameters for filtering, timeouts, and resource versions. Works directly with persistent volume objects using data types such as `Watch_event.t` and `Uri.t`. Useful for monitoring changes to specific persistent volumes in real-time or querying their state with custom selection and pagination criteria.",
      "description_length": 433,
      "index": 885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node",
      "library": "kubecaml",
      "description": "This module represents Kubernetes worker nodes, providing operations to construct and manipulate node objects with metadata, specifications, and status. It supports JSON serialization via Yojson for integration with API requests and responses, and includes a child module for handling lists of nodes as string-identifier pairs. Use cases include creating node configurations, parsing node data from cluster APIs, and synchronizing node metadata with external systems. The module enables both individual node management and batch operations on node collections.",
      "description_length": 560,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_list",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes RBAC Role objects, providing functions to construct, access, and serialize Role lists with associated metadata, kind, and API version. It supports operations to convert to and from JSON, making it suitable for use in API interactions or configuration management. The main data type is `t`, representing a list of Roles, along with associated metadata, while the child module handles JSON serialization and deserialization. Specific examples include parsing a JSON response from a Kubernetes API endpoint into a structured Role list or converting a batch of Roles into JSON for storage or transmission.",
      "description_length": 651,
      "index": 887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Storage_class",
      "library": "kubecaml",
      "description": "This module provides tools to define and manage storage classes for dynamic volume provisioning in Kubernetes. It supports key operations like specifying provisioners, reclaim policies, and mount options, allowing administrators to configure storage tiers with precise parameters. The module includes functionality to serialize and deserialize storage class definitions to and from JSON, enabling configuration storage and transmission. For example, a cluster administrator can create a storage class for SSD-backed volumes with a custom reclaim policy and later export its configuration to JSON for version control.",
      "description_length": 616,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Namespace resource by name. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and label selectors, returning a result indicating success or failure. Use it to monitor real-time updates to a Namespace, such as tracking its creation, deletion, or modification.",
      "description_length": 375,
      "index": 889,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Watch.Apiservices",
      "library": "kubecaml",
      "description": "This module monitors changes to API services through HTTP requests, supporting streaming updates with customizable parameters like resource version, label selector, and timeout. It parses watch events or error responses, enabling real-time tracking of service lifecycle events. The child module specializes in watching individual Kubernetes API services by name, providing functions to build request paths and perform targeted watches. Together, they allow use cases such as detecting when a specific API service becomes available or reacting to configuration changes in a Kubernetes cluster.",
      "description_length": 592,
      "index": 890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_deployment",
      "library": "kubecaml",
      "description": "This module orchestrates rolling update strategies for Kubernetes deployments by defining parameters like `max_surge` and `max_unavailable`, ensuring controlled pod replacement while maintaining availability. It includes operations to construct, modify, and serialize rolling update configurations, supporting both numeric and percentage-based values. A child module handles lists of key-value rolling update specs, enabling JSON serialization via `to_yojson` and deserialization with `of_yojson` for storage or transmission. Users can, for example, define a deployment strategy that allows 25% surge and 10% unavailability, then serialize it to JSON for use in deployment pipelines.",
      "description_length": 683,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review",
      "library": "kubecaml",
      "description": "This module represents and processes token review requests for Kubernetes authentication, handling token validation and user identification. It defines core types like token specifications, authentication status, and API metadata, with operations to construct, modify, and serialize these structures. The module supports submitting token reviews to the Kubernetes API server and interpreting the responses, including handling lists of token-review pairs in JSON format via Yojson integration. Submodules focus on serialization workflows, enabling efficient conversion between in-memory representations and JSON for token authentication processing.",
      "description_length": 647,
      "index": 892,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1.Priorityclasses.By_name",
      "library": "kubecaml",
      "description": "This module handles direct CRUD operations for Kubernetes PriorityClass resources by name, using HTTP methods to interact with the Kubernetes API server. It works with specific data types such as `Priority_class.t` for representing priority classes and `Delete_options.t` and `Patch.t` for deletion and partial updates. Concrete use cases include retrieving, creating, updating, and deleting individual priority classes in a Kubernetes cluster.",
      "description_length": 444,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_spec",
      "library": "kubecaml",
      "description": "This module structures storage requirements for Kubernetes workloads by defining access modes, resource constraints, and volume bindings. It supports direct creation and manipulation of persistent volume claim specifications, including storage class and capacity settings. The child module handles provider-specific configurations through key-value mappings, enabling integration with different storage backends via JSON serialization. Together, they allow precise declaration and customization of storage needs, such as specifying read-write access and size limits for pod volumes.",
      "description_length": 582,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Controllerrevisions",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Kubernetes controller revisions, supporting filtering by label and field selectors, resource version, and timeout settings. Works with Kubernetes API objects like `Watch_event` and `Uri.t`, handling HTTP requests over a provided context. Useful for real-time monitoring of controller revision changes in a cluster, such as tracking rollouts or stateful set updates.",
      "description_length": 430,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_ingress_rule",
      "library": "kubecaml",
      "description": "This module organizes a collection of ingress rules that define allowed traffic sources and target ports for Kubernetes pods, combining structured data types for peers, ports, and policies into a cohesive system for enforcing network access. It supports operations to build, modify, and validate ingress rules based on IP ranges, pod selectors, and service identifiers, with direct functions to specify port-based restrictions and source-based allowances. The child module handles lists of these rules, enabling JSON serialization and deserialization for use in Kubernetes manifests. Example usage includes defining ingress access for pods from specific namespaces or CIDR ranges, and restricting traffic to HTTPS port 443 unless additional selectors are met.",
      "description_length": 759,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Deployments",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Deployment resources by sending HTTP requests to a provided URI. It supports filtering by label and field selectors, limiting results, and specifying resource versions for consistent watches. A typical use case involves monitoring a cluster for Deployment updates to trigger automated workflows or event-driven actions.",
      "description_length": 365,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for working with Kubernetes scale subresources, focusing on the `replicas` field to specify the desired number of instances. It includes functions to construct a scale specification, retrieve the replicas value, and convert to and from JSON format, enabling seamless integration with Kubernetes APIs. The child module extends this functionality by handling collections of scale specifications, providing `to_yojson` and `of_yojson` for efficient serialization and deserialization. Use these modules when programmatically managing scaling parameters for Kubernetes objects like deployments or stateful sets.",
      "description_length": 655,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Tcp_socket_action",
      "library": "kubecaml",
      "description": "This module defines TCP socket actions for container health checks, allowing specification of endpoints via host and port, with support for numeric or named service ports. It provides functions to create and manipulate socket actions directly, while its child module handles JSON serialization and deserialization of these configurations. Use it to set up TCP-based readiness or liveness probes in Kubernetes, targeting specific container endpoints. The module supports operations like constructing socket actions and converting them to Yojson for API interactions.",
      "description_length": 565,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1.Storageclasses.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes StorageClass resources by name, including `get`, `put`, `delete`, and `patch` functions. It works directly with StorageClass definitions and Delete/Patch meta types from Kubernetes API groups. Use this module to manage storage class configurations programmatically, such as retrieving existing classes, updating configurations, or deleting deprecated classes.",
      "description_length": 413,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Customresourcedefinitions.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Custom Resource Definitions (CRDs) by name, offering `get`, `put`, `delete`, and `patch` operations to manipulate CRDs directly via HTTP requests. It centers around CRD and delete option data types, enabling precise control over named resources within a cluster. The child module extends this functionality by allowing status updates through a specialized `put` operation, using a request path template to modify CRD status fields. Together, they support workflows like retrieving a CRD, modifying its spec or status, and cleaning up resources with targeted delete and patch actions.",
      "description_length": 614,
      "index": 901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_rules_review_spec",
      "library": "kubecaml",
      "description": "This module defines the core specification for evaluating authorization rules applicable to the current user in a Kubernetes cluster, including operations to construct and manipulate a specification object with an optional namespace. It provides data types for representing access control rules as a list-based structure mapping string keys to authorization review specifications, along with functions to serialize and deserialize these structures to and from JSON. The module supports concrete use cases such as determining allowed operations for an authenticated user in a specific namespace during admission control. Together with its submodules, it enables structured, flexible evaluation of user permissions across Kubernetes API resources.",
      "description_length": 745,
      "index": 902,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rolling_update_deployment",
      "library": "kubecaml",
      "description": "This module orchestrates rolling update strategies for deployments by managing `max_surge` and `max_unavailable` parameters, which can be specified as absolute values or percentages. It integrates with Kubernetes deployment specs to control pod replacement, ensuring availability and resource constraints are respected during updates. The child module handles JSON serialization and deserialization of these configurations, converting between in-memory representations and JSON format for storage or transmission. For example, it can enforce a deployment that allows no more than 20% surge or requires at least 80% pods available at all times, while also persisting those rules as JSON.",
      "description_length": 686,
      "index": 903,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_tls",
      "library": "kubecaml",
      "description": "This module manages TLS configurations for Ingress resources, centering on the `t` record that captures optional `secret_name` and `hosts` fields to define SSL termination and SNI routing. It enables creating, accessing, and serializing TLS settings, such as specifying a TLS secret for HTTPS termination or listing domains covered by a certificate. The child module handles lists of these configurations, pairing each with a string identifier and supporting JSON conversion for integration with Kubernetes API payloads. Together, they facilitate precise TLS setup and parsing in Ingress definitions.",
      "description_length": 600,
      "index": 904,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Job_template_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes job creation from templates, supporting construction, manipulation, and JSON serialization of job specs with optional metadata and behavior settings. It includes a submodule for managing named job templates as key-value pairs, enabling structured storage and retrieval of multiple templates. Operations include generating job configurations from stored templates, modifying job specs, and converting specifications to and from JSON for API interaction. Example uses include creating parameterized jobs, persisting template collections, and extracting job specs for monitoring.",
      "description_length": 610,
      "index": 905,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_status",
      "library": "kubecaml",
      "description": "This module captures the observed state of a Kubernetes Deployment, offering access to replica counts, condition statuses, and collision metrics. It provides constructors, serializers, and accessors for fields like available, ready, and updated replicas, enabling inspection or modification of Deployment status data from API responses or controllers. A child module extends this by representing Deployment statuses as key-value pairs and supporting JSON conversion via Yojson. Use these capabilities to serialize status information, track deployment health, or integrate with monitoring systems.",
      "description_length": 596,
      "index": 906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1.Storage_class_list",
      "library": "kubecaml",
      "description": "This module manages Kubernetes storage class lists, offering constructors and accessors for metadata, API version, kind, and item collections. It includes direct operations for building and inspecting storage class lists, along with JSON (de)serialization via `Yojson` for integration with Kubernetes APIs and config files. The child module handles conversion between raw JSON and typed storage class list structures, enabling workflows like parsing cluster configurations or generating policy-compliant storage specs. Example uses include constructing a storage class list from a JSON file, extracting metadata for validation, or serializing a configured list for deployment.",
      "description_length": 676,
      "index": 907,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale_status",
      "library": "kubecaml",
      "description": "The module tracks the state of a Kubernetes scale subresource, including replicas and label selectors, with functions to construct and access these fields. It supports inspecting the observed state of scaled deployments or replica sets, and integrates serialization via a child module that converts scale status objects to and from JSON using `Yojson.Safe.t`. This enables API interactions, storage, and retrieval of scale status data in a structured format.",
      "description_length": 458,
      "index": 908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_list",
      "library": "kubecaml",
      "description": "This module represents a list of Pod Disruption Budget (PDB) objects with support for versioning, kind, and metadata, enabling the management of PDB collections for cluster operations. It provides constructors, accessors, and JSON serialization/deserialization functions, allowing for storage or transmission of PDB data. The module handles both individual PDB lists and nested structures, such as lists of labeled PDB lists, through its submodules. Use it to retrieve, construct, or update groups of PDBs, for example when listing all PDBs in a namespace or sending batch updates to the Kubernetes API.",
      "description_length": 603,
      "index": 909,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_terminated",
      "library": "kubecaml",
      "description": "This module represents the terminated state of a container in Kubernetes, offering constructors and accessors to manage timestamps, exit codes, signals, and metadata like messages and container IDs. It includes serialization capabilities through `to_yojson` and `of_yojson` for integrating with Kubernetes API workflows. Use it to build or inspect termination details such as exit status, termination time, or runtime identifiers, both directly and through structured key-value representations.",
      "description_length": 494,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Serviceaccounts",
      "library": "kubecaml",
      "description": "This module manages Kubernetes service accounts within a namespace, offering functions to list, watch, create, and delete accounts while handling API communication. It centers around service account objects and metadata, supporting operations like lifecycle management and access control automation. The child module extends this by implementing CRUD actions\u2014get, put, delete, patch\u2014using Cohttp for HTTP transport and Kubernetes API definitions for data handling. Together, they enable tasks such as programmatically provisioning service accounts, synchronizing account states, and enforcing security policies across clusters.",
      "description_length": 627,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set",
      "library": "kubecaml",
      "description": "This module provides core functionality for creating and managing DaemonSet configurations in Kubernetes, including structured types like `t`, `spec`, and `status` to represent and manipulate daemon set objects. It supports operations to define metadata, configure pod templates, and inspect status fields, enabling precise control over system-wide pod deployments across a cluster. The child module extends this by allowing grouped management of multiple daemon sets as a list of key-value pairs, with JSON serialization via Yojson for integration with external systems. Together, they facilitate programmatic configuration, validation, and deployment of daemon sets in Kubernetes environments.",
      "description_length": 695,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rolling_update_stateful_set_strategy",
      "library": "kubecaml",
      "description": "This module defines a rolling update strategy for StatefulSets by capturing a partition point that controls the update order of replicas. It supports creating and manipulating strategies with an optional partition ordinal, and includes functions for JSON serialization and deserialization. The strategy can be used to manage incremental updates in a Kubernetes cluster, such as specifying that only replicas with an ordinal less than a given value should be updated first. Together with its submodules, it provides a complete interface for defining, modifying, and persisting rolling update configurations in both OCaml and JSON formats.",
      "description_length": 637,
      "index": 913,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Rolebindings",
      "library": "kubecaml",
      "description": "This module watches for changes to RoleBinding resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific RoleBinding resource, supporting parameters like `watch`, `timeout_seconds`, and `label_selector` to filter and control the event stream. Use it to monitor real-time updates or deletions of RoleBindings within a namespace.",
      "description_length": 365,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_ref",
      "library": "kubecaml",
      "description": "This module structures Kubernetes RBAC role references with fields for name, kind, and API group, enabling creation, access, and JSON conversion of role references. It supports building and manipulating role bindings in RBAC policies, with direct operations for constructing and serializing role reference data. The child module extends this by representing role references as associative lists, mapping keys to configurations and offering JSON handling for API interactions. Together, they facilitate managing RBAC data structures both individually and in grouped forms.",
      "description_length": 571,
      "index": 915,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior of Kubernetes pod templates, including metadata and configuration for pod creation. It provides functions to build, modify, and serialize pod templates, working directly with Kubernetes object metadata and pod specs. The child module handles JSON conversion, enabling storage or transmission of templates as key-value pairs. Use this module to generate deployment-ready pod configurations or manipulate existing templates programmatically.",
      "description_length": 486,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes ReplicaSet objects, offering functions to construct, access, and serialize groups of ReplicaSets along with metadata. It includes the main types `Replica_set.t` for individual ReplicaSets and `List_meta.t` for list-level metadata, supporting operations like retrieval, creation, and configuration serialization. The v1beta2 submodule extends this functionality by providing JSON (de)serialization using Yojson, enabling seamless interaction with Kubernetes clusters through structured data formats. Use this module to programmatically handle ReplicaSet lists, such as when querying or updating workloads in a cluster.",
      "description_length": 663,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_condition",
      "library": "kubecaml",
      "description": "This module manages the state of a DaemonSet condition by providing constructors and inspectors for condition values, including type, status, reason, message, and optional last transition time. It supports operations to serialize and deserialize condition collections, which are represented as key-value pairs mapping strings to DaemonSet conditions. You can use it to track condition changes, construct status updates, or parse incoming DaemonSet data from the Kubernetes API. The module also enables converting condition maps to JSON for storage or transmission.",
      "description_length": 564,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set",
      "library": "kubecaml",
      "description": "This module provides tools to construct, configure, and serialize Daemon_set objects for Kubernetes clusters using the v1beta1 API. It supports setting metadata, spec, status, kind, and API version, and includes structured types like Daemon_set_spec and Object_meta. The child module handles JSON conversion, enabling storage or transmission of daemon set configurations as key-value pairs. Example uses include building daemon sets for deployment or querying their state in a cluster.",
      "description_length": 485,
      "index": 919,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Non_resource_attributes",
      "library": "kubecaml",
      "description": "This module handles authorization attributes for non-resource HTTP requests in Kubernetes, such as those targeting `/api` or `/healthz`. It provides core operations to construct, access, and serialize attributes like HTTP verbs and URL paths, enabling access control evaluations for non-resource endpoints. The child module supports representing these attributes as key-value pairs and converting them to and from JSON, facilitating integration with policy definitions and API responses. Example uses include checking if a user can access `/version` or determining authorization for API group discovery endpoints.",
      "description_length": 613,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_stateful_set_strategy",
      "library": "kubecaml",
      "description": "This module defines a rolling update strategy for StatefulSets by capturing a partition ordinal that controls update rollout. It provides a core type with accessors and JSON conversion functions, allowing precise configuration of update behavior. The child module extends this by handling lists of these strategies, enabling structured serialization and deserialization in Kubernetes manifests. Together, they support defining and persisting complex update parameters in a distributed system.",
      "description_length": 492,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Nodes.By_name",
      "library": "kubecaml",
      "description": "This module watches changes to a specific Kubernetes Node resource by name. It provides a `get` function to establish a watch stream with optional parameters like timeout, resource version, and label selectors, returning a result indicating success or failure of the watch event. The module works directly with Kubernetes Node objects and is used for real-time monitoring of node state changes in a cluster.",
      "description_length": 407,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for handling Kubernetes namespace specifications, including creating specs with optional finalizers and converting them to and from JSON. It centers around the Namespace_spec type, supporting operations like adding finalizers and serializing configurations. The child module enhances this functionality by providing list-based JSON conversion, enabling batch processing of namespace specs as tuples of strings and Namespace_spec values. Together, they facilitate configuring namespace behavior, especially for managing cleanup logic during deletion, through both direct manipulation and JSON interchange.",
      "description_length": 653,
      "index": 923,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_deployment",
      "library": "kubecaml",
      "description": "This module orchestrates rolling update strategies for Kubernetes deployments by defining constraints on surge capacity and unavailable pods using `Int_or_string` values. It supports configurations like limiting surge to 30% or ensuring at least 70% pod availability during updates. The child module manages a list of these strategies, enabling serialization to and from JSON for integration with Kubernetes API interactions. Together, they provide a structured way to define, store, and transmit deployment update policies.",
      "description_length": 524,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Webhook",
      "library": "kubecaml",
      "description": "This module configures Kubernetes admission webhooks by defining rules, operations, and client settings that determine when and how webhooks are triggered. It provides data types like `Rule_with_operations`, `Label_selector`, and `Webhook_client_config`, along with operations to build and modify webhook policies. For example, it can enforce image validation on pod creation or restrict resource access based on namespace labels. The module also includes utilities for converting webhook configurations to and from JSON, enabling persistence and interoperability with external systems.",
      "description_length": 586,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module monitors real-time changes to Role and RoleBinding resources within Kubernetes namespaces, enabling dynamic tracking of authorization policies. It provides event streams that support filtering by labels, fields, and resource versions, with timeout controls for precise monitoring. Developers can use it to detect and respond to updates such as new role bindings or revoked permissions as they occur. For example, it can trigger alerts when a restricted role is bound to a service account or log all RBAC changes in a specific namespace.",
      "description_length": 548,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Lifecycle",
      "library": "kubecaml",
      "description": "This module orchestrates container lifecycle events by defining handlers like `post_start` and `pre_stop` that execute custom actions\u2014such as running commands or sending HTTP requests\u2014during container creation and termination. It uses the `Handler` type to specify synchronous actions that block container management until completion, unless the container process fails. The module also includes utilities for mapping event names to actions and supports JSON serialization and deserialization for integration with systems like Kubernetes. Example use cases include initializing resources after a container starts or triggering cleanup before it stops.",
      "description_length": 651,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Aws_elastic_block_store_volume_source",
      "library": "kubecaml",
      "description": "This module represents an AWS Elastic Block Store (EBS) volume source for Kubernetes pods, providing a type `t` to define volume configurations such as volume ID, read-only flag, partition, and filesystem type. It ensures correct mounting of existing EBS volumes into containers by enforcing zone alignment and access mode constraints. The module includes functions to construct and access these configurations, and supports ownership management and SELinux relabeling. A child module handles JSON serialization and deserialization of EBS volume sources, enabling storage or transmission of configurations and parsing them from JSON input.",
      "description_length": 639,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_strategy",
      "library": "kubecaml",
      "description": "This module defines and manipulates deployment strategies for Kubernetes Deployments, supporting \"recreate\" and \"rolling_update\" types with functions to construct, inspect, and serialize configurations. It includes operations for setting rolling update parameters such as max surge and unavailable. The child module handles lists of key-value pairs where each value is a deployment strategy, offering JSON serialization and deserialization. Use this module to define or modify Deployment resources, ensuring controlled pod replacement during updates.",
      "description_length": 550,
      "index": 929,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_file_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module enables Kubernetes pods to mount Azure File Service storage by defining a persistent volume source with support for secure credential handling through secret references. It provides operations to construct and configure volume sources with parameters like storage share names and read-only flags, while its child module manages the serialization and deserialization of these configurations to JSON for API interaction. You can use it to create volume definitions that are programmatically converted to Kubernetes deployment specs or API payloads. Example uses include mounting an Azure file share into a pod using a preconfigured secret and programmatically generating volume source JSON for cluster deployment.",
      "description_length": 723,
      "index": 930,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_var",
      "library": "kubecaml",
      "description": "This module manages environment variables for containers, supporting direct value assignment or sourcing from external references through a dedicated value source type. It provides operations to construct, manipulate, and serialize environment variables to and from JSON, facilitating integration with Kubernetes configurations. The module works with string-based keys and values, and its helper submodule handles conversion between OCaml tuples and JSON representations of environment variable lists. Use cases include defining environment variables with optional values or sources and transforming them for use in Kubernetes manifests.",
      "description_length": 637,
      "index": 931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Controller_revision",
      "library": "kubecaml",
      "description": "This module manages immutable snapshots of controller state data, primarily used for versioning and rollback in Kubernetes controllers like DaemonSet and StatefulSet. It defines the `t` type, representing a revision with metadata, kind, API version, and an immutable serialized data field, supporting operations to create and delete revisions. The module includes utilities to serialize and deserialize lists of string and Controller_revision pairs using Yojson, enabling persistence and transmission of revision data. Specific use cases include tracking configuration changes and implementing rollback mechanisms by referencing stored revisions.",
      "description_length": 646,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Http_header",
      "library": "kubecaml",
      "description": "This module represents custom HTTP headers for Kubernetes probes, providing a data structure to store header name-value pairs along with functions to construct, access, and serialize them. It supports JSON conversion through `to_yojson` and `of_yojson`, enabling integration with Kubernetes pod specifications. A list of these headers can be used to configure liveness or readiness probes requiring custom HTTP headers. For example, it allows setting headers like `Authorization: Bearer token` or `Content-Type: application/json` when defining probe configurations.",
      "description_length": 565,
      "index": 933,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Fc_volume_source",
      "library": "kubecaml",
      "description": "This module represents Fibre Channel volume sources in Kubernetes, handling configuration through identifiers like wwids and target_wwns, optional read-only flags, and LUN numbers. It enables defining and manipulating Fibre Channel storage volumes for pod specifications, ensuring correct mounting and access control. The child module manages lists of these configurations with JSON serialization, facilitating storage management in Kubernetes API objects. Together, they support creating, serializing, and applying Fibre Channel volume settings in cluster deployments.",
      "description_length": 569,
      "index": 934,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Object_metric_status",
      "library": "kubecaml",
      "description": "This module represents the current value of a metric for a Kubernetes object, such as an Ingress, and includes functions to construct and access its components: a `Cross_version_object_reference` for the target object, a string for the metric name, and a `Quantity` for the metric value. It supports retrieving and serializing metric data for autoscaling decisions, while its child module handles JSON conversion for structured metric representations using associative lists mapping string keys to metric status values. Direct operations allow building and inspecting metric statuses, and the child module enables encoding and decoding these statuses to and from JSON for API interactions. Example uses include extracting the current metric value of a specific object or preparing metric data for Kubernetes autoscaling integrations.",
      "description_length": 833,
      "index": 935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis.Apiextensions",
      "library": "kubecaml",
      "description": "This module enables the definition, validation, and serialization of Kubernetes Custom Resource Definitions (CRDs) and related API structures. It supports key data types such as JSON schemas, validation rules, subresource configurations (e.g., scale, status), and CRD metadata, with operations to build, inspect, and convert these to and from JSON using `Yojson`. You can encode complex validation logic, configure autoscaling via JSON paths, track CRD status conditions, and manage custom resource naming. Example uses include serializing CRDs for cluster registration, validating schemas against OpenAPI rules, and configuring subresources for Kubernetes API extensions.",
      "description_length": 672,
      "index": 936,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Subject",
      "library": "kubecaml",
      "description": "This module manages subject references in Kubernetes RBAC role bindings, supporting users, groups, and service accounts with operations to construct, set, and retrieve fields like kind, name, namespace, and API group. It ensures correctness across different subject types and provides a structured way to define identities that roles apply to. The included submodule handles JSON serialization and deserialization of subject data, converting between in-memory representations and JSON format for storage or transmission. Use the main module to build and manipulate role binding subjects, and the submodule to convert these structures to or from JSON during configuration loading or API interactions.",
      "description_length": 699,
      "index": 937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Controller_revision_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes ControllerRevision objects, providing access to their metadata, API version, kind, and individual items. It supports creating, serializing, and deserializing lists of ControllerRevision resources, with direct operations for managing stateful application revisions such as retrieving historical versions of StatefulSets or DaemonSets. The child module handles JSON conversion using `to_yojson` and `of_yojson`, enabling interaction with Kubernetes API endpoints that require ControllerRevision data in JSON format. Together, they facilitate tasks like inspecting revision history, performing rollbacks, and synchronizing controller state across clusters.",
      "description_length": 697,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_series",
      "library": "kubecaml",
      "description": "This module organizes event series data structures with support for tracking state, last observed time, and occurrence count, while also enabling JSON serialization via Yojson. It includes a child module that manages a list of key-value pairs mapping to event series, reflecting related sequences in Kubernetes. Developers can construct, inspect, and persist event series to monitor and analyze event patterns in cluster resources. Example usage includes tracking repeated Kubernetes events to assess resource health or system behavior over time.",
      "description_length": 546,
      "index": 939,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_condition",
      "library": "kubecaml",
      "description": "This module handles the creation and inspection of structured Kubernetes replica set conditions, capturing state transitions with fields like type, status, reason, message, and transition time. It supports operations to set and retrieve these conditions, using precise time values for accurate state tracking. The child module manages collections of these conditions, offering JSON serialization and deserialization for data interchange. Together, they enable detailed monitoring and persistence of replica set states, such as detecting availability or scaling issues.",
      "description_length": 568,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flex_volume_source",
      "library": "kubecaml",
      "description": "This module provides a Flex_volume_source type to represent exec-based plugin volumes in Kubernetes, with fields for driver name, filesystem type, mount options, read-only status, and secret references. It includes operations to construct and manipulate these volume sources directly, supporting dynamic storage provisioning through external plugins. The child module handles lists of these volume sources, offering JSON serialization and deserialization for integration with Kubernetes configuration APIs. You can use this to define custom storage volumes backed by exec plugins in pod specs, with full control over mount parameters and secrets.",
      "description_length": 646,
      "index": 941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_list",
      "library": "kubecaml",
      "description": "This module represents a deprecated Kubernetes Network Policy List, providing functions to create, serialize, and access metadata, API version, and individual network policy items. It includes operations to convert lists of network policies to and from JSON, enabling data interchange with external systems. The main data type is a list of network policies, each paired with a string identifier, supporting both direct manipulation and structured encoding. Use this module to handle legacy 1.9 network policy data in OCaml, including reading from and writing to JSON format.",
      "description_length": 574,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_condition",
      "library": "kubecaml",
      "description": "This module models the condition of Kubernetes components using a structured data type that captures type, status, and optional error or message fields. It provides constructors to build conditions with required and optional parameters, functions to access individual components, and JSON serialization via Yojson. The child module extends this by representing collections of component conditions as key-value pairs, enabling structured representation of the overall system state. These tools support tasks like unmarshaling component statuses from the Kubernetes API, checking health states, or generating diagnostic outputs.",
      "description_length": 626,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event_series",
      "library": "kubecaml",
      "description": "This module manages event series data structures that track continuous occurrences of Kubernetes events, capturing details like count, last observed time, and state. It supports construction, inspection, and JSON serialization of these series, enabling efficient monitoring and logging. The child module organizes event series into keyed lists, allowing grouping by attributes such as source or category, and provides JSON conversion for persistence and transmission. Together, they enable structured representation, aggregation, and exchange of event sequences in Kubernetes systems.",
      "description_length": 584,
      "index": 944,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_access_review_spec",
      "library": "kubecaml",
      "description": "This module structures access review requests for Kubernetes authorization, allowing specification of either resource or non-resource attributes with mutual exclusivity. It provides constructors and serializers to build and convert access review specifications to and from JSON using `to_yojson` and `of_yojson`. You can define an access request by setting attributes like user, verb, and resource type, then serialize it for submission to the Kubernetes API. The module ensures correctness in request formation while supporting direct manipulation and structured serialization through its child module.",
      "description_length": 603,
      "index": 945,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Nodes.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of a Kubernetes Node resource by name. It operates on Node objects and Patch documents, using HTTP requests to interact with the Kubernetes API. Concrete use cases include checking the health status of a specific node, updating node conditions, or applying selective status modifications without full replacement.",
      "description_length": 390,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_ref",
      "library": "kubecaml",
      "description": "This module provides a structured representation of role references in Kubernetes RBAC, capturing the role's name, kind, and API group. It includes functions to construct and deconstruct these references, along with JSON serialization and deserialization for integration with API payloads. The child module extends this functionality by handling collections of role references, mapping string keys to individual reference objects in the v1beta1 API. Together, they enable precise role binding definitions by linking subjects to named roles within namespaces.",
      "description_length": 558,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module watches for changes to Horizontal Pod Autoscaler resources in a Kubernetes cluster. It provides a `get` function to stream events based on resource version, label selectors, and field selectors, returning structured watch events or error messages. Use it to monitor autoscaling behavior in real time, such as tracking when new autoscalers are added or existing ones are modified.",
      "description_length": 391,
      "index": 948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Roles",
      "library": "kubecaml",
      "description": "This module watches for changes to a list of Role resources in the Kubernetes API. It provides a `get` function to stream updates with options like resource version, label selectors, and timeouts, returning events as they occur. Use it to monitor role modifications in real time for cluster management or auditing.",
      "description_length": 314,
      "index": 949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Jobs, providing functions to construct, access, and serialize job lists. It works with job list objects that include metadata, API version, kind, and a list of individual Job objects, supporting operations like parsing job list responses from the Kubernetes API, building custom job list payloads, and converting data to and from JSON. A child module handles batch v1 job lists with structured representations and string identifiers, enabling tasks like persisting or retrieving multiple job states. Together, these components support managing job collections in Kubernetes workflows, from API interactions to storage and transmission.",
      "description_length": 679,
      "index": 950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy_spec",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Pod Security Policy configurations, enforcing constraints on pod behavior through `Pod_security_policy_spec.t` objects that control user/group IDs, capabilities, volume plugins, and host namespace access. It supports creating, serializing, and inspecting these policies, enabling use cases like restricting privileged containers and defining allowed storage volumes. The child module handles JSON serialization and deserialization, converting policy specs to and from JSON for storage or transmission using associative lists mapping strings to policy objects. Together, they provide a complete workflow for defining, manipulating, and persisting cluster security policies.",
      "description_length": 703,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review_status",
      "library": "kubecaml",
      "description": "This module represents the outcome of a token authentication request in a Kubernetes API context, offering functions to construct and inspect token review statuses. It provides access to authentication results such as token validity, user information, and error messages, supporting workflows that validate bearer tokens for user identification. The module includes operations for serializing and deserializing token review status objects, handling conversions between JSON and internal data structures. For example, it can parse a JSON response from a Kubernetes API to determine if a token is valid and extract the associated user details.",
      "description_length": 641,
      "index": 952,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_item",
      "library": "kubecaml",
      "description": "This module manages resource usage limits for Kubernetes objects, supporting operations to define and manipulate min/max constraints, default requests, and limit-to-request ratios for resources like CPU and memory. It works with `Quantity.Object.t` values, allowing optional specification by resource name, and includes functions to enforce boundaries in LimitRange policies or set container defaults. A child module handles JSON serialization and deserialization of lists of key-value pairs where each value is a limit range item, using `Yojson.Safe.t` for data exchange. This enables converting limit range configurations to JSON for storage or parsing them from external inputs.",
      "description_length": 681,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring and management of PodPreset resources across Kubernetes namespaces. It supports filtering by labels and fields, version tracking, and pagination with continuation tokens for efficient querying. Key operations include watching individual PodPreset objects, applying limits to result sets, and dynamically updating environment variables and volume mounts. For example, you can track configuration changes in a specific namespace or paginate through large collections of PodPresets to apply consistent settings across a cluster.",
      "description_length": 567,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment",
      "library": "kubecaml",
      "description": "This module handles deprecated Kubernetes Deployment objects from the `extensions/v1beta1` API version, enabling the creation, serialization, and inspection of deployments that manage Pods and ReplicaSets. It includes core operations for defining deployment specs, metadata, and status, along with utilities to convert to and from JSON for use with legacy manifests. The child module manages lists of Deployments, providing JSON (de)serialization for bulk handling of deployment configurations. Use cases include reading and writing YAML/JSON files that follow the older Kubernetes API schema and interacting with clusters that still rely on this version.",
      "description_length": 655,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range",
      "library": "kubecaml",
      "description": "This module manages Kubernetes resource limits by defining and manipulating LimitRange objects that enforce constraints on CPU, memory, and storage within namespaces. It provides direct access to core fields like metadata, spec, kind, and api_version, allowing construction, serialization, and inspection of LimitRange resources. The child module extends this functionality by offering a structured way to handle collections of LimitRange objects as key-value pairs, with JSON serialization support via Yojson. Together, they enable programmatic enforcement of resource quotas, such as setting a maximum memory limit of \"2Gi\" for containers in a namespace.",
      "description_length": 656,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_status",
      "library": "kubecaml",
      "description": "This module captures the runtime state of a DaemonSet in a Kubernetes cluster, tracking metrics like scheduled, ready, and misscheduled node counts. It provides constructors, accessors, and serialization for status objects, including optional fields such as collision count and conditions. A child module offers a key-value structure for node-specific statuses with JSON support, enabling distributed state management. Together, they facilitate monitoring, reconciliation, and persistence of DaemonSet deployments.",
      "description_length": 514,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review",
      "library": "kubecaml",
      "description": "This module represents subject access reviews in Kubernetes's authorization API, providing a type `t` to model access requests and functions to construct, inspect, and serialize these objects. It supports operations to retrieve metadata, set user and group information, and convert access reviews to and from JSON for API interaction. The child module handles JSON serialization and deserialization, enabling conversion of access review data between in-memory and wire formats. Example usage includes building an access review for a user requesting to create a pod in a namespace, then serializing it to send to the Kubernetes API for evaluation.",
      "description_length": 646,
      "index": 958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_status",
      "library": "kubecaml",
      "description": "This module captures the observed state of a Kubernetes Deployment, offering direct access to replica counts and condition details while supporting serialization to JSON. It provides constructors and parsers for building and interpreting deployment status data. The submodule extends this functionality by representing multiple status entries as key-value pairs, enabling structured serialization and deserialization. Together, they facilitate inspecting, storing, and updating deployment states in Kubernetes systems.",
      "description_length": 518,
      "index": 959,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Controller_revision",
      "library": "kubecaml",
      "description": "This module manages immutable snapshots of controller state data, primarily used by Kubernetes controllers like DaemonSet and StatefulSet for updates and rollbacks. It supports creating, serializing, and deserializing snapshots using JSON, with accessors for key fields such as revision number, metadata, kind, and API version. The module handles conversion between JSON and Controller_revision values, enabling storage or transmission of state snapshots. Clients can generate new revisions, retrieve revision metadata, and convert snapshots to JSON for API interactions, while ensuring Data field immutability after creation.",
      "description_length": 626,
      "index": 960,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Local_subject_access_review",
      "library": "kubecaml",
      "description": "This module represents and processes local subject access reviews in Kubernetes, enabling precise checks of namespace-scoped permissions for users or groups. It defines a type `t` with operations to construct, serialize, and access fields like `spec`, `status`, `kind`, and `api_version`, supporting direct validation of actions within a specific namespace. The included serialization module converts access review objects to and from JSON, facilitating storage, transmission, and reconstruction of structured access review data. Use this module to programmatically evaluate and enforce fine-grained namespace-level policies, such as checking if a user can create or modify resources in a given namespace.",
      "description_length": 705,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_port",
      "library": "kubecaml",
      "description": "This module represents network ports within a container, providing a data structure to define port numbers, protocols, and optional host bindings. It includes functions to construct and access port configurations, and supports serialization and deserialization via JSON. The child module extends this functionality by handling conversion between JSON and structured port data, using string-identified port configurations. Together, they enable defining container ports, mapping them to host ports, and integrating with systems like Kubernetes through JSON-based API interactions.",
      "description_length": 579,
      "index": 962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_status",
      "library": "kubecaml",
      "description": "This module tracks the status of a DaemonSet, capturing key metrics like scheduled, ready, and misscheduled node counts, along with conditions and collision counts. It supports construction, serialization, and field access for status data, using integers, optional values, and condition lists. The child module provides a string-keyed mapping for direct status entry access, with JSON conversion for persistence and API interchange. Together, they enable monitoring rollout progress, diagnosing scheduling issues, and validating pod distribution across nodes.",
      "description_length": 559,
      "index": 963,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer_configuration_list",
      "library": "kubecaml",
      "description": "This module represents a list of initializer configurations in Kubernetes's admission registration API, providing functions to construct, access, and serialize the list using `to_yojson` and `of_yojson`. It includes fields for API version, kind, metadata, and a list of items, aligning with Kubernetes API conventions. Use it to manage collections of initializer configurations that enforce initialization logic on resources before persistence. For example, you can create a list of configurations, serialize it to JSON for storage, or deserialize it from an API response to apply admission control policies.",
      "description_length": 608,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_address",
      "library": "kubecaml",
      "description": "This module represents a network endpoint with an IP address and optional metadata like hostname, node name, and object reference, enabling precise definition and serialization of Kubernetes service endpoints. It supports operations to construct, access, and convert endpoint data, including determining endpoint locality via node names or checking target references. The child module extends this by managing collections of endpoint addresses as key-value pairs, providing JSON serialization for use in Kubernetes API interactions. Example usage includes defining service endpoints with specific IP and node information, or serializing endpoint lists for API resource updates.",
      "description_length": 677,
      "index": 965,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoints_list",
      "library": "kubecaml",
      "description": "This module manages a list of Kubernetes endpoints, offering functions to construct, serialize, and access endpoint collections along with their metadata and versioning. It includes operations to convert individual endpoint objects to and from JSON using Yojson, enabling precise API interactions. You can use it to track pods backing a service or handle endpoint data retrieved from or sent to a Kubernetes API server. The module supports both list-level operations and per-endpoint manipulation keyed by string identifiers.",
      "description_length": 525,
      "index": 966,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_status",
      "library": "kubecaml",
      "description": "This module represents the state of a job in a Kubernetes cluster, tracking fields like active pod count, start and completion times, and success or failure counts. It provides constructors, accessors, and JSON (de)serialization for job status data, enabling integration with Kubernetes APIs. The child module specializes in handling JSON conversions using Yojson, supporting parsing and generation of job status payloads for API interactions. Together, they enable monitoring, evaluation, and communication of batch job outcomes within a cluster.",
      "description_length": 547,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes Deployment objects, providing functions to construct, access, and serialize deployment lists. It supports operations to set and retrieve API version, kind, metadata, and the underlying deployments, while its child module handles conversion to and from Yojson for storage or transmission. You can create a deployment list, add deployments to it, and serialize it to JSON for use in API requests or configuration files. The module also allows parsing JSON data into typed deployment list structures for programmatic manipulation.",
      "description_length": 574,
      "index": 968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Supplemental_groups_strategy_options",
      "library": "kubecaml",
      "description": "This module defines the core strategy type and configuration options for managing supplemental group IDs in Kubernetes security contexts. It provides functions to create and manipulate strategies with optional rules and ID ranges, along with JSON serialization support via `to_yojson` and `of_yojson`. The module enables enforcement of group ID constraints in pod security policies, allowing configurations such as restricting supplemental groups to specific ID ranges or requiring predefined values. Submodules extend this functionality by supporting structured collections of these strategy options, facilitating complex policy definitions.",
      "description_length": 642,
      "index": 969,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Subject",
      "library": "kubecaml",
      "description": "This module manages subject references in Kubernetes RBAC role bindings, supporting creation and manipulation of subjects with attributes like name, kind, namespace, and API group. It includes operations to access these fields and represents users, groups, or service accounts targeted by policies. The child module handles JSON serialization and deserialization of subjects, converting between in-memory structures and the Kubernetes RBAC v1beta1 format for API objects. Use the main module to construct and inspect subjects, and the child module to encode or decode subject lists for storage or transmission.",
      "description_length": 610,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_update_strategy",
      "library": "kubecaml",
      "description": "This module manages the update strategies for StatefulSets in Kubernetes, focusing on the rolling update method. It provides data types to represent strategy configurations, including the strategy type and rolling update parameters, along with operations to create, serialize, and extract these configurations. The module supports direct manipulation of update policies and integrates with a submodule for JSON serialization, enabling seamless interaction with Kubernetes APIs when applying or retrieving StatefulSet strategies. Example uses include defining a rolling update with specific partition settings and converting strategy objects to and from JSON for API communication.",
      "description_length": 680,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_node_affinity",
      "library": "kubecaml",
      "description": "This module enforces constraints on which nodes can access a volume, using the `t` type to represent affinity rules and `Node_selector.t` to define label-based node requirements. It supports creating, validating, and serializing node affinity policies that ensure volumes are only mounted on nodes matching specified labels. The child module manages a list of key-value constraints, offering JSON conversion for integration with Kubernetes APIs. Example uses include defining storage placement rules and verifying volume access at mount time.",
      "description_length": 542,
      "index": 972,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_projection",
      "library": "kubecaml",
      "description": "This module defines a composite volume projection type that combines multiple data sources such as secrets, downward API, and config maps into a single volume configuration. It provides constructors and accessors to build and manipulate these projections, enabling precise setup of Kubernetes pod volumes with environment-specific data. The child module handles lists of key-value projections, offering JSON serialization and deserialization via Yojson for use in pod spec configurations. Together, they support defining complex, multi-source volumes that inject various data types into containers, such as combining secrets with pod metadata or configuration values.",
      "description_length": 667,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment",
      "library": "kubecaml",
      "description": "This module manages the creation and manipulation of volume attachment objects, representing attach or detach requests for storage volumes in a Kubernetes cluster. It supports structured configuration through types like Volume_attachment_spec, Volume_attachment_status, and Object_meta, and includes operations to serialize and deserialize these objects to and from JSON. You can construct volume attachment instances with custom metadata and state, then convert them to JSON for storage or transmission. Submodule functionality extends this by enabling direct conversion of volume attachment lists to and from Yojson representations.",
      "description_length": 634,
      "index": 974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Deployment specifications with core fields like replicas, strategy, and pod templates, and provides functions to configure rollout strategies, label selectors, and pause status. It supports programmatic creation and manipulation of Deployment configurations, such as defining pod creation and update behavior in a cluster. The child module handles key-value mappings of Deployment specs, enabling JSON serialization and deserialization via Yojson for use in generating or parsing Kubernetes manifests. Together, they allow precise control and transformation of Deployment definitions in both code and serialized formats.",
      "description_length": 654,
      "index": 975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_status",
      "library": "kubecaml",
      "description": "This module tracks the observed state of a Kubernetes Deployment, capturing replica counts, conditions, and collision counters to reflect deployment health and progress. It offers constructors and accessors for status fields, enabling checks for readiness, analysis of rollout states, and detection of configuration conflicts. The submodule handles JSON serialization and deserialization of status data using Yojson, facilitating interaction with the Kubernetes API and persistent state storage. Together, they support monitoring, debugging, and control of deployment processes in a cluster.",
      "description_length": 591,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment",
      "library": "kubecaml",
      "description": "This module handles the structure and manipulation of a deprecated Kubernetes Deployment resource, allowing creation, serialization, and field access for apps/v1beta1 compatibility. It defines core types like Deployment, with nested metadata, spec, and status fields, and supports operations such as parsing from and converting to JSON. The child module extends this functionality by managing multiple Deployments as a collection, enabling bulk serialization and deserialization using Yojson. Together, they facilitate working with Deployment manifests in both individual and grouped forms, suitable for configuration storage or API interaction.",
      "description_length": 645,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Non_resource_rule",
      "library": "kubecaml",
      "description": "This module defines a rule structure for non-resource API access in Kubernetes authorization, including operations to construct rules with specific verbs and URL paths. It supports data types for representing sets of HTTP verbs and URL patterns, with wildcard handling for flexible matching. The child module handles lists of these rules, enabling serialization and deserialization to JSON for Kubernetes API interactions. Example uses include defining access policies for endpoints like `/api` or `/healthz` and managing rule sets in JSON format.",
      "description_length": 547,
      "index": 978,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume",
      "library": "kubecaml",
      "description": "This module provides type-safe construction and inspection of Kubernetes volume configurations, supporting diverse storage sources like AWS EBS, ConfigMap, and PersistentVolumeClaim. It operates on `Volume.t` values to manipulate structured fields such as volume names and storage-specific parameters, while enabling JSON serialization via `Yojson.Safe.t` for integration with Kubernetes APIs. A child module handles lists of named volumes, offering conversion to and from JSON for use in pod configurations that require multiple volumes to be referenced by containers. Example uses include defining Pod storage requirements, mapping host directories, or integrating cloud provider volumes into orchestration workflows.",
      "description_length": 719,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Se_linux_strategy_options",
      "library": "kubecaml",
      "description": "This module defines the core types and operations for configuring SELinux strategy options in Kubernetes security policies, enabling the specification of allowed labels and enforcement mechanisms. It includes functions to construct and manipulate strategy rules, along with submodules that handle structured policy data such as key-value lists for SELinux context constraints. The API supports converting policy configurations to JSON, facilitating integration with Kubernetes API objects like PodSecurityPolicy. Example usage includes defining a restricted SELinux context that limits containers to run with a specific label such as `system_u:object_r:container_file_t`.",
      "description_length": 671,
      "index": 980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Validatingwebhookconfigurations.By_name",
      "library": "kubecaml",
      "description": "This module handles direct interactions with Kubernetes ValidatingWebhookConfigurations by name, providing functions to retrieve, replace, delete, and partially update webhook configurations. It operates on specific Kubernetes API types, including `Validating_webhook_configuration` and `Delete_options`, using HTTP methods over URIs. Concrete use cases include managing admission control policies by manipulating webhook configurations during deployment or configuration updates.",
      "description_length": 480,
      "index": 981,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_error",
      "library": "kubecaml",
      "description": "The module captures errors from volume operations with structured data, including timestamps and messages, and supports JSON serialization. It organizes these errors into key-value lists for detailed reporting, enabling precise error tracking during storage system interactions. Functions allow creating, accessing, and converting error data, facilitating integration with Kubernetes APIs. This structure handles and transmits rich error information from volume attach or detach operations.",
      "description_length": 490,
      "index": 982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.Token_review_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for token authentication requests in the Kubernetes API, including creating specifications with optional bearer tokens and converting them to and from JSON. It centers around a core data type representing a token review specification, supporting operations like parsing from JSON, validating tokens, and serializing responses. The child module handles the concrete object structure and conversion logic, enabling seamless integration with Kubernetes authentication workflows. Example usage includes constructing a token review request, validating a bearer token, and serializing the result for API responses.",
      "description_length": 657,
      "index": 983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_condition",
      "library": "kubecaml",
      "description": "This module models the state transitions of Kubernetes StatefulSets by providing constructors and accessors for condition records, including fields such as type, status, reason, message, and last transition time. It supports direct manipulation of these records along with serialization to and from JSON using Yojson, facilitating integration with Kubernetes API interactions. The child module handles collections of conditions as lists of string-keyed records, enabling structured processing of multiple conditions. Use this module to inspect, construct, or serialize StatefulSet status changes, such as tracking when a StatefulSet becomes available or encounters an error.",
      "description_length": 674,
      "index": 984,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1.Watch.Initializerconfigurations",
      "library": "kubecaml",
      "description": "This module enables real-time observation of initializer configuration changes in Kubernetes by providing watch operations that stream updates as they occur. It includes a `get` function that allows filtering through parameters like `label_selector`, `resource_version`, and `timeout_seconds`, making it possible to track dynamic changes across a list or specific initializer configurations. The child module extends this functionality by enabling per-name monitoring, supporting precise event streaming for individual configurations. Together, they allow use cases such as dynamically updating admission control policies in response to configuration changes.",
      "description_length": 659,
      "index": 985,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module provides real-time tracking and filtering of Horizontal Pod Autoscaler events within a namespace, capturing lifecycle changes like scaling and configuration updates. It supports focused monitoring through label selectors, resource version synchronization, and named autoscaler tracking with optional timeouts. Key data types include autoscaler configurations and event streams, enabling use cases such as streaming scaling events across all autoscalers or monitoring a specific autoscaler with controlled connection lifetimes. Example usage includes filtering autoscaler events by label or tracking a single autoscaler's activity within a defined time window.",
      "description_length": 671,
      "index": 986,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_condition",
      "library": "kubecaml",
      "description": "This module models the state transitions of a DaemonSet in Kubernetes through `Daemon_set_condition` records, capturing details like type, status, reason, message, and last transition time. It supports creating, accessing, and serializing these conditions to JSON, facilitating integration with status reporting and reconciliation workflows. The child module extends this by organizing multiple conditions into a map, enabling structured handling of DaemonSet states across different nodes or update stages. Together, they provide a complete interface for tracking and transmitting DaemonSet health and progress in cluster management scenarios.",
      "description_length": 644,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module manages RBAC resources within a Kubernetes namespace, focusing on Roles and RoleBindings. It provides data types like `Role.t`, `Role_list.t`, `Role_binding.t`, and `Role_binding_list.t`, along with operations to list, create, update, and delete these resources using the Kubernetes API. You can use it to automate access control synchronization, enforce policies, or clean up RBAC definitions during namespace teardown. Specific actions include granting user permissions via role bindings or removing outdated roles programmatically.",
      "description_length": 546,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch.Events",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes events by making HTTP requests to a predefined API path. It supports filtering by resource version, label selectors, and field selectors, and returns parsed watch events or error messages. Use it to monitor event streams in real-time, such as tracking new events or updates in a specific namespace or resource.",
      "description_length": 356,
      "index": 989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_ingress_rule",
      "library": "kubecaml",
      "description": "This module defines deprecated Kubernetes network policy ingress rules that allow traffic only when both port and source criteria are matched. It provides data types for specifying optional port lists and source peers, enabling fine-grained network access controls for pods in pre-1.9 clusters. The associated submodule handles JSON serialization and deserialization of these rules, supporting structured data exchange for API interactions. Example uses include defining ingress rules with specific ports and sources, and converting those rules to and from JSON for configuration management.",
      "description_length": 591,
      "index": 990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Deployment specifications with fields like replicas, strategy, and pod template, enabling precise control over pod creation, updates, and rollbacks. It includes functions to set and access parameters such as min_ready_seconds, paused, and revision_history_limit, directly shaping deployment behavior. The module supports JSON serialization via Yojson, allowing the specification to be stored or transmitted as structured data. Together with its submodules, it provides a complete interface for defining and manipulating Deployment resources in a Kubernetes cluster.",
      "description_length": 599,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Allowed_flex_volume",
      "library": "kubecaml",
      "description": "This module defines a structure for specifying allowed Flexvolume drivers in Kubernetes policies, including functions to create and access the driver name field, along with JSON serialization and deserialization. It enforces storage driver restrictions by representing a single allowed Flexvolume driver entry. The child module provides a list-based structure mapping string keys to `Allowed_flex_volume` values, enabling manipulation of multiple Flexvolume configurations and their parameters. Use this module to manage and serialize policy definitions that control permitted Flexvolume drivers in a Kubernetes cluster.",
      "description_length": 620,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_status",
      "library": "kubecaml",
      "description": "This module tracks the status of a Replica Set in Kubernetes, with fields like `replicas`, `ready_replicas`, and `conditions` to capture observed state. It supports constructing, serializing, and inspecting Replica Set statuses, enabling monitoring and reconciliation of desired versus actual state. The child module handles JSON conversion for structured status metadata, allowing seamless interaction with Kubernetes APIs. You can use it to check readiness, track deployment progress, or serialize status data for storage and transmission.",
      "description_length": 541,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Configmaps",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ConfigMap resources within a namespace through HTTP requests, supporting retrieval, creation, and deletion of ConfigMaps using standard API parameters. It operates directly on data types such as `Config_map.t` and `Config_map_list.t`, offering concrete functions to list all ConfigMaps, create a new one, or delete a collection. The child module extends this functionality with fine-grained CRUD operations, allowing for patching and customizing requests with headers and contexts. Together, they enable precise management of ConfigMap resources in cluster configurations, such as updating application settings or removing outdated configurations.",
      "description_length": 678,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Id_range",
      "library": "kubecaml",
      "description": "This module defines a range of integer IDs with inclusive min and max bounds, used to represent allowed ID ranges in policy definitions. It provides functions to construct a range, access its min and max values, and convert to and from JSON format. A typical use case is specifying user or group ID ranges in Kubernetes pod security policies. The child module extends this by managing a collection of named ID ranges, mapping string identifiers to ranges, and supporting JSON serialization for use in policy configuration constraints.",
      "description_length": 534,
      "index": 995,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Subject",
      "library": "kubecaml",
      "description": "This module manages subject references in Kubernetes RBAC role bindings, supporting direct API object targets and non-object identities like users and groups. It provides functions to construct and manipulate subjects with precise control over kind, name, namespace, and API version, ensuring valid role bindings for resources such as service accounts or nodes. The serialization submodule handles conversion to and from JSON, working with lists of subject definitions to support role bindings that apply to specific Kubernetes objects. Use this to define and manage fine-grained access controls targeting both users and cluster resources.",
      "description_length": 639,
      "index": 996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes cron jobs, offering operations to set and retrieve metadata, API version, and job lists, along with JSON serialization and deserialization. Its core data type is a list of cron job objects, each representing a scheduled workload in Kubernetes. The included submodule handles JSON conversion, enabling seamless transformation of cron job collections to and from JSON for storage or transmission. Use this module to interact with Kubernetes batch API endpoints, construct cron job lists, and serialize them for external use.",
      "description_length": 568,
      "index": 997,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Projected_volume_source",
      "library": "kubecaml",
      "description": "This module represents a projected volume source for Kubernetes, enabling the composition of volume projections like secrets, config maps, and downward API data into a single volume with optional default file mode settings. It provides operations to construct, access, and serialize these configurations, working directly with lists of projection objects and an optional mode integer. The child module handles JSON conversion, supporting serialization of key-value lists where values are projected volume sources, facilitating API interactions and configuration storage. Example usage includes defining a pod's projected volume with specific permissions or converting volume specs to JSON for deployment.",
      "description_length": 704,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_config_source",
      "library": "kubecaml",
      "description": "This module defines node configuration sources with a single non-nil subfield, supporting creation, serialization, and access to fields like `kind`, `api_version`, and `config_map_ref`. It handles referencing versioned Kubernetes objects to specify where node configuration data originates in a cluster. The child module enables JSON serialization and deserialization of these sources, working with key-value pairs for structured parsing and API communication. Examples include converting configuration sources to JSON for storage or reconstructing them from persisted state.",
      "description_length": 575,
      "index": 999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Allowed_host_path",
      "library": "kubecaml",
      "description": "This module enforces restricted host path access in pod security policies by defining and manipulating path prefix constraints. It provides operations to create, serialize, and extract allowed path prefixes, enabling precise control over host volume access. The child module supports converting policy configurations to and from JSON, handling associative lists that map strings to path constraints. Together, they allow defining policies like restricting pods to only access specific host directories such as `/var/log` or `/data/app`.",
      "description_length": 536,
      "index": 1000,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_list",
      "library": "kubecaml",
      "description": "This module manages a list of Kubernetes NetworkPolicy objects, with support for API version, kind, metadata, and item fields. It provides operations to construct, serialize, and access network policy lists, including conversion to and from JSON using `to_yojson` and `of_yojson`. The module is used for handling multiple network policies in Kubernetes API interactions, such as retrieving, updating, or serializing policy collections for API requests. Each network policy entry is represented as a tuple of a string and a Network_policy structure, enabling precise handling of policy data during serialization and API communication.",
      "description_length": 633,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module handles direct interactions with Kubernetes RBAC `ClusterRole` resources by name, providing functions to get, put, delete, and patch individual roles. It works with fully defined `Cluster_role` and `Delete_options`/`Patch` types, translating HTTP requests into typed OCaml values. Concrete use cases include managing cluster-wide role definitions, updating role rules, and cleaning up roles in automated deployment or policy enforcement tools.",
      "description_length": 455,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_condition",
      "library": "kubecaml",
      "description": "This module provides a structured representation of Kubernetes replica set conditions, capturing state transitions through fields like type, status, reason, message, and transition time. It includes functions to construct, access, and serialize these records to and from JSON, aligning with Kubernetes API requirements. The child module organizes multiple conditions into a key-value structure, enabling efficient serialization and deserialization of entire condition sets. Use these modules to programmatically inspect, create, or persist replica set states during cluster management or API interactions.",
      "description_length": 605,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_condition",
      "library": "kubecaml",
      "description": "This module models the state of a Kubernetes deployment using structured condition objects that capture type, status, reason, and optional timestamps. It supports operations to create, update, and query individual conditions, enabling precise tracking of deployment readiness and status transitions. The child module organizes multiple conditions into a map-like structure with string keys, providing JSON serialization for data exchange and persistence. Together, they enable detailed monitoring, diagnostics, and state management of deployments through both direct condition manipulation and structured collections.",
      "description_length": 617,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment",
      "library": "kubecaml",
      "description": "This module provides tools for creating and managing Kubernetes Deployment objects, allowing users to define and modify metadata, specifications, and status fields. It includes data types such as Deployment_spec, Deployment_status, and Object_meta, enabling precise control over Deployment configurations. The associated child module extends this functionality to handle multiple Deployments, supporting bulk operations and JSON serialization for storage or API communication. Example uses include constructing Deployment manifests for cluster deployment or converting existing Deployment objects to and from JSON for persistence or transmission.",
      "description_length": 646,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_status",
      "library": "kubecaml",
      "description": "This module tracks the runtime state of storage volumes in a Kubernetes cluster, capturing availability, binding status, and associated messages. It includes direct operations to construct, inspect, and serialize status objects, along with a child module that maps string identifiers to these statuses for API interactions. You can use it to report current volume conditions, update status fields, or synchronize state across controllers. For example, you might deserialize a status from an API response, modify its availability flag, and serialize it back for an update request.",
      "description_length": 579,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Endpoints",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Endpoints resources within a namespace, offering direct functions to list, watch, create, and delete Endpoints while supporting filtering through query parameters. It operates on core types like `Endpoints`, `Endpoints_list`, and `Status`, enabling precise interactions with the Kubernetes API server. The child module extends this functionality with REST-level operations\u2014get, put, delete, and patch\u2014allowing fine-grained manipulation of named Endpoints objects using standard HTTP methods. Together, they support tasks like dynamically updating service endpoints or monitoring endpoint changes in real time.",
      "description_length": 640,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for a scale subresource specification, primarily handling the `replicas` field to indicate the desired number of instances. It provides functions to construct a specification, retrieve the replicas value, and convert to and from JSON using Yojson, enabling interaction with Kubernetes scale subresources to define or update scaling parameters. The child module extends this by representing a list of key-value pairs where each value is a `Scale_spec.t`, offering `to_yojson` and `of_yojson` for JSON conversion, commonly used in Kubernetes custom resources like horizontal pod autoscalers. Together, they support defining, serializing, and managing scaling configurations for containerized workloads.",
      "description_length": 749,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "Implements watch operations for monitoring changes to Horizontal Pod Autoscaler resources in Kubernetes. It provides functions to establish a streaming connection that receives real-time updates matching specified query parameters such as label selectors, resource version, and timeout duration. This module is used to observe scaling events and adjust system behavior based on current autoscaling states.",
      "description_length": 405,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service",
      "library": "kubecaml",
      "description": "This module provides tools to create and manipulate Kubernetes Service objects, including setting metadata, API version, ports, and selectors, with support for JSON serialization via Yojson. It handles both individual services and collections of named services, enabling use cases like defining network endpoints for cluster applications and managing routing rules to backend pods. The main data types include the Service definition and a list of named services, with operations to construct, modify, and serialize them. Specific examples include configuring a MySQL service with a local port and pod selector, or managing multiple services in a configuration file using their JSON representations.",
      "description_length": 698,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_spec",
      "library": "kubecaml",
      "description": "This module structures and enforces resource quotas in Kubernetes, specifying hard limits and scopes for resources like CPU, memory, and storage. It supports operations to define, compare, and apply quota constraints using resource quantities and string-based filters. The child module handles JSON serialization and deserialization of quota specifications, enabling interaction with Kubernetes APIs using associative lists mapping strings to quota configurations. Together, they allow creating, managing, and deploying quota policies programmatically within a cluster.",
      "description_length": 569,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_condition",
      "library": "kubecaml",
      "description": "This module represents and manipulates deployment condition records, capturing the state of a deployment at specific points with fields like type, status, reason, message, and timestamps. It provides functions to construct, inspect, and serialize these records, along with a list structure for managing multiple conditions, serialized to JSON. Use it to track deployment progress, health status, or failures in Kubernetes environments, such as recording when a deployment becomes available or encounters an error.",
      "description_length": 513,
      "index": 1012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Non_resource_rule",
      "library": "kubecaml",
      "description": "This module defines non-resource authorization rules for Kubernetes API access, supporting operations to create rules with verbs and optional URL paths, and extract rule details. It includes a child module for handling lists of rules, enabling conversion to and from JSON with `Yojson.Safe.t`. Main data types include the rule type `t` and a list module for structured policy definitions. You can create a rule allowing `GET` on `/api`, or define a list of such rules for use in cluster authorization policies.",
      "description_length": 510,
      "index": 1013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and manipulation functions for an ingress specification in Kubernetes, including TLS settings, routing rules, and a default backend. It supports creating, accessing, and serializing ingress configurations, with direct operations to build and modify ingress objects. The child module handles lists of key-value pairs mapping strings to ingress specifications, enabling JSON serialization and deserialization via Yojson. Use this module to construct and manage ingress objects for deployment or inspection in Kubernetes environments.",
      "description_length": 565,
      "index": 1014,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_list",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes RBAC roles with fields for metadata, kind, API version, and a list of role items. It provides functions to construct and access these fields, along with JSON serialization and deserialization using `to_yojson` and `of_yojson`. The child module extends this functionality by organizing role lists into an associative structure mapping strings to role lists, enabling structured management and persistence of RBAC configurations. Example usage includes parsing a JSON file into a role list, modifying role permissions, and serializing the updated structure back to JSON for deployment.",
      "description_length": 633,
      "index": 1015,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes daemon sets, offering direct access to metadata, API version, and individual items. It supports creation, serialization, and deserialization of daemon set lists, with utilities to extract or build list components. The child module enhances this functionality by introducing labeled entries\u2014each pair consisting of a string identifier and a daemon set\u2014enabling structured serialization to and from JSON. Use cases include handling responses from Kubernetes API endpoints, managing node-level workloads across clusters, and persisting daemon set collections in a structured format.",
      "description_length": 625,
      "index": 1016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Glusterfs_volume_source",
      "library": "kubecaml",
      "description": "This module represents a Glusterfs volume configuration for Kubernetes pods, centered around the `t` type that captures endpoints, path, and read-only status. It provides functions to construct and manipulate these configurations, enabling the definition of persistent storage using Glusterfs in pod specs. The associated submodule handles JSON serialization and deserialization, converting between `t` values and JSON representations for storage or transmission. Example usage includes creating a volume source with a given endpoint and path, then serializing it to JSON for inclusion in a pod's volume list.",
      "description_length": 609,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Vsphere_virtual_disk_volume_source",
      "library": "kubecaml",
      "description": "This module represents a vSphere virtual disk volume source for Kubernetes, enabling creation and manipulation of vSphere volume configurations through string fields like volume path, storage policy name and ID, and filesystem type. It integrates with VMware storage infrastructure by specifying persistent volumes in Kubernetes pod definitions. The child module handles JSON serialization and deserialization of these configurations, converting between list-based structures of string keys and `Vsphere_virtual_disk_volume_source.t` values for API interactions. Use this module to construct volume configurations and convert them to JSON for cluster communication.",
      "description_length": 665,
      "index": 1018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_condition",
      "library": "kubecaml",
      "description": "This module manages certificate signing request conditions, including fields like type, reason, message, and last update time, with support for JSON serialization and deserialization via Yojson. It provides constructors, accessors, and utilities to handle state transitions and track approval statuses in Kubernetes certificate workflows. The child module specializes in converting condition data to and from JSON, enabling seamless API interactions through list-based key-value pair operations. Example uses include updating a condition's status with a timestamp and serializing it for storage or transmission.",
      "description_length": 611,
      "index": 1019,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_spec",
      "library": "kubecaml",
      "description": "This module defines and manages persistent volume specifications, supporting diverse storage configurations such as cloud provider volumes, network filesystems, and distributed storage. It exposes structured access to key fields like capacity, access modes, and storage class identifiers, and allows type-safe retrieval of provider-specific configurations for Kubernetes integration. The module includes a child module for handling named collections of volume specs, enabling JSON serialization and management of multiple storage configurations. Example uses include defining AWS EBS-backed volumes with size constraints, configuring NFS mounts with read-write access modes, and serializing specs for API interaction with Kubernetes.",
      "description_length": 733,
      "index": 1020,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Api.Resource",
      "library": "kubecaml",
      "description": "This module provides precise handling of Kubernetes resource quantities such as CPU and memory, using a custom type `t` that supports parsing from strings and conversion to and from JSON. It includes operations like `make` for constructing quantity values and a submodule for managing key-value collections of these quantities, with support for structured serialization via `to_yojson` and `of_yojson`. These features allow developers to define, manipulate, and serialize resource specifications for use in Kubernetes API interactions. For example, you can create a memory limit with `make \"2Gi\"` and serialize it as part of a pod specification.",
      "description_length": 645,
      "index": 1021,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_list",
      "library": "kubecaml",
      "description": "This module manages lists of horizontal pod autoscaler objects, providing constructors, accessors, and serialization for Kubernetes autoscaling configurations. It supports operations such as building and inspecting lists with fields like `api_version`, `kind`, `metadata`, and `items`, and includes submodules for converting these lists to and from JSON. Use it to programmatically generate autoscaler configurations, parse existing JSON data from Kubernetes, or serialize lists for storage and transmission. Example tasks include reading autoscaler settings from a JSON file, modifying them in memory, and writing them back in serialized form.",
      "description_length": 644,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Metric_status",
      "library": "kubecaml",
      "description": "This module captures the state of a single metric used in autoscaling decisions, supporting construction and access to metric data tied to Kubernetes objects, pods, resources, or external sources. It provides structured types like `Resource_metric_status`, `Pods_metric_status`, `Object_metric_status`, and `External_metric_status` to represent metric details, with operations to evaluate current values against autoscaling targets. The child module extends this by organizing multiple metric statuses into a list of key-value pairs, enabling JSON serialization and deserialization via Yojson for data exchange in autoscaling workflows. Example uses include tracking CPU usage across pods or ingesting external metrics to drive horizontal pod scaling decisions.",
      "description_length": 761,
      "index": 1023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_status",
      "library": "kubecaml",
      "description": "This module provides a structured representation of a Kubernetes pod's runtime status, including phase, IP addresses, and container statuses, with operations to inspect state and diagnose scheduling issues. It defines core types like `t`, `Pod_condition.t`, and `Container_status.t`, enabling checks on container readiness and pod health. The child module handles JSON serialization and deserialization of pod status data, converting between in-memory representations and key-value pair lists. Together, they support efficient status tracking, debugging, and data interchange for Kubernetes pods.",
      "description_length": 596,
      "index": 1024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Service_reference",
      "library": "kubecaml",
      "description": "This module defines a structure to reference a Kubernetes service, including fields for service name, namespace, and an optional path, used in admission control configurations. It provides constructors and accessors for these fields, enabling precise routing of webhook requests to service endpoints. The child module extends this by managing named service references as a list of string-`Service_reference` pairs, offering JSON serialization and deserialization via Yojson. This supports reading and writing admission registration configurations that include multiple service references.",
      "description_length": 588,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Affinity",
      "library": "kubecaml",
      "description": "This module organizes affinity scheduling rules for Kubernetes pods, combining node affinity, pod affinity, and pod anti-affinity into a structured type system. It supports key operations such as creating, modifying, and serializing affinity constraints to JSON using `Yojson.Safe.t`. The child module provides a mapping from string keys to affinity rules, enabling fine-grained control over pod placement policies. You can use this module to define which nodes or pods should co-locate or be separated, directly influencing scheduling decisions in a Kubernetes cluster.",
      "description_length": 570,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Weighted_pod_affinity_term",
      "library": "kubecaml",
      "description": "This module combines a pod affinity term with an integer weight between 1 and 100, used in Kubernetes scheduling to score nodes based on affinity preferences. It supports creating weighted terms, accessing their components, and converting to and from JSON. The child module represents a list of key-value pairs where each value is a weighted pod affinity term, enabling structured definition of affinity rules using pod labels and topology. Together, they allow expressing and serializing complex affinity policies that influence node selection by aggregating weights of matching terms.",
      "description_length": 586,
      "index": 1027,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_env_source",
      "library": "kubecaml",
      "description": "This module structures references to Kubernetes Secrets for injecting their data as environment variables into containers. It provides operations to create and manipulate these references, including accessing the secret name and status, along with serialization functions for JSON conversion. The child module extends this by defining a list of such references, enabling bulk configuration of environment variables sourced from multiple Secrets. You can use this system to securely pass sensitive data from Kubernetes Secrets into pod environments during configuration.",
      "description_length": 569,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for token authentication requests in the Kubernetes API, including creating specifications with optional bearer tokens, extracting tokens, and converting to and from JSON. It centers around the token review specification type, supporting serialization with `to_yojson` and `of_yojson` for integration with authentication flows. You can use it to construct and validate token reviews, extract authentication tokens from specifications, or serialize them for transmission. The module works both directly, through its API, and via its child module, which handles the underlying object structure and JSON conversions.",
      "description_length": 662,
      "index": 1029,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_device",
      "library": "kubecaml",
      "description": "This module defines a mapping for raw block devices within containers, allowing direct access to devices by specifying their host path and container mount point. It supports integration with persistent volume claims by referencing their name and provides functions to construct and manipulate device mappings. The child module handles lists of these mappings, offering JSON serialization and deserialization for use in Kubernetes pod specifications. Example usage includes configuring high-performance storage access in containers by mapping raw disks directly into pods.",
      "description_length": 571,
      "index": 1030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_rollback",
      "library": "kubecaml",
      "description": "This module provides a structured representation of Kubernetes deployment rollback data, including target deployment names, rollback configurations, and optional annotations. It includes utilities to construct, serialize, and access rollback objects, with support for JSON conversion via `to_yojson` and `of_yojson` for integration with Kubernetes v1beta1 APIs. The module is designed for use in Kubernetes operators or automation tools that need to manage and execute deployment rollbacks programmatically. A list of rollback configurations can be processed and converted to JSON for API requests or stored for audit purposes.",
      "description_length": 627,
      "index": 1031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes event management by namespace, enabling targeted operations on events within isolated environments. It supports listing, creating, updating, and deleting events individually or in bulk, with filtering and partial updates via PATCH. Key data types include event objects, namespace identifiers, and patch payloads. You can retrieve event streams with custom queries, update event statuses, or remove outdated events in specific namespaces.",
      "description_length": 470,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler",
      "library": "kubecaml",
      "description": "This module structures and configures horizontal pod autoscalers for Kubernetes, defining metadata, behavior, and status fields. It supports creating, serializing, and deserializing autoscaler configurations, enabling programmatic management of scaling policies based on metrics like CPU usage. The child module handles JSON conversion, working with lists of string-configuration tuples to read and write autoscaler definitions. Together, they allow building, modifying, and persisting autoscaling rules for deployments in Kubernetes environments.",
      "description_length": 547,
      "index": 1033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_disk_volume_source",
      "library": "kubecaml",
      "description": "This module configures Azure disk volume sources for Kubernetes pods, supporting operations to define disk mounts with properties like name, URI, caching mode, and filesystem type. It includes a child module for managing collections of these configurations using string-keyed lists, with support for JSON serialization and deserialization. You can use it to integrate Azure Blob storage into container workloads by specifying persistent volumes in pod definitions. Example uses include constructing a disk configuration, adding it to a list, and converting the structure to JSON for deployment.",
      "description_length": 594,
      "index": 1034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Load_balancer_ingress",
      "library": "kubecaml",
      "description": "This module models the ingress points of a Kubernetes load balancer, capturing either an IP address or hostname, and provides constructors, accessors, and JSON (de)serialization for integration with Kubernetes APIs. It handles use cases such as representing endpoints for cloud load balancers like AWS ELBs or GCP load balancers, where services are exposed via DNS or IP addresses. The child module manages JSON conversion using a list of tuples, each pairing an identifier with an ingress status object, enabling structured API responses and configuration updates. Together, they support creating, manipulating, and serializing ingress status data for service routing in cloud environments.",
      "description_length": 691,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review_status",
      "library": "kubecaml",
      "description": "This module represents the outcome of a Kubernetes authorization decision, providing functions to construct and inspect status objects with fields like `allowed`, `denied`, `reason`, and `evaluation_error`. Its main type models the result of a subject access review, enabling interpretation or generation of access review responses during integration with Kubernetes authorization APIs. The child module handles JSON serialization and deserialization of these status objects, supporting interaction with Kubernetes API endpoints that consume or return access review results in JSON format. Together, they allow building, inspecting, and converting access review statuses for use in authentication workflows and API clients.",
      "description_length": 723,
      "index": 1036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Scale_io_volume_source",
      "library": "kubecaml",
      "description": "This module manages Scale_io volume source configurations for Kubernetes pods, supporting creation, field access, and serialization. It handles required parameters like gateway, system, and secret reference, along with optional settings such as storage pool and SSL mode. The child module provides JSON (de)serialization capabilities, converting configurations to and from JSON for storage or transmission. Users can construct a volume source, modify its fields, and serialize it to JSON or parse it from an existing configuration.",
      "description_length": 531,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Se_linux_options",
      "library": "kubecaml",
      "description": "This module manages SELinux labels for Kubernetes containers, offering operations to create, parse, and serialize labels containing user, role, type, and level fields. It supports direct manipulation of individual labels and includes a submodule for handling collections of labeled containers, enabling structured configuration of pod security policies. You can use it to define SELinux contexts in container specs or extract existing labels from configurations. The module also provides JSON serialization for integration with Kubernetes APIs and policy definitions.",
      "description_length": 567,
      "index": 1038,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_status",
      "library": "kubecaml",
      "description": "This module captures the runtime state of a Kubernetes deployment, tracking pod availability, readiness, and rollout progress through fields like replica counts and condition states. It provides constructors and accessors to inspect deployment health and supports custom reconciliation logic based on observed cluster state. The child module extends this functionality by handling collections of deployment statuses keyed by strings, offering JSON serialization and deserialization for structured data exchange. Together, they enable detailed analysis and storage of deployment outcomes, including extended status metadata.",
      "description_length": 623,
      "index": 1039,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_rules_review",
      "library": "kubecaml",
      "description": "This module reviews the set of actions a user can perform within a Kubernetes namespace, using structures like `Self_subject_rules_review_spec` and `Subject_rules_review_status`. It includes operations for evaluating permissions client-side, serializing to and from JSON, and handling errors or incomplete results due to server authorization modes. The child module focuses on converting rule review data to and from JSON, supporting API communication and structured inspection of permission sets. Use cases include building UIs that reflect user permissions and analyzing access rules locally for visibility, not for enforcing authorization decisions.",
      "description_length": 652,
      "index": 1040,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review_status",
      "library": "kubecaml",
      "description": "This module represents the outcome of a Kubernetes subject access review, capturing whether access is allowed or denied along with optional metadata like reasons and evaluation errors. It supports creating, inspecting, and converting these outcomes to and from JSON using Yojson. The child module extends this capability by handling structured conversion of access review status entries, particularly for working with lists of key-value pairs during data serialization and transmission. Together, they enable precise handling and persistence of authorization decisions within Kubernetes systems.",
      "description_length": 595,
      "index": 1041,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Empty_dir_volume_source",
      "library": "kubecaml",
      "description": "This module defines an ephemeral storage configuration for Kubernetes pods using an empty directory, allowing control over storage medium and size limits. It provides direct access to fields like `medium` and `size_limit`, enabling precise configuration of temporary, in-memory or disk-backed directories for containers. The child module handles JSON serialization and deserialization of these configurations, supporting conversion to and from associative lists mapping strings to volume source settings. Use this module to define and manage temporary storage in pod specifications programmatically or when working with JSON-based Kubernetes APIs.",
      "description_length": 647,
      "index": 1042,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_status",
      "library": "kubecaml",
      "description": "This module tracks the status of a Replica Set in Kubernetes, providing core data types and operations to monitor and manage its state. It includes fields like `replicas`, `ready_replicas`, and `conditions`, with functions to construct and access these values for use cases such as health checks and scaling validation. The module also supports JSON serialization and deserialization, enabling seamless interaction with Kubernetes APIs and persistent storage of status data. Together, these features allow developers to inspect, update, and persist Replica Set statuses efficiently.",
      "description_length": 582,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Ceph_fs_volume_source",
      "library": "kubecaml",
      "description": "This module configures CephFS volume sources for Kubernetes pods, allowing specification of monitors, paths, read-only mode, users, and secret references. It supports operations to construct and manipulate these parameters, enabling authenticated and read-only CephFS mounts within pods. The child module handles JSON serialization and deserialization of these configurations, converting between in-memory representations and JSON for storage or transmission. Example uses include defining a CephFS volume in a pod spec with a custom secret or converting an existing pod spec with CephFS mounts to JSON for persistence.",
      "description_length": 619,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements HTTP client operations for managing Kubernetes `ClusterRoleBinding` resources by name. It provides functions to get, put, delete, and patch cluster role bindings, using a request path template to construct resource URLs. These operations are used to directly manipulate role bindings in a Kubernetes cluster's RBAC system.",
      "description_length": 345,
      "index": 1045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Resource_attributes",
      "library": "kubecaml",
      "description": "This module captures Kubernetes API authorization attributes like group, verb, resource, and namespace, providing precise checks for resource access. It includes operations to construct and inspect these attributes, enabling validation of user permissions such as verifying if a user can delete a pod in a specific namespace. The child module handles lists of these attributes, supporting JSON serialization and deserialization for use in authorization decision workflows. Together, they facilitate structured, attribute-based access control for Kubernetes API requests.",
      "description_length": 570,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for specifying Kubernetes network policies, including ingress and egress rules, label-based pod selection, and policy types. It supports creating, accessing, and serializing network policy specifications to and from JSON, enabling precise control over pod traffic, such as restricting outbound connections or limiting ingress to specific sources. The child module handles collections of network policy specifications using key-value pairs, providing direct serialization to and from JSON with functions like `to_yojson` and `of_yojson`. This allows for parsing and generating structured lists of network policies, such as when loading configuration files or interacting with the Kubernetes API.",
      "description_length": 743,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module enables permission checks within a Kubernetes namespace by creating LocalSubjectAccessReview resources. It provides a `post` function to submit access review requests and a `request_path_template` for constructing API paths. The core data type is LocalSubjectAccessReview, used to evaluate user or group access to namespace-scoped resources. For example, it can verify if a user can read pods or manage secrets within a specific namespace.",
      "description_length": 451,
      "index": 1048,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Local_volume_source",
      "library": "kubecaml",
      "description": "This module manages storage configurations for directly attached node storage in Kubernetes, allowing creation and manipulation of local volume sources with specified file paths. It includes serialization and deserialization to and from JSON, enabling integration with Kubernetes API objects. The child module extends this functionality by handling lists of key-value pairs mapping to local volume sources, providing JSON conversion for pod specifications that reference local storage. Example uses include defining a local directory or block device as a volume source and serializing it for inclusion in a persistent volume claim or pod spec.",
      "description_length": 643,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_update_strategy",
      "library": "kubecaml",
      "description": "This module manages daemon set update strategies for Kubernetes, centering around the `t` type to represent strategy configurations with support for `rolling_update` and `on_delete` types. It provides functions like `make`, `type_`, and `rolling_update` to construct and inspect strategies, while enabling JSON conversion through `to_yojson` and `of_yojson` for integration with Kubernetes APIs. The included submodule handles serialization and deserialization of strategy objects into JSON, operating on key-value lists where each value is a strategy. Users can create a rolling update strategy with specific parameters, inspect its type, or convert strategies to and from JSON for storage or API communication.",
      "description_length": 712,
      "index": 1050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_waiting",
      "library": "kubecaml",
      "description": "This module models the waiting state of a container in a Kubernetes pod, offering functions to construct and manipulate states with optional `reason` and `message` fields. It supports direct inspection and creation of container states, such as when an image is being pulled or dependencies are unresolved. A child module extends this functionality to handle lists of container waiting states, enabling conversion to and from Yojson for use with Kubernetes API interactions. Together, they provide a structured way to represent, serialize, and interpret container state data during cluster operations.",
      "description_length": 600,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set",
      "library": "kubecaml",
      "description": "This module manages stateful applications in Kubernetes by defining data structures and operations for creating, serializing, and inspecting stateful sets. It supports stable network identities and storage mappings, with core functions to manipulate metadata, specs, and status fields, and includes JSON serialization for data exchange. The child module handles conversion to and from JSON, enabling persistence and transmission of stateful set configurations. You can use it to define databases or distributed systems where each pod has consistent storage and network identity across restarts.",
      "description_length": 594,
      "index": 1052,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Roles",
      "library": "kubecaml",
      "description": "This module watches for changes to Role resources in a Kubernetes cluster. It provides a `get` function to stream Role events with optional filtering by label or field selectors, resource version, and timeout settings. Use it to monitor Role updates in real time, such as tracking role modifications for audit or synchronization tasks.",
      "description_length": 335,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Rule",
      "library": "kubecaml",
      "description": "This module structures Kubernetes admission rules through tuples of API groups, versions, and resources, enabling precise criteria for validating or mutating API requests. It provides operations to construct, access, and serialize rule objects, often used in admission webhooks to enforce policies. The child module extends this by handling rule definitions in the context of API groups, supporting JSON conversion for configuration. Together, they allow defining and managing admission control logic based on resource types and API versions.",
      "description_length": 542,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Photon_persistent_disk_volume_source",
      "library": "kubecaml",
      "description": "This module represents a Photon Controller persistent disk volume source in Kubernetes, providing constructors and accessors for the disk identifier (`pd_id`) and optional filesystem type (`fs_type`). It supports direct creation and manipulation of disk volume configurations, enabling integration with Kubernetes storage volumes that reference Photon-managed disks. The module includes JSON serialization and deserialization capabilities, allowing conversion between in-memory structures and JSON payloads for API interactions or configuration storage. For example, you can create a disk volume source with a specific `pd_id` and `fs_type`, then serialize it to JSON for use in a Kubernetes pod specification.",
      "description_length": 710,
      "index": 1055,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_condition",
      "library": "kubecaml",
      "description": "This module models the state of a Kubernetes deployment at specific points in time, capturing properties like type, status, reason, and optional timestamps for transitions. It provides operations to create, inspect, and serialize individual conditions as well as collections of conditions, supporting precise tracking of deployment status changes. The child module handles lists of conditions keyed by string, enabling structured serialization to JSON for persistence or transmission. Use this module to monitor deployment health, debug status transitions, or record condition history in a structured format.",
      "description_length": 608,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Mutating_webhook_configuration",
      "library": "kubecaml",
      "description": "This module configures mutating admission webhooks in Kubernetes, enabling the definition and manipulation of rules that modify resources during creation or update. It provides data types for webhook configurations, including fields like `api_version`, `kind`, `metadata`, and a list of `webhooks`, along with operations to construct and serialize these configurations. The child module handles JSON conversion, allowing seamless translation between in-memory structures and the JSON payloads used by Kubernetes admission controllers. Example uses include injecting sidecars into pods or applying default labels to resources based on policy.",
      "description_length": 641,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Ingresses",
      "library": "kubecaml",
      "description": "This module watches for changes to Ingress resources in a Kubernetes cluster. It provides functions to construct request paths and retrieve streaming updates with optional filtering by label or field selectors, resource version, and timeout settings. Use it to monitor ingress events in real time, such as tracking new ingress creation or configuration changes.",
      "description_length": 361,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_status",
      "library": "kubecaml",
      "description": "This module manages node status information in a Kubernetes cluster, providing structured access to runtime state such as node addresses, resource capacity, conditions, and volumes. It supports operations to construct, update, and query node status fields directly, while its child module handles collections of node statuses with JSON serialization via `Yojson`. You can use it to check node health, track available resources, or serialize node state for transmission or storage. The combination enables both fine-grained status manipulation and bulk processing of node data.",
      "description_length": 576,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_affinity",
      "library": "kubecaml",
      "description": "This module orchestrates pod affinity scheduling rules, enabling precise control over pod placement in Kubernetes clusters. It centers around data structures that represent affinity terms\u2014such as required and preferred rules\u2014and supports operations like rule creation, serialization, and evaluation based on existing pod distributions. Submodules refine this functionality by organizing affinity rules under specific keys, facilitating structured configuration and JSON conversion for storage or API transmission. For example, it can enforce that tightly coupled microservices schedule on the same node or prioritize placement near pods with shared storage volumes.",
      "description_length": 665,
      "index": 1060,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler",
      "library": "kubecaml",
      "description": "This module provides tools to construct, serialize, and inspect horizontal pod autoscaler configurations, enabling automatic scaling of Kubernetes resources based on defined metrics. It supports creating autoscaler instances with optional metadata, specs, and status fields, and includes JSON conversion for API interactions. The child module handles serialization to and from JSON, supporting structured storage and retrieval of autoscaling policies. Example uses include defining autoscaling rules for deployments based on CPU usage or custom metrics, and persisting those configurations in JSON format.",
      "description_length": 605,
      "index": 1061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoints",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes service endpoints, representing network locations through structured subsets of IP addresses and ports. It supports constructing, serializing, and accessing endpoint data, including metadata, API version, and kind fields. Submodules handle JSON conversion and subset management, enabling precise control over service routing and discovery. Example usage includes defining multiple endpoint subsets for a service, serializing them for storage or transmission, and retrieving specific addresses or ports for cluster communication.",
      "description_length": 561,
      "index": 1062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Services",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Services within a namespace, providing `get` to list or watch Services and `post` to create a new Service, using standard Kubernetes API query parameters and request options. It operates on `Service_list` and `Service` data types, representing collections and individual Service resources. The status submodule allows direct manipulation of Service status conditions, while the proxy submodule forwards HTTP requests to running Services, supporting path-based routing for metrics or custom endpoints. Together, these enable full lifecycle management of Services, from creation and monitoring to status updates and endpoint interaction.",
      "description_length": 666,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set",
      "library": "kubecaml",
      "description": "This module provides tools for creating, modifying, and analyzing Stateful_set resources, ensuring stable network and storage identities for pods in Kubernetes clusters. It supports operations such as setting metadata, inspecting spec and status fields, and converting configurations to and from JSON. The child module enhances this functionality by enabling structured serialization and deserialization, allowing Stateful_set objects to be stored, transmitted, or parsed programmatically. Together, they facilitate defining and managing stateful applications with consistent identities across cluster environments.",
      "description_length": 615,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_status",
      "library": "kubecaml",
      "description": "This module tracks the status of Kubernetes DaemonSets, capturing details like scheduled, ready, and misscheduled node counts. It supports constructing, modifying, and serializing status objects to JSON, enabling health monitoring and scheduling analysis. The child module manages collections of these statuses, mapping string keys to status values and supporting bulk JSON serialization. Together, they facilitate handling individual and grouped DaemonSet status data for cluster management and controller coordination.",
      "description_length": 520,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_volume_source",
      "library": "kubecaml",
      "description": "This module projects Kubernetes Config_map data into a volume, exposing each key as a file with optional path mapping, permission settings, and key selection. It provides the `make` function to construct volume sources and supports advanced configuration like ownership management and SELinux relabeling. The child module handles JSON serialization and deserialization of these volume configurations, enabling seamless integration with Kubernetes pod definitions. Example usage includes mounting application configuration files from a Config_map into a running pod.",
      "description_length": 565,
      "index": 1066,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota_status",
      "library": "kubecaml",
      "description": "This module captures the status of resource quotas in a Kubernetes cluster, tracking hard limits and current usage for resources like CPU and memory using `Quantity.Object`. It supports creating, accessing, and serializing quota status data, with optional fields for hard limits and usage. The child module handles lists of resource quota statuses, enabling structured parsing and generation of Kubernetes API responses in JSON. For example, it can track memory usage against set quotas or serialize quota data for API communication.",
      "description_length": 533,
      "index": 1067,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container",
      "library": "kubecaml",
      "description": "This module defines and manipulates individual containers within a Kubernetes pod, offering structured access to core properties such as images, environment variables, ports, and lifecycle probes. It supports direct configuration of runtime settings like volume mounts, termination messages, and TTY allocation, with built-in JSON serialization for Kubernetes API compatibility. The child module extends this functionality to handle collections of named containers, enabling seamless conversion between lists of containers and JSON representations. Together, they allow developers to programmatically define, modify, and serialize container configurations for use in cluster orchestration workflows.",
      "description_length": 699,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Podsecuritypolicies.By_name",
      "library": "kubecaml",
      "description": "This module handles direct interactions with Kubernetes PodSecurityPolicy resources by name, offering CRUD operations through HTTP methods. It works with Pod_security_policy and related Kubernetes API types like Delete_options and Patch. Concrete use cases include retrieving, updating, deleting, or patching specific PodSecurityPolicies within a cluster.",
      "description_length": 355,
      "index": 1069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale",
      "library": "kubecaml",
      "description": "This module manages scaling operations for Kubernetes resources by defining a `Scale` type with fields for metadata, kind, API version, spec, and status, enabling precise control over scaling behavior and state. It supports constructing and manipulating scale objects directly, with use cases like implementing horizontal pod autoscaling and managing replica counts. The child module extends this functionality by handling collections of named scaling requests, providing JSON serialization via Yojson for structured configuration management. Together, they facilitate processing, persisting, and applying scaling configurations in deployment workflows.",
      "description_length": 653,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Resource_attributes",
      "library": "kubecaml",
      "description": "This module captures Kubernetes API authorization attributes like group, version, resource, and verb into a structured format, enabling precise checks for resource access. It supports constructing and querying these attributes to validate permissions, such as verifying if a user can delete a pod in a specific namespace. The child module handles JSON serialization and deserialization of these records, facilitating interaction with Kubernetes authorization endpoints using key-attribute tuple lists. Together, they provide a complete workflow for managing and transmitting authorization data in real-world access control scenarios.",
      "description_length": 633,
      "index": 1071,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_access_review_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for specifying access review requests in a Kubernetes authorization system. It includes functions to create and manipulate access review specifications with optional user, group, resource, and non-resource attributes, supporting both resource-based and non-resource-based authorization checks. The child module handles serialization and deserialization of these specifications, enabling JSON conversion via Yojson for use in API interactions. Use this module to construct, validate, and serialize access review requests for evaluating permissions in Kubernetes API operations.",
      "description_length": 625,
      "index": 1072,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_anti_affinity",
      "library": "kubecaml",
      "description": "This module defines and manages pod anti-affinity rules for Kubernetes scheduling, enabling the creation and manipulation of constraints that prevent pods from being colocated based on label selectors. It supports both required and preferred rule types, allowing precise control over pod distribution across nodes or topologies. The module includes operations to build, modify, and serialize anti-affinity policies, with direct support for converting rule lists to and from JSON for integration with configuration workflows. For example, you can define a rule that avoids placing pods on nodes running a specific service or use serialized JSON to persist and load anti-affinity configurations across deployments.",
      "description_length": 712,
      "index": 1073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Eviction",
      "library": "kubecaml",
      "description": "This module manages eviction requests for pods in a Kubernetes cluster, allowing creation and manipulation of eviction objects with metadata, API version, and delete options. It provides direct accessors for field retrieval and supports interaction with Kubernetes eviction subresources through proper policy enforcement. The child module extends this functionality by grouping eviction requests into a list, where each entry pairs a pod name with an eviction policy, enabling batch handling and validation. Together, they facilitate programmatic eviction triggering and policy-compliant management via JSON serialization and Kubernetes API integration.",
      "description_length": 653,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set",
      "library": "kubecaml",
      "description": "This module provides tools for constructing and manipulating Replica_set objects in the Kubernetes API, including setting metadata, specifications, and status fields. It supports structured data types that model Kubernetes Replica_set resources, with nested submodules for handling specs and status. The module includes functions for converting Replica_set definitions to and from JSON, enabling API communication and configuration storage. Use cases include creating Replica_set definitions for deployment management and working with lists of Replica_set objects in JSON format.",
      "description_length": 579,
      "index": 1075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Bindings",
      "library": "kubecaml",
      "description": "This module handles the creation of Kubernetes Binding resources within a specified namespace. It provides a `post` function to submit a binding request to the Kubernetes API, accepting parameters such as namespace, request body, and optional HTTP context and headers. The module uses the `Binding.t` type from the Core V1 API definitions and returns a result indicating success or failure of the binding operation.",
      "description_length": 415,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_status",
      "library": "kubecaml",
      "description": "This module tracks the runtime state of Kubernetes namespaces, centered on the optional `phase` field that indicates lifecycle stages like \"Active\" or \"Terminating\". It supports inspecting and serializing namespace status data, often used during cluster management tasks. The child module extends this by handling collections of namespace statuses as key-value pairs, enabling bulk processing and JSON serialization via Yojson. Together, they facilitate both individual and batch operations on namespace status information.",
      "description_length": 523,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes LimitRange objects, enabling the construction, serialization, and manipulation of lists containing resource constraints for containers. It directly supports operations on `Limit_range.t` lists, with metadata handling via `List_meta.t` and optional API versioning. The child module extends this by supporting JSON conversion for structured data exchange in API interactions. Example uses include enforcing CPU/memory limits across clusters and serializing configurations for storage or transmission.",
      "description_length": 544,
      "index": 1078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Allowed_host_path",
      "library": "kubecaml",
      "description": "This module manages allowed host path constraints for Kubernetes pod volumes, ensuring paths adhere to specified prefixes without wildcard support. It provides functions to construct, serialize, and access host path policies, often used when restricting container access to specific host directories. The child module represents a list of key-value pairs where each key is a string and the value is an `Allowed_host_path` definition, enabling structured specification of multiple allowed paths in pod security policies. Together, they facilitate defining and enforcing precise host volume access rules in Kubernetes environments.",
      "description_length": 629,
      "index": 1079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_egress_rule",
      "library": "kubecaml",
      "description": "This module defines network policy egress rules that control outbound traffic from pods by specifying allowed destination peers and ports. It supports creating, modifying, and extracting rule components such as peer selectors and port ranges, enabling precise control over Kubernetes pod egress at the network level. The child module handles lists of these rules, providing JSON serialization via Yojson for integration with Kubernetes APIs and configuration files. You can use this module to programmatically define or parse egress policies that restrict or allow traffic based on specific network criteria.",
      "description_length": 608,
      "index": 1080,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes RBAC role binding list object, providing functions to construct, manipulate, and version collections of role bindings. It operates on a list of `Role_binding.t` values, supporting JSON serialization and deserialization via Yojson for use with Kubernetes API interactions or RBAC configuration files. The module handles API versioning, kind identification, and metadata, while its child module manages the list structure and JSON conversion. Example uses include generating RBAC manifests or parsing role binding lists from API server responses.",
      "description_length": 580,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_rules_review_status",
      "library": "kubecaml",
      "description": "This module captures the outcome of a Kubernetes authorization rules check, representing both resource and non-resource permissions granted to a subject along with evaluation errors and completeness flags. It provides constructors and accessors to inspect or build authorization decisions, and includes a child module for JSON serialization and deserialization of rule results as string-tuple lists. The main data types include the subject rules review status itself and associated error information, with operations to convert to and from JSON using `to_yojson` and `of_yojson`. You can use it to evaluate access rules for subjects in a cluster, handle incomplete rule sets due to missing authorizers, and interface directly with Kubernetes' SubjectRulesReview API.",
      "description_length": 766,
      "index": 1082,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Local_object_reference",
      "library": "kubecaml",
      "description": "This module provides a way to reference Kubernetes objects within the same namespace, enabling cross-references between resources such as secrets and config maps. It supports constructing and accessing references by name, along with JSON serialization and deserialization via Yojson. The submodule handles conversion of reference lists to and from JSON, facilitating integration with Kubernetes APIs. Example usage includes referencing a secret in a pod spec or mapping config data by name within a deployment.",
      "description_length": 510,
      "index": 1083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_egress_rule",
      "library": "kubecaml",
      "description": "This module represents a deprecated version of a Kubernetes network policy egress rule, defining allowed outbound traffic based on destination peers and ports. It provides constructors to create rules with optional peer and port filters, along with accessors to retrieve these fields. The associated JSON submodule enables conversion of egress rules to and from JSON, supporting use cases like storing policy configurations or processing API responses. Together, these components allow developers to define, manipulate, and serialize network policy egress rules for controlling pod outbound traffic.",
      "description_length": 599,
      "index": 1084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_quota",
      "library": "kubecaml",
      "description": "This module manages Kubernetes resource quotas by defining data structures and operations for creating, accessing, and manipulating quota restrictions at the namespace level. It includes functions to work with metadata, spec, and status fields of resource quotas, enabling precise control over CPU, memory, and storage limits. The child module handles JSON serialization and deserialization of resource quota objects, allowing conversion between in-memory representations and JSON-formatted data. Together, they support tasks like enforcing resource constraints, exporting quota configurations, and parsing quota definitions from external sources.",
      "description_length": 647,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Daemon_set_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes DaemonSet configurations, managing deployment across nodes with strategies like rolling updates and rollback policies. It defines key types such as update strategy, pod template, and label selector, enabling precise control over DaemonSet behavior. The child module handles lists of key-value paired DaemonSet specs, offering JSON serialization and deserialization for storage or transmission. Use cases include configuring node-specific workloads, enforcing pod readiness, and managing versioned DaemonSet deployments.",
      "description_length": 553,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_system_info",
      "library": "kubecaml",
      "description": "This module captures detailed system information for a Kubernetes node, including identifiers like system UUID and machine ID, along with component versions such as kubelet and the kernel. It provides constructors, accessors, and JSON serialization via `Yojson` for structured data exchange. The child module handles conversion between JSON and typed node system info structures, supporting operations like parsing JSON input or serializing node metadata for transmission. Use this module to gather, serialize, and manage node metadata for monitoring, debugging, and cluster management tasks.",
      "description_length": 592,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Local_subject_access_review",
      "library": "kubecaml",
      "description": "This module evaluates whether users or groups can perform actions within Kubernetes namespaces, using structured types like `Subject_access_review_spec`, `Subject_access_review_status`, and `Object_meta`. It supports creating and inspecting access reviews directly, enabling fine-grained authorization checks in namespace-scoped policies. The child module handles JSON serialization of access review configurations, converting between string identifiers and review data using `Yojson.Safe.t`. Together, they allow applications to enforce and validate permissions programmatically, such as checking if a user can deploy resources in a specific namespace.",
      "description_length": 653,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of various Kubernetes resources within a namespace, including Events, Pods, Secrets, Services, and more, with support for label and field selectors, resource version control, timeout settings, and event streaming. Each resource type exposes a `get` function to initiate a watch stream for specific instances, while broader watch functions track changes across the namespace, returning structured `Watch_event` data for inspection or automated responses. You can use it to detect Pod status transitions, track ConfigMap updates, monitor PersistentVolumeClaims, or react to Service configuration changes as they occur. The combined interfaces enable precise, scalable observation of cluster state with customizable filtering and streaming behavior.",
      "description_length": 788,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes list of Deployments, providing functions to construct and access Deployment collections with associated metadata, kind, and API version. It supports JSON serialization and deserialization for data interchange and configuration handling, allowing Deployment data to be converted to and from JSON for storage or transmission. The main type `t` holds a list of Deployments along with group, version, and kind information. Example uses include retrieving a batch of Deployments from a cluster or persisting Deployment configurations in JSON format.",
      "description_length": 580,
      "index": 1090,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset_list",
      "library": "kubecaml",
      "description": "This module manages Kubernetes PodPresetList objects, offering functions to construct, serialize, and access lists of Pod_preset items along with their metadata, kind, and API version. It includes direct operations for creating and modifying PodPreset lists, and provides a child module for converting these lists to and from JSON using `to_yojson` and `of_yojson`. Use it to build and manipulate PodPreset configurations programmatically or when interfacing with Kubernetes APIs that consume or return PodPresetList resources.",
      "description_length": 527,
      "index": 1091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Rolebindings",
      "library": "kubecaml",
      "description": "This module watches for changes to RoleBinding resources in a Kubernetes cluster. It provides a `get` function to stream events matching specified criteria, such as label or field selectors, and uses a request path template to target the appropriate API endpoint. Use this module to monitor RoleBinding updates in real-time, for example, to trigger actions when role bindings are created or modified.",
      "description_length": 400,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_status_list",
      "library": "kubecaml",
      "description": "This module manages a list of Kubernetes component statuses, including metadata, kind, and API version fields, and provides operations to construct, access, and serialize these lists using `Yojson`. Each entry pairs a string identifier with a `Component_status_list.t` value, representing the status of a specific component. The module supports parsing and generating JSON responses from Kubernetes API endpoints, allowing direct manipulation of component status data. The child module enhances this functionality by implementing tuple-based serialization for structured status lists.",
      "description_length": 584,
      "index": 1093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Podsecuritypolicies",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of PodSecurityPolicy resources in a Kubernetes cluster, offering a `get` function to stream create, update, and delete events with optional filtering via `label_selector` and `field_selector`. It works directly with Kubernetes API types like `Watch_event` and `Pod_security_policy`, allowing precise tracking of policy changes such as updates or deletions. A concrete use case includes automating compliance checks or audit logging in response to policy modifications. The module supports both broad event streaming and fine-grained retrieval of specific policies by name.",
      "description_length": 613,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Clusterrolebindings.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing Kubernetes ClusterRoleBindings by name, including get, put, delete, and patch methods. It works with ClusterRoleBinding and related Kubernetes API types such as DeleteOptions and Patch. Use this module to directly manipulate ClusterRoleBinding resources in a Kubernetes cluster, such as retrieving a binding, replacing its rules, or deleting it.",
      "description_length": 397,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Aggregation_rule",
      "library": "kubecaml",
      "description": "This module defines how to locate and combine ClusterRoles using label selectors, forming dynamic aggregations of permissions in Kubernetes RBAC. It provides data types for specifying selector-based rules and operations to build, access, and manipulate these rules. The child module handles the representation of selected ClusterRoles as a list, supporting JSON serialization and deserialization for integration with external configurations. Use this module to programmatically define and manage role aggregations that automatically collect permissions from matching ClusterRoles.",
      "description_length": 580,
      "index": 1096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Statefulsets",
      "library": "kubecaml",
      "description": "Implements watching for changes to StatefulSet resources in a Kubernetes cluster. It provides a function to construct request paths and another to perform GET requests with customizable parameters like timeouts, resource versions, and selectors. This module is used to monitor real-time updates to StatefulSets, such as during deployment rollouts or scaling operations.",
      "description_length": 369,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rollback_config",
      "library": "kubecaml",
      "description": "This module manages rollback configurations for Kubernetes deployments, centered around specifying and manipulating revision numbers. It provides core operations to create, retrieve, and serialize revision data, enabling precise control over deployment rollbacks. The child module extends this functionality by handling lists of named rollback configurations, converting them to and from JSON for integration with Kubernetes APIs. For example, you can define a rollback target with `create 3`, then serialize it to JSON for submission or parse existing configuration data into OCaml structures.",
      "description_length": 594,
      "index": 1098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller",
      "library": "kubecaml",
      "description": "This module manages the configuration and behavior of Kubernetes replication controllers, ensuring a specified number of pod instances are running. It defines key data types representing metadata, specifications, and status, with operations to create, modify, and access components like replica counts and pod templates. The module includes a child module for JSON serialization and deserialization, working with string-identified replication controller configurations for storage or transmission. Example uses include defining replicated workloads and converting controller configurations to JSON for integration with other systems.",
      "description_length": 633,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_ref",
      "library": "kubecaml",
      "description": "This module provides a structured representation of Kubernetes RBAC role references, capturing attributes like role name, kind, and API group. It includes utilities to construct, inspect, and serialize role references, particularly supporting conversion to and from JSON via its dedicated submodule. The core API allows direct manipulation of role reference fields, while the submodule enables batch processing of role references paired with identifiers, facilitating efficient handling of RBAC configuration data. Example uses include building role bindings programmatically and serializing them for cluster configuration updates.",
      "description_length": 631,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module streams real-time updates for ClusterRoleBinding resources, allowing observation of RBAC policy changes across the cluster. It supports filtering by resource version, label selectors, and timeouts, returning events via a `get` function that yields a `Watch_event`. The child module extends this by enabling targeted observation of specific ClusterRoleBinding instances by name. Together, they enable precise monitoring of role bindings, such as detecting when new subjects are granted cluster-wide permissions or when existing bindings are modified.",
      "description_length": 561,
      "index": 1101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_status",
      "library": "kubecaml",
      "description": "This module represents the state of a cron job in a Kubernetes cluster, providing functions to create and manipulate status objects with optional active job references and last schedule times. It includes accessors to retrieve these fields and integrates with Kubernetes object references and time representations for tracking execution state. The child module handles JSON serialization and deserialization of cron job status data in batch v1beta1 format, using associative lists mapping strings to status values. Use this module to construct, inspect, and convert cron job statuses when interacting with Kubernetes APIs or managing job scheduling state.",
      "description_length": 655,
      "index": 1102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time observation of Kubernetes workload changes within a namespace, focusing on StatefulSets, Deployments, and ControllerRevisions. It offers event streaming with support for label and field selectors, resource versioning, and name-based filtering via `get` operations. Developers can monitor rollout progress, trigger actions on updates, or track deletions with custom timeout configurations. Example uses include autoscaling based on StatefulSet changes and auditing ControllerRevision deletions.",
      "description_length": 523,
      "index": 1103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates Pod Disruption Budget policies in Kubernetes, using label selectors and availability constraints. It allows specifying either a minimum number of available pods or a maximum number of unavailable pods to control eviction behavior. The child module handles collections of these policies, enabling JSON serialization and deserialization for API interactions or configuration management. Example use cases include defining eviction rules for a deployment and serializing them into JSON for cluster policy enforcement.",
      "description_length": 553,
      "index": 1104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Rolling_update_daemon_set",
      "library": "kubecaml",
      "description": "This module configures rolling updates for DaemonSets in Kubernetes, centered around the `t` type that specifies the maximum number of unavailable pods during an update. It uses `Int_or_string` to express either absolute counts or percentages, enabling flexible availability constraints. The module supports creating and inspecting update strategies, and works with a child module that handles lists of key-value pairs representing these strategies, providing JSON serialization and deserialization via `to_yojson` and `of_yojson`. This allows defining, parsing, and enforcing custom rolling update behaviors in Kubernetes deployments.",
      "description_length": 635,
      "index": 1105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale_spec",
      "library": "kubecaml",
      "description": "This module defines a data structure for specifying the desired state of a Kubernetes scale subresource using integer replica counts, with functions to construct, access, and serialize specifications to and from JSON. It supports optional replica fields to handle dynamic scaling scenarios, such as configuring horizontal pod autoscaling parameters. The child module extends this functionality by managing multiple named scale specifications as a list of key-value pairs, enabling structured handling of complex scaling configurations. Together, they facilitate serialization, configuration, and API interaction for Kubernetes scaling mechanisms.",
      "description_length": 646,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes RBAC cluster roles, represented as key-value pairs where each key is a string identifier and the value is a cluster role object. It supports constructing, serializing, and accessing cluster role lists, with fields like API version, kind, metadata, and the role list itself. Operations include converting the collection to and from JSON using `to_yojson` and `of_yojson`, enabling integration with Kubernetes RBAC APIs for configuration and policy tasks. It is used to retrieve or manipulate groups of cluster roles during system management or access control enforcement.",
      "description_length": 617,
      "index": 1107,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Allowed_flex_volume",
      "library": "kubecaml",
      "description": "This module defines a structure for specifying allowed Flexvolume drivers in Kubernetes, with functions to create and access the driver name, along with JSON serialization and deserialization. It supports managing Flexvolume configurations through a list-based mapping of string keys to Flexvolume entries, enabling precise control over permitted drivers. Use it to configure storage plugins requiring flexible volume support within Kubernetes policies. The module and its submodules together facilitate both direct manipulation of individual Flexvolume entries and structured management of driver configurations.",
      "description_length": 613,
      "index": 1108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides programmatic access to Kubernetes RBAC resources within a namespace, focusing on Role and RoleBinding management through HTTP interactions. It supports key operations like listing, creating, updating, and deleting roles and role bindings, using precise types such as `Role`, `RoleList`, `RoleBinding`, and `RoleBindingList`, along with parameters like `label_selector` and `resource_version` for filtering and synchronization. You can use it to automate access control setup, enforce permission policies, or clean up RBAC configurations during namespace lifecycle events.",
      "description_length": 592,
      "index": 1109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Http_get_action",
      "library": "kubecaml",
      "description": "This module defines and manipulates HTTP GET action configurations, primarily for use in Kubernetes readiness or liveness probes. It supports creating and accessing parameters such as host, path, port, scheme, and custom headers, enabling precise control over HTTP GET requests made by probes. The child module provides a list structure for managing multiple HTTP GET configurations, with JSON serialization and deserialization for integration with Kubernetes APIs. Example uses include defining custom health checks in container specifications or configuring probe behavior in deployments.",
      "description_length": 590,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Validating_webhook_configuration",
      "library": "kubecaml",
      "description": "This module manages validating webhook configurations for Kubernetes admission control, enabling the creation, serialization, and manipulation of policies that validate resources during creation or update. It provides direct access to fields like `api_version`, `kind`, `metadata`, and a list of `webhooks`, while its child module handles conversion between OCaml records and JSON format using key-value pairs. You can define validation rules that reject malformed resources or enforce custom policies, such as requiring specific annotations or rejecting pods with insecure configurations.",
      "description_length": 589,
      "index": 1111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_update_strategy",
      "library": "kubecaml",
      "description": "The module defines a `t` type to represent StatefulSet update strategies, supporting creation, configuration, and JSON serialization of strategies such as rolling updates. It integrates with rolling update parameters to control update behavior during StatefulSet revisions. The child module handles lists of strategy definitions, enabling conversion between JSON and OCaml representations for persistence or API communication. Example uses include defining a rolling update with specific batch sizes and converting strategy configurations to JSON for deployment.",
      "description_length": 562,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_list",
      "library": "kubecaml",
      "description": "This module manages a list of Kubernetes services with fields for API version, kind, metadata, and service items, supporting construction, serialization, and access operations. It includes a child module that organizes service lists by namespace, using tuples of namespace strings and service list values for JSON serialization and deserialization. You can use it to process and transmit Kubernetes service data grouped by namespace, such as when retrieving or storing cluster state. Example tasks include converting a namespaced service list to JSON for API communication or extracting metadata from a service list for analysis.",
      "description_length": 629,
      "index": 1113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Aggregation_rule",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for specifying how to aggregate ClusterRoles into a ClusterRole based on label selectors. It includes functions to create, access, and serialize an aggregation rule, which contains an optional list of label selectors used to locate matching ClusterRoles. The child module extends this by representing a list of labeled aggregation rules, enabling structured grouping and JSON serialization via Yojson. Together, they support dynamic role aggregation in Kubernetes RBAC configurations by defining and combining rules that select ClusterRoles based on label criteria.",
      "description_length": 614,
      "index": 1114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set",
      "library": "kubecaml",
      "description": "This module provides tools for constructing and modifying DaemonSet configurations used in Kubernetes clusters, allowing users to define metadata, specs, and statuses. It supports operations such as creating DaemonSet objects and converting them to or from JSON using the child module that handles structured data serialization. Specific use cases include generating deployable DaemonSet configurations and persisting or transmitting them as JSON. The combination of direct object manipulation and JSON conversion enables seamless integration with Kubernetes APIs and configuration management systems.",
      "description_length": 601,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1.User_info",
      "library": "kubecaml",
      "description": "This module represents user authentication information in Kubernetes, including username, UID, groups, and extra metadata. It provides functions to construct and access user details, along with JSON serialization and deserialization via `to_yojson` and `of_yojson`. The child module extends this functionality by handling collections of user information entries, each pairing a string identifier with a user info value. These structures are used to manage and transmit authenticated user identity and group membership during Kubernetes API interactions.",
      "description_length": 553,
      "index": 1116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides a REST interface for managing Kubernetes CronJob resources within a namespace, supporting operations to list, create, and delete CronJobs. It works with CronJob and CronJobList data types, enabling tasks like scheduling periodic workloads and managing batch processing workflows. The status submodule allows inspection and updates to a CronJob's runtime state, offering precise control over execution and configuration. Example uses include automating job scheduling and modifying job policies through HTTP requests.",
      "description_length": 537,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_strategy",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes deployment strategies by defining how existing pods are replaced with new ones during updates. It centers around the `Deployment_strategy.t` type, supporting creation, inspection, and JSON serialization of strategies such as rolling updates. Operations include setting max surge and unavailable thresholds, retrieving strategy types, and integrating with Kubernetes manifests via JSON. Submodules handle structured configuration of strategy parameters, enabling precise control over deployment behavior in cluster management workflows.",
      "description_length": 571,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_condition",
      "library": "kubecaml",
      "description": "This module models the state of batch jobs through structured condition records, capturing transitions with fields like type, status, reason, and timestamps. It supports creating, inspecting, and serializing job conditions, enabling precise tracking and debugging of job execution. Child modules organize these conditions into collections, facilitating efficient management and conversion to JSON for external communication. Use cases include failure diagnosis, progress monitoring, and triggering control flow based on job status changes.",
      "description_length": 539,
      "index": 1119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_volume_source",
      "library": "kubecaml",
      "description": "This module projects Kubernetes Secrets into containers as files, using keys from the Secret's Data field as filenames. It supports ownership management, SELinux relabeling, and optional configuration of file permissions and key selection. The main data type is a volume source that maps Secret keys to mounted files, and it enables use cases like mounting database credentials or TLS certificates as readable files in a pod. A helper submodule handles JSON serialization and deserialization of these volume configurations using `Yojson.Safe.t`, facilitating integration with Kubernetes APIs or configuration storage.",
      "description_length": 617,
      "index": 1120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_status",
      "library": "kubecaml",
      "description": "The module represents and manipulates the status of a volume attachment request in a Kubernetes API context, tracking success state, metadata, and errors from attach or detach operations. It provides constructors, accessors, and JSON conversion for `t` values, supporting integration with storage controllers or external attacher components. The child module handles JSON serialization and deserialization of Volume_attachment_status objects, converting them to and from key-value lists for storage or transmission. Together, they enable structured status tracking and data exchange for volume attachment workflows.",
      "description_length": 615,
      "index": 1121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides operations to manage Kubernetes Job resources within a namespace, supporting listing, creation, deletion, and state inspection using types like `Job`, `Job_list`, and `Status`. It enables automation of job lifecycle tasks and real-time monitoring through targeted status updates and API-driven state adjustments. Example use cases include tracking job execution in real time, restarting failed jobs, and programmatically scaling job configurations.",
      "description_length": 469,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review_status",
      "library": "kubecaml",
      "description": "This module represents the outcome of a token authentication request in a Kubernetes API context, providing functions to construct and deconstruct status objects that may include user information, authentication results, or error messages. It supports operations to serialize and deserialize these objects to and from JSON, using a list of string-token review status pairs for structured data handling. The module enables processing and returning token validation results in authentication workflows, such as converting a list of user attributes into a JSON-formatted token review response. Specific examples include parsing incoming token review requests and generating structured authentication responses for Kubernetes API interactions.",
      "description_length": 739,
      "index": 1123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Probe",
      "library": "kubecaml",
      "description": "This module configures health checks for containers using structured data, supporting actions like HTTP GET, TCP socket, and exec with parameters such as timeouts and thresholds. It enables creating and inspecting probe settings used in liveness and readiness checks for Kubernetes pods. The child module manages collections of named probes and provides JSON serialization for integration with Kubernetes API operations. Example uses include defining health check policies for containerized applications and converting probe configurations to JSON for deployment.",
      "description_length": 563,
      "index": 1124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_rules_review",
      "library": "kubecaml",
      "description": "This module constructs and manipulates SelfSubjectRulesReview objects representing user permissions within a Kubernetes namespace, supporting creation, field access, and serialization. It handles API requests to retrieve user permissions for UI visibility control or diagnostics, and includes functions for converting rule review data to and from JSON. The JSON submodule specifically enables serialization of SelfSubjectRulesReview objects for transmission or storage, working with lists of string-tuples containing review data. Together, these components provide a complete interface for building, inspecting, and encoding permission reviews for user-facing tools.",
      "description_length": 666,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_binding",
      "library": "kubecaml",
      "description": "This module provides tools for creating and managing Role_binding objects in Kubernetes RBAC, allowing precise assignment of roles to users or service accounts within a namespace. It supports operations to set and retrieve subjects, role references, metadata, and API versioning, centered around the Role_binding.t type. The module includes functions for converting Role_binding data to and from JSON, enabling seamless integration with storage systems or API endpoints. For example, you can define a Role_binding that grants a user access to resources in a specific namespace, then serialize it for storage or deserialize a stored configuration to apply it programmatically.",
      "description_length": 675,
      "index": 1126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Http_ingress_path",
      "library": "kubecaml",
      "description": "This module defines path-based routing rules for HTTP ingress by mapping URL paths to backend services, using extended POSIX regex syntax for path matching and referencing Kubernetes services as backends. It supports creating, inspecting, and serializing path-backend pairs, enabling configuration of ingress controllers to direct traffic based on URL paths. The child module handles JSON serialization and deserialization of these routing rules, converting between structured data and JSON representations for storage or transmission. For example, it can parse JSON input into a list of path-backend tuples or serialize configured routes into JSON for persistence.",
      "description_length": 665,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy_list",
      "library": "kubecaml",
      "description": "This module manages Pod Security Policy List objects by providing functions to construct, serialize, and deserialize them to and from JSON. It supports access and manipulation of key fields such as `api_version`, `kind`, `metadata`, and `items`, which holds a list of Pod Security Policy objects. The module enables efficient configuration and retrieval of cluster-level Pod Security Policies via the Kubernetes API. Specific operations include converting policy lists to JSON tuples for API requests and parsing responses into OCaml values for inspection or modification.",
      "description_length": 572,
      "index": 1128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module tracks and reacts to changes in PodDisruptionBudget resources across namespaces, supporting real-time monitoring and event streaming. It provides fine-grained control through label and field selectors, resource versioning, and pagination. Key operations include `get`, which watches named budgets for updates or deletions, enabling dynamic policy adjustments during cluster maintenance. For example, it can stream events for a specific budget during a rolling update or trigger actions when a budget is modified.",
      "description_length": 524,
      "index": 1129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_access_review_spec",
      "library": "kubecaml",
      "description": "This module structures access review requests for a Kubernetes authorization system, allowing specifications to be built using either resource or non-resource attributes, but not both. It provides functions to convert instances to and from JSON, enabling seamless API integration. The child module extends this by bundling multiple keyed access review specifications into a list structure, also supporting JSON serialization. Together, they facilitate the creation, manipulation, and transmission of complex authorization requests with strict attribute constraints.",
      "description_length": 565,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Rbd_volume_source",
      "library": "kubecaml",
      "description": "This module provides a type-safe interface for configuring Rados Block Device (RBD) volumes in Kubernetes, with support for specifying Ceph monitors, image names, authentication secrets, and mount options such as read-only and filesystem type. It includes operations for working with optional fields, lists, and string values, along with JSON serialization and deserialization for integration with Kubernetes APIs. The child module manages collections of RBD volume configurations as key-value pairs, offering functions to convert these structures to and from JSON, enabling seamless use in pod specifications. Use cases include defining RBD-backed storage volumes, authenticating with Ceph clusters using secrets, and ensuring correct filesystem mounting during pod initialization.",
      "description_length": 782,
      "index": 1131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Certificatesigningrequests.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CertificateSigningRequests by name, offering direct operations to retrieve, update, delete, and patch individual resources. It supports key data types such as `Certificate_signing_request` and related metadata, enabling precise lifecycle control, such as modifying approval statuses or updating request state. The approval submodule programmatically issues approvals using a `put` function on a named request, while the status submodule replaces the status of a request, targeting specific use cases like automated certificate denial or acceptance. Together, these components enable fine-grained manipulation of certificate workflows through direct API interactions.",
      "description_length": 697,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Podsecuritypolicies.By_name",
      "library": "kubecaml",
      "description": "This module handles PodSecurityPolicy operations in Kubernetes's Extensions v1beta1 API. It provides functions to get, put, delete, and patch PodSecurityPolicy resources by name, using HTTP requests with customizable headers and contexts. These functions are used to manage PodSecurityPolicy configurations directly on a Kubernetes cluster.",
      "description_length": 340,
      "index": 1133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes Deployment objects, offering functions to construct and manipulate deployment lists with metadata, API version, and kind information. It provides direct access to deployment items and list metadata, along with JSON serialization via `to_yojson` and `of_yojson`. The child module extends this by handling conversion between Deployment lists and Yojson representations, enabling efficient storage, transmission, and interaction with Kubernetes APIs. Example usage includes building a deployment list with `make`, extracting items with `items`, and serializing the result for API requests or config files.",
      "description_length": 649,
      "index": 1134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Daemonsets",
      "library": "kubecaml",
      "description": "This module watches for changes to DaemonSet resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific DaemonSet resource, supporting parameters like `watch`, `timeout_seconds`, and `label_selector` for targeted monitoring. Use it to observe lifecycle events or status updates of DaemonSets in real time.",
      "description_length": 342,
      "index": 1135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Replicasets",
      "library": "kubecaml",
      "description": "This module watches for changes to ReplicaSet resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific ReplicaSet list, supporting parameters like `watch`, `timeout_seconds`, and `label_selector`. Use it to monitor ReplicaSet updates in real-time, such as tracking scaling events or deployment progress.",
      "description_length": 342,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_volume_source",
      "library": "kubecaml",
      "description": "This module provides a volume source that injects pod metadata such as IP, namespace, and labels into a container's filesystem at runtime. It supports ownership management and SELinux relabeling through `t` type configurations that include optional file items and default file modes. The child module handles JSON serialization and deserialization of these configurations, enabling their use in Kubernetes pod definitions. Example usage includes mounting pod metadata as files into a container with specified permissions and labels.",
      "description_length": 532,
      "index": 1137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes StatefulSet objects, offering functions to construct, access, and serialize groups of StatefulSets using API version v1beta1. It supports operations such as converting lists to and from JSON with Yojson, and works with Stateful_set.t values, List_meta.t metadata, and string-based API version and kind identifiers. Use it to retrieve StatefulSet lists from an API, build custom collections, or serialize data for storage and transmission. Key examples include parsing StatefulSet lists from JSON responses or constructing a list to send to a Kubernetes API.",
      "description_length": 603,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes API object for managing a list of cluster roles in RBAC v1alpha1, providing functions to construct, serialize, and access cluster role lists, including fields like `api_version`, `kind`, `metadata`, and `items`. It includes direct operations for manipulating cluster role collections programmatically, such as retrieving or updating RBAC policies via the Kubernetes API. The child module handles JSON serialization and deserialization of cluster role lists using `to_yojson` and `of_yojson`, enabling interaction with API endpoints that require or return cluster role data in JSON format. Together, these components support building, modifying, and transmitting structured lists of cluster roles within a Kubernetes RBAC system.",
      "description_length": 764,
      "index": 1139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Deployment specifications with fields like replicas, strategy, and pod templates, and provides constructors and accessors for deployment configurations. It supports defining rollout strategies, label selectors, and pod readiness constraints, enabling precise control over pod creation, updates, and rollbacks. The child module manages multiple Deployment specs as a list of key-value pairs, offering JSON serialization and deserialization for grouped deployment handling. Use the main module to configure individual Deployments and the child module to manage collections of Deployments in a structured, serializable format.",
      "description_length": 657,
      "index": 1140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Rolling_update_daemon_set",
      "library": "kubecaml",
      "description": "This module defines the rolling update strategy for daemon sets, centered around the `t` type that represents the specification and the `max_unavailable` parameter, which can be set as a number or percentage using `Int_or_string`. It provides functions to configure and retrieve this parameter, enabling policies like limiting unavailability to 30% of nodes during updates. The child module handles JSON serialization and deserialization of these policies, converting between typed OCaml values and JSON key-value lists for API interactions. Together, they support defining, manipulating, and transmitting daemon set update rules while ensuring availability constraints are respected.",
      "description_length": 684,
      "index": 1141,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates StatefulSet configurations in Kubernetes, supporting templates, update strategies, volume claims, and pod management policies. It directly handles Kubernetes API objects like pod templates and label selectors, while its child module organizes multiple specifications as key-value pairs with JSON serialization. You can define a StatefulSet's scaling behavior, persistent storage, and pod identity, then group and export several specs for deployment. Functions allow building, modifying, and converting specs to and from JSON, enabling dynamic configuration management.",
      "description_length": 607,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes IngressList object for API version v1beta1, containing a list of Ingress resources along with metadata, kind, and API version information. It provides functions to construct, access, and serialize ingress lists, enabling operations such as parsing API responses or generating collections of ingress data. The child module handles JSON serialization and deserialization of ingress lists, converting between JSON structures and internal representations for storage or transmission. Use this module to manage multiple ingress resources collectively, such as retrieving, modifying, or exporting ingress configurations in a Kubernetes cluster.",
      "description_length": 674,
      "index": 1143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rollback_config",
      "library": "kubecaml",
      "description": "This module defines a rollback configuration for Kubernetes deployments, centered around the `t` type representing a configuration with an optional revision number. It provides operations to construct and query revision values, along with JSON serialization using Yojson, enabling integration with Kubernetes APIs. The child module extends this by handling lists of key-value pairs where each value is a rollback configuration, offering `to_yojson` and `of_yojson` for structured JSON encoding and decoding. This supports managing multiple rollback configurations as part of a larger deployment object in Kubernetes workflows.",
      "description_length": 626,
      "index": 1144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes events with fields for API version, kind, metadata, and event items, providing functions to construct, access, and serialize event lists. It includes a submodule that extends this functionality by organizing event lists into key-value pairs, where each key is a string and the value is an `Event_list` structure, enabling structured handling of events from API responses. Operations include converting event data to and from JSON using Yojson, making it suitable for processing events retrieved from Kubernetes API endpoints. Example uses include parsing event lists by namespace or resource and serializing them for storage or transmission.",
      "description_length": 685,
      "index": 1145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_spec",
      "library": "kubecaml",
      "description": "This module defines the core structure and operations for configuring replication controllers, including key fields like replicas, selector, template, and min ready seconds. It enables creation, serialization, and access to replication controller specifications, supporting integration with Kubernetes API workflows. The nested list module handles collections of these specifications, providing JSON conversion for storage or transmission. Example uses include defining desired pod replica states and packaging multiple configurations for batch processing.",
      "description_length": 556,
      "index": 1146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset_spec",
      "library": "kubecaml",
      "description": "This module describes a pod preset specification, combining structured configuration with JSON serialization. It supports defining environment variables, volume mounts, and labels to apply to matching pods, along with functions to convert to and from JSON. The child module organizes multiple presets under string keys, enabling grouped serialization and deserialization for API or config file use. Example usage includes defining a preset that adds a debug sidecar container to pods with a specific label.",
      "description_length": 506,
      "index": 1147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_daemon_endpoints",
      "library": "kubecaml",
      "description": "This module captures and manipulates node daemon endpoints, primarily focusing on the Kubelet endpoint, allowing construction, access, and serialization of endpoint data for node daemons. It supports operations such as retrieving or configuring Kubelet communication ports on Kubernetes nodes, and works with structured representations of named endpoints paired with their port configurations. The module includes functions to serialize and deserialize these endpoint records to and from JSON, enabling use cases like generating API responses or parsing configuration data. For example, it can convert a list of named Kubelet endpoints into JSON for storage or extract port settings from JSON input during node setup.",
      "description_length": 717,
      "index": 1148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role",
      "library": "kubecaml",
      "description": "This module provides tools to create and manage Kubernetes RBAC `ClusterRole` objects, including setting policy rules, metadata, and aggregation rules. It supports structured data types like `Policy_rule`, `Object_meta`, and `Aggregation_rule` for defining cluster-level roles, and integrates with Kubernetes API clients for role management. The child module handles collections of named cluster roles using a list-based structure, enabling JSON serialization and deserialization via `Yojson.Safe.t`. Use cases include generating RBAC configurations programmatically and managing multiple cluster roles in storage or transmission formats.",
      "description_length": 638,
      "index": 1149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review_spec",
      "library": "kubecaml",
      "description": "This module structures access review requests for Kubernetes authorization checks, handling fields like user, groups, and either resource or non-resource authorization attributes. It ensures valid specification construction with exactly one attribute type set and supports JSON serialization for API integration. The child module manages authorization attributes as key-value pairs, mapping strings to access control specifications with JSON support. Together, they enable creating and processing detailed access requests, such as checking user permissions on specific resources or non-resource endpoints in Kubernetes clusters.",
      "description_length": 628,
      "index": 1150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_list",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes CronJob resources, providing functions to construct, inspect, and serialize the collection. It works with CronJob objects and associated metadata, including API version, kind, and list metadata. The main data types include the list of CronJob structures and their key-value mappings, with operations such as `to_yojson` and `of_yojson` for JSON serialization and parsing. You can use this module to manage groups of scheduled batch jobs in a Kubernetes cluster, such as retrieving or organizing multiple CronJob definitions in a structured format or converting them to and from JSON for API interactions.",
      "description_length": 654,
      "index": 1151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Handler",
      "library": "kubecaml",
      "description": "This module defines handlers for specifying actions like executing commands, making HTTP requests, or interacting with TCP sockets during Kubernetes pod lifecycle events. It provides functions such as `make`, `exec`, `http_get`, and `tcp_socket` to create and manage handlers, ensuring only one action type per handler. The child module manages collections of handlers, supporting JSON serialization and deserialization for integration with Kubernetes API operations. Together, they enable defining and handling lifecycle hooks such as pre-stop and post-start for container management.",
      "description_length": 585,
      "index": 1152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_dns_config",
      "library": "kubecaml",
      "description": "This module manages DNS configuration parameters for Kubernetes pods, enabling customization of nameservers, resolver options, and search domains beyond the defaults set by DNS policy. It supports constructing, accessing, and serializing DNS settings, with concrete use cases such as configuring private DNS servers, setting resolution timeouts, and defining custom search domains. The child module handles parsing and serialization of DNS fields, working on a list of string-`Pod_dns_config.t` pairs for conversion to and from JSON. Together, they provide a complete interface for defining and transforming DNS configurations for deployment or inspection.",
      "description_length": 656,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Event objects with fields for metadata, kind, API version, and a list of events, providing functions to construct, access, and serialize these structures to and from JSON. It supports handling collections of events returned by the Kubernetes API, enabling structured manipulation and inspection of event data within applications. A child module extends this functionality by grouping events by namespace, using a list of tuples where each tuple contains a namespace string and an Event_list value. This allows aggregation, serialization, and transmission of multi-namespace event data while maintaining structured access to individual event lists per namespace.",
      "description_length": 705,
      "index": 1154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior for configuring Kubernetes ReplicaSet specifications, including functions to create, serialize, and access fields such as the pod template, label selector, replica count, and minimum readiness duration. It represents a list of key-value pairs where each value is a Replica_set_spec, enabling structured configuration of replica sets and providing serialization to and from JSON using Yojson. Use this module to programmatically define or manipulate ReplicaSet configurations in deployment tools or cluster management systems, ensuring compatibility with Kubernetes API expectations. Specific operations include setting replica counts, defining pod templates, and managing label selectors to control pod deployment and scaling behavior.",
      "description_length": 782,
      "index": 1155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_condition",
      "library": "kubecaml",
      "description": "This module manages the state of a DaemonSet condition through operations to construct and inspect values, supporting condition type, status, reason, message, and transition time. It enables tracking condition transitions, reporting status changes, and serializing condition data using optional time and string values. The child module extends this functionality by organizing multiple conditions into a JSON-serializable structure, allowing full state snapshots to be stored or transmitted. Together, they provide a complete interface for managing, converting, and persisting DaemonSet condition states.",
      "description_length": 604,
      "index": 1156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis.Meta",
      "library": "kubecaml",
      "description": "This module structures Kubernetes API interactions through data types like label selectors, owner references, and status responses, enabling precise resource filtering, initialization workflows, and error handling. Operations include constructing and serializing metadata, interpreting API statuses, and managing versioned API groups with network routing. Users can build pod selectors for deployments, encode API errors, and direct clients based on CIDR ranges. Specific use cases involve serializing metadata for resource creation and handling initializer states during object creation.",
      "description_length": 588,
      "index": 1157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role",
      "library": "kubecaml",
      "description": "This module defines and manipulates Kubernetes RBAC ClusterRole objects, handling policy rules, metadata, and versioning. It supports creating, serializing, and accessing fields like rules, aggregation rules, and object metadata, enabling programmatic management of cluster-level role definitions. A child module manages collections of cluster roles keyed by name, allowing serialization and deserialization of role configurations to and from JSON. Together, they support defining, grouping, and persisting RBAC policies that can be referenced by role bindings or cluster role bindings.",
      "description_length": 586,
      "index": 1158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template",
      "library": "kubecaml",
      "description": "This module defines a Pod template structure used to generate identical pods in Kubernetes, including fields for metadata, kind, API version, and a pod specification. It provides functions to construct templates, access their components, and convert to and from JSON format. The child module manages a list of key-value pairs mapping strings to Pod templates, enabling structured serialization and management of multiple reusable pod specifications. Together, they support defining and organizing pod configurations for deployments, stateful sets, and replica sets in Kubernetes.",
      "description_length": 579,
      "index": 1159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_security_context",
      "library": "kubecaml",
      "description": "This module manages pod-level security settings for Kubernetes, including user and group IDs, SELinux options, and supplemental groups, providing constructors and accessors to configure these attributes. It supports JSON serialization and deserialization, enabling storage and API interaction, and allows setting default security policies such as non-root user enforcement and SELinux consistency across containers. The child module handles lists of these security context records, offering utilities to convert them to and from JSON using `Yojson.Safe.t`. This structure is used to manage collections of pod security settings, facilitating batch processing and configuration serialization.",
      "description_length": 690,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Rolling_update_deployment",
      "library": "kubecaml",
      "description": "This module orchestrates rolling update strategies for Kubernetes deployments by defining parameters like `max_surge` and `max_unavailable`, which control pod availability during updates using `Int_or_string` values for flexibility. It supports safe deployment rollouts in production environments with strict SLAs, ensuring service availability and resource constraints are maintained. The child module enables serialization of these strategies to and from JSON via `to_yojson` and `of_yojson`, facilitating integration with Kubernetes API interactions. Together, they allow defining, modifying, and persisting deployment update policies programmatically.",
      "description_length": 655,
      "index": 1161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes replication controllers, offering operations to create, access, and serialize controller lists with metadata and version information. It supports JSON conversion through `to_yojson` and `of_yojson`, and allows structured access to individual controllers and list metadata. Each controller can be paired with a string identifier, enabling labeled grouping and efficient serialization. Example uses include querying a cluster's replication state or persisting controller configurations to storage.",
      "description_length": 541,
      "index": 1162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_list",
      "library": "kubecaml",
      "description": "This module manages lists of horizontal pod autoscaler objects, providing operations to construct, serialize, and access their contents. It supports conversion to and from JSON, retrieval of metadata, API version, and kind, and direct manipulation of the list of autoscaler items. The child module handles serialization of each autoscaler entry as a string-structure tuple, using `to_yojson` and `of_yojson` for Kubernetes-compatible JSON interchange. Together, they enable efficient handling and transmission of collections of autoscaler configurations within a Kubernetes cluster.",
      "description_length": 582,
      "index": 1163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy",
      "library": "kubecaml",
      "description": "This module manages Pod Security Policy objects within the Kubernetes API, enabling the creation, manipulation, and serialization of policies that enforce security constraints on pod and container configurations. It provides direct access to policy metadata, API version, kind, and security specifications, while its child module handles JSON conversion using tuple-based structures for API communication. You can define policies restricting root access, privileged containers, or volume usage, and serialize them for cluster deployment or deserialize incoming API data for inspection and modification.",
      "description_length": 602,
      "index": 1164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Run_as_user_strategy_options",
      "library": "kubecaml",
      "description": "This module defines the core types and operations for specifying user identity strategies in Kubernetes pod security policies, including user ID ranges and enforcement rules. It supports constructing and validating strategies using string-based rules and lists of ID ranges, ensuring pods run with authorized user identifiers. The child module extends this by representing configurations as key-value pairs with conversion to and from JSON, enabling structured policy serialization. Example usage includes defining a strategy that restricts user IDs to a specific range and serializing it for use in Kubernetes API extensions.",
      "description_length": 626,
      "index": 1165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides direct management of Kubernetes network policies within a namespace, supporting core operations like list, watch, create, delete, get, put, and patch via HTTP. It works with structured data types including NetworkPolicy and NetworkPolicyList, enabling precise control and synchronization of policy states. Specific operations include applying new policies, updating existing ones, and handling API responses with structured error handling. Example tasks include enforcing network isolation rules or synchronizing policy configurations across clusters.",
      "description_length": 572,
      "index": 1166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_template_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes Pod templates, each paired with a string identifier, enabling structured handling of multiple template configurations. It supports constructing, serializing, and accessing Pod template lists, with direct operations for adding or retrieving templates by identifier. The module facilitates defining groups of Pod templates for deployment configurations and cluster management, while its child module enhances interaction with JSON for API communication. Example uses include storing versioned Pod templates and preparing batched template updates for Kubernetes resources.",
      "description_length": 615,
      "index": 1167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_backend",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Ingress backend endpoints, capturing service names and ports\u2014either numeric or named\u2014and provides utilities to build, access, and serialize these configurations. It supports defining routing rules that direct traffic to services based on path or host, enabling precise ingress control. The child module extends this by organizing backend configurations into a list of service-to-backend mappings, offering JSON serialization for integration with API clients or configuration files. Together, they allow defining, transforming, and exporting complex ingress routing setups that map incoming requests to the appropriate service backends.",
      "description_length": 669,
      "index": 1168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job",
      "library": "kubecaml",
      "description": "This module represents the configuration of a single job and provides operations for constructing and manipulating Kubernetes Job resources, including creating, serializing, and accessing job metadata, specifications, and status. It works with structured data types such as `Job_spec`, `Job_status`, and `Object_meta`, enabling tasks like generating batch processing job configurations or converting job definitions to and from JSON for API interactions. The child module extends this functionality by managing multiple named Job configurations as a list of key-value pairs, supporting serialization to and from JSON using Yojson. Together, they enable both individual job configuration and bulk management with consistent serialization behavior.",
      "description_length": 746,
      "index": 1169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module implements HTTP operations for managing Kubernetes RBAC `ClusterRole` resources by name, including `GET`, `PUT`, `DELETE`, and `PATCH` requests. It works directly with `Cluster_role.t` and related types such as `Delete_options.t` and `Patch.t`. It is used to retrieve, replace, delete, or partially update a specific `ClusterRole` resource via a constructed URI.",
      "description_length": 374,
      "index": 1170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Replicationcontrollers",
      "library": "kubecaml",
      "description": "This module manages replication controllers within a Kubernetes namespace, offering direct operations like listing, creating, and deleting controllers using the Kubernetes API. It works with core types such as `Replication_controller`, `Replication_controller_list`, and `Status`, supporting standard query parameters for filtering and control. Child modules extend functionality with fine-grained operations: one handles scale adjustments using dedicated types, while another manipulates controller statuses directly via HTTP methods. Use this module to deploy controllers, adjust replica counts, or inspect and update controller states programmatically.",
      "description_length": 655,
      "index": 1171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Volume_mount",
      "library": "kubecaml",
      "description": "This module manages volume mount configurations for Kubernetes containers, allowing you to define and manipulate mount paths, sub-paths, read-only flags, and propagation settings. It includes functions to construct and modify individual mounts as well as collections of mounts, supporting direct configuration and structured composition. The child module handles groups of mounts, enabling JSON serialization and deserialization for integration with Kubernetes pod specifications. You can use this module to define how storage volumes are exposed inside containers, either individually or in bulk, ensuring compatibility with Kubernetes APIs.",
      "description_length": 642,
      "index": 1172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Controller_revision",
      "library": "kubecaml",
      "description": "This module captures immutable snapshots of controller state data, enabling versioning and rollback functionality for Kubernetes controllers like DaemonSet and StatefulSet. It defines core types such as `t`, `Object_meta`, and `Raw_extension`, and supports creation and deletion operations while enforcing immutability of the `Data` field after creation. The module includes direct APIs for managing revisions and integrates with JSON serialization via `to_yojson` and `of_yojson` for persistence and API interaction. Example usage includes storing configuration states at specific revision numbers and facilitating rollbacks by retrieving prior Controller_revision objects.",
      "description_length": 674,
      "index": 1173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and manipulation functions for Kubernetes network policy specifications, including fields for ingress and egress rules, pod selection via label selectors, and policy type configuration. It supports serialization to and from JSON using `Yojson`, and provides constructors and accessors for building and inspecting network policies targeting specific pods. A child module handles a list of key-value pairs representing individual network policies, offering JSON conversion for backward compatibility with Kubernetes versions prior to 1.9. Concrete use cases include defining network isolation rules for pods in a namespace, specifying allowed ingress and egress traffic, and ensuring compliance with cluster security policies.",
      "description_length": 758,
      "index": 1174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Controller_revision_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes ControllerRevision objects, providing accessors for API version, kind, metadata, and the list of items. It supports serialization to and from JSON using Yojson, with concrete use cases in managing stateful set revisions and inspecting controller history. The child module handles JSON conversion for associative lists mapping strings to Controller_revision_list values, enabling structured interaction with Kubernetes API endpoints that require or return Controller_revision list data in JSON format. Operations include constructing instances with optional metadata, kind, and API version fields, as well as converting between structured and JSON representations using `to_yojson` and `of_yojson`.",
      "description_length": 741,
      "index": 1175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_status",
      "library": "kubecaml",
      "description": "This module represents the runtime status of a Kubernetes StatefulSet, capturing key properties like replica counts, revisions, and conditions. It provides constructors, accessors, and JSON serialization for manipulating and inspecting the observed state of a StatefulSet during deployment or monitoring. The child module extends this functionality by enabling structured storage of multiple StatefulSet statuses as key-value pairs, supporting efficient lookup and management. Together, they facilitate tracking readiness, collision counts, and persistent volume claim states across StatefulSets in a cluster.",
      "description_length": 609,
      "index": 1176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Id_range",
      "library": "kubecaml",
      "description": "This module defines a range of integer IDs with inclusive min and max bounds, allowing creation, access to min/max values, and JSON serialization. It supports managing ID ranges in Kubernetes extension configurations, such as specifying allowed replica or pod IDs. The child module extends this by handling lists of named ID ranges, providing JSON conversion for structured configuration data. Example uses include defining size constraints for Kubernetes resources and serializing them for API transmission.",
      "description_length": 508,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_condition",
      "library": "kubecaml",
      "description": "This module manages stateful set condition records, capturing key details like type, status, and transition times, and provides constructors, accessors, and Yojson serialization. It supports tracking Kubernetes StatefulSet states, such as availability or errors, and handles structured conversion to and from JSON. The child module extends this by mapping string identifiers to these condition records, enabling efficient serialization and deserialization of StatefulSet status data for API interactions. Together, they facilitate precise state tracking and data exchange in Kubernetes environments.",
      "description_length": 599,
      "index": 1178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_update_strategy",
      "library": "kubecaml",
      "description": "This module manages DaemonSet update strategies, supporting configurations like rolling updates and on-delete policies. It provides functions to create, inspect, and serialize strategy values, including parameters such as max unavailable nodes. Child modules handle JSON conversion, enabling persistence and exchange of strategy definitions. Example uses include defining rolling update constraints for DaemonSet deployments and converting strategies to and from JSON for API interactions.",
      "description_length": 489,
      "index": 1179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_spec",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes Pod specification as a list of key-value pairs, where each value is a `Pod_spec.t`. It provides functions to construct, manipulate, and serialize Pod specifications, including support for optional parameters like containers, tolerations, affinity, and volumes, along with conversion to and from JSON using Yojson. You can use it to dynamically generate environment-specific Pod specs, enforce scheduling constraints, or interact with Kubernetes APIs through serialized Pod definitions. The module ensures type-safe configuration of pod-level attributes such as resource limits, node selectors, and security contexts.",
      "description_length": 652,
      "index": 1180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_status",
      "library": "kubecaml",
      "description": "This module tracks the status of a Replica Set in Kubernetes, with core fields like `replicas`, `ready_replicas`, and `conditions`, and provides functions to construct and query these statuses, such as `make`, `available_replicas`, and `observed_generation`. Its child module extends this functionality by offering a list-based mapping from string keys to status values, along with JSON encoding and decoding via `to_yojson` and `of_yojson`, enabling seamless interaction with Kubernetes API responses. Together, they support use cases like monitoring Replica Set health, verifying replica counts, and diagnosing deployment issues through condition analysis. The combined interface allows for both direct status manipulation and structured, serialized representation of Replica Set states during cluster inspection or reconciliation.",
      "description_length": 833,
      "index": 1181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module enables namespace-scoped access control evaluations in Kubernetes by creating LocalSubjectAccessReview resources. It provides a `post` function to submit access review requests and a `request_path_template` for generating API paths. The core data type is the LocalSubjectAccessReview definition, used to evaluate user permissions within a specific namespace. For example, it can determine if a user can perform a specific action on a resource in a given namespace.",
      "description_length": 476,
      "index": 1182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Mutatingwebhookconfigurations.By_name",
      "library": "kubecaml",
      "description": "This module handles direct interactions with Kubernetes mutating webhook configurations by providing HTTP operations to retrieve, replace, delete, and partially update specific configurations using their names. It works with Kubernetes API objects such as `Mutating_webhook_configuration` and `Delete_options`, and uses standard HTTP request parameters like headers and context. Concrete use cases include managing admission control policies by modifying webhook configurations in a running Kubernetes cluster.",
      "description_length": 510,
      "index": 1183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Controllerrevisions",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Kubernetes ControllerRevision resources. Works with Kubernetes API request URIs and handles responses as parsed Watch_event values. Useful for monitoring changes to stateful set controller revisions in real time.",
      "description_length": 277,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Iscsi_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module provides operations to define and configure iSCSI persistent volume sources, including fields such as target portal, LUN, IQN, and CHAP authentication, supporting string, integer, boolean, and secret reference types. It enables setting up iSCSI disks for Kubernetes volumes with interface and authentication parameters. The child module handles JSON serialization and deserialization of these configurations, using lists of string-volume tuples for API requests and responses. Example uses include constructing an iSCSI volume with CHAP credentials and converting it to JSON for cluster deployment.",
      "description_length": 610,
      "index": 1185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Controller_revision_list",
      "library": "kubecaml",
      "description": "This module manages lists of Kubernetes controller revision objects, providing operations to construct and manipulate their metadata, kind, API version, and item entries. It supports JSON serialization via `Yojson.Safe.t` and includes accessors for key fields like `api_version`, `metadata`, and `items`, enabling tasks such as tracking deployment rollouts or stateful set revisions. The child module enhances this functionality by handling associative lists of controller revision lists, offering `to_yojson` and `of_yojson` for JSON conversion when interacting with Kubernetes API endpoints. Together, they facilitate retrieving, storing, and managing historical controller states in a cluster.",
      "description_length": 696,
      "index": 1186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.User_info",
      "library": "kubecaml",
      "description": "This module represents a list of key-value pairs mapping strings to user information values, providing serialization and deserialization to and from JSON using `to_yojson` and `of_yojson`. It works with the core user data structure to store and retrieve user authentication data in a structured format. Concrete use cases include handling user identity information within Kubernetes API authentication workflows, particularly when encoding or decoding JSON payloads during API requests and responses.",
      "description_length": 500,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Key_to_path",
      "library": "kubecaml",
      "description": "This module maps string keys to file paths within a Kubernetes volume, supporting optional mode bits to define file permissions. It provides operations to construct, access, and serialize individual mappings as well as lists of mappings, ensuring valid paths and mode values. The module handles both single key-path entries and collections, enabling precise configuration of projected volumes like ConfigMaps or Secrets mounted into containers. For example, it can map a ConfigMap key `\"config.json\"` to `/etc/config.json` with mode `0o644`, and serialize the result to JSON for use in Kubernetes pod specs.",
      "description_length": 607,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Controllerrevisions",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Kubernetes ControllerRevision resources. Works with Kubernetes API request URIs and returns parsed watch events or error strings. Enables real-time monitoring of ControllerRevision changes with customizable query parameters like resource version, label selectors, and timeouts.",
      "description_length": 342,
      "index": 1189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Client_ip_config",
      "library": "kubecaml",
      "description": "This module manages client IP session affinity configurations for Kubernetes services, allowing creation of configurations with optional timeout settings and serialization to and from JSON. It includes a child module that organizes multiple configurations into a list of key-value pairs, enabling structured representation and manipulation of session affinity rules. Operations include converting configurations to JSON format using `to_yojson` and reconstructing them with `of_yojson`. Example usage includes defining a client IP configuration with a 60-second timeout and serializing it for storage or transmission.",
      "description_length": 617,
      "index": 1190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Webhook_client_config",
      "library": "kubecaml",
      "description": "This module manages TLS connection configurations for webhooks, handling CA bundles, service references, and URLs to establish secure connections during Kubernetes admission registration. It supports creating, serializing, and validating webhook client configurations, allowing users to define endpoints either via direct URLs or service references with associated certificate authorities. The child module handles conversion of these configurations to and from JSON, using a list of key-value pairs for transmission or storage during Kubernetes API interactions. Example usage includes setting up a webhook with a PEM-encoded CA bundle and a service reference, then serializing it for use in an admission controller.",
      "description_length": 717,
      "index": 1191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Storage_os_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module represents a StorageOS persistent volume source configuration with fields for volume identification, namespace, filesystem type, read-only status, and secret reference. It provides constructors, accessors, and JSON (de)serialization via `to_yojson` and `of_yojson` for integrating StorageOS-backed volumes in Kubernetes. The child module extends this functionality to handle list-based representations, enabling conversion between associative lists of configurations and their JSON equivalents for storage or transmission. Together, they support defining, manipulating, and serializing complex StorageOS volume setups within Kubernetes environments.",
      "description_length": 661,
      "index": 1192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Watch.Mutatingwebhookconfigurations",
      "library": "kubecaml",
      "description": "This module watches for real-time changes to mutating webhook configurations, supporting filters like resource version and label selector, and allows setting request timeouts and response formats. It enables monitoring admission control policies in a Kubernetes cluster, dynamically adjusting to configuration updates. The child module extends this by allowing per-name tracking of configurations, supporting operations like `get` and streaming updates via direct interaction with Kubernetes API paths and Cohttp. Together, they facilitate precise, real-time monitoring and dynamic adaptation to mutating webhook configuration changes in a cluster.",
      "description_length": 648,
      "index": 1193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Ceph_fs_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module configures CephFS-based persistent volumes for Kubernetes pods, specifying mount parameters such as monitors, path, user, and secrets. It supports direct creation and manipulation of volume sources that persist for the pod's lifetime, without ownership management or SELinux relabeling. The child module handles JSON serialization and deserialization of these configurations, enabling storage or transmission of CephFS volume settings. Together, they allow Kubernetes to consume and manage distributed CephFS storage through structured, serializable volume source definitions.",
      "description_length": 588,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Security_context",
      "library": "kubecaml",
      "description": "This module manages container-level security configurations in Kubernetes, combining direct manipulation of security fields like user/group IDs, SELinux options, and capabilities with structured mappings from container names to their respective security settings. It supports constructing, inspecting, and serializing security contexts to enforce least privilege and control container behavior. Use it to define fine-grained security policies for individual containers, such as restricting filesystem access or dropping specific capabilities. The module integrates container-specific settings with mappings that associate named containers to their security configurations, enabling flexible and precise security enforcement in Kubernetes deployments.",
      "description_length": 750,
      "index": 1195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_field_selector",
      "library": "kubecaml",
      "description": "This module handles Kubernetes container resource field selectors for CPU and memory, allowing construction, serialization, and access to fields like resource type, divisor, and container name. It supports integration with Kubernetes configurations for resource-based environment variables and volume sources. The child module provides a list-based structure mapping string keys to selectors, enabling precise resource queries and offering JSON serialization for interaction with Kubernetes API objects. Together, they facilitate detailed resource constraint manipulation in pod and container definitions.",
      "description_length": 605,
      "index": 1196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_error",
      "library": "kubecaml",
      "description": "The module captures errors from volume operations with structured data, including optional timestamps and messages, and supports construction, inspection, and JSON serialization. It handles single error instances, while its child module extends functionality to manage collections of errors as key-value pairs, enabling efficient serialization of multiple errors. Operations include creating errors, extracting details like timestamps, and converting error data to or from JSON for logging and monitoring purposes. This structure is particularly useful in Kubernetes storage systems for reporting and analyzing volume attach or detach failures.",
      "description_length": 644,
      "index": 1197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Clusterroles",
      "library": "kubecaml",
      "description": "This module streams ClusterRole events from the RBAC API, allowing real-time monitoring of role changes with customizable filtering and timeouts. It supports direct access via `get` to watch all ClusterRoles or delegate to the `By_name` submodule for tracking specific roles by identifier. The `By_name` submodule enables fine-grained observation of individual ClusterRoles using streaming HTTP, with filtering by resource version, labels, or fields. Use this module to implement dynamic access control or security auditing workflows that react to role modifications as they occur.",
      "description_length": 581,
      "index": 1198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role",
      "library": "kubecaml",
      "description": "This module defines a Kubernetes RBAC role with fields for API version, kind, metadata, and a list of policy rules, and provides functions to construct, access, and serialize roles to and from JSON. It represents role-based access control policies within a Kubernetes namespace and allows grouping policy rules as reusable units referenced by role bindings. The child module manages collections of roles keyed by string identifiers, enabling serialization and deserialization of role lists for storage or transmission. Example uses include creating a role with specific rules, converting it to JSON for persistence, or loading a named role collection from a configuration file.",
      "description_length": 677,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Apiservices.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes API services by name, supporting core operations like retrieval, replacement, deletion, and partial updates through HTTP requests. It works primarily with `Api_service.t` for representing services, `Delete_options.t` for deletion parameters, and `Patch.t` for applying updates. The child module extends this functionality by allowing status updates of existing API services using a fully defined `Api_service.t` object, enabling tasks like synchronizing service state after configuration changes or health checks. Together, they provide a focused interface for maintaining API service registration and configuration in a cluster.",
      "description_length": 660,
      "index": 1200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event",
      "library": "kubecaml",
      "description": "This module models Kubernetes events with structured data, offering direct access to fields like `action`, `message`, and `involved_object`, along with serialization and construction utilities. It includes a submodule for handling collections of events as key-value pairs, supporting JSON conversion and typed event stream processing. You can create, serialize, and manipulate individual events or groups of events, making it suitable for cluster monitoring, auditing, and handling event series with structured field updates. The integration with object references allows modeling events in relation to other Kubernetes resources within the core v1 API.",
      "description_length": 653,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Watch.Volumeattachments",
      "library": "kubecaml",
      "description": "This module enables real-time observation of VolumeAttachment resources in Kubernetes, offering a `get` function to initiate watch requests with filters like label selector, field selector, and resource version. It streams continuous updates, reflecting live changes to volume attachments. The `By_name` submodule enhances this functionality by allowing targeted watches on specific volume attachments by name, supporting detailed queries and structured event delivery. Users can, for example, track the state of a particular volume attachment over time or monitor for new attachments matching specific criteria.",
      "description_length": 612,
      "index": 1202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides a structured interface for managing Horizontal Pod Autoscalers within a Kubernetes namespace, enabling creation, deletion, and modification through standard REST operations. It centers around the `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list` types, supporting full and partial updates via PUT and PATCH methods. The status submodule allows direct manipulation of autoscaler status fields, enabling precise control over scaling behavior. Examples include dynamically adjusting autoscaling thresholds based on real-time metrics or programmatically updating deployment scaling policies.",
      "description_length": 623,
      "index": 1203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module tracks changes to Kubernetes RBAC resources like Roles and RoleBindings within namespaces, enabling real-time monitoring with customizable filters. It provides `get` functions to stream events based on labels, field selectors, resource versions, and timeouts, supporting precise and dynamic observation. You can use it to audit permission changes, synchronize role definitions, or monitor RBAC policy updates across a cluster. Key data types include Role, RoleBinding, and event streams with associated metadata.",
      "description_length": 524,
      "index": 1204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Ip_block",
      "library": "kubecaml",
      "description": "This module defines a CIDR block with optional exclusion ranges for Kubernetes network policy rules, allowing precise control over allowed or restricted IP ranges. It provides functions to construct, serialize, and access CIDR blocks and their exceptions, ensuring valid IP range definitions. The child module handles lists of such rules, enabling bulk definition and parsing of network policy ingress or egress rules using JSON via Yojson. Use this module to configure network policies that filter pod communication based on CIDR ranges and exceptions, such as allowing \"192.168.1.0/24\" but excluding \"192.168.1.100/32\".",
      "description_length": 621,
      "index": 1205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_spec",
      "library": "kubecaml",
      "description": "This module structures volume attachment requests for Kubernetes APIs, defining core operations to create, serialize, and access fields like attacher, node name, and source. It supports working with volume attachment source types to express the intent to attach storage to a node using a specific driver. The child module handles JSON conversion, enabling serialization and deserialization of volume attachment specs for API communication or configuration storage. Together, they allow constructing and manipulating volume attachment intents programmatically and persisting or transmitting them in JSON format.",
      "description_length": 610,
      "index": 1206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Deployment_list",
      "library": "kubecaml",
      "description": "This module organizes a collection of Kubernetes Deployment objects, each paired with a string identifier, and provides tools to serialize and deserialize the collection using Yojson. It includes operations to set and retrieve metadata, API version, and kind, while supporting structured interaction with Kubernetes API responses. The module enables handling multiple Deployments as a single unit, such as when retrieving or updating a group from a cluster. For example, you can construct a deployment list from JSON data, modify individual Deployments, and then serialize the updated list back to JSON for transmission.",
      "description_length": 620,
      "index": 1207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis.Apiregistration",
      "library": "kubecaml",
      "description": "This module manages Kubernetes API services through structured data types and operations for configuration, status tracking, and service referencing. Key types include API service specifications with TLS and priority settings, service references with optional namespace and name, and API service conditions with status and transition time. Operations support constructing, modifying, and inspecting services, including loading from files, updating TLS parameters, and querying health states. Example uses include registering backend servers, exporting service configurations to JSON, and organizing API services by label or version for cluster management.",
      "description_length": 655,
      "index": 1208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_image",
      "library": "kubecaml",
      "description": "A container image tracks identifiers and metadata like size, with functions to build, access, and serialize images to JSON. It supports managing Kubernetes image references, such as recording alternative names and size constraints. The list submodule handles collections of images paired with keys, enabling structured storage and retrieval in configurations like deployments. Together, they provide a complete interface for representing and manipulating container image data in cluster resource definitions.",
      "description_length": 508,
      "index": 1209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes ConfigMap objects, providing operations to construct, serialize, and access the list along with its metadata, API version, and kind. It supports working with multiple ConfigMaps as a single unit, such as when handling API responses or requests that include a list of ConfigMaps. The child module extends this functionality by pairing ConfigMap lists with string keys, enabling structured grouping and direct JSON conversion using `to_yojson` and `of_yojson`. Example uses include persisting grouped ConfigMaps to disk or transmitting them over a network in a serialized format.",
      "description_length": 624,
      "index": 1210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_binding",
      "library": "kubecaml",
      "description": "This module provides tools to construct and manipulate ClusterRoleBinding objects in the RBAC v1alpha1 API, linking cluster roles to users or groups through role references and subject data. It supports operations to set and extract role bindings, including metadata, and works with types like Role_ref, Subject, and Object_meta. The child module handles JSON serialization and deserialization, enabling ClusterRoleBinding data to be stored, transmitted, or interfaced with external systems. Examples include creating bindings for service accounts and converting binding records to or from JSON for persistence or inspection.",
      "description_length": 625,
      "index": 1211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time observation and reaction to changes in Kubernetes resources such as Ingress, Deployment, ReplicaSet, NetworkPolicy, and DaemonSet within a namespace. It provides typed watch operations that support filtering by labels and fields, pagination, timeouts, and resource versioning, along with event streams and continuation tokens for tracking state changes. Users can monitor all instances of a resource type or focus on specific named resources, handling events like rollouts, scaling, and configuration updates. Example applications include triggering service mesh reloads on Ingress modifications, driving autoscaling decisions from ReplicaSet events, or validating DaemonSet deployments in real time.",
      "description_length": 730,
      "index": 1212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Http_ingress_rule_value",
      "library": "kubecaml",
      "description": "This module organizes HTTP ingress rules that route incoming requests to backends based on URL paths and host matches. It provides functions to construct and manipulate lists of routing rules, where each rule maps a URL path to a backend service. The module supports JSON serialization and deserialization for integration with Kubernetes ingress configurations. For example, it can define a rule that routes all requests to `/api` on a given host to a specific backend service.",
      "description_length": 477,
      "index": 1213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector_term",
      "library": "kubecaml",
      "description": "This module structures node selection criteria for Kubernetes scheduling, combining label match expressions into precise affinity rules. It supports creating and manipulating terms that define which nodes a pod can be scheduled on, using key-value pairs where values are node selector terms. Functions for conversion to and from Yojson enable serialization and integration with Kubernetes API objects. Use it to define or parse node affinity constraints in pod specifications, ensuring workloads are placed according to custom scheduling policies.",
      "description_length": 547,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role",
      "library": "kubecaml",
      "description": "This module provides tools to build and manipulate Kubernetes RBAC ClusterRole objects, including setting policy rules, metadata, and versioning. It supports structured data types such as Policy_rule, Object_meta, and Aggregation_rule, enabling programmatic generation and JSON serialization of ClusterRole configurations. The child module manages collections of cluster roles as string-cluster role pairs, offering JSON conversion for batch handling during API interactions. Example uses include defining fine-grained access policies and packaging them for cluster deployment or API exchange.",
      "description_length": 593,
      "index": 1215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Attached_volume",
      "library": "kubecaml",
      "description": "This module models storage volumes attached to nodes, providing a structured type to represent each attachment along with operations to create and access volume records by name and device path. It includes JSON (de)serialization via `Yojson`, enabling integration with APIs and configuration systems. The child module extends this by handling collections of volume attachments, mapping node identifiers to their respective volumes, and supporting bulk serialization for cluster state synchronization. Use cases include tracking Kubernetes node storage devices and converting between in-memory representations and JSON payloads during API calls.",
      "description_length": 644,
      "index": 1216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates StatefulSet configurations in Kubernetes, supporting templates, update strategies, volume claims, and policies for pod management. It enables defining stateful applications with persistent storage, controlled rolling updates, and stable network identities via service integration. The child module handles collections of StatefulSet specifications as key-value pairs, offering JSON serialization for managing multiple configurations in files or API responses. Together, they provide both fine-grained control over individual StatefulSets and tools to manage groups of them efficiently.",
      "description_length": 624,
      "index": 1217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_source",
      "library": "kubecaml",
      "description": "This module represents a volume attachment source in Kubernetes, primarily for attaching persistent volumes, with a single type `t` that can be constructed and converted to and from JSON. It includes operations to set and retrieve the volume source, supporting direct interaction with Kubernetes storage APIs. The child module handles JSON serialization and deserialization of volume attachment sources, enabling conversion of typed OCaml values to JSON for API requests and vice versa. Example usage includes specifying a persistent volume to attach and processing API responses containing volume attachment data.",
      "description_length": 614,
      "index": 1218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Resource_requirements",
      "library": "kubecaml",
      "description": "This module defines and manipulates resource requirements for Kubernetes containers, handling CPU and memory limits and requests using the `Quantity` type for precise values. It provides functions to construct, access, and serialize resource configurations, such as specifying constraints in container specs or adjusting allocations in manifests. The child module manages a list of key-value pairs mapping strings to resource requirements, enabling conversion to and from JSON with `Yojson.Safe.t`. This supports use cases like defining resource limits for containers in Kubernetes deployments or programmatically modifying resource settings in configuration files.",
      "description_length": 665,
      "index": 1219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state_running",
      "library": "kubecaml",
      "description": "This module captures the running state of a container, including an optional timestamp for the last start time, and supports conversion to and from JSON using `Yojson.Safe.t`. It provides operations to serialize and deserialize container state data, enabling integration with Kubernetes status reporting. A list of key-value pairs, where each value is a running state, can represent multiple containers' runtime metadata. This structure is used to track and transmit container events and statuses in a Kubernetes cluster.",
      "description_length": 521,
      "index": 1220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Resourcequotas",
      "library": "kubecaml",
      "description": "This module manages Kubernetes resource quotas within a namespace, supporting creation, deletion, and listing with options for filtering and watching. It works directly with resource quota definitions and status responses, enabling precise control through REST operations like get, put, delete, and patch. The status submodule extends this by allowing updates and retrieval of observed quota states. Examples include setting CPU/memory limits, modifying quota constraints, and tracking quota usage in real time.",
      "description_length": 511,
      "index": 1221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module tracks real-time changes to Horizontal Pod Autoscaler resources within Kubernetes namespaces, enabling event streaming for configuration updates and scaling actions. It supports filtering by namespace, label selector, and resource version, allowing targeted monitoring of autoscaler behavior. Key operations include streaming events for specific autoscalers, such as observing when an autoscaler triggers a deployment scale based on metric thresholds. For example, it can monitor a named autoscaler to capture scaling decisions as they happen.",
      "description_length": 555,
      "index": 1222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides namespace-scoped management of core Kubernetes workloads and network policies, enabling full lifecycle operations through HTTP interactions. It supports key resource types including DaemonSets, ReplicaSets, Ingresses, NetworkPolicies, Deployments, and scaling subresources, each with create, list, update, and delete capabilities via `get`, `put`, `patch`, and `delete` operations. Submodules offer fine-grained control over status updates, routing rules, TLS settings, and replica scaling, enabling tasks like rolling updates, dynamic scaling, and policy adjustments. Example operations include applying a DaemonSet patch to roll out configuration changes, scaling a Deployment in response to metrics, or modifying Ingress routing rules.",
      "description_length": 759,
      "index": 1223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides namespace-scoped RBAC management by handling Role and RoleBinding resources through the Kubernetes Rbac v1beta1 API. It supports key operations such as listing, creating, updating, and deleting roles and role bindings, with filtering by labels and support for resource versioning. You can, for example, list roles matching a specific label, create a new role in a namespace, or watch for changes to role bindings to enforce dynamic access control policies. The module's submodules handle low-level REST interactions, enabling precise control over RBAC resources using standard HTTP methods.",
      "description_length": 611,
      "index": 1224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Capabilities",
      "library": "kubecaml",
      "description": "This module manages POSIX capabilities for containers by allowing specific capabilities to be added or removed, and organizes them in a structured list associating each container with its configured capabilities. The main data types include a capabilities configuration with add/drop lists and a list of container-specific capability entries. Operations include creating, modifying, and serializing capability configurations to and from JSON, enabling precise control over system-level privileges for container security settings. For example, it can define a container's capabilities in a Kubernetes pod spec or adjust privilege drops for enhanced security during container execution.",
      "description_length": 684,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role",
      "library": "kubecaml",
      "description": "This module defines and manipulates Kubernetes RBAC roles, combining core operations for constructing, serializing, and accessing role data with utilities for managing collections of roles indexed by identifiers. It centers around the `Role.t` type, representing a single role with associated metadata and policy rules, and supports key operations such as role creation, JSON serialization, and policy rule composition. The child module extends this functionality by enabling grouping and persistence of multiple roles in JSON format, facilitating configuration management and API interactions. Example usage includes programmatically generating RBAC roles from policy rules, serializing them for storage, or deserializing and querying a set of roles by identifier.",
      "description_length": 765,
      "index": 1226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_list",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes Secret objects into structured collections, supporting operations to build, inspect, and serialize secret groups with metadata, kind, and API version. It directly handles lists of secrets with functions for JSON conversion using Yojson, enabling seamless interaction with Kubernetes API responses and config files. The namespace-aware submodule extends this functionality by grouping secrets by namespace, allowing deployment or retrieval of secrets scoped to specific namespaces. Use this module to define multi-namespace secret configurations, extract secrets from cluster responses, or generate valid Kubernetes secret manifests.",
      "description_length": 665,
      "index": 1227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Watch.Storageclasses",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes storage class resources, producing events for additions, updates, or deletions. It supports filtering by label selectors, resource version tracking, and configurable timeouts, allowing precise control over watched resources. The `get` function in the child module extends this functionality by enabling named storage class watches, ideal for tracking specific classes for dynamic provisioning or policy adjustments. Together, they facilitate responsive cluster management based on storage class configuration changes.",
      "description_length": 572,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_list",
      "library": "kubecaml",
      "description": "This module represents a list of persistent volume claims in a Kubernetes cluster, including metadata, kind, and API version. It provides operations to construct, manipulate, and serialize the list to and from JSON using Yojson, with direct access to fields like `items`, `metadata`, `kind`, and `api_version`. The child module extends this functionality by handling structured JSON conversion for lists of named persistent volume claim objects. Use cases include managing claim collections for cluster operations and serializing data during API interactions.",
      "description_length": 559,
      "index": 1229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_list",
      "library": "kubecaml",
      "description": "This module manages a list of persistent volume objects, including metadata, kind, and API version fields, allowing construction, manipulation, and JSON serialization. It supports operations to convert lists to and from JSON, facilitating integration with Kubernetes APIs and configuration files. The main data type is `t`, representing a persistent volume list, and operations include adding items, extracting metadata, and serializing to JSON. A helper module handles conversion using string-`t` tuples, enabling structured JSON input/output for deployment tools.",
      "description_length": 565,
      "index": 1230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Podsecuritypolicies",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Pod Security Policies in a Kubernetes cluster, offering a `get` function to establish a watch stream with customizable parameters such as resource version, label selectors, and timeouts. It works directly with Kubernetes API types like `Watch_event` and `Pod_security_policy`, allowing users to track dynamic updates to specific policies by name. Submodules extend this functionality to support fine-grained policy monitoring and enforcement, such as auditing security settings or reacting to compliance changes in real time. Example use cases include streaming policy changes for a specific Pod Security Policy and enforcing dynamic access control based on observed policy updates.",
      "description_length": 726,
      "index": 1231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Rolling_update_stateful_set_strategy",
      "library": "kubecaml",
      "description": "This module defines a rolling update strategy for StatefulSets by capturing the partition ordinal that controls update boundaries. It provides functions to construct, modify, and serialize strategies, including setting the partition value and converting to and from JSON. The main data type is `t`, representing a strategy with an optional partition, and operations include `set_partition` and JSON conversion. A list of such strategies can be processed in bulk when configuring StatefulSet update policies in Kubernetes.",
      "description_length": 521,
      "index": 1232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Watch.Validatingwebhookconfigurations",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes ValidatingWebhookConfiguration resources in real-time, streaming events based on filters such as resource version and label selector. It offers a `get` function to observe changes to specific configurations by name, using watch semantics with support for timeouts and Cohttp-based transport. The core functionality enables tracking dynamic updates to admission control policies, allowing applications to react to changes in validation rules as they occur. Watch events are returned as structured results, facilitating immediate processing of added, modified, or removed webhook configurations.",
      "description_length": 625,
      "index": 1233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Deployments",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Deployment resources by sending HTTP requests to a provided URI. It supports filtering by label and field selectors, limiting results, and controlling request timeouts and resource versions. A typical use case involves monitoring Deployment updates in a cluster to trigger automated workflows or event-driven actions.",
      "description_length": 363,
      "index": 1234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Aggregation_rule",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for specifying how cluster roles are aggregated in Kubernetes RBAC. It includes functions to create and access label selectors that determine which cluster roles to combine, enabling precise control over role aggregation rules. The associated list module represents a collection of labeled ClusterRole references, supporting JSON serialization and deserialization for processing aggregation rules in API interactions. Use these components together to build, parse, and manage complex role aggregation policies in Kubernetes RBAC configurations.",
      "description_length": 593,
      "index": 1235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Host_alias",
      "library": "kubecaml",
      "description": "This module manages mappings between IP addresses and hostnames for Kubernetes pod hosts files, providing data structures and operations to create, manipulate, and serialize these entries. It supports configuration of custom DNS-like entries in container environments, enabling use cases such as local development or testing with overridden hostnames. The main type represents a single IP-to-hostname mapping, while the list submodule handles collections with JSON serialization for integration into Kubernetes manifests. Example usage includes defining a list of custom host entries and serializing them into a pod spec's hostAliases field.",
      "description_length": 641,
      "index": 1236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes Job resources within a namespace, supporting label and field filtering, configurable timeouts, and pagination. It enables tracking of job creation, updates, and deletions through event streams, with key operations including `get` to start a watch and handlers for lifecycle events. Examples include detecting failed jobs immediately or tracking job completion status in real time.",
      "description_length": 436,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch.Cronjobs",
      "library": "kubecaml",
      "description": "This module watches for changes to CronJob resources in a Kubernetes cluster. It supports operations like `get` to stream events for a specific CronJob, using parameters such as `watch`, `timeout_seconds`, and `label_selector`. It works directly with CronJob definitions and Watch_event types, providing real-time updates for monitoring scheduled workloads.",
      "description_length": 357,
      "index": 1238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch.Poddisruptionbudgets",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Pod Disruption Budget resources in a Kubernetes cluster. It provides a `get` operation that supports filtering by label and field selectors, limiting results, and controlling connection behavior with timeouts and context. Use this module to monitor real-time changes to Pod Disruption Budgets in a namespace or cluster-wide.",
      "description_length": 389,
      "index": 1239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Daemon_endpoint",
      "library": "kubecaml",
      "description": "This module represents a single Daemon endpoint, primarily storing and manipulating port numbers, with functions to construct, access, and convert endpoints to and from JSON. It works in tandem with its child module, which manages a list of such endpoints, allowing structured handling of network services exposed by Kubernetes DaemonSets. The main data type `t` holds an endpoint's port, while the child module extends this to a list of keyed endpoints with full JSON serialization support via Yojson. You can define an endpoint for port 8080, embed it into a list with a label like \"http\", and serialize the entire structure for use in Kubernetes configurations.",
      "description_length": 664,
      "index": 1240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Preferred_scheduling_term",
      "library": "kubecaml",
      "description": "This module provides operations to construct and manipulate preferred scheduling terms, which define weighted node selection preferences in Kubernetes scheduling. It supports creating terms with a weight and node selector, extracting their components, and serializing or deserializing them using JSON. The child module handles lists of these terms, enabling structured representation of scheduling preferences that can be converted to and from JSON for use in Kubernetes configurations. Example usage includes defining node affinity rules in pod specs where nodes with specific labels are preferred with assigned weights.",
      "description_length": 621,
      "index": 1241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes list of cluster role bindings, providing constructors and accessors for metadata, API version, kind, and items. It enables creation, serialization, and inspection of RBAC role binding collections, often used when interacting with Kubernetes RBAC APIs. Each binding can be paired with a string identifier, allowing structured grouping and reference. Functions are available to convert the list to and from JSON format using `Yojson.Safe`, facilitating integration with external configuration systems.",
      "description_length": 535,
      "index": 1242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes PodPreset management within namespaces, providing structured access to collections and individual resources. It supports listing groups of presets, applying new configurations, and cleaning up outdated ones, using types like PodPresetList and PodPreset. Operations include bulk creation, label-based retrieval, and dynamic updates via fine-grained REST interactions. For example, you can enforce default pod settings across a namespace or programmatically remove obsolete presets before deploying new workloads.",
      "description_length": 544,
      "index": 1243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_source",
      "library": "kubecaml",
      "description": "This module defines a type `t` for representing volume attachment sources, primarily used to reference persistent volumes by name in Kubernetes storage operations. It includes functions to create and access the volume name, along with JSON serialization and deserialization capabilities via the child module, which handles conversion using Yojson for configurations. Specific use cases include encoding and decoding volume attachment data for external attachment workflows. The module supports both direct manipulation of volume references and structured data exchange through JSON.",
      "description_length": 582,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides namespace-scoped management of Kubernetes workloads, including Deployments, StatefulSets, and ControllerRevisions, using direct HTTP operations. It centers on data types like Deployment, StatefulSet, ControllerRevision, and their list counterparts, with operations such as `get`, `post`, `put`, and `patch` to create, inspect, update, and delete resources. Submodules enable fine-grained control over subresources like scale and status, supporting use cases such as scaling replicas in response to load, rolling back to previous revisions, and programmatically managing rollout history. Example workflows include adjusting Deployment scale, inspecting StatefulSet status, and managing ControllerRevision history for stateful applications.",
      "description_length": 759,
      "index": 1245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy_spec",
      "library": "kubecaml",
      "description": "This module defines and enforces security constraints for Kubernetes pods, centering on capabilities, volume plugins, and namespace/user/group strategies through the `t` type. It provides accessors like `supplemental_groups` and `volumes` to configure policy rules, enabling precise control over allowed volume types and group strategies. The child module handles JSON serialization and deserialization of policy specs, facilitating interaction with Kubernetes API endpoints. Together, they support defining, transmitting, and enforcing cluster-wide pod security policies with structured data.",
      "description_length": 593,
      "index": 1246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Rolebindings",
      "library": "kubecaml",
      "description": "This module watches for changes to RoleBinding resources in a Kubernetes cluster. It provides a `get` function to stream RoleBinding events with optional filtering and pagination parameters. The `request_path_template` defines the API path for RoleBinding watch requests.",
      "description_length": 271,
      "index": 1247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_projection",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Secret data as files in a projected volume, allowing selective inclusion of keys with custom paths and optional projection. It supports operations to define secret projections, specify file paths, and control projection behavior. The child module handles JSON serialization and deserialization of these projections, enabling their use in configuration files or API interactions. For example, you can project a secret's username and password keys as files under /etc/auth, then serialize this setup to JSON for deployment.",
      "description_length": 555,
      "index": 1248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Deployment_strategy",
      "library": "kubecaml",
      "description": "This module defines deployment strategies for Kubernetes Deployments, supporting \"recreate\" and \"rolling_update\" types, and provides functions to construct, inspect, and serialize these strategies. It includes operations to define rolling update parameters such as max surge and max unavailable, enabling precise control over pod replacement during updates. The module also supports serialization to and from JSON via Yojson, ensuring compatibility with Kubernetes API specifications. Use it to configure or modify Deployment resources in Kubernetes manifests, especially when specifying update behavior like gradual rollouts or full restarts.",
      "description_length": 643,
      "index": 1249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Pods_metric_status",
      "library": "kubecaml",
      "description": "The module provides a type `t` to represent per-pod metric status data in Kubernetes autoscaling, with fields for metric name and average value, along with JSON serialization via `Yojson`. It supports operations to construct, access, and convert metric values, facilitating integration with autoscaling systems. The child module extends this by handling structured serialization of collections of per-pod metrics, using lists of string-`t` pairs to represent multiple metrics across pods. Together, they enable precise metric tracking and API-level communication for horizontal pod autoscaling.",
      "description_length": 594,
      "index": 1250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_strategy",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes workload updates by defining strategies that govern pod replacement, with support for types like \"recreate\" and \"rolling_update\" and optional rolling update parameters. It includes core operations to build, inspect, and serialize strategy configurations, enabling precise control over deployment transitions. The child module handles mappings of string keys to strategy configurations, facilitating JSON serialization and deserialization for integration with Kubernetes manifests. Together, they allow defining and manipulating complex deployment policies, such as specifying max surge and unavailable limits in rolling updates or selecting recreate strategy via structured data.",
      "description_length": 715,
      "index": 1251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_reference",
      "library": "kubecaml",
      "description": "This module represents a reference to a Kubernetes Secret, capturing the namespace and name required to uniquely identify a secret resource. It provides functions to construct, access, and serialize secret references, ensuring accurate retrieval of secrets within a specified namespace. The main data type is `t`, representing a secret reference with fields for namespace and name, along with operations to convert to and from JSON using `to_yojson` and `of_yojson`. A child module extends this functionality by handling serialization of mappings between string keys and secret references, enabling configurations that associate named identifiers with secrets across namespaces.",
      "description_length": 678,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.External_metric_status",
      "library": "kubecaml",
      "description": "This module manages global, non-Kubernetes metrics used in autoscaling decisions, providing a structured way to represent, construct, and serialize metric values, names, and selectors. It supports operations to convert metric data to and from JSON, enabling integration with Kubernetes' autoscaling system for metrics like queue length or request rate from external sources. The child module handles lists of these metrics, offering utilities to serialize and deserialize them for use in autoscaling configurations. Together, they enable precise external metric tracking and data interchange in autoscaling workflows.",
      "description_length": 617,
      "index": 1253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Azure_file_volume_source",
      "library": "kubecaml",
      "description": "This module configures Azure File Service volumes for Kubernetes pods, offering direct access to fields like storage account secret name, file share name, and read-only flag. It supports creating, serializing, and manipulating volume source configurations, enabling persistent storage integration in pod definitions. The child module extends this functionality by managing multiple Azure File mounts through a key-based list structure, with JSON serialization for interoperability. Together, they allow defining and organizing complex Azure-backed storage setups within Kubernetes orchestration.",
      "description_length": 595,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job_spec",
      "library": "kubecaml",
      "description": "This module structures and manages cron job configurations in Kubernetes, enabling the definition of schedules, job templates, concurrency policies, and history retention limits. It supports creating and manipulating job execution policies and specifying named configurations through key-value mappings, which can be serialized to and from JSON using `to_yojson` and `of_yojson`. Concrete uses include scheduling recurring tasks, enforcing execution constraints, and maintaining a configurable number of past job runs for auditing or debugging. The module combines direct configuration management with named specification serialization for flexible deployment and storage workflows.",
      "description_length": 682,
      "index": 1255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_list",
      "library": "kubecaml",
      "description": "This module represents a collection of Kubernetes RBAC roles, each with metadata, kind, API version, and a list of role items. It provides constructors, accessors, and transformations for these structures, enabling manipulation and management of RBAC role groups. The included submodule handles JSON serialization and deserialization, converting Role_list data to and from key-value pair lists for storage or API interaction. For example, users can construct a role list, modify its entries, and serialize it to JSON for transmission to a Kubernetes service.",
      "description_length": 558,
      "index": 1256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch.Cronjobs",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Kubernetes CronJob resources using a watch request path template. It provides the `get` function to establish a watch stream with customizable query parameters like resource version, label selectors, and timeouts. This module is used to monitor changes to CronJobs in real-time, such as tracking job creation, completion, or failures in a cluster.",
      "description_length": 412,
      "index": 1257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for configuring a Replica Set in Kubernetes, including setting the number of replicas, pod template, and label selector. It provides functions to create, serialize, and access fields such as `replicas`, `template`, `selector`, and `min_ready_seconds`, and works with a child module that manages a list of key-value pairs where each value is a `Replica_set_spec.t` record. Use this module to programmatically define or manipulate Replica Set specifications, such as in deployment automation or Kubernetes resource management tools, and to convert collections of named replica set configurations to and from JSON.",
      "description_length": 660,
      "index": 1258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_volume_file",
      "library": "kubecaml",
      "description": "This module structures file definitions for downward API volumes, allowing pod or container fields to be exposed as files with specified paths and optional modes. It supports direct creation and manipulation of file configurations, and includes a child module for mapping string keys to these configurations, enabling structured injection of pod metadata or resource data into containers. The child module provides JSON serialization and deserialization via `to_yojson` and `of_yojson`, facilitating integration with Kubernetes configuration workflows. Example usage includes injecting a pod's IP or container resource limits into a mounted file for consumption by application code.",
      "description_length": 682,
      "index": 1259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_projection",
      "library": "kubecaml",
      "description": "This module projects a ConfigMap into a volume, exposing its data as files in a container's filesystem. It allows precise control over which keys are included, their file paths, and whether they are optional. The projection can be serialized to and from JSON, enabling seamless integration with API requests and responses. For example, you can map specific ConfigMap keys to custom paths in the container or encode projections for transmission over HTTP APIs.",
      "description_length": 459,
      "index": 1260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes Namespace objects with metadata, API version, and kind, providing functions to construct, access, and serialize namespace lists. It includes direct operations for list manipulation and conversion to and from JSON using Yojson, supporting efficient API communication. The module is used to handle collections of Namespace resources, such as when retrieving or updating multiple namespaces from a cluster. Specific operations include creating a namespace list from raw JSON data, extracting individual namespaces, and serializing the list for API requests.",
      "description_length": 598,
      "index": 1261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Nfs_volume_source",
      "library": "kubecaml",
      "description": "This module defines an NFS volume source for Kubernetes pods, allowing creation and manipulation of NFS mount configurations with server, path, and read-only settings. It includes a submodule that manages lists of named NFS volume configurations, supporting JSON serialization and deserialization for use in Kubernetes pod specs. Main data types include the NFS volume source record and a list type representing multiple mounted volumes. Example usage includes configuring a pod to mount a shared NFS directory at `/mnt/data` from server `nfs.example.com` as read-only.",
      "description_length": 569,
      "index": 1262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_status",
      "library": "kubecaml",
      "description": "This module represents the runtime state of an Ingress resource, primarily tracking load balancer status with functions to construct and access the optional load balancer status field. It supports JSON serialization and deserialization, enabling conversion of Ingress_status data to and from JSON for storage or transmission. The module handles a list of key-value pairs where each value is an Ingress_status, allowing inspection or update of external IPs and ingress hostnames in Kubernetes. Specific operations include extracting load balancer status, modifying Ingress state, and converting status data to JSON for external use.",
      "description_length": 631,
      "index": 1263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Iscsi_volume_source",
      "library": "kubecaml",
      "description": "This module provides core functionality for defining and configuring iSCSI volume sources in Kubernetes, allowing the setup of secure, read/write iSCSI disks with support for authentication, target portals, and LUN specification. It includes operations to set file system types, enable SELinux relabeling, and manage ownership, working with primitives like strings, integers, and lists alongside Kubernetes object references. A child module extends this by enabling the representation of multiple named iSCSI volume sources as key-value pairs, with JSON serialization and deserialization support. Together, they facilitate the integration of iSCSI-backed storage into pod definitions for stateful applications requiring persistent, configurable storage.",
      "description_length": 753,
      "index": 1264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Env_var_source",
      "library": "kubecaml",
      "description": "This module defines a data structure for specifying sources of environment variable values in Kubernetes pod specifications, supporting references to ConfigMaps, secrets, resource fields, and object fields. It provides functions to construct and access these sources, enabling precise configuration of environment variables from cluster resources. The child module handles serialization and deserialization of these sources in Kubernetes API v1 objects, working with associative lists mapping strings to `Env_var_source.t` values. Use the combined functionality to inject configuration data, secrets, or metadata into containers at runtime and manage environment variable configurations in JSON format for deployment.",
      "description_length": 717,
      "index": 1265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1.Watch.Priorityclasses",
      "library": "kubecaml",
      "description": "This module provides real-time observation of Kubernetes priority class resources, supporting filtered watches, result limiting, and control over request parameters like timeout and resource version. It includes a submodule that streams events for specific priority class instances by name, enabling precise tracking of changes. Main data types include event streams and priority class objects, with operations to watch, retrieve, and filter based on labels or fields. Example uses include dynamically adjusting scheduling policies in response to priority class updates or tracking cluster-wide priority class state in an external controller.",
      "description_length": 642,
      "index": 1266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Storage_os_volume_source",
      "library": "kubecaml",
      "description": "This module represents a StorageOS persistent volume source for Kubernetes, offering constructors and accessors to configure volume parameters like namespace, name, filesystem type, and read-only status. It supports secret references for authentication and provides JSON serialization and deserialization of volume configurations, enabling dynamic mounting of StorageOS volumes in pods. The child module structures multiple StorageOS volume sources as key-value pairs, facilitating their use in Kubernetes persistent volume claims through JSON-compatible mappings. Together, they allow defining and managing StorageOS-backed persistent volumes with namespace scoping and filesystem customization.",
      "description_length": 696,
      "index": 1267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates horizontal pod autoscaler specifications, handling scaling parameters such as min and max replicas, metric sources, and target references. It supports constructing autoscaler configurations for Kubernetes deployments based on resource or custom metrics, enabling dynamic scaling logic. The module includes functions to serialize and deserialize specifications using Yojson, working with key-value lists where each value is an autoscaler spec. You can define autoscaling behavior programmatically, convert it to JSON for API submission, or parse existing configurations for modification.",
      "description_length": 625,
      "index": 1268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod",
      "library": "kubecaml",
      "description": "This module provides tools for building and managing Pod resources, combining direct operations on Pod metadata, specifications, and status with structured data types like `Pod_spec`, `Pod_status`, and `Object_meta`. It supports key operations such as creating Pod configurations, serializing to JSON for API interaction, and parsing JSON responses into typed objects. A child module extends this functionality by organizing multiple named Pod specs into a collection, enabling use cases like multi-tenant workload management. Together, the module and its submodules facilitate both individual Pod manipulation and grouped configuration handling.",
      "description_length": 646,
      "index": 1269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes workload resources within a namespace, focusing on stateful and replicated application deployments. It supports key data types including StatefulSet, ReplicaSet, DaemonSet, Deployment, and ControllerRevision, along with their list and status variants, enabling operations like creation, deletion, scaling, and status updates. Submodules handle fine-grained control such as scaling replica counts, applying patches, and inspecting runtime state. Example uses include deploying a new StatefulSet, scaling a ReplicaSet in response to load, or updating a Deployment's configuration.",
      "description_length": 635,
      "index": 1270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Watch.Customresourcedefinitions",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes custom resource definitions by watching for changes such as creation, deletion, or updates. It supports configurable parameters like resource version, label selectors, and timeouts, and processes watch event streams to track CRD lifecycle events. A specific CRD can be observed by name using the `get` function, which streams events and returns either a watch result or an error. Example usage includes detecting when a CRD is updated to trigger corresponding application logic or ensuring synchronization with cluster state changes.",
      "description_length": 588,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Scale_status",
      "library": "kubecaml",
      "description": "This module represents the current state of a Kubernetes scale subresource, tracking replicas and label selectors for scalable objects like deployments. It provides operations to create, serialize, and access fields such as `replicas`, `selector`, and `target_selector`, enabling precise monitoring and management of scaling behavior. The child module extends this by organizing multiple `Scale_status.t` values in a list-based structure, mapping string keys to statuses for handling collections of scaled resources. Together, they support parsing and generating Kubernetes API responses, such as retrieving observed replica counts or updating desired scaling targets.",
      "description_length": 668,
      "index": 1272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes StatefulSet configurations, allowing definition of pod templates, update strategies, volume claims, and pod management policies. It supports creating and modifying StatefulSet specs for applications needing stable identities and persistent storage, like databases. The child module organizes multiple specs into a JSON-serializable list, enabling programmatic deployment and inspection of stateful workloads. Together, they facilitate precise control and serialization of stateful application configurations in Kubernetes.",
      "description_length": 556,
      "index": 1273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment",
      "library": "kubecaml",
      "description": "This module manages the lifecycle of volume attachment requests in a Kubernetes environment, allowing construction, manipulation, and tracking of attach or detach operations between volumes and nodes. It provides core data types representing volume attachments, with functions to define metadata, specify attachment behavior, and monitor status, along with JSON serialization and deserialization capabilities. The child module enhances this functionality by enabling conversion of volume attachment definitions to and from JSON, facilitating API communication and persistent storage. Example uses include programmatically creating volume attachment intents, serializing them for transmission, or parsing and processing incoming attachment requests from external systems.",
      "description_length": 770,
      "index": 1274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Daemonsets",
      "library": "kubecaml",
      "description": "This module watches for changes to DaemonSet resources in a Kubernetes cluster. It provides a `get` function to stream events matching specified criteria, such as label selectors or resource versions, over HTTP. Use it to monitor DaemonSet updates in real time, for example, to trigger rollouts or health checks based on observed state changes.",
      "description_length": 344,
      "index": 1275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch.Podpresets",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for PodPreset resources in a Kubernetes cluster. It provides a `get` function to establish a watch stream with optional parameters like label selectors, resource version, and timeouts, returning events describing changes to PodPreset objects. This module is used to monitor dynamic configuration presets applied to pods in real time.",
      "description_length": 394,
      "index": 1276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_list",
      "library": "kubecaml",
      "description": "This module manages certificate signing request lists in Kubernetes, offering functions to construct, serialize, and deserialize these lists to and from JSON. It supports access to core fields such as `api_version`, `kind`, and `items`, and works with Kubernetes API v1beta1 certificate endpoints using structured data like tuples of strings and certificate signing request objects. The child module specializes in JSON conversion, enabling seamless interaction with Kubernetes APIs and handling complex data structures for configuration and response payloads. Example uses include parsing API responses into typed OCaml structures and generating JSON for submission to Kubernetes certificate endpoints.",
      "description_length": 703,
      "index": 1277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Policy_rule",
      "library": "kubecaml",
      "description": "This module defines the core structure and operations for representing Kubernetes RBAC policy rules, including verbs, resources, API groups, and non-resource URLs. It supports constructing, deconstructing, and manipulating individual rules to define fine-grained access control policies. The child module extends this functionality by pairing policy rules with string identifiers, enabling structured serialization to JSON and integration with RBAC v1beta1 configurations. Use these modules together to build and manage role or cluster role permissions programmatically.",
      "description_length": 570,
      "index": 1278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1.Event",
      "library": "kubecaml",
      "description": "This module models Kubernetes events that reflect state changes in a cluster, offering tools to create, inspect, and serialize events with metadata, timestamps, and object references. It exposes key operations to extract event properties like `action`, `reason`, and type, while the nested `Object` module manages resource references associated with events. The child module extends this functionality by handling collections of events keyed by strings, enabling structured processing of event streams from the Kubernetes API. Use it to monitor cluster activity, audit resource changes, or trigger workflows based on events such as pod scheduling or container restarts.",
      "description_length": 669,
      "index": 1279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Pods",
      "library": "kubecaml",
      "description": "This module manages Pod resources within a Kubernetes namespace, supporting CRUD operations through `get`, `put`, `delete`, and `patch` functions on core types like Pod, DeleteOptions, and Patch. It enables retrieving Pod details, applying configuration updates, and managing deletion grace periods, while submodules provide specialized capabilities such as streaming logs, forwarding ports, executing commands, and evicting Pods. Specific tasks include debugging applications via port forwarding, inspecting logs with custom filters, and rescheduling Pods through eviction policies. The combination of direct API access and submodule extensions offers fine-grained control over Pod lifecycle and interaction within cluster workflows.",
      "description_length": 734,
      "index": 1280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for configuring a Kubernetes scale subresource, including creating, serializing, and deserializing scale specifications with optional replica counts. It centers around the `t` type representing a scale specification and supports key operations like setting and retrieving desired replica counts. The included child module handles lists of key-value pairs with `Scale_spec.t` values, providing `to_yojson` and `of_yojson` for JSON conversion. Use this module to programmatically manage scaling parameters for Kubernetes workloads and serialize them for storage or transmission.",
      "description_length": 625,
      "index": 1281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_address",
      "library": "kubecaml",
      "description": "This module represents a node's address in a Kubernetes cluster, including its type (e.g., Hostname, External_ip, Internal_ip) and the associated string value. It provides constructors, accessors, and JSON serialization through `to_yojson` and `of_yojson` for use in API communication. The child module extends this by managing collections of addresses keyed by string, enabling structured serialization and deserialization of multiple addresses. Together, they support tasks like parsing and generating node network details in Kubernetes API interactions.",
      "description_length": 556,
      "index": 1282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_condition",
      "library": "kubecaml",
      "description": "This module models the condition of a Kubernetes pod with structured data, capturing type, status, timestamps, and diagnostic messages. It supports creating, inspecting, and serializing individual conditions, while its child module organizes multiple conditions into a keyed collection for efficient state tracking and JSON conversion. Use cases include evaluating pod readiness, diagnosing failed probes, and synchronizing with Kubernetes control loops using precise condition transitions.",
      "description_length": 490,
      "index": 1283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Session_affinity_config",
      "library": "kubecaml",
      "description": "This module manages session affinity configurations for Kubernetes services, focusing on client IP-based routing to ensure stable backend pod selection. It provides data types to represent affinity settings and operations to construct, access, and serialize these configurations. The included serialization submodule converts configurations to and from JSON, supporting use cases like storing or transmitting affinity rules as structured data. Example usage includes setting up load-balanced services that maintain client-to-pod affinity or restoring such settings from a JSON-encoded configuration.",
      "description_length": 599,
      "index": 1284,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_rules_review_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates self-subject rules review specifications for the Kubernetes authorization API, supporting namespace context and JSON serialization. It enables creating and processing review requests to determine user permissions in specific namespaces. The child module extends this functionality by mapping string keys to review spec values, facilitating the representation of rule sets and their conversion to and from JSON. Together, they support constructing, serializing, and submitting complex authorization queries in Kubernetes workflows.",
      "description_length": 569,
      "index": 1285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1.Volume_attachment_status",
      "library": "kubecaml",
      "description": "This module represents the status of a volume attachment request in a Kubernetes API, tracking whether a volume is attached, any associated errors, and metadata from attach or detach operations. It provides constructors and accessors for working with boolean attachment states, optional error information, and string-based metadata. The included submodule handles JSON serialization and deserialization of these status objects, converting between in-memory representations and JSON using key-value lists. You can use this module to construct status updates, inspect attachment errors, and serialize status data for transmission or storage.",
      "description_length": 639,
      "index": 1286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Podtemplates",
      "library": "kubecaml",
      "description": "This module manages PodTemplate resources within a Kubernetes namespace, offering operations to list, create, and delete collections of PodTemplates using standard query parameters and Kubernetes API objects like PodTemplateList and Status. It supports filtering and resource management workflows, enabling tasks like deploying or cleaning up templates based on labels or field selectors. The child module extends this functionality with fine-grained CRUD operations for individual PodTemplates, including `get`, `put`, `delete`, and `patch`, allowing precise manipulation of resources by name. Together, they provide a complete interface for managing PodTemplates at both the collection and individual resource level.",
      "description_length": 718,
      "index": 1287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Binding",
      "library": "kubecaml",
      "description": "This module manages associations between Kubernetes resources, such as pods and nodes, by defining binding objects with metadata, versioning, and target references. It supports creating, serializing, and manipulating these bindings, with direct operations for setting resource kinds and references. The child module extends this functionality by providing a list structure for handling multiple bindings as key-value pairs, enabling efficient processing of deprecated binding data from cluster snapshots. Specific uses include constructing pod-to-node assignments and converting binding data to and from JSON for API interaction or storage.",
      "description_length": 640,
      "index": 1288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Deployments",
      "library": "kubecaml",
      "description": "Implements watching individual changes to Kubernetes Deployment resources via a streaming HTTP request. Accepts parameters like `watch`, `timeout_seconds`, and `label_selector` to filter and control the event stream. Returns a result containing a Watch_event or an error message.",
      "description_length": 279,
      "index": 1289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Metric_spec",
      "library": "kubecaml",
      "description": "This module defines a single metric specification for autoscaling, supporting four distinct metric sources: resource, pods, object, and external. It provides constructors and accessors to create and manipulate metric specifications, ensuring only one metric source is set at a time. A child module extends this by representing a list of metric specifications, each paired with a string identifier, and supports JSON serialization via Yojson. Together, they enable defining and serializing complex autoscaling policies, such as configuring Kubernetes horizontal pod autoscalers based on CPU usage, custom metrics, or external queue lengths.",
      "description_length": 639,
      "index": 1290,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_condition",
      "library": "kubecaml",
      "description": "This module represents and manipulates node condition data in a Kubernetes API context, modeling health and state transitions with structured fields like type, status, and timestamps. It provides constructors and accessors for individual node conditions, along with a submodule for managing collections of conditions, enabling operations such as JSON serialization and deserialization via Yojson. The combined functionality supports tracking, persisting, and retrieving node states in a type-safe and structured manner. Example uses include constructing a node condition with a specific status and reason, or serializing a collection of conditions to store in a configuration file.",
      "description_length": 681,
      "index": 1291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Stateful_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes StatefulSet objects, offering direct access to API version, kind, metadata, and item lists, along with JSON (de)serialization via Yojson. It supports operations to construct, retrieve, and modify StatefulSet entries, enabling efficient handling of groups of StatefulSets for Kubernetes API interactions. The child module enhances this functionality by representing StatefulSets as string-structure tuples, facilitating structured list processing and serialization. Use cases include persisting StatefulSet groups to disk or transmitting them over a network in a Kubernetes environment.",
      "description_length": 631,
      "index": 1292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Clusterroles.By_name",
      "library": "kubecaml",
      "description": "This module implements CRUD operations for Kubernetes ClusterRole resources using HTTP verbs. It works with ClusterRole definitions, handling creation, retrieval, update, and deletion via `put`, `get`, `patch`, and `delete` functions. Use this module to manage cluster-level role-based access control policies programmatically.",
      "description_length": 327,
      "index": 1293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Gce_persistent_disk_volume_source",
      "library": "kubecaml",
      "description": "This module configures GCE Persistent Disk volume sources for Kubernetes, allowing disks to be mounted into containers with specified read/write permissions, partition, and filesystem settings. It operates on a structured type that captures GCE PD metadata and supports JSON serialization for integration with Kubernetes APIs. The module ensures disks are correctly referenced by name and configured for use in GKE environments, handling ownership and SELinux settings as needed. It is commonly used alongside its child module to serialize volume configurations when defining Kubernetes pods that require persistent storage from GCE.",
      "description_length": 633,
      "index": 1294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes StatefulSet objects with fields for API version, kind, metadata, and a list of items. It provides functions to construct, serialize, and access the list, along with a nested Object module for per-item operations such as updating replicas or inspecting status. The v1beta2 submodule adds JSON serialization support via Yojson, enabling conversion to and from JSON for storage or transmission. Use this module to manage multiple StatefulSets, such as listing all in a namespace or processing batch updates.",
      "description_length": 548,
      "index": 1295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1.Job_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes Job configurations with custom types for parallelism, completion thresholds, pod templates, and label selectors, enabling precise control over batch job execution. It supports defining jobs with retry policies, deadlines, and selection strategies, while its child module handles structured configuration through JSON serialization of job spec collections. Operations include creating job specs from templates, setting completion criteria, and associating labels with pods. Example uses include generating job configurations from JSON files and programmatically constructing batch tasks with custom execution parameters.",
      "description_length": 653,
      "index": 1296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Object_metric_source",
      "library": "kubecaml",
      "description": "This module manages object metric sources for Kubernetes autoscaling, enabling the definition and manipulation of custom metrics on Kubernetes objects such as Ingress. It provides core operations to construct, serialize, and access metric sources, including specifying the metric name, target object reference, and desired value. The child module handles JSON conversion using Yojson, supporting translation between in-memory configurations and API payloads. Example uses include scaling pods based on Ingress request rates or custom resource metrics by serializing metric source definitions for the Kubernetes autoscaling API.",
      "description_length": 627,
      "index": 1297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module tracks CronJob resources in Kubernetes namespaces, providing real-time updates on job lifecycle events, status changes, and deletions. It supports filtering by labels and fields, maintains resource versions for consistency, and handles large datasets through pagination. Developers can monitor all CronJobs or target specific jobs to trigger actions like auto-scaling or live dashboard updates based on job creation, modifications, or removals. Example use cases include scaling systems reacting to scheduled workloads and monitoring tools displaying job status in real time.",
      "description_length": 587,
      "index": 1298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_spec",
      "library": "kubecaml",
      "description": "This module structures Kubernetes daemon set specifications with core fields like pod templates, label selectors, update strategies, and revision limits. It coordinates with nested API types to enforce consistent pod distribution and deployment policies across cluster nodes. The child module manages collections of these specifications as key-value pairs, supporting JSON serialization for storage and transmission. Together, they enable defining, updating, and serializing daemon set configurations for cluster-wide deployment.",
      "description_length": 529,
      "index": 1299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Toleration",
      "library": "kubecaml",
      "description": "This module defines a toleration structure that allows pods to schedule onto nodes with matching taints, based on key, value, effect, and operator fields. It includes functions to construct and access toleration fields, along with JSON serialization and deserialization for integration with Kubernetes pod specifications. The child module handles lists of tolerations, enabling conversion to and from JSON using Yojson. Together, they support configuring and serializing complex scheduling policies, such as specifying which node taints a pod can tolerate.",
      "description_length": 556,
      "index": 1300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Run_as_user_strategy_options",
      "library": "kubecaml",
      "description": "This module defines strategy options for Kubernetes run-as-user policies, including rule types and UID ranges, with functions to construct and validate these policies. It supports precise user ID constraints for pod security policies, enabling configurations that restrict containers to run as specific users. The child module manages a list of key-value pairs mapping strings to strategy options, facilitating JSON serialization and deserialization for policy configuration. Together, they allow creating, validating, and exporting user execution constraints used in Kubernetes security contexts.",
      "description_length": 597,
      "index": 1301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Resource_rule",
      "library": "kubecaml",
      "description": "This module defines and manipulates authorization rules for Kubernetes API resources, specifying allowed verbs, resources, resource names, and API groups. It supports creating, serializing, and accessing fields of a resource rule, working with optional and wildcard-based policies, and handles lists of such rules with support for duplicates and incomplete entries. The child module provides JSON serialization and deserialization using `Yojson.Safe.t`, enabling direct interaction with Kubernetes API payloads. Concrete use cases include constructing and validating RBAC policies, such as defining permissions for specific resources or restricting access to certain API groups.",
      "description_length": 678,
      "index": 1302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Limit_range_spec",
      "library": "kubecaml",
      "description": "This module defines and enforces resource usage limits for Kubernetes objects based on kind, providing functions to create and access a list of `Limit_range_item` objects that specify min/max constraints for resources like CPU and memory. It supports configuring resource boundaries in Kubernetes namespaces to ensure workloads adhere to predefined limits. The module includes serialization functions to convert a list of key-value pairs, where each value is a `Limit_range_spec.t`, to and from JSON using `to_yojson` and `of_yojson`. This enables correct encoding and decoding of resource limit specifications when interacting with the Kubernetes API or persisting configurations.",
      "description_length": 681,
      "index": 1303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_key_selector",
      "library": "kubecaml",
      "description": "This module provides a selector for extracting specific keys from Kubernetes ConfigMaps, allowing users to reference configuration data directly within resource definitions. It supports constructing and accessing selectors with operations to retrieve the key, name, and optional presence flag. The child module extends this functionality by representing a list of key-value pairs where each value is a selector, enabling structured configuration mappings that can be serialized to JSON. This combination allows users to define complex configurations pulling multiple values from ConfigMaps, suitable for use in Kubernetes resources like Pods or Deployments.",
      "description_length": 657,
      "index": 1304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1.Pod_preset",
      "library": "kubecaml",
      "description": "This module provides tools to define and manipulate Pod-preset resources that enforce runtime constraints on Kubernetes pods. It supports creating, serializing, and accessing core fields like api_version, kind, metadata, and spec, enabling programmatic management of Pod-preset configurations in a Kubernetes v1alpha1 context. The included submodule handles JSON conversion, allowing Pod-preset objects to be encoded to or decoded from JSON representations for storage or transmission. For example, you can construct a Pod-preset with specific environment variables or volume mounts, then serialize it to JSON for deployment or later retrieval.",
      "description_length": 644,
      "index": 1305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_condition",
      "library": "kubecaml",
      "description": "This module models the state of a replication controller condition with fields for type, status, reason, message, and transition time, providing constructors and accessors for these properties. It includes serialization and deserialization to JSON via Yojson, enabling integration with Kubernetes APIs. The child module handles lists of these conditions, offering JSON conversion for collections, which allows tracking and transmitting multiple status changes in a cluster. Example usage includes constructing a condition to reflect a failed pod creation event and serializing it for logging or API responses.",
      "description_length": 609,
      "index": 1306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_status",
      "library": "kubecaml",
      "description": "This module tracks the runtime state of a StatefulSet, capturing fields like replicas, revisions, and conditions to reflect deployment status. It provides constructors and accessors for these fields, enabling precise monitoring and management of rollouts. A child module handles JSON serialization and deserialization of StatefulSet status data, supporting API interactions through key-value lists of status records. Together, they enable inspection of observed revisions, collision counts, and condition states, both directly and through structured data exchange.",
      "description_length": 564,
      "index": 1307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch.Networkpolicies",
      "library": "kubecaml",
      "description": "This module handles watching for changes to a list of NetworkPolicy resources in a Kubernetes cluster. It provides a `get` function to initiate a watch request with customizable parameters like timeouts, selectors, and resource versions, returning events as they occur. The `request_path_template` gives the API path for these watch operations.",
      "description_length": 344,
      "index": 1308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_selector_requirement",
      "library": "kubecaml",
      "description": "This module defines a selector requirement with a key, operator, and optional list of values, ensuring validity based on the operator's constraints. It supports operations to construct and access these components, enabling precise node selection logic such as requiring specific label values or numeric conditions. The child module extends this by managing a list of such requirements, offering JSON serialization and deserialization for integration with Kubernetes scheduling. Together, they allow defining and manipulating complex node selection constraints directly in OCaml and through structured data formats.",
      "description_length": 614,
      "index": 1309,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Container_state",
      "library": "kubecaml",
      "description": "This module represents the state of a Kubernetes container, which can be waiting, terminated, or running, and provides functions to construct, access, and serialize these states to and from JSON. Its primary data type encodes the container's state with variants for each possible condition, allowing inspection or modification of container statuses within Kubernetes resources like pods. A child module extends this functionality by managing multiple container states keyed by strings, supporting bulk operations and JSON conversion for use in API interactions. Use this module to handle container lifecycle events, track state transitions, or serialize container status information for storage or transmission.",
      "description_length": 711,
      "index": 1310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Policy_rule",
      "library": "kubecaml",
      "description": "This module defines the core structure and operations for representing Kubernetes RBAC policy rules, including verbs, resources, API groups, and non-resource URLs. It supports constructing, manipulating, and serializing individual rules and collections of rules to and from JSON, enabling integration with Kubernetes API interactions and configuration tools. The module handles both resource-based access control and URL-based access rules, allowing precise specification of permissions such as allowing GET and POST actions on specific resources or paths. Specific uses include defining access policies for Kubernetes controllers, converting rule sets to machine-readable formats, and validating rule structures before deployment.",
      "description_length": 731,
      "index": 1311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flex_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module represents a persistent volume source configured with a FlexVolume driver, enabling dynamic provisioning and attachment through exec-based plugins. It supports constructing volume sources with optional parameters like filesystem type, read-only mode, and secrets, and includes functions for JSON serialization and deserialization. The child module extends this functionality by handling list-based JSON conversions, allowing bulk processing of volume source configurations. Use this module to integrate custom storage solutions into Kubernetes clusters using external drivers, either by building and serializing configurations directly or parsing them from JSON input.",
      "description_length": 680,
      "index": 1312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1.Storage_class",
      "library": "kubecaml",
      "description": "This module provides tools for creating and managing Kubernetes storage class objects, including parameters like provisioner, reclaim policy, and mount options. It includes structured types such as `t` and `Object_meta.t`, and supports JSON serialization and deserialization through its child module. Use it to define storage configurations for dynamic volume provisioning or convert storage class definitions to and from JSON for API interactions.",
      "description_length": 448,
      "index": 1313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Mutating_webhook_configuration_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes list of mutating webhook configurations, with fields like `api_version`, `kind`, `metadata`, and `items`. It provides constructors, accessors, and JSON (de)serialization via `to_yojson` and `of_yojson` for handling collections of configurations in admission control setups. The child module extends this functionality by supporting conversion between JSON and a list of key-value pairs, where each value is a `Mutating_webhook_configuration_list.t`. You can use this structure to interact with Kubernetes API endpoints that consume or return lists of mutating webhook configurations in JSON format.",
      "description_length": 634,
      "index": 1314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Fs_group_strategy_options",
      "library": "kubecaml",
      "description": "This module defines filesystem group strategy options for Kubernetes security contexts, including rule selection and ID range constraints. It supports creating and manipulating strategy configurations with optional rules and ID ranges using the `Id_range` type to enforce filesystem group policies in pod security settings. The child module handles key-value mappings of these strategies, enabling JSON serialization and deserialization via Yojson for integration with Kubernetes configuration files. Use this structure to define and manage filesystem group policies in Kubernetes API extensions and pod security configurations.",
      "description_length": 628,
      "index": 1315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch.Roles",
      "library": "kubecaml",
      "description": "This module watches for changes to Role resources in a Kubernetes cluster. It provides a `get` function to stream Role events with options like resource version, label selectors, and timeouts, returning a result indicating success or failure. The `request_path_template` defines the API path for Role watch requests.",
      "description_length": 316,
      "index": 1316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Scale",
      "library": "kubecaml",
      "description": "This module represents and manipulates scaling requests for Kubernetes resources, providing constructors and accessors for fields such as `spec`, `status`, `metadata`, `kind`, and `api_version`. It includes direct support for serializing and deserializing these objects to and from JSON using `Yojson`, enabling seamless interaction with Kubernetes APIs. The child module specializes in handling lists of scaling request definitions, converting them to and from JSON for storage or transmission. Together, they allow users to programmatically define, modify, and exchange scaling configurations for deployments or stateful sets.",
      "description_length": 628,
      "index": 1317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Rbd_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module provides a persistent volume source for Rados Block Device (RBD) in Kubernetes, enabling configuration of RBD-specific parameters such as monitors, image name, pool, user, and secret reference. It supports operations to construct and access these parameters, facilitating integration with Ceph storage for stateful workloads that require durable storage with ownership and SELinux management. The child module handles JSON serialization and deserialization of RBD volume configurations, working with lists of key-value pairs to convert specifications for storage or transmission. Example uses include defining an RBD-backed volume with a Ceph monitor list and secret reference, then serializing it to JSON for use in a pod specification.",
      "description_length": 749,
      "index": 1318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Object_field_selector",
      "library": "kubecaml",
      "description": "This module provides a way to select versioned fields from Kubernetes API objects, allowing users to construct and manipulate field selectors with optional API versions. It includes operations to extract field paths and versions, and supports dynamic access to object metadata or status fields in resource definitions. The child module extends this functionality by handling lists of key-value pairs with `Object_field_selector` values, enabling structured field selection configurations to be serialized and deserialized to JSON. Together, they facilitate precise field targeting in Kubernetes API interactions, such as building custom controllers or admission webhooks.",
      "description_length": 671,
      "index": 1319,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_condition",
      "library": "kubecaml",
      "description": "This module models the operational state of a Kubernetes StatefulSet using a structured data type that captures condition type, status, reason, message, and transition time. It supports creating, accessing, and serializing these conditions to and from JSON, enabling integration with Kubernetes APIs. The child module extends this functionality by handling lists of keyed conditions, allowing mappings from string keys to condition data for batch processing and API exchanges. Example uses include tracking StatefulSet health transitions and encoding condition metadata for cluster status reporting.",
      "description_length": 599,
      "index": 1320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request_status",
      "library": "kubecaml",
      "description": "This module manages certificate signing request statuses within a Kubernetes API, providing constructors, accessors, and serialization for status objects, including conditions and issued certificates. It supports operations to set approval states, retrieve signed certificates, and convert status data to and from JSON using its child module. The core data type represents a status with condition lists and optional certificate data, while JSON conversion works with key-value lists for external representation. Example uses include updating a CSR's approval state and extracting a signed certificate after issuance.",
      "description_length": 616,
      "index": 1321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Csi_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module provides a structured representation of CSI-managed storage volumes for Kubernetes, capturing essential properties like driver, volume handle, filesystem type, and secret references. It enables secure configuration of persistent volumes that interface with external storage systems through CSI drivers. The module supports both direct manipulation of volume source fields and list-based handling of multiple volume sources, with JSON serialization for integration into Kubernetes manifests. Example usage includes defining a CsiPersistentVolumeSource with a specific driver and secret, then serializing it for inclusion in a cluster's storage configuration.",
      "description_length": 669,
      "index": 1322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Scale_status",
      "library": "kubecaml",
      "description": "This module tracks the state of Kubernetes scale subresources, with fields for replica counts, label selectors, and target selectors, enabling precise interpretation of scaling behavior. It includes functions to construct and access these fields directly, along with JSON serialization via `to_yojson` and `of_yojson` for API interaction. The child module extends this by organizing multiple `Scale_status` records into a list structure, supporting versioned Kubernetes API responses. Together, they allow efficient handling of scaling status data, from individual resources to grouped representations in deployment workflows.",
      "description_length": 626,
      "index": 1323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy",
      "library": "kubecaml",
      "description": "This module provides tools for creating, manipulating, and analyzing Kubernetes network policy objects, focusing on structured access to API version, kind, metadata, and specification fields. It supports key operations such as building valid network policies, extracting rule sets for enforcement, and converting policies to JSON for API communication. The child module enhances this functionality by enabling robust serialization and deserialization of network policies, allowing for storage or transmission as JSON. For example, users can define a network policy with specific ingress and egress rules, serialize it to JSON for cluster deployment, or deserialize an existing policy to inspect and modify its structure.",
      "description_length": 720,
      "index": 1324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume",
      "library": "kubecaml",
      "description": "This module provides tools for creating and managing persistent volume objects, including setting metadata, specifications, and status, while supporting serialization and deserialization via JSON. It handles core Kubernetes persistent volume definitions and exposes accessors for key properties such as API version, kind, and spec. The child module specializes in converting lists of persistent volume definitions to and from JSON, enabling data storage and transmission. Use cases include generating and serializing persistent volume configurations for cluster management and automating storage provisioning workflows.",
      "description_length": 619,
      "index": 1325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides typed HTTP operations to manage Horizontal Pod Autoscaler resources within a Kubernetes namespace using the V2beta1 API. It supports creating, listing, and deleting autoscalers through precise `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list` data types, enabling programmatic adjustments to scaling policies for deployments or stateful sets. You can use it to retrieve current autoscaler configurations, set new scaling thresholds, or automate responses to system load changes in real time.",
      "description_length": 527,
      "index": 1326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Supplemental_groups_strategy_options",
      "library": "kubecaml",
      "description": "This module defines the core strategy and configuration options for managing supplemental group policies in Kubernetes security contexts. It supports creating, serializing, and deserializing configurations that specify allowed ID ranges and selection rules for supplemental groups. The module includes operations to convert policy configurations to and from JSON using a list of key-value tuples representing strategy options. Example uses include defining a restricted range of supplemental group IDs and encoding them for storage or API transmission.",
      "description_length": 552,
      "index": 1327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_name.Finalize",
      "library": "kubecaml",
      "description": "This module constructs request paths and sends PUT requests to update the finalized state of a Kubernetes Namespace by name. It operates on Namespace resources, taking a Namespace definition as input and returning the updated Namespace or an error. Concrete use cases include programmatically finalizing a Namespace's termination or modifying its finalizers list during cleanup operations.",
      "description_length": 389,
      "index": 1328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch.Jobs",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Kubernetes Job resources, supporting filtering by label and field selectors, resource version, and timeout settings. It operates on Kubernetes Job objects and returns events indicating additions, modifications, or deletions. Useful for monitoring job status changes in real-time within a namespace or cluster.",
      "description_length": 374,
      "index": 1329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Replicasets",
      "library": "kubecaml",
      "description": "This module handles watching for changes to a list of ReplicaSet resources in Kubernetes. It provides a `get` function to initiate a watch request with customizable parameters like timeouts, selectors, and pagination, returning events describing changes. The `request_path_template` gives the API path for ReplicaSet watch operations.",
      "description_length": 334,
      "index": 1330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Pods_metric_source",
      "library": "kubecaml",
      "description": "This module configures pod-level metrics for horizontal autoscaling by averaging values across pods, using a metric name and target average quantity. It supports creating, accessing, and serializing metric sources to JSON, enabling autoscaling rules based on per-pod metrics like average requests per second. The child module handles conversion between JSON and typed representations, working with string maps of metric sources. Together, they allow defining and persisting autoscaling policies that respond to per-pod performance data.",
      "description_length": 536,
      "index": 1331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Statefulsets",
      "library": "kubecaml",
      "description": "Implements watching for changes to StatefulSet resources in a Kubernetes cluster. It provides a function to establish a watch stream with customizable parameters like resource version, label selectors, and timeouts, returning events as they occur. This module handles watch events for StatefulSets, enabling real-time monitoring of their state changes.",
      "description_length": 352,
      "index": 1332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time observation of Kubernetes events within a namespace, supporting targeted monitoring through filters based on labels, fields, resource versions, and timeouts. It provides event streams and filter configurations as core data types, with operations to subscribe, filter, and retrieve event data. Users can track events for specific resources like pods or services, enabling automated reactions and detailed debugging. For instance, it can monitor changes to a service's event stream or capture pod-related events in real time.",
      "description_length": 553,
      "index": 1333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Cluster_role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes API list resource containing multiple cluster role bindings, providing functions to construct, access, and serialize these lists with fields such as `api_version`, `kind`, `metadata`, and `items`. It includes support for converting the entire list to and from JSON using `Yojson.Safe.t`, enabling serialization for API interactions or configuration management. Each binding in the list is paired with a string identifier, allowing for structured handling of RBAC configurations. Use this module when managing collections of cluster role bindings in a Kubernetes control plane context, particularly for reading, creating, or serializing such lists.",
      "description_length": 683,
      "index": 1334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Self_subject_access_review",
      "library": "kubecaml",
      "description": "This module represents a self-subject access review in Kubernetes, enabling the current user to check whether they are authorized to perform an action, optionally across all namespaces. It defines the `t` type with operations to construct, inspect, and serialize reviews, including accessing metadata, kind, API version, and status. The child module handles JSON serialization of key-value lists where each value is a `t`, using `Yojson.Safe.t` for integration with Kubernetes' authorization API. Example usage includes creating a review to determine if the user can create a pod or access a service in a specific or all namespaces.",
      "description_length": 632,
      "index": 1335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module tracks and inspects Kubernetes RBAC resources in real time, focusing on Roles and RoleBindings within a namespace. It supports `get` and `watch` operations with filtering, resource versions, timeouts, and pagination. You can use it to monitor RBAC updates in multi-tenant clusters, stream role changes for audit logs, or synchronize permissions dynamically. Key data types include Role and RoleBinding, with operations optimized for real-time access control and security auditing.",
      "description_length": 492,
      "index": 1336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1.Stateful_set_update_strategy",
      "library": "kubecaml",
      "description": "The module provides operations to define and configure StatefulSet update strategies, centered around the `t` type which captures strategy types and associated parameters like rolling update settings. It integrates with the `Rolling_update_stateful_set_strategy` module to specify details such as max surge and max unavailable during deployments. The module supports converting strategy configurations to and from JSON using key-value lists, enabling storage, transmission, or dynamic configuration from external inputs. Example usage includes setting a rolling update policy with specific thresholds and serializing it for use in a Kubernetes deployment pipeline.",
      "description_length": 664,
      "index": 1337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_condition",
      "library": "kubecaml",
      "description": "This module represents the state of a Kubernetes replica set at a specific point in time, capturing fields such as `type_`, `status`, `reason`, `message`, and `last_transition_time`. It provides functions to construct, access, and serialize these state records to and from JSON using `Yojson`, enabling integration with API interactions and persistent storage. The child module organizes multiple `Replica_set_condition` values into a collection, supporting bulk serialization and deserialization of replica set states. Example uses include tracking replica set availability transitions and scaling events within cluster management workflows.",
      "description_length": 642,
      "index": 1338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes RBAC role bindings, providing functions to construct, access, and serialize the list along with its associated metadata and API version. It supports operations such as listing all role bindings in a namespace or cluster and processing them in tooling that interacts with Kubernetes RBAC policies. The primary data types include the role binding list itself, along with standard Kubernetes fields like kind and API version. The child module handles JSON serialization and deserialization of role binding lists, enabling seamless API communication and data storage.",
      "description_length": 607,
      "index": 1339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes ReplicaSet objects, combining direct access to API version, kind, metadata, and a list of ReplicaSet items with structured key-value serialization via child modules. It supports operations like listing all ReplicaSets in a namespace or decoding ReplicaSet collections from JSON API responses. The primary data types include the list of ReplicaSets and associated metadata, with key-value pairs enabling efficient lookups and serialization. Example uses include processing batch updates, inspecting cluster state, and interacting with Kubernetes list resources directly.",
      "description_length": 615,
      "index": 1340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Util.Intstr",
      "library": "kubecaml",
      "description": "This module handles values that can be either integers or strings, commonly used in Kubernetes API definitions for fields like container ports or resource limits. It provides a `make` function to construct these values from strings, along with JSON serialization and deserialization via `to_yojson` and `of_yojson`. The module also supports structured encoding and decoding of key-value pairs with `Int_or_string` values, useful for parsing Kubernetes objects like selector rules or annotations. Example uses include converting container port configurations and resource constraints to JSON for API requests.",
      "description_length": 608,
      "index": 1341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_spec",
      "library": "kubecaml",
      "description": "This module structures and manipulates horizontal pod autoscaler specifications, enabling the definition of autoscaling policies for Kubernetes deployments. It supports operations to set and retrieve core fields such as target CPU utilization, min and max replicas, and scale target references. The module also includes a child module for handling collections of named autoscaler specifications, allowing for JSON serialization and deserialization of lists of key-value pairs. For example, users can programmatically define a policy with specific replica bounds and CPU thresholds, then serialize the configuration for deployment or storage.",
      "description_length": 641,
      "index": 1342,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_status",
      "library": "kubecaml",
      "description": "This module manages the state of a cron job within a Kubernetes API context, providing functions to create and manipulate status instances with optional active job references and last schedule times. It includes accessors to retrieve these fields and integrates time values and object references to track job execution. The module supports JSON serialization and deserialization through a child module, enabling conversion of cron job status data to and from JSON for storage or transmission. Example uses include updating a cron job's last schedule time and serializing status data for API communication.",
      "description_length": 605,
      "index": 1343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Rule_with_operations",
      "library": "kubecaml",
      "description": "This module structures Kubernetes admission control rules by combining API operations and resources with optional constraints like API groups and versions. It ensures validity through helpers that enforce singleton slices for wildcards and provides accessors to extract rule components. The serialization submodule converts these rule tuples to and from JSON, enabling integration with Kubernetes API configurations. Example usage includes defining webhook policies that restrict operations on specific resource types or validating rule sets during admission controller setup.",
      "description_length": 576,
      "index": 1344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes CronJob resources across namespaces, delivering real-time event streams for creation, update, and deletion events. It provides filtering capabilities through label and field selectors, supports resource versioning, and includes limit controls for efficient tracking. Users can observe specific CronJobs for detailed lifecycle changes, such as detecting schedule modifications or failed schedules. Example use cases include triggering alerts when a CronJob fails to schedule or notifying when new CronJobs match a given selector.",
      "description_length": 560,
      "index": 1345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Component_status",
      "library": "kubecaml",
      "description": "This module manages Kubernetes component status objects, allowing creation and manipulation of structured validation data for clusters. It defines core types like `Component_status.t` and `Component_condition.t`, with operations to set metadata, kind, API version, and conditions. The child module handles lists of these statuses, enabling JSON serialization and deserialization for API interactions or state persistence. You can use it to build, update, and export component health checks as part of cluster validation workflows.",
      "description_length": 530,
      "index": 1346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Se_linux_strategy_options",
      "library": "kubecaml",
      "description": "This module defines the strategy and options for configuring SELinux policies in Kubernetes pod security contexts. It provides functions to construct and manipulate SELinux strategy options, including setting the enforcement rule and specifying SELinux options. The main data types include the strategy type and `Se_linux_options`, which is used to enforce SELinux constraints during pod deployment. A child module handles lists of these options, offering JSON serialization and management capabilities for Kubernetes extensions.",
      "description_length": 529,
      "index": 1347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Clusterroles",
      "library": "kubecaml",
      "description": "This module watches for changes to ClusterRole resources in the RBAC API, offering a `get` function to stream events with optional filtering and pagination. The `By_name` submodule extends this capability by allowing targeted watches on specific ClusterRoles by name, supporting parameters like timeout and resource version. Together, they enable real-time monitoring and selective tracking of ClusterRole updates within a Kubernetes cluster. For example, you can use `get` to list and watch ClusterRoles matching a label selector or use `By_name.get` to observe updates to a specific ClusterRole by its name.",
      "description_length": 609,
      "index": 1348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_security_policy",
      "library": "kubecaml",
      "description": "This module manages Pod Security Policies, which control the security context applied to pods and containers in a Kubernetes cluster. It provides data types for representing policies, along with operations to construct, access, and validate policy specifications, including support for metadata and API versioning. A key operation involves checking pod creation requests against defined policies to enforce container privilege restrictions and manage capabilities. The child module handles JSON serialization and deserialization of policy objects, enabling storage or transmission of policies as structured data.",
      "description_length": 612,
      "index": 1349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Downward_api_projection",
      "library": "kubecaml",
      "description": "This module structures downward API projections for Kubernetes volumes, handling lists of volume files with key-value mappings from pod and container fields. It provides operations to build, access, and serialize these projections, enabling configuration of projected volumes that expose metadata like labels or resource limits. The child module supports precise key-to-field mappings with JSON conversion, allowing validation and integration with Kubernetes APIs. Example usage includes projecting container resource requests into a volume for consumption by running pods.",
      "description_length": 573,
      "index": 1350,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress_rule",
      "library": "kubecaml",
      "description": "This module structures ingress routing by matching incoming requests to backend services based on host and path. It defines the core types for representing ingress rules, including optional host specifications and HTTP rule values that map paths to backends, along with operations to construct, inspect, and manipulate these rules. The child module extends this by organizing rules into host-to-value mappings, supporting JSON serialization and deserialization for integration with ingress controllers. Together, they enable precise traffic routing configurations, such as directing requests to \"example.com/api\" to a specific service while defaulting unmatched hosts or paths to a fallback backend.",
      "description_length": 699,
      "index": 1351,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior of a Kubernetes Deployment specification, including fields like replicas, strategy, and pod template. It provides functions to construct and access deployment configurations, such as setting the pod template, update strategy, and rollout limits. The child module represents the specification as key-value pairs with JSON serialization and deserialization support via Yojson. Together, they enable defining and modifying Deployments to control scaling, rolling updates, and rollback policies in a Kubernetes cluster.",
      "description_length": 562,
      "index": 1352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides namespace-scoped Kubernetes resource management across multiple workload types, enabling creation, retrieval, update, and deletion of ControllerRevisions, StatefulSets, DaemonSets, Deployments, and ReplicaSets. It supports core operations like `get`, `put`, `patch`, `delete`, and `list`, along with subresource interactions for status and scaling via Kubernetes API groups such as Apps V1 and Autoscaling V1. Example workflows include rolling back a deployment using ControllerRevision history, scaling a StatefulSet to adjust replica count, or patching a DaemonSet's pod template for rolling updates. The module uses typed representations like `Deployment.t`, `Stateful_set_list.t`, and `Replica_set.status` to ensure structured access to cluster state and modifications.",
      "description_length": 794,
      "index": 1353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Subject_access_review",
      "library": "kubecaml",
      "description": "This module evaluates whether a user or group has permission to perform an action in a Kubernetes cluster. It defines the SubjectAccessReview type, supporting construction, field access, and JSON conversion through functions like `make`, `user`, `resource`, and `is_allowed`. The included serialization submodule handles conversion to and from JSON, enabling transmission or storage of access review data. Use it to programmatically validate user actions, enforce policies, or audit permissions within Kubernetes.",
      "description_length": 513,
      "index": 1354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Cross_version_object_reference",
      "library": "kubecaml",
      "description": "This module provides a data structure to reference Kubernetes resources across API versions, capturing the name, kind, and optional API version. It supports constructing, accessing, and serializing these references to JSON, enabling use in custom resource definitions and multi-version controllers. The autoscaling submodule specializes this functionality for the V2beta1 API, handling string tuples and structured references for Kubernetes autoscaling resources. Together, they allow precise cross-version resource identification and seamless integration with Kubernetes tooling.",
      "description_length": 580,
      "index": 1355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale_status",
      "library": "kubecaml",
      "description": "The module represents the current state of a Kubernetes scale subresource, tracking the actual number of replicas and an optional label selector string. It provides constructors, accessors, and serialization functions to convert instances to and from JSON using Yojson. The child module extends this functionality by handling conversion of lists of scale status objects, enabling interpretation or generation of JSON data for Kubernetes API interactions. This allows inspecting replica counts, manipulating selectors, and exchanging structured scale status data with a Kubernetes cluster.",
      "description_length": 588,
      "index": 1356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Resource_metric_source",
      "library": "kubecaml",
      "description": "This module structures resource-based scaling metrics for Kubernetes, such as CPU or memory, by defining how to average pod resource usage and compare it to a target. It provides data types and operations to set and retrieve the resource name, target average utilization, and target average value, enabling precise autoscaling policies. The child module handles JSON serialization and deserialization of these metric sources, allowing integration with Kubernetes APIs. For example, it can configure an autoscaler to maintain an average CPU usage of 50% across pods in a deployment.",
      "description_length": 581,
      "index": 1357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Apiservices.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes API services by name, offering direct operations to get, put, delete, and patch resources, targeting `Api_service.t` and `Delete_options.t` types. It enables tasks like registering custom API endpoints, updating service configurations, and removing deprecated services. A child module enhances this functionality by providing a `put` operation to update the status of an API service using a predefined path template, specifically for adjusting availability or endpoints during reconfiguration. Together, they support full lifecycle management of API services within the Kubernetes aggregator layer.",
      "description_length": 629,
      "index": 1358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Daemon_set_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes daemon sets, exposing their metadata, API version, kind, and individual items. It supports creation, serialization, and deserialization of daemon set lists, with optional fields for API version and resource metadata. The module handles node-level workload management and batch updates across clusters, using key-value pairs to store daemon sets with string identifiers. It integrates with `Yojson` for JSON conversion, enabling efficient retrieval, storage, and transmission of daemon set data through the Kubernetes API.",
      "description_length": 568,
      "index": 1359,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module monitors changes to NetworkPolicy resources in Kubernetes namespaces, providing real-time visibility and reaction to policy modifications. It allows filtering by labels, fields, and resource versions, with a `get` function to fetch current states or stream updates. Developers can respond to policy creation, updates, or deletions, such as triggering security rule adjustments or logging audit events. For example, it can automatically update firewall rules when a new NetworkPolicy is applied.",
      "description_length": 506,
      "index": 1360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes API object for managing a list of cluster roles in RBAC v1beta1, providing constructors, accessors, and serialization for core fields like `api_version`, `kind`, `metadata`, and `items`. It supports operations to build, inspect, and convert cluster role lists to and from JSON using functions like `to_yojson` and `of_yojson`, enabling programmatic interaction with RBAC APIs. The module handles each cluster role entry as a tuple of a string and a structured role, facilitating structured data transfer and manipulation. Use it to list, create, or serialize cluster role configurations when working with Kubernetes RBAC systems.",
      "description_length": 665,
      "index": 1361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Runtime.Raw_extension",
      "library": "kubecaml",
      "description": "This module manages the deferred decoding of Kubernetes API objects containing raw JSON or YAML data, allowing fields to be selectively unmarshaled at runtime. It provides `to_yojson`, `of_yojson`, `make`, and `raw` functions to convert between structured and raw representations, supporting late binding of plugin types during conversion. The module handles both scalar and list-based raw extension structures, enabling precise manipulation of versioned resources like custom resource definitions with embedded, typed extensions. For example, a field in an external struct can hold raw JSON until it is converted into an internal object such as a plugin configuration or runtime.Unknown if the type is unrecognized.",
      "description_length": 716,
      "index": 1362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Replica_set_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for configuring a Kubernetes Replica Set, including fields like `replicas`, `selector`, `template`, and `min_ready_seconds`. It supports constructing, accessing, and validating Replica Set specifications to manage pod replicas declaratively. The included serialization submodule handles conversion to and from JSON, enabling integration with Kubernetes APIs and persistent configuration storage. Use this module to generate Replica Set configurations programmatically or validate deployment specs before deployment.",
      "description_length": 564,
      "index": 1363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer_configuration",
      "library": "kubecaml",
      "description": "This module manages initializer configurations for Kubernetes admission control, enabling the definition and manipulation of metadata, API versions, initializer lists, and custom logic for resource modification or validation. It provides direct operations to construct and adjust configurations, while its child module handles JSON serialization and deserialization for integration with Kubernetes admission registration APIs. Use it to implement admission controllers that inject sidecars, apply default labels, or enforce policies during resource creation. The core data types include initializer objects, versioned API resources, and structured key-value lists for JSON interactions.",
      "description_length": 686,
      "index": 1364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1.Certificate_signing_request",
      "library": "kubecaml",
      "description": "This module provides tools for creating, parsing, and working with certificate signing requests (CSRs) in a Kubernetes environment, particularly for TLS bootstrapping and authentication. It supports converting CSRs to and from JSON using Yojson, and exposes accessors for key fields like metadata, spec, and status. The child module handles JSON serialization and deserialization of CSR objects, allowing efficient conversion between raw JSON data and structured representations. You can use this module to generate a CSR, inspect its properties, and serialize it for storage or transmission.",
      "description_length": 592,
      "index": 1365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role_binding",
      "library": "kubecaml",
      "description": "This module provides tools to create and manage Role_binding objects that link subjects to roles or cluster roles within a namespace. It supports operations like binding construction, JSON conversion, and metadata access using types such as Role_binding.t, Subject.t, and Role_ref.t. The child module extends this functionality by organizing bindings into a structured list for API serialization and policy management. Together, they enable tasks like assigning user permissions in a namespace, serializing access policies, and inspecting role-subject relationships.",
      "description_length": 566,
      "index": 1366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Secret_key_selector",
      "library": "kubecaml",
      "description": "This module provides operations to select and reference specific keys within Kubernetes Secrets, centered around the data type `t` that captures a key, name, and optional presence flag. It enables precise access to secret data, such as selecting a `password` key from a `db-secrets` Secret for use in environment variables or volume mounts. The module supports constructing, accessing, and serializing these references, with child modules extending this capability to structured collections of key-value pairs. These collections facilitate bulk configuration of secure workload parameters, converting to and from JSON for Kubernetes API compatibility.",
      "description_length": 651,
      "index": 1367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module monitors Kubernetes ClusterRoleBinding resources, streaming events for all or specific role bindings with support for filtering by label and controlling watch behavior via timeout and resource version. It provides direct access to raw Kubernetes API objects like `Watch_event` and `ClusterRoleBinding`, enabling real-time tracking of access control changes across a cluster. The child module enhances this functionality by allowing fine-grained observation of individual role bindings by name, making it possible to react programmatically to updates or failures in role binding configurations. Example use cases include auditing role changes, enforcing policy compliance, or triggering access revocation workflows.",
      "description_length": 726,
      "index": 1368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Cinder_volume_source",
      "library": "kubecaml",
      "description": "This module defines a Cinder volume source for Kubernetes, enabling the configuration of persistent storage using OpenStack Cinder volumes with fields like `volume_id`, `read_only`, and `fs_type`. It includes functions to create, manipulate, and serialize volume configurations to and from JSON, supporting use cases such as deploying stateful applications like databases in Kubernetes. The child module extends this functionality by managing multiple Cinder volume sources as a list of key-value pairs, facilitating the specification of several volumes in pod definitions. Together, they enable seamless integration of OpenStack storage into Kubernetes workloads with proper serialization and configuration handling.",
      "description_length": 717,
      "index": 1369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Portworx_volume_source",
      "library": "kubecaml",
      "description": "This module represents a Portworx volume source, providing operations to construct and manipulate volume configurations using basic types like string and boolean. It supports defining storage volumes in Kubernetes pod specifications with properties such as volume ID, filesystem type, and read-only status. The child module handles JSON serialization and deserialization of these configurations, using lists of string-Portworx_volume_source.t pairs for API communication. Use cases include generating API requests for storage provisioning and parsing cluster management responses into structured data.",
      "description_length": 601,
      "index": 1370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes RBAC v1beta1 RoleBindingList, containing a list of RoleBinding objects along with metadata, kind, and API version information. It provides functions to construct, access, and serialize RoleBindingList instances, particularly for handling collections of RBAC role bindings in a Kubernetes cluster. The core data type is an associative list mapping strings to RoleBinding values, with operations for conversion to and from JSON using `Yojson.Safe` for API communication or storage. Use this module to list all role bindings in a namespace or process RBAC configurations from JSON.",
      "description_length": 614,
      "index": 1371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job",
      "library": "kubecaml",
      "description": "This module provides tools for building and managing Kubernetes cron job configurations, including setting schedules, job templates, and metadata. It supports direct manipulation of cron job specifications and status, with operations for converting configurations to and from JSON. A list of cron jobs can be handled as named key-value pairs, enabling batch processing and integration with Kubernetes APIs. Example tasks include defining a cron job with a specific schedule, updating its template, or serializing multiple jobs for storage or transmission.",
      "description_length": 555,
      "index": 1372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1.Cron_job_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior for configuring cron job specifications in Kubernetes, including scheduling parameters, concurrency policies, and job templates. It provides functions to construct and manipulate cron job specs, set retention limits for job history, and control execution timing and suspension. The child module handles collections of cron job specs, offering JSON serialization and deserialization via `to_yojson` and `of_yojson` for managing multiple configurations in JSON format. Use cases include defining scheduled batch tasks with retry constraints and automating Kubernetes job lifecycle policies.",
      "description_length": 635,
      "index": 1373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Watch.Certificatesigningrequests",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of certificate signing requests in a Kubernetes cluster, allowing clients to watch for changes and retrieve request data as it evolves. It supports watch streams with configurable parameters such as resource version, label selectors, and timeouts, and returns events for added or updated requests. The child module extends this functionality by enabling per-name tracking using the certificates v1beta1 API, with utilities like `request_path_template` for path construction. Together, they facilitate precise, dynamic monitoring of certificate signing workflows, such as tracking approval statuses of specific requests over time.",
      "description_length": 670,
      "index": 1374,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Self_subject_access_review",
      "library": "kubecaml",
      "description": "This module enables users to check if they are authorized to perform specific actions in Kubernetes, either within a particular namespace or across all namespaces. It provides data structures to define access review specifications, metadata, and status, along with operations to construct, inspect, and serialize these structures to JSON. The included serialization submodule handles conversion to and from JSON, supporting API interactions by encoding or decoding access review responses as key-value pairs. Example uses include verifying permissions for deploying resources or accessing cluster APIs before execution.",
      "description_length": 619,
      "index": 1375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim_condition",
      "library": "kubecaml",
      "description": "This module manages the condition states of Kubernetes Persistent Volume Claims, providing types and operations to represent, construct, and query conditions such as readiness, resizing, and provisioning errors. It supports direct manipulation of condition records with accessors for type, status, timestamps, and messages, along with JSON serialization and deserialization. The child module organizes these conditions into key-value collections, enabling efficient handling of multiple PVC states within cluster status reports. Example uses include parsing API responses for PVC status tracking, checking for error conditions, and serializing condition data for logging or monitoring.",
      "description_length": 685,
      "index": 1376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Replica_set_list",
      "library": "kubecaml",
      "description": "This module manages a collection of Kubernetes ReplicaSet objects, enabling construction, access, and serialization of the collection. It provides operations to manipulate API version, kind, metadata, and ReplicaSet items directly, while its child module handles JSON serialization and deserialization of ReplicaSet lists. Use this module to process batch operations or API list responses, such as converting ReplicaSet data to JSON for storage or transmitting configuration updates. Example tasks include extracting metadata from a list of ReplicaSets, updating the API version, or serializing a list of ReplicaSets for an API request.",
      "description_length": 636,
      "index": 1377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1.Replica_set",
      "library": "kubecaml",
      "description": "This module orchestrates the management of pod replicas in a Kubernetes cluster by defining ReplicaSet objects with configurable metadata, specifications, and status fields. It supports direct operations such as converting individual ReplicaSet instances to and from JSON, while its child module handles collections of ReplicaSet objects using key-value pairs, enabling bulk serialization and API interactions. Together, they facilitate defining deployment strategies, ensuring pod availability, and managing dynamic scaling across workloads. Example uses include creating ReplicaSets from configuration files, grouping identical pods under labeled sets, and programmatically adjusting replica counts via Kubernetes API integrations.",
      "description_length": 733,
      "index": 1378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Cron_job",
      "library": "kubecaml",
      "description": "This module provides a structured representation of Kubernetes CronJob resources, enabling the creation, manipulation, and serialization of cron job configurations using types like `t`, `Cron_job_spec`, and `Object_meta`. It supports operations such as setting metadata, defining schedules, and inspecting status fields, allowing users to programmatically generate or analyze CronJob manifests. The module also includes a submodule for managing collections of named cron jobs, facilitating batch processing and JSON serialization of multiple configurations. Example uses include building deployment-ready CronJob definitions, parsing existing configurations from JSON, and modifying schedules or job templates programmatically.",
      "description_length": 727,
      "index": 1379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch.Networkpolicies",
      "library": "kubecaml",
      "description": "This module watches for changes to NetworkPolicy resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific NetworkPolicy resource, supporting parameters like `watch`, `timeout_seconds`, and `label_selector` to filter and control the event stream. Use it to monitor real-time updates to network policies, such as tracking when new policies are applied or existing ones are modified.",
      "description_length": 419,
      "index": 1380,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Pod_disruption_budget",
      "library": "kubecaml",
      "description": "This module manages PodDisruptionBudget objects, enforcing constraints on pod disruptions in a Kubernetes cluster. It allows constructing, serializing, and accessing fields like metadata, spec, and status to control disruption tolerance policies. The child module handles JSON serialization and deserialization of these objects, supporting persistence and transmission of policy configurations. Example use cases include ensuring high availability during rolling updates by limiting concurrent pod disruptions.",
      "description_length": 510,
      "index": 1381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch.Statefulsets",
      "library": "kubecaml",
      "description": "This module watches for changes to StatefulSet resources in a Kubernetes cluster. It provides a `get` function to stream events based on resource version, label selectors, and field selectors, returning typed watch events or error messages. Use it to monitor StatefulSet updates in real time, such as tracking rollouts or observing scaling events.",
      "description_length": 347,
      "index": 1382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_list",
      "library": "kubecaml",
      "description": "This module manages collections of Kubernetes Pod objects, providing constructors, accessors, and JSON serialization for pod lists, including metadata, API version, and kind fields. It supports parsing and generating JSON representations of pod lists, enabling interaction with Kubernetes API servers or configuration files. The child module enhances this functionality by handling structured key-value pair representations of pods, where each key maps to a Pod specification. Together, they allow operations like retrieving a list of pods from an API response, modifying their specifications, or serializing them into JSON for storage or transmission.",
      "description_length": 652,
      "index": 1383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1.Token_review",
      "library": "kubecaml",
      "description": "This module represents and processes token review requests in Kubernetes authentication, providing data structures and operations to construct, serialize, and inspect token reviews. It includes types for token specifications, metadata, and authentication results, along with functions to convert between JSON representations, particularly for use in webhook token authenticators. The module handles lists of string and token review type pairs, enabling efficient processing of multiple authentication requests. Example uses include validating user identities during API server integration and caching token review responses in webhook plugins.",
      "description_length": 643,
      "index": 1384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1.Initializerconfigurations.By_name",
      "library": "kubecaml",
      "description": "This module implements RESTful operations for managing Kubernetes InitializerConfiguration resources by name, supporting get, put, delete, and patch methods. It works with Initializer_configuration and Delete_options data types, using Cohttp for HTTP transport. Concrete use cases include retrieving, updating, deleting, or patching specific InitializerConfiguration objects within a Kubernetes cluster.",
      "description_length": 403,
      "index": 1385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Watch.Apiservices",
      "library": "kubecaml",
      "description": "This module enables real-time observation of Kubernetes API service resources, offering a `get` function to establish a watch stream with parameters like resource version, label selectors, and timeouts. It returns events as they occur, supporting dynamic tracking of additions or removals of API services in a cluster. The child module extends this functionality by allowing per-name monitoring of API services, using `Watch_event.t` values to represent changes tied to specific `Api_service` resources. Together, they facilitate precise, real-time updates for both broad collections and individual API services.",
      "description_length": 612,
      "index": 1386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ingress",
      "library": "kubecaml",
      "description": "This module provides core functionality for working with Kubernetes Ingress resources, enabling the creation, manipulation, and serialization of ingress configurations that define routing rules, TLS settings, and virtual hosts. It includes support for constructing ingress objects with metadata, spec, and status fields, and converting them to JSON for API interaction. The child module handles lists of ingress rules, mapping identifiers to configurations and supporting JSON (de)serialization via Yojson for external representation. Together, they allow developers to programmatically manage ingress definitions, such as setting up HTTP routes to backend services or configuring SSL termination in a cluster.",
      "description_length": 710,
      "index": 1387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_account_list",
      "library": "kubecaml",
      "description": "This module represents a list of Kubernetes ServiceAccount objects with fields for API version, kind, metadata, and items. It includes functions to construct, access, and serialize the list to and from JSON using `to_yojson` and `of_yojson`. You can use it to manage multiple ServiceAccount resources, such as listing all service accounts in a namespace or converting service account data to JSON for API interactions. The serialization submodule handles conversion of service account lists to and from JSON, supporting key-value pair representations.",
      "description_length": 551,
      "index": 1388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1.Watch.Volumeattachments",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of VolumeAttachment resources in Kubernetes, offering a `get` function to stream updates based on label and field selectors, resource version, and uninitialized resource flags. It supports tracking when storage volumes are attached or detached from nodes, providing structured access to watch events for dynamic cluster management. The child module extends this functionality by allowing name-based retrieval and watch operations with custom timeouts and filtering, making it possible to observe lifecycle changes of specific VolumeAttachment objects in detail. Together, they facilitate precise, event-driven handling of storage attachment events within a Kubernetes cluster.",
      "description_length": 717,
      "index": 1389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes workload resources across namespaces, focusing on Deployments, ControllerRevisions, DaemonSets, ReplicaSets, and StatefulSets. It offers data types representing resource events and supports operations like filtered watches, resource versioning, and event stream capture. Users can observe Deployment rollouts, DaemonSet lifecycle events, or StatefulSet configuration changes with label and field selectors for precise tracking. Specific examples include alerting on ReplicaSet scaling or inspecting ControllerRevision updates as they happen.",
      "description_length": 596,
      "index": 1390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_name.Status",
      "library": "kubecaml",
      "description": "This module handles retrieving, replacing, and partially updating the status of Kubernetes namespaces by name. It operates on `Namespace.t` and `Patch.t` data types, interacting directly with the Kubernetes API via HTTP requests. Concrete use cases include checking the current status of a namespace, updating its state entirely, or applying a strategic merge or JSON patch to its status.",
      "description_length": 388,
      "index": 1391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Daemon_set_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior for configuring Kubernetes DaemonSet specifications, including pod templates, label selectors, update strategies, and rollout parameters. It provides data types like `t`, `Daemon_set_update_strategy.t`, and `Pod_template_spec.t`, along with operations to construct, manipulate, and serialize DaemonSet configurations. The child module handles lists of key-value pairs mapping names to DaemonSet specs, offering `to_yojson` and `of_yojson` for JSON serialization and parsing, enabling interaction with Kubernetes API endpoints. Use cases include deploying DaemonSets, retrieving rollout settings, and managing multiple DaemonSet specs in JSON format.",
      "description_length": 696,
      "index": 1392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Exec_action",
      "library": "kubecaml",
      "description": "This module represents commands executed directly within a container, typically for liveness or readiness probes, and includes functions to construct, access, and serialize these actions to and from JSON. It supports defining container health checks without relying on external scripts, enabling integration with Kubernetes pod definitions. The module includes a child module that organizes named `Exec_action` definitions, providing JSON serialization through `to_yojson` and `of_yojson` for managing execution policies in pod specs. Example usage includes specifying a command like `[\"cat\", \"/tmp/healthy\"]` to be run inside a container to determine its health status.",
      "description_length": 670,
      "index": 1393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Scale",
      "library": "kubecaml",
      "description": "This module represents scaling requests for resources, providing operations to create, serialize, and access Kubernetes scale objects with fields such as `api_version`, `kind`, `metadata`, `spec`, and `status`. It includes custom types for scale specifications and statuses, enabling tasks like generating replica scaling requests and parsing API responses. The child module extends this functionality by handling collections of scaling requests as key-value pairs, supporting batch operations and JSON serialization via `Yojson.Safe.t`. Together, they facilitate managing individual and grouped scaling operations in Kubernetes autoscaling workflows.",
      "description_length": 651,
      "index": 1394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Quobyte_volume_source",
      "library": "kubecaml",
      "description": "This module defines a Quobyte volume source for Kubernetes pods, allowing configuration of volume mounts with fields like volume name, registry addresses, user and group mappings, and read-only flags. It includes functions to construct and access these configurations directly, as well as a child module for handling lists of Quobyte volume sources in JSON format. Use it to specify durable Quobyte storage in pod definitions, ensuring correct mounting across the pod's lifecycle through both direct API manipulation and JSON serialization.",
      "description_length": 540,
      "index": 1395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set",
      "library": "kubecaml",
      "description": "This module provides tools for creating, modifying, and analyzing stateful sets, ensuring stable network and storage identities for pods. It supports defining pod specifications, metadata, and storage claims, with direct operations to convert to and from JSON, set labels, and inspect status fields. The child module handles JSON serialization, enabling parsing and generation of stateful set configurations from key-value lists. You can define a database cluster with persistent storage, serialize it to JSON for storage, and later deserialize and inspect its structure programmatically.",
      "description_length": 588,
      "index": 1396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling.V1alpha1.Priority_class_list",
      "library": "kubecaml",
      "description": "This module manages a list of Kubernetes priority classes, enabling construction and manipulation of collections with operations to set and retrieve metadata, API version, and kind. It pairs string keys with priority class structures, supporting JSON serialization and deserialization for interaction with Kubernetes APIs or configuration storage. Use it to organize and process batched priority class resources in scheduling configurations, handling both in-memory representations and external data exchange.",
      "description_length": 509,
      "index": 1397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_port",
      "library": "kubecaml",
      "description": "This module manages service port configurations in Kubernetes, enabling the definition and manipulation of ports, protocols, and target ports. It supports structured data transformations, including JSON serialization and deserialization through a child module that processes lists of named service port tuples. Main data types include port definitions with numeric, protocol, and target port fields, while operations allow for constructing, modifying, and converting service port configurations. Examples include mapping container ports to service ports, configuring NodePort exposure, and converting service port data to JSON for storage or transmission.",
      "description_length": 655,
      "index": 1398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1.Subject_rules_review_status",
      "library": "kubecaml",
      "description": "This module captures the outcome of a Kubernetes authorization rules check, representing resource and non-resource permissions granted to a subject. It includes constructors, accessors, and JSON serialization for handling rule evaluation results, allowing inspection or construction of authorization decisions. A child module supports converting lists of rule review statuses to and from JSON, facilitating integration with Kubernetes APIs. Use this module to analyze effective permissions or build tools that process authorization results.",
      "description_length": 540,
      "index": 1399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Deployment",
      "library": "kubecaml",
      "description": "This module handles the deprecated Kubernetes Deployment resource, allowing construction, serialization, and manipulation of Deployment objects for older clusters using the apps/v1beta2 API. It provides core data types like Deployment_spec, Deployment_status, and Object_meta, along with functions to create and modify Deployment manifests. The child module manages collections of Deployments paired with identifiers, supporting JSON conversion for configuration and serialization workflows. Use cases include maintaining compatibility with legacy Kubernetes setups and working with Deployment lists in structured formats.",
      "description_length": 622,
      "index": 1400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Service_status",
      "library": "kubecaml",
      "description": "This module represents the runtime state of a Kubernetes service, focusing on load balancer presence and configuration. It provides a core data type for service status with operations to create and access optional load balancer status information. The child module handles JSON serialization and deserialization of service statuses, enabling data conversion for API interaction or logging. Together, they support constructing, inspecting, and transmitting service state information in both native and JSON formats.",
      "description_length": 514,
      "index": 1401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Flocker_volume_source",
      "library": "kubecaml",
      "description": "This module configures Flocker volume sources for Kubernetes, allowing creation and manipulation of volume objects using either a dataset name or UUID. It ensures only one identifier is set and supports JSON serialization and deserialization for integration with Kubernetes pod specifications. The child module handles conversion to and from JSON, working with lists of key-value pairs where each value defines a Flocker volume source. Together, they enable mounting Flocker volumes in Kubernetes by referencing datasets via name or UUID.",
      "description_length": 538,
      "index": 1402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1.Cluster_role_binding",
      "library": "kubecaml",
      "description": "This module provides operations for creating and managing ClusterRoleBinding objects in the RBAC v1beta1 API, linking cluster roles to subjects such as users, groups, or service accounts. It supports setting and retrieving role references, subjects, and metadata, enabling fine-grained access control in Kubernetes. The child module handles lists of these bindings, offering JSON serialization and deserialization via Yojson for storage or transmission. Together, they allow you to define, manipulate, and persist cluster-level RBAC policies programmatically.",
      "description_length": 559,
      "index": 1403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Event_source",
      "library": "kubecaml",
      "description": "This module represents structured data for Kubernetes event sources, providing a data structure with optional fields for component and host information. It includes functions to construct, access, and serialize event sources to and from JSON using Yojson. Use this module to capture or interpret the origin of Kubernetes events, such as identifying which node or system component triggered an event. It also supports mapping string keys to event sources, enabling integration with Kubernetes API payloads.",
      "description_length": 505,
      "index": 1404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1.Role",
      "library": "kubecaml",
      "description": "This module defines a Role in the RBAC API as a logical grouping of policy rules within a namespace, providing constructors, accessors, and serialization for role metadata, API version, kind, and rules. It supports creating and manipulating Kubernetes authorization policies programmatically. The child module manages collections of Role objects, enabling JSON serialization and deserialization of multiple roles as a list of (string * Role) tuples. Together, they facilitate structured RBAC role management and configuration in Kubernetes systems.",
      "description_length": 548,
      "index": 1405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_port",
      "library": "kubecaml",
      "description": "This module defines and manipulates network policy port specifications, combining direct operations for creating and accessing port configurations with JSON serialization support from its child module. The main data types include the network policy port type, which captures protocol and port number or name, and a list of tuples for JSON conversion. You can define allowed ports and protocols for Kubernetes network traffic rules, and serialize them for API communication or storage. The child module handles JSON conversion, enabling structured data interchange while maintaining type integrity.",
      "description_length": 597,
      "index": 1406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1.Validating_webhook_configuration_list",
      "library": "kubecaml",
      "description": "This module manages lists of validating webhook configurations in Kubernetes, providing direct access to fields like `api_version`, `kind`, `metadata`, and `items`. It supports constructing and serializing these lists, with child modules handling JSON conversion for storage or transmission. Operations include building configuration lists, extracting metadata, and converting to and from JSON representations. Use it to manage, persist, or exchange collections of validating webhooks in an admission controller workflow.",
      "description_length": 521,
      "index": 1407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Horizontal_pod_autoscaler_status",
      "library": "kubecaml",
      "description": "This module manages the runtime state of a horizontal pod autoscaler by defining data structures and operations to track metrics like desired and current replicas, CPU utilization, and timestamps. It supports creating, updating, and serializing status objects to JSON for interaction with Kubernetes APIs. The child module maps string keys to status values, enabling dynamic handling of API responses and requests. For example, you can decode a JSON status response from Kubernetes, adjust the current replica count, and re-encode it for an update request.",
      "description_length": 556,
      "index": 1408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1.Volumeattachments.By_name",
      "library": "kubecaml",
      "description": "This module implements REST operations for managing Kubernetes VolumeAttachment resources by name. It supports get, put, delete, and patch methods to retrieve, create or update, remove, and modify VolumeAttachment objects in a Kubernetes cluster. The module works directly with VolumeAttachment definitions and standard Kubernetes delete and patch options.",
      "description_length": 356,
      "index": 1409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_affinity",
      "library": "kubecaml",
      "description": "This module organizes node affinity rules into labeled key-value mappings, enabling precise Kubernetes pod scheduling based on node attributes. It supports creating, serializing, and applying both required and preferred constraints using types like `Node_selector` and `Preferred_scheduling_term`. For example, it can enforce that a pod only runs on nodes with `\"gpu=true\"` or prefer nodes with `\"ssd=true\"` for faster disk access. The module's API and JSON handling make it suitable for integration into deployment pipelines and cluster management tools.",
      "description_length": 555,
      "index": 1410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Host_port_range",
      "library": "kubecaml",
      "description": "This module represents a range of host ports defined by inclusive start and end values, used to enforce allowed port allocations for pods in Kubernetes policies. It provides constructors, accessors, and validation to ensure proper port range usage, such as specifying that a pod can expose a container port on a node's port 80 to 85. The child module handles JSON serialization and deserialization of these ranges, allowing policy configurations to be stored and retrieved in formats like JSON, using key-range pairs for structured definitions. Together, they enable precise control and persistence of host port policies in cluster configurations.",
      "description_length": 647,
      "index": 1411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Endpoint_port",
      "library": "kubecaml",
      "description": "This module represents a single network port in a Kubernetes endpoint, with fields for name, port number, and protocol. It provides constructors, accessors, and serialization functions to convert port data to and from JSON, enabling integration with API interactions and configuration storage. The child module extends this functionality by handling structured conversion of port collections, allowing efficient marshaling of multiple ports for service discovery and network setup. Example uses include defining endpoint ports for Kubernetes services and serializing them into JSON for API requests or configuration files.",
      "description_length": 622,
      "index": 1412,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Replication_controller_status",
      "library": "kubecaml",
      "description": "This module tracks the status of replication controllers in Kubernetes, providing key metrics like `replicas`, `ready_replicas`, and `conditions` to reflect current state. It supports creating and accessing these status records directly, while its child module handles JSON serialization and deserialization of multiple status entries using key-value pairs. Use it to monitor controller health, verify replica counts, and exchange status data with Kubernetes APIs in JSON format.",
      "description_length": 479,
      "index": 1413,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_peer",
      "library": "kubecaml",
      "description": "This module represents a deprecated Kubernetes network policy peer specification, used to define network policy rules targeting pods, namespaces, or IP blocks in extensions v1beta1. It provides constructors and accessors for key fields like pod selector, namespace selector, and IP block, enabling precise rule definitions for ingress or egress policies. The included submodule handles JSON serialization and deserialization of these peer specifications, converting configurations to and from JSON for storage or transmission. Use this to build and manipulate network policy rules before migrating to the newer networking/v1 version.",
      "description_length": 633,
      "index": 1414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Taint",
      "library": "kubecaml",
      "description": "This module manages taints applied to Kubernetes nodes, controlling pod scheduling by enforcing constraints based on key, effect, and optional value or time fields. It includes operations to construct, access, and manipulate individual taints, as well as a submodule for handling collections of taints, enabling serialization and deserialization via Yojson. The combined functionality supports use cases like isolating pods on nodes with specific hardware or labels, ensuring only compatible pods are scheduled. Direct API functions allow precise taint creation and inspection, while the submodule facilitates structured storage and transmission of node taint configurations.",
      "description_length": 675,
      "index": 1415,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Events",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Event resources within a specific namespace, offering operations to list events, create new ones, and delete existing collections using parameterized HTTP requests. It directly handles Event and Event_list data types, with support for custom query parameters and headers. The child module extends this functionality by enabling fine-grained management of individual events by name, supporting get, put, delete, and patch operations with Delete_options and Event types. Together, they allow tasks like retrieving event logs, updating event metadata, and selectively removing or modifying specific events within a namespace.",
      "description_length": 653,
      "index": 1416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Secrets",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Secret resources within a namespace, offering operations to list, create, and delete secrets with support for filtering, watching, and customizing API requests. It works directly with Kubernetes-native Secret and Status types, enabling integration with cluster configuration and secret management workflows. The child module provides fine-grained CRUD access using `get`, `put`, `delete`, and `patch` functions over Cohttp, allowing precise manipulation of secrets and control structures like Delete_options and Patch. Together, they support tasks such as automating secret deployment, monitoring secret changes, and applying selective updates in a Kubernetes cluster.",
      "description_length": 699,
      "index": 1417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module streams ClusterRoleBinding events from the RBAC API, supporting filters like resource version and label selectors. It offers a `get` function to monitor changes in real time, returning a result with a `Watch_event`. The `By_name` submodule enhances this by allowing targeted watches on specific ClusterRoleBindings, enabling precise tracking of role binding updates for audit or sync operations. Together, they support use cases like real-time permission monitoring and reconciliation workflows.",
      "description_length": 507,
      "index": 1418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Namespace",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes namespace objects within a structured scope, enabling the creation, manipulation, and serialization of individual namespaces and collections. It defines core operations for building and modifying namespace metadata, spec, and status, along with direct support for JSON conversion via Yojson. The module also includes a submodule for managing multiple namespaces as a key-value map, facilitating bulk operations and persistence. Example uses include generating namespace configurations for deployment, extracting status information for monitoring, and storing serialized namespace states for later restoration.",
      "description_length": 642,
      "index": 1419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Host_path_volume_source",
      "library": "kubecaml",
      "description": "This module configures host path volumes for Kubernetes pods by mapping host directories into containers, supporting direct access to host filesystem paths for use cases like persistent storage or file sharing. It provides constructors, accessors, and serializers for host path volume sources, including fields for the path and optional type. The JSON submodule handles conversion to and from JSON, enabling persistence and parsing of volume configurations in pod specs. You can create a volume source pointing to `/var/log`, serialize it to JSON, and later deserialize it back into a configuration.",
      "description_length": 599,
      "index": 1420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1.Job_template_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and behavior for creating Kubernetes Jobs from templates, including metadata and job specification fields. It provides constructors to build template specifications and accessors to retrieve their components, along with JSON serialization and deserialization capabilities via the Yojson library. The JSON submodule handles conversion of template data to and from JSON, supporting storage or API transmission. Example uses include constructing a job template with optional labels and converting it to JSON for Kubernetes API submission.",
      "description_length": 569,
      "index": 1421,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_spec",
      "library": "kubecaml",
      "description": "This module defines the configuration attributes for creating nodes in a Kubernetes cluster, including optional settings like taints, pod CIDR, provider ID, and unschedulability. It provides functions to construct node specifications, access individual properties, and convert to and from JSON. A related submodule handles collections of node specifications keyed by string identifiers, supporting structured configuration management through JSON serialization. Use cases include defining node behavior for provisioning, setting taints to control scheduling, and managing pod network ranges across multiple nodes.",
      "description_length": 613,
      "index": 1422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Version.Info",
      "library": "kubecaml",
      "description": "This module captures and manages version metadata, such as build date, Git commit, and Go version, with support for constructing, accessing, and serializing version info objects. It includes functions to convert these objects to and from JSON using Yojson, enabling structured storage or transmission of version details. The child module extends this capability by handling list-based JSON serialization, where each entry pairs a string key with a version info value. Together, they allow tools to programmatically inspect, encode, and expose detailed version data for Kubernetes components.",
      "description_length": 591,
      "index": 1423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Storage_class_list",
      "library": "kubecaml",
      "description": "This module represents a list of storage class entries in a Kubernetes API response, providing access to items, metadata, kind, and API version fields. It supports creating instances with optional metadata and version information, and converting to and from JSON using functions like `to_yojson` and `of_yojson`. Each entry is a tuple of a string and a storage class structure, allowing structured access to both names and configurations. It is used when retrieving or managing multiple storage classes through Kubernetes API endpoints that handle JSON-formatted lists.",
      "description_length": 569,
      "index": 1424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Ip_block",
      "library": "kubecaml",
      "description": "This module provides functionality for defining and managing IP block rules used in Kubernetes network policies, allowing the specification of CIDR ranges and optional exclusions. It includes operations to create, validate, and manipulate IP blocks, ensuring they conform to required formats, and supports serialization and deserialization to JSON for integration with policy definitions. The child module handles collections of IP blocks paired with keys, enabling structured configuration of network policy rules that control traffic based on allowed or excluded IP ranges. Example usage includes defining a \"192.168.1.0/24\" block with exceptions like \"192.168.1.100/32\" to restrict access selectively within a cluster.",
      "description_length": 721,
      "index": 1425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1.Initializer",
      "library": "kubecaml",
      "description": "This module manages initializer configurations for Kubernetes admission registration, handling the name, failure policy, and resource rules that determine when an initializer is applied. It provides data types for representing initializers and operations for constructing, serializing, and deserializing them, often working with Kubernetes API objects like `Rule`. The child module supports converting initializer configurations to and from JSON, enabling structured API interactions. Example uses include defining initializer logic for admission control webhooks and managing initializer settings across different system components.",
      "description_length": 633,
      "index": 1426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Scale_io_persistent_volume_source",
      "library": "kubecaml",
      "description": "This module represents a persistent ScaleIO volume source for Kubernetes, enabling the construction and manipulation of volume configurations using strings, booleans, and `Secret_reference` values. It supports defining connection parameters such as gateway, system name, storage pool, protection domain, and SSL settings for Kubernetes persistent volumes. The module includes functions to serialize and deserialize these configurations to and from JSON, using key-value pairs for conversion to and from typed OCaml structures. This allows for both programmatic configuration and interchange with external systems using JSON-encoded volume specs.",
      "description_length": 645,
      "index": 1427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling.V1alpha1.Priority_class",
      "library": "kubecaml",
      "description": "This module organizes priority classes by name and numeric value, supporting creation, access, and JSON conversion for Kubernetes scheduling configuration. It handles metadata, description, and default status alongside priority integers, enabling structured management of scheduling tiers. The child module processes lists of named priority classes, converting them to and from JSON for persistence or communication. Together, they allow defining, serializing, and exchanging priority class data with precise control over scheduling behavior.",
      "description_length": 542,
      "index": 1428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_binding_list",
      "library": "kubecaml",
      "description": "This module represents a Kubernetes list resource containing multiple `ClusterRoleBinding` objects, with fields like `apiVersion`, `kind`, `metadata`, and `items`. It provides operations to construct, access, and serialize these lists, enabling management of RBAC configurations and policy audits. The child module handles JSON serialization and deserialization of cluster role binding lists, working with tuples of strings and `Cluster_role_binding_list.t` values for API interactions or data storage. Use this module to programmatically manipulate and persist collections of cluster role bindings.",
      "description_length": 599,
      "index": 1429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Node_list",
      "library": "kubecaml",
      "description": "This module manages a collection of registered Kubernetes nodes, offering functions to construct, access, and manipulate node lists with metadata, kind, and API version information. It supports JSON serialization and deserialization of node data, both directly and through its child module that organizes nodes as key-value pairs for structured storage and transmission. Operations include tracking node registration status, managing cluster inventory, and interfacing with Kubernetes control plane components using concrete data formats like Yojson. Example uses include parsing Kubernetes API responses into typed node lists and converting local node data to JSON for persistence or communication.",
      "description_length": 699,
      "index": 1430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1.Resource_rule",
      "library": "kubecaml",
      "description": "This module defines and manipulates authorization rules for Kubernetes API resources, specifying allowed verbs, resources, resource names, and API groups. It supports creating, serializing, and accessing rule fields, with special handling for wildcards and subresources, enabling fine-grained access control policies such as read-only access to specific services or full access to all resources in a group. The child module handles collections of these rules, providing JSON serialization and deserialization via `Yojson` for direct interaction with Kubernetes RBAC policies. Together, they allow constructing, modifying, and exchanging structured authorization rules with cluster APIs.",
      "description_length": 686,
      "index": 1431,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Network_policy_port",
      "library": "kubecaml",
      "description": "This module defines and manipulates network policy port specifications, including protocol and port number or name. It supports creating, accessing, and serializing port configurations for Kubernetes network policies. The main data types include port definitions with optional protocol and port identifiers, while operations allow for constructing and converting these definitions. A child module handles JSON serialization, converting between tuples of names and port definitions and their JSON representation for API use.",
      "description_length": 523,
      "index": 1432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_claim",
      "library": "kubecaml",
      "description": "This module provides tools to construct, manipulate, and serialize persistent volume claim configurations for Kubernetes clusters. It supports key data types such as `Object_meta`, `Persistent_volume_claim_spec`, and `Persistent_volume_claim_status`, allowing users to define and modify claims programmatically. The module includes operations to set metadata, configure storage specifications, and inspect claim status, with child modules enabling JSON serialization and deserialization. Example use cases include generating claim configurations for deployment or converting existing Kubernetes claims to JSON for storage or API interaction.",
      "description_length": 641,
      "index": 1433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1.Fs_group_strategy_options",
      "library": "kubecaml",
      "description": "This module defines filesystem group strategy configurations for Kubernetes security policies, including strategy rules and allowed ID ranges. It provides functions to construct, serialize, and extract these configurations, enabling enforcement of filesystem group constraints in pod security contexts. The child module represents a list of key-value pairs where each value is a strategy configuration, supporting JSON conversion via Yojson for use in policy definitions. Example uses include defining allowed group IDs and selection rules to control filesystem access in Kubernetes workloads.",
      "description_length": 593,
      "index": 1434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_affinity_term",
      "library": "kubecaml",
      "description": "This module defines pod affinity terms that specify co-location constraints based on node labels and pod selectors. It provides operations to construct and access fields like `topology_key`, `namespaces`, and `label_selector`, enabling precise control over Kubernetes pod scheduling. The child module extends this functionality by grouping multiple affinity terms and supporting JSON serialization for integration with configuration systems. Together, they allow defining and managing complex scheduling policies that ensure pods run on the same or different nodes based on label matches.",
      "description_length": 588,
      "index": 1435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace.Persistentvolumeclaims",
      "library": "kubecaml",
      "description": "This module manages Kubernetes PersistentVolumeClaims within a namespace, supporting REST operations like list, create, and delete via HTTP requests with customizable parameters and headers. It operates on Kubernetes API v1 objects such as `Persistent_volume_claim`, `Persistent_volume_claim_list`, and `Status`, enabling precise control over storage resources. The status submodule allows retrieval and modification of claim statuses through replacement or partial updates. Example uses include automating claim provisioning, inspecting claim states, and updating claim status independently of their full resource representation.",
      "description_length": 630,
      "index": 1436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Pod_security_policy_list",
      "library": "kubecaml",
      "description": "This module manages Pod Security Policy List objects in Kubernetes, enabling construction, serialization, and field access for structured lists containing metadata, API version, kind, and individual Pod Security Policy entries. It provides direct operations to build and manipulate these lists, while its child module handles JSON conversion using `to_yojson` and `of_yojson` for integration with Kubernetes API endpoints. You can create a list, add policies, and serialize it to JSON for submission to the Kubernetes API or deserialize a JSON response into a list for inspection and modification.",
      "description_length": 597,
      "index": 1437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1.Network_policy_peer",
      "library": "kubecaml",
      "description": "This module defines network policy peer specifications for Kubernetes, enabling precise traffic control based on IP blocks, namespace selectors, or pod selectors. It ensures only one selection method is active and provides constructors and accessors for building and inspecting these policies. The included submodule handles JSON (de)serialization, supporting structured configuration of allowed traffic sources in Kubernetes network policies. For example, you can define a peer that allows traffic from a specific IP range or from pods matching a label selector in a particular namespace.",
      "description_length": 589,
      "index": 1438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1.Cross_version_object_reference",
      "library": "kubecaml",
      "description": "This module represents cross-version object references in Kubernetes, enabling identification of resources across API versions through structured data. It defines a type `t` with operations to construct and deconstruct references using name, kind, and optional API version fields. The module supports direct manipulation of references and includes serialization functions for converting them to and from JSON. For example, it can create a reference to a resource in an autoscaling configuration and serialize it for storage or transmission.",
      "description_length": 540,
      "index": 1439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Resource_metric_status",
      "library": "kubecaml",
      "description": "This module captures the current state of Kubernetes resource metrics like CPU or memory usage for autoscaling, offering constructors and accessors for raw and percentage-based averages across pods. It includes a child module for handling collections of these metric statuses as key-value pairs, enabling structured serialization and deserialization to and from JSON. Use it to inspect or build horizontal pod autoscaler status data based on built-in Kubernetes resource metrics. Example operations include retrieving average memory usage or constructing CPU utilization thresholds for scaling decisions.",
      "description_length": 604,
      "index": 1440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map",
      "library": "kubecaml",
      "description": "This module manages configuration data for Kubernetes pods by providing functions to create and manipulate Config_map objects, including setting metadata, API version, kind, and key-value pairs in string or binary form. It supports validation and versioning for deployment in Kubernetes clusters, while its child module handles collections of named ConfigMap objects, enabling serialization and deserialization to JSON via Yojson. Use this module to construct individual Config_map instances or manage multiple configurations as a list of key-value pairs. Example uses include defining environment settings for pods or storing configuration files as binary data within a Config_map.",
      "description_length": 682,
      "index": 1441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Pod_dns_config_option",
      "library": "kubecaml",
      "description": "This module defines DNS resolver options for Kubernetes pods, handling configuration parameters like `name` and `value` to customize DNS behavior. It supports constructing, accessing, and serializing DNS config objects, enabling settings such as `ndots` and `timeout` in pod specifications. The child module maps string keys to DNS option values and provides JSON serialization via `to_yojson` and `of_yojson`. Together, they allow precise control over DNS resolver behavior in pod configurations, such as tuning timeouts or setting search domains.",
      "description_length": 548,
      "index": 1442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Host_port_range",
      "library": "kubecaml",
      "description": "This module represents a range of host ports with inclusive integer bounds, used to define allowed port ranges in Kubernetes policies. It provides constructors, accessors for min and max values, and JSON serialization support through the child module, which handles conversion to and from JSON for lists of port range key-value pairs. Use it to enforce port restrictions in Kubernetes extension APIs by defining valid port ranges and serializing them for policy enforcement.",
      "description_length": 474,
      "index": 1443,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Policy_rule",
      "library": "kubecaml",
      "description": "This module defines a policy rule structure used to specify access control permissions in Kubernetes RBAC configurations. It includes functions to construct and manipulate policy rules with fields like verbs, resources, and API groups, and supports serialization to and from JSON. A child module extends this functionality by organizing policy rules into a collection indexed by string keys, enabling programmatic management and integration with Kubernetes API clients. Example uses include defining precise access policies for cluster roles and serializing them for storage or transmission.",
      "description_length": 591,
      "index": 1444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1.Watch.Storageclasses",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring and retrieval of Kubernetes storage class resources through HTTP-based watch operations, supporting label and field selectors, resource version control, and timeout management. It enables tracking changes to storage classes dynamically, such as detecting updates to provisioner configurations or access modes, and retrieving current or historical states of specific storage classes. The child module extends this by allowing direct lookup by name and streaming updates, facilitating precise, targeted observation of storage class events. Together, they support use cases like dynamic storage provisioning and cluster-wide storage policy enforcement.",
      "description_length": 691,
      "index": 1445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2.Stateful_set_status",
      "library": "kubecaml",
      "description": "This module captures the runtime state of a Kubernetes StatefulSet, providing fields like `replicas`, `ready_replicas`, `current_revision`, and `update_revision` to track deployment progress and health. It supports operations to construct, inspect, and update these state values based on observed cluster conditions. The child module handles JSON encoding and decoding of StatefulSet status data, enabling serialization for storage or transmission and deserialization for inspection. Together, they allow precise management and persistence of StatefulSet rollout states, such as determining readiness or tracking revision changes during updates.",
      "description_length": 645,
      "index": 1446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1.Cluster_role_binding",
      "library": "kubecaml",
      "description": "This module provides tools to create, manipulate, and serialize Kubernetes RBAC ClusterRoleBinding objects that link a ClusterRole to users, groups, or service accounts across the cluster. It supports direct operations such as setting role references, adding subjects, and converting to and from JSON, while its child module manages collections of bindings as string-ClusterRoleBinding pairs, enabling bulk serialization and configuration. You can use it to define cluster-wide role bindings for service accounts in different namespaces or map external user groups to cluster roles. The main data types include the ClusterRoleBinding structure and a list of labeled bindings used for grouping or API interactions.",
      "description_length": 713,
      "index": 1447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for managing Kubernetes CronJob resources within a namespace using HTTP operations. It supports listing, creating, and deleting CronJobs, with additional capabilities for replacing, partially updating, and modifying job status through strategic patches. Key data types include `Cron_job.t` for job definitions and `Patch.t` for partial updates, enabling precise control over job configuration and execution state. Specific operations allow filtering job lists, submitting new job specifications, updating existing jobs, and adjusting runtime status information directly via API interactions.",
      "description_length": 638,
      "index": 1448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1.Deployment_rollback",
      "library": "kubecaml",
      "description": "This module represents Kubernetes deployment rollbacks with structured data, capturing deployment names, target revisions, and annotations. It provides constructors, accessors, and serialization for rollback configurations, enabling precise control over deployment history. The included JSON module converts rollback data to and from JSON, supporting storage or API transmission. Use this module to implement rollback features in Kubernetes tooling by programmatically reverting deployments or exporting rollback instructions.",
      "description_length": 526,
      "index": 1449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Object_reference",
      "library": "kubecaml",
      "description": "This module provides a type-safe way to construct, inspect, and manipulate references to Kubernetes objects using identifiers like kind, name, namespace, and UID. It includes functions to serialize and deserialize references to JSON, enabling seamless interaction with Kubernetes APIs and storage systems. The child module enhances this functionality by handling batch conversion of object references from and to JSON tuples, simplifying bulk processing. Use these capabilities to reliably manage object references when working with Kubernetes resources such as pods, services, or events.",
      "description_length": 588,
      "index": 1450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch.Deployments",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Deployment resources by sending HTTP requests to a server. It supports filtering by label, field selectors, and resource version, and returns events describing changes to deployments. Use this to monitor deployment updates in real-time, such as tracking rollouts or detecting failed deployments.",
      "description_length": 341,
      "index": 1451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1.Volume_attachment_spec",
      "library": "kubecaml",
      "description": "This module defines the structure and operations for specifying volume attachment requests in Kubernetes, including functions to construct, serialize, and access fields such as attacher, node name, and volume source. It is used to request the attachment of a volume to a specific node using a particular volume driver. The child module handles JSON serialization and deserialization of these specifications, working with lists of tuples containing string identifiers and Volume_attachment_spec.t values. This enables conversion between in-memory representations and JSON for API communication.",
      "description_length": 593,
      "index": 1452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1.Config_map_env_source",
      "library": "kubecaml",
      "description": "This module provides a configuration structure for sourcing environment variables from a Kubernetes ConfigMap, allowing the selection of a target ConfigMap and handling optional presence and name fields. It supports operations to create, serialize, and access ConfigMap references, enabling the injection of ConfigMap data into Kubernetes pod specifications as environment variables. The child module handles conversion between JSON and a list of key-value pairs, facilitating serialization and deserialization of environment variable data when working with ConfigMap sources. Together, they allow structured manipulation of environment variable configurations both in memory and in serialized formats.",
      "description_length": 702,
      "index": 1453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1.Horizontal_pod_autoscaler_status",
      "library": "kubecaml",
      "description": "This module models the status of a Kubernetes horizontal pod autoscaler, capturing key metrics like current and desired replicas, scaling conditions, and timestamps. It supports operations to construct, inspect, and update autoscaler status, enabling integration with control loops and monitoring systems. The child module extends this functionality by serializing and deserializing the status to JSON using `Yojson`, facilitating interaction with Kubernetes API endpoints. Together, they allow developers to programmatically evaluate autoscaler health, track scaling events, and maintain synchronization with cluster state.",
      "description_length": 624,
      "index": 1454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates.V1beta1",
      "library": "kubecaml",
      "description": "This module provides tools for constructing, inspecting, and serializing certificate signing requests (CSRs) and their associated data in Kubernetes. It supports key operations such as encoding and decoding PKCS#10 CSRs, managing request specifications, tracking conditions, and handling approval statuses with immutable metadata like username, groups, and usage constraints. The core data types include CSR specs, conditions, statuses, and lists, all with JSON serialization and deserialization via Yojson. Example uses include generating a base64-encoded CSR for TLS bootstrapping, updating a request's approval state with a timestamp, and parsing API responses into typed OCaml structures for further processing.",
      "description_length": 715,
      "index": 1455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes RBAC resources, including Roles, RoleBindings, ClusterRoles, and ClusterRoleBindings. It supports streaming events with filtering by labels, fields, resource versions, and timeouts, enabling precise tracking of access control changes cluster-wide or within specific namespaces. Operations include `get` to retrieve event streams and submodules to target resources by name. Examples include detecting when a restricted role is bound to a service account, tracking updates to default ClusterRoles, or logging all RBAC changes in a namespace.",
      "description_length": 595,
      "index": 1456,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module offers targeted management of Kubernetes Job resources within a namespace, enabling listing, creation, deletion, and status inspection. It centers around key types like `Job`, `Job_list`, and `Status` to support automation of job lifecycle tasks and real-time monitoring. Users can track job execution, restart failed jobs, or scale configurations programmatically through API-driven operations. Specific workflows include dynamic job control and state synchronization based on observed status updates.",
      "description_length": 514,
      "index": 1457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module enables fine-grained RBAC management within a namespace by leveraging the Kubernetes Rbac v1beta1 API to manipulate Role and RoleBinding resources. It supports core operations\u2014list, create, update, delete\u2014with label filtering and resource versioning for consistency. You can create a role with specific permissions, bind it to users or service accounts, or monitor role bindings for real-time policy enforcement. Submodules abstract REST interactions, allowing direct use of HTTP methods for precise control over RBAC resources.",
      "description_length": 540,
      "index": 1458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for managing Kubernetes RBAC configurations through structured data types and JSON serialization. It supports key RBAC components like Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings, along with policy rules and subject references, enabling precise control over access policies within and across namespaces. Operations include constructing, inspecting, and serializing these objects, with examples such as programmatically defining a RoleBinding to grant a user access in a specific namespace or aggregating ClusterRoles based on label selectors. The module facilitates integration with Kubernetes APIs by converting data to and from JSON, supporting configuration management, policy enforcement, and cluster auditing tasks.",
      "description_length": 782,
      "index": 1459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Roles",
      "library": "kubecaml",
      "description": "This module handles retrieving Role resources from the Kubernetes RBAC API by constructing request paths and issuing GET requests with customizable query parameters. It works with Role_list data structures and supports filtering, pagination, and real-time watching of Role objects. Concrete use cases include listing all Roles in a namespace, watching for Role changes over time, or fetching specific Roles based on label or field selectors.",
      "description_length": 441,
      "index": 1460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Util",
      "library": "kubecaml",
      "description": "This module handles values that can be either integers or strings, commonly found in Kubernetes API fields like container ports or resource limits. It provides a `make` function to construct these values from strings, along with JSON serialization and deserialization through `to_yojson` and `of_yojson`. It also supports structured encoding and decoding of key-value pairs containing such values, enabling parsing of Kubernetes objects like selector rules or annotations. Example uses include converting container port settings and resource constraints to JSON for API requests.",
      "description_length": 579,
      "index": 1461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time tracking of Kubernetes custom resource definitions, capturing creation, update, and deletion events with support for label selectors, resource versions, and timeouts. It exposes a `get` function to observe specific CRDs by name, returning a stream of events or an error, enabling precise lifecycle monitoring. Users can react to CRD changes as they occur, such as triggering application logic on updates or maintaining consistency with cluster state. Example applications include synchronizing configuration changes or automating responses to CRD deletions.",
      "description_length": 588,
      "index": 1462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Rolebindings",
      "library": "kubecaml",
      "description": "This module handles retrieving lists of RoleBinding resources from a Kubernetes API server, supporting operations like filtering by label or field selectors, pagination, and watch streams. It works with RoleBinding and RoleBindingList data types defined in the Kubernetes RBAC v1 API. Concrete use cases include listing all RoleBindings in a namespace or watching for changes to RoleBindings in real time.",
      "description_length": 405,
      "index": 1463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes event management by namespace, enabling targeted operations on events within isolated environments. It supports listing, creating, updating, and deleting events individually or in bulk, with filtering and partial updates via PATCH. Key data types include event objects, namespace identifiers, and patch payloads. You can retrieve event streams with custom queries, update event statuses, or remove outdated events in specific namespaces.",
      "description_length": 470,
      "index": 1464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core.V1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive set of data structures and operations for modeling Kubernetes API objects and their configurations. It includes core types like `Object_meta`, `Container`, `Pod_spec`, `Service_account`, `Secret`, `Volume`, and `Resource_requirements`, along with supporting constructs for networking, storage, scheduling, and runtime state management. Operations allow creation, inspection, and serialization of Kubernetes resources such as pods, services, secrets, persistent volumes, and resource quotas, with JSON support via `to_yojson` and `of_yojson`. Developers can programmatically define container specs with environment variables and resource limits, configure storage using persistent volume claims or cloud provider volumes, manage service networking with ingress and endpoints, enforce scheduling constraints with taints and tolerations, and serialize entire configurations to JSON for deployment or API interaction.",
      "description_length": 950,
      "index": 1465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Selfsubjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles the creation of self-subject access reviews in Kubernetes by providing a function to construct and send a POST request with a `SelfSubjectAccessReview` resource body. It works with the `SelfSubjectAccessReview` type from the Kubernetes authorization API, allowing clients to evaluate access permissions for the calling user. A concrete use case is determining whether the current user is allowed to perform a specific action on a resource, such as checking if they can create a pod in a namespace.",
      "description_length": 517,
      "index": 1466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes Job resources, providing event streams that track job creation, updates, and deletions within a namespace or cluster. It supports filtering by labels, fields, and resource version, along with configurable timeouts and pagination. Key operations include starting a watch, handling lifecycle events, and retrieving streaming updates. Examples include detecting failed jobs immediately or tracking job completion status in real time.",
      "description_length": 485,
      "index": 1467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time observation of Kubernetes workload changes across namespaces, supporting Deployments, DaemonSets, ReplicaSets, StatefulSets, and ControllerRevisions. It streams `Watch_event` values with filtering by labels, fields, and resource versions, enabling precise tracking of configuration updates, health changes, and scaling events. Operations include monitoring Deployment rollouts, DaemonSet node status, StatefulSet scaling, and ControllerRevision changes, with support for timeouts and pagination. Example uses include triggering actions on resource modifications or tracking stateful set revisions during updates.",
      "description_length": 643,
      "index": 1468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Namespaces",
      "library": "kubecaml",
      "description": "This module offers a full set of HTTP-based operations for managing Kubernetes CronJob resources within a namespace, including listing, creating, deleting, replacing, and patching jobs. It centers around the `Cron_job.t` type for representing job configurations and `Patch.t` for applying partial updates, supporting precise control over job definitions and runtime status. Users can filter existing jobs, submit new configurations, modify active jobs through strategic patches, and directly adjust execution state via API interactions. Example uses include deploying scheduled tasks, updating job schedules, and managing job status without redeploying entire configurations.",
      "description_length": 675,
      "index": 1469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for handling Kubernetes authorization workflows, centered around access reviews, authorization attributes, and policy rules. It defines core data types such as access review specifications, subject and self-subject rules reviews, authorization attributes, and resource/non-resource rules, along with operations to construct, inspect, and serialize these structures to and from JSON. You can use it to evaluate user permissions for specific resources or URLs, define and validate RBAC policies, or integrate with Kubernetes API endpoints by submitting and processing access review requests. Examples include checking if a user can create a pod in a namespace, defining a rule to allow `GET` on `/api`, or retrieving a user's permissions for UI visibility control.",
      "description_length": 809,
      "index": 1470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of mutating and validating webhook configurations in Kubernetes, supporting filters like resource version and label selector. It exposes structured watch events and allows per-name tracking with operations such as `get` and streaming updates over Cohttp. Users can observe dynamic changes to admission control policies and react to additions, modifications, or deletions of webhook configurations as they occur. Example usage includes tracking a specific validating webhook by name and streaming its updates with a custom timeout.",
      "description_length": 572,
      "index": 1471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Daemonsets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching DaemonSet resources from a Kubernetes API server. It provides a `get` function to list or watch DaemonSets with optional filtering, pagination, and request configuration. The function operates on URI inputs and returns a result containing a DaemonSet list or an error message.",
      "description_length": 320,
      "index": 1472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Persistentvolumeclaims",
      "library": "kubecaml",
      "description": "This module watches for changes to persistent volume claims in a Kubernetes cluster. It provides a `get` function to stream events matching specified criteria, such as label selectors or resource versions, over HTTP. Use it to monitor claim creation, deletion, or updates in real time.",
      "description_length": 285,
      "index": 1473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg.Apis",
      "library": "kubecaml",
      "description": "This module provides tools to define, validate, and serialize Kubernetes API structures, particularly CRDs, with support for JSON schemas, validation rules, and subresource configurations. Key data types include CRD metadata, status conditions, and scale settings, with operations to encode and decode these structures using `Yojson`. It allows defining custom validation logic, configuring autoscaling via JSON paths, and ensuring schema compliance with OpenAPI standards. Example uses include preparing CRDs for cluster registration, validating API extensions, and managing custom resource status and naming.",
      "description_length": 610,
      "index": 1474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Selfsubjectrulesreviews",
      "library": "kubecaml",
      "description": "This module handles the creation of self-subject rules reviews in a Kubernetes API. It provides a function to construct the request path and another to send a POST request with a self-subject rules review body, returning the reviewed rules or an error. It works directly with Kubernetes authorization v1beta1 self-subject rules review objects, used to determine permissions for the calling user. A concrete use case is checking if the current user has permission to perform specific actions on resources within a cluster.",
      "description_length": 521,
      "index": 1475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Replicasets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching ReplicaSet resources from the Kubernetes API. It provides a `get` function to list or watch ReplicaSets with optional parameters like label selectors, resource versions, and timeouts. The module works directly with Kubernetes ReplicaSet definitions and interacts with the API via HTTP requests using Cohttp.",
      "description_length": 351,
      "index": 1476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Apiservices",
      "library": "kubecaml",
      "description": "This module handles Kubernetes API registration operations, listing, creating, and deleting `Api_service` resources with support for filtering, pagination, and asynchronous I/O using Lwt. It works directly with `Api_service.t`, `Delete_options.t`, and `Patch.t` to manage service definitions and supports core operations like retrieval, replacement, deletion, and partial updates by name. The child module extends this functionality by allowing status updates of existing API services using fully defined `Api_service.t` objects, enabling synchronization of service state after configuration changes or health checks. Together, they provide a focused interface for dynamically managing API service registration and configuration in a Kubernetes cluster.",
      "description_length": 753,
      "index": 1477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module enables namespace-level management of Kubernetes workloads through direct HTTP operations on resources like Deployments, StatefulSets, and ControllerRevisions. It provides core data types and operations\u2014`get`, `post`, `put`, `patch`\u2014to create, inspect, update, and delete these resources, with submodules offering control over subresources such as scale and status. You can use it to programmatically scale deployments, roll back to previous controller revisions, or monitor the status of stateful sets in response to load changes. Example workflows include dynamically adjusting replica counts, inspecting rollout history, and managing stateful application revisions.",
      "description_length": 680,
      "index": 1478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module provides HTTP-based operations for managing Kubernetes RBAC cluster role bindings, supporting get, post, and delete actions on role binding objects and lists. It includes a child module that extends functionality for named cluster role bindings, enabling precise manipulation via get, put, delete, and patch operations using resource URLs. Main data types include cluster role binding objects and lists, with operations that allow filtering via query parameters and direct resource targeting. Examples include retrieving filtered role binding lists, creating new bindings, and updating or removing specific bindings by name.",
      "description_length": 636,
      "index": 1479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time observation of Kubernetes workload changes across Deployments, StatefulSets, and ControllerRevisions, using HTTP streaming with support for label and field selectors, resource versions, and timeouts. It enables monitoring of cluster updates to trigger automated actions, track rollout progress, or audit deletions. Key operations include constructing watch requests, filtering by name or selector, and retrieving events with customizable consistency and time limits. Example uses include autoscaling based on StatefulSet updates and event-driven workflows responding to Deployment changes.",
      "description_length": 620,
      "index": 1480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive framework for handling token authentication in the Kubernetes API, centered around constructing, validating, and serializing token review requests and responses. It defines key data types such as token review specifications, status objects, and user information maps, with operations to convert to and from JSON using `to_yojson` and `of_yojson`. You can use it to extract and validate authentication tokens, encode user data, and generate structured responses for webhook token authenticators. Example workflows include parsing incoming token reviews, validating user identities, and returning JSON-formatted authentication results during API server interactions.",
      "description_length": 701,
      "index": 1481,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1.Storageclasses",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes storage classes, supporting core operations like listing all classes, creating new ones, and deleting existing entries. It works with storage class definitions and API response structures to handle status and error reporting. The `By_name` submodule adds name-based access for precise CRUD control, allowing actions like fetching a specific class, updating its configuration, or removing it. Together, they enable programmatic management of storage configurations in a Kubernetes cluster, from bulk operations to fine-grained adjustments.",
      "description_length": 595,
      "index": 1482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Secrets",
      "library": "kubecaml",
      "description": "Implements functions to watch for changes to Kubernetes Secret resources via a streaming HTTP request. It provides a `get` function that accepts parameters like `watch`, `timeout_seconds`, and `label_selector` to filter and control the stream of events. Uses `Watch_event.t` to represent events and works directly with URIs to target specific Kubernetes API endpoints.",
      "description_length": 368,
      "index": 1483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1.Jobs",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Job resources via HTTP requests. It provides a `get` function to list or watch Job objects with optional parameters like label selectors, field selectors, and pagination. The function operates on URIs and returns a result containing a Job list or an error message, using the Cohttp library for HTTP communication.",
      "description_length": 368,
      "index": 1484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring and dynamic management of PodPreset resources across Kubernetes namespaces. It supports operations such as watching for changes, filtering by labels and fields, and applying updates to environment variables and volume mounts, with support for pagination and version tracking. You can, for example, stream configuration changes in a specific namespace or iterate through large sets of PodPresets to enforce cluster-wide settings. The `get` function establishes a watch stream, allowing you to receive events that describe updates to PodPreset objects in real time.",
      "description_length": 604,
      "index": 1485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Roles",
      "library": "kubecaml",
      "description": "This module handles retrieving Role resources from the Kubernetes RBAC API using a GET request. It supports filtering by label and field selectors, pagination with limit and continue parameters, and watching for changes with a resource version. Concrete use cases include listing all Roles in a namespace or watching Role updates for dynamic policy management.",
      "description_length": 360,
      "index": 1486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1",
      "library": "kubecaml",
      "description": "This module provides a structured interface for managing Kubernetes batch jobs, encompassing job configurations, statuses, and execution conditions. It defines key data types such as `Job`, `Job_list`, `Job_status`, `Job_condition`, and `Job_spec`, along with operations for constructing, inspecting, and serializing these entities to and from JSON. Functions support tasks like parsing API responses, building custom job definitions, tracking job state transitions, and managing collections of jobs with consistent serialization. Example uses include programmatically generating job configurations with custom parallelism and selectors, monitoring job completion status, and persisting or transmitting job collections across systems.",
      "description_length": 734,
      "index": 1487,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module manages Kubernetes CronJob resources within a namespace, offering REST operations to list, create, and delete CronJobs, along with inspecting and updating their runtime state. It operates on CronJob and CronJobList data types, enabling automation of periodic workloads and batch processing workflows. Example uses include scheduling jobs via HTTP requests and modifying job execution policies through the status submodule.",
      "description_length": 434,
      "index": 1488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes API services, supporting both global and per-name observation. It provides a `get` function to establish a watch stream with parameters such as resource version and label selectors, returning `Watch_event.t` values that represent changes to specific `Api_service` resources. These events allow dynamic tracking of additions, updates, or removals of API services as they occur. For example, you can watch all API services matching a label selector or track changes to a specific service by name.",
      "description_length": 549,
      "index": 1489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Events",
      "library": "kubecaml",
      "description": "This module handles watching for changes to Kubernetes event resources by providing a function to initiate a watch request with customizable parameters such as timeout, resource version, and selectors. It operates on Kubernetes event data, returning structured watch events or error strings asynchronously. Concrete use cases include monitoring cluster events in real-time, such as tracking pod creation or deletion, and responding to changes in event state within a specific namespace or label set.",
      "description_length": 499,
      "index": 1490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V2alpha1",
      "library": "kubecaml",
      "description": "This module provides structured tools for defining, managing, and serializing Kubernetes cron jobs and their configurations. It centers around data types such as cron job specifications, job templates, and status instances, supporting operations like schedule definition, metadata manipulation, and JSON conversion for API interaction. You can create parameterized jobs, manage scheduled workloads with concurrency policies, update job status with execution details, and serialize configurations for storage or transmission. Example tasks include defining a cron job with a specific schedule, persisting and retrieving job templates, and synchronizing job status with last execution times.",
      "description_length": 689,
      "index": 1491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring and event streaming for Kubernetes resources such as PodDisruptionBudget and PodSecurityPolicy, enabling dynamic responses to changes in cluster state. It supports fine-grained filtering through label and field selectors, resource versioning, timeouts, and context-based control, with core operations centered around the `get` function to establish watch streams. Users can track updates or deletions of specific resources, trigger actions on policy changes, or enforce compliance dynamically. Example use cases include streaming events for a named PodDisruptionBudget during a rolling update or auditing modifications to a PodSecurityPolicy in real time.",
      "description_length": 697,
      "index": 1492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for modeling, managing, and serializing Kubernetes deployment and stateful workload configurations. It centers around key data types such as Deployment, StatefulSet, Scale, and ControllerRevision, along with their associated specs, statuses, and strategies, enabling precise control over rollout behavior, scaling, and state transitions. Operations include constructing and modifying resource specifications, tracking deployment health through condition records, defining update and rollback strategies, and serializing or deserializing data to and from JSON for API interaction or persistent storage. Example uses include programmatically managing deployment rollouts with custom update strategies, tracking StatefulSet status changes for monitoring, or encoding scaling configurations for transmission to a Kubernetes cluster.",
      "description_length": 875,
      "index": 1493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Nodes.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Node resources by name through direct HTTP interactions, enabling operations like retrieval, replacement, deletion, and partial updates of node objects and their status. It works with Node definitions, metadata, and Patch documents, using HTTP clients to communicate with the API server for tasks such as updating labels, modifying conditions, or removing decommissioned nodes. The first child module extends this functionality by providing proxy-based access to node-level endpoints, supporting fine-grained operations like diagnostics or low-level resource management via path-based requests. The second child module focuses specifically on node status management, allowing precise updates and health checks without requiring full object replacement.",
      "description_length": 783,
      "index": 1494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes API services through HTTP-based watch requests, allowing clients to track lifecycle events and configuration changes. It provides data types for watch events, error responses, and request parameters such as resource version, label selector, and timeout. Operations include initiating targeted watches by service name, building request paths, and parsing streaming updates or errors. Example use cases include detecting when a specific API service becomes available or triggering actions in response to service configuration updates.",
      "description_length": 587,
      "index": 1495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Statefulsets",
      "library": "kubecaml",
      "description": "Implements operations for retrieving StatefulSet resources from the Kubernetes API. It provides a `get` function to list or watch StatefulSet objects with support for filtering, pagination, and connection settings. Works directly with Kubernetes StatefulSet definitions and integrates into client workflows for cluster management and deployment tracking.",
      "description_length": 354,
      "index": 1496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1beta2",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for managing Kubernetes workload resources, including Deployments, StatefulSets, DaemonSets, and ReplicaSets, along with their associated statuses, conditions, and scaling parameters. It defines structured types for key Kubernetes concepts such as rolling update strategies, scale subresources, and controller revisions, supporting operations like construction, access, and JSON serialization using Yojson. You can define and modify deployment configurations with update strategies, track observed replica states, serialize DaemonSet statuses for monitoring, or manage ControllerRevision history for rollbacks, all while maintaining compatibility with Kubernetes APIs through structured JSON conversion.",
      "description_length": 750,
      "index": 1497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1beta1",
      "library": "kubecaml",
      "description": "This module suite provides Kubernetes admission control configuration capabilities, centered around mutating and validating webhooks that enforce policies during resource creation or updates. Core data types include `Rule_with_operations`, `Webhook_client_config`, `Service_reference`, and configurations for both mutating and validating webhooks, each supporting construction, access, and JSON serialization. You can define policies that inject sidecars, enforce resource constraints, validate annotations, or restrict operations based on resource types and namespaces. Secure webhook endpoints are configured using TLS settings with CA bundles or service references, and configurations can be persisted or exchanged in JSON format for integration with Kubernetes APIs.",
      "description_length": 770,
      "index": 1498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Persistentvolumes",
      "library": "kubecaml",
      "description": "This module enables real-time observation of persistent volume changes in Kubernetes, offering streaming watch operations with support for label and field filtering, resource version control, and pagination. It provides a `get` function that returns a stream of `Watch_event.t` values, representing additions, updates, or deletions of persistent volumes. The module allows monitoring specific volumes by name and includes utilities for custom selection, timeouts, and request tuning using types like `Uri.t`. Submodules enhance direct API interactions by enabling fine-grained control over individual persistent volume resources and their event streams.",
      "description_length": 653,
      "index": 1499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module enables namespace-scoped management of Kubernetes workloads and network policies through HTTP operations, supporting full lifecycle control of resources like DaemonSets, ReplicaSets, Deployments, Ingresses, and NetworkPolicies. Key operations include `get`, `put`, `patch`, and `delete` for managing resource state, with submodules handling scaling, status updates, TLS settings, and routing rules. It allows specific actions such as applying configuration changes via DaemonSet patches, scaling Deployments based on metrics, and updating Ingress routing rules dynamically.",
      "description_length": 585,
      "index": 1500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Namespaces",
      "library": "kubecaml",
      "description": "This module handles RBAC management within Kubernetes namespaces by offering structured types and operations for Roles and RoleBindings. It supports creating, updating, listing, and deleting these resources, enabling programmatic access control adjustments. You can use it to automate permission grants, synchronize policies, or remove obsolete roles during namespace cleanup. Examples include binding a user to a role or clearing outdated role definitions.",
      "description_length": 457,
      "index": 1501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1.Apiservices",
      "library": "kubecaml",
      "description": "This module implements HTTP client operations for managing Kubernetes API services, combining core functions for listing, watching, creating, and deleting services with named resource operations in its child module. It handles key data types like `Api_service.t` and `Delete_options.t`, supporting direct interactions such as registering custom API endpoints, updating service configurations, and removing deprecated services. The child module extends functionality by enabling fine-grained updates, including status modifications via a specialized `put` operation on predefined paths. Together, they provide a comprehensive interface for controlling API service lifecycle and availability within a Kubernetes cluster.",
      "description_length": 718,
      "index": 1502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Certificatesigningrequests",
      "library": "kubecaml",
      "description": "This module manages certificate signing requests in a Kubernetes cluster, supporting operations like list, create, and delete with customizable HTTP queries and headers. It works directly with `Certificate_signing_request` and `Certificate_signing_request_list` objects, enabling full lifecycle control. Submodules allow per-request management by name, including approval and status updates via `put` and status replacement, facilitating automated certificate workflows like issuance, denial, or state modification. Specific operations include retrieving individual requests, patching metadata, and programmatically approving or rejecting requests through targeted API interactions.",
      "description_length": 682,
      "index": 1503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Api",
      "library": "kubecaml",
      "description": "This module handles Kubernetes resource quantities with a custom type `t` that supports parsing from strings and JSON conversion. It offers operations like `make` to construct values for CPU or memory limits and includes a submodule for managing key-value collections of these quantities. Developers can create and serialize resource specifications, such as defining a memory limit with `make \"2Gi\"` and embedding it in a pod spec. Structured serialization via `to_yojson` and `of_yojson` enables seamless integration with Kubernetes API requests.",
      "description_length": 547,
      "index": 1504,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module handles retrieving lists of Horizontal Pod Autoscaler resources from a Kubernetes API server, supporting operations like filtering by label or field selectors, limiting results, and watching for changes. It works with Kubernetes Horizontal Pod Autoscaler objects and related metadata, providing typed responses using Cohttp for HTTP communication. Concrete use cases include monitoring autoscaling policies in a cluster and dynamically adjusting resources based on current metrics.",
      "description_length": 493,
      "index": 1505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module enables management of Kubernetes workloads within a namespace, supporting creation, modification, and monitoring of resources like Deployments, StatefulSets, DaemonSets, and their subresources. Key operations include `get`, `put`, `patch`, `delete`, and `list`, with typed data structures such as `Deployment.t` and `Stateful_set_list.t` for safe, structured interactions. It facilitates tasks like scaling replica counts, rolling back deployments using ControllerRevision history, or updating pod templates for rolling updates. Specific workflows include adjusting a StatefulSet's size, patching a DaemonSet's template, or inspecting a ReplicaSet's status via Kubernetes API groups like Apps V1 and Autoscaling V1.",
      "description_length": 727,
      "index": 1506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive toolkit for managing Kubernetes RBAC v1beta1 configurations, enabling the construction, manipulation, and serialization of roles, role bindings, and policy rules. It centers around core data types such as `Role.t`, `Role_binding.t`, `Subject.t`, `Policy_rule.t`, and their cluster-scoped counterparts, with operations to build, inspect, and associate these entities. Functions support JSON conversion via `Yojson.Safe`, allowing structured interaction with Kubernetes APIs and configuration files. Examples include defining a role with specific permissions, binding it to a user or service account in a namespace, or aggregating cluster roles based on label selectors for dynamic access control.",
      "description_length": 732,
      "index": 1507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1.Volumeattachments",
      "library": "kubecaml",
      "description": "This module manages Kubernetes VolumeAttachment resources, offering operations to list, watch, create, and delete attachments across the cluster. It centers around the VolumeAttachment and VolumeAttachmentList data types, enabling direct interaction with the Kubernetes API to track and manipulate volume attachment states. The child module extends this functionality by providing named-based REST operations, including get, put, delete, and patch, to manage individual VolumeAttachment objects with precision. Together, they support use cases like automating volume lifecycle management and monitoring attachment status for storage devices in a running cluster.",
      "description_length": 662,
      "index": 1508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module organizes operations for managing PodDisruptionBudget resources within Kubernetes namespaces, offering both broad and detailed control over budget lifecycle and status. It centers around the PodDisruptionBudget and PodDisruptionBudgetList types, enabling actions like listing, creating, deleting, and updating budgets, as well as retrieving and modifying their status independently. Users can enforce availability policies during deployments by applying or adjusting budgets, or perform bulk deletions during cluster maintenance. For example, it allows creating a budget to limit pod disruptions during a rollout or patching an existing budget to adjust its constraints.",
      "description_length": 682,
      "index": 1509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration.V1alpha1",
      "library": "kubecaml",
      "description": "This module implements Kubernetes admission control logic through initializer configurations and resource rules, enabling structured enforcement of policies during resource creation. It provides data types for initializer lists, admission rules, and versioned API resources, with operations to construct, serialize, and apply these configurations. Functions like `to_yojson` and `of_yojson` support JSON conversion for API interactions, while rule tuples define precise matching criteria for mutating or validating requests. Example uses include injecting sidecars, applying default labels, or enforcing custom policies based on API groups, versions, and resource types.",
      "description_length": 670,
      "index": 1510,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides functionality for working with Kubernetes PodPreset and PodPresetList resources in the v1alpha1 API version. It includes data types for representing pod presets, their specifications, and lists of presets, along with operations to construct, modify, and serialize these structures. Each type supports JSON conversion through dedicated submodules, enabling seamless integration with configuration files or API interactions. For example, you can define a pod preset that injects environment variables or volume mounts into matching pods, group multiple presets, and serialize them to JSON for deployment or storage.",
      "description_length": 634,
      "index": 1511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module offers typed HTTP operations for managing Horizontal Pod Autoscaler resources in a Kubernetes namespace via the V2beta1 API. It enables creation, listing, and deletion of autoscalers using structured data types like `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list`. You can retrieve existing autoscaler configurations, define new scaling policies based on metrics, or automate adjustments in response to real-time system load changes. Example use cases include programmatically setting CPU-based scaling thresholds for deployments or dynamically removing outdated autoscalers.",
      "description_length": 604,
      "index": 1512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Serviceaccounts",
      "library": "kubecaml",
      "description": "This module implements a Kubernetes API endpoint for watching service account resources. It provides a `get` function to stream real-time updates as service accounts are created, modified, or deleted, supporting filtering by label, field, and resource version. Use this to monitor service account changes in a namespace or cluster for automation or auditing purposes.",
      "description_length": 367,
      "index": 1513,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg.Apis",
      "library": "kubecaml",
      "description": "This module provides structured management of Kubernetes API services through typed representations of service configurations, references, and health states. It supports operations for constructing, modifying, and inspecting services, including loading from files, updating TLS settings, and querying status conditions. Key data types include API service specifications with priority and TLS parameters, service references with optional namespace and name, and conditions tracking status transitions. Example uses include registering backend servers, exporting configurations to JSON, and organizing services by label or version for cluster management.",
      "description_length": 652,
      "index": 1514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes priority class resources with support for filtering, limiting results, and controlling request parameters such as timeout and resource version. It provides event streams and priority class objects, allowing operations to watch, retrieve, and filter priority classes by labels or fields. A submodule streams events for specific priority class instances by name, enabling precise change tracking. Example uses include dynamically adjusting scheduling policies or tracking cluster-wide priority class state in an external controller.",
      "description_length": 585,
      "index": 1515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module enables programmatic management of Kubernetes RBAC resources within a namespace, focusing on Roles and RoleBindings. It provides types like `Role`, `RoleList`, `RoleBinding`, and `RoleBindingList`, along with operations to list, create, update, and delete these resources, supporting parameters such as `label_selector` and `resource_version` for precise filtering and synchronization. You can use it to automate access control setup, enforce permission policies, or manage RBAC cleanup during namespace lifecycle events.",
      "description_length": 533,
      "index": 1516,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes ControllerRevision resources via HTTP requests. It works with `Controller_revision_list` data structures and supports filtering with label and field selectors, limiting results, and controlling request behavior with timeouts and context. Concrete use cases include listing ControllerRevision objects from a cluster or watching for changes to specific revisions based on resource version or initialization state.",
      "description_length": 466,
      "index": 1517,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1beta1",
      "library": "kubecaml",
      "description": "This collection manages Kubernetes storage resources including volume attachments, storage classes, and associated metadata, errors, and statuses. It provides structured types like `t` for volume attachment specifications, storage class definitions, and error tracking, along with operations to construct, inspect, and serialize these types to and from JSON. Users can define storage tiers with custom parameters, track attachment status and errors, and encode or decode volume attachment requests for API interaction. Example workflows include creating a storage class for SSD volumes, managing volume attachment lifecycles, and transmitting structured error data for monitoring.",
      "description_length": 680,
      "index": 1518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes initializer configurations, streaming updates as they happen. It supports filtering through parameters like `label_selector`, `resource_version`, and `timeout_seconds`, and allows per-name observation for precise event tracking. Developers can use it to react dynamically to configuration changes, such as updating admission control policies in response to observed updates. Example use cases include watching for changes to specific initializer configurations and triggering actions based on live updates.",
      "description_length": 562,
      "index": 1519,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Clusterroles",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations for Kubernetes RBAC cluster roles, enabling programmatic management of cluster-wide role-based access control policies. It supports core operations like listing, creating, and deleting cluster roles, working directly with types such as `Cluster_role`, `Cluster_role_list`, and `Status`. The child module extends this functionality by allowing fine-grained manipulation of individual roles by name, including get, put, delete, and patch operations using types like `Delete_options` and `Patch`. Together, they enable tasks such as automating role creation, enforcing policy updates, and cleaning up role definitions in deployment pipelines.",
      "description_length": 683,
      "index": 1520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of VolumeAttachment resources in Kubernetes, enabling structured access to watch events for tracking when storage volumes are attached or detached from nodes. It offers `get` and name-based retrieval functions that support label and field selectors, resource version control, custom timeouts, and filtering for precise observation of lifecycle changes. Developers can use it to stream updates on specific VolumeAttachment objects, facilitating dynamic cluster management in response to storage events. For example, it allows watching for when a particular volume is attached to a node or detecting detachment events for cleanup or rescheduling actions.",
      "description_length": 694,
      "index": 1521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Pods",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve streaming updates for Pod resources in a Kubernetes cluster. Accepts query parameters like `label_selector`, `resource_version`, and `timeout_seconds` to filter and control the event stream. Designed for real-time monitoring of Pod state changes, returning events as `Watch_event.t` values.",
      "description_length": 333,
      "index": 1522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Deployments",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Deployment resources via HTTP requests. It provides a `get` function to list or watch Deployments with optional filters like label selectors, resource versions, and timeouts. The function interacts with URIs and returns parsed Deployment list data or error messages, using Cohttp for HTTP communication.",
      "description_length": 358,
      "index": 1523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V1",
      "library": "kubecaml",
      "description": "This module provides structured representations and operations for Kubernetes autoscaling resources, including horizontal pod autoscalers and scale subresources. It defines core data types such as autoscaler specifications, scale specifications, and status objects, with support for key operations like setting replica bounds, tracking metrics, and referencing cross-version resources. Each component includes constructors, accessors, and serialization routines for JSON and YAML, enabling programmatic configuration, modification, and persistence of scaling policies. For example, users can build autoscaling rules based on CPU utilization, inspect or update current replica counts, and serialize configurations for deployment or storage.",
      "description_length": 739,
      "index": 1524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Limitranges",
      "library": "kubecaml",
      "description": "Implements functions to watch and retrieve LimitRange resources from a Kubernetes API server. It supports filtering by label and field selectors, resource version, and includes options for pagination and timeout settings. This module is used to monitor dynamic changes to LimitRange objects within a cluster, such as when new limits are applied or existing ones are modified.",
      "description_length": 375,
      "index": 1525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Networkpolicies",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes NetworkPolicy resources via the API. It provides operations to list or watch network policies with options like label selectors, field selectors, and resource versioning. It works directly with network policy objects and is used for network security configuration management in clusters.",
      "description_length": 342,
      "index": 1526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Horizontalpodautoscalers",
      "library": "kubecaml",
      "description": "This module handles retrieving lists of Horizontal Pod Autoscaler resources from a Kubernetes API server, supporting operations like filtering by label or field selectors, setting timeouts, and handling pagination. It works with Kubernetes Horizontal Pod Autoscaler definitions and interacts with HTTP requests via Cohttp. Concrete use cases include querying autoscaler configurations for monitoring or managing scaling policies in a cluster.",
      "description_length": 442,
      "index": 1527,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1.Initializerconfigurations",
      "library": "kubecaml",
      "description": "This module manages Kubernetes initializer configurations through HTTP operations like list, create, and delete, supporting filtering, pagination, and change watching. It provides access to initializer configuration objects across the cluster, allowing actions such as listing all configurations or creating new ones. The child module handles per-resource RESTful operations, enabling precise get, put, delete, and patch actions on named InitializerConfiguration objects using Cohttp. Together, they support tasks like retrieving a specific configuration, updating its spec, or watching for cluster-wide initializer changes.",
      "description_length": 624,
      "index": 1528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring and dynamic retrieval of Kubernetes storage class resources through HTTP-based watch operations. It supports label and field selectors, resource version control, and timeout management, allowing precise tracking of changes such as updates to provisioner configurations or access modes. Key operations include streaming updates, direct lookup by name, and retrieving current or historical states of storage classes. Use cases include dynamic storage provisioning and enforcement of cluster-wide storage policies.",
      "description_length": 552,
      "index": 1529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Watch",
      "library": "kubecaml",
      "description": "This module tracks changes to NetworkPolicy resources in Kubernetes, enabling real-time responses to policy events across namespaces or specific resources. It supports filtering by labels, fields, and timeouts, with a `get` function to retrieve current states or stream updates. Developers can react to policy creation, modification, or deletion, such as by synchronizing firewall rules or recording audit logs. For instance, it can trigger automatic security adjustments when a new NetworkPolicy is applied or notify systems when existing policies change.",
      "description_length": 556,
      "index": 1530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Replicasets",
      "library": "kubecaml",
      "description": "This module handles retrieving ReplicaSet resources from the Kubernetes API. It provides a `get` function to list or watch ReplicaSets with optional filters like label selectors, resource version, and timeouts. The function operates on URIs and returns parsed ReplicaSet list data or error messages.",
      "description_length": 299,
      "index": 1531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking.V1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive system for defining and managing Kubernetes network policies through structured data types and operations. It supports constructing and serializing ingress and egress rules, CIDR blocks, peer and port specifications, and policy metadata, enabling precise control over pod network traffic. You can define policies that restrict traffic to specific ports, allow connections from certain IP ranges or labeled pods, and manage collections of policies for API interactions. Example use cases include enforcing HTTPS-only access to services, blocking external traffic to internal pods, and programmatically generating or parsing network policy configurations in JSON format.",
      "description_length": 705,
      "index": 1532,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events.V1beta1",
      "library": "kubecaml",
      "description": "This module provides structured handling of Kubernetes event data, organizing individual events and event series into grouped, serializable collections. It defines core data types such as event lists, keyed event series, and namespace-grouped event tuples, supporting operations like construction, inspection, and JSON conversion. You can use it to track event sequences, aggregate events by namespace, or extract detailed metadata such as event type and resource references. Specific use cases include monitoring cluster state changes, auditing resource activity, and transmitting structured event data across systems.",
      "description_length": 619,
      "index": 1533,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Configmaps",
      "library": "kubecaml",
      "description": "This module watches for changes to ConfigMap resources in a Kubernetes cluster. It provides a `get` function to stream events for a specific ConfigMap, accepting parameters like `watch`, `timeout_seconds`, and `resource_version` to control the watch behavior. Use it to monitor real-time updates or deletions of ConfigMaps in a namespace.",
      "description_length": 338,
      "index": 1534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time tracking of Kubernetes volume attachments and storage classes, enabling precise observation of resource changes as they occur. It supports filtered watches using label selectors, field selectors, and resource versions, with operations to stream updates for specific resources by name or broader categories. The core data types include volume attachments and storage classes, with structured events for additions, modifications, and deletions. For example, users can monitor the attachment status of a specific volume or respond dynamically to changes in storage class configurations.",
      "description_length": 614,
      "index": 1535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Volumeattachments",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes VolumeAttachment resources, enabling operations like listing, watching, creating, and deleting attachments. It works with the storage v1beta1 API group, using types such as `Volume_attachment` and `Volume_attachment_list`, and supports monitoring attachment state changes and managing ephemeral storage. The child module extends this functionality with RESTful per-name operations\u2014get, put, delete, and patch\u2014for precise control over individual VolumeAttachment objects. Together, they allow tasks like retrieving specific attachments, updating status fields, or cleaning up collections of attachments in a cluster.",
      "description_length": 672,
      "index": 1536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Runtime",
      "library": "kubecaml",
      "description": "This module enables deferred decoding of Kubernetes API objects with raw JSON or YAML content, allowing selective unmarshaling of fields at runtime. It supports scalar and list-based raw extension structures through functions like `to_yojson`, `of_yojson`, `make`, and `raw`, facilitating precise handling of versioned resources such as custom resource definitions. Operations allow delaying type resolution until needed, for example converting a raw JSON field into a typed plugin configuration or `runtime.Unknown` if the type is not recognized.",
      "description_length": 547,
      "index": 1537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Apis",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes API interactions using structured data types such as label selectors, owner references, and versioned API groups. It supports operations for resource filtering, metadata serialization, status interpretation, and client routing based on network CIDR ranges. Users can construct pod selectors for deployments, encode API errors, and manage initializer workflows during resource creation. Specific examples include serializing metadata for object creation and directing API clients based on network configuration.",
      "description_length": 543,
      "index": 1538,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes RBAC resources, including Roles, RoleBindings, ClusterRoles, and ClusterRoleBindings. It supports streaming updates through `get` and `watch` operations with filtering by label, field, or name, along with resource versions and timeouts. You can use it to audit access control changes, enforce policies, or synchronize permissions dynamically across namespaces or clusters. Specific operations include watching for modifications to a specific ClusterRole by name, streaming RoleBinding updates matching a label selector, or tracking RBAC changes across a multi-tenant environment.",
      "description_length": 635,
      "index": 1539,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of certificate signing requests in Kubernetes, using configurable watch streams to track changes and retrieve updated request data. It supports operations like setting resource versions, label selectors, and timeouts, and emits events for added or modified requests. The certificates v1beta1 API extension allows per-name tracking and path construction via utilities like `request_path_template`. Users can, for example, monitor the approval status of a specific certificate request over time or react dynamically to new signing requests.",
      "description_length": 580,
      "index": 1540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Deployments",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Deployment resources via HTTP requests. It provides a `get` function to list or watch Deployments with optional parameters like label selectors, resource versions, and timeouts, returning a result containing a Deployment list or an error. The module works directly with Kubernetes API objects and is used for querying Deployment states in cluster management workflows.",
      "description_length": 423,
      "index": 1541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Events",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Event resources via HTTP requests. It provides a `get` function to list or watch events with options like label selectors, resource version, and timeouts, returning an Event_list result. The module works directly with Kubernetes event definitions and integrates with Cohttp for handling HTTP interactions.",
      "description_length": 360,
      "index": 1542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes namespace operations around autoscaling management, focusing on `Horizontal_pod_autoscaler` and `Horizontal_pod_autoscaler_list` types. It supports full and partial updates via PUT and PATCH, and allows direct manipulation of autoscaler status fields. You can use it to programmatically adjust scaling policies, update autoscaling thresholds in response to metrics, or manage deployment scaling behavior dynamically.",
      "description_length": 449,
      "index": 1543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Namespaces",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes PodPreset management within namespaces, enabling structured access to collections and individual resources. It supports listing, creating, and updating presets using types like PodPresetList and PodPreset, with operations such as label-based retrieval and bulk creation. You can enforce default pod settings across a namespace or remove obsolete presets dynamically before deploying new workloads. Fine-grained REST interactions allow precise control over preset configurations.",
      "description_length": 511,
      "index": 1544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Nodes",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Node resources, providing a `get` function to stream events with support for parameters like `watch`, `timeout_seconds`, and `label_selector` for targeted monitoring. The `By_name` submodule extends this functionality by enabling watches on specific nodes by name, allowing fine-grained tracking of individual node state changes. Both modules work directly with Kubernetes Node objects, enabling real-time observation of node additions, updates, and deletions. Example usage includes monitoring node readiness or tracking node labels across a cluster.",
      "description_length": 597,
      "index": 1545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Podtemplates",
      "library": "kubecaml",
      "description": "This module watches for changes to Pod templates in a Kubernetes cluster by sending HTTP requests to the Kubernetes API. It supports filtering by label and field selectors, limiting results, and controlling request timeouts and versions. Use it to monitor dynamic updates to Pod templates in real time.",
      "description_length": 302,
      "index": 1546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Podsecuritypolicies",
      "library": "kubecaml",
      "description": "This module manages Pod Security Policies in Kubernetes, offering operations to list, create, and delete policies using the Extensions v1beta1 API. It provides direct functions to get, update, and delete named PodSecurityPolicy resources, enabling enforcement of security constraints on pod creation and updates. Key data types include `Pod_security_policy`, `Pod_security_policy_list`, and associated status responses. Example uses include programmatically applying policies to restrict privileged containers or limit filesystem groups.",
      "description_length": 537,
      "index": 1547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module evaluates user permissions within Kubernetes namespaces by creating and submitting LocalSubjectAccessReview requests. It centers on the LocalSubjectAccessReview data type, which defines access evaluation parameters, and includes the `post` function to send reviews and `request_path_template` to construct API paths. For example, it can check whether a user has permission to create a deployment in a specific namespace.",
      "description_length": 432,
      "index": 1548,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authentication.V1.Tokenreviews",
      "library": "kubecaml",
      "description": "This module handles token review requests in a Kubernetes API context. It provides a function to construct the API path and another to send a POST request for validating authentication tokens, returning the reviewed token data or an error. It works directly with Kubernetes token review definitions and is used for authenticating users or service accounts by validating bearer tokens.",
      "description_length": 384,
      "index": 1549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication.V1beta1",
      "library": "kubecaml",
      "description": "This module handles Kubernetes token authentication workflows, processing token reviews and representing authentication outcomes. It defines core types for token specifications, review statuses, and user information, with operations to construct, validate, and serialize these structures. Functions support submitting token reviews, parsing API responses, and extracting user identity details like username, UID, and groups. Example usage includes validating a bearer token, constructing a token review request, or serializing user data for API interactions.",
      "description_length": 558,
      "index": 1550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Subjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles the creation and path resolution for SubjectAccessReview resources in the Kubernetes authorization API. It provides a function to construct the API path template and another to send a POST request for evaluating user access to cluster resources. The module works directly with SubjectAccessReview objects to determine authorization decisions for specific users or groups.",
      "description_length": 391,
      "index": 1551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1.Storageclasses",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes storage classes, enabling operations like listing, creating, and deleting storage class resources for dynamic cluster configuration. It handles v1beta1 storage class definitions and API response structures, supporting tasks such as provisioning new storage classes or retrieving existing ones for monitoring. The child module extends this functionality with RESTful operations for per-name management, allowing retrieval, replacement, deletion, and patching of individual storage classes using types like DeleteOptions and Patch. Together, they enable programmatic updates, policy enforcement, and automated cleanup of storage resources within a Kubernetes environment.",
      "description_length": 726,
      "index": 1552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes CronJob resources by establishing watch streams that capture lifecycle events, status updates, and deletions. It supports filtering through label selectors, field selectors, and resource versioning to ensure consistent, targeted updates. Developers can use it to react dynamically to CronJob changes, such as triggering auto-scaling based on scheduled workloads or updating live dashboards with job statuses. Example applications include scaling systems that adapt to job creation or failure events and monitoring tools that display real-time job state across namespaces.",
      "description_length": 626,
      "index": 1553,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch.V1beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for managing Kubernetes CronJob resources, enabling the creation, inspection, and serialization of cron job configurations, statuses, and templates. Key data types include cron job specifications, status objects with execution state, job templates, and collections of named resources, all supporting JSON conversion for API interaction. Operations allow setting schedules, defining job templates, tracking execution status with optional timestamps and references, and managing groups of CronJobs. Example uses include programmatically generating deployment-ready CronJob manifests, parsing and modifying existing configurations, and tracking active jobs and their execution history in batch v1beta1 format.",
      "description_length": 753,
      "index": 1554,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1.Watch",
      "library": "kubecaml",
      "description": "This module streams real-time events for changes to Horizontal Pod Autoscaler resources in Kubernetes, supporting filtering by namespace, label selectors, and resource version. It provides structured watch events that capture autoscaler configuration updates and scaling actions, such as when an autoscaler triggers a deployment scale based on metric thresholds. The `get` function allows monitoring of specific autoscalers, enabling use cases like tracking when new autoscalers are created or observing scaling decisions as they occur. Example usage includes watching a named autoscaler in a specific namespace to log scaling events or detect configuration changes.",
      "description_length": 666,
      "index": 1555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module watches Kubernetes CronJob resources for real-time creation, update, and deletion events, supporting filtering by labels, fields, and resource versions. It provides operations like `get` to stream events with parameters such as `watch`, `timeout_seconds`, and `label_selector`, enabling precise monitoring of scheduled workloads. Main data types include CronJob definitions and Watch_event types, which capture lifecycle changes and resource states. Example uses include alerting on CronJob scheduling failures or detecting when new CronJobs match a specified selector.",
      "description_length": 581,
      "index": 1556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Persistentvolumes.By_name",
      "library": "kubecaml",
      "description": "This module provides direct HTTP operations to manage Kubernetes PersistentVolumes by name, including retrieving, replacing, deleting, and partially updating volumes. It works with core types like `Persistent_volume.t`, `Delete_options.t`, `Patch.t`, and `Status.t` to support precise control over volume configuration and lifecycle. The status submodule extends this functionality by enabling retrieval and modification of a volume's operational state, allowing use cases such as inspecting current conditions or updating status fields in response to external events. Together, these components enable fine-grained management of storage resources in a Kubernetes cluster.",
      "description_length": 672,
      "index": 1557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes workload resources, including DaemonSets, ReplicaSets, ControllerRevisions, StatefulSets, and Deployments. It supports streaming updates using watch parameters such as label selectors, resource versions, and timeouts, returning structured events for each change. Operations include establishing event streams, filtering updates, and capturing state transitions across workloads. Examples include tracking deployment rollouts, monitoring ReplicaSet scaling, and inspecting ControllerRevision updates as they occur.",
      "description_length": 569,
      "index": 1558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1.Cronjobs",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes CronJob resources via HTTP requests. It provides a `get` function to list or watch CronJob objects with optional filters like label selectors, resource versions, and timeouts, returning a result containing a list of CronJob definitions. The `request_path_template` function generates the base URI path for CronJob-related API endpoints.",
      "description_length": 391,
      "index": 1559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Deployments",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Deployment resources via HTTP requests. It provides a `get` function to list or watch Deployments with optional filters like label selectors, resource versions, and timeouts. The function operates on URIs and returns parsed Deployment list responses or error strings, using the Cohttp library for HTTP communication.",
      "description_length": 371,
      "index": 1560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Roles",
      "library": "kubecaml",
      "description": "This module handles retrieving Role resources from the Kubernetes RBAC API using a GET request. It supports filtering by label and field selectors, pagination with limit and continue parameters, and watching for changes with a resource version. Concrete use cases include listing all Roles in a namespace or watching Role updates for dynamic policy management.",
      "description_length": 360,
      "index": 1561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of various Kubernetes resources including ReplicaSets, Ingresses, DaemonSets, Deployments, NetworkPolicies, and PodSecurityPolicies. It supports streaming events with filtering by label, field, resource version, and timeout, using functions like `get` and path constructors to observe changes at varying granularity. Developers can track updates to specific resources or entire resource types, enabling use cases such as auto-scaling, compliance auditing, service mesh reloads, and deployment validation. The module works directly with Kubernetes API types like `Watch_event`, `Deployment`, and `Network_policy`, allowing precise and typed reactions to cluster state changes.",
      "description_length": 717,
      "index": 1562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Namespaces",
      "library": "kubecaml",
      "description": "This module facilitates permission validation within Kubernetes namespaces by leveraging LocalSubjectAccessReview resources. It centers on the LocalSubjectAccessReview data type, which encapsulates access requests for namespace-scoped actions, and offers the `post` function to submit these checks against the API. The `request_path_template` aids in forming the correct API endpoint for submission. For instance, it can determine whether a user has the right to read pods or modify secrets in a given namespace.",
      "description_length": 512,
      "index": 1563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Endpoints",
      "library": "kubecaml",
      "description": "This module watches for changes to Kubernetes Endpoint resources by sending HTTP GET requests to a templated API path. It supports filtering by label and field selectors, limiting results, and specifying resource versions for consistent watches. A concrete use case is monitoring real-time updates to service endpoints in a cluster for dynamic service discovery.",
      "description_length": 362,
      "index": 1564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides tools for managing and organizing Kubernetes priority classes, allowing users to construct, manipulate, and serialize collections of priority class data. It supports operations to set and retrieve metadata, API version, kind, description, and default status, along with mapping priority class names to numeric values for scheduling configuration. Users can convert priority class lists to and from JSON for persistence or API interaction, enabling precise control over scheduling tiers. Example usage includes defining named priority levels like \"high-priority\" with associated integers and metadata for cluster scheduling policies.",
      "description_length": 653,
      "index": 1565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Validatingwebhookconfigurations",
      "library": "kubecaml",
      "description": "This module manages Kubernetes ValidatingWebhookConfiguration resources through a REST API, supporting list, create, and delete operations across collections of configurations. It uses Cohttp for HTTP transport and returns typed results or errors wrapped in Lwt promises, allowing integration with asynchronous workflows. The child module extends this functionality to individual webhook configurations, enabling retrieval, replacement, deletion, and partial updates by name. Together, they support concrete use cases like managing admission control policies during deployment by interacting with specific webhook configurations or querying across all configured webhooks.",
      "description_length": 672,
      "index": 1566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1.Cronjobs",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes CronJob resources via HTTP requests. It provides a `get` function to list or watch CronJob objects with optional parameters like label selectors, field selectors, and resource versioning. The module works directly with CronJob list data structures and is used for querying scheduled job configurations in a Kubernetes cluster.",
      "description_length": 381,
      "index": 1567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Deployments",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Deployment resources via HTTP requests. It provides a `get` function to list or watch deployments with optional parameters like label selectors, resource versions, and timeouts, returning a result containing a deployment list or an error. The `request_path_template` function generates the base path for deployment-related API requests.",
      "description_length": 391,
      "index": 1568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes events with support for filtering by label, field, and resource version, both globally and within specific namespaces. Core data types include event streams and filter configurations, with operations to subscribe, refine, and retrieve event data. It enables use cases such as tracking pod status changes, observing service updates, or capturing namespace-specific events for automation and debugging. Example usage includes monitoring a service's event stream for modifications or filtering pod events by label selector in real time.",
      "description_length": 589,
      "index": 1569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg.Version",
      "library": "kubecaml",
      "description": "This module captures and manages version metadata, including build date, Git commit, and Go version, providing structured access and serialization via Yojson. It supports constructing version info objects, converting them to and from JSON, and handling list-based JSON representations where each entry pairs a string key with version data. You can use it to programmatically inspect and encode version details for Kubernetes components, enabling structured storage or transmission. For example, it allows serializing version info into JSON for logging or exposing it via an API endpoint.",
      "description_length": 587,
      "index": 1570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes RBAC ClusterRoleBinding resources, supporting core operations like list, watch, create, and delete. It works directly with ClusterRoleBinding and ClusterRoleBindingList types, enabling programmatic access to RBAC configuration. The child module extends this functionality with named operations such as get, put, and patch, allowing precise updates and retrieval of individual bindings. Together, they enable tasks like creating role bindings, modifying access rules, and cleaning up obsolete permissions in a cluster.",
      "description_length": 574,
      "index": 1571,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_name",
      "library": "kubecaml",
      "description": "This module manages Kubernetes namespaces by name, providing direct operations to retrieve, replace, delete, and patch namespace resources using standard HTTP methods over a Cohttp client. It works primarily with `Namespace.t` and `Delete_options.t`, supporting lifecycle actions like deletion with custom grace periods and configuration updates. The first child module specializes in finalizing namespace termination by sending PUT requests to update finalizers, while the second focuses on status management, allowing retrieval, full replacement, or patching of namespace status fields. Together, they enable precise control over namespace state, from creation and modification to termination and cleanup.",
      "description_length": 707,
      "index": 1572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module manages Kubernetes network policies within namespaces, offering structured operations like create, delete, get, and update through HTTP. It works with data types such as NetworkPolicy and NetworkPolicyList, enabling precise control and synchronization of network policies. It supports tasks like enforcing network isolation rules and applying or updating policies across clusters. Example uses include creating a new NetworkPolicy to restrict pod communication or updating an existing policy to modify ingress rules.",
      "description_length": 528,
      "index": 1573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides structured representations and operations for Kubernetes RBAC v1alpha1 resources, including roles, role bindings, cluster roles, and policy rules. It enables constructing, manipulating, and serializing RBAC objects to JSON for API interactions, with data types like `Role_ref`, `Subject`, `Policy_rule`, and `ClusterRoleBinding`. You can define access policies with precise verbs and resources, bind subjects to roles, and aggregate ClusterRoles based on label selectors. Examples include generating RBAC manifests, parsing role bindings from API responses, and programmatically managing fine-grained access controls for users and cluster resources.",
      "description_length": 670,
      "index": 1574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1.Selfsubjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles the creation of self-subject access reviews by providing a function to construct the request path and another to send a POST request with a self-subject access review body. It works with the `Self_subject_access_review.t` type and interacts with HTTP clients via `Cohttp_lwt_unix`. It is used to determine whether the current user is allowed to perform specific actions within a Kubernetes cluster.",
      "description_length": 418,
      "index": 1575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1.Mutatingwebhookconfigurations",
      "library": "kubecaml",
      "description": "This module manages Kubernetes mutating webhook configurations through HTTP operations for listing, creating, and deleting resources, using URIs and Kubernetes API objects like `Mutating_webhook_configuration` and `Status`. Its child module extends this functionality by allowing fine-grained manipulation of named configurations, including retrieval, replacement, partial updates, and deletion with support for `Delete_options`, headers, and context. Together, they enable comprehensive control over admission control policies by interacting directly with the Kubernetes API. Example tasks include registering a new mutating webhook, updating an existing configuration, or removing deprecated webhooks from a cluster.",
      "description_length": 718,
      "index": 1576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Subjectaccessreviews",
      "library": "kubecaml",
      "description": "This module handles the creation and path resolution for SubjectAccessReview resources in the Kubernetes Authorization API. It provides a function to construct the API path template and another to send a SubjectAccessReview request, returning the evaluated authorization result. It works directly with Kubernetes SubjectAccessReview definitions to determine user permissions for specific actions.",
      "description_length": 396,
      "index": 1577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Podsecuritypolicies",
      "library": "kubecaml",
      "description": "This module manages Kubernetes Pod Security Policies by providing operations to list, create, and delete policies, working directly with API objects like `Pod_security_policy` and `Pod_security_policy_list`. It supports enforcement of security constraints on pod creation, retrieval of policy configurations, and resource cleanup. The child module enables fine-grained CRUD operations on named policies, allowing updates, patches, and deletions using Kubernetes types such as `Delete_options` and `Patch`. Together, they facilitate full lifecycle management of Pod Security Policies within a cluster.",
      "description_length": 600,
      "index": 1578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1.Selfsubjectrulesreviews",
      "library": "kubecaml",
      "description": "Implements operations for querying and creating SelfSubjectRulesReview resources in the Kubernetes Authorization API. It provides a function to construct the request path and another to send a POST request with a SelfSubjectRulesReview body, returning the server's response. This module is used to determine the set of rules that apply to the current user for a given namespace.",
      "description_length": 378,
      "index": 1579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Services",
      "library": "kubecaml",
      "description": "Implements functions to watch for changes to Kubernetes Service resources via the API, supporting operations like `get` with customizable query parameters such as `watch`, `timeout_seconds`, and `label_selector`. Works with data types including `Uri.t` for request configuration and `Watch_event.t` to represent change events. Enables real-time monitoring of Service resource updates in a cluster, such as tracking when new Services are created or existing ones are modified.",
      "description_length": 475,
      "index": 1580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Controllerrevisions",
      "library": "kubecaml",
      "description": "Implements operations for retrieving and watching ControllerRevision resources in a Kubernetes cluster. Works with Kubernetes API objects like `Controller_revision_list` and uses standard query parameters for filtering, pagination, and resource versioning. Useful for tracking revisions of stateful workloads during deployment rollouts or rollbacks.",
      "description_length": 349,
      "index": 1581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1alpha1",
      "library": "kubecaml",
      "description": "This module suite provides structured handling of Kubernetes volume attachment workflows, from request creation to status tracking and error reporting. Core data types include volume attachment specifications, sources, statuses, and error records, organized with metadata and conversion capabilities to and from JSON. Operations allow constructing attach/detach intents, serializing configurations for API requests, parsing responses, and managing structured error data. Example uses include programmatically building a volume attachment request with a specified attacher and node name, converting it to JSON for API submission, and processing the resulting status or error information.",
      "description_length": 686,
      "index": 1582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Replicasets",
      "library": "kubecaml",
      "description": "This module handles retrieving ReplicaSet resources from the Kubernetes API by providing a `get` function with parameters for filtering, pagination, and streaming. It works with ReplicaSetList data structures and supports use cases like listing all ReplicaSets in a namespace or watching for changes to ReplicaSets in real time. The `request_path_template` function generates the base API path used for these operations.",
      "description_length": 420,
      "index": 1583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions.V1beta1",
      "library": "kubecaml",
      "description": "This collection provides structured access to Kubernetes v1beta1 API objects and subresources, focusing on deployment, scaling, networking, and security configurations. Core data types include ReplicaSet, DaemonSet, Deployment, Ingress, NetworkPolicy, and PodSecurityPolicy, each with associated specs, statuses, and conditions, along with utilities for JSON serialization and deserialization. Operations allow programmatic construction, inspection, and modification of Kubernetes resources, such as defining rolling update strategies, configuring TLS for Ingress, enforcing pod security constraints, and managing network traffic rules. Example uses include automating deployment rollouts with controlled surge limits, defining ingress routing with path-based backends, enforcing host path and group ID restrictions in security policies, and scaling ReplicaSets via the Kubernetes API.",
      "description_length": 885,
      "index": 1584,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization.V1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive framework for evaluating and managing authorization decisions in Kubernetes, centered around structured representations of access control rules, subject access reviews, and authorization attributes. Key data types include specifications for resource and non-resource access, rule sets with wildcards, and review outcomes with metadata, all supporting serialization to and from JSON. Operations allow constructing, inspecting, and validating permissions for users or groups across namespaces, such as checking if a user can create a pod, defining access policies for API endpoints, or auditing allowed actions in a cluster.",
      "description_length": 659,
      "index": 1585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps.V1",
      "library": "kubecaml",
      "description": "This module provides structured representations and operations for managing Kubernetes workload resources including Deployments, DaemonSets, StatefulSets, and ReplicaSets. It defines core data types like specifications, statuses, and update strategies with support for JSON serialization and deserialization via Yojson, enabling integration with Kubernetes APIs. Users can configure rolling updates with parameters such as `max_surge`, `max_unavailable`, and `partition`, track runtime conditions and states, and manage collections of resources using key-value mappings. Example uses include defining a Deployment with a rolling update strategy, inspecting DaemonSet status across nodes, or serializing StatefulSet configurations for cluster deployment.",
      "description_length": 753,
      "index": 1586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Clusterrolebindings",
      "library": "kubecaml",
      "description": "This module provides HTTP-based management of Kubernetes RBAC ClusterRoleBinding resources, supporting operations like listing, watching, creating, and bulk-deleting bindings through direct API interactions. It works primarily with ClusterRoleBinding and ClusterRoleBindingList types, enabling programmatic access to cluster-level role binding data. The child module extends this functionality with per-name CRUD operations, allowing precise retrieval, update, and deletion of individual bindings using path templates and Kubernetes RBAC options. Together, they enable tasks like synchronizing binding states, enforcing access policies, or automating cleanup of obsolete cluster roles.",
      "description_length": 685,
      "index": 1587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Rolebindings",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching RoleBinding resources in the Kubernetes RBAC API. It provides operations to list or watch RoleBinding objects with support for filtering, pagination, and connection settings. Use this module to interact with RBAC role bindings in a cluster, such as listing all role bindings or watching for changes in real time.",
      "description_length": 356,
      "index": 1588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Daemonsets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching DaemonSet resources from a Kubernetes API server. It provides a `get` function to list or watch DaemonSets with options like label selectors, resource version, and timeouts, returning a result containing a DaemonSet list or an error. The module works directly with Kubernetes DaemonSet definitions and integrates with Cohttp for HTTP communication.",
      "description_length": 392,
      "index": 1589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1.Watch",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Horizontal Pod Autoscaler resources in Kubernetes, tracking lifecycle events such as scaling actions and configuration changes. It supports filtering through label selectors, resource version synchronization, and named autoscaler tracking with timeout control. Key data types include event streams and autoscaler configurations, allowing users to stream all scaling events or focus on specific autoscalers. Example uses include observing autoscaling behavior across a namespace or tracking a single autoscaler's activity within a defined time window.",
      "description_length": 594,
      "index": 1590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Daemonsets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes DaemonSet resources via HTTP requests. It provides the `get` function to list or watch DaemonSet objects with optional parameters like label selectors, resource versions, and timeouts. The module works directly with Kubernetes API definitions for DaemonSets and returns structured results in an Lwt async context.",
      "description_length": 368,
      "index": 1591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time monitoring of Kubernetes RBAC resources, including Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings. It supports streaming events with filtering by label, field, resource version, and timeout settings, enabling precise tracking of permission changes across namespaces or the entire cluster. Operations include `get` to watch all resources or `By_name` submodules for targeted observation of specific roles or bindings. Example uses include auditing role modifications, synchronizing RBAC policies, and implementing dynamic access control that reacts to changes as they occur.",
      "description_length": 616,
      "index": 1592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Resourcequotas",
      "library": "kubecaml",
      "description": "Implements functions to watch for changes to ResourceQuota objects in a Kubernetes cluster. It provides a `get` function that initiates a watch request with customizable parameters such as timeout, resource version, and label selectors, returning a stream of watch events. This module is used to monitor real-time updates or deletions of ResourceQuota resources in Kubernetes.",
      "description_length": 376,
      "index": 1593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1.Customresourcedefinitions",
      "library": "kubecaml",
      "description": "This module manages Kubernetes custom resource definitions (CRDs) through a combination of direct API operations and named resource manipulation. It supports listing and watching CRDs across the cluster, creating new CRDs, and deleting multiple CRDs in bulk, while child modules enable per-CRD operations such as `get`, `put`, `delete`, and `patch` for precise control over individual resources. The API centers on CRD and delete option data types, allowing status updates, spec modifications, and targeted cleanup actions using a customizable base URI and Kubernetes v1beta1 types. Example workflows include dynamically extending the Kubernetes API by creating a CRD, updating its status via HTTP patch, or cleaning up multiple CRDs using filtered delete requests.",
      "description_length": 765,
      "index": 1594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1.Clusterroles",
      "library": "kubecaml",
      "description": "This module provides HTTP client operations for managing Kubernetes RBAC cluster roles, enabling actions such as listing, watching, creating, and deleting roles across the cluster. It handles full lifecycle operations for individual roles via submodules that support direct manipulation by name, including `GET`, `PUT`, `DELETE`, and `PATCH` requests using types like `Cluster_role.t`, `Delete_options.t`, and `Patch.t`. You can use it to retrieve existing cluster roles, define new roles with specific permissions, or remove outdated configurations. Specific operations include watching for role changes, creating a role with custom rules, and performing partial updates to existing roles using strategic merge patches.",
      "description_length": 720,
      "index": 1595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Replicationcontrollers",
      "library": "kubecaml",
      "description": "This module watches for changes to ReplicationController resources in a Kubernetes cluster. It provides a `get` function to stream events based on resource version, label selectors, and field selectors, returning typed watch events or error messages. Use it to monitor scaling events or pod status changes in real-time.",
      "description_length": 319,
      "index": 1596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage.V1",
      "library": "kubecaml",
      "description": "This module provides structured representations and utilities for working with Kubernetes storage classes, enabling the creation, manipulation, and serialization of both individual storage class objects and collections. It defines core types like `t` and `Object_meta.t`, and supports operations such as setting provisioner parameters, managing reclaim policies, and converting to and from JSON using `Yojson`. You can use it to parse and generate storage class configurations from files or API responses, validate metadata, or prepare policy-compliant storage specs for deployment. Example workflows include constructing a storage class from JSON, modifying its mount options, or building a storage class list for cluster configuration.",
      "description_length": 737,
      "index": 1597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authentication.V1beta1.Tokenreviews",
      "library": "kubecaml",
      "description": "This module handles token review requests in a Kubernetes authentication context. It provides a function to construct the API path template and another to send a POST request for validating authentication tokens, returning the reviewed token data or an error. It works directly with Kubernetes token review objects and is used for authenticating users or service accounts by validating bearer tokens against a Kubernetes cluster.",
      "description_length": 429,
      "index": 1598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1.Rolebindings",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching RoleBinding resources in a Kubernetes cluster. It provides operations to list RoleBinding objects with optional filtering, pagination, and streaming via the `get` function, using a structured API path template. The module works directly with RoleBinding and RoleBindingList types, supporting use cases such as role-based access control monitoring and policy validation.",
      "description_length": 413,
      "index": 1599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Namespaces",
      "library": "kubecaml",
      "description": "This module offers HTTP-based management of Kubernetes workload resources within a namespace, focusing on stateful and replicated applications. It supports operations on key data types such as StatefulSet, ReplicaSet, DaemonSet, Deployment, and ControllerRevision, enabling creation, deletion, scaling, patching, and status inspection. Submodules provide fine-grained control for adjusting replica counts and applying configuration updates. Example uses include deploying a StatefulSet, scaling a ReplicaSet in response to load, or updating a Deployment's configuration.",
      "description_length": 570,
      "index": 1600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1.Priorityclasses",
      "library": "kubecaml",
      "description": "This module provides HTTP-based operations for managing Kubernetes priority classes at both the collection and individual resource levels. It supports listing and deleting priority class collections with custom query parameters, while its child module enables direct CRUD operations on individual priority classes by name, using types like `Priority_class.t`, `Delete_options.t`, and `Patch.t`. Key operations include creating, retrieving, updating, and deleting priority classes to control pod scheduling priorities and enforce resource policies in clusters. Together, the module and its child provide a complete interface for interacting with Kubernetes scheduling priority configurations.",
      "description_length": 691,
      "index": 1601,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling.V2beta1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive framework for defining, managing, and serializing Kubernetes horizontal pod autoscaling configurations based on diverse metric sources. It includes structured types for resource, pod, object, and external metrics, along with conditions, statuses, and references that enable precise scaling decisions driven by real-time data from both in-cluster and off-cluster sources. Operations allow constructing autoscaler specs with min/max replicas and metric thresholds, inspecting current metric values and autoscaler states, and converting configurations to and from JSON for API interaction. Example uses include scaling deployments based on CPU utilization, Ingress request rates, or cloud queue lengths, with full support for programmatic configuration, monitoring, and integration with Kubernetes autoscaling APIs.",
      "description_length": 849,
      "index": 1602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy.V1beta1",
      "library": "kubecaml",
      "description": "This module provides comprehensive support for managing Kubernetes security and disruption policies through structured data types and JSON serialization. It includes types for Pod Disruption Budgets, SELinux strategies, Flexvolume drivers, host paths, ID ranges, and eviction requests, along with operations to construct, inspect, and serialize these policies. You can define Pod Security Policies with constraints on user IDs, supplemental groups, and volume plugins, or manage disruption budgets to control pod evictions during updates. Specific examples include enforcing SELinux contexts like `system_u:object_r:container_file_t`, defining allowed host paths, or specifying eviction policies that preserve availability during rolling deployments.",
      "description_length": 750,
      "index": 1603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces.By_namespace",
      "library": "kubecaml",
      "description": "This module provides structured access to Kubernetes namespace-scoped resources, enabling precise management of core components like ConfigMaps, Secrets, Services, and Pods through direct integration with the Kubernetes API. It supports standard CRUD operations\u2014get, put, delete, patch\u2014on native data types such as `Service.t`, `Pod.t`, `Secret.t`, and their list counterparts, allowing for resource creation, modification, deletion, and real-time monitoring. Specific capabilities include programmatically updating application configurations via ConfigMaps, managing service accounts for access control, inspecting and evicting Pods, and synchronizing resource quotas or persistent volume claims with cluster requirements. Submodules extend these operations with specialized functionality like status updates, log streaming, and HTTP proxying to enable comprehensive cluster automation and introspection.",
      "description_length": 905,
      "index": 1604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1.Controllerrevisions",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes ControllerRevision resources via HTTP requests. It provides the `get` function to list or watch ControllerRevision objects with options like label selectors, field selectors, and resource versioning. The module works directly with Kubernetes API objects and integrates with the Cohttp library for HTTP communication.",
      "description_length": 371,
      "index": 1605,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1.Podpresets",
      "library": "kubecaml",
      "description": "Implements retrieval of PodPreset resources from the Kubernetes API, supporting operations like listing and watching with customizable parameters such as label selectors, resource version, and timeouts. Works with PodPreset objects and related list types, handling HTTP requests and responses via Cohttp. Useful for integrating Kubernetes PodPreset management into OCaml applications, such as synchronizing configuration presets with cluster state or automating pod initialization workflows.",
      "description_length": 491,
      "index": 1606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2.Statefulsets",
      "library": "kubecaml",
      "description": "Implements operations for retrieving StatefulSet resources from the Kubernetes API. It provides a `get` function to list or watch StatefulSet objects with support for filtering, pagination, and connection settings. Works directly with Kubernetes StatefulSet definitions and integrates into workflows requiring dynamic stateful workload management.",
      "description_length": 347,
      "index": 1607,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Ingresses",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Ingress resources via HTTP requests. It provides a `get` function to list or watch Ingress objects with optional filters like label and field selectors, and returns a result containing an Ingress list or an error. The `request_path_template` function generates the API path template used for these operations.",
      "description_length": 364,
      "index": 1608,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch.Namespaces",
      "library": "kubecaml",
      "description": "This module enables real-time monitoring of Kubernetes Namespace resources and their sub-resources through a streaming API. It provides functions to initiate watch requests with customizable parameters such as timeout, resource version, and label selectors, and supports filtering by name or subpaths for targeted observation. The main data types include watch streams and result types indicating success or failure, while operations allow tracking of Namespace lifecycle events and internal resource changes. Specific use cases include monitoring Namespace creation or deletion, tracking Pod status transitions, observing ConfigMap updates, and reacting to Service configuration changes as they occur.",
      "description_length": 702,
      "index": 1609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1.Statefulsets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes StatefulSet resources via HTTP requests. It provides a `get` function to list or watch StatefulSets with optional query parameters like label selectors, resource version, and timeouts. The function operates on URIs and returns a result containing a StatefulSet list or an error string, suitable for integration into Kubernetes control loops or monitoring tools.",
      "description_length": 416,
      "index": 1610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1.Poddisruptionbudgets",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching PodDisruptionBudget resources from the Kubernetes API. It provides the `get` function to list or watch PodDisruptionBudget objects with optional filtering and pagination parameters. The module works directly with PodDisruptionBudgetList data structures and integrates with Lwt for asynchronous HTTP requests.",
      "description_length": 352,
      "index": 1611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1.Networkpolicies",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes NetworkPolicy resources via HTTP requests. It provides operations to list or watch network policies with optional filters like label selectors, resource versions, and pagination. The module works directly with Kubernetes API objects such as `Network_policy_list` and interacts with cluster network policies for monitoring or management use cases.",
      "description_length": 401,
      "index": 1612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1.Clusterroles",
      "library": "kubecaml",
      "description": "This module manages Kubernetes RBAC cluster roles through HTTP operations, enabling creation, deletion, and enumeration of cluster-wide roles. It operates on core types like `Cluster_role`, `Cluster_role_list`, and `Status`, offering functions to query and modify role configurations programmatically. The child module extends this functionality with fine-grained CRUD operations using HTTP verbs such as `put`, `get`, `patch`, and `delete`. Together, they support use cases like automating cluster-wide permission provisioning and inspecting RBAC policies in running clusters.",
      "description_length": 577,
      "index": 1613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Componentstatuses.By_name",
      "library": "kubecaml",
      "description": "Implements retrieval of Kubernetes ComponentStatus resources by name through HTTP requests. It operates on URIs and returns typed results containing ComponentStatus data or error messages. Useful for querying cluster component health directly from OCaml applications.",
      "description_length": 267,
      "index": 1614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V1",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes autoscaling workflows by retrieving API resources, managing horizontal pod autoscalers, and handling namespace-scoped scaling policies. It exposes core types like `Horizontal_pod_autoscaler`, `Namespace`, and `Watch_event`, enabling operations such as listing available autoscaling resources, applying scaling policies to deployments, and streaming real-time updates. Submodules enhance this functionality by supporting filtered watches on autoscaler events, partial updates to autoscaler configurations, and structured access to autoscaler lists with metadata. Example workflows include dynamically adjusting CPU-based scaling thresholds, monitoring autoscaler changes across namespaces, and logging scale events triggered by metric violations.",
      "description_length": 781,
      "index": 1615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Batch",
      "library": "kubecaml",
      "description": "This module offers a structured interface for managing Kubernetes batch and cron job resources, providing data types such as `Job`, `Job_spec`, `Job_status`, `CronJob`, and `Job_template`. It supports operations to define schedules, configure job parameters, track execution states with conditions and timestamps, and serialize configurations to JSON for API interaction or persistence. You can create custom job definitions with parallelism settings, define cron jobs with concurrency policies, and inspect or update job statuses with execution details. Example uses include generating deployment-ready manifests, monitoring job completion, and synchronizing execution history with API responses.",
      "description_length": 697,
      "index": 1616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Scheduling",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes priority class data, enabling structured management of scheduling tiers through named priority levels. It supports creating and manipulating priority classes with metadata, API version, kind, description, and default status, along with mapping names to numeric values. Operations include serializing to and from JSON for persistence or API interaction, allowing precise control over cluster scheduling policies. Example usage includes defining a \"high-priority\" class with a numeric value of 1000 and associated metadata for use in scheduling configurations.",
      "description_length": 591,
      "index": 1617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1alpha1",
      "library": "kubecaml",
      "description": "This module orchestrates interactions with Kubernetes admission registration resources, combining direct access to API discovery and request path construction with real-time monitoring and RESTful management of initializer configurations. It enables developers to list supported admission resources, establish watches for live updates, and perform create, read, update, and delete operations on initializer configurations across the cluster. With support for filtering, pagination, and per-name observation, it facilitates dynamic policy updates and cluster-wide configuration tracking. Example workflows include streaming changes to initializer configurations and programmatically modifying admission control rules in response to observed events.",
      "description_length": 747,
      "index": 1618,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1beta1",
      "library": "kubecaml",
      "description": "This module provides direct access to Kubernetes storage APIs for managing storage classes and volume attachments through HTTP requests, supporting operations like list, get, create, update, and delete. It integrates real-time watch capabilities for tracking changes to these resources, allowing filtered subscriptions to events based on labels, fields, or resource versions. The core data types include storage class definitions and volume attachment metadata, with structured event streams for observing additions, modifications, and deletions. Users can, for example, query available storage classes, monitor the status of specific volume attachments, or automate configuration updates in response to dynamic cluster needs.",
      "description_length": 726,
      "index": 1619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Certificates",
      "library": "kubecaml",
      "description": "This module handles the creation, manipulation, and serialization of certificate signing requests (CSRs) and related data in Kubernetes. It provides data types for CSR specifications, conditions, statuses, and lists, supporting operations like CSR encoding/decoding in PKCS#10 format, status updates with metadata such as username and groups, and JSON serialization via Yojson. You can generate base64-encoded CSRs for TLS bootstrapping, modify approval states with timestamps, or convert API responses into structured OCaml values for further processing.",
      "description_length": 555,
      "index": 1620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions.V1beta1",
      "library": "kubecaml",
      "description": "This module orchestrates low-level interactions with Kubernetes API extensions, combining direct utilities for API resource discovery and path construction with specialized submodules for CRD lifecycle management and real-time event tracking. It exposes core operations like retrieving API versions and building request URIs, while its child modules enable both bulk and per-resource CRD actions\u2014such as creation, deletion, patching, and versioned watches\u2014alongside streaming event observation with label filtering and timeouts. Key data types include CRD specifications, delete options, and event streams, supporting workflows like dynamic API extension, automated CRD cleanup, and real-time synchronization with cluster state changes. Example uses include watching for CRD updates to trigger configuration reloads, creating CRDs to extend cluster capabilities, and tracking resource deletions to maintain external system consistency.",
      "description_length": 935,
      "index": 1621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Events",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Event objects via the API. It provides a `get` function to list or watch events with optional parameters like label selectors, resource versions, and timeouts, returning an Event_list result. The module works directly with Kubernetes v1 Event definitions and integrates with Cohttp for HTTP communication.",
      "description_length": 360,
      "index": 1622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling.V2beta1",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes autoscaling operations through typed HTTP interactions, namespace-scoped resource discovery, and real-time event monitoring. It exposes core types like `Horizontal_pod_autoscaler`, `Horizontal_pod_autoscaler_list`, and event streams, enabling creation, deletion, querying, and observation of autoscaling resources. You can list autoscalers filtered by labels, watch scaling events in real time, or configure new policies based on metrics like CPU usage. Direct API functions for request path construction and API resource discovery integrate with submodules to support both imperative control and declarative monitoring of autoscaling behavior.",
      "description_length": 680,
      "index": 1623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Configmaps",
      "library": "kubecaml",
      "description": "This module handles HTTP requests for watching or retrieving Kubernetes ConfigMap resources. It supports operations like `get` with parameters for filtering, pagination, and streaming, returning typed ConfigMap list results. It works directly with ConfigMap definitions and interacts over HTTP using Cohttp types.",
      "description_length": 313,
      "index": 1624,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1",
      "library": "kubecaml",
      "description": "This module orchestrates interactions with Kubernetes API resources, enabling discovery of available workloads and structured access to their metadata and lifecycle operations. It coordinates with submodules to provide real-time observation, retrieval, and manipulation of Deployments, DaemonSets, StatefulSets, ReplicaSets, and ControllerRevisions, using typed data structures like `Deployment.t` and `Controller_revision_list.t`. You can list available resources, watch for changes with label or field filters, or perform `get`, `put`, `patch`, and `delete` operations on specific workloads within a namespace. For example, you can monitor Deployment rollouts, scale StatefulSets, track ControllerRevision updates, or watch DaemonSet node status across a cluster.",
      "description_length": 765,
      "index": 1625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Persistentvolumeclaims",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching persistent volume claim resources from a Kubernetes API server. It provides a `get` function to list or watch persistent volume claims with options like label selectors, field selectors, and resource versioning, returning a result containing a list of claims or an error. The `request_path_template` function generates the base path for constructing API requests targeting persistent volume claims.",
      "description_length": 442,
      "index": 1626,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Storage",
      "library": "kubecaml",
      "description": "This module manages Kubernetes storage resources, including volume attachments and storage classes, with structured types for specifications, statuses, and errors. It supports creating, modifying, and serializing storage configurations to JSON for API interaction, enabling workflows like defining storage tiers, tracking attachment states, and handling structured error data. Users can build volume attachment requests, configure storage classes with custom parameters, and process status updates or errors from the API. Example uses include generating a storage class for SSD volumes, constructing an attach request with a specified node, and parsing API responses into structured status or error records.",
      "description_length": 707,
      "index": 1627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Resourcequotas",
      "library": "kubecaml",
      "description": "Implements operations to retrieve and monitor Kubernetes ResourceQuota objects via HTTP requests. It handles Resource_quota_list data structures, supporting list and watch semantics with parameters like label selectors, field selectors, and pagination. Useful for querying quota usage across namespaces or tracking quota changes in real-time.",
      "description_length": 342,
      "index": 1628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator.Pkg",
      "library": "kubecaml",
      "description": "This module enables structured management of Kubernetes API services using typed representations for configurations, references, and health states. Key data types include service specifications with priority and TLS settings, optional namespace and name references, and condition tracking for status transitions. Operations allow constructing, modifying, and inspecting services, such as loading configurations from files, updating TLS parameters, and exporting to JSON. Example uses include registering backend servers, organizing services by label or version, and querying service status within a cluster.",
      "description_length": 607,
      "index": 1629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta2",
      "library": "kubecaml",
      "description": "This module manages Kubernetes controller resources through HTTP operations, enabling listing, watching, and retrieving Deployments, DaemonSets, StatefulSets, ReplicaSets, and ControllerRevisions with customizable filters and streaming. It supports real-time monitoring of workload changes, version tracking during rollouts, and namespace-scoped management of stateful and replicated applications. Key data types include DeploymentList, ReplicaSetList, StatefulSet, DaemonSet, and ControllerRevision, with operations for filtering by label, resource version, or timeout. Example uses include streaming Deployment updates, scaling ReplicaSets dynamically, tracking ControllerRevision history, and inspecting StatefulSet status in real time.",
      "description_length": 739,
      "index": 1630,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery.Pkg",
      "library": "kubecaml",
      "description": "This module provides utilities for representing and manipulating Kubernetes API values with support for polymorphic types, resource quantities, deferred decoding, structured metadata, and version information. Key data types include tagged integers and strings, resource quantities with unit parsing, raw extension wrappers, label selectors, and version metadata. Operations span JSON serialization, value construction, selective unmarshaling, and structured encoding of Kubernetes objects. Examples include converting resource limits like `\"2Gi\"` into typed values, deferring decoding of custom resource fields, constructing label selectors for deployments, and serializing version details for logging or API exposure.",
      "description_length": 718,
      "index": 1631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1beta1",
      "library": "kubecaml",
      "description": "This module manages authorization workflows in Kubernetes by creating and evaluating access reviews for users, groups, and service accounts across cluster and namespace scopes. It provides direct functions to construct API paths and submit review requests, working with types like `SubjectAccessReview`, `LocalSubjectAccessReview`, and `SelfSubjectRulesReview` to validate permissions. For example, it can check if a user can create pods in a namespace or if the current account has permissions to delete services. Submodules specialize in self-subject reviews, subject rules, and namespace-scoped access checks, enabling precise policy evaluation and enforcement.",
      "description_length": 664,
      "index": 1632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration.V1beta1",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes admission control by managing webhook configurations and API resource discovery. It enables constructing request paths, retrieving resource lists, and interfacing with both validating and mutating webhooks through REST and streaming watch mechanisms. The module supports real-time monitoring of configuration changes, CRUD operations on individual or collections of webhook configurations, and fine-grained updates with support for labels, timeouts, and context-aware requests. Example tasks include dynamically tracking webhook updates, deploying new admission policies, or querying cluster resources to construct targeted API requests.",
      "description_length": 673,
      "index": 1633,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Replicationcontrollers",
      "library": "kubecaml",
      "description": "This module handles HTTP requests for listing or watching Kubernetes ReplicationController resources. It provides a `get` function that accepts query parameters like `label_selector`, `field_selector`, and `watch` to filter and stream updates from the Kubernetes API. The function operates on URIs and returns parsed ReplicationController list data or error messages.",
      "description_length": 367,
      "index": 1634,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Podtemplates",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching PodTemplate resources from the Kubernetes API. It provides a `get` function to list or watch PodTemplates with optional parameters like label selectors, field selectors, and resource versions. The function operates on URIs and returns a result containing a PodTemplate list or an error message.",
      "description_length": 338,
      "index": 1635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authentication",
      "library": "kubecaml",
      "description": "This module implements Kubernetes token authentication workflows, focusing on constructing, validating, and serializing token review requests and responses. It defines core data types including token specifications, review statuses, and user information structures, with operations to encode and decode these to and from JSON. You can use it to validate bearer tokens, extract user identity details such as username and groups, and generate structured authentication responses for API server interactions. Example workflows include processing incoming token reviews, validating user identities, and returning JSON-formatted results during webhook authentication.",
      "description_length": 662,
      "index": 1636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Componentstatuses",
      "library": "kubecaml",
      "description": "This module provides HTTP-based access to Kubernetes ComponentStatus resources, allowing retrieval of control plane component health by name or with filters like `field_selector` and `label_selector`. It supports pagination via `limit` and `continue`, returning typed v1 API responses representing components such as etcd or kube-scheduler. The child module enables direct lookups by name, while the parent handles broader queries, together offering a complete interface for monitoring cluster component status from OCaml. Example usage includes checking the health of etcd instances or verifying scheduler availability across a cluster.",
      "description_length": 637,
      "index": 1637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver.Pkg",
      "library": "kubecaml",
      "description": "This module suite enables the definition, validation, and serialization of Kubernetes API structures, especially CRDs, with support for JSON schemas, validation rules, and subresource configurations. Key data types include CRD metadata, status conditions, and scale settings, manipulated through encoding, decoding, and validation operations compatible with `Yojson` and OpenAPI. It supports defining custom validation logic, configuring autoscaling via JSON paths, and ensuring schema compliance. Example uses include preparing CRDs for cluster registration, validating API extensions, and managing custom resource status and naming.",
      "description_length": 634,
      "index": 1638,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Autoscaling",
      "library": "kubecaml",
      "description": "This module enables programmatic management of Kubernetes autoscaling configurations through structured types and operations for horizontal pod autoscalers and scale subresources. It supports key data types such as autoscaler specifications, metric sources (resource, pod, object, external), and status objects, with operations to set replica bounds, track metrics, and serialize configurations to JSON/YAML. Users can define autoscaling policies based on CPU utilization, Ingress request rates, or cloud queue lengths, inspect current metric values, and update autoscaler settings for dynamic scaling decisions. Example workflows include building and deploying autoscaling rules for deployments or stateful sets based on real-time cluster or external metrics.",
      "description_length": 760,
      "index": 1639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1",
      "library": "kubecaml",
      "description": "This module provides Kubernetes storage class management and monitoring capabilities, combining direct API access with submodules for precise control. It handles core operations like listing available classes, constructing API request paths, and watching for resource changes in real time. The HTTP management submodule supports CRUD actions, such as creating, retrieving, and deleting storage classes, while the watch submodule enables streaming updates and version-controlled lookups. Specific use cases include automating storage provisioning, enforcing policies, and maintaining up-to-date cluster storage state.",
      "description_length": 616,
      "index": 1640,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Apps",
      "library": "kubecaml",
      "description": "This module offers structured representations and operations for modeling and managing Kubernetes workload resources, including Deployments, StatefulSets, DaemonSets, and ReplicaSets. It centers around key data types such as Specs, Statuses, Scale subresources, and ControllerRevisions, enabling precise configuration of update strategies, scaling parameters, and state tracking. Operations include constructing and modifying resource definitions, inspecting runtime conditions, and serializing or deserializing data to and from JSON for API interaction. Example uses include defining a StatefulSet with a custom rolling update strategy, tracking Deployment health through status conditions, or encoding a DaemonSet configuration for transmission to a cluster.",
      "description_length": 760,
      "index": 1641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Nodes",
      "library": "kubecaml",
      "description": "This module handles Kubernetes Node management through HTTP requests, supporting operations like listing, creating, and deleting nodes while working directly with Node and NodeList data structures. It enables concrete use cases such as provisioning worker nodes, monitoring status changes, and cleaning up decommissioned nodes. The module provides fine-grained access through submodules: one offers proxy-based interaction with node-level endpoints for diagnostics and resource management, while the other focuses on precise node status updates and health checks without full object replacement. Together, they allow detailed control over node lifecycle and state, including label updates, condition modifications, and partial object patches.",
      "description_length": 742,
      "index": 1642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking.V1",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes networking operations by managing network policies and namespaces, while integrating resource discovery and request path construction for networking endpoints. It coordinates with submodules that list, watch, and track changes to NetworkPolicy resources, enabling real-time responses to policy modifications across namespaces using label and field filters. Structured operations for creating, updating, and deleting policies allow enforcement of network isolation rules, such as restricting pod communication or modifying ingress rules. Developers can stream policy updates, synchronize security configurations, or trigger actions like firewall adjustments when policies change.",
      "description_length": 714,
      "index": 1643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Serviceaccounts",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes ServiceAccount resources via the API. It provides a `get` function to list or watch ServiceAccount objects with optional parameters like label selectors, field selectors, and resource versioning. The module works directly with ServiceAccountList data structures and integrates with HTTP clients for API communication.",
      "description_length": 372,
      "index": 1644,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1beta1",
      "library": "kubecaml",
      "description": "This module interacts with Kubernetes batch v1beta1 APIs to manage cron jobs, namespaces, and watch operations, providing functions to retrieve API resources and construct request paths using types like `Api_resource_list` and `Uri.t`. It supports scheduling batch jobs, monitoring resource changes, and querying batch endpoints. The CronJob submodule enables creating, listing, and deleting cron jobs with status updates, while the Watch submodule streams real-time events for cron job lifecycle changes. The Http submodule handles listing and watching cron jobs via HTTP with filters like label selectors and timeouts, generating request paths for API endpoints.",
      "description_length": 664,
      "index": 1645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage.V1alpha1",
      "library": "kubecaml",
      "description": "This module handles Kubernetes storage API operations, focusing on volume attachments and real-time watch events. It provides functions to retrieve API resources, manage storage volumes, and monitor resource changes using Cohttp for HTTP requests and structured responses. The main data types include VolumeAttachment and VolumeAttachmentList, with operations to list, create, delete, and watch these resources across a cluster. Specific use cases include automating volume lifecycle management, tracking attachment status, and responding dynamically to storage events like volume attachment or detachment.",
      "description_length": 606,
      "index": 1646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Endpoints",
      "library": "kubecaml",
      "description": "This module handles retrieving and watching Kubernetes Endpoints resources via HTTP requests. It provides a `get` function to list or watch endpoints with optional parameters like label selectors, field selectors, and resource versions. The module works with Kubernetes V1 Endpoints data structures and is used for interacting with the Kubernetes API to manage network endpoints for services.",
      "description_length": 392,
      "index": 1647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates.V1beta1",
      "library": "kubecaml",
      "description": "This module interacts with Kubernetes certificates APIs to manage certificate signing requests and enable real-time monitoring of resource changes. It provides operations for retrieving available resources, constructing API paths, and handling certificate issuance workflows using resource lists and request definitions. The main data types include `Certificate_signing_request`, `Certificate_signing_request_list`, and watch events, with core operations for list, create, delete, patch, and status updates. Users can automate approval workflows, monitor request statuses dynamically, or react to new certificate signing requests using configurable watch streams and per-name tracking.",
      "description_length": 685,
      "index": 1648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V1",
      "library": "kubecaml",
      "description": "This module provides direct access to Kubernetes Batch v1 APIs for managing and monitoring job resources across namespaces. It supports key operations such as listing, creating, and deleting jobs, along with real-time status tracking through watch events and HTTP streaming. Core data types include `Job`, `Job_list`, and `Status`, which are used to represent and manipulate resource states. Users can automate job lifecycle tasks, respond to status changes, or query job data with label and field filters using HTTP-based retrieval and event-driven monitoring.",
      "description_length": 561,
      "index": 1649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Core",
      "library": "kubecaml",
      "description": "This module models Kubernetes API objects and configurations with rich data types and manipulation functions. Key types include `Pod_spec`, `Container`, `Volume`, `Secret`, and `Resource_requirements`, enabling precise definitions of containerized workloads, storage, and resource constraints. Operations support building and modifying Kubernetes resources like pods and services, applying scheduling rules, and serializing configurations to JSON. Example uses include defining a container with environment variables and CPU limits, configuring a pod with persistent storage, or generating deployable JSON manifests from service specifications.",
      "description_length": 644,
      "index": 1650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Policy",
      "library": "kubecaml",
      "description": "This module offers structured data types and JSON serialization for Kubernetes security and disruption policies. It supports defining constraints on user IDs, SELinux contexts, volume plugins, and host paths, along with managing pod disruption budgets and eviction requests. You can enforce policies that restrict container privileges or control pod availability during cluster updates. Examples include specifying allowed SELinux contexts, defining eviction thresholds, or restricting volume access to specific host paths.",
      "description_length": 523,
      "index": 1651,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Secrets",
      "library": "kubecaml",
      "description": "This module handles retrieving Kubernetes Secret resources via HTTP requests. It supports operations like listing and watching Secrets, with customizable parameters such as label selectors, field selectors, and timeouts. The module works directly with Kubernetes V1 Secret definitions and integrates with Cohttp for transport-level handling.",
      "description_length": 341,
      "index": 1652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Authorization",
      "library": "kubecaml",
      "description": "This module handles Kubernetes authorization workflows by providing data structures and operations for access reviews, authorization attributes, and policy rules. It supports constructing and evaluating permissions for users or groups, including resource and non-resource access checks, and integrates with Kubernetes APIs for dynamic permission validation. You can determine if a user can create a pod in a namespace, define a rule to allow `GET` on `/api`, or retrieve a user's permissions for UI visibility control. Key types include access review specifications, rule sets, and review outcomes, all serializable to and from JSON.",
      "description_length": 633,
      "index": 1653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Admissionregistration",
      "library": "kubecaml",
      "description": "This module enables Kubernetes admission control by defining and managing mutating and validating webhooks, initializer configurations, and associated policies. It centers around data types like `Rule_with_operations`, `Webhook_client_config`, initializer lists, and versioned API resources, supporting construction, serialization, and policy application via operations like `to_yojson` and `of_yojson`. You can implement policies to inject sidecars, enforce constraints, validate annotations, or restrict operations based on namespaces, resource types, and API versions. TLS settings and service references secure webhook endpoints, and configurations can be persisted or exchanged in JSON for Kubernetes API integration.",
      "description_length": 722,
      "index": 1654,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Namespaces",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes namespace management by handling creation, listing, and watching operations with support for label selectors and pagination. It centers around `Namespace.t` and integrates with Cohttp for HTTP-based interactions, enabling direct control over namespace lifecycle and status updates through submodules. The first child module provides fine-grained operations on individual namespaces, supporting deletion with custom options and finalizer management, while the second extends control to namespace-scoped resources like Pods, Services, and Secrets, enabling full CRUD operations and real-time monitoring. Together, they allow automation of cluster-wide tasks such as configuration updates, resource eviction, and quota synchronization.",
      "description_length": 768,
      "index": 1655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1",
      "library": "kubecaml",
      "description": "This module discovers and retrieves Kubernetes API resources, providing structured access to API groups and versions while enabling dynamic client interactions through resource listings. It works with core data types like `Api_service.t`, `Delete_options.t`, and `Patch.t`, supporting operations to list, create, delete, and update API services, including status synchronization for configuration changes. Submodules extend this with real-time monitoring via `Watch_event.t`, allowing per-name or filtered observation of service changes. Example uses include querying available APIs, managing service definitions with asynchronous I/O, and tracking live updates to API services based on label selectors or specific names.",
      "description_length": 721,
      "index": 1656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides Kubernetes scheduling API operations for managing priority classes and watching resource changes, with functions to retrieve API resources and construct request paths. It supports real-time monitoring through event streams with filtering, limiting, and custom request parameters, enabling dynamic adjustment of scheduling policies or tracking cluster state. HTTP-based operations allow full CRUD control over priority classes using structured types like `Priority_class.t` and `Patch.t`, facilitating creation, deletion, and updates to enforce scheduling policies. Submodules offer fine-grained access to individual resources and streaming updates by name for precise change tracking.",
      "description_length": 705,
      "index": 1657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Persistentvolumes",
      "library": "kubecaml",
      "description": "This module manages Kubernetes PersistentVolume resources, offering operations to list, create, and delete volumes based on selectors, while integrating detailed control through child modules. It handles core types like `Persistent_volume.t`, `Persistent_volume_list.t`, and `Status.t`, supporting use cases such as provisioning storage, filtering volumes by label, and inspecting resource states. The child module enables per-volume operations\u2014like replacement, deletion, and status updates\u2014allowing precise lifecycle management. Combined, they facilitate both bulk and fine-grained manipulation of persistent storage in a cluster.",
      "description_length": 632,
      "index": 1658,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Networking",
      "library": "kubecaml",
      "description": "This module offers a structured approach to defining and managing Kubernetes network policies, enabling precise control over pod traffic through typed representations of ingress and egress rules. It supports operations for specifying CIDR blocks, peer and port constraints, and policy metadata, allowing policies to enforce HTTPS-only access, restrict traffic based on IP ranges or pod labels, and manage policy collections. You can serialize policies to JSON for API interactions or generate configurations programmatically. Example uses include blocking external access to internal services and defining fine-grained network isolation rules.",
      "description_length": 643,
      "index": 1659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1beta1",
      "library": "kubecaml",
      "description": "This module provides programmatic access to Kubernetes RBAC resources, enabling management of roles, role bindings, cluster roles, and cluster role bindings through direct API operations. It supports core actions like list, create, update, delete, and watch across both namespaced and cluster-scoped resources, with support for label and field filtering, resource versioning, and streaming event detection. You can create and bind roles with specific permissions, monitor RBAC changes in real time, or automate policy updates and cleanup across a cluster. Submodules refine this functionality with focused operations for named resources, HTTP-level control, and structured retrieval with pagination and event streaming.",
      "description_length": 719,
      "index": 1660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions.V1beta1",
      "library": "kubecaml",
      "description": "This module provides Kubernetes API operations for managing cluster resources including daemon sets, deployments, ingress routes, namespaces, network policies, pod security policies, and replica sets. It supports listing, creating, updating, and deleting resources with asynchronous I/O via Lwt, enabling automation of deployment configurations, enforcement of network policies, and management of cluster-wide security settings. Child modules extend this functionality with resource-specific operations: retrieve and watch ReplicaSets, manage namespace-scoped workloads, enforce pod security policies, monitor real-time resource changes, and handle ingress, daemon sets, and network policies with typed, filtered event streams. Specific capabilities include dynamically updating ingress rules, scaling deployments based on metrics, applying security constraints on pod creation, and streaming events for compliance auditing or auto-scaling decisions.",
      "description_length": 950,
      "index": 1661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Settings",
      "library": "kubecaml",
      "description": "This module handles Kubernetes PodPreset and PodPresetList resources from the v1alpha1 API, offering types to define presets, their specs, and collections. It supports creating, modifying, and serializing these structures to JSON for storage or API use. You can, for instance, set up a preset to inject environment variables or volumes into matching pods, combine presets into a list, and export the configuration as JSON.",
      "description_length": 422,
      "index": 1662,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Services",
      "library": "kubecaml",
      "description": "This module handles HTTP requests for interacting with Kubernetes Service resources, supporting operations like listing and watching services through the `get` function. It works with Kubernetes Service data structures, specifically `Service_list.t`, and uses standard HTTP request parameters for filtering, pagination, and connection settings. Concrete use cases include retrieving a filtered list of services or establishing a watch stream to monitor service changes in real time.",
      "description_length": 482,
      "index": 1663,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Extensions",
      "library": "kubecaml",
      "description": "This collection provides structured access to Kubernetes v1beta1 API objects, enabling programmatic management of deployment, scaling, networking, and security configurations. It includes core data types such as ReplicaSet, Deployment, Ingress, NetworkPolicy, and PodSecurityPolicy, each with specs, statuses, and conditions, along with JSON serialization utilities. Operations support defining rolling updates, configuring TLS for ingress, enforcing security constraints, and managing network rules. Example uses include automating controlled rollouts, setting up path-based ingress routing, restricting host paths in security policies, and scaling ReplicaSets via the API.",
      "description_length": 674,
      "index": 1664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Events",
      "library": "kubecaml",
      "description": "This module organizes Kubernetes event data into structured, serializable collections, enabling efficient tracking and aggregation of events across namespaces. It centers around data types like event lists, keyed event series, and namespace-grouped tuples, offering operations to construct, inspect, and convert these structures to JSON. You can use it to monitor cluster state changes, audit resource activity, or transmit structured event data between systems. For example, it allows grouping events by namespace or extracting metadata such as event type and resource references.",
      "description_length": 581,
      "index": 1665,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authentication.V1beta1",
      "library": "kubecaml",
      "description": "This module manages authentication operations for Kubernetes API interactions, focusing on token validation and API resource discovery. It includes functions to generate request paths and perform GET and POST requests to authenticate users or service accounts using bearer tokens. Core data types include URI values, Cohttp client contexts, and Kubernetes token review objects. Example usage includes validating a bearer token by sending a POST request to the token review endpoint and retrieving the authenticated user's details.",
      "description_length": 530,
      "index": 1666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides Kubernetes API operations for managing settings-related resources, including namespaces, pod presets, and watch events, working with structured data types like `Api_resource_list`. It enables real-time monitoring of PodPreset changes across namespaces, supports label-based filtering, pagination, and dynamic updates to environment variables and volume mounts. You can stream configuration updates in real time, enforce default pod settings across a namespace, or iterate through large sets of presets to maintain cluster-wide configurations. It integrates directly with the Kubernetes API using Cohttp, allowing for custom list, watch, and apply operations with support for resource versions and timeouts.",
      "description_length": 727,
      "index": 1667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration.V1beta1",
      "library": "kubecaml",
      "description": "This module provides discovery and retrieval capabilities for Kubernetes API resources, exposing functions to list available services and construct request paths based on resource versions and API groups. It directly handles resource registration endpoints and URI construction, while integrating real-time monitoring through watch requests and full lifecycle management via HTTP client operations. Key data types include API resource lists, watch events, service configurations, and deletion options, with operations for querying registered services, initiating watches on specific resources, and performing create, update, and delete actions. Example workflows include tracking API service availability, reacting to configuration changes, and programmatically managing custom API endpoints within a cluster.",
      "description_length": 809,
      "index": 1668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch.V2alpha1",
      "library": "kubecaml",
      "description": "This module interacts with the Kubernetes batch API to manage cron jobs, namespaces, and real-time watch operations, enabling precise control over periodic workloads and dynamic resource monitoring. It provides core functions for retrieving API resources, constructing request paths, and handling CronJob lifecycle operations, while its child modules support HTTP-based management, real-time event watching, and queryable data retrieval. The `Cron_job.t` type represents job configurations, and `Patch.t` allows partial updates, with label and field selectors enabling targeted filtering. Example uses include deploying and modifying scheduled tasks, reacting to job status changes in real time, and querying active jobs across namespaces.",
      "description_length": 739,
      "index": 1669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization.V1",
      "library": "kubecaml",
      "description": "This module handles authorization operations in the Kubernetes API, enabling creation and evaluation of access reviews, subject rules reviews, and permission checks for users and service accounts. It provides direct access to core authorization constructs like access review paths, request templates, and HTTP submission functions, working with types such as `SelfSubjectAccessReview`, `LocalSubjectAccessReview`, and `SubjectAccessReview`. The child modules extend this functionality by implementing specific review types: one checks permissions for the current user using self-subject access reviews, another evaluates access within namespaces via local subject access reviews, a third handles subject access reviews for specific users or service accounts, and the fourth retrieves applicable rules for the current user in a namespace. Example uses include verifying if a user can create a pod, checking deployment permissions in a namespace, or listing access rules for the current subject.",
      "description_length": 993,
      "index": 1670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps.V1beta1",
      "library": "kubecaml",
      "description": "This module manages Kubernetes API resources by listing available endpoints and building request paths, working with types like `Api_resource_list`, `Uri.t`, and `Cohttp.Header.t`. It supports direct operations on Deployments, StatefulSets, and ControllerRevisions, enabling creation, modification, and deletion via HTTP methods, as well as real-time observation of changes using streaming. Submodules provide fine-grained control, such as scaling workloads, watching resource updates with selectors, and retrieving historical controller revisions. Example uses include programmatically rolling back StatefulSets, monitoring Deployment status for autoscaling, and listing Namespaces or ControllerRevisions with custom filters.",
      "description_length": 726,
      "index": 1671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authentication.V1",
      "library": "kubecaml",
      "description": "This module manages authentication workflows in a Kubernetes API, centered on token validation and resource discovery. It provides direct access to listing supported authentication resources and constructing token review endpoints, using path templates and POST requests to validate bearer tokens. The child module extends this functionality by implementing concrete token review operations, returning authenticated user details or errors based on Kubernetes definitions. Together, they enable workflows like verifying service account tokens and dynamically determining available authentication endpoints during API interactions.",
      "description_length": 629,
      "index": 1672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events.V1beta1",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes event and namespace management through direct API interactions, enabling retrieval of API resources, path construction, and versioned requests. It centers around data types like `Api_resource_list`, event objects, and namespace identifiers, offering operations to list, watch, filter, and modify resources both globally and per-namespace. Submodules refine this functionality by enabling targeted event management within namespaces, HTTP-based event retrieval with custom options, and real-time monitoring with label and field-based filters. Example workflows include tracking service updates in real time, bulk-deleting outdated events in a specific namespace, or watching pod events with a label selector and resource version constraints.",
      "description_length": 776,
      "index": 1673,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Watch",
      "library": "kubecaml",
      "description": "This module provides real-time streaming watches for a variety of Kubernetes resources, including Pods, Services, Secrets, PersistentVolumes, and more. Each resource type offers a `get` function that initiates an HTTP-based watch with filters like `label_selector`, `resource_version`, and `timeout_seconds`, returning a stream of `Watch_event.t` values representing changes. You can monitor cluster state changes such as Pod creation, Service updates, or ConfigMap modifications, with support for fine-grained control via URIs and submodules for named resource tracking. Examples include watching for new Secrets in a namespace, tracking PersistentVolume updates, or monitoring Node readiness changes in real time.",
      "description_length": 715,
      "index": 1674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1",
      "library": "kubecaml",
      "description": "This module provides programmatic access to Kubernetes RBAC resources, enabling management of roles, role bindings, cluster roles, and cluster role bindings across namespaces and the entire cluster. It supports standard operations like list, create, update, delete, and watch, with structured types such as Role, RoleBinding, ClusterRole, and ClusterRoleBinding, along with options for filtering, pagination, and real-time event streaming. You can use it to automate access control policies, enforce least privilege, and react dynamically to permission changes across the cluster. Submodules extend this functionality with targeted operations, such as per-name CRUD for cluster role bindings or namespace-specific RBAC management.",
      "description_length": 730,
      "index": 1675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api.Rbac",
      "library": "kubecaml",
      "description": "This module provides structured data types and operations for managing Kubernetes RBAC configurations across multiple API versions, supporting the creation, inspection, and serialization of roles, role bindings, policy rules, and subject references. Key types include `Role`, `ClusterRole`, `RoleBinding`, `Subject`, and `PolicyRule`, with operations to define permissions, associate subjects, and aggregate roles based on label selectors. It enables programmatic generation of RBAC manifests, integration with Kubernetes APIs via JSON serialization, and dynamic access control management, such as granting user access in a namespace or combining ClusterRoles for complex policies. Examples include defining a Role with specific verbs and resources, binding it to a service account, or aggregating ClusterRoles for multi-tenant access control.",
      "description_length": 843,
      "index": 1676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac.V1alpha1",
      "library": "kubecaml",
      "description": "This module provides a comprehensive interface for managing RBAC resources in Kubernetes, enabling creation, retrieval, update, and deletion of roles and role bindings across namespaces and clusters. It supports key data types such as Role, RoleBinding, ClusterRole, and ClusterRoleBinding, with operations that include filtering, pagination, patching, and real-time watching. Submodules extend functionality for cluster-scoped roles and bindings, allowing precise manipulation via HTTP-based APIs, including named resource updates and streaming change detection. Example uses include automating role creation, enforcing access policies dynamically, and synchronizing permissions across environments using real-time monitoring and targeted updates.",
      "description_length": 748,
      "index": 1677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Limitranges",
      "library": "kubecaml",
      "description": "Implements HTTP operations for interacting with Kubernetes LimitRange resources, supporting `get` requests with optional query parameters like `label_selector`, `field_selector`, and `watch`. Works with `Limit_range_list` data structures, handling responses from the Kubernetes API server. Useful for retrieving and monitoring resource constraints in a Kubernetes namespace.",
      "description_length": 374,
      "index": 1678,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1.Pods",
      "library": "kubecaml",
      "description": "Implements functions to interact with Kubernetes Pod resources, including retrieving pod lists with optional filters like label selectors and field selectors. Works with Pod_list data structures and supports operations such as get with customizable request parameters. Useful for querying and monitoring pods in a Kubernetes cluster based on specific criteria.",
      "description_length": 360,
      "index": 1679,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy.V1beta1",
      "library": "kubecaml",
      "description": "This module provides tools for managing Kubernetes policy resources, enabling users to query available API resources, construct request paths, and interact with policy objects like pod disruption budgets and security policies. It supports core operations such as listing, creating, updating, and deleting policies, while integrating with submodules for real-time monitoring, namespace-scoped budget management, and security policy enforcement. For example, users can construct URIs for policy operations, stream live updates to a PodDisruptionBudget during a rollout, or apply constraints to pod creation through security policies. Submodules extend functionality with fine-grained control over policy lifecycle, status updates, and event-based compliance actions.",
      "description_length": 764,
      "index": 1680,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Batch",
      "library": "kubecaml",
      "description": "This module coordinates Kubernetes batch operations across API versions, using a `get` function to retrieve group details with CoHTTP clients and URI configurations. It integrates versioned submodules for precise control over batch resources\u2014V1 manages jobs with creation, deletion, and watch capabilities, V1beta1 extends to cron jobs with scheduling and real-time event streaming, and V2alpha1 offers advanced cron job management with patching and filtering. Users can list jobs in a namespace, monitor cron job status changes in real time, or deploy scheduled workloads with version-specific APIs. Core types like `Job`, `Cron_job.t`, and `Patch.t` enable structured interactions, while HTTP submodules support filtered queries and event-driven updates.",
      "description_length": 756,
      "index": 1681,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Certificates",
      "library": "kubecaml",
      "description": "This module provides certificate-related functionality within a Kubernetes API, handling group information retrieval and request path templating. It supports operations like querying certificate endpoints and constructing URIs, working directly with Kubernetes API group definitions using Cohttp for HTTP interactions. The child module extends this by managing certificate signing requests with types such as `Certificate_signing_request`, `Certificate_signing_request_list`, and watch events, enabling list, create, delete, patch, and status operations. Users can automate certificate approvals, monitor request statuses in real time, and track specific resources by name through configurable watch streams.",
      "description_length": 708,
      "index": 1682,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Storage",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes storage operations across API versions, handling API group negotiation, path construction, and Cohttp-based request execution. It exposes core data types such as storage classes, volume attachments, and their respective lists, enabling operations like list, get, create, update, and delete, while supporting real-time watch streams for change detection. Users can query storage configurations, monitor volume attachment states, or automate policy-driven updates with version-controlled watches. Submodules refine this functionality, offering focused APIs for storage class management, volume attachment control, and event-driven synchronization with cluster state.",
      "description_length": 700,
      "index": 1683,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apiextensions_apiserver",
      "library": "kubecaml",
      "description": "This module suite handles the definition, validation, and serialization of Kubernetes API structures, particularly CRDs, using JSON schemas and OpenAPI. It provides data types for CRD metadata, status conditions, and scale settings, with operations for encoding, decoding, and validation. Users can define custom validation logic, configure autoscaling with JSON paths, and ensure schema compliance. Example uses include preparing CRDs for registration, validating extensions, and managing custom resource status.",
      "description_length": 513,
      "index": 1684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apps",
      "library": "kubecaml",
      "description": "This module handles API requests for Kubernetes app resources, offering a `get` function for group information and a `request_path_template` to construct paths. It integrates with Kubernetes API groups and uses Cohttp for HTTP operations, enabling typed client construction for cluster management. The module\u2019s submodules provide structured access to Deployments, DaemonSets, StatefulSets, ReplicaSets, and ControllerRevisions, supporting operations like `list`, `watch`, `get`, `put`, `patch`, and `delete` with filters and streaming. You can monitor rollouts, scale workloads, track revisions, list resources with custom selectors, and perform real-time updates or rollbacks across namespaces.",
      "description_length": 695,
      "index": 1685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api.V1",
      "library": "kubecaml",
      "description": "This module provides direct access to Kubernetes API v1 resources, enabling management of core cluster components such as pods, services, secrets, and namespaces through standard CRUD operations. It supports listing, retrieving, creating, updating, and deleting resources using Cohttp for HTTP communication, with concrete use cases like monitoring pod status, managing service endpoints, and handling secret data. Child modules extend this functionality to specialized resources like Events, ConfigMaps, PersistentVolumeClaims, and ResourceQuotas, offering typed access and streaming watches for real-time updates. Specific capabilities include watching for new Secrets in a namespace, tracking PersistentVolume changes, querying quota usage across namespaces, and managing node lifecycle with partial updates, all while working directly with Kubernetes v1 data structures like Pod_list, Service_list, and Watch_event.t.",
      "description_length": 921,
      "index": 1686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Events",
      "library": "kubecaml",
      "description": "This module manages Kubernetes event data through API requests, providing a `get` function to retrieve events using a predefined path template and Cohttp for HTTP handling. It integrates with Kubernetes API groups and supports operations like listing, watching, and filtering events with context, headers, or resource version constraints. Submodules extend this functionality by enabling namespace-scoped event management, customizable HTTP retrieval options, and real-time monitoring with label and field selectors. Example uses include querying event details from a cluster, tracking service updates in real time, and filtering pod events by label.",
      "description_length": 650,
      "index": 1687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Networking",
      "library": "kubecaml",
      "description": "This module provides low-level access to Kubernetes networking APIs, focusing on retrieving API group information through direct HTTP interactions using Cohttp. It exposes a core `get` function to query group details from a given URI, supporting operations that inspect and interact with cluster networking configurations. Its child module extends this functionality by managing network policies and namespaces, offering structured operations to create, update, and delete policies, as well as stream real-time updates using label and field filters. Together, they enable tasks like enforcing network isolation between pods or synchronizing firewall rules in response to policy changes.",
      "description_length": 686,
      "index": 1688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Extensions",
      "library": "kubecaml",
      "description": "This module extends Kubernetes API group discovery with a comprehensive set of resource management capabilities. At its core, it provides a `get` function to retrieve API group details from a URI, enabling runtime discovery of supported versions and resources. The child module adds typed operations for managing cluster resources such as deployments, ingress, namespaces, and network policies, using Lwt for asynchronous I/O. Examples include dynamically updating ingress rules, scaling deployments, enforcing pod security policies, and streaming real-time events for auditing or auto-scaling.",
      "description_length": 594,
      "index": 1689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Settings",
      "library": "kubecaml",
      "description": "This module combines core settings functionality with Kubernetes API operations to manage cluster configurations and resources. It provides data types like `Api_resource_list` and operations for querying API groups, building request paths, and handling HTTP interactions via Cohttp. You can monitor PodPreset changes in real time, apply label-based filters, and manage namespace-level settings with support for pagination and resource versioning. Specific use cases include streaming configuration updates, enforcing default pod settings, and iterating through large preset collections for cluster-wide management.",
      "description_length": 614,
      "index": 1690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Apimachinery",
      "library": "kubecaml",
      "description": "This module offers tools for working with Kubernetes API values, supporting polymorphic types, resource quantities, deferred decoding, and structured metadata. Key data types include tagged integers and strings, label selectors, version metadata, and raw extensions, with operations for JSON serialization, value construction, and selective unmarshaling. It enables tasks like parsing resource limits (e.g., `\"2Gi\"`), deferring decoding of custom fields, building label selectors for deployments, and serializing version information for logging or API use.",
      "description_length": 556,
      "index": 1691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiregistration",
      "library": "kubecaml",
      "description": "This module manages API registration tasks for Kubernetes, enabling retrieval and manipulation of API group information through direct queries to the API server. It provides structured access to API resources using data types like `Api_service.t`, `Delete_options.t`, and `Watch_event.t`, supporting operations such as listing, creating, updating, and deleting API services. Submodules extend functionality with real-time monitoring of service changes and dynamic client interactions, allowing for label-based filtering and per-name observation. Example uses include synchronizing API service status, managing custom API endpoints, and tracking live updates to service configurations using asynchronous I/O.",
      "description_length": 707,
      "index": 1692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Rbac",
      "library": "kubecaml",
      "description": "This module orchestrates RBAC management in Kubernetes by combining core operations with structured resource handling. It exposes data types like Role, RoleBinding, ClusterRole, and ClusterRoleBinding, enabling actions such as list, create, update, delete, and watch with support for filtering, pagination, and event streaming. You can automate policy enforcement, bind roles to users or groups, and monitor access changes in real time across namespaces and clusters. Submodules refine this control with namespace-specific management, named resource operations, and low-level HTTP interfaces for precise interaction with RBAC resources.",
      "description_length": 636,
      "index": 1693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Apiextensions",
      "library": "kubecaml",
      "description": "This module manages low-level access to Kubernetes API extensions, offering direct functions to retrieve API group information, construct request paths, and perform HTTP GET requests using Cohttp and Kubernetes-specific types like `Api_group.t`. Its submodules extend this functionality with CRD lifecycle operations\u2014supporting creation, deletion, patching, and versioned watches\u2014alongside event streaming with label filtering and timeouts. Key data types include CRD specifications, delete options, and event streams, enabling workflows such as dynamic API extension, automated CRD cleanup, and real-time synchronization with cluster state. Example uses include querying API groups for discovery, creating CRDs to extend cluster capabilities, and watching CRD updates to trigger configuration reloads.",
      "description_length": 802,
      "index": 1694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authentication",
      "library": "kubecaml",
      "description": "This module orchestrates authentication workflows for Kubernetes API interactions, combining core operations with specialized submodules to handle token validation and resource discovery. It provides direct access to authentication group metadata via HTTP GET requests, using Cohttp for communication and working with Kubernetes API group data structures. The first submodule implements concrete token review operations, enabling bearer token validation through POST requests and returning authenticated user details. The second submodule extends this by dynamically listing supported authentication resources and constructing token review endpoints using path templates, facilitating workflows like service account token verification and API endpoint discovery.",
      "description_length": 762,
      "index": 1695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Scheduling",
      "library": "kubecaml",
      "description": "This module handles API requests for Kubernetes scheduling groups, providing a function to retrieve group information via HTTP using Cohttp. It integrates with Kubernetes API group definitions to enable fetching scheduling metadata from a cluster using custom URIs, with support for optional context or headers. The child module extends this functionality with CRUD operations on priority classes, real-time event streams for resource changes, and path construction for API requests. Key data types like `Priority_class.t` and `Patch.t` support structured interactions, allowing dynamic policy adjustments and cluster state tracking through both synchronous and streaming HTTP interfaces.",
      "description_length": 688,
      "index": 1696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Kube_aggregator",
      "library": "kubecaml",
      "description": "This module provides structured management of Kubernetes API services through typed representations of configurations, references, and health states. Key data types include service specifications with priority and TLS settings, optional namespace and name references, and conditions for tracking status transitions. Operations support constructing, modifying, and inspecting services, such as loading configurations from files, updating TLS parameters, and exporting to JSON. Example uses include registering backend servers, organizing services by label or version, and querying service status within a cluster.",
      "description_length": 612,
      "index": 1697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Admissionregistration",
      "library": "kubecaml",
      "description": "This module handles API requests for Kubernetes admission registration, supporting operations like retrieving API group information and webhook configurations. It provides a templated request path and asynchronous `get` function, using Cohttp for HTTP interactions, while enabling CRUD operations, watches, and filtered queries on admission resources. Developers can list initializer configurations, stream live updates, and modify admission policies dynamically, with support for pagination, labels, and context-aware requests. Example workflows include programmatically managing webhook configurations, observing cluster-wide policy changes, and constructing targeted API requests based on discovered resources.",
      "description_length": 713,
      "index": 1698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Authorization",
      "library": "kubecaml",
      "description": "This module orchestrates Kubernetes authorization workflows by handling API requests for access reviews, subject rules, and permission checks. It exposes typed operations for constructing and submitting requests using Cohttp, supporting core data types like `SubjectAccessReview`, `LocalSubjectAccessReview`, and `SelfSubjectRulesReview`. Child modules refine this functionality with scoped implementations: evaluating self-subject access, namespace-limited reviews, and rule discovery for active users. Example uses include validating if a service account can create deployments in a namespace or enumerating access rules for the current user across cluster resources.",
      "description_length": 669,
      "index": 1699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions.Api",
      "library": "kubecaml",
      "description": "This module provides structured access to a wide range of Kubernetes API resources, enabling precise definition, manipulation, and serialization of workloads, policies, and cluster configurations. Core data types include job specifications, priority classes, certificate requests, storage configurations, token reviews, autoscaling rules, and network policies, each supporting operations like creation, modification, status tracking, and JSON/YAML conversion. You can define and deploy Kubernetes resources such as batch jobs, autoscaling deployments, and network isolation rules, enforce security constraints via PodSecurityPolicies or RBAC configurations, and manage authentication, authorization, and admission control workflows programmatically. Example uses include generating TLS bootstrapping certificates, configuring storage classes for SSD volumes, and implementing webhook-based admission policies for pod sidecar injection.",
      "description_length": 935,
      "index": 1700,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Logs.By_logpath",
      "library": "kubecaml",
      "description": "This module handles retrieving Kubernetes logs from a specified log path by constructing the appropriate request path template and issuing HTTP GET requests. It works with URIs and log file paths, interacting directly with the Kubernetes API to stream or fetch container logs. A concrete use case is tailing logs from a specific container in a pod by providing the log path returned from a prior API call.",
      "description_length": 405,
      "index": 1701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Autoscaling",
      "library": "kubecaml",
      "description": "This module manages Kubernetes autoscaling groups through typed HTTP interactions, providing a `get` function to retrieve group metadata and integrate with cluster management tools using Cohttp and URI configurations. It supports core types like `Horizontal_pod_autoscaler`, `Namespace`, and `Watch_event`, enabling operations such as listing autoscalers, applying scaling policies, and monitoring real-time scale events. Submodules extend this functionality with filtered watches, partial configuration updates, and structured access to autoscaler lists, allowing workflows like dynamically adjusting CPU-based thresholds and streaming updates across namespaces. You can query autoscaling resources by labels, construct API request paths, or observe metric-driven scaling triggers directly or through namespace-scoped event streams.",
      "description_length": 833,
      "index": 1702,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis.Policy",
      "library": "kubecaml",
      "description": "This module handles API requests for Kubernetes policy resources, retrieving group information via HTTP using Cohttp, and works with Kubernetes API group definitions to query policy metadata from clusters. It provides functions to list, create, update, and delete policies such as pod disruption budgets and security policies, while supporting URI construction for policy operations and integration with submodules. Child modules enable real-time monitoring, namespace-scoped budget management, and event-driven compliance actions, allowing users to stream live updates to a PodDisruptionBudget or enforce constraints on pod creation. Together, the module and its submodules offer a cohesive interface for managing policy lifecycle, status, and enforcement across Kubernetes environments.",
      "description_length": 788,
      "index": 1703,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Kubecaml.Kubernetes.Logs",
      "library": "kubecaml",
      "description": "This module retrieves Kubernetes logs via HTTP requests, using a templated path structure and the `get` function to fetch logs from a URI. It integrates with Cohttp types like `Uri.t` and `Cohttp.Header.t`, and uses Lwt for asynchronous execution, enabling efficient querying of container logs from a Kubernetes API server. The child module extends this functionality by handling log retrieval from specific file paths, allowing operations like tailing logs from a container using a prior API response. Together, they support concrete workflows such as streaming logs from a running pod or fetching historical logs based on file paths.",
      "description_length": 635,
      "index": 1704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.Of_bools",
      "library": "kubecaml",
      "description": "This module handles conversion between a list of string-boolean pairs and JSON format. It provides functions to serialize the list to JSON and deserialize JSON into the list, ensuring correct parsing. Use this module when working with JSON representations of boolean flags or configuration options.",
      "description_length": 298,
      "index": 1705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Api",
      "library": "kubecaml",
      "description": "This module orchestrates low-level communication with Kubernetes APIs, constructing request paths and negotiating API versions during client initialization. It directly supports querying API capabilities and version metadata, while its child modules expose typed interfaces for managing v1 resources like pods, services, and secrets through CRUD operations and streaming watches. Concrete operations include watching for new Secrets, tracking PersistentVolumeClaims, and querying ResourceQuotas across namespaces using Cohttp for HTTP transport. The module combines version negotiation and path construction with rich submodules that handle real-time updates, partial resource modifications, and structured access to Kubernetes v1 objects like Pod_list and Watch_event.t.",
      "description_length": 771,
      "index": 1706,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Object.Of_ints",
      "library": "kubecaml",
      "description": "This module handles conversion between a list of string-integer pairs and JSON values using Yojson. It provides functions to serialize the list to JSON and deserialize JSON back into the list structure. Use this module when working with JSON representations of key-value pairs where values are integers, such as configuration settings or numeric metadata.",
      "description_length": 355,
      "index": 1707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.Of_strings",
      "library": "kubecaml",
      "description": "This module handles conversion between string pairs and JSON values. It provides functions to serialize a list of string pairs into a JSON object and to deserialize a JSON object into a list of string pairs, ensuring proper error handling during parsing. It is useful for working with key-value configurations or annotations in JSON format.",
      "description_length": 340,
      "index": 1708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.Of_floats",
      "library": "kubecaml",
      "description": "This module handles conversion between float-valued key-value lists and JSON representations. It works with associative lists mapping strings to floats and safely serializes or deserializes them using Yojson. It is useful for exporting or parsing JSON metrics or configuration data with float values.",
      "description_length": 300,
      "index": 1709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.Value",
      "library": "kubecaml",
      "description": "This module defines a type `value` for representing Kubernetes resource values and provides direct conversions to and from `Yojson.Safe.json` format. It includes functions `value_of_yojson` and `value_to_yojson` for parsing and serializing values, ensuring compatibility with JSON-based Kubernetes APIs. It is used to handle structured data in Kubernetes object definitions, such as configuration files or API payloads.",
      "description_length": 419,
      "index": 1710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Kubecaml.Kubernetes.Apis",
      "library": "kubecaml",
      "description": "This module coordinates Kubernetes API group discovery and version retrieval through HTTP interactions, enabling clients to dynamically query available API resources and construct request paths. It provides core functions like `get` for fetching API group lists and `request_path_template` for building versioned endpoints, supporting structured types such as `Api_group.t` and `Api_resource_list`. Submodules extend this foundation to manage batch operations, certificates, storage, apps, events, networking, RBAC, and custom resources, each exposing typed operations like `list`, `watch`, `create`, `patch`, and `delete` for precise control over cluster state. Users can, for example, monitor job statuses in real time, automate certificate approvals, scale deployments, enforce network policies, or manage autoscaling rules\u2014all through versioned, composable APIs backed by Cohttp and Lwt for asynchronous I/O.",
      "description_length": 912,
      "index": 1711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Definitions",
      "library": "kubecaml",
      "description": "This module suite provides structured definitions and manipulation of Kubernetes API resources, from custom CRDs to core workloads and services. It includes data types for metadata, validation rules, resource quantities, API services, and configurations, with operations for encoding, decoding, validation, and status tracking. Users can define and serialize CRDs, configure autoscaling with JSON paths, parse resource limits like `\"2Gi\"`, manage service TLS settings, and enforce policies such as network isolation or PodSecurity. Example uses include preparing custom resources for registration, managing service configurations, and programmatically deploying jobs or certificate requests.",
      "description_length": 691,
      "index": 1712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.Make",
      "library": "kubecaml",
      "description": "This module represents Kubernetes API objects as lists of key-value pairs, where values are of a type `V.value`. It provides functions to convert these objects to and from Yojson representations, enabling serialization and deserialization for use in JSON-based APIs. It is used to model and manipulate structured Kubernetes resource data, such as Pods or Services, in a type-safe way.",
      "description_length": 384,
      "index": 1713,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object.S",
      "library": "kubecaml",
      "description": "This module represents Kubernetes API objects as associative lists mapping field names to values, enabling structured data manipulation. It provides functions to convert these objects to and from Yojson representations, ensuring compatibility with JSON-based Kubernetes APIs. Use this module to serialize and deserialize Kubernetes resource definitions for API interactions or configuration management.",
      "description_length": 402,
      "index": 1714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes.Version",
      "library": "kubecaml",
      "description": "This module handles version-related interactions with a Kubernetes API. It provides a function to retrieve the server's version information by sending an HTTP GET request to the appropriate endpoint. The module works with Cohttp types for making HTTP requests and returns parsed version data from the Kubernetes API response.",
      "description_length": 325,
      "index": 1715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Kubernetes",
      "library": "kubecaml",
      "description": "This module suite enables comprehensive interaction with Kubernetes APIs, from version negotiation and API discovery to real-time resource management and log retrieval. It provides structured types like `Api_group.t`, `Pod_list`, and `Watch_event.t`, along with operations for CRUD, streaming, log tailing, and version querying, all backed by Cohttp and Lwt for asynchronous HTTP communication. Users can watch for new Secrets, stream container logs, list PersistentVolumeClaims, or scale deployments programmatically. Specific workflows include automating certificate approvals, enforcing network policies, and managing custom resources with precise, versioned API calls.",
      "description_length": 672,
      "index": 1716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml.Object",
      "library": "kubecaml",
      "description": "This module enables the creation and manipulation of Kubernetes API objects by converting structured data into JSON representations and back. It supports key-value pairs with values of various primitive types\u2014booleans, integers, strings, and floats\u2014through dedicated submodules that handle safe serialization and deserialization using Yojson. The core functionality includes converting raw data into typed Kubernetes resource definitions and preparing them for API requests, as well as parsing API responses into usable OCaml structures. For example, you can construct a configuration object from a list of string-integer pairs, serialize it to JSON for an API call, or parse a JSON response containing float-valued metrics into a typed list for further processing.",
      "description_length": 765,
      "index": 1717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Kubecaml",
      "library": "kubecaml",
      "description": "This module suite provides structured access to Kubernetes APIs, enabling version negotiation, resource management, and real-time event watching. It includes key data types like `Api_group.t`, `Pod_list`, and `Watch_event.t`, and supports operations such as CRUD, log streaming, and configuration serialization using Yojson. Users can programmatically scale deployments, tail container logs, convert typed data to JSON for API requests, or parse metric responses into usable structures. Specific use cases include automating certificate approvals, managing custom resources, and enforcing policies through precise API interactions.",
      "description_length": 631,
      "index": 1718,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 1719,
    "meaningful_modules": 1719,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 993,
    "min_description_length": 240,
    "avg_description_length": 514.3711460151251,
    "embedding_file_size_mb": 6.244651794433594
  }
}