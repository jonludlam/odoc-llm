{
  "package": "piaf",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 80,
  "creation_timestamp": "2025-08-15T15:23:46.461205",
  "modules": [
    {
      "module_path": "Sendfile",
      "library": "piaf.sendfile",
      "description": "This module provides direct bindings to the `sendfile(2)` system call for efficiently transferring data from a source file descriptor to a destination file descriptor. It supports both partial and complete file sends, handling interruptions like `EINTR` and `EAGAIN` when appropriate. These functions are useful for high-performance network servers that need to stream file contents over sockets without copying data into user space.",
      "description_length": 433,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Multipart.Pp",
      "library": "piaf.multipart",
      "description": "This module provides functions to format and print multipart form data structures, including fields, content types, and extensions, using OCaml's standard formatting library. It works directly with data types representing MIME content types, form fields, and token extensions. Use this module to generate human-readable string representations of multipart form components for logging, debugging, or protocol inspection.",
      "description_length": 419,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Multipart",
      "library": "piaf.multipart",
      "description": "This module handles parsing and inspecting multipart form data, providing direct access to content types, headers, and form fields. It works with low-level multipart structures, string-based content types, and streaming input via `Bigstringaf.t` and `Faraday.iovec`. Use it to extract and process form data from HTTP requests, including file uploads and structured payloads, with support for streaming and custom event handling.",
      "description_length": 428,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Headers.Well_known.HTTP1",
      "library": "piaf",
      "description": "This module provides access to well-known HTTP/1 header names as string constants. It works with string data types to represent header fields. Concrete use cases include standardizing header names when constructing or parsing HTTP requests and responses, such as using `host` to refer to the Host header field.",
      "description_length": 310,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Headers.Well_known.HTTP2",
      "library": "piaf",
      "description": "This module provides access to well-known HTTP/2 header fields as string values. It works with string data types to represent header field names and values. Concrete use cases include setting or retrieving standard HTTP/2 headers such as `host` when constructing or parsing HTTP/2 requests and responses.",
      "description_length": 304,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions.HTTP.Raw",
      "library": "piaf",
      "description": "This module handles HTTP protocol versions using a simple record type with `major` and `minor` integer fields. It provides conversions to and from strings, comparison, and pretty-printing for debugging or logging. Common use cases include parsing HTTP version strings from requests/responses and converting between raw and typed representations for validation or serialization.",
      "description_length": 377,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Headers.Well_known.Values",
      "library": "piaf",
      "description": "This module defines well-known string values used in HTTP headers. It includes operations to reference standardized header value strings such as `close`. These values are used when constructing or parsing HTTP headers to ensure correctness and interoperability.",
      "description_length": 261,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Config.HTTPS",
      "library": "piaf",
      "description": "This module defines an HTTPS server configuration with TLS settings, certificate handling, and client authentication controls. It works with TLS versions, certificate pairs, and socket addresses for secure server binding. Concrete use cases include setting up HTTPS servers with mutual TLS, custom CA trust stores, and restricted TLS protocol versions.",
      "description_length": 352,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Server.Config",
      "library": "piaf",
      "description": "This module configures HTTP and HTTPS servers with precise control over TLS settings, protocol versions, socket options, and performance tuning parameters. It works with socket addresses, TLS configurations, and HTTP version policies to enable use cases like enforcing HTTP/2 with ALPN, configuring TCP keepalive settings, and managing graceful shutdown timeouts. Key operations include creating fully customized server configurations with optional HTTPS support, H2C upgrades, and fine-grained buffer sizing for high-performance networking scenarios.",
      "description_length": 551,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Response.Upgrade",
      "library": "piaf",
      "description": "Constructs HTTP responses for upgraded connections, supporting generic and WebSocket-specific handling. Works with HTTP requests, responses, headers, and I/O switches. Used to implement WebSocket handshakes and custom protocol upgrades directly over raw connections.",
      "description_length": 266,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Error_response",
      "library": "piaf",
      "description": "This module defines a type `t` representing error responses in a server context, along with operations to construct, match, and serialize errors. It works with HTTP status codes and error payloads, enabling precise error handling and response generation. Concrete use cases include returning structured JSON errors or custom status responses in a web application.",
      "description_length": 363,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Server.Command",
      "library": "piaf",
      "description": "This module manages the lifecycle of network servers, handling operations like starting and shutting down servers that process incoming connections using a provided handler. It works with connection handlers that accept a switch, socket, and address, and manages servers bound to specific addresses with configurable options like backlog and reuse flags. Concrete use cases include running HTTP servers that handle client requests over TCP or Unix domain sockets.",
      "description_length": 463,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Handler",
      "library": "piaf",
      "description": "Handles requests for undefined routes by returning a 404 Not Found response. Works with the `Piaf.Response.t` type to construct error responses. Useful for implementing fallback routing logic in web applications.",
      "description_length": 212,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Versions.TLS",
      "library": "piaf",
      "description": "This module defines a type `t` representing TLS protocol versions, including SSLv3 and TLS 1.0 through 1.3. It provides functions to compare versions, parse from strings, and pretty-print in a human-readable format. Concrete use cases include validating and selecting TLS versions during HTTPS connection setup or configuration parsing.",
      "description_length": 336,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Cookies.Set_cookie",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP `Set-Cookie` headers with precise control over attributes like expiration, path, domain, and security flags. It operates on a structured type `t` representing a cookie, allowing incremental updates through with_* functions and conversion to raw cookie strings. Concrete use cases include setting session cookies with expiration times, securing cookies for HTTPS contexts, and parsing cookies from HTTP headers for processing.",
      "description_length": 469,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Ws.Descriptor",
      "library": "piaf",
      "description": "This module handles WebSocket communication by providing functions to send and receive messages over a WebSocket connection. It works with data types like `t` for descriptors, `Message.t` for incoming frames, and `IOVec.t` for efficient data transmission. Concrete use cases include streaming text or binary data, sending ping/pong control frames, and managing connection closure with `close` and `is_closed`.",
      "description_length": 409,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Headers.Well_known",
      "library": "piaf",
      "description": "This module provides string constants for well-known HTTP header names and values, including headers like `content_type` and values like `close`. It operates on string data types to standardize the representation of HTTP headers and their values. Concrete use cases include constructing and parsing HTTP requests and responses with standardized header names and values, such as setting `content_length` or using `Values.close` in HTTP/1.1 communication.",
      "description_length": 453,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions.ALPN",
      "library": "piaf",
      "description": "Converts between string representations and HTTP version values, specifically handling ALPN identifiers. Works with the `Piaf.Versions.HTTP.t` type, which represents HTTP versions like HTTP/1.1 or HTTP/2. Useful for parsing ALPN protocol IDs during TLS handshake negotiation or logging protocol versions in network services.",
      "description_length": 324,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Ws.Message",
      "library": "piaf",
      "description": "This module represents WebSocket messages as a pair of opcode and a buffer vector. It provides functions to create, inspect, and manipulate message frames, including text, binary, and control frames. Direct use cases include handling incoming WebSocket data, constructing outgoing messages, and managing frame fragmentation.",
      "description_length": 324,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cookies.Cookie",
      "library": "piaf",
      "description": "Parses HTTP headers into a list of cookie key-value pairs and serializes such lists back into a cookie header. Works with `Piaf.Headers.t` and lists of string pairs. Used to extract and format cookies in HTTP requests and responses.",
      "description_length": 232,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Client.Oneshot",
      "library": "piaf",
      "description": "This module implements HTTP client operations for sending one-time requests. It supports standard methods like GET, POST, PUT, PATCH, DELETE, and HEAD, allowing custom headers, request bodies, and configuration. Each function takes a URI, execution environment, and switch for resource management, returning a result with the response or error.",
      "description_length": 344,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Form.Multipart",
      "library": "piaf",
      "description": "Handles parsing of multipart form data from HTTP requests, providing access to uploaded files and form fields. It processes `Piaf.Request.t` inputs and yields structured values representing form parts, including their name, filename, content type, and body. Useful for extracting file uploads or form data in web applications handling multipart/form-data requests.",
      "description_length": 364,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions.HTTP",
      "library": "piaf",
      "description": "This module defines HTTP version types (`HTTP_1_0`, `HTTP_1_1`, `HTTP_2`) and supports parsing, pretty-printing, and comparison operations. It works with string representations of HTTP versions and structured types for validation and serialization. Concrete use cases include extracting HTTP versions from request lines, validating protocol compatibility, and generating HTTP/1.1 or HTTP/2 headers in network services.",
      "description_length": 418,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Config",
      "library": "piaf",
      "description": "This module defines a configuration structure for HTTP client settings, including options for redirects, TLS versions, buffer sizes, and header handling. It works with custom types for HTTP and TLS versions, certificates, and headers. Concrete use cases include setting up secure client connections with specific CA trust stores, configuring HTTP/2 behavior, and controlling redirect policies for web scraping or API interactions.",
      "description_length": 430,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server",
      "library": "piaf",
      "description": "This module implements HTTP server functionality with precise control over network configuration, request handling, and error responses. It works with socket addresses, TLS settings, HTTP protocols, and custom handlers to support use cases like serving REST APIs over HTTPS with HTTP/2, handling malformed or undefined routes with custom 404 responses, and generating structured error payloads. Key operations include creating and managing HTTP and HTTPS servers, defining fallback routing logic, and customizing error handling with typed responses.",
      "description_length": 549,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.IOVec",
      "library": "piaf",
      "description": "This module manages I/O vector structures for efficient data transmission, providing operations to create, shift, and measure vectors over bigstrings. It supports slicing and formatting of data buffers with precise offset and length control. Concrete use cases include network packet assembly, file chunking, and zero-copy data processing.",
      "description_length": 339,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cert",
      "library": "piaf",
      "description": "This module represents and prints SSL/TLS certificate data, supporting two forms: file paths and PEM-encoded strings. It provides a `pp` function to format and display certificate values using OCaml's standard formatting system. Useful for logging or debugging certificate information in network security contexts.",
      "description_length": 314,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Client",
      "library": "piaf",
      "description": "This module manages persistent HTTP connections for issuing multiple requests to a remote endpoint. It supports standard HTTP methods (GET, POST, PUT, PATCH, DELETE, HEAD) with custom headers, request bodies, and WebSocket upgrades. The client handles connection lifecycle management, including explicit shutdown, and works with URIs, HTTP methods, and response types directly.",
      "description_length": 377,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Response",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP responses, providing functions to create responses from various body types (strings, bigstrings, streams, files), modify existing responses, and inspect response components. It works with HTTP status codes, headers, versions, and body types, supporting both immediate and streaming data transmission. Concrete use cases include sending static files, building custom HTTP responses with specific headers or versions, and handling streaming content like server-sent events.",
      "description_length": 515,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Form",
      "library": "piaf",
      "description": "Processes multipart form data from HTTP requests, extracting structured values for form fields and file uploads. Works with `Piaf.Request.t` inputs, providing access to part metadata like name, filename, content type, and body. Ideal for handling file uploads and form submissions in web applications receiving `multipart/form-data` payloads.",
      "description_length": 342,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Error",
      "library": "piaf",
      "description": "This module defines error types for handling failures in HTTP/2 communication, including client and server-specific errors, protocol issues, TLS problems, and malformed responses. It provides functions to convert errors to human-readable strings and format them for logging or debugging. Concrete use cases include reporting connection failures, invalid response bodies, protocol violations, and TLS handshake errors during HTTP transactions.",
      "description_length": 442,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Method",
      "library": "piaf",
      "description": "This module defines HTTP request methods and operations to classify their properties, such as safety, cacheability, and idempotence. It works with symbolic representations of standard methods like `GET`, `POST`, and custom methods via `Other`. Use this module to determine method characteristics for routing, caching, or validating HTTP requests.",
      "description_length": 346,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Request",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP request objects, providing accessors for components like method, target, version, headers, scheme, and body. It supports creating requests with custom parameters and modifying existing requests using labeled optional fields. Concrete use cases include building client-side HTTP requests, inspecting incoming request data, and formatting requests for network transmission.",
      "description_length": 415,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Ws",
      "library": "piaf",
      "description": "This module implements WebSocket communication by handling message framing and connection management. It works with data types like `Message.t` for representing WebSocket frames and `Descriptor.t` for managing active connections. Concrete use cases include sending and receiving text or binary messages, handling control frames like ping/pong, and managing connection closure with proper framing and buffering.",
      "description_length": 410,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions",
      "library": "piaf",
      "description": "This module defines types and operations for handling HTTP, TLS, and ALPN protocol versions. It supports parsing, comparing, and converting between string and structured representations of these versions. Concrete use cases include validating HTTP and TLS versions during network communication, negotiating ALPN protocols in TLS handshakes, and generating version-compatible headers in network services.",
      "description_length": 403,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Body",
      "library": "piaf",
      "description": "This module provides utilities for handling HTTP message payloads through construction, transformation, and iterative processing of chunked data streams. It operates on `Bigstringaf.t` and `string` fragments encapsulated in `IOVec.t` structures, supporting both synchronous and asynchronous consumption patterns with explicit handling of stream termination, error propagation, and content-length metadata. Typical applications include streaming large HTTP responses, incremental parsing of chunked transfers, and converting between memory-efficient bigstring buffers and heap-allocated string representations for compatibility with different processing pipelines.",
      "description_length": 663,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Status",
      "library": "piaf",
      "description": "This module provides operations to classify HTTP status codes into standard categories (e.g., informational, client error), convert between integer, string, and typed representations, and check specific properties like permanent redirection. It works with polymorphic variant types (e.g., `Code of int`, `` `Moved_permanently ``) and includes utilities for parsing, formatting, and validating status codes according to RFC standards. It is particularly useful in web servers or clients for handling response semantics, redirect logic, and error classification.",
      "description_length": 560,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Scheme",
      "library": "piaf",
      "description": "This module defines types for HTTP and HTTPS schemes and provides functions to convert between URIs and these types. It includes operations to parse a URI into an `http` or `https` scheme, convert schemes to strings, and pretty-print them. Use cases include validating and handling URL schemes in network-related code.",
      "description_length": 318,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Request_info",
      "library": "piaf",
      "description": "This module represents HTTP request metadata, including the request scheme, HTTP version, client address, and an Eio switch for managing asynchronous operations. It is used to capture and pass contextual information during HTTP request handling. Concrete use cases include routing decisions based on HTTP version, logging client addresses, and managing resource lifetimes via the Eio switch.",
      "description_length": 391,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cookies",
      "library": "piaf",
      "description": "This module handles HTTP cookies through two submodules: `Set_cookie` constructs and manipulates `Set-Cookie` headers with support for expiration, domain, path, and security attributes, while `Cookie` parses and formats cookie headers into key-value lists. It works with string pairs, `Piaf.Headers.t`, and custom types for expiration and same-site policies. Use cases include setting secure session cookies with max-age or session scope, and extracting cookies from incoming HTTP requests for authentication or tracking.",
      "description_length": 521,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf",
      "library": "piaf",
      "description": "This module processes HTTP headers through specialized operations for parsing, constructing, and manipulating header fields in both request and response contexts. It works with structured representations of header names and values, supporting case-insensitive lookups, multi-value handling, and efficient serialization to and from wire format. Concrete use cases include validating host headers in reverse proxies, managing content negotiation headers like `Accept` and `Content-Type`, and implementing custom header-based authentication schemes.",
      "description_length": 546,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Parameters.Map",
      "library": "piaf.multipart_form",
      "description": "This module provides key-value map operations for managing HTTP multipart form content type parameters, supporting insertion",
      "description_length": 124,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Subtype",
      "library": "piaf.multipart_form",
      "description": "This module defines and validates content type subtypes for multipart forms, supporting IETF, IANA, and custom `X_token` types. It provides a parser for IANA tokens and a formatter for pretty-printing subtypes. Use it when handling or constructing content types in HTTP multipart form data processing.",
      "description_length": 301,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Header.Decoder",
      "library": "piaf.multipart_form",
      "description": "Parses HTTP multipart form headers from raw byte strings into structured values. It operates on `Piaf_multipart_form.Multipart_form.Header.t` values using the Angstrom parsing library. Useful for extracting form field metadata, such as content type and disposition, during HTTP request handling.",
      "description_length": 295,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Parameters.Map",
      "library": "piaf.multipart_form",
      "description": "This map implementation manages key-value associations with string keys and polymorphic values, offering dictionary operations like insertion, lookup, filtering, and list-aware transformations to handle multi-value parameters. It supports bidirectional conversion between maps and sequences of key-value pairs, enabling bulk updates via `add_seq` and iterative processing through reversed or key-indexed sequences. Designed for multipart form parameter handling, it excels in scenarios requiring flexible storage, combination, or traversal of content type metadata, such as parsing repeated fields or merging parameter sets from disparate sources.",
      "description_length": 647,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Parameters",
      "library": "piaf.multipart_form",
      "description": "This module manages key-value pairs for HTTP multipart form content type parameters, where keys are strings and values can be either strings or tokens. It supports creating, adding, and serializing parameter maps, with functions to safely or unsafely convert strings into keys and values. Use cases include constructing and manipulating Content-Type headers with parameters like charset or boundary in HTTP requests.",
      "description_length": 416,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Type",
      "library": "piaf.multipart_form",
      "description": "This module defines a type `t` representing various MIME content types, including standard categories like `Text`, `Image`, and `Application`, as well as custom types via `Ietf_token` and `X_token`. It provides a function `pp` to format these content types for output, enabling precise serialization in HTTP multipart form handling. Use cases include parsing and generating Content-Type headers in web applications that process file uploads or structured form data.",
      "description_length": 465,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Parameters",
      "library": "piaf.multipart_form",
      "description": "This module provides operations for parsing, manipulating, and comparing key-value maps representing content-type parameters in multipart forms, where keys are strings and values are either `String` or `Token` variants. It includes utilities for unescaping encoded values, converting between list and map representations, and safely handling parameter equality checks. Specific use cases include processing HTTP headers with encoded parameters, validating multipart form boundaries, and normalizing content-type metadata for comparison or serialization.",
      "description_length": 553,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes content using specified transfer encodings like Base64, Quoted-printable, or raw Binary. It operates on pretty-printing buffers (`Prettym.ppf`) to format encoded data directly during output. Use it when generating MIME-compliant messages with embedded file attachments or binary payloads.",
      "description_length": 308,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Field",
      "library": "piaf.multipart_form",
      "description": "This module represents HTTP header fields with typed values, associating a field name with a specific value type. It supports constructing and deconstructing fields using a GADT-based representation, enabling precise type handling for each field. Concrete use cases include parsing and building HTTP headers with strict type guarantees, such as extracting a `Content-Type` field with a specific media type value.",
      "description_length": 412,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Type",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content type values used in HTTP multipart form parsing. It includes types for discrete media types like text and image, composite types like multipart, and extensions such as IETF and X-tokens. Functions allow constructing, comparing, printing, and validating these content types, with specific use cases in handling HTTP request boundaries and form data encoding.",
      "description_length": 401,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Set",
      "library": "piaf.multipart_form",
      "description": "This module provides set operations for managing collections of string-based multipart form field names, supporting union, intersection, difference, and transformations like filtering or mapping. It includes utilities for converting sets to sequences, iterating in standard or reversed order, and checking membership or equality, which are useful for tasks like form validation, field aggregation, or comparing sets of required and submitted fields. The data structures focus on immutable sets and sequences of strings, following functional programming patterns for predictable manipulation.",
      "description_length": 591,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module defines an encoder for field names in multipart form data. It provides a function `field_name` that converts a string into a prettym-formatted value suitable for use as a form field name. It is used when serializing multipart form fields to ensure proper formatting and escaping of field names.",
      "description_length": 306,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Decoder",
      "library": "piaf.multipart_form",
      "description": "Parses string values into field names for multipart form data using the Angstrom parsing library. Works directly with byte strings and Angstrom's parser combinators. Useful for extracting form field names from raw HTTP request data during form submission processing.",
      "description_length": 266,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type",
      "library": "piaf.multipart_form",
      "description": "This module handles MIME content types for HTTP multipart forms, combining type, subtype, and parameter components into structured values. It provides operations to construct, compare, serialize, and parse content types, supporting precise handling of headers like `Content-Type` in web applications processing file uploads or form data. Concrete use cases include validating and generating content type strings with parameters such as `charset` or `boundary`.",
      "description_length": 460,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides functions for parsing and validating tokens, whitespace, and control characters in content encoding headers. It includes parsers for specific token types like `base64`, `quoted-printable`, and custom extensions, returning structured values for further processing. Use cases include decoding MIME content transfer encodings and validating header values in HTTP multipart form parsing.",
      "description_length": 404,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Map",
      "library": "piaf.multipart_form",
      "description": "This module provides dictionary operations for managing string-keyed collections with support for both single and multiple values per key, enabling transformations, filtering, and ordered traversal. It works with maps that associate string-based field names to generic values, offering utilities to convert between maps, lists, and sequences while preserving key ordering. Typical use cases include processing HTTP multipart form data or query parameters where fields may have multiple entries, requiring aggregation, iteration, or conditional updates.",
      "description_length": 552,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Header",
      "library": "piaf.multipart_form",
      "description": "This module handles HTTP headers within `multipart/form-data` parts, providing access to fields like content type, encoding, and disposition. It supports operations to retrieve, check existence, and convert header fields to and from lists, with concrete use cases in parsing and processing form data during HTTP request handling. The Decoder submodule specifically parses raw byte strings into structured header values using Angstrom.",
      "description_length": 434,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides parsers for decoding MIME content types and parameters from byte streams, focusing on handling tokens, attributes, and UTF-8 encoded values. It processes key-value pairs and structured content types, supporting both standard MIME conventions (like `application` or `text`) and custom extensions. Typical use cases include parsing HTTP multipart/form-data in web applications, extracting form fields, and handling file uploads with complex encoding requirements.",
      "description_length": 482,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Header.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides functions to parse HTTP multipart form headers using the Angstrom parsing library. It includes a predicate to check for whitespace characters and parsers for individual header fields and complete header lists. It is used to extract structured header data from raw byte strings in multipart form data processing.",
      "description_length": 332,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Subtype",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content type subtypes used in multipart form parsing, supporting IETF, IANA, and custom extension tokens. It provides functions to construct, compare, and format these subtypes, ensuring valid values via result-returning and exception-raising variants. Concrete use cases include parsing and validating content type headers in HTTP requests.",
      "description_length": 377,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field.Decoder",
      "library": "piaf.multipart_form",
      "description": "Parses a specific field from a multipart form, using an optional map of field witnesses to decode values into structured types. It operates on `Piaf_multipart_form.Field_name.Map` and `Piaf_multipart_form.Field.field` values, enabling precise extraction of form fields during parsing. This is useful when handling HTTP multipart form data where specific fields need to be decoded into custom data types based on their names.",
      "description_length": 424,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_disposition",
      "library": "piaf.multipart_form",
      "description": "This module handles parsing and constructing Content-Disposition headers in multipart form data. It provides accessors to retrieve disposition type, name, filename, and size from a parsed header, along with functions to create and format such headers. Typical use cases include processing file uploads in HTTP requests by extracting metadata like filenames and content disposition types (e.g., inline or attachment).",
      "description_length": 416,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes content disposition headers for multipart form data. It provides functions to serialize disposition types like `Attachment` and `Inline`, along with associated parameters such as filename and size. Use it when generating HTTP requests with file uploads or form data that requires structured content disposition formatting.",
      "description_length": 342,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides parsers for decoding Content-Disposition headers in multipart form data, extracting structured information like filenames, dates, sizes, and disposition types from raw byte streams. It leverages the Angstrom library to transform low-level input into OCaml values such as strings, integers, and custom disposition types. Typical use cases include processing HTTP requests with multipart/form-data encodings, handling file upload metadata, and parsing form submissions in web services.",
      "description_length": 504,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_encoding",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content encoding types used in multipart form data, such as `Base64`, `Quoted_printable`, and custom token encodings. It provides functions to convert between string representations and typed values, along with pretty-printing support. Use this module when parsing or generating Content-Transfer-Encoding headers in email or HTTP multipart payloads.",
      "description_length": 385,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes MIME content types and related components into a pretty-printed format. It handles media types, subtypes, parameters, and values, following standards like IANA and IETF token conventions. It is used to format `Content-Type` headers in HTTP multipart form data, ensuring correct syntax for transmission.",
      "description_length": 322,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Field_name",
      "library": "piaf.multipart_form",
      "description": "This module represents and manipulates field names in multipart form data. It provides operations for comparing, capitalizing, and validating field names, as well as checking prefixes and canonicalizing values. It is used to handle standard header fields like content type, transfer encoding, and disposition in multipart form parsing and construction.",
      "description_length": 352,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Header.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module provides utilities for constructing structured header fields with precise formatting, including indentation, line wrapping, and value serialization. It operates on custom formatting combinators (`ppf`, `order`, `t`) to encode strings, lists, and optional values into RFC-compliant multipart form headers, managing output emission and buffering. It is particularly useful for generating complex HTTP multipart/form-data payloads with controlled layout and hierarchical content organization.",
      "description_length": 501,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module provides a function to encode a multipart form field into a formatted output stream using a pretty-printing mechanism. It operates on `Piaf_multipart_form.Field.field` values and writes the encoded result to a `Prettym.ppf` stream. A concrete use case is serializing HTTP multipart form data for transmission in client requests or server responses.",
      "description_length": 360,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Rfc2046",
      "library": "piaf.multipart_form",
      "description": "This module implements parsers and utilities for handling multipart/form-data as defined by RFC 2046. It provides functions for boundary detection, delimiter handling, and parsing message bodies with support for nested multipart structures. Key operations include constructing and parsing boundaries, consuming input between delimiters, and extracting body parts with associated headers and content.",
      "description_length": 399,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type",
      "library": "piaf.multipart_form",
      "description": "This module handles MIME content type operations for HTTP multipart/form-data, focusing on structured manipulation of type/subtype pairs, parameter handling with encoding, and boundary extraction. It provides utilities for parsing and serializing content type headers, validating character constraints, and performing equality checks on typed fields and parameters. Key use cases include processing form data boundaries, normalizing content type values, and managing encoded parameter key-value pairs in HTTP requests.",
      "description_length": 518,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content disposition headers in multipart form data. It provides types for disposition kinds, file metadata, and parameter lists, along with functions to construct, inspect, and format these values. It is used to parse and generate Content-Disposition headers for handling file uploads and form submissions in HTTP services.",
      "description_length": 359,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Header",
      "library": "piaf.multipart_form",
      "description": "This module manages HTTP multipart form headers as lists of key-value pairs with specialized accessors and modifiers. It supports operations like adding, replacing, and querying header fields by name, extracting specific header values, and converting to and from lists. It is used to construct and manipulate structured headers for multipart form data, particularly in HTTP request handling and form data parsing workflows.",
      "description_length": 423,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field",
      "library": "piaf.multipart_form",
      "description": "Handles parsing and encoding of individual multipart form fields, working with `Piaf_multipart_form.Field_name.t`, `Piaf_multipart_form.Field.t`, and structured values. Provides functions to convert between raw form data and typed values using Angstrom parsers and Prettym formatters. Useful for extracting and serializing specific HTTP form fields like file uploads or text inputs into domain-specific types.",
      "description_length": 409,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content encoding types used in HTTP multipart forms, including standard encodings like Base64, Quoted-printable, and binary. It provides functions to parse and compare encoding values, convert them to and from strings, and handle custom extensions such as IETF or X-tokens. Use this module to validate and process content transfer encodings when parsing or generating MIME-formatted data, such as email or HTTP payloads with file uploads.",
      "description_length": 474,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name",
      "library": "piaf.multipart_form",
      "description": "This module handles string-based field names for multipart form data with validation, comparison, and transformation operations. It provides utilities to canonicalize, capitalize, and validate field names, along with serialization and deserialization functions for use in HTTP form processing. Concrete use cases include parsing raw HTTP request data into valid field names, formatting field names during form serialization, and managing sets or maps of field names with ordered traversal and multi-value support.",
      "description_length": 513,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form",
      "library": "piaf.multipart_form",
      "description": "This module parses and constructs `multipart/form-data` payloads, handling operations like streaming part extraction, header parsing, and boundary management. It works with structured data types including content types, encodings, and headers, along with streams and byte buffers for efficient processing. Concrete use cases include handling HTTP form submissions with file uploads, streaming large multipart payloads without full in-memory storage, and building valid multipart responses with custom boundaries and encoded content.",
      "description_length": 532,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form",
      "library": "piaf.multipart_form",
      "description": "This module processes and constructs HTTP multipart/form-data payloads for handling file uploads and form submissions. It provides structured types and operations for content dispositions, encodings, headers, and form fields, enabling efficient parsing, validation, and serialization of MIME-formatted data. Concrete use cases include streaming multipart form data, extracting file metadata, and handling encoded content in HTTP services.",
      "description_length": 438,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_stream",
      "library": "piaf.stream",
      "description": "This module implements asynchronous streams for producing and consuming sequences of values, supporting operations like creation, mapping, iteration, and folding. It works with polymorphic stream types and optional values, enabling efficient handling of asynchronous data sources. Concrete use cases include processing HTTP chunked responses, streaming file reads, or implementing custom async generators with backpressure.",
      "description_length": 423,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 83,
    "meaningful_modules": 80,
    "filtered_empty_modules": 3,
    "retention_rate": 0.963855421686747
  },
  "statistics": {
    "max_description_length": 663,
    "min_description_length": 124,
    "avg_description_length": 406.4125,
    "embedding_file_size_mb": 1.1593961715698242
  }
}