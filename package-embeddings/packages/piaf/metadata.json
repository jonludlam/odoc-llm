{
  "package": "piaf",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 80,
  "creation_timestamp": "2025-07-15T23:19:11.587040",
  "modules": [
    {
      "module_path": "Piaf_stream",
      "library": "piaf.stream",
      "description": "This module implements asynchronous streams for handling sequences of values with support for creation, consumption, and lifecycle management. It works with polymorphic stream types that can be populated incrementally, closed, and processed using operations like `take`, `map`, `iter`, and `fold`. Concrete use cases include streaming HTTP responses, processing asynchronous data sources, and managing pipelined operations with backpressure.",
      "description_length": 441,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Multipart.Pp",
      "library": "piaf.multipart",
      "description": "This module provides functions to format and print multipart form data structures, including fields, content types, and extensions, using OCaml's standard formatting library. It works directly with data types representing HTTP multipart content, such as field values, content type trees, and subtype tokens. Use this module to generate human-readable string representations of multipart form components for logging, debugging, or display purposes.",
      "description_length": 447,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Multipart",
      "library": "piaf.multipart",
      "description": "This module processes multipart form data in HTTP requests, parsing headers, content types, and form fields into structured values while supporting streaming for efficient handling of large payloads like file uploads. It includes operations to extract and decode individual parts, manage content disposition, and navigate nested multipart structures. The formatting submodule integrates with OCaml's standard pretty-printing system to render multipart components\u2014such as fields and content types\u2014as human-readable strings for debugging or logging. Together, they enable both programmatic manipulation and inspection of multipart data streams in web applications.",
      "description_length": 662,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sendfile",
      "library": "piaf.sendfile",
      "description": "This module provides functions to efficiently transfer data from a source file descriptor to a destination file descriptor using the `sendfile` system call. It supports both partial and complete file transfers, handling interruptions like `EINTR` and `EAGAIN` automatically for reliable transmission. These functions are useful for high-performance network servers that need to stream file contents directly to sockets without buffering in user space.",
      "description_length": 451,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Parameters.Map",
      "library": "piaf.multipart_form",
      "description": "This module provides a persistent map structure for managing HTTP content type parameters with string keys and arbitrary value types, supporting functional operations like search, traversal, transformation, and filtering. It includes utilities for bidirectional conversion between maps and sequences, enabling efficient bulk insertion and iteration, particularly suited for parsing and manipulating multipart form data in type-safe workflows. Key use cases involve processing header parameters, normalizing form fields, and handling structured payloads in HTTP requests.",
      "description_length": 570,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Parameters",
      "library": "piaf.multipart_form",
      "description": "This module handles parsing and constructing HTTP content-type parameters, such as those found in multipart form boundaries or charset declarations. It supports safe creation and manipulation of keys and values, where values can be plain strings or tokens, and integrates a persistent map structure for managing these parameters with functional operations like search, traversal, and transformation. You can use it to parse and format content-type headers, normalize form fields, and handle structured payloads in HTTP requests while ensuring correct handling of encoded values and boundary delimiters. The module enables efficient bulk insertion and iteration through bidirectional conversion between maps and sequences, making it suitable for type-safe multipart data workflows.",
      "description_length": 780,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Parameters.Map",
      "library": "piaf.multipart_form",
      "description": "This module provides dictionary operations for managing content type parameters with string keys and arbitrary values, supporting both single-value and list-valued entries through insertion, deletion, lookup, and merging. It works with maps and sequences of key-value pairs, offering traversal, transformation, filtering, and conversion between structured formats, alongside equality checks and membership queries. These features are particularly useful for parsing multipart form headers with multiple values, combining parameter sets, or transforming form data during HTTP request handling.",
      "description_length": 592,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Subtype",
      "library": "piaf.multipart_form",
      "description": "This module defines and validates content type subtypes for multipart forms, supporting IETF, IANA, and custom `X_token` types. It provides a parser for IANA-defined subtypes and a formatter for pretty-printing. Concrete use cases include parsing and representing media subtypes like `plain` in `text/plain` or custom types such as `x-custom-type`.",
      "description_length": 348,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Header.Decoder",
      "library": "piaf.multipart_form",
      "description": "Parses HTTP multipart form headers from raw byte streams using Angstrom parsers. Works with `Piaf_multipart_form.Multipart_form.Header.t` to extract header fields like content type and disposition. Useful for decoding multipart/form-data requests in web servers or clients.",
      "description_length": 273,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type.Type",
      "library": "piaf.multipart_form",
      "description": "This module defines a type `t` representing various MIME content types, including standard categories like `Text`, `Image`, and `Multipart`, as well as custom extensions via `Ietf_token` and `X_token`. It provides a function `pp` to format values of type `t` as strings, suitable for use in HTTP headers or logging. This is useful when handling multipart form data, especially for distinguishing between different kinds of uploaded content.",
      "description_length": 440,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes content using specified transfer encodings like Base64, Quoted-Printable, or raw binary, producing formatted output on a `Prettym.ppf`. It directly handles string-based content, applying the chosen encoding mechanism for transmission over protocols requiring specific content encoding. Use it when generating MIME-compliant messages or HTTP requests with encoded payloads such as file uploads.",
      "description_length": 413,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Header",
      "library": "piaf.multipart_form",
      "description": "This module manages HTTP headers within multipart/form-data parts, offering direct access to content type, encoding, and disposition fields. It provides operations to retrieve, check existence, and convert headers to and from list representations. The included parser submodule decodes raw byte streams into header values using Angstrom, enabling efficient handling of multipart/form-data requests in web servers or clients. Example usage includes extracting content type metadata or parsing header fields during form data ingestion.",
      "description_length": 533,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module defines a parser for extracting field names from multipart form data using the Angstrom parsing library. It operates on string inputs and produces a structured representation of form field names. Useful for processing HTTP multipart/form-data requests, such as parsing file upload forms or structured form submissions.",
      "description_length": 330,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_encoding",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content encoding types used in multipart form data, such as `Base64`, `Quoted_printable`, and custom token encodings. It provides functions to convert between string representations and typed values, along with pretty-printing support. Use this module when parsing or generating Content-Transfer-Encoding headers in email or HTTP multipart payloads.",
      "description_length": 385,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides functions for parsing and validating content encodings in multipart form data, including checks for special characters, tokens, and whitespace. It defines parsers for specific encoding mechanisms like base64, quoted-printable, and custom tokens. Use cases include decoding Content-Transfer-Encoding headers and validating token-based encoding names in HTTP multipart messages.",
      "description_length": 397,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes content disposition headers for multipart form data. It provides functions to serialize disposition types like `Attachment` and `Inline`, along with associated parameters such as filename and size. Use it when generating HTTP requests with file uploads or form data that requires structured content disposition formatting.",
      "description_length": 342,
      "index": 15,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module offers RFC-compliant parsers for decoding Content-Disposition headers, extracting parameters such as filenames, timestamps, and sizes. It processes byte streams and character data to produce structured values like strings, integers, and unit, with utilities for handling quoted strings, token validation, and date parsing. These capabilities are essential for processing multipart form data, particularly when retrieving file metadata during HTTP uploads.",
      "description_length": 467,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module encodes MIME content types and related values into a pretty-printing format. It handles media types like `application`, `text`, and `multipart`, along with subtypes, parameters, and structured content type values. It is used to format HTTP content type headers and multipart form data metadata for output or logging.",
      "description_length": 328,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Map",
      "library": "piaf.multipart_form",
      "description": "This module offers associative map operations for managing multipart form field names paired with arbitrary values, supporting key-based queries, iteration, and transformations. It facilitates converting between maps and sequences or lists of key-value pairs, enabling efficient processing of form data. Specific use cases include parsing and manipulating HTTP multipart form submissions where field names require structured handling and predicate-driven selection.",
      "description_length": 465,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Field.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module provides a function to serialize multipart form fields into a human-readable format using a pretty-printing buffer. It operates on `Piaf_multipart_form.Field.field` values, which represent individual form fields in a multipart form data structure. A concrete use case is generating debug output or logging the contents of form fields during HTTP request handling.",
      "description_length": 375,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Field",
      "library": "piaf.multipart_form",
      "description": "This module represents HTTP header fields with typed values, associating each field name with a specific value type. It supports constructing and deconstructing fields using a GADT-based structure, enabling precise type handling for HTTP headers. Concrete use cases include parsing and serializing headers like `Content-Type` or `Authorization` with correctly typed values.",
      "description_length": 373,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Parameters",
      "library": "piaf.multipart_form",
      "description": "This module processes content type parameters in multipart forms by parsing, converting, and manipulating key-value pairs where keys are strings and values are either strings or tokens. It provides maps with operations for unescaping, equality checks, and conversions between list and map representations, supporting both single-value and list-valued entries through insertion, deletion, lookup, and merging. Submodules extend this functionality with dictionary operations over sequences and structured transformations, enabling tasks like parsing multipart headers, combining parameter sets, or normalizing URL-encoded form data. Specific uses include extracting parameter values from HTTP Content-Type headers, merging and filtering form fields during request handling, and converting between different structured representations of form data.",
      "description_length": 845,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module provides parsers for decoding MIME content types and associated parameters from HTTP multipart/form-data, focusing on handling token validation, attribute extraction, and parameter key-value pairs. It operates on byte strings and character sequences using Angstrom, supporting UTF-8 encoding and quoted string semantics. Typical use cases include parsing headers and encoded payloads in web applications, such as form submissions or file uploads with structured metadata.",
      "description_length": 483,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Set",
      "library": "piaf.multipart_form",
      "description": "This module manages string-based identifiers for form fields in multipart data, offering set operations like union, intersection, and difference, alongside membership checks, transformations (map, filter), and bidirectional conversions with lists and sequences. It operates on collections of strings representing field names, supporting efficient validation of required fields, detection of duplicates, and hierarchical form data processing through iterative and combinatorial set manipulations.",
      "description_length": 495,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_type",
      "library": "piaf.multipart_form",
      "description": "This module manages HTTP content types by defining and manipulating type, subtype, and parameters, enabling precise parsing, construction, and formatting for use in HTTP requests. It supports operations like parsing from and converting to strings, handling multipart boundaries, and distinguishing content categories such as `Text`, `Image`, and `Multipart`, including custom extensions. Submodules provide structured handling of content-type parameters using persistent maps, validation for multipart subtypes, and type-safe representation of MIME types with formatting support. You can use it to process multipart form data, normalize headers, and ensure correct handling of encoded values and boundary delimiters across standard and custom content types.",
      "description_length": 757,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Header.Decoder",
      "library": "piaf.multipart_form",
      "description": "This module defines parsers for HTTP multipart form headers, specifically handling field parsing and whitespace checks. It works with character inputs and constructs lists of form fields using Angstrom parsers. It is used to decode raw header data into structured form fields during multipart form parsing.",
      "description_length": 306,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Field_name",
      "library": "piaf.multipart_form",
      "description": "This module defines a private string type for representing field names in multipart form data, along with operations to create, compare, and manipulate these field names. It provides functions for validation, case conversion, and prefix checks, ensuring correct formatting and handling of field names like \"content-type\" and \"content-disposition\". Use cases include parsing and constructing multipart form headers with strict field name conventions.",
      "description_length": 449,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Subtype",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content type subtypes used in multipart form parsing, supporting IETF, IANA, and custom extension tokens. It provides functions to construct, compare, and format these subtypes, ensuring valid handling of media types and extensions. Concrete use cases include parsing and validating content type headers in HTTP requests and form data processing.",
      "description_length": 382,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Header.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module supports encoding and serialization of string-like data types (`string`, `bytes`, `bigstring`) and structured data (lists, optional values) into formatted textual representations. It ensures RFC 822 compliance through precise handling of line breaks, indentation, and whitespace, primarily used for constructing multipart form headers in HTTP requests. Key operations include streaming output, line wrapping, and compositional encoders for embedding values with custom formatting, enabling efficient generation of headers with complex hierarchical layouts.",
      "description_length": 568,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form.Content_disposition",
      "library": "piaf.multipart_form",
      "description": "This module handles parsing and constructing Content-Disposition headers in multipart form data. It provides accessors to retrieve disposition type, name, filename, and size from a parsed header, along with functions to create and format such headers. Typical use cases include processing file uploads in HTTP requests by extracting metadata like filenames and disposition types from incoming form data.",
      "description_length": 403,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field.Decoder",
      "library": "piaf.multipart_form",
      "description": "Parses a specific field from a multipart form, using an optional map of field witnesses to validate structure. It operates on multipart form field names and values, producing a result within the Angstrom parser monad. Useful for decoding known fields from HTTP multipart form data into typed values.",
      "description_length": 299,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type.Type",
      "library": "piaf.multipart_form",
      "description": "This module defines and manipulates content type values used in HTTP multipart form data. It provides types for discrete media types like text and image, composite types like multipart, and extensions such as IETF and custom tokens. Functions include parsing, comparison, string conversion, and formatting for these content types, along with helpers to check type classifications and construct specific values.",
      "description_length": 410,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name.Encoder",
      "library": "piaf.multipart_form",
      "description": "This module defines an encoder for field names in multipart form data. It provides a function `field_name` that converts a string into a prettym-formatted value suitable for use as a form field name. It is used when serializing multipart form fields to ensure proper formatting of field names in HTTP requests.",
      "description_length": 310,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Multipart_form",
      "library": "piaf.multipart_form",
      "description": "This module processes MIME multipart/form-data by parsing and assembling structured payloads with support for streaming, handling form submissions and file uploads. It structures data using field names, content types, and content dispositions, and supports encodings like Base64 and Quoted-printable for safe data transfer. You can decode multipart streams into fields with metadata, encode parts into valid messages with custom headers and boundaries, or extract filename and encoding info from Content-Disposition headers. Submodules provide typed access to HTTP headers, content types, and encoding values, enabling precise parsing, construction, and normalization of multipart components in HTTP or email contexts.",
      "description_length": 718,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Header",
      "library": "piaf.multipart_form",
      "description": "This module manages HTTP multipart form headers, allowing manipulation of fields through operations like add, replace, and remove, while supporting extraction of key values such as content type and disposition. Its parsing submodule decodes raw header data into structured fields using Angstrom, handling whitespace and field formatting during input processing. The encoding submodule constructs headers by serializing strings and structured data with RFC 822 compliance, supporting line wrapping and custom formatting for hierarchical layouts. Example uses include building and decoding multipart form headers in HTTP requests with precise control over field structure and textual representation.",
      "description_length": 697,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field_name",
      "library": "piaf.multipart_form",
      "description": "This module processes field names in multipart form data with validation, comparison, and transformation functions that enforce HTTP form field naming conventions. It supports case normalization, safe construction, and structured parsing through Angstrom, enabling precise extraction and formatting of field names in HTTP requests. The module's map and set submodules allow key-value associations and set operations over field names, facilitating validation, iteration, and hierarchical processing of form data. Example uses include parsing file upload forms, checking required fields, and serializing form data with correctly formatted field names.",
      "description_length": 649,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Rfc2046",
      "library": "piaf.multipart_form",
      "description": "This module implements parsers and formatters for handling multipart/form-data content according to RFC 2046. It provides functions to parse boundaries, delimiters, headers, and body parts, as well as utilities for consuming input streams during multipart parsing. Concrete use cases include parsing HTTP requests with file uploads and extracting structured form data with nested fields.",
      "description_length": 387,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_type",
      "library": "piaf.multipart_form",
      "description": "This module processes structured media types and parameters for web applications, offering functions to parse, construct, and manipulate content types, subtypes, and parameter dictionaries. It supports hierarchical type-subtype relationships, boundary extraction, and encoding or decoding between string representations and typed values, enabling tasks like handling HTTP multipart form data and content negotiation. Child modules refine this functionality with specific support for pretty-printing content types, parsing and merging parameter maps, decoding MIME types from byte strings, and managing subtype and media type values with validation. Examples include extracting boundary strings from multipart headers, normalizing form data parameters, and constructing or comparing content types with custom extensions.",
      "description_length": 819,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf_multipart_form.Content_disposition",
      "library": "piaf.multipart_form",
      "description": "This module handles the parsing and construction of content disposition headers for HTTP multipart form data, supporting standard and custom disposition types with file metadata and parameter attributes. It provides direct operations for encoding and decoding headers, managing special characters, and validating data, with structured extraction of values like filenames, timestamps, and sizes. The child modules specialize in serialization for generating form data with precise formatting and in RFC-compliant parsing for processing incoming multipart streams. You can use it to build or analyze content disposition headers with full control over encoding, decoding, and metadata handling.",
      "description_length": 690,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Content_encoding",
      "library": "piaf.multipart_form",
      "description": "This module handles content encodings for multipart form data, centered around a polymorphic variant type representing standard encodings like `Base64` and `Quoted_printable`, along with custom tokens. It supports core operations such as parsing from strings, converting to strings, and comparing encoding values, ensuring compliance with RFC specifications for HTTP and MIME. The encoding submodule applies these formats to string-based content, producing MIME-compliant output on a `Prettym.ppf`, while the parsing submodule decodes and validates headers, checking for valid encoding names and special characters in incoming messages. Use it to encode file uploads in HTTP requests or validate and process received multipart content with precise encoding checks.",
      "description_length": 764,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form.Field",
      "library": "piaf.multipart_form",
      "description": "This module processes multipart form fields by parsing and encoding structured data from raw multipart/form-data inputs. It works with field names, typed descriptions, and unparsed content, using Angstrom parsers and Prettym serializers to convert between raw and structured representations. The `Piaf_multipart_form.Field.field` type models individual form fields, while the pretty-printing submodule renders these fields in a human-readable format for debugging or logging. A typical use case involves decoding known fields into typed values using parsers, then serializing them for inspection or further processing.",
      "description_length": 618,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf_multipart_form",
      "library": "piaf.multipart_form",
      "description": "This module processes multipart/form-data by parsing, constructing, and manipulating structured payloads with support for streaming, file uploads, and HTTP form submissions. It provides typed representations for fields, headers, content types, and encodings, enabling precise decoding and encoding of multipart messages with custom boundaries, metadata, and formatting. Key operations include parsing raw multipart streams into structured fields, extracting filenames and content dispositions, applying Base64 or Quoted-printable encodings, and building RFC-compliant multipart messages. Example uses include handling HTTP POST requests with file uploads, validating form data, and serializing structured fields for transmission or logging.",
      "description_length": 740,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Config.HTTPS",
      "library": "piaf",
      "description": "This module defines an HTTPS server configuration with TLS settings, including certificate management, protocol version constraints, and client authentication enforcement. It works with TLS certificates, socket addresses, and configuration options to establish secure server connections. Concrete use cases include setting up a secure web server with mutual TLS authentication, restricting allowed TLS versions, and configuring trusted certificate authorities for client verification.",
      "description_length": 484,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Headers.Well_known.HTTP2",
      "library": "piaf",
      "description": "This module provides access to well-known HTTP/2 header fields as string values. It defines constants for common headers such as `host`, enabling direct use in HTTP/2 requests and responses. Concrete use cases include setting or checking standard HTTP/2 headers in server or client implementations.",
      "description_length": 298,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Headers.Well_known.HTTP1",
      "library": "piaf",
      "description": "This module provides access to well-known HTTP/1 header names as string constants. It works with string data types to represent header keys like `host`. Use this module to standardize header names when constructing or parsing HTTP requests and responses.",
      "description_length": 254,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Headers.Well_known.Values",
      "library": "piaf",
      "description": "The module defines specific string values used in HTTP headers, such as `close`, which indicates that a connection should be closed after the response is sent. It works directly with string data types to represent standardized header field values. This module is useful when constructing or parsing HTTP messages where well-known header values must be referenced exactly, such as in web servers or HTTP clients.",
      "description_length": 411,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Versions.HTTP.Raw",
      "library": "piaf",
      "description": "This module handles raw HTTP version parsing, formatting, and comparison. It defines a version type with major and minor integers, and provides conversions to and from strings, along with predefined constants for common HTTP versions. Functions support exact string parsing, pretty-printing, and safe or unsafe conversion to an abstract HTTP version type used elsewhere in the library.",
      "description_length": 385,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions.HTTP",
      "library": "piaf",
      "description": "This module represents and processes HTTP version identifiers, supporting parsing, comparison, and string conversion for HTTP/1.0, HTTP/1.1, and HTTP/2. It defines the `t` type with major and minor version fields, along with operations to convert to and from strings, compare versions, and select appropriate versions during client-server negotiation. The child module handles low-level parsing and formatting, offering constants like `http_1_1` and safe conversion functions to ensure correct version handling in network communication. Example uses include validating incoming HTTP version strings and selecting the highest supported version during a handshake.",
      "description_length": 662,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Response.Upgrade",
      "library": "piaf",
      "description": "This module handles response upgrades for HTTP connections, supporting generic and WebSocket-specific upgrade mechanisms. It works with HTTP requests and responses, headers, and switch constructs to manage connection state. Concrete use cases include initiating WebSocket handshakes and handling custom protocol upgrades with user-defined callbacks.",
      "description_length": 349,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions.TLS",
      "library": "piaf",
      "description": "This module defines a type `t` representing supported TLS versions, including SSLv3 and TLS from 1.0 to 1.3. It provides functions to compare TLS versions, parse them from strings, and pretty-print them in a human-readable format. These operations are used when configuring or validating TLS protocol versions in secure communication stacks.",
      "description_length": 341,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Handler",
      "library": "piaf",
      "description": "Handles HTTP 404 Not Found responses by providing a function that returns a standard response. Works with the `Piaf.Response.t` type to construct error responses. Useful for routing logic where unmatched endpoints need to return a consistent error format.",
      "description_length": 255,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cookies.Cookie",
      "library": "piaf",
      "description": "Parses HTTP headers into a list of cookie key-value pairs and serializes such lists back into a cookie header string. Works directly with `Piaf.Headers.t` and lists of string pairs. Used to extract and format cookies from and to HTTP requests or responses.",
      "description_length": 256,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Server.Command",
      "library": "piaf",
      "description": "This module manages the lifecycle of network servers, providing functions to start and shut down servers that handle incoming connections via a custom handler. It works with stream sockets, socket addresses, and Eio switches to manage concurrency and resource cleanup. Concrete use cases include binding to a TCP address with specific socket options, handling incoming connections asynchronously, and gracefully shutting down a server after a timeout.",
      "description_length": 451,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Headers.Well_known",
      "library": "piaf",
      "description": "This module provides standardized string constants for HTTP header fields and values, enabling precise construction and parsing of HTTP messages. It includes operations to access common headers like `authorization`, `content_type`, and `location`, while its submodules HTTP1 and HTTP2 offer version-specific header constants such as `host` for HTTP/1 and HTTP/2 respectively. The Values submodule supplies associated string values like `close`, used to indicate connection behavior in HTTP headers. Use this module to ensure correctness when handling HTTP headers in clients or servers by referencing exact field names and values.",
      "description_length": 630,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Form.Multipart",
      "library": "piaf",
      "description": "Handles parsing of multipart form data from HTTP requests, providing access to uploaded files and form fields. It processes `Piaf.Request.t` inputs and returns streamed or collected form parts, each containing name, filename, content type, and body data. Useful for handling file uploads and form submissions in web applications.",
      "description_length": 329,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Ws.Descriptor",
      "library": "piaf",
      "description": "This module handles bidirectional WebSocket communication by providing functions to send and receive messages, including text, binary data, and control frames like ping/pong. It works with data types such as `t` for connection state, `Stream.t` for message sequences, and `IOVec.t` for efficient data transmission. Concrete use cases include streaming large payloads over WebSockets, implementing real-time messaging protocols, and managing connection lifecycle events like closing and ping/pong heartbeats.",
      "description_length": 507,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cookies.Set_cookie",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP `Set-Cookie` headers with precise control over attributes like expiration, path, domain, and security flags. It operates on a structured type `t` representing a cookie, allowing incremental updates through with_* functions and conversion to raw cookie strings. Concrete use cases include setting session cookies with expiration times, securing cookies for HTTPS contexts, and parsing cookies from HTTP headers for processing.",
      "description_length": 469,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Ws.Message",
      "library": "piaf",
      "description": "Represents WebSocket messages as a pair of opcode and payload. Provides functions to create, inspect, and manipulate message frames, including text, binary, and control frames. Used for handling low-level WebSocket communication, such as sending and receiving framed data over a network connection.",
      "description_length": 298,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Client.Oneshot",
      "library": "piaf",
      "description": "This module executes single HTTP requests with methods like GET, POST, HEAD, PUT, PATCH, and DELETE. It works with URIs, HTTP headers, optional request bodies, and configuration settings, returning parsed HTTP responses or errors. Use it to interact with REST APIs, fetch remote resources, or send data to web services.",
      "description_length": 319,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Versions.ALPN",
      "library": "piaf",
      "description": "Converts between string representations and HTTP version values. Works with the `Piaf.Versions.HTTP.t` type, handling parsing and serialization. Useful for processing HTTP headers where versions are exchanged as strings.",
      "description_length": 220,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Server.Config",
      "library": "piaf",
      "description": "This module configures HTTP servers with options for protocols, timeouts, buffers, and connection handling, while its HTTPS submodule manages TLS settings for secure connections. It supports specifying HTTP versions, enabling HTTP/2 server push, configuring TCP socket options, and setting up mutual TLS authentication with certificate authorities. You can define a server that only accepts HTTP/2, set read and write timeouts, enable TCP nodelay, and require client certificates for secure endpoints. The API combines low-level socket configuration with high-level protocol tuning for custom server setups.",
      "description_length": 607,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Server.Error_response",
      "library": "piaf",
      "description": "This module defines a type `t` representing error responses in a server context. It includes functions to construct and manipulate error responses, such as setting HTTP status codes and error messages. Concrete use cases include generating standardized error outputs for API endpoints or handling failed requests with consistent formatting.",
      "description_length": 340,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Versions",
      "library": "piaf",
      "description": "This module manages version identifiers for HTTP and TLS protocols, providing types and operations to parse, compare, and convert version values. The core `t` type represents HTTP versions with major and minor fields, while a separate `t` for TLS encodes versions like TLS 1.3 for secure communication stacks. Functions support string conversion, version negotiation, and validation, enabling tasks like parsing HTTP headers or selecting the highest mutually supported TLS level during handshake. Examples include converting \"HTTP/1.1\" to its internal representation or comparing TLS versions to enforce secure connections.",
      "description_length": 623,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Client",
      "library": "piaf",
      "description": "This module manages HTTP client connections for interacting with remote endpoints using standard HTTP methods like GET, POST, PUT, DELETE, and PATCH, as well as custom requests. It handles request and response bodies, HTTP headers, URI routing, and supports WebSocket upgrades and secure connections over HTTPS. The child module provides functions to execute individual HTTP requests with fine-grained control over headers, body content, and client configuration, returning structured responses or error details. You can use the combined functionality to build REST API clients, retrieve or modify remote resources, and manage persistent or stateful HTTP interactions programmatically.",
      "description_length": 685,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Form",
      "library": "piaf",
      "description": "This module processes HTTP form data, extracting fields and files from requests with support for streaming or collecting parts. It operates on `Piaf.Request.t`, parsing each form part into structured components like name, filename, content type, and body. You can use it to handle file uploads, retrieve text fields, or process large form submissions efficiently without loading all data into memory at once.",
      "description_length": 408,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Config",
      "library": "piaf",
      "description": "This module defines a configuration structure for HTTP client behavior, including options like redirect following, TLS settings, buffer sizes, and HTTP version preferences. It works with custom types for certificates, HTTP and TLS versions, and headers. Concrete use cases include setting up secure client connections with specific CA trust stores, configuring HTTP/2 support, and controlling redirect and timeout behavior.",
      "description_length": 423,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Scheme",
      "library": "piaf",
      "description": "This module defines types for HTTP and HTTPS schemes and provides functions to convert between URIs and these types. It includes operations to parse a URI into a scheme, render a scheme as a string, and pretty-print schemes in a human-readable format. Use this module when handling URL schemes in network-related code, such as routing or protocol dispatch.",
      "description_length": 356,
      "index": 66,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Piaf.Cookies",
      "library": "piaf",
      "description": "This module manages HTTP cookies by parsing, serializing, and manipulating cookie data, supporting key attributes like expiration, path, domain, and security flags. It operates on string-based key-value pairs and structured cookie types, allowing precise construction and interpretation of `Set-Cookie` headers. The parsing submodule extracts and formats cookies from HTTP headers, while the construction submodule enables incremental updates to cookie attributes before serialization. Examples include setting secure session cookies with expiration times or processing incoming cookies from a request.",
      "description_length": 602,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Status",
      "library": "piaf",
      "description": "This module provides typed representations and utility functions for handling HTTP status code classes (informational, successful, redirection, errors) along with conversions between integer, string, and polymorphic variant forms. It operates on a polymorphic variant type that supports standard codes (e.g., `Moved_permanently`) and arbitrary integer values, enabling robust classification and validation. Typical applications include HTTP response handling, status code validation, and logic branching based on semantic categories like permanent redirections or client errors.",
      "description_length": 578,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Cert",
      "library": "piaf",
      "description": "This module represents and prints SSL certificate data, supporting file paths or PEM-encoded strings. It provides a pretty-printing function `pp` for displaying certificate values in a readable format. Useful for debugging or logging certificate information in network applications.",
      "description_length": 282,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.IOVec",
      "library": "piaf",
      "description": "This module manages I/O vector structures, providing operations to create, shift, and measure them. It works with Bigstringaf.t buffers and supports precise memory slicing with offsets and lengths. Concrete use cases include efficient data transmission over sockets and handling fragmented data in network protocols.",
      "description_length": 316,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Error",
      "library": "piaf",
      "description": "This module defines error types for handling failures in HTTP/2 communication, including client and server-specific errors, TLS issues, and protocol violations. It provides functions to convert errors to human-readable strings and format them for logging or debugging. Use cases include error reporting in network clients, server response handling, and debugging protocol-level issues.",
      "description_length": 385,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Request",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP request objects, providing accessors for components like method, target, version, headers, scheme, and body. It supports creating requests with custom parameters and modifying existing requests using `with_`. Concrete use cases include building client requests for HTTP clients, inspecting incoming server requests, and formatting requests for logging or debugging.",
      "description_length": 409,
      "index": 72,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Piaf.Response",
      "library": "piaf",
      "description": "This module constructs and manipulates HTTP responses, offering direct access to status, headers, version, and body. It supports creating responses from strings, bigstrings, and streams, with specialized handling for file-backed and error responses. The upgrade submodule extends this functionality by enabling HTTP connection upgrades, including WebSocket handshakes and custom protocols, using requests, headers, and user-defined callbacks to manage state transitions. Together, they allow building, modifying, and upgrading HTTP responses efficiently, from simple static content to streaming bodies and persistent connections.",
      "description_length": 629,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Headers",
      "library": "piaf",
      "description": "This module standardizes HTTP header field names and values, offering direct access to common headers like `authorization`, `content_type`, and `location`. Its submodules HTTP1 and HTTP2 provide version-specific constants such as `host`, while Values contains associated strings like `close` for precise header construction. Use it to build or parse HTTP messages with exact field names and values, ensuring protocol correctness in clients and servers.",
      "description_length": 452,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Piaf.Server",
      "library": "piaf",
      "description": "This module implements a web server interface for handling HTTP requests and responses, using data types like `Request.t`, `Headers.t`, and `Body.t` to manage connections and route traffic. It supports defining custom error handling logic, creating HTTP connection handlers for Eio-based networking, and building request processing pipelines using middleware and service definitions. The error module constructs and manipulates error responses with functions to set status codes and messages, while the not_found module provides standard HTTP 404 responses for unmatched routes. Server lifecycle management is handled through functions to start and shut down servers, bind to TCP addresses, and manage asynchronous connections using Eio switches and stream sockets. Configuration options for HTTP versions, timeouts, TLS settings, and socket options allow fine-grained control over connection handling and protocol behavior.",
      "description_length": 924,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Request_info",
      "library": "piaf",
      "description": "This module represents HTTP request metadata, including the request scheme, HTTP version, client address, and an Eio switch for managing asynchronous operations. It is used to capture and pass contextual information during HTTP request handling. Concrete use cases include routing decisions based on the HTTP version, logging client addresses, and managing resource lifetimes via the Eio switch.",
      "description_length": 395,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Ws",
      "library": "piaf",
      "description": "This module enables bidirectional WebSocket communication by managing connection state and message transmission. It provides data types like `t` for connections, `Stream.t` for message sequences, and `IOVec.t` for efficient data handling, along with operations to send and receive text, binary, and control frames. You can use it to stream large payloads, implement real-time messaging, or manage connection events like heartbeats. It also models WebSocket messages as opcode-payload pairs, allowing low-level manipulation of framed data during transmission.",
      "description_length": 558,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf.Method",
      "library": "piaf",
      "description": "This module defines HTTP request methods and operations to classify their properties, such as safety, cacheability, and idempotence. It works with symbolic representations of standard methods like `GET`, `POST`, and custom methods via `Other`. Use this module to determine method characteristics for routing, caching, or HTTP compliance checks.",
      "description_length": 344,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Piaf",
      "library": "piaf",
      "description": "This module provides a comprehensive toolkit for building and managing HTTP and HTTPS clients and servers, handling everything from protocol versions and request/response lifecycle to secure communication and real-time data exchange. Core data types include structured representations of HTTP methods, status codes, headers, cookies, requests, responses, and WebSocket connections, along with configuration options for TLS, redirects, and HTTP versions. Operations span parsing and validating HTTP data, constructing and modifying messages, managing secure sessions, and handling streaming or file-backed content. You can use it to implement RESTful clients, route HTTP traffic, enforce TLS policies, process form submissions, manage cookies, and establish WebSocket connections for real-time communication.",
      "description_length": 807,
      "index": 79,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 83,
    "meaningful_modules": 80,
    "filtered_empty_modules": 3,
    "retention_rate": 0.963855421686747
  },
  "statistics": {
    "max_description_length": 924,
    "min_description_length": 220,
    "avg_description_length": 478.025,
    "embedding_file_size_mb": 0.2910795211791992
  }
}