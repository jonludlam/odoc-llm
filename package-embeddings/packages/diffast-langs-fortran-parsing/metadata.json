{
  "package": "diffast-langs-fortran-parsing",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 217,
  "creation_timestamp": "2025-08-15T17:49:12.495437",
  "modules": [
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for driving incremental parser execution through token supply and checkpoint manipulation, inspecting LR(1) parser states via index-based access and symbol comparisons, and analyzing grammar properties like nullability and first sets. It operates on parser environments, checkpoints, LR(1) states, productions, and terminal/nonterminal symbols, enabling use cases such as error recovery, custom parsing loop control, and grammar validation in compiler development workflows.",
      "description_length": 506,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates the conversion of Fortran abstract syntax tree (AST) nodes into annotated token sequences, supporting precise mapping between source code and structured representations. It provides utilities to classify and manipulate tokens derived from various Fortran constructs, including preprocessor directives and type specifications, while preserving positional information. These capabilities are essential for compiler frontends, code analysis tools, and language processing pipelines handling Fortran source code.",
      "description_length": 532,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran constructs like tokens, program units, and control structures by resuming from specific lexing positions, producing checkpointed parser states that facilitate staged parsing. It operates on a partial abstract syntax tree (`Ast.Partial.t`) and parameterizes recovery points over positional data, supporting context-sensitive analysis and error resilience. Designed for Menhir-based parsers, it is ideal for interactive development environments and compilers handling incomplete code, including complex elements like OpenMP directives or nested subroutine declarations.",
      "description_length": 618,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers low-level parsing and interpreter tools for incremental Menhir parsers, focusing on token stream manipulation, stack-based state transitions, and grammar analysis. It operates on tokens, parsing stacks, environments, and symbolic representations (terminals, nonterminals) to enable precise control over parsing strategies, error recovery, and grammar introspection. Specific applications include implementing custom error handling, debugging parser behavior through state inspection, and analyzing grammar properties like first sets and nullable symbols.",
      "description_length": 573,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides incremental parsing operations for Fortran syntax, enabling step-by-step analysis of program units, statements, and expressions through checkpoint-based resumption. It works with Lexing.position inputs and generates checkpoints parameterized over partial AST nodes, allowing parsers to track progress and recover mid-parsing. These capabilities are particularly useful for error recovery, partial input handling, and interactive parsing scenarios where resuming at specific syntactic boundaries is required.",
      "description_length": 528,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST elements (program units, expressions, type specs) into tokens annotated with source location data, enabling precise structural representation. It also analyzes and processes preprocessor tokens, identifying directives (e.g., includes, macros) and converting partial AST fragments into token streams. These operations support compiler workflows like macro expansion, include resolution, and source-to-source translation.",
      "description_length": 454,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to convert Fortran abstract syntax trees (ASTs) into tokenized representations with source location metadata and to analyze existing tokens for type information, size, and content extraction. It works with Fortran AST nodes (program units, expressions, type specs), parsing specifications, and raw token data structures. These capabilities support compiler pipeline stages like code generation, syntax highlighting, and static analysis tools requiring precise Fortran source manipulation.",
      "description_length": 520,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by converting abstract syntax tree (AST) nodes into annotated token sequences, enabling precise source-to-structure mapping. It supports classification and manipulation of tokens from Fortran constructs such as preprocessor directives and type specifications, preserving positional data. Key functions include `tag_to_node` for reconstructing AST nodes from tagged contexts and `make_tag` for creating token tags with source locations.",
      "description_length": 477,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates the conversion of Fortran abstract syntax tree (AST) nodes\u2014such as program units, expressions, and type specifications\u2014into annotated token sequences with positional metadata. It enables analysis of preprocessor tokens by classifying directive types (e.g., include statements), measuring token dimensions, and extracting fragments from partial AST structures. These capabilities are particularly useful for code refactoring tools, static analyzers, or preprocessors requiring precise token-level manipulation and semantic context tracking in Fortran codebases.",
      "description_length": 584,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers low-level parsing operations for incremental Menhir parsers, focusing on token feeding, checkpoint manipulation, and stack management to enable precise control over parsing workflows. It operates on parser checkpoints, environments, and grammar structures, providing capabilities like state introspection, reduction forcing, and grammar analysis (e.g., nullability checks, first-set computation). These features are particularly useful for implementing Fortran compilers, error-resilient parsers, or tools requiring fine-grained manipulation of parsing states and grammar properties.",
      "description_length": 602,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions for incrementally parsing Fortran language constructs\u2014such as program units, type declarations, and OpenMP/OpenCL directives\u2014into partial abstract syntax tree (AST) nodes. It operates on lexbuf inputs using a custom token stream, leveraging Menhir's incremental parsing capabilities to support staged construction of compiler frontends. The design enables handling incomplete or evolving Fortran codebases, particularly useful for interactive development environments or tools requiring speculative parsing of modern Fortran features.",
      "description_length": 565,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides error reporting, symbol registration, and scope management operations for Fortran parsing, working with AST nodes, labels, type specs, and scope frames. It supports semantic analysis through utilities for string checks, node construction, and attribute manipulation, while enabling scope boundary marking and OCL directive processing for constructs like functions, derived types, and program units. Key use cases include resolving name collisions during parsing, normalizing labels in nested scopes, and binding semantic attributes to data objects or access specifiers in Fortran code.",
      "description_length": 606,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for transforming Fortran abstract syntax tree (AST) nodes into token representations paired with source location metadata, alongside functions to inspect and categorize preprocessor directives and other token properties. It operates on AST elements like program units, expressions, and type specifications, as well as raw token values to identify directives (e.g., include statements) and extract positional information. These capabilities support tasks such as code analysis, preprocessing, and structured representation of Fortran source code during compilation or tooling workflows.",
      "description_length": 616,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables fine-grained control over a Menhir-based LR(1) parser processing Fortran tokens, offering operations to drive incremental parsing, manage checkpoints, and inspect or modify parser states and stacks. It works with parser environments, LR(1) states, productions, and extended symbols to support tasks like error recovery, analysis of grammar properties (e.g., nullable nonterminals, first sets), and custom parsing logic. Functions also facilitate reduction handling, symbol comparison, and terminal traversal for precise manipulation of parsing states during compilation workflows.",
      "description_length": 600,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "The module provides incremental parsing functions for Fortran constructs such as statements, expressions, and OpenMP/OpenCL directives, enabling resumable, context-sensitive parsing from specific source positions. It works with `Lexing.position` inputs and Menhir checkpoints parameterized over `Ast.node` or `Ast.Partial.t`, supporting granular recovery and parsing of incomplete code. This is particularly useful for interactive editing, error recovery, or processing partial program units like function headers or execution blocks.",
      "description_length": 534,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran abstract syntax trees (ASTs) into location-annotated tokens using a shared specification, supporting constructs like program units, expressions, and type definitions. It also enables inspection of token properties\u2014such as directive classification, size retrieval, and extraction from partial AST fragments\u2014facilitating tasks like parsing Fortran programs, resolving preprocessor logic, or analyzing token-level structure in compiler toolchains.",
      "description_length": 475,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports semantic analysis, scope management, and AST manipulation for Fortran parsing, focusing on symbol table registration, error reporting, and OCL directive processing. It operates on Fortran AST nodes, scope frames, name/type specifications, and lexical data to handle tasks like variable declaration, label normalization, and attribute assignment during parsing. Specific use cases include resolving derived type definitions, managing nested program scopes, and transforming AST structures for semantic consistency checks in Fortran compilers.",
      "description_length": 562,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis and symbol management capabilities for Fortran parsing, with operations to handle scope lifecycle control, register program constructs (like modules and subroutines), and manage type information during AST construction. It works with abstract syntax trees, name frames, symbol tables, and lexical data to perform tasks such as error reporting, node labeling, and attribute assignment. These functions are essential for accurately parsing Fortran's hierarchical structure, resolving symbol bindings, and processing language-specific features like OCL directives.",
      "description_length": 600,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes into token-location pairs and analyzing preprocessor directives within partially parsed code. It operates on Fortran AST structures and token sequences, with a focus on extracting syntactic elements like program units, expressions, and directives while measuring token metadata. Specific applications include handling `#include` directives, macro expansions, and mapping AST elements to their original source tokens for precise error reporting or code transformation tasks.",
      "description_length": 537,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran syntax elements like tokens, control structures, and parallel directives using Lexing.position values to generate position-aware checkpoints tied to partial abstract syntax trees. It supports error-tolerant parsing, resumption of interrupted parsing workflows, and analysis of complex Fortran constructs such as nested program units and OpenMP/OpenCL directives through granular, recoverable parser states.",
      "description_length": 457,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis utilities for Fortran code processing, focusing on error handling, scope management, and symbol registration during AST construction. It operates on Fortran AST nodes, labels, and semantic data structures like `Label.t` and `Pinfo.t`, supporting tasks such as binding attribute updates, OCL directive parsing, and label normalization. Key use cases include resolving derived type declarations, managing function/subroutine scopes, and transforming OCL tuples into numeric values for compilation or static analysis.",
      "description_length": 553,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables low-level control of incremental parsing processes through operations on parser checkpoints, tokens, and LR(1) environments, supporting tasks like error recovery, stack inspection, and state transitions. It provides utilities for analyzing and modifying grammar elements\u2014such as terminals, nonterminals, and productions\u2014via first-set computation, nullability checks, and reduction handling, while also exposing LR(1) state properties like default reductions and incoming symbols. These capabilities are particularly useful for parser debugging, custom error handling, and dynamic parsing logic transformations.",
      "description_length": 630,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for driving incremental parsing workflows, including token consumption, error recovery, and resumption of parsing with customizable strategies, while enabling fine-grained introspection of parser environments\u2014such as examining LR(1) states, symbol relationships, and reduction behaviors. It works with parser checkpoints, environments, terminals/nonterminals, and productions to support tasks like lookahead analysis, input feeding, and grammar-driven decision-making in language processing tools. Key use cases include implementing custom parsing loops, handling ambiguous or error-prone inputs, and analyzing grammar properties such as nullability and first sets.",
      "description_length": 697,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran abstract syntax trees (ASTs) into location-annotated tokens, handling constructs like program units, expressions, and type specifications. It also provides utilities to inspect and manipulate preprocessor directives and token metadata, enabling tasks like source-to-source translation, static analysis, and compiler tooling that require precise AST-to-token mappings. Operations include querying token properties (e.g., directive detection) and assembling tokens from partial AST nodes.",
      "description_length": 517,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "Translates Fortran AST nodes into tagged tokens and constructs branch tags from token data, handling program units, expressions, and type definitions. Works with AST node lists, location-annotated tokens, and context tags to support parsing, preprocessor resolution, and token analysis in Fortran compiler toolchains. Directly used for converting abstract syntax into processable token sequences with positional and directive metadata.",
      "description_length": 435,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to transform Fortran AST nodes into location-annotated tokens, supporting operations like token classification (e.g., directives, includes), type validation, and size computation. It operates on Fortran abstract syntax trees and token streams, enabling precise mapping between source code constructs and their lexical representations. Key use cases include compiler frontend development, static analysis tools, and refactoring systems requiring accurate token-level manipulation and positional tracking.",
      "description_length": 534,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes\u2014such as program units, statements, expressions, and type specifications\u2014into tokens enriched with location information, following a standardized mapping pattern. It also processes preprocessor tokens by classifying their types (e.g., include directives, general directives), determining their size, and transforming partial AST nodes into token representations. These operations are used in parsing Fortran code, analyzing preprocessor directives, and generating location-aware token sequences for downstream analysis or transformation tasks.",
      "description_length": 581,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for parsing Fortran code, focusing on error handling, scope management, and AST node manipulation. It works with Fortran-specific data structures like `Ast.name`, `Ast.node`, lexical positions, labels, and OCL directives to register symbols, normalize scopes (e.g., programs, modules), and enforce semantic rules. Specific use cases include parsing function and module definitions, resolving name collisions, handling derived types, and converting intermediate representations during AST traversal.",
      "description_length": 530,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes into token sequences paired with source location metadata, while also enabling analysis of preprocessor directives and token properties. It operates on abstract syntax trees and token structures to support tasks like parsing, directive handling, and source-level transformations where precise tokenization and location tracking are critical. Specific applications include processing include directives, measuring token spans for diagnostics, and reconstructing source representations from ASTs.",
      "description_length": 535,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis capabilities for Fortran code through error handling, scope management, and AST manipulation. It operates on Fortran AST nodes, scope frames, labels, and symbol tables to register program units (functions, modules), normalize identifiers, and propagate attributes during parsing. Specific applications include lexical position tracking, AST restructuring (e.g., unary-to-binary operation conversion), and OCL tuple conversion for semantic annotations, supporting tasks like symbol resolution and error reporting in Fortran compilers.",
      "description_length": 572,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran abstract syntax tree (AST) nodes\u2014such as program units, control structures, and expressions\u2014into token-AST location pairs, while also analyzing and processing preprocessor tokens like include directives and general directives. It operates on AST nodes and token data structures, handling tasks such as token type checking, size determination, and generation from partial AST nodes. Specific use cases include mapping structured Fortran syntax elements to their source locations during parsing and managing preprocessor token streams for compilation or transformation workflows.",
      "description_length": 631,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran AST nodes and tokens to construct tagged branches in the AST, using source location data to maintain precise structural and contextual information. It works with Fortran AST elements, tokens, and location data to support operations like macro expansion and source-to-source translation. Key functions include `tag_to_node`, which assembles AST nodes into a tagged branch, and `make_tag`, which creates a tag from a token and location data.",
      "description_length": 469,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes into lexical tokens paired with source code locations, following a consistent pattern to map program units, statements, and expressions to their textual representation. It operates on Fortran parsing tokens, preprocessor directives, and AST structures, offering operations for token classification (e.g., include directives), conversion of partial AST nodes, and precise location tracking. These capabilities are particularly useful in compiler frontends, static analysis tools, and refactoring utilities where accurate source code mapping and preprocessing are critical.",
      "description_length": 612,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran AST nodes\u2014such as program units, statements, and expressions\u2014into lexical tokens paired with source location metadata, focusing on structured code elements. It also provides utilities to analyze token properties, including type checks for directives (e.g., include, preprocessor) and size retrieval, primarily supporting parsing and preprocessing workflows. These operations enable precise code generation, static analysis, and transformation of Fortran programs by bridging abstract syntax with lexical representation.",
      "description_length": 550,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran abstract syntax trees (ASTs) into location-annotated tokens for constructs like program units, expressions, and type specifications, while also providing utilities to inspect token properties. It supports operations to classify tokens (e.g., identifying preprocessor directives), extract metadata like size, and retrieve tokens from partial AST fragments. These capabilities are particularly useful for source code generation, parsing validation, and tools requiring precise source location tracking.",
      "description_length": 529,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements low-level parsing operations for a Menhir-based LR(1) parser, including token handling, checkpoint resumption, and stack manipulation, while enabling introspection of parser states and environments. It operates on parser checkpoints, LR(1) states, grammar symbols (terminals and nonterminals), and environments, with applications in incremental parsing, error recovery, and parser state analysis through grammar properties like nullability checks and first set computation.",
      "description_length": 496,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to parse Fortran constructs into partial AST fragments or handle token-level operations like state management and preprocessing, operating on `Lexing.lexbuf` streams and producing `Ast.Partial.t` or `Ast.node` values. It enables incremental parsing of complex syntactic constructs\u2014such as incomplete subprograms, expressions, and OpenMP/OpenCL directives\u2014using Menhir's interpreter tools to manage parsing states and recover from errors in resumable, context-sensitive workflows.",
      "description_length": 510,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis, symbol registration, and error handling utilities for Fortran parsing, operating on AST nodes, labels, and symbol tables to manage program units like modules, subroutines, and derived types. It includes functions for scope tracking, name resolution, and string manipulation (e.g., edit descriptors, label normalization) to support tasks such as semantic attribution, OCL directive conversion, and resolving declarations within Fortran code. Specific patterns address scope-aware symbol binding, AST node transformation, and semantic annotation of parsed constructs.",
      "description_length": 605,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides error reporting, symbol registration, and scope management operations for Fortran parsing, primarily manipulating AST nodes, lexical positions, and Fortran-specific constructs like modules, functions, and common blocks. It supports semantic analysis through utilities for label normalization, attribute manipulation, and node transformation, with use cases in parsing error recovery, symbol visibility tracking, and AST construction during Fortran code processing.",
      "description_length": 485,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables precise control over incremental parsing workflows through operations like checkpoint management, token feeding, and stack manipulation, while exposing state inspection capabilities. It operates on parser states, nonterminals, terminals, and checkpoints to support tasks like error recovery, grammar analysis (e.g., nullability checks), and custom parsing strategies. Specific functions facilitate symbol property analysis (nullable, first-sets) and dynamic state transitions, making it suitable for advanced parser customization and debugging scenarios.",
      "description_length": 574,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports incremental and partial parsing of Fortran source code into intermediate abstract syntax tree (AST) fragments, handling constructs like program units, type declarations, control blocks, and expressions. It operates on lexing buffers and token streams using a custom token representation, with integrated Menhir interpreter control for precise error recovery and resumable parsing workflows. The design enables applications such as robust preprocessing, interactive development environments, and fault-tolerant compiler pipelines where parsing must adapt to incomplete or malformed input.",
      "description_length": 608,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran syntax elements like statements, expressions, control structures, and parallel directives by generating recovery checkpoints at lexical positions. It operates on partial parsing states represented as `Partial.t` values and Menhir interpreter checkpoints, which encapsulate typed AST fragments or unit values to track progress. These capabilities support use cases such as fault-tolerant parsing of incomplete Fortran code and stepwise analysis of structured program units.",
      "description_length": 523,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax trees by mapping AST nodes to annotated token sequences with positional metadata, supporting precise source code reconstruction and analysis. It includes functions for token classification, location tracking, and conditional parsing logic specific to Fortran constructs such as directives, type specifications, and control statements. Concrete use cases include refactoring tools, static analyzers, and preprocessors requiring fine-grained manipulation of Fortran source code and semantic context.",
      "description_length": 543,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.BF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran abstract syntax tree (AST) nodes\u2014such as program units, expressions, and type specifications\u2014into tokens paired with source location metadata. It also processes preprocessor directives by identifying include statements, directive types, and partial AST fragments, while calculating token sizes. These operations support parsing and preprocessing workflows where precise tokenization and location tracking are critical for analysis or transformation tasks.",
      "description_length": 484,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to create and manipulate tagged Fortran AST nodes during token processing. It works with Fortran source tokens, location metadata, and AST node structures. Concrete use cases include reconstructing AST fragments from token streams and attaching semantic tags for downstream analysis and transformation stages in the compiler pipeline.",
      "description_length": 365,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides incremental parsing mechanisms that generate checkpoints for partial abstract syntax trees (ASTs) or unit values, enabling structured recovery and reconstruction of Fortran syntax elements at specific lexical positions. It operates on lexical tokens and Fortran program components like subroutines, expressions, control blocks, and parallel directives (e.g., OpenMP/OpenCL), using position-aware parsing to handle incomplete or nested constructs. The checkpoints facilitate error recovery and incremental AST building during parsing of complex Fortran codebases.",
      "description_length": 583,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for semantic analysis and transformation of Fortran AST nodes, focusing on error handling, scope management, and label manipulation. It operates on abstract syntax trees, symbol tables, lexical position data, and OCL directive tuples to support tasks like name resolution, binding validation, and directive processing during parsing. Key use cases include tracking construct scopes (subroutines, modules), normalizing identifiers, and modifying node structures while maintaining semantic consistency.",
      "description_length": 531,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables partial parsing and preprocessing of Fortran source code into intermediate AST nodes, handling constructs like variables, type declarations, and OpenMP directives. It operates on Lexing.lexbuf input through a token stream, producing Fortran_parsing.Ast.Partial.t values to represent incomplete program units or expressions. Designed for resilience in environments like IDEs and compilers, it supports incremental parsing of evolving or fragmented Fortran syntax.",
      "description_length": 482,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers low-level lexical analysis and tokenization for Fortran source code, specializing in source form detection (fixed/free format), preprocessor directives, and parallelism extensions like OpenMP/OpenACC. It operates on `Sedlexing.lexbuf` buffers and token streams (`qtoken`), managing lexical states for continuation lines, Hollerith constants, and margin tracking. Key use cases include preprocessing (e.g., macro expansion, conditional compilation), semantic analysis, and structured code representation through precise label handling and directive parsing.",
      "description_length": 575,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to map Fortran AST nodes\u2014such as program units, expressions, and type specifications\u2014to tokens and source location data, while also offering utilities to query token properties like type classifications (e.g., directives) and measure token attributes. It operates on Fortran parser tokens and AST structures, enabling tasks like source-to-AST parsing, pretty-printing, and token analysis for preprocessing or source code metrics. Specific use cases include generating textual representations of ASTs and extracting semantic information from parsed tokens during compilation or static analysis.",
      "description_length": 625,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables stepwise parsing of Fortran source code through functions that generate checkpoints for partial abstract syntax trees (ASTs) at specific lexical positions. It operates on Fortran language constructs like program units, expressions, control flow elements, and OpenMP/OpenCL directives, supporting error recovery and incremental analysis during parsing. Use cases include building resilient parsers that handle incomplete or malformed code and implementing tools requiring syntactic introspection at intermediate parsing stages.",
      "description_length": 546,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements Fortran lexical analysis and preprocessing with support for source form detection, directive handling, and token stream generation. It works with `Sedlexing.lexbuf`, Fortran AST nodes, and token structures enriched with source location metadata. It is used for tasks such as macro expansion, conditional compilation, source reconstruction, and semantic analysis requiring precise tokenization and directive processing.",
      "description_length": 441,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides partial parsing operations and specialized token handling for Fortran syntax elements, focusing on complex constructs like type declarations, control structures, and program units. It operates on lexing buffers and tokens to generate partial AST nodes, leveraging incremental parsing mechanisms for state control and error recovery. Specific use cases include parsing OpenMP/OpenCL directives, function headers, and managing grammatical ambiguities in Fortran's specification parts through position-aware checkpointing.",
      "description_length": 540,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables partial parsing of Fortran source code by generating Menhir parser checkpoints for syntactic elements like program units, declarations, and OpenMP directives starting from specified lexical positions. It operates on token streams and Fortran AST nodes, supporting resumption of parsing after additional input becomes available. Key applications include handling incomplete code fragments in interactive environments and parsing large Fortran files in streaming scenarios.",
      "description_length": 491,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes into token sequences paired with source locations, enabling precise syntactic element tracking. It supports analysis and manipulation of tokens through type inspection, size evaluation, and construction from partial AST data. These capabilities are critical for source-to-source translation, syntax validation, and code refactoring tools requiring positional fidelity.",
      "description_length": 409,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to convert Fortran abstract syntax tree (AST) nodes\u2014such as program units, statements, and expressions\u2014into lexical tokens paired with source location metadata, enabling precise mapping between structured syntax and their textual representation. It includes utilities to analyze token properties, such as type classification (e.g., directives, includes) and size calculation, operating on both full tokens and partial AST fragments. These capabilities are particularly useful for source code transformation, static analysis, and tooling that requires alignment between syntactic constructs and their original source positions.",
      "description_length": 658,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran AST nodes (program units, statements, expressions) into tokens enriched with source location data, using a shared specification parameter to unify their representation. It also classifies preprocessor tokens by type (e.g., include directives) and extracts metadata like token size, enabling tasks such as Fortran code parsing, preprocessing, and structural analysis where precise tokenization and directive handling are critical.",
      "description_length": 460,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for semantic analysis and abstract syntax tree (AST) manipulation during Fortran parsing, focusing on error handling, scope management, and symbol registration. It operates on AST nodes, labels, name frames, and lexical positions to support tasks like type binding, attribute assignment, and scope-aware symbol table updates. Key patterns include error reporting with location tracking, label normalization for code generation, and syntactic classification of constructs during semantic resolution.",
      "description_length": 529,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran AST nodes and token sequences to support precise source mapping and transformation tasks. It includes functions for creating and tagging AST elements with location and token metadata, enabling accurate tracking of source origins. Concrete use cases include handling preprocessor directives like `#include`, expanding macros, and aligning AST nodes with their original source tokens for error reporting or refactoring tools.",
      "description_length": 453,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for parsing error handling, scope management, and semantic analysis during Fortran code processing. It works with abstract syntax trees (ASTs), symbol tables, scope frames, labels, and Fortran-specific types like type specs and OCL directives to enforce context-aware checks and structural transformations. Specific use cases include registering program units (subroutines, modules), resolving symbol attributes, normalizing labels, and converting unary operations to binary constructs during AST manipulation.",
      "description_length": 542,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports Fortran parsing through semantic analysis, scope management, and AST node manipulation. It processes Fortran constructs like modules, subroutines, and derived types, handles label normalization and attribute transformations, and operates on AST nodes, symbol tables, and lexical data. Key applications include error detection during parsing, source location extraction, and OCL directive conversion for structured code analysis.",
      "description_length": 449,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.BF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran abstract syntax tree (AST) nodes\u2014such as program units, expressions, and type specifications\u2014into location-annotated tokens, while also analyzing preprocessor tokens to identify directives (e.g., includes) and extract metadata like token size or AST mappings. It operates on Fortran source code representations, bridging AST structures with low-level token sequences for tasks like parsing, directive handling, or tooling that requires precise token-level analysis in Fortran programs.",
      "description_length": 514,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes into location-annotated tokens and analyzes token properties. It operates on Fortran abstract syntax trees and token sequences, supporting tasks like preprocessor directive detection, token size calculation, and AST-to-token translation for compiler pipelines or source analysis tools.",
      "description_length": 324,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides lexical analysis, tokenization, and preprocessing capabilities for Fortran source code, focusing on handling syntax-specific features like Hollerith literals, continuation lines, and compiler pragmas (OpenMP, OpenACC). It operates on `Sedlexing.lexbuf` input buffers, `qtoken`-wrapped tokens, and stateful structures like `SourceForm.t` to manage source form detection, positional tracking, and semantic transformations. Use cases include parsing Fortran's fixed/free-form syntax, expanding preprocessor directives (`#ifdef`, `#include`), and normalizing legacy code constructs during compilation or static analysis.",
      "description_length": 637,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parser control by offering tokens to checkpoints, resuming parsing with specific strategies, and converting lexers into token suppliers. It operates on LR(1) parser environments, stacks, symbols, and productions to support introspection of states, reductions, and grammar properties, facilitating tasks like implementing Fortran parsers with custom token handling, analyzing symbol nullability, and debugging parsing logic through state and environment analysis.",
      "description_length": 494,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports semantic analysis and name resolution during Fortran parsing through operations that manage symbol tables, register program constructs (e.g., modules, subroutines, derived types), and enforce scope boundaries using lifecycle controls like `begin_scope` and `end_scope`. It works with AST nodes, labels, name frames, and Fortran-specific types to handle tasks like attribute assignment, label manipulation, and OCL directive processing in parsed code. Key use cases include resolving renamed symbols in modules, binding data object attributes, and traversing AST structures to extract source locations or specification/execution context.",
      "description_length": 657,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles Fortran token transformation, semantic analysis, and parsing operations. It includes functions for mapping AST nodes to location-annotated tokens, performing semantic checks, and parsing token streams into AST fragments. It works directly with Fortran abstract syntax trees, token streams, lexical buffers, and symbol tables, supporting use cases like compiler frontends, static analysis tools, and refactoring systems that require precise syntactic and semantic manipulation of Fortran code.",
      "description_length": 512,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes into tokens paired with source locations, enabling precise structural and semantic parsing of program units, statements, expressions, and type definitions. It also provides utilities to analyze preprocessor tokens by identifying directive types (e.g., include directives) and extracting metadata like token-node mappings or size information. These operations are critical for tasks such as Fortran code parsing, preprocessor directive handling, and maintaining source location fidelity during compilation.",
      "description_length": 544,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes\u2014such as program units, expressions, and type specifications\u2014into tokens enriched with source location metadata, enabling precise syntactic analysis. It provides utilities to inspect token properties, like type checks for directives or preprocessor elements, and measures token size for parsing workflows. These operations support scanner-level tasks such as source mapping, error reporting with positional context, and preprocessing logic that relies on granular token attributes.",
      "description_length": 521,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing through token feeding and checkpoint resumption, while providing fine-grained control over LR(1) parser environments and stacks. It operates on tokens, parser states, terminals, nonterminals, and productions to support error recovery, custom parsing strategies, and analysis of grammar properties like nullability and first sets. Use cases include integrating lexers with parsers, implementing parser introspection tools, and driving complex state transitions during syntactic analysis.",
      "description_length": 526,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to convert Fortran AST nodes (such as program units, statements, and expressions) into tokens paired with source location data, using a shared specification context. It also includes utilities for analyzing and manipulating Fortran preprocessor tokens, such as identifying directive types (e.g., include directives) and constructing tokens from partial AST information. These operations are used for tasks like source-to-source translation, static analysis, and preprocessing of Fortran code.",
      "description_length": 523,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements lexing and tokenization functions for Fortran source code, handling lexical elements like Hollerith constants, preprocessor directives, compiler extensions, and legacy formatting rules. It operates on `Sedlexing.lexbuf` input buffers and `SourceForm.t` state to produce annotated tokens (`qtoken`), supporting semantic analysis, code transformation, and preprocessing workflows. Key functionalities include source form detection, label handling, continuation line processing, and parsing of conditional compilation directives and dialect-specific extensions like OpenMP or DEC.",
      "description_length": 600,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis and symbol management operations during Fortran parsing, focusing on error handling, scope tracking, and AST transformation. It works with abstract syntax trees (AST nodes), lexical labels, name frames, and Fortran-specific constructs like access specs, derived types, and common blocks. Key use cases include resolving symbol visibility in program structures (modules, subroutines), normalizing identifiers during parsing, and annotating AST nodes with semantic metadata while preserving source location accuracy for diagnostics.",
      "description_length": 569,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides partial parsing and preprocessing capabilities for Fortran code, transforming token streams into incomplete AST fragments (`Partial.t`) while handling constructs like control blocks, expressions, and subprograms. It operates on lexbuf inputs with lexer functions, supporting incremental parsing workflows that enable error recovery, position tracking, and custom parsing strategies for complex features such as OpenMP directives and program unit boundaries. The design facilitates reconstructing structured syntax elements from incomplete or evolving source code, particularly useful in interactive development environments or compilers requiring robust parsing of non-contiguous code regions.",
      "description_length": 714,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides lexical analysis and tokenization capabilities for Fortran code, specializing in handling source form transitions, directive parsing, and context-sensitive token recognition. It operates on `Sedlexing.lexbuf` input buffers and `SourceForm.t` state, producing annotated tokens (`qtoken`) while managing lexical context like Hollerith literals, continuation lines, and preprocessor directives. Key use cases include parsing OpenMP/OpenACC pragmas, resolving Fortran-specific syntax (labels, comments, fixed/free format), and supporting static analysis through precise source position tracking and token stream manipulation.",
      "description_length": 642,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax trees and tokens to construct tagged branches with precise source location tracking. It supports operations like merging source locations, inspecting token properties for statement context, and handling token metadata during parsing and transformation workflows. Concrete use cases include macro expansion, source-to-source translation, and AST manipulation tasks requiring accurate positional data and token analysis.",
      "description_length": 464,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates Fortran parsing and semantic analysis through operations that register language constructs (functions, modules, derived types), manage scopes and labels, and manipulate AST nodes with attributes. It works with abstract syntax trees, lexical positions, OCL directives, and Fortran-specific types like common blocks and access specifiers. Use cases include parsing Fortran source code into structured ASTs, resolving symbol scopes during compilation, and annotating nodes with semantic metadata for analysis or transformation pipelines.",
      "description_length": 558,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides incremental parsing operations for Fortran source code, transforming `Lexing.lexbuf` input into partial abstract syntax trees (`Partial.t`) through a custom token interface. It supports parsing of Fortran language elements like control structures, expressions, and subprograms, with specialized handling for parallel directives (OpenMP, OpenCL) and fault-tolerant recovery via Menhir's LR(1) incremental parser. The design enables use cases such as stepwise compilation, AST introspection for analysis tools, and robust preprocessing of Fortran codebases with embedded parallelism.",
      "description_length": 602,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides incremental parsing capabilities for Fortran by generating checkpoints that handle partial abstract syntax trees and token recognition. It operates on lexical positions and syntactic constructs like program units, type declarations, and OpenMP directives, producing checkpointed parser states to resume parsing from arbitrary points. These features support use cases such as error recovery, incremental compilation, and real-time code analysis in interactive development environments.",
      "description_length": 505,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions for semantic analysis, scope management, and AST node manipulation during Fortran parsing. It operates on AST nodes, symbol tables, scopes, labels, and OCL directives, facilitating tasks like registering program entities (functions, modules, derived types), handling accessibility attributes, managing nested scopes, and transforming AST structures for semantic consistency and error reporting. Key use cases include parsing Fortran programs, resolving names, normalizing labels, and enforcing semantic rules through symbol table population and node attribute updates.",
      "description_length": 599,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to create and manipulate tagged AST nodes in Fortran code, specifically through `tag_to_node` which constructs AST nodes from context and branch tags, and `make_tag` which generates branch tags from tokens and source locations. It works with Fortran AST nodes, tokens, and location metadata. Concrete use cases include AST transformation, source-to-source compilation, and precise error reporting during parsing or refactoring.",
      "description_length": 459,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran abstract syntax tree (AST) elements\u2014such as program units, statements, and expressions\u2014into tokens enriched with location metadata, enabling precise code analysis and transformation. It also includes operations to inspect and construct preprocessor tokens, such as checking directive types (e.g., include guards) and assembling tokens from partial data, which supports preprocessing tasks like macro expansion and conditional compilation. These capabilities are critical for building tools that parse, analyze, or refactor Fortran codebases.",
      "description_length": 595,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source tokens and AST nodes to support precise token-to-node mapping, location tracking, and conditional analysis during parsing. It includes functions for merging source locations, identifying statement contexts, and evaluating token conditions specific to Fortran control structures and type specifications. Use cases include reconstructing AST fragments from token streams, attaching semantic tags, and mapping Fortran syntax elements to source locations for compilation or transformation workflows.",
      "description_length": 532,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes into tokens paired with location information, following a common specification parameter. It provides operations for analyzing token types, determining token size, and transforming partial AST nodes into tokens, primarily supporting parsing and preprocessing workflows such as handling include statements, preprocessor directives, or type specification validation in Fortran codebases.",
      "description_length": 424,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to map Fortran AST nodes to tokens and source locations, and to construct and tag AST nodes from tokens with specific attributes. It works with Fortran AST structures, tokens, and location data to support tasks like source code reconstruction, AST traversal, and semantic analysis. Specific use cases include pretty-printing parsed Fortran code and extracting directive information for compilation or analysis tools.",
      "description_length": 447,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for Fortran semantic analysis, focusing on error handling, scope management, and AST manipulation. It operates on abstract syntax trees, symbol tables, and Fortran-specific constructs like labels, type specs, and OCL directives to support name resolution, semantic attribute assignment, and code transformation. Key use cases include parsing legacy Fortran code, enforcing scoping rules during compilation, and preparing ASTs for downstream analysis or translation tasks.",
      "description_length": 502,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran abstract syntax trees (ASTs) into lexical tokens paired with source locations, handling constructs like program units, expressions, and directives. It provides utilities to analyze token properties\u2014such as type classification and size determination\u2014and supports partial AST conversions for preprocessing tasks. These operations enable precise source code reconstruction, static analysis, and compiler tooling requiring detailed lexical and positional information.",
      "description_length": 494,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for semantic analysis and scope management in Fortran compilation, including error handling, symbol registration into symbol tables, and normalization of labels and names for constructs like modules, subroutines, and derived types. It works with abstract syntax trees (ASTs), lexical positions, OCL directive tuples, and semantic metadata to perform tasks such as attribute modification, node transformation, and scope-aware symbol binding. These utilities support parsing, semantic resolution, and compiler pipeline stages like directive processing and program structure validation.",
      "description_length": 615,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides resilient, incremental parsing operations for constructing partial abstract syntax trees (ASTs) from Fortran source code. It processes lexbuf input streams using a custom token type to build partial representations of language constructs like statements, expressions, and OpenMP directives, with dedicated mechanisms for error recovery and syntactic introspection. The design supports use cases such as incremental compilation, syntax-aware editing, and analysis of incomplete or malformed Fortran codebases through its integration with interpreter and incremental processing submodules.",
      "description_length": 608,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.BF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by converting AST nodes and tokens into tagged structures with location metadata, supporting precise parsing and preprocessing. It works with Fortran AST nodes, tokens, and location information, enabling transformations and analysis that require tracking source positions. Concrete use cases include handling include directives, directive parsing, and mapping tokens to AST elements for compiler tooling.",
      "description_length": 446,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers lexing and tokenizing operations for Fortran source code, specializing in handling compiler directives (OpenMP, OpenCL, DEC, XLF), Hollerith constants, continuation lines, and source form detection (fixed/free format). It operates on `Sedlexing.lexbuf` input buffers and produces annotated tokens (`qtoken`) with positional metadata (`Loc.t`), while managing state for preprocessor directives, label merging, and context-sensitive lexical analysis. Key use cases include Fortran compiler front-ends, semantic analysis tools, and source-to-source transformation pipelines requiring precise handling of Fortran-specific syntax and directive-driven compilation.",
      "description_length": 677,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "The module offers functions for parsing error handling, scope lifecycle management, and AST node manipulation during Fortran semantic analysis. It operates on abstract syntax trees, symbol tables, labels, and lexical positions to support tasks like registering program constructs (e.g., subroutines, modules), resolving symbol bindings, and normalizing labels. These operations are used in compiler pipelines for semantic validation, code transformation, and static analysis of Fortran programs.",
      "description_length": 495,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes into annotated tokens with source location metadata and analyzing token properties. It operates on Fortran abstract syntax trees and token sequences, with specialized functions for identifying preprocessor directives, measuring token size, and reconstructing tokens from partial AST components. These capabilities support tasks like Fortran code parsing, macro expansion, and source-to-source transformations where precise syntactic element tracking is required.",
      "description_length": 526,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens.Make.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of terminal symbols used in parsing Fortran code, including language keywords, operators, literals, and compiler directives. It works with `MenhirInterpreter.terminal` values, each representing a distinct token category recognized during parsing. These terminals support detailed syntactic and semantic analysis of Fortran source files, enabling precise handling of constructs like control flow, data declarations, and parallel programming directives.",
      "description_length": 491,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser.Make.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports incremental parsing, error recovery, and abstract syntax tree (AST) construction through low-level manipulation of tokens, parser checkpoints, and stacks. It provides utilities for inspecting parser environments (e.g., state comparisons, stack traversal) and analyzing grammar properties like nullable nonterminals, first sets, and production rules. Specific use cases include dynamic parser configuration during Fortran source parsing and static grammar analysis for compiler tooling.",
      "description_length": 506,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides Fortran-specific parsing and lexing utilities for handling source code structure, tokenization, and semantic analysis. It operates on `Sedlexing.lexbuf` input buffers, `SourceForm.t` context trackers, and position-aware data to manage lexical elements like Hollerith constants, comments, preprocessor directives, and dialect-specific features (e.g., OpenMP, OpenACC). Its functions support use cases such as conditional compilation, continuation line detection, and dialect-aware token generation for Fortran compilers or analysis tools.",
      "description_length": 558,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran abstract syntax trees (ASTs) into location-annotated token sequences and analyzing token metadata. It operates on Fortran AST nodes, token streams, and preprocessor constructs, with functions to identify directives (e.g., `#include`), measure token sizes, and construct tokens from partial AST components. These capabilities support tasks like source-to-source translation, preprocessor handling, and static analysis of Fortran codebases.",
      "description_length": 492,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements Fortran lexical analysis and token transformation, converting raw source input into annotated tokens with positional metadata. It processes Fortran-specific lexical constructs such as Hollerith constants, preprocessor directives, and legacy formatting, producing tokens used for syntactic and semantic analysis. Key functionalities include source form detection, macro expansion, token property inspection, and error reporting with precise source locations, directly supporting Fortran compiler frontends and static analysis tools.",
      "description_length": 554,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides lexical analysis and preprocessing capabilities for Fortran source code, focusing on token construction, source location tracking, and directive handling. It operates on `Sedlexing.lexbuf` buffers and `SourceForm.t` state to manage lexical contexts like margins, continuation lines, and Hollerith constants, producing tokens with precise position data. Key use cases include parsing OpenMP/accelerator directives, handling conditional compilation (`#if`, `#include`), and distinguishing between fixed/free-form syntax elements like labels and block comments.",
      "description_length": 579,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by converting AST nodes into tokens with source locations, analyzing preprocessor directives, and supporting partial parsing workflows. It operates on Fortran AST nodes, tokens, lexbuf inputs, and source location data to enable precise parsing, error recovery, and code reconstruction. Concrete use cases include handling include directives, mapping tokens to AST elements, and parsing incomplete code fragments in interactive environments.",
      "description_length": 482,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg.F.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides low-level utilities for Fortran semantic analysis, focusing on error reporting, symbol registration, and AST manipulation. It operates on abstract syntax trees, lexical position data, name scopes, and Fortran-specific constructs like modules, subroutines, and OCL directives, with functions to handle label normalization, attribute assignment, and scope-bound symbol binding. Key use cases include resolving naming conflicts during parsing, constructing error-recovery nodes, and transforming AST structures for semantic classification or code generation tasks.",
      "description_length": 582,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.AccessSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines an enumerated type representing access specifiers in Fortran declarations, with values for no specifier, private, and public. It includes functions to convert the type to a string and to check if the access is public or private. This module is used to determine visibility settings for variables or procedures in Fortran code analysis.",
      "description_length": 355,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers functions to parse Fortran source code into partial abstract syntax tree (AST) fragments and preprocess lexical input, working with lexing buffers and token streams to build structured elements like statements, subroutines, and directives. It supports incremental parsing, error recovery, and checkpoint-based resumption, enabling efficient handling of complex syntactic constructs, OpenMP/OpenCL directives, and program unit assembly.",
      "description_length": 454,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes into lexical tokens paired with source location data, handling constructs like program units, statements, and expressions. It also processes preprocessor tokens to identify directives, includes, and directive types while measuring token size, operating on parser-generated AST and token structures. These capabilities support precise token-level analysis for tasks like error reporting and preprocessor directive handling.",
      "description_length": 463,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements Fortran lexical analysis, preprocessing, and incremental parsing, providing precise tokenization, source form detection, directive handling, and AST generation with rich source location tracking. It operates on `Sedlexing.lexbuf`, Fortran AST nodes, tokens, and location metadata, supporting transformations like macro expansion, conditional compilation, source reconstruction, and semantic analysis of Fortran codebases. Key use cases include parsing OpenMP/OpenACC pragmas, handling include directives, fault-tolerant parsing of Fortran control structures, and AST manipulation requiring accurate positional data and context-sensitive token recognition.",
      "description_length": 678,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Codimension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines types and conversions for codimension annotations in Fortran variable declarations. It supports parsing and string representation of codimension markers, specifically handling cases like no codimension, explicit coshape, and deferred coshape. It is used during AST processing to interpret dimensionality information in Fortran source code.",
      "description_length": 359,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax trees and token sequences to support source mapping, semantic analysis, and incremental parsing. It includes functions for token property analysis, scope management, partial AST construction, and precise source location tracking. Concrete use cases include resolving renamed symbols in modules, handling preprocessor directives, and enabling syntax-aware editing and error recovery in Fortran compilers or analysis tools.",
      "description_length": 467,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.BF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax tree (AST) nodes and tokens, converting AST elements into location-annotated tokens and analyzing preprocessor directives. It includes functions to map tags to AST nodes and construct tagged tokens with source locations. Concrete use cases include precise token-level analysis, directive extraction, and mapping between AST structures and source code tokens for tooling or transformation tasks.",
      "description_length": 440,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to convert Fortran abstract syntax tree (AST) nodes\u2014such as program units, expressions, and type specifications\u2014into tokens enriched with source location data. It also includes utilities to classify tokens by type (e.g., preprocessor directives, include statements), measure their size, and extract them from partial AST structures. These operations are particularly useful for analyzing or transforming parsed Fortran code while preserving precise syntactic and positional information.",
      "description_length": 517,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.ImplicitSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "Converts a label into an optional range of characters representing a letter-based implicit type specification. Works with labels to extract implicit typing information commonly used in Fortran code. Useful for parsing Fortran declarations where variables are typed based on their initial letter.",
      "description_length": 295,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.ScopingUnit",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing various scoping units in Fortran, such as programs, modules, functions, and derived type definitions, along with constructors like `mkmodule` and `mkderivedtypedef` to create specific scoping unit instances. It provides operations to convert scoping units to strings with `to_string` and to duplicate them with `copy`. Concrete use cases include tracking and manipulating Fortran code structure during parsing or analysis, such as identifying module boundaries or function scopes.",
      "description_length": 524,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module constructs and manipulates tagged AST nodes for Fortran source code, pairing tokens with location data to support precise syntactic transformations. It works with Fortran AST nodes, tags, and token sequences, enabling use cases like source-to-source translation and syntax validation. Key operations include creating tagged nodes from tokens and generating AST fragments with accurate source location tracking.",
      "description_length": 422,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran source code into partial abstract syntax tree (AST) nodes, focusing on constructing program elements like statements, expressions, and subroutines from token streams. It operates on lexing buffers and Fortran tokens using Menhir's incremental parsing framework, supporting resumable parsing for interactive development environments and streaming input scenarios where code may be incomplete or dynamically extended.",
      "description_length": 466,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module tokenizes Fortran source code into enriched tokens with location metadata, classifies preprocessor directives, and supports precise AST-to-token mapping. It operates on `Sedlexing.lexbuf`, `Tokens.token`, and Fortran AST nodes to enable parsing, preprocessing, and semantic analysis workflows. Concrete use cases include handling Fortran's fixed/free-form syntax, expanding `#include` and `#ifdef`, and mapping AST fragments to source locations for compilation or code transformation.",
      "description_length": 496,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This component provides operations to convert Fortran AST nodes into lexical tokens augmented with source location metadata, while also enabling analysis of token properties like type classification and size calculation. It operates on Fortran-specific constructs such as program units, type specifications, and preprocessor directives, mapping them to a unified token representation with precise positional tracking. The functionality supports use cases requiring exact source correspondence, such as static analysis tools or transformations preserving original code structure in Fortran compilers.",
      "description_length": 599,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser.Make.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran syntax through functions that start at specified lexing positions and return checkpointed states, allowing partial parsing of constructs like program units, type declarations, and control structures. It generates partial AST nodes while handling elements such as expressions, derived type definitions, and preprocessor directives. This supports use cases like error-resilient parsing, syntax recovery in incomplete code, and structured reconstruction of Fortran programs.",
      "description_length": 522,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.IntentSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing the intent specifications of Fortran variables (`NoIntent`, `In`, `Out`, `Inout`) and provides conversions to string and from label representations. It works directly with variant types and string values. Concrete use cases include parsing and representing variable intent in Fortran code analysis tools.",
      "description_length": 348,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports semantic analysis and symbol management during Fortran parsing through operations like error generation, scope lifecycle management, and AST transformation. It works with Fortran AST nodes, symbol tables, scope frames, and lexical location data to handle tasks such as registering program units (functions, modules), resolving name bindings, and processing directives. Specific use cases include semantic validation of Fortran code structure, attribute propagation in declarations, and preparing ASTs for downstream analysis by attaching type information and resolving scopes.",
      "description_length": 597,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Dimension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different dimension kinds in Fortran array declarations, such as explicit, assumed, and deferred shapes. It includes functions to convert dimension types to strings, retrieve the rank, and construct dimensions from labels or explicit sizes. Concrete use cases include parsing Fortran array specifications and determining array dimensionality during semantic analysis.",
      "description_length": 415,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for semantic analysis and AST manipulation during Fortran parsing, focusing on error handling, symbol registration, and scope management. It works with abstract syntax trees, symbol tables, lexical position data, and OCL directive tuples to handle Fortran-specific constructs like modules, derived types, and common blocks. These capabilities support use cases such as parsing procedure declarations, transforming unary operations in AST nodes, and binding source location metadata during compiler frontend development.",
      "description_length": 551,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for symbol declaration tracking, scoping, and resolution in Fortran code, working with data structures representing symbols like data objects, derived types, modules, and procedures. It supports semantic analysis tasks such as attribute extraction, visibility checks, and structural decomposition of declarations, enabling applications like compiler symbol table management and code analysis tools. Key functionalities include resolving symbol domains, querying accessibility, and constructing typed name specifications for semantic validation.",
      "description_length": 576,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for handling parsing errors, registering Fortran language constructs (e.g., modules, subroutines, derived types) into semantic contexts, and managing scope and symbol tables during parsing. It operates on AST nodes, labels, name frames, OCL directives, and lexical positions, with utilities for string checks, node transformation, and attribute assignment to support semantic analysis. These functions are used to track symbols, normalize names, and manipulate AST structures during Fortran code parsing, ensuring accurate representation of program hierarchy and accessibility rules.",
      "description_length": 615,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements low-level token processing and AST node construction for Fortran parsing, including functions to convert tags to nodes, merge source locations, and evaluate token conditions for statement boundaries and syntactic contexts. It operates directly on Fortran AST nodes, tokens, lexing positions, and token sources, supporting precise parsing decisions and error handling. Specific use cases include resolving conditional token sequences, constructing tagged AST nodes, and managing source location metadata during parsing and preprocessing.",
      "description_length": 559,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser_aux.LineStat",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of line status classifications for Fortran source lines, including whether a line is blank, a pure comment, mixed content, or continued from the previous line. It provides functions to convert these statuses to strings and to check specific line properties such as whether a line is a pure comment or a continuation. These classifications are used to accurately parse and process Fortran code based on line structure and content.",
      "description_length": 455,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Common.DirectiveLine",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and constructs directive lines in Fortran code, specifically handling different directive types like OpenMP, OpenACC, and compiler-specific directives. It works with a `raw` record containing metadata such as the directive tag, original line text, and continuation flags, along with a queue for parsed tokens. Concrete use cases include parsing and reconstructing directive lines during Fortran source analysis or transformation tasks.",
      "description_length": 458,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.SourceForm",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines an enumerated type representing Fortran source form classifications (unknown, fixed, free, mixed) and provides a conversion function to string. It is used to distinguish source format variants during Fortran code parsing and analysis. Concrete use cases include determining line length constraints and comment/start-of-statement rules based on source form.",
      "description_length": 376,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser_aux.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates semantic analysis and symbol resolution in Fortran parsing through operations that manage symbol tables, enforce scoping rules, and register language entities like subroutines and modules. It works with abstract syntax trees (ASTs), lexical positions, type specifications, and scope frames to handle tasks such as error reporting, label normalization, and attribute assignment for data objects. Key use cases include transforming AST node structures, resolving renamed entities in OCL directives, and validating string prefixes during parsing.",
      "description_length": 567,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec.Clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing clauses used in Fortran declarations, such as alignment, privatization, and vectorization directives. It provides operations to convert these clauses to string representations, extract structured tags, and anonymize sensitive data. Use cases include parsing and processing Fortran code annotations for optimization and analysis tools.",
      "description_length": 382,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens.Make",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of terminal symbols used in parsing Fortran code, including language keywords, operators, literals, and compiler directives. It works with `MenhirInterpreter.terminal` values, each representing a distinct token category recognized during parsing. These terminals support detailed syntactic and semantic analysis of Fortran source files, enabling precise handling of constructs like control flow, data declarations, and parallel programming directives.",
      "description_length": 491,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.TypeSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type for representing Fortran type specifiers, including built-in types like `Integer`, `Real`, and `Complex`, as well as derived and parameterized types. It provides functions to convert types to strings, extract names, resolve from labels, and check if a type is fully resolved. Concrete use cases include parsing and analyzing Fortran declarations where precise type information is required for semantic checks or code generation.",
      "description_length": 463,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic disambiguation and transformation operations for Fortran AST nodes, focusing on resolving symbols, binding identifiers, and inferring structural properties like array ranks. It works with labeled AST structures, scopes, and lexical contexts to handle ambiguous syntax in areas like array/pointer references, derived type components, and declaration attributes. Specific applications include resolving variable/constant references in expressions, disambiguating procedure calls with Linda syntax, and elaborating control structures during semantic analysis.",
      "description_length": 586,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax trees (ASTs) by converting AST nodes into tokens enriched with source location data and classifying those tokens by type. It provides functions to generate tags from tokens, map tags to AST nodes, and extract or analyze token information such as size and location. Concrete use cases include source code transformation, syntactic analysis, and precise error reporting during Fortran code parsing.",
      "description_length": 442,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_dec.Attribute",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing Fortran attribute specifiers, such as `Allocatable`, `Inline`, or `Dllimport`, each capturing specific syntactic and semantic modifiers used in Fortran declarations. It provides functions to convert attributes to strings, extract associated names or parameters, and construct attributes from keywords, often used during parsing or code generation. Concrete use cases include attribute validation, transformation during AST processing, and emitting Fortran source from internal representations.",
      "description_length": 545,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ast.Partial",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module constructs and manipulates abstract syntax tree elements for Fortran code, centered around a variant type representing syntactic constructs like program units, statements, and expressions. It uses a metadata-rich structure with mutable fields to track node properties such as length and type tags, supporting incremental AST assembly and inspection. Typical use cases include parsing Fortran source code into structured nodes while preserving positional and semantic metadata for analysis or transformation tools.",
      "description_length": 525,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_xlf.Assertion",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing specific assertion kinds like `Itercnt`, `Minitercnt`, `Maxitercnt`, and `Nodeps`. It provides functions to convert these assertions to strings (`to_string`, `to_simple_string`) and to tag them with associated data (`to_tag`). These operations support parsing and processing of Fortran XL Fortran directives by mapping assertion variants to structured representations.",
      "description_length": 420,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.LangExtension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of supported Fortran language extensions as a variant type, including vendors like IBM, Intel, and PGI. It provides a direct mapping from these extensions to their string representations. Use this module when handling Fortran source files that require specific compiler extensions, such as CUDA support for GPU-accelerated code.",
      "description_length": 354,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements Fortran lexical analysis, preprocessing, and token processing, providing functions for source form detection, macro expansion, directive handling, and AST generation with detailed source location tracking. It operates on lexing buffers, tokens, and AST nodes to support use cases such as parsing OpenMP/OpenACC pragmas, handling include directives, and performing fault-tolerant parsing of Fortran control structures. The module includes submodules for low-level token manipulation, transformation, and state management during parsing and preprocessing.",
      "description_length": 576,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for parsing and representing Fortran name attributes (e.g., intent, access modifiers, dimensionality) and constructing specifications for variables, procedures, and module-like structures. It works with variant types, string representations, and symbol tables to enable semantic analysis tasks like symbol resolution, type inference, and declaration tracking, while supporting use cases such as defining constants, derived types, and scoped units with access control.",
      "description_length": 499,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Rank",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of values and operations to represent and manipulate array rank information in Fortran code analysis. It includes functions to construct rank values from integers, check if a rank is zero or non-zero, and convert rank values to strings. It is used to track the dimensionality of arrays during parsing and semantic analysis of Fortran programs.",
      "description_length": 369,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.LangConfig",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines standard maximum line length limits for fixed and free Fortran source formats. It provides integer values `default_max_line_length_fixed` and `default_max_line_length_free` representing the maximum allowed line lengths for each format. These values are used to enforce line length constraints during Fortran source code parsing and validation.",
      "description_length": 363,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Token.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module translates Fortran abstract syntax tree (AST) components\u2014such as program units, expressions, type specifications, and subroutine statements\u2014into token sequences paired with source location metadata. It includes utilities to classify and measure tokens, with specialized handling for preprocessing directives and structural elements like PU tails. The functionality supports tasks like source-to-source transformations, code analysis, and pretty-printing where precise token-level manipulation or AST reconstruction is required.",
      "description_length": 539,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_xlf.Directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines data types and operations for handling Fortran compiler directives specific to the XLF dialect. It supports parsing and manipulating directive types such as loop control, source form specification, and execution frequency, along with conversion functions to strings and extraction of associated labels or names. Concrete use cases include processing `!DEC$` or `CDEC$` directives during Fortran source analysis and transformation.",
      "description_length": 450,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Common.LangSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different Fortran language standards and provides a function to convert these variants to their corresponding string representations. It works with the `t` type, which includes constructors for F77, F90, F95, F2003, and F2008. Use this module when handling Fortran source files to identify and represent the specific language version being parsed.",
      "description_length": 395,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements Fortran-specific parsing and semantic analysis operations, including token generation with source location metadata, macro expansion, and context-sensitive lexical analysis. It works with `Sedlexing.lexbuf`, Fortran AST nodes, symbol tables, and token sequences to support concrete tasks like preprocessor directive handling, macro resolution, and dialect-aware parsing with features such as OpenMP or OpenACC. Key functions enable precise token reconstruction, end-of-file marker creation, and semantic validation of Fortran constructs during compilation or transformation workflows.",
      "description_length": 607,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens_.T",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of lexical tokens used in parsing Fortran code, including compiler directives, control structures, data types, and preprocessor elements. It works with abstract syntax tree nodes and string-labeled variants to represent parsed language constructs and metadata. These tokens are used directly by the parser to build structured representations of Fortran programs during compilation.",
      "description_length": 421,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.ProcInterface",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` that represents different kinds of procedure interfaces in Fortran, including unknown interfaces, named interfaces, and interfaces based on type specifications. It provides functions to convert interface values to strings, extract names, construct interfaces from labels, and check if an interface is a named interface. This module is used to analyze and manipulate Fortran procedure declarations by distinguishing between different interface forms during parsing and semantic analysis.",
      "description_length": 517,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides lexical analysis and parsing tools for Fortran code, focusing on token generation, source form detection, and preprocessing of compiler-specific extensions. It operates on `Sedlexing.lexbuf` input buffers, source form states (`SF.t`), and annotated tokens (`qtoken`), handling Fortran-specific features like Hollerith constants, continuation lines, and directive buffering. Key use cases include parsing legacy fixed-form syntax, managing OpenMP/OpenACC directives, and preprocessing macros while maintaining precise source location tracking for error reporting and semantic analysis.",
      "description_length": 605,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module tokenizes Fortran source code, processes preprocessor directives, and maps AST nodes to location-annotated tokens. It works with `Sedlexing.lexbuf`, Fortran AST nodes, and `Tokens.token` to support parsing, preprocessing, and semantic analysis. Concrete use cases include handling fixed/free-form syntax, expanding `#include` and `#ifdef`, and mapping AST fragments to source locations for error reporting or code transformation.",
      "description_length": 441,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec.Directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran compiler directives and annotations, along with operations to convert them to strings, extract names, and classify their usage context. It includes functions to simplify, anonymize, and tag directives based on their structure and semantic role. Concrete use cases include parsing and processing Fortran source files to analyze or transform compiler directives during preprocessing or static analysis.",
      "description_length": 456,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser.Make",
      "library": "diffast-langs-fortran-parsing",
      "description": "The module provides functions to parse Fortran source code into partial abstract syntax tree (AST) nodes, focusing on syntactic elements like variables, expressions, control structures, and program units. It operates on `lexbuf` input using a custom token stream, producing incomplete AST fragments (`Partial.t`) through incremental parsing techniques supported by the MenhirInterpreter and Incremental modules. This approach enables error-resilient parsing and handling of incomplete or malformed code, useful for tools like interactive editors or gradual code analysis systems.",
      "description_length": 579,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_generic_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines types and operations for handling generic specification records in Fortran parsing, including formatted, unformatted, and custom record kinds. It supports converting these specifications to strings, extracting names, and anonymizing them for consistency. Use cases include processing Fortran I/O statements and managing operator and assignment specifications during semantic analysis.",
      "description_length": 404,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_control_edit_desc",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing different Fortran control edit descriptors, such as position control, end-of-record markers, sign formatting, and scale factors. It provides functions to convert these descriptors to string representations, extract structured tags with attributes, and anonymize sensitive content. Use cases include parsing and manipulating Fortran format strings for input/output operations and code analysis tools.",
      "description_length": 451,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_position_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different position specifications in Fortran I/O statements, such as `Err`, `Iomsg`, `Iostat`, and `Unit`. It provides functions to convert these specifications to strings, extract labels, and transform them into corresponding I/O control and inquire specs. Use cases include handling error labels in I/O operations and mapping position specifiers to their string representations or associated tags with attributes.",
      "description_length": 463,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_header_file",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran header file constructs, supporting operations to create, inspect, and convert header file entries such as user, system, macro, and generated headers. It provides accessors to extract attributes, names, and paths, and includes utilities to anonymize entries or convert them to string representations. Concrete use cases include processing Fortran include directives, managing macro definitions, and handling generated or system header references during compilation or analysis tasks.",
      "description_length": 529,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_type_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran type specifiers, including built-in types like `Integer`, `Real`, and `Complex`, as well as derived and user-defined types. It provides functions to convert type specs to strings, extract names, and map keywords to type values, supporting precise parsing and manipulation of Fortran type declarations. Concrete use cases include type resolution in Fortran AST processing and type string normalization during code generation.",
      "description_length": 480,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Token",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates conversion and manipulation of Fortran tokens, handling operations like serialization, keyword classification, and source location tracking. It works with token representations such as `qtoken`, `rawtoken`, and `PB.token`, alongside AST components, enabling precise token-level transformations and metadata-aware processing. Its utilities support use cases like static code analysis, AST reconstruction, and source-to-source translation with fidelity to original source structure.",
      "description_length": 504,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_ocl_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for interpreting and transforming OpenCL pragma directives embedded in Fortran code, focusing on optimizations like loop unrolling, array fusion, and memory prefetching. It works with variant types representing directive kinds (e.g., `Parallel`, `Simd`) and structured tuples containing parameters, using helper functions to extract numeric values, resolve symbolic references, and analyze directive placement within Fortran's code structure. Specific use cases include static analysis of OpenCL-annotated Fortran for optimization opportunities and generating transformed code with applied parallelism or memory access patterns.",
      "description_length": 660,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_intent_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates intent specifications for Fortran variables, supporting conversion to string representations and extraction of associated tags. It operates on a variant type representing `In`, `Out`, and `Inout` intents. Use cases include parsing Fortran keywords into intent values and generating string or tagged output for code generation or analysis tools.",
      "description_length": 380,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Context",
      "library": "diffast-langs-fortran-parsing",
      "description": "This component defines a tagged type for tracking parsing contexts in Fortran code, with operations to manipulate syntactic construct tags (e.g., program units, statements, expressions) and associated state flags. It provides utilities to inspect and modify these contexts, enabling precise analysis of code structure during parsing, such as resolving function boundaries, declaration scopes, and execution flow. The type works with Fortran source elements like variables, derived types, and module components, supporting use cases in semantic analysis, code transformation, and context-sensitive error checking.",
      "description_length": 612,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Keyword",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module maps specific Fortran keyword strings to their corresponding token representations, handling various context-dependent keyword sets. It processes string inputs to identify and return the appropriate token for keywords related to I/O control, language bindings, file positioning, and connection specifications. These functions are used during parsing to accurately interpret Fortran syntax in contexts like `OPEN`, `CLOSE`, `INQUIRE`, and `FLUSH` statements.",
      "description_length": 469,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_format",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing different Fortran format specifiers, including expressions, labeled formats, and list-directed input/output. It provides operations to convert format values to strings, extract labels, and anonymize labeled formats. Use cases include parsing and manipulating Fortran format statements, particularly for handling labeled and list-directed I/O in compiler frontends or code analysis tools.",
      "description_length": 431,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_case_value_range",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing different kinds of case value ranges in Fortran, such as single values, lower bounds, upper bounds, and inclusive ranges. It provides functions to convert these range types into string representations and tagged tuples, suitable for use in AST processing or code generation. These operations are specifically useful when handling Fortran's `SELECT CASE` construct and similar control flow structures.",
      "description_length": 444,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module tokenizes Fortran source code, processes preprocessor directives, and maps AST nodes to location-annotated tokens. It operates on `Sedlexing.lexbuf`, Fortran AST nodes, and `Tokens.token` to handle syntax parsing, directive expansion, and source location tracking. Use cases include managing fixed/free-form formatting, resolving `#include` and `#ifdef` directives, and linking AST elements to their source positions for diagnostics or refactoring.",
      "description_length": 460,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a rich set of terminal symbols for parsing Fortran code, including keywords, operators, literals, and compiler directives. It works with `MenhirInterpreter.terminal` values to represent distinct token categories recognized during parsing. These terminals enable precise syntactic and semantic analysis of Fortran constructs such as control structures, data declarations, and parallel programming directives.",
      "description_length": 427,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Lib",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a function to convert traditional Menhir parsers into revised parsers that track token positions, and a predefined macro table for Fortran parsing. It works with parser types from MenhirLib and Lexing positions, along with macro tables for preprocessing. Concrete use cases include setting up Fortran parsers with position tracking and initializing macro environments for Fortran code processing.",
      "description_length": 417,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_module_subprogram",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different kinds of Fortran module subprograms\u2014functions, subroutines, and separate module subprograms\u2014each identified by a name. It provides operations to convert these subprogram types to string representations, extract or modify their names, and serialize them with tags for structured output. Concrete use cases include parsing and analyzing Fortran code, generating human-readable or machine-parsable representations of subprograms, and anonymizing subprogram names for obfuscation or testing.",
      "description_length": 545,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_connect_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran connection specifications, such as file access modes, unit identifiers, and error labels. It provides functions to convert these specifications to strings, extract labels, map them to inquire specifications, and anonymize them. Use cases include parsing and manipulating Fortran OPEN and INQUIRE statements, handling file I/O options, and processing labeled error targets in Fortran code.",
      "description_length": 444,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_inquire_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran `INQUIRE` specifiers and provides operations to convert them to strings, extract labels, and anonymize values. It works directly with Fortran labels and keyword-based specifiers used in file and unit inquiries. Concrete use cases include parsing and manipulating Fortran `INQUIRE` statements for static analysis or code transformation tools.",
      "description_length": 397,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer",
      "library": "diffast-langs-fortran-parsing",
      "description": "The module implements lexical analysis operations for Fortran source code, focusing on character classification and state transition management to identify tokens. It operates on lookup tables (`__sedlex_table_*`) and partition functions that map character codes to lexical categories (e.g., whitespace, digits, operators) and state transitions. These components enable efficient token recognition for Fortran constructs like keywords, literals, and preprocessor directives, supporting tasks such as parsing conditional compilation blocks or distinguishing language-specific operators.",
      "description_length": 585,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Printer",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts structured Fortran abstract syntax trees to human-readable strings. It provides functions to recursively format individual nodes, entire trees, or print them directly to standard output. Use it when generating textual representations of parsed Fortran code for debugging or logging.",
      "description_length": 303,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_pp_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functionality to represent and manipulate preprocessor directives in Fortran code, focusing on conditional logic (branches like `If`, `Else`, `Endif`), diagnostic messages (`Error`, `Warning`), and directives such as `Define` and `Include`. It operates on structured types that model these elements, enabling tasks like parsing, metadata extraction, and normalization. Specific use cases include preprocessing Fortran sources to resolve conditionals, generating human-readable representations, and anonymizing code for analysis or tooling purposes.",
      "description_length": 569,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_proc_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates procedure attribute specifications in Fortran, including visibility, binding, intent, and storage characteristics. It provides operations to convert attributes to strings, extract structured tags, anonymize values, and construct attributes from keywords. Concrete use cases include parsing Fortran source code to represent and transform procedure declarations during compilation or analysis.",
      "description_length": 427,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_linda_call",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different Linda coordination operations in Fortran code, such as `In`, `Out`, and `Eval`. It provides functions to convert these operations to string representations and to extract tagged information with associated arguments. This module is used to parse and represent Linda calls in Fortran source code, enabling analysis or transformation of parallel programming constructs.",
      "description_length": 425,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_program_unit",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different Fortran program units such as main programs, functions, subroutines, modules, and block data. It provides operations to convert these units to string representations, extract their names, and anonymize them by removing identifiers. These functions support analysis, transformation, and reporting tasks on Fortran source code structures.",
      "description_length": 394,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents conditional compilation branches in Fortran code, using tags to capture directives like `#ifdef`, `#ifndef`, and `#if`, along with their associated locations. It provides operations to convert tags to strings, extract source locations, and map tags to AST nodes with location information. Concrete use cases include analyzing preprocessor directives, transforming conditional code blocks, and supporting precise error reporting during parsing.",
      "description_length": 466,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_defined_operator",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates user-defined operators in Fortran, supporting operations to construct, deconstruct, and convert operator types. It works with a variant type `t` that distinguishes between general, unary, and binary defined operators, along with functions to extract names, anonymize operators, and serialize them to strings or tagged representations. Concrete use cases include parsing and processing custom operators in Fortran source code during compilation or analysis tasks.",
      "description_length": 501,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_io_control_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran I/O control specifiers, handling both their string representations and structured data forms. It supports operations to convert between textual keywords and typed values, extract names and labels, and anonymize specific specifiers. Concrete use cases include parsing Fortran I/O statements, generating error messages with descriptive tags, and analyzing control flow in Fortran code.",
      "description_length": 430,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_format_item",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates Fortran format specifiers, including data edits, control descriptors, and special symbols like `$` or `\\`. It supports operations to convert format items to strings, simplify or anonymize them, and extract structured tags with attributes. Use cases include parsing and pretty-printing Fortran I/O format strings, and transforming format descriptors during code analysis or refactoring.",
      "description_length": 421,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_proc_component_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates Fortran procedure component attribute specifications, such as `Pointer`, `Pass`, `Nopass`, `Private`, and `Public`. It provides operations to convert attributes to strings, extract names, anonymize them, and serialize to tagged representations with associated metadata. Concrete use cases include parsing and processing Fortran code attributes for procedure components during static analysis or transformation tasks.",
      "description_length": 452,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_wait_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different wait specifiers in Fortran, such as end-of-record, end-of-file, and error conditions, each optionally associated with a label. It provides functions to convert these specifiers to strings, extract labels, and anonymize them by removing label information. Concrete use cases include parsing and processing Fortran I/O statements where wait specifiers control program flow based on I/O events.",
      "description_length": 449,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran attribute specifications, such as `Parameter`, `Allocatable`, and `Pointer`, along with operations to convert these attributes to strings, simplified string representations, tagged tuples, and to parse them from keywords. It directly supports Fortran attribute handling in parsing and code generation tasks. Use cases include translating Fortran declarations into internal representations and serializing attributes for output or analysis.",
      "description_length": 495,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens_",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of lexical tokens representing Fortran language constructs, including compiler directives, control structures, data types, and preprocessor elements. It works with abstract syntax tree nodes and string-labeled variants to capture parsed elements and metadata. These tokens are used directly by the parser to construct structured representations of Fortran programs during compilation.",
      "description_length": 424,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_prefix_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran prefix specifications, such as type declarations, purity, and elemental attributes. It provides conversions to string and simplified string forms, extraction of names, and construction from keywords. Use cases include parsing and processing Fortran function and variable declarations with specific modifiers.",
      "description_length": 355,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_constant",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates various types of Fortran literal constants and named references, including integers, real numbers, complex numbers, logical values, characters, and preprocessor macros. It provides constructors for creating specific constant variants, functions to extract names and values, and transformations to anonymize or convert constants to different string formats. Concrete use cases include parsing Fortran source code to represent constants accurately, supporting analysis or transformation tools that require inspecting or modifying literal values or macro references in the code.",
      "description_length": 614,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing OpenACC clause keywords and provides functions to convert these clauses to string representations, extract tags with associated data, and anonymize clause values. It operates on the enumerated type `t` that includes OpenACC directives like `Async`, `Bind`, `Copy`, and `Device`, among others. Use cases include parsing and manipulating OpenACC pragmas in Fortran code, particularly for analysis, transformation, or code generation tasks involving accelerator directives.",
      "description_length": 518,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_omp_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates OpenMP directive types used in Fortran parsing, including atomic operations, parallel constructs, and synchronization primitives. It provides functions to convert these directives to string representations, extract names, and determine contextual usage in specification or execution parts of code. Concrete use cases include parsing OpenMP annotations in Fortran source files and generating human-readable representations of parallel constructs for analysis or transformation tools.",
      "description_length": 518,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Label_common",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for converting optional values and lists into formatted strings and structured attribute-value pairs, using functions like `opt_to_attr` and `list_to_attr` to enforce consistent encoding patterns. It handles data types including options, lists of strings or integers, and key-value pairs, emphasizing precise prefix/suffix handling and hierarchical data representation. These utilities are particularly useful for data serialization, configuration generation, and interfacing with systems requiring attribute-centric data models.",
      "description_length": 561,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing Fortran declaration specifiers and annotations, along with functions to convert them to string representations, extract structured tags, and anonymize values. It supports concrete use cases such as parsing and transforming Fortran source code during preprocessing, static analysis, or code generation workflows. The module also includes submodules for handling compiler directives, declaration clauses, and attribute specifiers with specific semantic roles in Fortran.",
      "description_length": 520,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_omp_construct",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different OpenMP constructs in Fortran code, such as `Atomic`, `Critical`, `Do`, `Parallel`, and combinations like `ParallelDo` or `TargetTeamsDistributeParallelDo`. It provides operations to convert these constructs to strings, extract names, anonymize named constructs, and serialize them with tags and attributes. These capabilities support parsing, analysis, and transformation of Fortran code involving OpenMP directives.",
      "description_length": 474,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_intrinsic_operator",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing intrinsic operators in Fortran, including logical, relational, arithmetic, and string operations. It provides functions to convert these operators to string representations and to extract tagged information with associated data. Use this module when processing or analyzing Fortran code that involves built-in operators, such as in AST transformations or semantic analysis.",
      "description_length": 421,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Label",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module classifies syntactic constructs, extracts embedded data (names, variables, directives), and constructs labeled AST nodes for Fortran code analysis, focusing on ambiguous parses and dialect-specific features like OpenMP or OpenACC. It operates on a sum type `Label.t` representing statement categories, declarations, and directives, alongside dialect-specific types such as `OmpDirective.t` and `AccDirective.t`. Key use cases include resolving syntactic ambiguities, transforming labeled constructs (e.g., loops, assignments), and validating semantic properties during Fortran parsing.",
      "description_length": 597,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_ambiguous",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing ambiguous Fortran syntax constructs, such as designators, tuples, array accesses, and data statement constants. It provides operations to convert these constructs to strings, extract names, and determine if a construct represents an array specification. Use cases include parsing Fortran code where syntactic ambiguity requires later resolution and transforming abstract syntax tree nodes during analysis or refactoring.",
      "description_length": 468,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates directive types used in parsing Fortran accelerator constructs. It supports operations like converting directives to strings, extracting names, checking context (specification or execution part), and anonymizing directive instances. The primary data types are `atomic_sub` and `t`, representing atomic suboperations and OpenACC directives such as `Parallel`, `Kernels`, `Loop`, and their end forms. Concrete use cases include processing and analyzing Fortran code with GPU offloading directives, enabling transformations or validations specific to parallel execution regions.",
      "description_length": 611,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_internal_subprogram",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents internal Fortran subprograms, either functions or subroutines, identified by a name. It provides operations to convert subprogram types to strings, extract or modify names, and generate tagged representations with associated metadata. Use cases include analyzing or transforming Fortran code structures during parsing or intermediate representation stages.",
      "description_length": 379,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_construct",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different OpenACC constructs in Fortran code, such as `Atomic`, `Parallel`, `Kernels`, and `Loop`. It provides functions to convert these constructs to string representations, extract tags with associated data, and anonymize construct values. These operations support analysis and transformation of Fortran code involving accelerator directives.",
      "description_length": 393,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_close_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines operations for handling Fortran `CLOSE` statement specifiers, including conversion to strings, extraction of labels, and transformation into connect specs. It works with a variant type representing different close specifiers, some of which carry labels. Concrete use cases include parsing and manipulating Fortran code during compilation or analysis tasks.",
      "description_length": 376,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements a token buffer for parsing Fortran code, handling operations such as token accumulation, partial parsing, and result classification. It works with token streams and partial parser states, using regular expressions to match numeric exponents during parsing. Concrete use cases include incremental parsing of Fortran source lines and managing incomplete or ambiguous parse results in a compiler frontend.",
      "description_length": 425,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates parsing Fortran source code by managing directive lines, language specifications, and source forms, while also converting lists, integers, and optional values into formatted strings or ordinal representations. It includes functionality for handling parsing errors with positional data and issuing warnings, making it suitable for processing Fortran programs with varying language extensions, line length constraints, or standards compliance requirements.",
      "description_length": 478,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module performs lexical analysis and preprocessing of Fortran source code, offering functions for token stream manipulation, macro expansion, and source form detection. It operates on lexing buffers, tokens, and abstract syntax trees (ASTs), with support for handling directives like include and pragmas such as OpenMP or OpenACC. Use cases include fault-tolerant parsing of Fortran control structures and detailed source location tracking during translation.",
      "description_length": 464,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_omp_clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles OpenMP clause attributes during Fortran parsing through enumerated types like data sharing modes, schedule kinds, and dependence types, along with conversion functions to string representations. It transforms AST nodes representing OpenMP clauses via the `anonymize` function, which removes identifiers to generate generalized forms. These capabilities support tasks like directive serialization, code analysis, and test case generation where clause structure preservation without specific identifiers is required.",
      "description_length": 534,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for Fortran-specific parsing and semantic analysis, including token generation with source location metadata, macro expansion, and context-sensitive lexical analysis. It works with `Sedlexing.lexbuf`, Fortran AST nodes, symbol tables, and token sequences to handle preprocessor directives, macro resolution, and dialect-aware parsing with OpenMP or OpenACC support. Key functions enable precise token reconstruction, EOF marker creation, and semantic validation of Fortran constructs during compilation or transformation workflows.",
      "description_length": 563,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran source code into partial AST nodes, handling variables, expressions, control structures, and program units. It processes input via `lexbuf` and generates incomplete AST fragments (`Partial.t`) using incremental parsing techniques. Designed for error-resilient parsing, it supports tools like interactive editors and code analysis systems that require handling of incomplete or malformed code.",
      "description_length": 419,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_access_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates access specifiers (`Private` and `Public`) in Fortran code. It provides conversions to string representations, attribute specifications, and structured tags, enabling precise handling of visibility in parsing and code generation. Use cases include translating access modifiers in Fortran declarations to various intermediate forms for analysis or output.",
      "description_length": 390,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_type_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates type attribute specifications in Fortran, including visibility, abstractness, binding, and inheritance. It provides operations to convert attributes to strings, extract structured tags, and anonymize names for consistency. Use cases include parsing Fortran type declarations and generating intermediate representations for analysis or transformation tools.",
      "description_length": 392,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ast",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for constructing and manipulating abstract syntax trees (ASTs) during Fortran parsing, with a focus on node creation, metadata management, and hierarchical traversal. It works with data structures representing AST nodes, lexical positions, labels, and specifier pairs, supporting transformations like positional spec conversion and semantic property extraction. Specific use cases include building metadata-rich ASTs, analyzing node relationships via pre/post-order traversal, and handling Fortran-specific constructs such as statement labels and specifier hierarchies.",
      "description_length": 601,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles Fortran parsing metadata, providing structured representations for array ranks, type specifiers, and procedure interfaces. It supports operations to construct, merge, and inspect name specifications with attributes like intent and access modifiers, and tracks dimensionality and type resolution during semantic analysis. Concrete use cases include parsing Fortran declarations, resolving symbols, and preparing for code generation by capturing detailed variable and procedure interface information.",
      "description_length": 518,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_xlf",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing specific XL Fortran constructs such as `CollapseArray`, `SubscriptorderArray`, and `ReductionClause`, along with operations to convert these to strings, extract names, and anonymize them. It supports parsing and transformation tasks by providing structured representations of XL Fortran extensions, particularly for handling array directives and clause types. Concrete use cases include analyzing `!DEC$` directives and processing loop transformations in Fortran source code.",
      "description_length": 527,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Macro",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles operations for representing and manipulating Fortran macro lines and bodies, with a focus on tracking resolution states, conditional statuses, and source locations. It works with structured representations of macro components\u2014such as raw strings, statuses, and object forms\u2014enabling their creation, conversion, and modification, while also supporting conditional logic management in macro bodies. These features are particularly useful for parsing Fortran code with macros, resolving conditional compilation directives, and preprocessing macro definitions.",
      "description_length": 576,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser_aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages parsing state and character context during Fortran source analysis, handling complex state transitions and symbol table operations. It works with state records tracking context flags, symbol tables, and stacks, alongside character context types to guide parsing decisions. Concrete use cases include tracking entry into Fortran constructs like `if`, `do`, and `type`, managing symbol visibility in nested scopes, and controlling parsing behavior in format, I/O, and type declaration contexts.",
      "description_length": 512,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_flush_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines operations for handling FLUSH statement specifiers in Fortran parsing, including converting values to strings, extracting labels, and anonymizing labeled specs. It works with a variant type representing possible FLUSH specifiers, such as error labels, IOMSG, IOSTAT, and UNIT. Concrete use cases include processing FLUSH statements during semantic analysis and generating consistent string representations for diagnostics or code generation.",
      "description_length": 461,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_binding_attr",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines operations for handling binding attributes in Fortran code, such as `Pass`, `Nopass`, and `Private`. It provides functions to convert attributes to strings, extract names, and anonymize bindings. These operations support analysis and transformation of Fortran interface and type-bound procedure declarations.",
      "description_length": 328,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Elaborate",
      "library": "diffast-langs-fortran-parsing",
      "description": "Copies a stack containing tuples with references, preserving structure and contents. Works with generic stack types where elements include references. Useful for duplicating parser state stacks during Fortran code analysis without shared mutable data.",
      "description_length": 251,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokensource",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes raw Fortran tokens and constructs qualified tokens with positional information. It handles tokenization of Fortran source code, including whitespace, comments, and line continuation. Use it when parsing Fortran programs to track token locations and structure input for further analysis.",
      "description_length": 308,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module performs semantic disambiguation and transformation on Fortran AST nodes, resolving symbols, binding identifiers, and inferring structural properties such as array ranks. It operates on labeled ASTs, scopes, and lexical contexts to handle ambiguities in array/pointer references, derived type components, and declarations. It is used to resolve variable and constant references in expressions, disambiguate procedure calls with Linda syntax, and elaborate control structures during semantic analysis.",
      "description_length": 512,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_case_selector",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing case selectors in Fortran, with variants for a list of value ranges or a default case. It provides functions to convert these selectors to string representations and extract tagged information with associated data. Use this module when processing Fortran `SELECT CASE` constructs to handle case labels and generate appropriate intermediate representations.",
      "description_length": 400,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_stmt",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a structured representation of Fortran statements through a generalized algebraic data type, capturing control flow constructs, declarations, and I/O operations with associated metadata like labels and variables. It offers utilities to classify statement categories (e.g., specification vs. execution), extract identifiers, and manipulate AST nodes through transformation and sanitization functions. The design supports use cases such as Fortran code analysis, compiler tooling, and program transformation tasks requiring precise statement introspection or restructuring.",
      "description_length": 592,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides Fortran source code parsing, abstract syntax tree (AST) manipulation, and semantic analysis capabilities, handling language-specific constructs like OpenACC directives, preprocessor macros, type attributes, and I/O specifications. It operates on structured representations including AST nodes, token streams, and source locations to enable tasks such as compiler tooling, static analysis, and source-to-source translation with precise error reporting and context tracking. Key operations include disambiguating overloaded syntax, elaborating declarations, and transforming Fortran code while preserving semantic fidelity.",
      "description_length": 642,
      "index": 216,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 300,
    "meaningful_modules": 217,
    "filtered_empty_modules": 83,
    "retention_rate": 0.7233333333333334
  },
  "statistics": {
    "max_description_length": 714,
    "min_description_length": 251,
    "avg_description_length": 504.8479262672811,
    "embedding_file_size_mb": 3.145634651184082
  }
}