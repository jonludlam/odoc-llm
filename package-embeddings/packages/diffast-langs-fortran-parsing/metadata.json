{
  "package": "diffast-langs-fortran-parsing",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 215,
  "creation_timestamp": "2025-07-16T00:03:39.726500",
  "modules": [
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for converting Fortran AST nodes (program units, statements, expressions, type definitions) into token-location pairs and analyzing token properties, such as directive types or size. It works with Fortran abstract syntax trees and token streams to support parsing, preprocessing, and pretty-printing workflows, particularly for handling preprocessor directives and structured type definitions.",
      "description_length": 425,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parser execution and control through token management, checkpoint manipulation, and stack inspection, operating on LR(1) states, parser environments, and checkpoints to support error recovery and custom parsing strategies. It also provides grammar analysis capabilities such as computing nullable nonterminals, first sets, and symbol iteration, which are essential for optimizing parsing pipelines and implementing domain-specific language tooling. The operations bridge low-level parser mechanics with high-level grammar introspection, facilitating applications like syntax-aware editors and parser debugging tools.",
      "description_length": 648,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran syntax\u2014including type declarations, subroutines, expressions, and OpenMP directives\u2014using Menhir-based stepwise construction and recovery mechanisms. It works with partial AST nodes (`Fortran_parsing.Ast.Partial.t`) and lexing positions to generate checkpoints that support error recovery and incremental processing, making it suitable for parsing large codebases or handling complex constructs in real-time scenarios.",
      "description_length": 469,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to generate incremental parsing checkpoints for Fortran constructs such as function statements, expressions, control structures, and OpenMP/OpenCL directives, using lexical positions to capture partial parsing states. It operates on `Lexing.position` values and returns `MenhirInterpreter.checkpoint` instances parameterized over partial AST representations (`Ast.Partial.t` or `Ast.node`), enabling granular, position-aware parsing. This supports error recovery, iterative source analysis, and stepwise parsing of Fortran program units, declarations, and complex language features.",
      "description_length": 613,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to map Fortran AST nodes (e.g., program units, expressions) to tokens augmented with location metadata, alongside utilities for token classification, size analysis, and metadata extraction. It operates on AST nodes and token sequences, enabling tasks like parsing, static analysis, and tooling that require precise Fortran source code manipulation.",
      "description_length": 379,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables low-level control of incremental parsing workflows by processing tokens and symbols through customizable strategies, supporting operations like stack manipulation, state transitions, and grammar analysis. It operates on parser environments, checkpoints, and grammar structures such as terminals, nonterminals, and productions, while exposing capabilities to inspect parser states, compute first sets, and enforce reductions. Its design facilitates use cases like error recovery, grammar debugging, and implementing domain-specific parsing logic with fine-grained state management.",
      "description_length": 600,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to translate Fortran AST nodes (e.g., program units, expressions, type specs) into tokens paired with source location data, alongside utilities for analyzing and categorizing preprocessor directives (e.g., `include`, general directives). It operates on AST structures and token representations, enabling tasks like pretty-printing, source analysis, and directive handling through operations such as directive classification, token size computation, and partial-specification-based token construction. Specific use cases include processing Fortran preprocessor macros and generating structured token streams for downstream compilation or transformation tools.",
      "description_length": 689,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis, scope management, and AST transformation capabilities for Fortran code, focusing on symbol registration, name resolution, and error handling. It operates on Fortran AST nodes, scope frames, symbol tables, and lexical metadata like labels and positions, supporting tasks like compiler front-end development, static analysis, and code refactoring where precise handling of program entities and their attributes is required. Key patterns include scope lifecycle management, attribute propagation, and labeled node manipulation for accurate source representation.",
      "description_length": 599,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This component supports semantic analysis and scope management during Fortran parsing by handling declaration registration, symbol table updates, and error validation across program entities like modules, functions, and subroutines. It operates on AST nodes, name frames, and lexical structures while providing utilities for label normalization, OCL directive translation, and node attribute manipulation. Key use cases include scope boundary tracking, semantic error detection, and AST transformation during parsing of Fortran source code.",
      "description_length": 540,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran source code into partial abstract syntax trees and performs preprocessing tasks using a custom lexer and token stream. It supports incremental parsing of constructs like interface specifications, function statements, expressions, and OpenMP/OpenACC directives, producing AST fragments that can be refined over time. The module enables fine-grained parser control through checkpointing, LR(1) state manipulation, and grammar analysis operations such as nullable nonterminal and first set computation. Applications include compiler development, static analysis tools, and syntax-aware editors that require efficient, real-time parsing and error recovery over large Fortran codebases.",
      "description_length": 708,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates converting Fortran AST nodes (e.g., program units, expressions) and preprocessor constructs into tokens enriched with location metadata, following structured specification patterns. It also includes utilities to query token properties, such as directive classifications (include, preprocessor) and size metrics, operating on `token` and `spec` types. These capabilities support parsing, static analysis, and transformation of Fortran code involving preprocessor logic and structured token generation.",
      "description_length": 524,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides low-level parsing operations for a Menhir-based parser, focusing on token handling, checkpoint manipulation, and stack management. It works with parser states, tokens, positions, and grammar symbols to enable incremental parsing, lexer integration, and control strategies like `Legacy` or `Simplified`. Specific use cases include analyzing Fortran grammar properties (nullability, first-terminals), guiding reductions via environment modifications, and inspecting production rules for parsing decisions.",
      "description_length": 524,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to generate incremental parsing checkpoints for Fortran syntax elements like statements, expressions, and blocks, enabling stepwise parsing and error recovery. It operates on partial AST nodes (`Fortran_parsing.Ast.Partial.t`) and Lexing positions, producing Menhir checkpoints parameterized by position. These capabilities support robust parsing of incomplete or malformed Fortran code, allowing resumption from specific points in the input stream.",
      "description_length": 480,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by transforming raw tokens into structured AST nodes, tagging them with location data and building parsed constructs from token streams and context. It supports conditional compilation and branch handling in Fortran grammar, while its child module converts AST nodes back into token-location pairs and analyzes token properties like directive types. Together, they enable parsing, preprocessing, and pretty-printing workflows, handling program units, expressions, and structured type definitions. Example uses include processing preprocessor directives, reconstructing token streams from ASTs, and extracting location-aware tokens for analysis or transformation.",
      "description_length": 704,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes into location-annotated tokens and classifying preprocessor tokens. It operates on Fortran abstract syntax trees and token streams, supporting tasks like directive identification (e.g., include statements) and token metadata extraction. The functionality is particularly useful for preprocessing steps that require structured analysis of Fortran source code, such as macro expansion or conditional compilation handling.",
      "description_length": 483,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST nodes (e.g., program units, expressions) into tokens enriched with source location data, while also analyzing token metadata to identify preprocessor directives, compute sizes, and resolve partial AST fragments. It operates on Fortran abstract syntax trees and token streams, enabling use cases like parsing source code into structured tokens, preprocessing directive resolution, and extracting structural information for compiler tooling.",
      "description_length": 474,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports incremental parsing and introspection of Menhir-generated LR(1) parsers through operations that feed tokens to checkpoints, manipulate parser states, and analyze grammar properties. It works with parser environments, LR(1) states, terminals, nonterminals, and productions to enable tasks like error recovery, lookahead analysis, and runtime grammar inspection. Specific use cases include implementing custom parsing strategies, debugging parser behavior, and computing first sets or nullable symbols during compilation.",
      "description_length": 540,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to convert Fortran AST nodes (like program units, expressions, and type specs) into location-annotated tokens, alongside utilities for token classification and metadata extraction (e.g., identifying include statements, directives, or token sizes). It operates on Fortran abstract syntax trees and token structures, enabling analysis of code structure and preprocessing artifacts. These capabilities are particularly useful for compiler pipelines, static analysis tools, or code refactoring systems that require precise Fortran source representation.",
      "description_length": 580,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes into lexical tokens paired with source location metadata, alongside functions to query token properties like type classifications (e.g., directives, includes) and positional attributes. It operates on Fortran abstract syntax trees and token streams, enabling use cases such as source-to-source translation, static analysis, and diagnostic reporting that require precise mapping between AST elements and their lexical representations.",
      "description_length": 497,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran source code into partial AST nodes, handling program units, type declarations, control structures, and interface specs using lexbuf input and a custom token stream. It generates `Ast.Partial.t` values and supports incremental parsing through Menhir checkpoints, enabling compiler frontends, static analysis tools, and language servers to process Fortran code efficiently and context-aware. The first child module enhances this by capturing parsing checkpoints at lexical positions, producing `MenhirInterpreter.checkpoint` instances that allow stepwise parsing, error recovery, and analysis of constructs like OpenMP directives and function statements. The second child module provides low-level parsing utilities for token handling, checkpoint manipulation, and parser control, supporting grammar analysis, reduction strategies, and environment-based parsing decisions.",
      "description_length": 897,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates converting Fortran abstract syntax trees (ASTs) into token sequences enriched with location metadata, supporting constructs like program units, statements, and type specifications. It also enables analysis of Fortran preprocessor tokens by identifying directive types (e.g., includes), extracting token sizes, and retrieving data from partial AST nodes. These operations are useful for tools requiring precise source-to-token mapping, such as compilers or static analyzers processing Fortran code with preprocessor directives.",
      "description_length": 550,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates parsing error handling, registration of Fortran constructs (e.g., variables, functions, modules, derived types), and management of parsing scopes and labels. It operates on AST nodes, symbol tables, lexical positions, and OCL directives, enabling semantic analysis through scope normalization, attribute manipulation, and AST transformations annotated with positional/type metadata. Specific use cases include parsing Fortran programs, resolving name references, and error reporting during semantic analysis of program units like subroutines and common blocks.",
      "description_length": 584,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables low-level parsing operations for Menhir-based parsers, including token stream processing, checkpoint resumption, and parser stack manipulation. It works with LR(1) parser states, environments, and grammar symbols (terminals, nonterminals, productions) to support introspection of parsing contexts, error recovery, and analysis of grammar properties like nullability and first sets. Specific use cases include dynamic parsing control, custom error handling, and symbolic analysis of parser behavior.",
      "description_length": 518,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers functions to control and analyze the execution of an incremental parser, enabling tasks like feeding tokens, resuming parsing from checkpoints, and inspecting parser states. It operates on parser environments, LR(1) state stacks, and symbol productions, with utilities for manipulating parsing workflows and analyzing grammar properties such as nullable nonterminals. These capabilities are particularly useful for error recovery, syntax-directed transformations, and optimizing Fortran-specific parsing workflows through precise parser state management.",
      "description_length": 573,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes (like program units, statements, and expressions) into token-location pairs and analyzing preprocessor directives. It operates on Fortran AST structures, tokens, and specification parameters, offering functions to detect include directives, measure token sizes, and classify directive types. These capabilities are particularly useful for Fortran code analysis, preprocessing, and transformation tasks that require precise source location tracking or directive handling.",
      "description_length": 534,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a comprehensive framework for lexing, parsing, and analyzing Fortran source code, integrating support for preprocessor directives, lexical constructs, and semantic analysis. It defines core data types like `qtoken`, `token`, `SourceForm.t`, and `Loc.t`, and enables mixed-source form parsing, directive resolution, and precise location tracking. Child modules extend its capabilities with AST-to-token translation, directive analysis, and semantic scope management, supporting tasks like macro processing, pretty-printing, and semantic error checking. Examples include extracting preprocessed token streams with location data, translating AST nodes into source-accurate tokens, and managing symbol tables during parsing.",
      "description_length": 741,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables precise control over incremental parsing workflows by managing token consumption, checkpoint resumption, and lexer integration, while exposing interfaces to inspect parser states, environments, and LR(1) item transitions. It operates on structured representations of parsing contexts including terminals, nonterminals, and symbolic states, with utilities to analyze language properties like nullability and first sets. Typical applications include implementing custom error recovery strategies, debugging parser behavior through state introspection, and building domain-specific language processors with dynamic parsing control.",
      "description_length": 648,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran source code incrementally, converting lexbuf input into partial ASTs while handling program units, declarations, control structures, and accelerator directives like OpenMP and OpenCL. It supports stepwise parsing for integration into larger pipelines, allowing construction of AST fragments for Fortran programs and declarations. The child module provides low-level control over parsing workflows through customizable strategies, enabling stack manipulation, state transitions, and grammar analysis on terminals, nonterminals, and productions. Together, they support tasks like error recovery, grammar debugging, and implementing domain-specific parsing logic with precise state management.",
      "description_length": 717,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module generates checkpoints to capture partial parsing states for Fortran's structural elements, including program units, type declarations, control structures, and OpenMP/OpenCL directives. It operates on Fortran AST nodes and lexical positions, enabling resumption or inspection of parsing progress at specific syntactic boundaries. These capabilities support incremental parsing workflows and error recovery in Fortran compilers or analysis tools processing incomplete or evolving source code.",
      "description_length": 502,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for semantic analysis and symbol management during Fortran parsing, handling operations like error reporting, scope lifecycle management (e.g., program/module boundaries), and symbol registration in AST nodes. It works with Fortran abstract syntax trees, symbol tables, labels, and type specifications to support tasks like name resolution, directive conversion, and lexical position tracking. Key use cases include normalizing labels, binding OCL directives to AST elements, and maintaining hierarchical scope contexts during compilation.",
      "description_length": 570,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran tokens and tracks their locations, enabling precise conversion of lexical positions into AST locations, merging of location ranges, and context-sensitive parsing decisions based on Fortran syntax. It identifies key elements like statement heads, conditionals, and edit descriptors using regex and token inspection, while supporting AST node construction and token transformation. Submodules handle semantic analysis and scope management, incremental parsing with custom lexing, AST-to-token conversion, and preprocessing tasks like directive classification and macro expansion. Example uses include building compiler front-ends, performing static analysis, and implementing syntax-aware tools that require accurate source location tracking and transformation of Fortran code.",
      "description_length": 805,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for semantic analysis and symbol management during Fortran parsing, focusing on error reporting, scope lifecycle control, and attribute manipulation. It operates on abstract syntax trees (ASTs), labels, and lexical scope frames to handle tasks like registering program units, resolving names, and transforming node structures. Key use cases include semantic validation of Fortran constructs, managing symbol visibility across scopes, and processing OCL directives or edit descriptors during parsing.",
      "description_length": 530,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables partial parsing of Fortran constructs\u2014such as variables, subroutines, and OpenMP/OpenACC directives\u2014by consuming `lexbuf` input and generating intermediate AST fragments using custom token types. It coordinates with child modules to support incremental parsing through checkpoints and Menhir's LR(1) introspection, allowing stepwise construction, error recovery, and context-sensitive decisions. The main data types include `Fortran_parsing.Ast.Partial.t`, Lexing positions, parser checkpoints, and LR(1) states, with operations to feed tokens, resume parsing, and analyze grammar properties. Examples include parsing incomplete Fortran code from arbitrary positions, resolving ambiguous productions via multi-pass strategies, and inspecting parser state to guide custom error recovery.",
      "description_length": 806,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to generate incremental parsing checkpoints for Fortran syntax elements like program units, declarations, and directives, operating on lexical positions and producing partially built AST nodes or unit values. It supports resumable parsing in Menhir-based systems by capturing state at specific points in the input stream, enabling recovery and continuation when parsing incomplete constructs such as function headers, expressions, or OpenMP/OpenCL clauses.",
      "description_length": 487,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran syntax through checkpoints that capture partial program state, producing structured AST fragments or unit values tied to lexing positions. It operates on Fortran-specific constructs like program units, interface blocks, and expressions using Menhir's checkpoint mechanism, allowing recovery from incomplete or invalid syntax during parsing. Key use cases include interactive development environments and gradual code analysis where partial results are needed before full program parsing completes.",
      "description_length": 548,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides incremental parsing functions for Fortran syntactic constructs like statements, expressions, and program units, producing resumable checkpoints tied to source positions. It operates on Lexing.position values and partial AST nodes using Menhir's incremental API, enabling piecemeal parsing of incomplete code. Its design supports use cases such as interactive development environments (IDEs) requiring error-tolerant parsing and stepwise code analysis.",
      "description_length": 472,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for parsing error handling, scope management, and symbol registration during Fortran AST processing, working with data structures like AST nodes, scope frames, labels, and OCL directives. It supports use cases such as semantic analysis for Fortran constructs (functions, modules, derived types), normalization of labels and declarations, and syntactic transformations like unary-to-binary operation conversion. Key functionalities include name resolution, attribute assignment, and interfacing with semantic analysis frameworks through structures like `Pinfo` and OCL tuple conversions.",
      "description_length": 618,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This component translates Fortran abstract syntax trees into location-annotated tokens for source tracking, handling constructs like program units, expressions, and type specifications. It operates on token streams and AST nodes, offering type checks for directives and size calculations to support parsing validation. Key applications include compiler front-end development and Fortran code analysis tools requiring precise source mapping.",
      "description_length": 440,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides low-level parsing operations for a Menhir-based incremental parser, primarily handling token processing, parser state manipulation, and grammar analysis. It operates on tokens, checkpoints, parser stacks, and environments to support incremental parsing of Fortran code, error recovery, and inspection of grammar properties like nullable nonterminals and first sets. Use cases include implementing custom parsing strategies, analyzing ambiguous grammars, and optimizing compiler",
      "description_length": 498,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes into tokens paired with source location metadata using specification and node parameters, supporting precise tokenization and position tracking. It operates on Fortran AST structures and token types, enabling queries to classify tokens (e.g., directives, includes), extract metadata, and analyze partial AST fragments. The functionality is particularly useful in compiler pipelines or static analysis tools requiring detailed source code reconstruction or diagnostic reporting.",
      "description_length": 516,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates the conversion of Fortran AST nodes\u2014such as program units, expressions, and control structures\u2014into tokens enriched with source location data, following a structured specification. It also enables analysis of preprocessor and directive tokens, allowing checks for properties like include directives or directive types, and determining token sizes. These features support Fortran parsing, preprocessing, and source-level tooling where precise token tracking and directive handling are required.",
      "description_length": 517,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.BF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "Supports converting Fortran AST nodes\u2014such as program units, statements, and expressions\u2014into tokens paired with source locations, enabling lexical analysis during parsing and pretty-printing workflows. Handles preprocessor directive tokens by identifying include directives, directive types, and metadata like size and position, facilitating tasks like macro expansion or conditional compilation analysis. This module is particularly useful for tools requiring precise token-level manipulation of Fortran source code, such as refactoring utilities or linters.",
      "description_length": 560,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages the construction and tagging of abstract syntax tree nodes during Fortran parsing, transforming lexical tokens into structured branch tags with positional data. It directly supports the creation of control flow structures like IF blocks and DO loops, while its child module enables conversion of AST nodes and preprocessor constructs into location-aware tokens and provides utilities to analyze token properties such as directive types and size metrics. Key data types include `token` and `spec`, with operations for tagging, querying, and structured token generation. Examples include assembling conditional logic from tokens and extracting preprocessor directives with metadata for analysis or transformation.",
      "description_length": 731,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for error reporting, scope management, and AST node transformations during Fortran parsing, operating on constructs like program units, derived types, and declarations. It manipulates AST nodes, labels, and symbol tables to handle semantic analysis, name resolution, and attribute propagation, with specific support for Fortran features like accessibility specs and OCL directives. Use cases include parsing subroutines, normalizing labels, and resolving renamed entities in modules or interfaces.",
      "description_length": 528,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran syntax tokens into structured AST nodes for branch constructs, converting tagged contexts and tokens into nodes with location data to build control flow structures like IF and DO loops during parsing. It includes functions to map AST nodes to tokens with metadata, classify tokens, analyze sizes, and extract metadata, supporting parsing and source manipulation tasks. Operations allow transforming raw token sequences into structured control flow representations and interrogating AST and token data for analysis or transformation. Examples include building IF statement nodes from token streams and extracting location metadata from DO loop constructs.",
      "description_length": 684,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran abstract syntax tree (AST) nodes into location-annotated tokens and analyzing preprocessor token properties. It operates on Fortran AST elements like program units, expressions, and type specifications, while interacting with preprocessor tokens through type checks (e.g., directive detection) and structural transformations. These capabilities support tasks like Fortran code parsing, preprocessing directive handling, and compiler intermediate representation generation.",
      "description_length": 526,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran abstract syntax tree (AST) nodes\u2014such as program units, statements, and type specifications\u2014into tokens enriched with location metadata, supporting precise source mapping. It also includes utilities to analyze and manipulate preprocessor tokens, enabling tasks like identifying directive types (e.g., `include`) or reconstructing tokens from partial AST fragments. These operations are critical for parsing, macro expansion, and tooling that requires fidelity between source code and its structured representation.",
      "description_length": 543,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates semantic analysis and code transformation in Fortran by handling error reporting, symbol registration, and scope management across program entities like modules and derived types. It operates on Fortran AST nodes, labels, and OCL directives, supporting tasks such as label normalization, node construction, and attribute manipulation during parsing and semantic processing. Key applications include resolving scoping rules, transforming AST elements with positional metadata, and converting OCL directives into structured identifiers or numeric values.",
      "description_length": 576,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for translating Fortran AST nodes into token-AST location pairs and analyzing preprocessor tokens. It operates on Fortran abstract syntax trees (ASTs) and token structures, offering functions to map program units, statements, and expressions to tokens, while also classifying preprocessor directives (e.g., include statements) and measuring token properties. These capabilities support tasks like source-to-source translation, code analysis, and preprocessing of Fortran programs containing macro directives.",
      "description_length": 539,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis operations for Fortran code, focusing on error handling, scope management, and symbol registration during parsing. It works with AST nodes, labeled constructs, and OCL directives to process Fortran language features like modules, derived types, and data objects. Key use cases include resolving name bindings, normalizing labels, converting OCL tuples to numeric values, and managing contextual symbol tables during scope transitions.",
      "description_length": 473,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module constructs and transforms AST nodes for Fortran branching logic, integrating token data and source locations into control flow structures. It converts parsed tokens and context tags into conditional branches and handles transformations of existing AST nodes. The child module enriches ASTs with token metadata, resolves preprocessor directives, and extracts structural information for tooling. Together, they enable parsing Fortran source into structured tokens, building control flow trees, and analyzing token streams for compiler passes.",
      "description_length": 552,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.BF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for mapping Fortran AST nodes to annotated token sequences and analyzing preprocessor token properties. It operates on abstract syntax trees representing Fortran constructs and token values from the parser, enabling source location tracking and classification of directives like includes. Typical applications include source code transformation pipelines requiring precise token-AST correspondence and preprocessor-aware static analysis tools.",
      "description_length": 474,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code through lexing and parsing operations, handling tokenization, source form detection, and lexical state management using `Sedlexing.lexbuf` and `qtoken` types. It supports semantic analysis and symbol management through child modules that handle scope lifecycle, symbol registration, and AST node binding, enabling tasks like name resolution and directive conversion. The parsing infrastructure translates ASTs into annotated tokens for source tracking, supporting compiler front-end development and code analysis tools. Specific capabilities include managing Hollerith constants, preprocessor directives, OpenMP clauses, and conditional compilation through macro parsing and file inclusion.",
      "description_length": 732,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran syntax nodes and tokens, transforming tagged context and token data into structured AST nodes while enabling detailed source reconstruction and analysis. It supports operations on parsing contexts, tokens, and location data to build and manipulate syntactic elements such as conditionals and loops. The child module specializes in converting AST nodes back into tokens with source location metadata, allowing precise classification, metadata extraction, and analysis of partial ASTs. Together, they facilitate robust parsing, transformation, and static analysis of Fortran code within compiler pipelines or diagnostic tools.",
      "description_length": 654,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to translate Fortran AST nodes into tokens paired with source location data and to query token properties like type and size. It operates on lexical tokens and structured AST elements such as statements, expressions, and program units. These capabilities support tasks like parsing, pretty-printing, and semantic analysis of Fortran code.",
      "description_length": 369,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran code through lexing, parsing, and preprocessing stages, working with lex buffers, source forms, and token streams to support compiler directives, macro expansion, and conditional compilation. It integrates semantic analysis and symbol management via ASTs and scope frames, enabling name resolution, symbol visibility control, and semantic validation, while also providing utilities to convert AST nodes into location-aware tokens for accurate source mapping and preprocessor token manipulation. Examples include parsing Fortran source with directive handling, expanding macros with positional tracking, and validating semantic constructs across scopes. The combination of direct parsing capabilities and submodules for semantic analysis and token transformation enables robust tooling and compiler development for Fortran.",
      "description_length": 852,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TrunkF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages low-level lexing and token construction for Fortran parsing, working with `Sedlexing.lexbuf`, `Tokens.token`, and `Astloc.t` to support context-sensitive analysis and macro resolution. It handles lexical position tracking, macro visibility, and token context during preprocessing, while child modules extend its capabilities with semantic analysis, AST-to-token translation, and directive processing. The framework supports mixed-source form parsing, location tracking, and preprocessing tasks like macro expansion and directive classification. Example uses include extracting token streams with precise locations, translating AST nodes into source-accurate tokens, and building compiler front-ends with semantic error checking and scope-aware symbol tables.",
      "description_length": 778,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST elements\u2014such as program units, statements, expressions, and type definitions\u2014into corresponding tokens paired with source location metadata, using parsing specifications to ensure structural consistency during translation. It also provides utilities to query and construct preprocessor tokens for directives, include statements, and macro-related nodes, enabling tasks like conditional compilation and macro expansion. These operations facilitate precise preservation of source-level details when transforming ASTs into a token-based representation for analysis, code generation, or refactoring workflows.",
      "description_length": 639,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides error reporting, symbol registration, and scope management utilities for Fortran parsing, operating on AST nodes, lexical positions, scopes, and string identifiers. Key operations include handling parsing errors with positional context, registering functions/modules/common blocks in symbol tables, managing scope transitions (e.g., program/module boundaries), and transforming AST nodes for semantic analysis. It supports use cases like Fortran code parsing, semantic validation of declarations, and attribute manipulation during compilation phases.",
      "description_length": 571,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to convert Fortran AST elements\u2014such as program units, statements, and expressions\u2014into tokens enriched with precise source location metadata, alongside utilities for inspecting scanner tokens to identify preprocessor directives, include statements, and structural properties. It works with Fortran scanner tokens and AST nodes, enabling use cases like context-sensitive token generation during parsing or analyzing preprocessor directives in compiler frontends.",
      "description_length": 494,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes\u2014program units, statements, expressions, and type specifications\u2014into tokens paired with source location metadata, uniformly extracting syntactic elements from partial ASTs using a shared specification. It also analyzes preprocessor tokens to identify directives (e.g., include statements) and measure token size, enabling use cases like source code analysis, preprocessing, and tooling that requires precise token-level insights.",
      "description_length": 468,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module orchestrates incremental Fortran parsing by integrating stepwise construction of AST fragments with mechanisms to control and inspect parser execution. It processes Fortran constructs like program units and expressions through partial parsing functions, while supporting parser state manipulation, error recovery, and grammar analysis via its submodules. The core functionality handles token streams and lexing buffers to build structured syntax elements, enabling use cases such as selective parsing of OpenMP directives or resuming from checkpoints in interactive environments. Together, the combined interface allows precise management of Fortran-specific parsing workflows with support for partial results and structured AST composition.",
      "description_length": 753,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates semantic analysis and symbol registration for Fortran constructs like functions, modules, and derived types, alongside managing scope lifecycle operations for program units and subroutines. It operates on AST nodes, labels, scopes, and OCL directives to",
      "description_length": 277,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST components\u2014such as program units, expressions, and type specifications\u2014into tokens enriched with source location metadata, enabling precise syntactic element extraction. It also includes utilities to analyze tokens, identifying properties like directive categories (e.g., include or preprocessor) and retrieving structural details such as size and positional data. These capabilities support applications like static code analysis, error diagnostics, and transformation workflows in Fortran toolchains.",
      "description_length": 535,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing control by offering tokens to checkpoints, manipulating parser stacks, and resuming parsing with customizable strategies, while also supporting error recovery through lexer conversion and stack inspection. It operates on LR(1) parser environments, symbols, and productions to facilitate syntactic analysis, state transitions, and grammar property checks like nullability and first-set computation. Use cases include implementing parser-driven lexing interfaces, analyzing Fortran grammar structures, and managing complex error recovery scenarios during source code processing.",
      "description_length": 616,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to construct and transform branch nodes in a Fortran abstract syntax tree, mapping context and token tags to structured nodes with location metadata. It supports parsing conditional statements and code blocks while enabling the creation of tagged branch elements. The child module converts ASTs into token sequences with location data, handles preprocessor directives, and extracts token information for analysis. Together, they facilitate precise source-to-token mapping, enabling tools like compilers and static analyzers to process Fortran code with rich structural and positional context.",
      "description_length": 623,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages semantic analysis tasks in Fortran compilation, focusing on parsing error resolution, registration of entities like functions and modules, and enforcing scoping rules through symbol table management. It operates on abstract syntax trees (ASTs), lexical labels, type specifications, and Fortran-specific attributes to handle compiler phases such as scope finalization, label normalization, and OCL directive conversion. Key use cases include resolving symbol visibility in nested scopes, validating Fortran code structure during parsing, and transforming high-level constructs into compiler-internal representations for further analysis.",
      "description_length": 656,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for semantic analysis and error handling during Fortran parsing, focusing on symbol registration, scope management, and AST node manipulation. It works with Fortran-specific data structures like AST nodes, symbol tables, labels, and location metadata to handle declarations, derived types, and language constructs. Key use cases include resolving name bindings, tracking scope transitions (e.g., modules, subroutines), and enforcing semantic rules through attribute checks and error reporting.",
      "description_length": 525,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran syntax incrementally into intermediate AST nodes while handling lexical preprocessing, focusing on constructs like interface specifications, function declarations, and OpenMP/OpenCL directives. It operates on `lexbuf` input using token-driven parsing strategies, producing partial syntax representations suitable for compiler development or source analysis tools. The first child module enables precise control over parsing workflows by managing token consumption, checkpoint resumption, and lexer integration, with utilities to inspect parser states, environments, and LR(1) item transitions for tasks like error recovery and parser debugging. The second child module generates checkpoints for partial parsing states at key syntactic boundaries\u2014such as program units, type declarations, and control structures\u2014supporting resumption, inspection, and error recovery in tools processing incomplete or evolving Fortran code.",
      "description_length": 948,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables partial parsing of Fortran code by converting lexing buffer input into AST fragments for constructs like type declarations, subroutines, and OpenMP directives, supporting incremental workflows for incomplete code. It integrates low-level token and state manipulation with high-level syntactic analysis, allowing resumable parsing tied to source positions using Lexing.position and Menhir checkpoints. Direct operations include parsing Fortran expressions and program units, while submodules enable custom parsing strategies, error recovery, and grammar analysis. Example uses include interactive IDEs for stepwise code analysis and interpreters requiring incremental parsing with position-based resumption.",
      "description_length": 726,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to transform Fortran AST nodes into source-located tokens and analyze token properties. It works with Fortran abstract syntax trees (program units, statements, expressions) and token streams, supporting tasks like directive identification, size calculation, and data extraction from partial ASTs. These capabilities are particularly useful for source-to-source translation, static analysis tools, and precise error reporting that requires mapping between AST elements and their original source positions.",
      "description_length": 536,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to convert Fortran AST nodes\u2014such as program units, statements, expressions, and type specifications\u2014into tokens paired with source locations, enabling precise mapping of abstract syntax to textual representation. It also includes operations to inspect and classify preprocessor tokens (e.g., identifying directives or includes) and utilities for token construction and size analysis, supporting tasks like preprocessing, syntactic validation, and static code analysis.",
      "description_length": 500,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides error reporting, symbol registration, and scope management operations for Fortran abstract syntax trees (ASTs), handling lexical positions, labels, and OCL directive components. It supports parsing and transformation tasks such as registering functions, modules, and derived types, normalizing labels, setting access attributes, and converting unary operations to binary forms. Key use cases include resolving name collisions in common blocks, managing nested scoping constructs (programs, subroutines), and translating OCL directives into typed AST nodes during Fortran code analysis.",
      "description_length": 606,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.BF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source tokens into structured AST nodes, using location data to build intermediate representations for analysis. It supports creating branch tags and assembling nodes from tokens and children, enabling precise reconstruction of program units, statements, and expressions. Child modules handle reverse translation of AST nodes back into tokens, supporting lexical analysis, pretty-printing, and preprocessor directive handling such as include and macro expansion. Examples include building ASTs from token streams, extracting source locations for diagnostics, and manipulating tokens for refactoring or linting.",
      "description_length": 640,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code with tools for detecting source form, generating tokens, and managing lexical state, using `Sedlexing.lexbuf` and `Lexing.position` to track input and support features like Hollerith constants and preprocessor macros. Its first child module converts AST nodes into token-location pairs and analyzes directives, enabling precise code analysis and preprocessing through functions that detect includes and classify directives. The second child module supports semantic operations like error reporting, scope management, and AST transformations, handling Fortran-specific constructs such as derived types and OCL directives during parsing. Together, they enable full-featured Fortran parsing, preprocessing, and transformation with detailed source tracking and semantic analysis.",
      "description_length": 817,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables the construction and transformation of Fortran AST nodes using context and branch tags, with core operations like `tag_to_node` and `make_tag` facilitating precise mapping between lexical tokens and structured AST elements. Its child module extends this by converting AST nodes into lexical tokens with location metadata, supporting queries on token properties and positional attributes. Together, they enable tasks such as source-to-source translation, static analysis, and diagnostic reporting by maintaining accurate connections between parsed Fortran code and its original source representation. Specific examples include reconstructing token streams from AST nodes and annotating Fortran directives with their source locations for analysis tools.",
      "description_length": 771,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles parsing errors, manages symbol tables and scoping for Fortran constructs (functions, modules, derived types), and manipulates AST nodes through transformations and semantic attribute updates. It operates on AST nodes, labels, OCL directives, and lexical data to support parsing, semantic analysis, and error reporting with source location tracking. Key use cases include normalizing labels, enforcing accessibility rules, and converting OCL tuples during Fortran code processing.",
      "description_length": 499,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code through lexical analysis, token handling, and AST construction, integrating parsing, error recovery, and source location tracking. It defines core data types like `token`, `Ast.Partial.t`, and `MenhirInterpreter.checkpoint`, supporting operations for mapping lexical positions to AST nodes, evaluating Fortran syntax conditions, and managing parser checkpoints. With submodules handling incremental parsing, semantic analysis, and token-to-AST conversion, it enables applications such as compiler frontends, static analysis tools, and language servers to process Fortran constructs like control structures, declarations, and directives. Specific uses include building IF block ASTs from tokens, normalizing Fortran labels, recovering from parsing errors stepwise, and extracting preprocessor directives with source metadata.",
      "description_length": 866,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.BranchF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for mapping Fortran abstract syntax tree (AST) nodes to token sequences paired with source location metadata, enabling precise tracking of code structure during parsing. It operates on AST components like program units, statements, and expressions, while also supporting analysis of token properties such as type classification (e.g., include directives, preprocessor tokens) and size computation. These capabilities facilitate tasks like source-to-source translation, semantic analysis, and compiler pipeline stages requiring positional fidelity.",
      "description_length": 578,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source by transforming tokens and analyzing lexical context during parsing, with core operations for node tagging, location tracking, and conditional evaluation tied to control structures and type specifications. It directly supports token manipulation and regex-based pattern matching, while its child modules enable AST-to-token conversion, parsing error handling, incremental source parsing, and control flow AST construction. Users can extract token metadata, resolve symbol scopes, parse Fortran code in stages, and build structured control flow trees annotated with source locations. Specific capabilities include identifying edit descriptors, managing parsing state, transforming AST nodes with contextual data, and integrating preprocessor logic into parsing workflows.",
      "description_length": 807,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.P.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables low-level manipulation of Menhir-based LR(1) parsers through operations that control token ingestion, parser resumption, and checkpoint management. It works directly with parser environments, grammar symbols (terminals and nonterminals), and stack-based representations of parsing states to support tasks like error recovery, incremental parsing, and custom parsing workflows. Key capabilities include analyzing symbol properties (e.g., nullability), inspecting state transitions, and modifying parser stacks to alter control flow during syntactic analysis.",
      "description_length": 577,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran tokens and manages parsing logic for structured constructs such as control flow statements, coordinating with submodules to enable partial parsing, AST construction, semantic analysis, and translation. It provides core operations for token transformation, location tracking, conditional analysis, and pattern matching, working with data types like lexbuf, parser checkpoints, LR(1) states, and AST fragments. Submodules support incremental parsing from arbitrary positions, building structured control flow nodes from tokens, resolving scoping and symbols during semantic analysis, and mapping AST elements to token sequences with location data. Examples include constructing IF and DO loop nodes from token streams, recovering from parsing errors using checkpoints, normalizing labels and directives during semantic processing, and translating AST nodes into token-accurate source representations.",
      "description_length": 928,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis and symbol management capabilities for Fortran parsing, focusing on registering constructs like functions, modules, and derived types with AST nodes while enforcing accessibility rules. It operates on symbol tables with `add`/`find`/`iter` interfaces, lexical position data, and Fortran-specific AST nodes to handle scope transitions (e.g., program/module boundaries), label management, and OCL directive integration. Key use cases include resolving symbol visibility during parsing, transforming unary operations in ASTs, and preparing labeled nodes for downstream analysis or error handling workflows.",
      "description_length": 642,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports semantic analysis and symbol management during Fortran parsing through operations like error handling, scope control, and AST transformation. It works with AST nodes, symbol tables, labels, and lexical positions to manage program unit scoping, OCL directive conversion, and access specification processing. These capabilities enable tasks such as resolving symbol visibility in modules, normalizing labels, and converting unary operations to binary constructs in the AST.",
      "description_length": 492,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module transforms Fortran AST elements into token sequences annotated with source location metadata, using a unified strategy to extract lexical information from constructs like statements and type definitions. It also classifies preprocessor tokens to identify directives (e.g., includes) and evaluate their attributes, operating on parsed token streams. These capabilities enable applications such as source code reconstruction, directive-aware analysis, and position-sensitive transformations in Fortran toolchains.",
      "description_length": 523,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module generates incremental checkpoints to track parsing progress for Fortran source code elements, focusing on partial syntactic constructs like statements, subprograms, and preprocessing directives. It operates on lexical positions and abstract syntax tree (AST) fragments, producing Menhir parser checkpoints that enable resuming parsing after errors or incomplete input. Specific applications include handling Fortran extensions (e.g., OpenMP, Accelerator directives) and recovering structured code elements during incremental analysis.",
      "description_length": 546,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes lexical tokens from Fortran source files into partial ASTs, focusing on preprocessing directives, type declarations, and structured elements like OpenMP/OpenCL. It supports incremental parsing through low-level Menhir operations for token stream manipulation, parser state introspection, and error recovery, enabling dynamic parsing control and custom error handling. The module also provides functions to generate and resume parsing checkpoints, allowing resumable parsing of incomplete constructs such as function headers and expressions. Together, these capabilities facilitate compiler frontends and static analysis tools that require partial parsing of Fortran programs or code fragments.",
      "description_length": 715,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran tokens and analyzes context to determine statement structure, control flow, and declaration semantics, working with token streams and lexical positions to build and manipulate AST nodes. It supports precise parsing of constructs like DO loops and IF statements, with operations for location tracking, token merging, and contextual role identification. Submodules enable AST-to-token conversion with source metadata, partial parsing from lexing buffers, and semantic symbol management for resolving visibility and scope transitions. Examples include reconstructing token streams from AST nodes, incrementally parsing incomplete code in IDEs, and annotating Fortran directives with source locations for diagnostics and transformation tools.",
      "description_length": 768,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.BF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source tokens into structured AST nodes, using context and location data to convert tagged tokens into branch nodes and construct tags from tokens with string values and positions. It supports parsing by building intermediate representations of Fortran code elements such as statements and expressions. The included utilities map AST nodes to annotated token sequences and analyze preprocessor token properties, enabling source location tracking, directive classification, and precise token-AST correspondence. These capabilities support source code transformation pipelines and preprocessor-aware static analysis tools.",
      "description_length": 650,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens.Make.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of terminal symbols used in parsing Fortran code, including language keywords, operators, literals, and compiler directives. It works with `MenhirInterpreter.terminal` values, parameterized by various data types such as strings, units, and AST nodes to represent parsed elements. These terminals are used directly by a Menhir-generated parser to recognize and process Fortran syntax during compilation.",
      "description_length": 442,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code with lexing, parsing, and tokenization, handling features like Hollerith constants, continuation lines, and compiler directives while supporting OpenMP, OpenCL, and preprocessor operations. It transforms source code into annotated tokens with positional context, enabling precise analysis and error reporting, and integrates with child modules for AST-to-token translation, token analysis, and semantic processing such as symbol resolution and scope management. You can use it to build source-aware tools that analyze, transform, or generate Fortran code, including static analyzers that map AST nodes to source locations or preprocessors that expand macros and evaluate conditions. The combination of low-level token handling and high-level semantic analysis supports tasks like code refactoring, translation, and custom compiler extensions.",
      "description_length": 884,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions for semantic analysis and symbol table management during Fortran parsing, focusing on registering language constructs (e.g., modules, subroutines), handling scope transitions, and resolving names. It operates on Fortran AST nodes, labels, OCL directives, and symbol tables to support parsing program units, transforming node structures (e.g., unary-to-binary operations), and assigning semantic attributes like accessibility or type information. Specific use cases include managing nested scoping contexts, normalizing lexical labels, and extracting location or type data during semantic classification.",
      "description_length": 634,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.AccessSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines an enumerated type representing access specifications in Fortran, with values for no specification, private, and public access. It includes functions to convert the type to a string and to check if a value is public or private. This module is used to handle visibility settings of program units or variables during parsing and analysis of Fortran code.",
      "description_length": 372,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.IntentSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing the intent specifications of Fortran variables (`NoIntent`, `In`, `Out`, `Inout`) and provides conversions to string and from intent specification labels. It is used to interpret and represent variable intent metadata during Fortran code analysis.",
      "description_length": 291,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities to translate Fortran abstract syntax tree (AST) nodes\u2014such as program units, statements, and expressions\u2014into lexical tokens paired with source location metadata. It also includes operations to analyze and manipulate these tokens, such as type classification (e.g., directives, includes) and size measurement. These capabilities are particularly useful for tasks requiring precise mapping between AST elements and their textual representation in source code, such as compiler frontends, code transformation tools, or static analysis systems.",
      "description_length": 572,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to map Fortran AST nodes (e.g., program units, expressions, type specifications) to tokens paired with source location metadata, alongside utilities for inspecting and transforming preprocessor tokens. It operates on Fortran AST structures and token streams, enabling tasks like macro expansion, source-to-source translation, and static analysis of preprocessor directives. Key operations include type-specific token construction, directive classification, and partial AST-to-token roundtripping for code generation or refactoring workflows.",
      "description_length": 572,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran tokens and manages parsing logic for structured constructs, converting tags to AST nodes, handling token locations, and evaluating conditions to guide parsing. It supports parsing Fortran statements, managing edit descriptors in data statements, and resolving token context during conditional stages. Submodules enable incremental parsing with AST fragment construction, parser state control, and error recovery, while others handle branch node creation, semantic analysis, symbol registration, and conversion of AST nodes back to tokens with source locations. Specific use cases include selective parsing of OpenMP directives, source-to-token mapping for compilers, semantic rule enforcement, and preprocessing or syntactic validation of Fortran code.",
      "description_length": 782,
      "index": 96,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code with lexing, tokenization, and preprocessing features, handling source form detection, continuation lines, and directives like OpenMP and preprocessor macros. It works with `Sedlexing.lexbuf` buffers and tracks positional metadata, supporting Fortran-specific elements such as Hollerith constants, labels, and conditional compilation. The first child module translates AST nodes into tokens with location data and allows querying token properties, enabling parsing, pretty-printing, and semantic analysis of statements and expressions. The second child module manages parsing errors with positional context, symbol registration for functions and modules, and scope transitions, supporting semantic validation and AST transformation during compilation.",
      "description_length": 793,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.A",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides semantic analysis and transformation operations for Fortran code, focusing on error handling, scope management, and registration of language constructs like subroutines, modules, and derived types. It works with abstract syntax trees (ASTs), symbol tables, lexical scopes, labels, and OCL directive data structures to support tasks like name resolution, attribute binding, and code normalization. Key use cases include parsing Fortran program units, analyzing structured code elements (e.g., execution vs. specification parts), and transforming AST nodes for downstream compilation or analysis tools.",
      "description_length": 621,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.U",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code through lexing, tokenization, and preprocessing, handling both free and fixed-form syntax while tracking source positions and lexical states. It operates on `Sedlexing.lexbuf` and `qtoken` values, supporting Hollerith literals, preprocessor directives, and conditional compilation. The child module transforms AST nodes into location-annotated tokens and analyzes preprocessor input to extract directives and measure token structure. Together, they enable precise source analysis, code transformation, and tooling around Fortran syntax and compiler directives.",
      "description_length": 602,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module parses Fortran source code incrementally, converting `lexbuf` input into partial AST fragments and handling complex syntactic elements like statements, expressions, and OpenMP/OpenCL directives. It supports direct operations on parser environments and lexical buffers, enabling custom parsing strategies, error recovery, and grammar analysis through LR(1) symbols and productions. Child modules refine this capability by managing parser checkpoints and resuming analysis after errors or incomplete input, particularly for Fortran extensions and structured constructs such as subroutines and type definitions. Examples include recovering partial ASTs after syntax errors, parsing OpenMP directives in streaming input, and building program units incrementally from token streams.",
      "description_length": 789,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Dimension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different dimension kinds in Fortran array declarations, such as explicit, assumed, and deferred shapes. It includes functions to convert dimension types to strings, retrieve their rank, and construct them from labels or explicit shape values. Concrete use cases include parsing Fortran array declarations and determining array dimension properties during semantic analysis.",
      "description_length": 422,
      "index": 101,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages parsing errors and symbol registration for Fortran language constructs, handling variables, functions, subroutines, modules, and derived types through AST node manipulation and symbol table updates. It operates on data structures like labels, lexical positions, and Fortran-specific types to facilitate scope management, name resolution, and attribute assignment during parsing. Key use cases include processing program structure definitions, normalizing labels, and ensuring accurate source location tracking for Fortran code analysis and compilation.",
      "description_length": 572,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser.Make.Incremental",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables incremental parsing of Fortran source code by providing functions that generate partial abstract syntax trees (ASTs) and Menhir checkpoints from specified lexical positions. It processes Fortran constructs like program units, type declarations, subroutine heads, and OpenMP/OpenCL directives, producing intermediate results such as `Ast.node` fragments or unit checkpoints to support piecemeal parsing of large or fragmented codebases. The design allows resumable parsing workflows, where partial ASTs (`Fortran_parsing.Ast.Partial.t`) are built incrementally while maintaining context through checkpoint-driven state transitions.",
      "description_length": 650,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.ImplicitSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "Converts a label into an optional range of characters representing a letter-based implicit type specification. Works with labels and character pairs to define type ranges. Useful for parsing Fortran code where implicit typing is specified by letter ranges in labels.",
      "description_length": 266,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts Fortran AST nodes into token-located pairs and extracts location information from nested data structures. It also supports querying token attributes, classifying token types, and building tokens from partial AST nodes, aiding in parsing, syntax analysis, and compiler-related tools such as error recovery and incremental processing.",
      "description_length": 353,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Trunk.F.TBF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module orchestrates token transformation and context analysis during Fortran parsing, specializing in statement structure and lexical disambiguation. It directly supports node tagging, location tracking, and conditional token evaluation, enabling precise handling of control structures like DO and IF, edit descriptors in data statements, and resolution of variable/type name ambiguities. Its child modules extend this by transforming AST nodes into tokens with source metadata, managing semantic analysis tasks like symbol resolution and scoping, and enabling incremental parsing with checkpointing and error recovery. Together, they provide a complete pipeline for parsing, transforming, and analyzing Fortran code with high fidelity for compiler and diagnostic tool development.",
      "description_length": 786,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to classify, decompose, and construct Fortran symbol declarations (e.g., variables, procedures, modules, derived types) while managing attributes like accessibility, binding, and location metadata. It operates on structured representations of declarations (`Name.Spec.t`) to enable semantic analysis, scoping resolution, and context-sensitive parsing of Fortran code. Key use cases include extracting declaration properties, enforcing language semantics during parsing, and handling complex entity relationships in modular or typed Fortran programs.",
      "description_length": 581,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.BranchF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran branching constructs into structured AST nodes, converting tagged contexts and tokens into nodes with source location tracking. It supports building control flow structures during parsing, such as if-then-else and do loops, while enabling precise mapping between AST elements and their original token sequences. The child module enhances this by allowing analysis of token properties, source location metadata association, and transformation tasks like rewriting or semantic inspection. Together, they enable robust parsing, transformation, and analysis of Fortran code with positional accuracy.",
      "description_length": 625,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.T",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module performs low-level lexical analysis of Fortran code, handling token creation, macro resolution, and context-sensitive behavior using `Sedlexing.lexbuf` and `qtoken` structures. It supports preprocessing directives, composite token recognition, and source form detection, with core operations for macro management, Hollerith constants, and OpenMP clause parsing. Child modules extend its functionality to semantic analysis, AST transformation, error handling, and source tracking, enabling tasks like symbol registration, label normalization, and directive conversion. Specific applications include parsing conditional compilation blocks, resolving include files, and generating annotated tokens for compiler front-ends.",
      "description_length": 731,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.ScopingUnit",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing different scoping units in Fortran, such as programs, modules, functions, and derived type definitions. It provides constructors like `mkmodule` and `mkderivedtypedef` to create specific scoping unit instances, along with `to_string` for string representation and `copy` for duplicating values. It is used to model Fortran program structure during parsing and analysis, enabling precise tracking of scope boundaries and nesting.",
      "description_length": 480,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg.F.Aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module facilitates semantic analysis and binding during Fortran parsing by providing operations to register language entities (e.g., functions, modules), manage scope lifecycles, and validate syntactic constructs. It operates on AST nodes, labels, OCL directives, and specification objects to handle tasks like error reporting, label normalization, node transformation, and attribute manipulation, ensuring proper semantic linkage and syntactic correctness during parsing.",
      "description_length": 477,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name.Codimension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines types and conversions for codimension attributes in Fortran variable declarations. It supports parsing and representing codimension information as either no codimension, explicit coshape, or deferred coshape. The module converts label values into codimension types and renders them as strings for diagnostic or output purposes.",
      "description_length": 347,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F.PP",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module orchestrates lexical analysis, parsing, and semantic processing for Fortran source code, integrating lexing buffers, token streams, and ASTs with precise source location tracking. It supports operations like macro expansion, directive handling, and branch tagging, using data types such as `token`, `Astloc.t`, and `MenhirInterpreter.checkpoint` to enable accurate source mapping and error recovery. With submodules focused on AST construction, semantic validation, and preprocessing, it facilitates tasks like building IF block nodes from tokens, resolving nested scopes, and translating AST elements back into source-accurate token sequences. Specific applications include developing Fortran compiler frontends, static analysis tools, and refactoring utilities that require fine-grained control over parsing and transformation workflows.",
      "description_length": 851,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.P",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code incrementally, generating AST nodes from lexbuf streams using a custom token type to handle constructs like program units, type declarations, and OpenMP directives. It supports piecemeal parsing of subroutines and specification parts, enabling front-end tasks such as selective code analysis and preprocessing. The companion module provides low-level control over Menhir LR(1) parsers, allowing manipulation of parsing states, error recovery, and custom workflows through direct access to grammar symbols and parser stacks. Together, they enable fine-grained parsing and transformation of Fortran programs, from token-level operations to structured AST construction.",
      "description_length": 708,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser.Make.MenhirInterpreter",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements low-level parsing operations for incremental Fortran analysis, handling token stream processing, checkpoint manipulation, and stack-based state transitions to support complex constructs like program units and expressions. It operates on parser environments, nonterminal hierarchies, and production rules, enabling error recovery, grammar property analysis (nullable symbols, first sets), and adaptive strategy selection (Legacy/Simplified), while providing precise control over reductions and lookahead for robust",
      "description_length": 536,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for converting Fortran AST nodes into token-location pairs and analyzing token properties, working with AST nodes, tokens, and location data. It supports parsing workflows by handling preprocessor directives, token size calculations, and AST-to-token transformations, particularly useful for Fortran code preprocessing and structured token stream generation. Specific functions identify directives (e.g., `is_include`), construct tokens from AST fragments, and map AST elements to their lexical representations.",
      "description_length": 543,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F.TrunkF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code from low-level token manipulation to high-level semantic analysis, integrating lexing, parsing, and transformation stages. It defines core data types such as `lexbuf`, tokens, AST nodes, and scopes, with operations for macro resolution, context-sensitive parsing, symbol registration, and source reconstruction. Functionality includes detecting source form, generating structured control flow nodes from tokens, resolving macro visibility, and mapping AST elements back to token sequences with precise position tracking. Specific applications range from preprocessing and error recovery using parser checkpoints to directive classification and semantic transformations preserving source layout.",
      "description_length": 736,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch.F.TokenF",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for converting Fortran AST nodes into location-annotated tokens and analyzing token properties. It operates on Fortran abstract syntax trees and token sequences to extract syntactic elements, classify token types (e.g., directives, statements), and measure structural characteristics. Typical applications include source code analysis, preprocessing, and generating precise location-aware representations of Fortran programs from partial AST fragments.",
      "description_length": 483,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_dec.Directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran compiler directives and associated operations. It provides functions to convert directives to strings, extract names, and determine contextual usage in specification or execution parts of code. Use cases include parsing and manipulating Fortran source files to apply or analyze compiler-specific annotations and control structures.",
      "description_length": 387,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.ProcInterface",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing different kinds of procedure interfaces in Fortran, including unknown, named interfaces, and type-based declarations. It provides functions to convert values to strings, extract names, construct from labels, and check if a value is a named interface. It is used to distinguish and handle procedure interface information during Fortran code analysis.",
      "description_length": 393,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_xlf.Assertion",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type `t` representing specific assertion kinds related to Fortran XL Fortran extensions, such as iteration count constraints and dependency checks. It provides functions to convert these assertions to string representations and structured tags with associated data. These operations support parsing and analyzing Fortran code that uses XL-specific directives.",
      "description_length": 389,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec.Attribute",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran attribute specifiers, such as `Allocatable`, `Inline`, or `Dllimport`, and provides functions to convert attributes to strings, extract associated names, and construct attributes from keywords. It works directly with `Label_common.name` and string identifiers, supporting precise parsing and manipulation of Fortran declarations. Concrete use cases include attribute normalization in Fortran AST processing and mapping compiler directives to internal representations.",
      "description_length": 523,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Common.LangSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different Fortran language standards, including F77, F90, F95, F2003, and F2008. It provides a function to convert these variants to their corresponding string representations. This is used to identify and handle Fortran source code versions during parsing.",
      "description_length": 305,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ast.Partial",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module supports structured creation, modification, and traversal of Fortran abstract syntax tree (AST) nodes with embedded metadata tracking. It centers on a recursive algebraic type representing program units, statements, and expressions, each annotated with positional metadata via a `spec` type capturing length and tag information. Key operations enable constructing typed AST elements (e.g., declarations, variables, blocks), extracting child nodes for analysis, and incrementally building partial ASTs during parsing or transformation workflows.",
      "description_length": 556,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements a lexer for Fortran code, defining buffer structures and tokenization logic to process character streams into lexical tokens. It integrates preprocessing, source form detection, and macro resolution with semantic analysis, AST construction, and error handling through its submodules. Core data types include `token`, `Sedlexing.lexbuf`, `Astloc.t`, and `qtoken`, supporting operations like token merging, location tracking, symbol registration, and scope management. You can use it to parse Fortran source files into tokens for compiler frontends, reconstruct token streams from AST nodes, perform incremental parsing in IDEs, or annotate directives with source metadata for diagnostics and transformations.",
      "description_length": 730,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec.Clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing clauses used in Fortran directive parsing, such as alignment, privatization, and vectorization options. It provides functions to convert clause values to string representations, extract structured tags with attributes, and anonymize clause data. These operations support analysis and transformation of Fortran code involving parallelism and optimization directives.",
      "description_length": 413,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Token.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to translate Fortran AST nodes (e.g., statements, expressions, program units) into tokens annotated with source locations, while supporting context-aware partial specification mapping. It includes utilities to inspect token properties (e.g., directive types, inclusion markers) and measure token size, operating on Fortran abstract syntax trees and token streams. These capabilities are used for parsing, preprocessing, and source location tracking in Fortran code analysis.",
      "description_length": 506,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokens.Make",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines the lexical tokens and terminal symbols used in parsing Fortran code, combining core token types with specialized constructs like compiler directives, control structures, and preprocessor elements. It supports operations for recognizing keywords, operators, literals, and AST nodes, using types such as strings and units to represent parsed components. The module enables tokenization of Fortran source files, integration with Menhir for parser generation, and precise handling of OpenMP and OpenCL directives during compilation. Together with its submodules, it provides a structured representation of lexical elements that directly drives syntactic analysis and transformation of Fortran programs.",
      "description_length": 719,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokens_.T",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a rich set of lexical tokens for parsing Fortran code, capturing language constructs such as compiler directives, control structures, and data types. It uses abstract syntax tree nodes and string-labeled variants to represent parsed elements and associated metadata. These tokens serve as the foundation for building structured program representations during compilation. While it includes a placeholder child module, the core functionality centers on token definition and AST integration.",
      "description_length": 509,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.LangConfig",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines default maximum line lengths for fixed and free Fortran source code formats. It provides integer values for `default_max_line_length_fixed` and `default_max_line_length_free`, which are used to enforce line length limits during parsing. These constants ensure correct interpretation of legacy Fortran code based on its format type.",
      "description_length": 351,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.LangExtension",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of supported Fortran language extensions as a variant type, including vendors like IBM, Intel, and PGI. It provides a direct mapping from these extension tags to their string representations. Use this module when identifying or handling vendor-specific Fortran syntax during parsing or analysis.",
      "description_length": 321,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code through lexing, preprocessing, and structured parsing, converting raw source lines into annotated token streams and AST nodes. It defines core types like `lexbuf`, `qtoken`, and branch tags, with operations to merge source locations, resolve conditional branches, and map between tokens and AST elements. Using its submodules, it supports macro expansion, selective parsing of OpenMP directives, source-to-source translation, and semantic analysis with scope management and symbol registration. Examples include constructing location-aware AST fragments, classifying preprocessor directives, and recovering from parsing errors while preserving source structure.",
      "description_length": 703,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo.TypeSpec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type for representing Fortran type specifiers, including built-in types like `Integer`, `Real`, and `Complex`, as well as derived and parameterized types. It provides functions to convert type specs to strings, extract names, resolve from labels, and check if a type is fully resolved. Use cases include parsing and analyzing Fortran declarations where precise type information is needed for semantic checks or code generation.",
      "description_length": 457,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code with lexing and parsing operations that handle identifiers, string literals, Hollerith constants, and preprocessor directives, supporting context-sensitive parsing through lexical buffers and stateful structures. It enables precise source position tracking and macro expansion, accommodating Fortran's fixed and free source forms along with vendor-specific extensions. The child modules extend this functionality by translating AST nodes into location-annotated tokens and managing parsing errors alongside symbol registration for variables, functions, and modules. Together, they support compiler frontends, static analysis tools, and code transformation utilities by providing structured access to lexical elements, symbol tables, and source-level metadata.",
      "description_length": 801,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Rank",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of values and operations to represent and manipulate array rank information in Fortran code analysis. It includes functions to construct rank values from integers, check if a rank is zero or non-zero, and convert rank values to strings. It is used to track the dimensionality of arrays during parsing and semantic analysis, such as distinguishing between scalar, unknown, and explicitly dimensioned arrays.",
      "description_length": 432,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by transforming tokens into structured AST nodes while maintaining lexical positions and context-sensitive parsing logic. It includes operations for token filtering, location merging, and conditional analysis, which are essential for lexical and syntactic processing in Fortran compilers. Child modules extend this functionality by enabling incremental parsing, error recovery, and structured control flow construction, supporting tasks like parsing OpenMP directives and building program units from token streams. Additional submodules refine AST-to-token conversion, directive analysis, and source location tracking, enabling precise transformations and semantic inspection of Fortran code.",
      "description_length": 734,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser.Make",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module orchestrates partial and incremental parsing of Fortran source code, combining core functions for token stream processing with specialized support for OpenMP, OpenCL, and accelerator directives. It generates AST fragments and Menhir checkpoints that enable piecemeal parsing of constructs like statements, expressions, and program units, while allowing resumable workflows through state transitions and context preservation. The child modules extend this by implementing low-level parsing operations, error recovery, and grammar analysis, supporting precise control over reductions and lookahead. Together, they facilitate applications such as source transformation, IDE integration, and static analysis by enabling structured composition of partial ASTs (`Ast.node`, `Fortran_parsing.Ast.Partial.t) from arbitrary lexical positions.",
      "description_length": 845,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser_aux.LineStat",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of line status classifications for Fortran source lines, including whether a line is blank, a pure comment, a mixed comment, non-blank, or continued. It provides functions to convert these classifications to strings and to check specific line properties such as whether a line is a pure comment, assumed blank, or continued. These classifications are used to accurately parse and process Fortran code based on line structure and content.",
      "description_length": 463,
      "index": 138,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Fortran_parsing.Common.SourceForm",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines an enumerated type representing the source form of Fortran code, including fixed, free, mixed, and unknown formats. It provides a function to convert these source form values to their corresponding string representations. This is used to determine and display the format of Fortran source files during parsing or preprocessing.",
      "description_length": 347,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_xlf.Directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines data types and operations for handling Fortran compiler directives, specifically for IBM's XLF compiler. It supports parsing and manipulating directive types such as loop control, optimization settings, and source form specifications, with functions to convert these directives to strings, extract metadata, and anonymize them. Use cases include preprocessing Fortran code for analysis, transformation, or integration with compiler toolchains.",
      "description_length": 463,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Trunk.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages low-level token generation and macro resolution for Fortran parsing, working directly with lexer buffers and token streams to construct end-of-file, end-of-line, and termination tokens. It enables context-sensitive name resolution, conditional macro expansion, and preprocessing of Fortran source files, forming the foundation for building structured token sequences used in parser input. Submodules handle lexing, parsing, and token annotation with positional context, supporting advanced use cases like static analysis, code refactoring, and macro expansion with precise source mapping. Additional components convert AST nodes to tokens, extract location data, and manage semantic processing such as symbol resolution and scope tracking, enabling robust tooling for Fortran code transformation and diagnostics.",
      "description_length": 832,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser_aux.STATE_T",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents the state of a Fortran parser, tracking the current environment and context stack during parsing. It supports operations that manipulate and query the parser's state, such as updating the environment or inspecting the context hierarchy. It is used internally during Fortran source analysis to maintain parsing context and resolve language-specific ambiguities.",
      "description_length": 383,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser_aux.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for semantic analysis and symbol registration during Fortran parsing, including error handling, scope lifecycle management, and AST manipulation. It works with AST nodes, symbol tables, name bindings, and OCL tuples to resolve declarations, enforce accessibility rules, and manage scopes for constructs like modules and subroutines. Utilities for string processing, directive conversion, and lexical positioning further support parsing tasks such as error recovery and semantic consistency checks.",
      "description_length": 529,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Pinfo.Name",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran name specifications by resolving attributes like intent, access, and dimensionality through structured types such as `Spec.t` and `Fortran_parsing.Common.name`. It organizes scoping units for variables, derived types, and procedures, enabling name resolution, dimension-aware declarations, and integration of vendor-specific functions. Submodules define core attributes including access control (`Public`, `Private`), intent (`In`, `Out`, `Inout`), and dimension kinds for arrays, while utilities handle implicit typing ranges, codimensions, and scoping constructs like modules and derived types. Examples include parsing array declarations with explicit or deferred shapes, determining variable visibility in modules, and constructing scoped program units with typed metadata.",
      "description_length": 807,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module builds and transforms AST nodes for Fortran branching logic, using tokens and location data to construct tagged node structures. It converts parsed tokens into structured branch nodes and assembles AST fragments, while its child module analyzes token properties, classifies token types, and generates location-annotated tokens from AST nodes. Together, they enable precise manipulation and representation of Fortran syntax, supporting tasks like source analysis, preprocessing, and AST reconstruction. Key data types include tokens, nodes, and location-annotated structures, with operations for transformation, classification, and assembly.",
      "description_length": 652,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common.DirectiveLine",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and constructs directive lines in Fortran code, specifically handling different directive types like OpenMP, OpenACC, and compiler-specific pragmas. It works with a tagged union type identifying directive origins and a structured type capturing the directive's components, including the directive head, full line, token queue, and continuation flags. Concrete use cases include parsing and reconstructing Fortran directive lines with support for different syntax conventions and continuation handling.",
      "description_length": 524,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg.F",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module disambiguates Fortran abstract syntax trees by transforming node labels, bindings, and structure based on annotated metadata, clarifying semantic intent in constructs like array references and procedure calls. It provides direct operations for relabeling, rewriting child lists, and propagating bindings, while its child module supports semantic analysis through entity registration, scope management, and syntactic validation. Examples include resolving name collisions in nested scopes, inferring missing context during finalization, and restructuring ambiguous grammar productions into coherent semantic forms. Together, they enable precise manipulation and validation of Fortran ASTs during parsing and transformation.",
      "description_length": 734,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_wait_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different wait specifications in Fortran, such as end-of-record (Eor), end-of-file (End), and error (Err), each optionally carrying a label. It provides operations to convert these specifications to strings, extract labels, and anonymize them by removing label information. These functions are used when processing Fortran control statements that involve labeled branches or status checks.",
      "description_length": 437,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenbuffer",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran source code by accumulating tokens and managing partial parser states, using regex to match numeric exponents and determine parse completeness. It transforms token streams into structured AST nodes, supporting lexical position tracking, token filtering, and context-sensitive parsing logic. Incremental parsing and error recovery enable robust handling of incomplete or malformed input, while submodules refine AST construction, directive analysis, and source location tracking. Examples include parsing OpenMP directives, merging token locations, and building program units from token streams.",
      "description_length": 624,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_access_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates access specifiers (`Private` and `Public`) in Fortran code. It provides conversions to string representations, attribute specifications, and tagged forms, enabling precise handling of visibility in parsing and code generation. Use cases include translating access modifiers in Fortran declarations to other syntax forms or output formats.",
      "description_length": 374,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_ocl_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module encodes and processes OpenCL pragma-like directives embedded in Fortran code, focusing on loop transformations, memory optimizations, and parallelism annotations. It operates on a tagged union type `t` that captures structured metadata (names, integers, options) and tuples containing numeric/name expressions, with utilities to convert these representations to strings, extract identifiers, or transform numeric components. Typical applications include analyzing directive parameters for compiler passes, generating optimized code regions, or refactoring legacy Fortran with OpenCL hints.",
      "description_length": 601,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Tokens",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines the lexical tokens and terminal symbols used in parsing Fortran code, including keywords, operators, literals, and specialized constructs like compiler directives and control structures. It provides types and operations for tokenizing Fortran source files and integrates with Menhir to enable parser generation and AST node recognition. The module supports precise handling of OpenMP and OpenCL directives, allowing transformations and syntactic analysis of Fortran programs based on structured lexical representations. Example uses include parsing Fortran code into tokens, identifying control structures during compilation, and processing preprocessor directives.",
      "description_length": 685,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokens_",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a comprehensive set of lexical tokens for parsing Fortran code, representing constructs like compiler directives, control structures, and data types using string-labeled variants and AST nodes. It directly supports the construction of abstract syntax trees from Fortran source, accommodating both legacy and modern dialects while integrating specialized structures for OpenMP and OpenACC pragmas. The child module extends this foundation with additional token variants and metadata handling, enhancing representation of parsed elements. Examples include modeling loops, conditionals, and parallel regions as structured tokens that feed directly into the parser's AST generation.",
      "description_length": 698,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_omp_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates OpenMP directive types used in Fortran parsing, including atomic operations, parallel constructs, and synchronization primitives. It provides functions to convert these directives to string representations, extract names, and determine contextual usage in specification or execution parts of code. Concrete use cases include parsing OpenMP annotations, generating diagnostic messages, and transforming directives during code analysis or rewriting.",
      "description_length": 483,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Lib",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a function `mkparser` that adapts traditional Menhir parsers to handle revised input formats with position tracking, and exposes a predefined macro table `predefined_macrotbl` for Fortran parsing. It works with parser types involving token streams and macro definitions, specifically targeting Fortran syntax processing. Use cases include building custom Fortran parsers with precise source location tracking and expanding macros during parsing.",
      "description_length": 466,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Parser",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module enables partial and incremental parsing of Fortran code, supporting structured construction of AST fragments from arbitrary lexical positions. It provides core types like `Ast.node` and `Fortran_parsing.Ast.Partial.t`, along with operations for token stream processing, error recovery, and checkpoint-based parsing workflows. You can use it to parse individual statements, resume parsing from intermediate states, or integrate Fortran analysis into tools like IDEs and source transformers. Specific capabilities include handling OpenMP directives, managing lookahead, and composing partial program units into larger ASTs.",
      "description_length": 633,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_intrinsic_operator",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing intrinsic operators in Fortran, such as logical, relational, arithmetic, and string operations. It provides functions to convert these operators to string representations and tagged forms for further processing. Use cases include parsing Fortran source code and generating intermediate representations for compiler analysis or transformation tasks.",
      "description_length": 396,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_pp_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides tools for analyzing and transforming Fortran preprocessor logic, handling conditional compilation branches, directive metadata, and diagnostic messages. It operates on structured representations of preprocessor elements like `If`/`Else` blocks, `Define` statements, and `Include` directives, enabling introspection through name extraction, part classification, and string serialization. Typical applications include code analysis, macro expansion, conditional block simplification, and anonymizing identifiers in preprocessor constructs for further processing or obfuscation.",
      "description_length": 596,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ulexer",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module implements lexical analysis for Fortran source code using character classification and state transitions generated by Sedlex, processing input through precomputed lookup tables and partition functions to recognize syntax elements like keywords, operators, and literals. It supports identifiers, string literals, Hollerith constants, and preprocessor directives, with stateful structures for context-sensitive parsing and precise source position tracking. The module handles fixed and free source forms, Unicode-aware character classification, and macro expansion, enabling compiler front-ends and static analysis tools to extract structured lexical data, manage parsing errors, and register symbols such as variables and functions. Specific operations include tokenizing Fortran input, translating AST nodes into annotated tokens, and supporting vendor-specific extensions through modular extensions.",
      "description_length": 912,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_proc_component_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran procedure component attribute specifications, such as `Pointer`, `Pass`, `Private`, and `Public`. It provides operations to convert these attributes to strings, extract names, and anonymize them, supporting tasks like code analysis and transformation. Use cases include parsing Fortran source files and generating intermediate representations for compilers or linters.",
      "description_length": 424,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Keyword",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module maps specific Fortran keyword strings to their corresponding token representations, handling various context-sensitive keyword sets used in Fortran syntax. It processes string inputs and returns tokens for precise language constructs such as I/O control, inquire, connect, and flush specifications. These functions are used during parsing to identify and categorize Fortran keywords in different syntactic contexts.",
      "description_length": 427,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Macro",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations for handling Fortran macro definitions, including managing unresolved/resolved states and conditional compilation flags. It supports constructing, resolving, and converting macro components while tracking source locations, working with macro bodies, strings, and location data. These capabilities are particularly useful for preprocessing Fortran code that involves conditional compilation directives or macro expansions requiring precise resolution and state management.",
      "description_length": 503,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_position_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different position specifications in Fortran, such as `Err`, `Iomsg`, `Iostat`, and `Unit`. It provides functions to convert these specifications to strings, extract labels, and transform them into related specification types like `F_inquire_spec` or `F_close_spec`. These operations support precise handling of Fortran I/O statements during parsing and analysis.",
      "description_length": 411,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_proc_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates procedure attribute specifications in Fortran, supporting operations like converting attributes to strings, extracting tags with associated data, and anonymizing values. It works with a variant type representing attributes such as `Public`, `Private`, `Intent`, and `Weird`, along with associated name labels. Concrete use cases include parsing and transforming Fortran procedure declarations, handling attribute annotations during code analysis, and generating string representations for debugging or output.",
      "description_length": 545,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_generic_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines data types and operations for handling generic specification records in Fortran parsing, including formatted, unformatted, and custom record kinds. It supports conversion between record kinds and strings, extraction of names from generic specifications, and anonymization of specification values. Concrete use cases include processing Fortran I/O statements and managing operator and assignment specifications during semantic analysis.",
      "description_length": 455,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Scanner",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a lexer for Fortran code that processes character streams into lexical tokens, integrating preprocessing, source form detection, and macro resolution. It supports token merging, location tracking, symbol registration, and scope management through key data types like `token`, `Sedlexing.lexbuf`, `Astloc.t`, and `qtoken`. You can use it to parse Fortran source files for compiler frontends, reconstruct token streams from AST nodes, enable incremental parsing in IDEs, or annotate directives with source metadata for diagnostics and transformations.",
      "description_length": 570,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Elaborate",
      "library": "diffast-langs-fortran-parsing",
      "description": "The `copy_stack` function duplicates a stack containing tuples of arbitrary types, including a reference, preserving the structure and contents. It operates on standard library stacks with elements of type `('a * 'b * 'c ref * 'd)`. This function is useful when maintaining independent copies of parsing state stacks during Fortran code transformation or analysis.",
      "description_length": 364,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Pinfo",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran declarations by unifying variable and procedure metadata into a structured form, centered around a discriminated union type `t` that captures single names, name lists, and external declarations. It supports operations to build and extract name specifications, resolve type and interface information, and manage dimensionality through integrated submodules for rank, type specifiers, and procedure interfaces. For example, it can parse a declaration with multiple possible bindings, determine if a procedure uses a named interface, or extract the rank of an array from its declaration. The module also handles attribute resolution\u2014such as intent, access, and scoping\u2014enabling semantic analysis tasks like resolving external references or collecting typed metadata in program units.",
      "description_length": 827,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_omp_clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This component provides operations for modeling and transforming OpenMP directive clauses in Fortran, including typed representations of data sharing modes, scheduling strategies, and memory mappings with bidirectional string conversions. It supports semantic analysis through structured tagging of clause elements and enables safe code generation via identifier anonymization in abstract syntax trees. These capabilities are critical for compiler passes that require precise clause semantics, such as parallelism optimization and cross-language translation.",
      "description_length": 558,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Disambg",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes Fortran abstract syntax trees by resolving ambiguities in semantic constructs through metadata-driven transformations. It supports relabeling nodes, rewriting child structures, and propagating bindings to clarify array references, procedure calls, and scope relationships. Operations include resolving name collisions, inferring missing context, and restructuring ambiguous grammar productions. Example uses include disambiguating nested variable references, validating syntactic constructs, and finalizing AST nodes with inferred semantic information.",
      "description_length": 574,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Trunk",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles low-level Fortran parsing by converting string inputs into structured token sequences and basic syntax trees, focusing on program units, declarations, and macro resolution. It provides data types such as tokens, AST nodes, and symbol tables, along with operations for lexing, preprocessing, and context-sensitive parsing. Users can extract subroutine definitions, expand macros with source mapping, or perform static analysis using annotated token streams and semantic scope tracking. Submodules support advanced tasks like token-to-AST conversion, location extraction, and code refactoring with precise positional context.",
      "description_length": 643,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_control_edit_desc",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type for representing Fortran control edit descriptors, including operations for positioning, scaling, sign handling, and record termination. It provides functions to convert these descriptors to strings, simplified strings, and tagged representations with attributes, along with an anonymization function. It is used for parsing and manipulating Fortran format specifications in a structured way.",
      "description_length": 427,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_directive",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates directive types used in parsing Fortran accelerator constructs. It includes operations for converting directive variants to strings, extracting names, checking structural placement (specification or execution part), and anonymizing directives. The primary data types are `atomic_sub` and `t`, representing atomic operations and OpenACC directives with optional names and attributes. Use cases include processing and analyzing Fortran source code with GPU or accelerator directives.",
      "description_length": 517,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Printer",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module converts structured Fortran abstract syntax trees to human-readable strings. It provides functions to generate string representations of tree nodes, including full dumps to standard output. Useful for debugging Fortran AST structures or generating source code from parsed representations.",
      "description_length": 300,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_inquire_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran `INQUIRE` specifier keywords and associated values. It provides operations to convert specifiers to strings, extract labels, and parse from keywords, handling labeled and unlabeled cases. Use cases include parsing and manipulating Fortran `INQUIRE` statements in a compiler or analysis tool.",
      "description_length": 347,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_dec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module organizes declaration-related transformations across multiple dimensions: levels, directives, clauses, and attributes. It provides core operations to convert structured data like integer pairs and lists into string representations, anonymize declaration elements, and manage metadata during compilation or analysis. The associated directive module handles Fortran-specific compiler annotations, including contextual usage and string extraction, while the attribute module supports parsing and normalization of specifiers like `Allocatable` or `Inline`. Clause constructs further extend this system with support for structured tags and optimization metadata, enabling precise manipulation of parallelism and vectorization directives in Fortran code.",
      "description_length": 760,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_connect_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran connection specifications, such as file access modes, unit identifiers, and error labels. It provides functions to convert these specifications to strings, extract labels, map them to inquire specifications, and anonymize them. Use cases include parsing and manipulating Fortran OPEN and INQUIRE statements, handling file I/O options, and processing labeled error targets in Fortran code.",
      "description_length": 444,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_format_item",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates Fortran format specification items, including data edits, control descriptors, character strings, and special symbols like `$` or `\\`. It provides functions to convert these items to strings, simplify them, and anonymize variables. Use cases include parsing and pretty-printing Fortran format statements during compiler or analysis tool development.",
      "description_length": 385,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_header_file",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran header file entries with variants for user, system, macro, and generated files. It provides operations to construct, deconstruct, and transform these entries, including extracting names, attributes, and string representations. Concrete use cases include parsing Fortran include directives, managing macro expansions, and generating file metadata for compilation pipelines.",
      "description_length": 419,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Label",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides operations to construct, transform, and analyze syntactic and semantic elements in Fortran code, with a focus on handling ambiguous or dialect-specific constructs. It works primarily with a polymorphic sum type that encapsulates program structure, control flow, declarations, expressions, and vendor extensions like OpenMP or OpenACC directives. Specific use cases include parsing Fortran with compiler-specific syntax, identifying statement roles (e.g., loop headers, conditionals), validating structural consistency in control constructs, and extracting metadata like variable names or subprogram attributes for analysis or transformation pipelines.",
      "description_length": 672,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_clause",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing OpenACC clause keywords used in Fortran parsing, such as `Async`, `Copy`, `Device`, and `Reduction`. It provides functions to convert these clauses to string representations, extract structured tags, and anonymize clause values. Use cases include processing and transforming OpenACC directives during static analysis or code generation in Fortran compilers or tools.",
      "description_length": 414,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_linda_call",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different modes of Linda calls in Fortran code, such as `In`, `Out`, and `Eval`. It provides functions to convert these modes to string representations and to extract their tags along with associated data. These operations support parsing and processing Linda synchronization primitives in Fortran source code.",
      "description_length": 358,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_format",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing different Fortran format specifiers, including expressions, labeled formats, and list-directed input/output. It provides functions to convert these formats to strings, extract labels, and anonymize labeled formats. Use cases include parsing and manipulating Fortran format statements while preserving or transforming their structure.",
      "description_length": 377,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran attribute specifications, such as `Parameter`, `Public`, `Allocatable`, and `Intent`, along with conversions to and from strings and structured tags. It supports parsing and pretty-printing of these attributes, enabling their use in abstract syntax trees or intermediate representations. Concrete use cases include processing Fortran declarations during compilation or analysis to determine variable and procedure properties.",
      "description_length": 481,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_acc_construct",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different OpenACC constructs in Fortran code, such as `Atomic`, `Parallel`, `Kernels`, and `Loop`. It provides functions to convert these constructs to string representations, extract tags with associated data, and anonymize construct instances. These operations support analysis and transformation of Fortran code involving accelerator directives.",
      "description_length": 396,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.Label_common",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module offers data transformation functions that convert options, lists, integers, and strings into formatted strings or attribute-value pairs, supporting customizable serialization patterns. It handles structured data representation through type-specific conversion routines and includes utilities for encoding string literals into path-like structures. The operations are designed for scenarios requiring precise attribute naming conventions and data marshaling, such as Fortran abstract syntax tree serialization or configuration generation.",
      "description_length": 549,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Token",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes lexical tokens for Fortran code, transforming and analyzing them through operations like string conversion, keyword validation, and source location tracking across multiple token representations. It supports structured data types such as token specifications, AST fragments, and source metadata, enabling tasks like debugging token streams and mapping tokens to their original source positions. The child module extends this functionality by translating Fortran AST nodes into annotated tokens, providing utilities to inspect token properties and measure token size for use in parsing and preprocessing workflows. Together, they facilitate detailed code analysis, error reporting, and context-aware token manipulation across different stages of Fortran source processing.",
      "description_length": 793,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_constant",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates various types of Fortran literal constants and named constants. It provides constructors for integer, real, complex, logical, character, and other specialized constants, along with operations to convert values to strings, extract names or tags, and anonymize constants. Use cases include parsing and processing Fortran source code to analyze or transform constant expressions in the language.",
      "description_length": 431,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_internal_subprogram",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents internal Fortran subprograms, either functions or subroutines, identified by a name. It provides operations to convert subprogram types to strings, extract or modify their names, and produce tagged representations with associated metadata. Use cases include analyzing or transforming Fortran code structures, such as identifying subprogram boundaries or generating unique identifiers for subprogram instances.",
      "description_length": 432,
      "index": 189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_xlf",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents Fortran parsing constructs like array collapsing, subscript ordering, and clause types using the variant type `t`, with operations to convert to strings, extract names, and anonymize elements. It handles XL Fortran extensions through a sub-variant type representing assertions such as iteration count constraints and dependency checks, supporting structured tagging and string conversion. Another sub-variant models IBM XLF compiler directives, including loop control and optimization settings, with functions to parse, manipulate, and anonymize them. Together, these components enable detailed Fortran syntax analysis, transformation, and preprocessing for XL and XLF-specific code.",
      "description_length": 706,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_omp_construct",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different OpenMP constructs in Fortran code, such as `Atomic`, `Critical`, `Do`, `Parallel`, and combinations like `ParallelDo` or `TargetTeamsDistributeParallelDo`. It provides functions to convert these constructs to strings, extract names, anonymize named constructs, and serialize them with tags and attributes. These operations support analysis, transformation, and code generation tasks specific to OpenMP directives in Fortran.",
      "description_length": 482,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_type_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran type specifiers, including built-in types like `Integer`, `Real`, and `Complex`, as well as derived and user-defined types. It provides functions to convert type specs to strings, extract names, and construct types from keywords. Use cases include parsing Fortran declarations, analyzing type information in AST nodes, and generating type representations during code transformation.",
      "description_length": 438,
      "index": 192,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Fortran_parsing.F_binding_attr",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a set of attributes for Fortran binding operations, including pass-by-name, no-pass, visibility, and override settings. It provides functions to convert attributes to strings, extract names, and anonymize bindings. These operations are used to manage method binding properties in Fortran code generation and analysis.",
      "description_length": 337,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_case_value_range",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing different kinds of case value ranges in Fortran, such as single values, lower bounds, upper bounds, and inclusive ranges. It provides functions to convert these range types to strings, simple string representations, and tagged tuples with associated data. This module is used to handle and format case statement values in Fortran code analysis or transformation tools.",
      "description_length": 412,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_ambiguous",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing ambiguous Fortran syntax constructs, such as designators, tuples, array accesses, and data statement constants. It provides operations to convert these constructs to strings, extract names, and determine if a construct represents an array specification. Concrete use cases include parsing and analyzing Fortran code where syntactic ambiguity needs to be preserved and resolved during later stages of processing.",
      "description_length": 459,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Common",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utility functions for converting and formatting optional values, lists, and integers into readable strings, particularly for diagnostic and parsing purposes. It includes submodules that define language standards, source forms, and extensions for Fortran, each offering direct conversions to string representations, along with constants for line length limits and structured types for directive handling. Together, these components support parsing, analysis, and diagnostics of Fortran code by capturing format constraints, language variants, and directive structures in a unified way. Examples include formatting a list of integers as a range string, converting a source form value to its string name, or constructing a directive line with OpenMP syntax.",
      "description_length": 775,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_close_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines operations for handling Fortran `CLOSE` statement specifiers, including conversion to strings, extraction of labels, and transformation into connect specs. It works with a variant type representing different close specifiers, some of which carry labels. Concrete use cases include parsing and manipulating Fortran code during compilation or analysis tasks.",
      "description_length": 376,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_module_subprogram",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different kinds of Fortran module subprograms\u2014functions, subroutines, and separate module subprograms\u2014each identified by a name. It provides operations to convert these subprogram types to string representations, extract or modify their names, and generate tagged output for structured processing. Concrete use cases include parsing and analyzing Fortran code to distinguish between subprogram types and transforming them for further compilation or analysis tasks.",
      "description_length": 512,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokenpp",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module performs partial tokenization checks on Fortran source code, identifying incomplete tokens and returning precise position information to support error recovery and incremental parsing. It operates on `Partial.t` structures, representing unfinished lexical states, and integrates with submodules that handle full lexing, preprocessing, structured parsing, and AST construction. Key data types include `lexbuf`, `qtoken`, and branch tags, enabling operations like source location merging, conditional branch resolution, and token-to-AST mapping. Examples include recovering from syntax errors while preserving source structure, classifying preprocessor directives, and building location-aware AST fragments for semantic analysis or source-to-source translation.",
      "description_length": 771,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_io_control_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing Fortran I/O control specifiers, such as `Advance`, `Fmt`, and `Unit`, each optionally associated with labels or names. It provides functions to convert these specifiers to strings, extract names or labels, and map keywords to specifier values. Use cases include parsing Fortran I/O statements and generating intermediate representations for compiler analysis or code transformation.",
      "description_length": 430,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_prefix_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates Fortran prefix specifications, such as type declarations, purity, and module attributes. It provides operations to convert specifications to strings, extract names, and construct them from keywords. Use cases include parsing Fortran function prefixes and generating intermediate representations for further processing.",
      "description_length": 357,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_case_selector",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a type `t` representing case selectors in Fortran, specifically `CaseValueRangeList` and `Default`. It provides functions to convert these selectors to string representations and extract tagged information. These operations are used when processing Fortran `SELECT CASE` statements to handle case label formatting and analysis.",
      "description_length": 347,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Context",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides functions to construct, modify, and validate syntactic contexts using tag-based identifiers and activation flags, focusing on Fortran's structural elements like program units, specification regions, and control blocks. These operations track hierarchical parsing states and enforce contextual constraints, supporting use cases such as managing function definitions, variable declarations, and derived type scopes during Fortran code analysis.",
      "description_length": 463,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_stmt",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines variant types and predicate functions to represent and classify Fortran statements, including control structures, declarations, and I/O operations, with support for labeled and unlabeled forms. It provides operations to inspect statement components (like labels, variables, and names), manipulate structural properties (relabeling, anonymization), and distinguish categories such as specification vs. execution statements. These capabilities enable parsing, analysis, and transformation of Fortran source code, particularly for tasks like compiler tooling or code refactoring.",
      "description_length": 596,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_intent_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates intent specifications for Fortran variables, supporting conversion to string representations and extraction of tags. It operates on a variant type with constructors `In`, `Out`, and `Inout`, representing variable intent in function parameters. Use cases include parsing Fortran code to determine variable usage modes and generating appropriate string outputs for code analysis or transformation tools.",
      "description_length": 437,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Parser_aux",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module manages parsing state for Fortran source analysis using context flags, symbol tables, and stack-based scopes. It includes line status classifications to identify blank, comment, and continued lines, and supports semantic analysis with symbol registration, scope management, and AST manipulation. Functions allow conversion between state objects, inspection of context hierarchies, and enforcement of language rules during parsing. Examples include resolving nested scopes in control structures and handling line formatting modes for accurate AST construction.",
      "description_length": 571,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_program_unit",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines a variant type representing different Fortran program units such as main programs, functions, subroutines, modules, and block data. It provides operations to convert these units to string representations, extract or modify their names, and anonymize them. Use cases include parsing and transforming Fortran source code, analyzing program structure, and generating output for code navigation or refactoring tools.",
      "description_length": 432,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_type_attr_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines and manipulates type attribute specifications in Fortran, including visibility, abstraction, and inheritance. It supports operations to convert attributes to strings, extract structured tags, and anonymize names for consistent representation. Use cases include parsing and processing Fortran type declarations for analysis or transformation tools.",
      "description_length": 367,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.F_defined_operator",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module represents and manipulates user-defined operators in Fortran, supporting operations to create, name, and convert operator types. It works with a variant type that distinguishes between general, unary, and binary defined operators, along with functions to extract names, anonymize operators, and serialize them. Concrete use cases include parsing and processing custom operators in Fortran source code during compilation or analysis tasks.",
      "description_length": 450,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Tokensource",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module processes raw Fortran tokens into structured, queryable token representations. It transforms `rawtoken` streams into `qtoken` values, enabling precise tracking of token positions and categories. Useful for building Fortran parsers that require detailed source analysis, such as linters or refactoring tools.",
      "description_length": 319,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Ast",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides utilities for building and transforming Fortran abstract syntax trees (ASTs), supporting the creation of labeled nodes and leaves, extraction of identifiers and location metadata, and conversion between structural representations such as specification and executable pairs. It includes operations for traversal, size computation, and reshaping nested structures, facilitating analysis of Fortran's context-sensitive syntax and preparation for semantic validation. The recursive algebraic type at its core represents program units, statements, and expressions, annotated with positional metadata via a `spec` type that captures length and tag information. Key tasks include constructing typed AST elements like declarations and blocks, extracting child nodes for analysis, and incrementally building partial ASTs during parsing or transformation.",
      "description_length": 866,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Fortran_parsing.Branch",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module handles conditional branching constructs in Fortran code through the `tag` type, representing branch conditions and source locations, with functions to convert tags to strings, extract location data, and build AST nodes using a builder. It works with its child module that constructs and transforms AST nodes from parsed tokens, classifies token types, and generates location-annotated tokens. Together, they support tasks like source analysis, preprocessing, and AST reconstruction by enabling precise manipulation of Fortran branching logic. Examples include building `#ifdef`, `#ifndef`, `#if`, `#elif`, and `#else` constructs during parsing and transforming them into structured AST fragments.",
      "description_length": 709,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing.F_flush_spec",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module defines operations for handling FLUSH specifiers in Fortran parsing, including converting specifier values to strings, extracting labels, and anonymizing labeled specifiers. It works with a variant type representing possible FLUSH specifiers such as `Err`, `Iomsg`, `Iostat`, and `Unit`, each optionally carrying a label. Concrete use cases include processing FLUSH statements during Fortran code analysis and transformation, particularly when handling error labels and I/O specifiers.",
      "description_length": 497,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Fortran_parsing",
      "library": "diffast-langs-fortran-parsing",
      "description": "This module provides a comprehensive framework for parsing, analyzing, and transforming Fortran source code. It defines core data types such as lexical tokens, abstract syntax trees (ASTs), variant types for Fortran constructs (e.g., I/O specifiers, OpenMP/OpenACC directives, type and access attributes), and parsing state structures. Key operations include tokenization, macro expansion, incremental parsing, directive processing, and AST manipulation with source location tracking. Examples include parsing Fortran control statements with wait specifications, transforming OpenMP directives for parallelism analysis, and reconstructing structured AST nodes from token streams for code generation or refactoring tools.",
      "description_length": 720,
      "index": 214,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 301,
    "meaningful_modules": 215,
    "filtered_empty_modules": 86,
    "retention_rate": 0.7142857142857143
  },
  "statistics": {
    "max_description_length": 948,
    "min_description_length": 266,
    "avg_description_length": 563.9813953488372,
    "embedding_file_size_mb": 0.781397819519043
  }
}