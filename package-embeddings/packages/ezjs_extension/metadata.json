{
  "package": "ezjs_extension",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 47,
  "creation_timestamp": "2025-07-15T23:19:37.531968",
  "modules": [
    {
      "module_path": "Browser.I18n",
      "library": "ezjs_extension.browser",
      "description": "This module handles internationalization tasks such as retrieving localized messages, detecting UI language, and identifying the language of provided text. It works with strings for message keys and substitutions, and uses callbacks to handle asynchronous language detection and acceptance. Concrete use cases include displaying translated UI elements, formatting language-specific content, and adapting application behavior based on user language preferences.",
      "description_length": 460,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser.Browser_action",
      "library": "ezjs_extension.browser",
      "description": "This module controls browser action UI elements like title, icon, popup, and badge properties for tabs or windows. It supports operations to set and retrieve badge text, colors, and icons, with support for tab-specific configurations. Use cases include updating a browser extension's toolbar icon dynamically, displaying notification badges, or enabling/disabling actions based on tab state.",
      "description_length": 391,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Browser.Windows",
      "library": "ezjs_extension.browser",
      "description": "This module provides functions to create, update, and manage browser windows, including setting window properties like position, size, and focus state. It works with window objects and lists of windows, supporting operations such as querying the current or last focused window, retrieving all windows, and handling window lifecycle events. Concrete use cases include opening new windows with specific dimensions, adjusting window focus, and reacting to window creation or removal events.",
      "description_length": 487,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser.Storage",
      "library": "ezjs_extension.browser",
      "description": "This module provides direct access to browser storage areas like `localStorage`, `sessionStorage`, and managed storage through operations such as `get`, `set`, `remove`, and `clear`. It works with primitive values, arrays, and JavaScript objects, enabling persistent client-side data management across sessions. Concrete use cases include saving user preferences, caching API responses, and managing application state in web extensions or single-page apps.",
      "description_length": 456,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser.Tabs",
      "library": "ezjs_extension.browser",
      "description": "This module enables comprehensive control over browser tabs through operations like creation, modification, and lifecycle management, including functions to hide, move, reload, and adjust visual properties. It utilizes tab and window identifiers, tab objects, and configuration structures to facilitate tasks such as scripting execution, event handling for state changes, and content manipulation. Typical applications include extensions requiring dynamic tab organization, content customization, or automated interactions like saving pages as PDFs and capturing screenshots.",
      "description_length": 575,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser.Runtime",
      "library": "ezjs_extension.browser",
      "description": "This module enables interaction with the browser runtime, supporting tasks like retrieving runtime metadata, managing extension lifecycles, and establishing communication channels. It operates on JavaScript objects, strings, and extension-specific entities through asynchronous APIs and event-driven patterns. Typical applications include coordinating inter-extension messaging, handling installation events, and controlling extension behavior via dynamic reloading or options page management.",
      "description_length": 493,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser",
      "library": "ezjs_extension.browser",
      "description": "This module enables direct interaction with browser-specific features such as tabs, windows, and storage through typed interfaces, while coordinating with submodules to provide a unified API for managing browser state and behavior. It supports key operations like modifying tab content, persisting user data across sessions, customizing browser action UI, and handling internationalization through concrete types such as tab descriptors, window configurations, and storage primitives. For example, you can dynamically update a browser extension's badge text based on tab state, save user preferences to `local` storage, or localize UI elements using detected language settings. Submodules extend this functionality with precise controls for runtime communication, window management, and content scripting.",
      "description_length": 805,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Storage_local_lwt",
      "library": "ezjs_extension.local-lwt",
      "description": "This module provides Lwt-based asynchronous operations for interacting with a local storage system, including getting, setting, and removing values by key, as well as clearing all stored data. It works directly with JavaScript objects via `Ezjs_min.t` and supports optional callbacks for side effects. Concrete use cases include persisting user preferences, caching data in web applications, and managing state across sessions in client-side OCaml applications.",
      "description_length": 461,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Browser_common.Storage",
      "library": "ezjs_extension.browser-common",
      "description": "This module provides direct access to browser storage areas such as `localStorage`, `syncStorage`, and `managedStorage` via the `storage`, `local`, `sync`, and `managed` values. It works with JavaScript-compatible data structures through the `Ezjs_min` bindings, allowing OCaml code to interact with browser APIs. Concrete use cases include persisting user preferences, caching data across sessions, and accessing enterprise-managed settings in Chrome extensions.",
      "description_length": 463,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_common.Tabs",
      "library": "ezjs_extension.browser-common",
      "description": "This module offers functions to create, modify, and manage browser tabs through actions like hiding, moving, injecting CSS, and toggling reader mode, while also handling tab lifecycle events such as activation, removal, and updates. It operates on tab identifiers and tab objects, enabling interactions with JavaScript via low-level bindings to respond to state changes like zoom adjustments or tab replacements. Use cases include browser extensions requiring dynamic tab manipulation, real-time UI synchronization, or custom styling interventions based on user behavior or system events.",
      "description_length": 588,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_common.I18n",
      "library": "ezjs_extension.browser-common",
      "description": "Handles internationalization by providing functions to retrieve localized messages and the current UI language. Works with strings and language-specific resources. Used to display translated text in the user interface based on the browser's language settings.",
      "description_length": 259,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Browser_common.Runtime",
      "library": "ezjs_extension.browser-common",
      "description": "This module provides operations for interacting with the browser runtime environment, including retrieving runtime information, managing extensions, and handling communication between components. It works with JavaScript-compatible data types through the `Ezjs_min` library and supports event-driven interactions via callbacks. Concrete use cases include reloading the runtime, connecting to extension ports, handling installation events, and exchanging messages between the extension and external applications.",
      "description_length": 511,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_common.Windows",
      "library": "ezjs_extension.browser-common",
      "description": "This module provides functions to create and update browser windows with specific dimensions, focus states, and URLs. It works with window objects and event callbacks to handle window lifecycle events. Concrete use cases include opening new windows with predefined properties, adjusting window size and position, and reacting to window focus or removal events.",
      "description_length": 360,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Browser_common.Browser_action",
      "library": "ezjs_extension.browser-common",
      "description": "This module controls browser action UI elements like icons, badges, and popups for extensions. It provides functions to dynamically update titles, icons, badge text, and colors, either globally or per tab/window. Use cases include reflecting extension state changes in the toolbar UI or handling user interactions via click events on browser actions.",
      "description_length": 350,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_common",
      "library": "ezjs_extension.browser-common",
      "description": "This module enables comprehensive interaction with browser features including storage, tabs, internationalization, runtime, windows, and UI actions. It provides data types such as tab identifiers, window objects, and language codes, along with operations to manipulate browser state, handle events, and exchange messages with JavaScript. Use cases include building extensions that persist user settings, dynamically adjust tab content, display localized text, and control window layout. Examples include caching data in `localStorage`, injecting CSS into tabs, opening windows with custom dimensions, and updating extension badges based on user activity.",
      "description_length": 654,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_lwt.Runtime",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module manages browser extension lifecycle events, facilitates inter-extension communication through messaging, and controls page interactions like background or options page access. It operates on JavaScript objects and strings, using Lwt promises for asynchronous operations to interface with browser APIs. Typical use cases include building extensions that require cross-component message passing, runtime updates, or platform-specific configuration.",
      "description_length": 458,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_lwt.Storage",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module provides Lwt-based asynchronous operations for interacting with browser storage areas, including local, sync, and managed storage. It supports getting, setting, removing, and clearing key-value pairs, as well as querying storage usage in bytes. Concrete use cases include persisting user preferences, caching data across sessions, and managing extension settings in a browser environment.",
      "description_length": 400,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_lwt.Tabs",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module provides asynchronous operations for managing browser tabs, including creation, movement, reloading, and removal, alongside content manipulation like script execution, CSS injection, and zoom adjustments. It works with tab identifiers, tab metadata, and Lwt promises to handle asynchronous workflows, supporting use cases such as browser extensions that automate tab organization, capture visual state, or respond to user interactions like tab activation or language detection. Event-driven patterns are emphasized, with handlers for tab lifecycle events (e.g., detachment, updates) enabling dynamic UI or background task coordination.",
      "description_length": 647,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_lwt.Windows",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module manages browser windows by creating, updating, and removing them with functions like `create`, `update`, and `remove`. It handles window properties such as position, size, focus, and state using `make_createData` and `make_updateInfo` to construct configuration objects. It also provides access to window information through `get`, `getCurrent`, `getLastFocused`, and `getAll`, supporting asynchronous operations with Lwt promises.",
      "description_length": 443,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Browser_lwt.I18n",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module handles internationalization tasks in a browser environment using Lwt for asynchronous operations. It provides functions to retrieve localized messages, detect UI language, and fetch accepted languages from the browser. Concrete use cases include dynamically loading translations, formatting language-specific content, and supporting multilingual user interfaces.",
      "description_length": 375,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Browser_lwt",
      "library": "ezjs_extension.browser-lwt",
      "description": "This module enables asynchronous interaction with browser tabs, windows, and storage systems, using data types like `tab`, `window`, and `storageArea` to manage persistent state and dynamic UI behavior. It supports operations such as saving user preferences, synchronizing data across sessions, and manipulating tab layouts or window configurations through Lwt-based promises. Submodules handle extension lifecycle, messaging, internationalization, and content manipulation, enabling use cases like cross-component communication, language detection, and automated tab management with event-driven handlers for updates, detachment, and activation. Specific examples include persisting settings in local storage, injecting scripts into active tabs, and creating browser windows with custom positioning and focus behavior.",
      "description_length": 819,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extension_utils.Tabs",
      "library": "ezjs_extension.common",
      "description": "This module creates configuration objects for querying and scripting browser tabs. It provides functions to build detailed query parameters and script injection settings with optional fields. Use it to target specific tabs by properties like URL, window ID, or index, and customize script execution context.",
      "description_length": 307,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extension_utils.Runtime",
      "library": "ezjs_extension.common",
      "description": "This module provides functions to convert between OCaml and JavaScript representations of platform and connection information. It works with records containing OS, architecture, and NaCl architecture strings, as well as connection info objects. Concrete use cases include passing browser platform details to JavaScript code and constructing JavaScript connection objects from string identifiers.",
      "description_length": 395,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extension_utils.Browser",
      "library": "ezjs_extension.common",
      "description": "This module provides functions for converting error data to and from JavaScript representations and managing event listeners for browser-based interactions. It works with error records containing message, file, and line number fields, as well as various event types with 1, 2, or 3 arguments. It is used to handle browser extension error reporting and event listener registration, such as capturing and responding to runtime errors or user actions in a browser environment.",
      "description_length": 473,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extension_utils",
      "library": "ezjs_extension.common",
      "description": "This module provides utilities for interacting with browser extensions by managing tab configurations, platform data conversions, and error handling. It supports creating query and script injection settings for tabs, converting platform and connection information between OCaml and JavaScript, and translating error and event data across language boundaries. You can target tabs by URL or window ID to inject scripts, pass OS and architecture details to JavaScript, and register event listeners for runtime errors or user actions. Examples include building a tab query with specific properties, converting a connection string into a JavaScript object, and capturing line numbers from extension errors.",
      "description_length": 701,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome.I18n",
      "library": "ezjs_extension.chrome",
      "description": "This module handles internationalization tasks such as retrieving localized messages, detecting UI language, and identifying the language of provided text. It works with strings, optional substitution lists, and callback functions for handling asynchronous results. Concrete use cases include displaying translated UI elements, formatting language-specific content, and adapting application behavior based on user language preferences.",
      "description_length": 435,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome.Tabs",
      "library": "ezjs_extension.chrome",
      "description": "This module enables managing browser tabs through creation, navigation, and state adjustments. It operates on tab identifiers, window contexts, and properties like active status or zoom configurations. Common applications include organizing tab layouts, injecting scripts, handling user interactions via events, and controlling zoom behavior.",
      "description_length": 342,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome.Windows",
      "library": "ezjs_extension.chrome",
      "description": "This module provides functions to create, update, and manage browser windows, including setting window properties like position, size, and focus state. It works with window objects and lists of windows, supporting operations such as retrieving specific windows, handling window creation and removal events, and modifying window state. Concrete use cases include opening new windows with specified dimensions, updating the position of an existing window, and tracking focus changes across windows.",
      "description_length": 496,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Chrome.Browser_action",
      "library": "ezjs_extension.chrome",
      "description": "This module manages the browser action UI elements in a Chrome extension, such as setting and getting the title, icon, popup, and badge text or color. It supports event handling through functions like `onClicked` and works with data types including strings, optional integers for tab IDs, and typed arrays for color data. Concrete use cases include updating the badge text when a tab changes, setting a custom icon based on page content, or toggling the browser action state when users click it.",
      "description_length": 495,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome.Runtime",
      "library": "ezjs_extension.chrome",
      "description": "This module enables managing extension lifecycles (e.g., reloading, uninstalling), establishing communication channels (including cross-extension/native messaging), and handling runtime events (e.g., startup, installation). It operates on JavaScript-wrapped runtime environments, ports, and error states, supporting use cases like background page coordination, platform-specific updates, and native application integration. The design bridges browser extension APIs through `Ezjs_min` and utility modules to facilitate scenarios such as secure inter-process communication and dynamic extension management.",
      "description_length": 605,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome.Storage",
      "library": "ezjs_extension.chrome",
      "description": "This module provides direct access to browser storage areas like `local`, `sync`, and `managed`, allowing data persistence across sessions. It supports operations to get, set, remove, and clear key-value pairs, as well as retrieve storage usage metrics. Concrete use cases include saving user preferences, caching application state, and managing cross-device data synchronization.",
      "description_length": 380,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome",
      "library": "ezjs_extension.chrome",
      "description": "This module provides direct access to Chrome extension APIs for managing browser tabs, windows, storage, internationalization, and runtime events. It enables developers to interact with tab contents, manipulate browser windows, persist data using local or synchronized storage, handle extension lifecycle events, and manage browser action UI elements. Functions support creating and navigating tabs, updating window properties, setting localized messages, exchanging messages between contexts, and modifying persistent key-value data. Concrete applications include building extensions that organize tab layouts, display translated UI elements, synchronize user preferences across devices, or coordinate background and foreground processes.",
      "description_length": 739,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Storage_local",
      "library": "ezjs_extension.local",
      "description": "This module provides direct access to client-side storage operations, including setting, retrieving, and removing key-value pairs using JavaScript's `localStorage` API. It supports operations on strings, arrays, and JavaScript objects, enabling persistent data storage across sessions. Concrete use cases include saving user preferences, caching application state, and managing authentication tokens.",
      "description_length": 400,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declarative_content",
      "library": "ezjs_extension.declarative-content",
      "description": "This module creates and manages declarative content rules for browser extensions, enabling actions like showing page actions, setting icons, and injecting content scripts based on URL and page state conditions. It works with rule, condition, action, pageUrl, and pageStateMatcher types, primarily for defining extension behavior in response to navigation or page events. Concrete use cases include injecting CSS or JavaScript on specific URLs, showing an icon when certain pages load, or removing rules dynamically based on runtime criteria.",
      "description_length": 541,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Chrome_lwt.Tabs",
      "library": "ezjs_extension.chrome-lwt",
      "description": "This module enables managing browser tabs through operations like creation, navigation, script execution, CSS injection, zoom control, and lifecycle management via events such as activation, movement, or removal. It operates on tab identifiers, structured representations of tab states, and message formats, often bridging OCaml and JavaScript via `Ezjs_min`. Use cases include automating tab interactions, building extensions that react to tab state changes, capturing screenshots, and facilitating bidirectional communication between OCaml logic and web content.",
      "description_length": 564,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_lwt.I18n",
      "library": "ezjs_extension.chrome-lwt",
      "description": "Handles internationalization tasks in Lwt-based applications. Provides functions to retrieve localized messages, detect languages, and access UI language settings. Works with strings and lists for language codes and message substitutions. Useful for dynamically translating content based on user preferences or browser settings.",
      "description_length": 328,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_lwt.Runtime",
      "library": "ezjs_extension.chrome-lwt",
      "description": "This module provides operations for retrieving runtime information (e.g., extension ID, manifest data), managing extension lifecycle (reloading, restarting, connecting), and handling events (installation, messages, startup) through an event-driven model. It works with JavaScript-compatible types, ports, message senders, and event listeners to facilitate asynchronous communication between extensions, native applications, and browser components. Typical use cases include implementing background services, cross-extension coordination, and native messaging integrations in browser extensions.",
      "description_length": 594,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_lwt.Windows",
      "library": "ezjs_extension.chrome-lwt",
      "description": "This module manages browser windows, allowing creation, modification, and querying of window properties such as position, size, and focus state. It supports event handling for window creation, removal, and focus changes, and works with window identifiers and metadata. Concrete use cases include opening new windows with specified dimensions, updating the position of existing windows, and tracking focus changes across windows.",
      "description_length": 428,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Chrome_lwt.Storage",
      "library": "ezjs_extension.chrome-lwt",
      "description": "This module provides Lwt-based asynchronous access to browser storage areas, allowing get, set, remove, and clear operations on key-value pairs. It works with JavaScript string keys and arbitrary OCaml values, supporting both individual and batched operations. Concrete use cases include persisting user preferences, caching application state, and managing session data across page reloads.",
      "description_length": 390,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_lwt",
      "library": "ezjs_extension.chrome-lwt",
      "description": "This module enables asynchronous interaction with Chrome extensions, handling tabs, windows, runtime events, and storage through JavaScript-wrapped values. It supports key operations like managing tab navigation and state, persisting data with `sync` or `local` storage, retrieving localized messages, inspecting runtime metadata, and controlling browser windows. You can automate tab workflows, translate content dynamically, exchange messages between extensions, store user settings, and respond to window or tab events in real time. Submodules extend this functionality with focused APIs for i18n, tab manipulation, runtime control, window management, and structured storage access.",
      "description_length": 685,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_common.Tabs",
      "library": "ezjs_extension.chrome-common",
      "description": "This module provides functions to create and manipulate browser tabs, including setting properties like URL, index, and window ID. It supports event handlers for tab lifecycle changes such as creation, removal, activation, and updates, as well as actions like injecting CSS or connecting to a tab's runtime. Concrete use cases include managing tab state in browser extensions, injecting styles dynamically, and handling user interactions across multiple windows.",
      "description_length": 462,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Chrome_common.Runtime",
      "library": "ezjs_extension.chrome-common",
      "description": "This module provides operations for interacting with the browser runtime environment, including retrieving extension metadata, managing connections, handling messages, and controlling lifecycle events. It works with JavaScript objects, strings, and specialized port and event types for communication. Concrete use cases include reloading the extension, establishing native messaging ports, responding to installation events, and handling cross-extension or native application messages.",
      "description_length": 485,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_common.Windows",
      "library": "ezjs_extension.chrome-common",
      "description": "This module provides functions to create and update browser windows with specific dimensions, positions, and states, using `createData` and `updateInfo` to configure window properties. It works with JavaScript object wrappers like `window Ezjs_min.t` and handles window lifecycle events such as creation, removal, and focus changes. Concrete use cases include managing popup windows, setting initial window layouts, and reacting to user window interactions in a browser extension.",
      "description_length": 480,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_common.Browser_action",
      "library": "ezjs_extension.chrome-common",
      "description": "This module handles browser action events in a Chrome extension, specifically providing a function to respond to clicks on the browser action icon. It works with tab data structures to identify which tab was active when the icon was clicked. Use this to implement context-specific behavior when users interact with the extension's UI element in the browser toolbar.",
      "description_length": 365,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_common.Storage",
      "library": "ezjs_extension.chrome-common",
      "description": "This module provides direct access to browser storage areas such as `local`, `sync`, and `managed`, allowing data persistence and retrieval across browser sessions. It works with JavaScript-compatible data structures through the `Ezjs_min` bindings, enabling interaction with the Chrome storage API. Concrete use cases include saving user preferences, caching application state, and synchronizing data across devices using Chrome's built-in storage mechanisms.",
      "description_length": 460,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Chrome_common.I18n",
      "library": "ezjs_extension.chrome-common",
      "description": "Handles internationalization by providing functions to retrieve localized messages and the current UI language. Works with strings and lists of substitution values for message formatting. Used to display translated text in the user interface based on locale-specific resources.",
      "description_length": 277,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Chrome_common",
      "library": "ezjs_extension.chrome-common",
      "description": "This module enables comprehensive browser extension development by integrating tab, window, and runtime management with storage, localization, and UI interaction capabilities. Key data types include tabs with configurable properties, windows with layout settings, runtime objects for messaging and extension control, storage APIs for persistent data, and localized strings. Operations allow injecting CSS into tabs, handling browser action clicks, persisting user settings across sessions, creating and tracking windows, and responding to runtime events like installation or connection changes. Example uses include building a popup UI that reacts to tab changes, storing user preferences with sync storage, or launching a custom-sized window on extension activation.",
      "description_length": 767,
      "index": 46,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 193,
    "meaningful_modules": 47,
    "filtered_empty_modules": 146,
    "retention_rate": 0.24352331606217617
  },
  "statistics": {
    "max_description_length": 819,
    "min_description_length": 259,
    "avg_description_length": 490.40425531914894,
    "embedding_file_size_mb": 0.17118167877197266
  }
}