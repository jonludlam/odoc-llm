{
  "package": "erlang",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 20,
  "creation_timestamp": "2025-08-14T23:29:26.744806",
  "modules": [
    {
      "module_path": "Erlang.Ast_helper.Type",
      "library": "erlang",
      "description": "This module provides functions to construct Erlang abstract syntax tree nodes representing type declarations and expressions. It supports creating type variables, constants, tuples, lists, records, maps, function types, and variant types, along with utilities to define type fields and map fields with optional presence annotations. Use this module to programmatically generate Erlang type specifications, record definitions, and type expressions for use in Erlang AST manipulation or code generation tasks.",
      "description_length": 507,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Mod",
      "library": "erlang",
      "description": "Handles construction and manipulation of Erlang module AST nodes. It provides functions to create module structures with attributes, behaviours, exports, functions, and types. Use it to programmatically generate Erlang module definitions from AST components.",
      "description_length": 258,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Export",
      "library": "erlang",
      "description": "This module creates AST nodes representing exported functions and types in Erlang. It provides functions to generate exports with specified names, arities, and kinds, such as functions or types. Use it when constructing Erlang module exports programmatically, like defining which functions or types are exposed in a module's interface.",
      "description_length": 335,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.FunDecl",
      "library": "erlang",
      "description": "This module creates function declarations and case expressions in Erlang ASTs. It provides `mk` to construct function declarations with a name, optional spec, and list of cases, and `case` to build individual function cases with patterns, optional guard, and a body expression. Use it to programmatically generate Erlang function definitions during code transformation or analysis.",
      "description_length": 381,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Printer.H",
      "library": "erlang",
      "description": "Adds a specified number of spaces to the beginning of a string. Works with integers and strings. Useful for formatting output, such as aligning text in logs or pretty-printing data structures.",
      "description_length": 192,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Atom",
      "library": "erlang",
      "description": "This module provides functions to create, manipulate, and compare Erlang atoms within an AST. It supports operations like concatenation of atoms with a separator, converting atoms to strings, checking equality, and converting to lowercase. Use cases include constructing atom literals in Erlang ASTs, normalizing atom values, and generating atoms dynamically during AST transformations.",
      "description_length": 386,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Expr",
      "library": "erlang",
      "description": "This module constructs and manipulates Erlang abstract syntax tree (AST) expressions for control flow structures (case, if, receive, try), data structures (tuples, lists, maps), function applications, variable bindings, and annotations. It operates on AST node types like `expr`, `case`, and `map_field`, enabling precise representation of Erlang code in intermediate forms. These capabilities are particularly useful for code generation, syntactic transformations, and analysis tools that process or emit Erlang source code programmatically.",
      "description_length": 542,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Ast",
      "library": "erlang",
      "description": "This module provides bidirectional conversion between abstract syntax trees and S-expressions, enabling serialization, parsing, and structured manipulation of Erlang code elements like expressions, patterns, bindings, function definitions, and module metadata. It operates on AST types representing literals (integers, strings, tuples), clauses, attributes, and program structures, supporting use cases such as source code marshaling, static analysis, and programmatic transformation of Erlang modules.",
      "description_length": 502,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Name",
      "library": "erlang",
      "description": "This module provides functions to construct and manipulate name expressions in Erlang ASTs. It supports creating variable names, atom names, and qualified names with module-function pairs. Use it to generate valid name nodes when building Erlang function calls, variable references, or module-qualified identifiers.",
      "description_length": 315,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Pat",
      "library": "erlang",
      "description": "This module provides functions to construct Erlang AST patterns including literals, variables, tuples, lists, cons cells, maps, and named patterns. It supports data types like integers, atoms, strings, and complex structures through the `Erl_ast.pattern` type. Concrete use cases include building match expressions, function clause parameters, and pattern-matching constructs in Erlang ASTs for code generation or analysis tools.",
      "description_length": 429,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Printer",
      "library": "erlang",
      "description": "This module formats and prints Erlang core abstract syntax trees to textual source code. It provides functions to print individual elements like variables, literals, expressions, function definitions, and entire modules to a formatter or output channel. Use it to generate readable Erlang source files from internal AST representations during compilation or code transformation workflows.",
      "description_length": 388,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Const",
      "library": "erlang",
      "description": "This module provides functions to construct literal values in an Erlang AST, including integers, characters, binaries, strings, floats, and atoms. It operates directly on string inputs and AST node types to produce concrete syntax elements. Use this module when generating Erlang code programmatically, such as in compilers, code generators, or AST manipulation tools.",
      "description_length": 368,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Lexer",
      "library": "erlang",
      "description": "Processes character input into structured tokens for parsing Erlang code. It defines the `token` function that consumes a `lexbuf` and returns the next parsed token according to the Erlang grammar. This module is used directly by the parser to handle low-level input processing during compilation or interpretation of Erlang source files.",
      "description_length": 338,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Printer",
      "library": "erlang",
      "description": "This module provides functions to convert Erlang abstract syntax trees into readable code by handling structural layout and lexical formatting of elements like expressions, patterns, and declarations. It operates on AST components such as atoms, function definitions, and type specifications, supporting both direct output to files and customizable formatting through layout controls. Typical applications include generating Erlang source files from ASTs or producing human-readable representations for tooling like linters and code generators.",
      "description_length": 544,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Parser",
      "library": "erlang",
      "description": "This module defines a comprehensive set of lexical tokens representing elements of the Erlang language, such as keywords, operators, literals, and punctuation, each annotated with parsing metadata. It includes a function `module_file` that parses a file's contents into a list of abstract syntax tree nodes representing Erlang module items. Concrete use cases include building Erlang source code analyzers, linters, or transformation tools that require detailed syntactic information.",
      "description_length": 484,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Parse",
      "library": "erlang",
      "description": "Reads an Erlang source file and parses it into an abstract syntax tree (AST) represented as a list of module items. Returns a result type with either the parsed AST or a parser error. Useful for analyzing or transforming Erlang code programmatically, such as in linters or code generators.",
      "description_length": 289,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast",
      "library": "erlang",
      "description": "This module defines an atom type and provides functions to convert abstract syntax tree (AST) elements\u2014specifically the top-level structure, expressions, and atoms\u2014into S-expressions. It works with data types representing Erlang source code constructs, such as modules, functions, and expressions. Use this module when serializing parsed Erlang code to S-expressions for analysis, transformation, or external representation.",
      "description_length": 424,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core",
      "library": "erlang",
      "description": "This module handles conversion between Erlang abstract syntax trees and S-expressions, and provides functions to print ASTs to readable Erlang source code. It works with AST types representing literals, expressions, function definitions, and module metadata. Use it to serialize Erlang code, perform static analysis, or generate source files from internal representations.",
      "description_length": 372,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper",
      "library": "erlang",
      "description": "This module provides functions to construct and manipulate Erlang abstract syntax trees (ASTs), covering atoms, names, constants, expressions, patterns, function declarations, types, and module exports. It works with AST node types such as `expr`, `pattern`, `fun_decl`, and `type_expr` to enable precise code generation and transformation. Concrete use cases include building Erlang function calls, match expressions, type declarations, and module exports programmatically in compilers or AST manipulation tools.",
      "description_length": 513,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang",
      "library": "erlang",
      "description": "This module processes Erlang source code through lexical analysis, parsing, and abstract syntax tree manipulation, providing functions to convert between ASTs, S-expressions, and human-readable code. It works with AST node types, lexical tokens, and module structures to support precise code generation, static analysis, and source transformation. Use it to build tools like linters, code generators, or Erlang compilers that require parsing, modifying, and emitting Erlang code.",
      "description_length": 479,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 20,
    "meaningful_modules": 20,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 544,
    "min_description_length": 192,
    "avg_description_length": 402.3,
    "embedding_file_size_mb": 0.2902088165283203
  }
}