{
  "package": "erlang",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 20,
  "creation_timestamp": "2025-07-15T23:09:43.647030",
  "modules": [
    {
      "module_path": "Erlang.Ast_helper.Expr",
      "library": "erlang",
      "description": "The module provides functions to construct expressions for control structures (conditionals, loops), data literals (lists, tuples, maps), function applications, variable bindings, and macro expansions, operating on AST elements like expressions, patterns, and clauses. These utilities enable programmatic generation of Erlang syntax trees for tasks like code transformation, compilation, or static analysis tools.",
      "description_length": 413,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Name",
      "library": "erlang",
      "description": "This module provides functions to construct and manipulate name expressions in Erlang ASTs. It supports creating variable names, atoms, and qualified names using `var`, `atom`, and `qualified`. These operations are essential when generating function calls, module references, or variable bindings in Erlang syntax trees.",
      "description_length": 320,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Printer.H",
      "library": "erlang",
      "description": "Adds a specified number of spaces to the beginning of a string. Works with integers and strings. Useful for formatting output in code generators or pretty-printers where indentation is required.",
      "description_length": 194,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Printer",
      "library": "erlang",
      "description": "This module formats and prints Erlang core abstract syntax trees to textual source code. It provides functions to print individual elements like variables, literals, expressions, function definitions, and entire modules to a formatter or file. Use it to generate readable Erlang source files from internal AST representations during compilation or code generation tasks.",
      "description_length": 370,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Export",
      "library": "erlang",
      "description": "This module creates AST nodes representing exported functions and types in Erlang. It provides functions to generate exports with specified names, arities, and kinds, such as `fun_` for functions and `type_` for types. Use it when building Erlang modules to declare which functions or types are exported.",
      "description_length": 304,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.FunDecl",
      "library": "erlang",
      "description": "This module creates function declarations and case expressions in Erlang ASTs. It provides `mk` to construct function declarations with a name, optional type spec, and list of cases, and `case` to build individual function cases with patterns, optional guard, and a body expression. Use it to programmatically generate Erlang function definitions with typed parameters, guards, and multiple clauses.",
      "description_length": 399,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Type",
      "library": "erlang",
      "description": "This module constructs and manipulates Erlang abstract syntax tree (AST) nodes related to type declarations and expressions. It supports creating type definitions, function types, records, maps, variants, and primitive types, working directly with `type_expr`, `type_decl`, and related structures. Concrete use cases include building type specifications for functions, defining record layouts, and generating type expressions for Erlang modules.",
      "description_length": 445,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Mod",
      "library": "erlang",
      "description": "Handles construction and manipulation of Erlang module AST nodes. Provides functions to create module structures with attributes, behaviours, exports, functions, and types. Used to programmatically generate valid Erlang module definitions from AST components.",
      "description_length": 259,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Const",
      "library": "erlang",
      "description": "This module provides functions to construct literal values in an Erlang AST, including integers, characters, binaries, strings, floats, and atoms. It operates directly on string inputs and atom values, converting them into their corresponding AST node representations. Use this module when generating Erlang code programmatically, such as in compilers, code generators, or AST manipulators.",
      "description_length": 390,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Pat",
      "library": "erlang",
      "description": "This module constructs Erlang abstract syntax tree (AST) patterns for matching and binding values in function clauses, case expressions, and receive statements. It supports creating patterns like variables, tuples, lists, cons cells, maps, and literals, often used when generating Erlang code from OCaml. Functions like `bind`, `tuple`, and `const` directly model common Erlang pattern forms for precise AST manipulation.",
      "description_length": 421,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Atom",
      "library": "erlang",
      "description": "This module provides functions to create, manipulate, and compare Erlang atoms within an AST. It supports operations like concatenation of atoms with a separator, converting atoms to strings, checking equality, and transforming to lowercase. Use cases include constructing atom literals in Erlang ASTs, normalizing atom values, and generating atoms dynamically during AST transformations.",
      "description_length": 388,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Ast",
      "library": "erlang",
      "description": "This module provides bidirectional conversion between Erlang abstract syntax trees (ASTs) and S-expressions, enabling serialization and deserialization of core language constructs. It operates on AST nodes like expressions, patterns, function definitions, and module structures, handling primitives (atoms, numbers) and composite forms (tuples, cons cells, clauses). Typical use cases include parsing Erlang code into manipulable ASTs, persisting ASTs as S-expressions, or generating Erlang code from serialized representations.",
      "description_length": 528,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Parser",
      "library": "erlang",
      "description": "This module defines a comprehensive set of lexical tokens representing elements of the Erlang language, such as operators, keywords, literals, and punctuation. It includes functions for parsing Erlang source files into abstract syntax trees, specifically handling tokenization and high-level module structure. It is used to analyze and process Erlang code, enabling tasks like compilation, linting, or code transformation.",
      "description_length": 422,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast",
      "library": "erlang",
      "description": "This module defines an atom type and functions to convert abstract syntax tree (AST) elements into S-expressions. It works with AST structures, expressions, and atoms, enabling serialization of parsed Erlang code into a readable sexp format. Concrete use cases include debugging parsers, generating intermediate representations, and interfacing with tools that consume S-expressions.",
      "description_length": 383,
      "index": 13,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Erlang.Lexer",
      "library": "erlang",
      "description": "Processes input text into structured tokens for parsing Erlang code. It defines the `token` function that consumes a `lexbuf` and returns the next parsed token according to Erlang syntax rules. This module is used during the initial stages of compiling or interpreting Erlang source files to break down raw input into meaningful syntactic units.",
      "description_length": 345,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper",
      "library": "erlang",
      "description": "This module enables construction and manipulation of Erlang abstract syntax trees (ASTs) by providing utilities for creating atoms, literals, expressions, patterns, function declarations, type definitions, exports, and module structures. It includes operations for building control structures, data literals, function calls, variable bindings, and module attributes, working directly with AST elements like expressions, patterns, clauses, and type expressions. Specific examples include generating function definitions with multiple clauses and guards, creating module exports, constructing type specifications, and forming Erlang literals such as atoms, integers, and strings. Submodules extend this functionality by handling name expressions, control flow expressions, function and type exports, and pattern matching constructs used in function clauses and case expressions.",
      "description_length": 876,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Parse",
      "library": "erlang",
      "description": "Reads an Erlang source file and parses it into an AST of module items, handling syntax errors by returning a result type. It processes strings as file paths and produces either a list of parsed module items or a parser error. Useful for analyzing or transforming Erlang code programmatically, such as in linters or code generators.",
      "description_length": 331,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Core",
      "library": "erlang",
      "description": "This module handles the transformation and representation of Erlang core abstract syntax trees (ASTs) through two complementary functionalities: one for printing ASTs as readable source code, and another for converting ASTs to and from S-expressions. It operates on key data types such as AST nodes (expressions, patterns, function definitions, and modules), and supports both primitive and composite Erlang constructs like atoms, numbers, tuples, and clauses. You can use it to generate Erlang source files from ASTs, serialize ASTs for storage or transmission, or reconstruct ASTs from S-expressions for further manipulation. For example, you can parse an Erlang module into an AST, modify its structure, and then output the updated source code or serialize the AST for later use.",
      "description_length": 782,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Printer",
      "library": "erlang",
      "description": "This module transforms Erlang abstract syntax tree (AST) elements\u2014such as atoms, expressions, patterns, literals, and type declarations\u2014into human-readable text using OCaml's `Format.formatter`, enabling precise formatting for code generation or analysis. It supports serializing AST components like function definitions, type signatures, and entire modules directly to source files or intermediate string representations, catering to use cases in compiler toolchains, debugging, and automated code transformation workflows. A helper function indents strings by a given number of spaces, facilitating structured output in code generators or pretty-printers that require alignment. Direct operations include AST-to-text conversion, while the helper enhances formatting control for structured output.",
      "description_length": 798,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang",
      "library": "erlang",
      "description": "This module processes Erlang source code through lexical analysis, parsing, and abstract syntax tree (AST) manipulation, enabling code analysis, transformation, and generation. It defines core data types like tokens, atoms, expressions, patterns, and modules, with operations for parsing files, constructing AST elements, converting to and from S-expressions, and formatting to readable source code. You can use it to build Erlang compilers, linters, code generators, or transformation tools that analyze or modify code programmatically. Examples include parsing a module into an AST, modifying function clauses, and outputting updated source code or serialized representations.",
      "description_length": 678,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 20,
    "meaningful_modules": 20,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 876,
    "min_description_length": 194,
    "avg_description_length": 452.3,
    "embedding_file_size_mb": 0.07305335998535156
  }
}