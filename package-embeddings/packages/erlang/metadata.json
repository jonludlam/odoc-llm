{
  "package": "erlang",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 21,
  "creation_timestamp": "2025-06-18T16:36:02.869893",
  "modules": [
    {
      "module_path": "Erlang.Printer.H",
      "description": "Adds a leading zero to a string to ensure it reaches a specified minimum length. Works with integers and strings, converting the integer to a string and padding as needed. Used to format numerical values for display in fixed-width fields.",
      "description_length": 238,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Ast",
      "description": "This module provides serialization and deserialization functions for converting OCaml abstract syntax tree (AST) elements, such as expressions, function definitions, attributes, and patterns, into and from S-expressions. It operates on specific AST types like `fun_expr`, `expr`, `fun_def`, and `t`, enabling structured manipulation of program syntax. Use cases include parsing S-expressions into executable code structures, generating human-readable representations, or facilitating interoperation between OCaml tools and external systems.",
      "description_length": 540,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core.Printer",
      "description": "Formats lists of values using a custom pretty-printer function, outputs Erlang variables, literals, expressions, and function definitions to a formatter. Works with Erlang abstract syntax tree nodes and related types. Converts entire Erlang modules to source files or lists of sources for display or output.",
      "description_length": 307,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Atom",
      "description": "Creates and manipulates Erlang atoms, converting them to strings, comparing for equality, concatenating with a separator, and transforming to lowercase. Operates on Erlang abstract syntax tree atoms. Used to generate and modify atom literals during code generation or analysis.",
      "description_length": 277,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Name",
      "description": "Constructs and manipulates Erlang identifiers, converting between strings, atoms, and qualified names. Operates on Erlang AST name structures, supporting both simple and module-qualified identifiers. Used to generate valid Erlang symbol representations from raw data during code generation.",
      "description_length": 290,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Const",
      "description": "Converts string inputs into specific Erlang AST literal nodes, including integers, characters, binaries, strings, and floats. Constructs atom literals from Erlang atom values. Used to generate structured Erlang abstract syntax tree nodes during code generation or transformation processes.",
      "description_length": 289,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Expr",
      "description": "The module constructs and manipulates Erlang abstract syntax tree (AST) expressions, including function applications, case statements, lists, tuples, and control structures, while handling AST nodes like patterns and literals. It processes string inputs to generate AST representations through functions like `macro`, enabling code parsing or transformation. These capabilities support tasks such as metaprogramming, code analysis, and syntactic manipulation in functional programming contexts.",
      "description_length": 494,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Pat",
      "description": "Constructs Erlang pattern matching expressions from various components, including wildcards, named bindings, tuples, lists, maps, and literals. Operates on Erlang abstract syntax tree (AST) elements such as names, literals, and pattern lists. Used to generate match patterns for function clauses or case expressions during code generation.",
      "description_length": 339,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.FunDecl",
      "description": "Constructs Erlang function declarations from a name, optional type specification, and a list of cases. Processes patterns and expressions to define function clauses with optional guards. Used to generate AST nodes for function definitions during code transformation or analysis.",
      "description_length": 278,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Type",
      "description": "Constructs and manipulates type expressions for Erlang AST, including function types, records, maps, tuples, and variants. Operates on atoms, names, literals, and type expressions to build structured type declarations. Used to generate type annotations for function signatures, data structures, and module specifications.",
      "description_length": 321,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper.Export",
      "description": "Creates export entries for Erlang abstract syntax trees, supporting function and type exports with specified names and arities. Operates on atoms and integers to construct export records. Used to generate module export declarations during AST construction.",
      "description_length": 256,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast_helper.Mod",
      "description": "Constructs and manipulates Erlang module ASTs by creating empty modules, building modules with specified attributes, behaviours, exports, functions, and type declarations, and converting module item lists into module structures. Operates on Erlang AST types such as attributes, exports, function declarations, and type declarations. Used to generate valid Erlang module representations for code generation or transformation tasks.",
      "description_length": 430,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Core",
      "description": "Converts OCaml and Erlang AST elements between S-expressions and executable structures, enabling syntax manipulation and interoperation. Handles types like `fun_expr`, `expr`, `fun_def`, and Erlang AST nodes, supporting operations such as parsing, pretty-printing, and code generation. Examples include transforming S-expressions into OCaml code, generating Erlang source files from abstract syntax, and displaying structured data in readable formats. Provides direct control over syntax representation and output formatting for both languages.",
      "description_length": 544,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Ast",
      "description": "This module provides functions for converting abstract syntax tree (AST) elements\u2014such as expressions, patterns, and type declarations\u2014into S-expression formats for serialization or debugging, as well as tools for constructing and annotating structured AST representations. It works with OCaml's internal syntax structures, including module items, attributes, and language constructs, enabling manipulation of program semantics. Use cases include debugging complex code structures, generating human-readable representations, and supporting static analysis tasks.",
      "description_length": 562,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Ast_helper",
      "description": "Provides tools for constructing and manipulating Erlang abstract syntax trees, including atoms, identifiers, literals, expressions, patterns, function declarations, type expressions, and module structures. Supports operations like string conversion, comparison, concatenation, and AST node creation, enabling precise control over code generation and transformation. Examples include generating function clauses with guards, building match patterns for case statements, and creating module exports with specified arities. Handles both simple and qualified names, and supports metaprogramming tasks by converting raw data into structured AST elements.",
      "description_length": 649,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Lexer",
      "description": "Processes input streams to identify and return tokens according to Erlang syntax rules. It operates on Lexing.lexbuf structures and produces Erlang__.Erl_parser.token values. Used to parse Erlang source code into a sequence of lexical elements for further processing.",
      "description_length": 267,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Parse",
      "description": "Processes an Erlang source file, parsing its contents into a list of abstract syntax tree nodes. Accepts a file path and returns either the parsed module items or a parser error message. Used to analyze and transform Erlang code during static analysis or code generation workflows.",
      "description_length": 281,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang.Parser",
      "description": "Parses Erlang source code into an abstract syntax tree using a provided lexer. Processes lexing buffers and token streams to generate a list of module items. Designed for integrating custom lexers with the parsing logic of Erlang modules.",
      "description_length": 238,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Erlang.Printer",
      "description": "Adds a leading zero to a string or integer to ensure it meets a specified minimum length, converting integers to strings as needed. Operates on strings and integers, returning padded results suitable for fixed-width formatting. Can convert `42` to `\"042\"` or `\"7\"` to `\"007\"` when targeting a length of 3. Useful for standardizing numeric or string representations in output.",
      "description_length": 375,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "erlang",
      "description": "Processes OCaml source code, translates it to Erlang, and handles type-checking with the OCaml type system. It operates on OCaml abstract syntax trees and Erlang BEAM bytecode. Used to integrate OCaml code into Erlang-based systems for concurrency and distribution.",
      "description_length": 265,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Erlang",
      "description": "Converts between OCaml and Erlang ASTs and S-expressions, handling elements like `fun_expr`, `expr`, and Erlang nodes, with support for parsing, pretty-printing, and code generation. Enables construction and manipulation of Erlang ASTs, including function clauses, patterns, and module structures, while providing tools for tokenization, parsing, and serialization of Erlang code. Performs string and integer padding with fixed-width formatting, useful for standardizing outputs. Examples include generating Erlang source files from ASTs, debugging code structures via S-expressions, and creating padded numeric strings for consistent formatting.",
      "description_length": 646,
      "index": 20,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 21,
    "meaningful_modules": 21,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 649,
    "min_description_length": 238,
    "avg_description_length": 375.5238095238095,
    "embedding_file_size_mb": 0.07671260833740234
  }
}