{
  "package": "duppy",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 13,
  "creation_timestamp": "2025-08-14T23:31:58.992127",
  "modules": [
    {
      "module_path": "Duppy.Monad.Mutex.Factory.Control",
      "library": "duppy",
      "description": "This module provides functions for creating and managing mutexes within a monadic context, enabling controlled access to shared resources in concurrent tasks. It operates on mutex values and integrates with the scheduler to handle blocking operations without freezing threads. Concrete use cases include coordinating access to shared state in network servers, such as managing client connections or synchronizing resource updates across multiple tasks.",
      "description_length": 452,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.Monad.Mutex.Factory",
      "library": "duppy",
      "description": "This module provides functions to create and manage mutexes within a monadic context, allowing controlled access to shared resources across concurrent tasks. It supports operations like creating a mutex, locking and unlocking it, and attempting non-blocking locks, all integrated with the scheduler to avoid thread blocking. Concrete use cases include synchronizing client connection handling or coordinating updates to shared state in network servers.",
      "description_length": 452,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.Monad.Condition.Factory",
      "library": "duppy",
      "description": "This module provides functions to create and manage condition variables that coordinate concurrent computations within a monadic context. It works with `condition` and `Mutex.mutex` types, enabling tasks to wait, signal, or broadcast state changes without blocking threads. Concrete use cases include synchronizing access to shared resources or coordinating task execution flow in server-side applications, such as managing client authentication steps or resource availability.",
      "description_length": 477,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.Monad.Condition",
      "library": "duppy",
      "description": "This module implements condition variables for coordinating concurrent computations in a monadic context. It provides operations to wait, signal, and broadcast on conditions, working with `condition` and `Mutex.mutex` types. Use it to synchronize shared resources or control task flow, such as managing client authentication or resource availability in server applications.",
      "description_length": 373,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Duppy.Monad.Io",
      "library": "duppy",
      "description": "This module provides functions to schedule and execute computations with specific priorities and delays, handle socket I/O operations with timeouts, and manage data transmission using markers or direct buffering. It works with sockets, strings, and bigarrays, enabling precise control over network communication in server tasks. Concrete use cases include authenticating clients, reading and processing data from sockets with custom delimiters, and sending responses with controlled timing and priority adjustments.",
      "description_length": 515,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Duppy.Monad.Mutex",
      "library": "duppy",
      "description": "This module provides monadic mutex operations for managing concurrent access to shared resources within Duppy's task system. It supports creating, locking, and unlocking mutexes in a way that blocks only the current computation, not the underlying thread, making it suitable for asynchronous, server-oriented workflows. Use cases include synchronizing client authentication steps and coordinating state updates in network services.",
      "description_length": 431,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.Monad.MakeIo",
      "library": "duppy",
      "description": "This module provides monadic operations for managing I/O tasks with explicit control over execution priority, delays, and socket communication. It works with sockets and handlers to perform non-blocking reads, writes, and delayed computations, handling timeouts and errors as part of the monadic flow. Concrete use cases include implementing network protocols where client interactions involve sequential reads and writes with timeout handling, and scheduling background tasks with adjusted priority or delay.",
      "description_length": 509,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.Monad",
      "library": "duppy",
      "description": "This module implements a monad for expressing computations that can either return a value or raise a termination signal, using `return`, `raise`, and `bind` operations. It supports composing asynchronous server workflows, such as client authentication and request handling, with utilities like `catch`, `fold_left`, and `iter` for structured error handling and iteration. The monad integrates with submodules for concurrency (Mutex, Condition) and I/O (Io, MakeIo), enabling fine-grained control over socket communication, task scheduling, and resource synchronization in network services.",
      "description_length": 589,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Duppy.Task",
      "library": "duppy",
      "description": "Handles task scheduling with event-driven execution, supporting delays, I/O operations, and exceptions. Works with tasks composed of events and actions, using Unix file descriptors and timers. Used to register callbacks that respond to network activity or time-based triggers in server applications.",
      "description_length": 299,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Duppy.Io",
      "library": "duppy",
      "description": "This module handles asynchronous socket I/O operations with precise control over data framing and error handling. It provides `read` for splitting incoming socket data on a delimiter or fixed length and `write` for sending data with optional callbacks on success or failure. It works directly with Unix file descriptors, strings, bigarrays, and structured error types, making it suitable for implementing network protocols with message framing, such as handling line-delimited or length-prefixed communication over TCP sockets.",
      "description_length": 527,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Duppy.Async",
      "library": "duppy",
      "description": "This module creates and manages asynchronous tasks that run within a scheduler, supporting delayed execution and manual resumption. It works with the `Duppy.scheduler` type and asynchronous task objects, allowing functions to be queued with delays or triggered externally via `wake_up`. Concrete use cases include scheduling periodic jobs, deferring work with backoff strategies, or resuming suspended tasks in response to external events.",
      "description_length": 439,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy.MakeIo",
      "library": "duppy",
      "description": "This module implements socket I/O operations with support for buffered reading and writing, handling partial data and error conditions. It works with Unix file descriptors wrapped in a transport module, strings, bigarrays, and custom markers for framing. Use it to implement protocols like HTTP or Redis that require reading until a delimiter or fixed length is reached, or to send binary data with optional timeouts and error callbacks.",
      "description_length": 437,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Duppy",
      "library": "duppy",
      "description": "This module provides advanced scheduling and asynchronous task management with support for I/O operations on Unix file descriptors. It includes precise control over event-driven tasks, timeouts, and socket communication, with monadic constructs for structured server workflows. Concrete use cases include implementing network servers handling concurrent clients, managing timed or event-triggered callbacks, and writing protocol-aware socket I/O with framing and error handling.",
      "description_length": 478,
      "index": 12,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 13,
    "meaningful_modules": 13,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 589,
    "min_description_length": 299,
    "avg_description_length": 459.84615384615387,
    "embedding_file_size_mb": 0.1888570785522461
  }
}