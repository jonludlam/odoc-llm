{
  "package": "bitwuzla",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 28,
  "creation_timestamp": "2025-07-15T23:12:14.880980",
  "modules": [
    {
      "module_path": "Bitwuzla.Once.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding mode terms for floating-point operations in an SMT session. It supports specific rounding modes such as round-to-nearest, round-to-zero, and directed rounding modes. These terms are used when encoding floating-point computations that require precise rounding behavior in the solver.",
      "description_length": 327,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Uf",
      "library": "bitwuzla",
      "description": "This module defines and manipulates uninterpreted functions within an SMT solver session. It supports creating function abstractions with `lambda`, applying functions to arguments with `apply`, and retrieving model values of functions with `assignment`. These operations are used to represent and solve constraints involving uninterpreted function symbols in bitvector theories.",
      "description_length": 378,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding-mode terms for floating-point operations in an SMT solver. It provides specific values for standard rounding modes (rne, rna, rtn, rtp, rtz) and a function to construct rounding-mode terms from operators. These terms are used to specify rounding behavior in floating-point arithmetic expressions within the solver.",
      "description_length": 359,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Uf",
      "library": "bitwuzla",
      "description": "This module defines and manipulates uninterpreted functions within a single Bitwuzla session. It supports creating function abstractions with `lambda`, applying functions to arguments with `apply`, and retrieving model values of functions with `assignment`. These operations work with variadic term and sort types, enabling precise modeling and querying of function behavior during SMT solving.",
      "description_length": 394,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bv",
      "library": "bitwuzla",
      "description": "This module enables bit-vector term construction, arithmetic operations with overflow detection, and bitwise manipulations for SMT expression modeling. It operates on bit-vector terms (`Term.Bv.t`) and supports conversions from integers, strings, and Zarith values, alongside shifts, rotations, concatenations, and signed/unsigned comparisons. Key use cases include formal verification of hardware/software systems and symbolic analysis requiring precise bit-level reasoning with overflow-safe arithmetic.",
      "description_length": 505,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Bv",
      "library": "bitwuzla",
      "description": "This module provides bit-vector term creation, arithmetic operations with overflow checks, bitwise manipulations, and bit-level extractions for constructing and analyzing SMT expressions in incremental solving contexts. It operates on bit-vector terms (`Term.Bv.t`) with conversions to integers (`Z.t`) and strings, supporting use cases like formal verification, program analysis, and scenarios requiring bit-precise reasoning or runtime model value extraction during solving.",
      "description_length": 476,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Uf",
      "library": "bitwuzla",
      "description": "This module defines and manipulates uninterpreted functions in the context of SMT solving. It supports creating function abstractions with `lambda`, applying functions to arguments with `apply`, and retrieving model values of functions with `assignment`. These operations are used to represent and evaluate arbitrary functions over bitvectors and other sorts during incremental SMT solving.",
      "description_length": 390,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Term.Fp",
      "library": "bitwuzla",
      "description": "This module provides functions for constructing and operating on floating-point terms in accordance with IEEE 754 semantics, including arithmetic operations (addition, multiplication, fused multiply-add), comparisons, and classification predicates (e.g., NaN, infinity checks). It works with `Term.Fp.t` values representing floating-point terms, `rm term` for rounding modes, and conversions to/from bitvector (`bv term`) and real types. These capabilities enable modeling and verification of floating-point computations in SMT problems involving hardware-aware numerical reasoning.",
      "description_length": 582,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Fp",
      "library": "bitwuzla",
      "description": "This module enables precise modeling of IEEE 754 floating-point computations within an SMT solver, offering arithmetic operations (addition, multiplication, square roots), comparisons, and classification predicates (e.g., NaN checks) that operate on `fp term` values with configurable rounding modes (`rm term`). It supports conversions between floating-point terms and bit-vectors (`bv term`) and extracts concrete floating-point values from solver models for verification tasks like numerical program analysis or hardware design validation. The operations align with SMT-LIB standards, ensuring interoperability with tools requiring bit-accurate FP reasoning.",
      "description_length": 661,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms in an SMT solver session. It supports creating constant arrays, accessing elements via index, updating elements at specific indices, and retrieving model values of arrays. These operations are used to model memory structures, register files, or any indexed data in formal verification tasks.",
      "description_length": 363,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms in the context of SMT solving, specifically supporting array creation, element access, and updates. It works with array terms where indices and elements can be bitvectors, floating-points, or rounding modes. Concrete use cases include modeling memory states, array-based data structures, and symbolic execution of programs with array operations.",
      "description_length": 417,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bv",
      "library": "bitwuzla",
      "description": "This module provides operations for constructing and manipulating bit-vector terms with arithmetic and logical operations, including overflow-aware addition, multiplication, and division, as well as bitwise operations like AND, XOR, and shifts. It works with `Term.Bv.t` values to represent bit-vectors and `Z.t` for integer conversions, enabling precise modeling of low-level data types in SMT solving. These capabilities are used for tasks like verifying arithmetic properties, analyzing bit-level manipulations, and extracting unsatisfiable cores or models in incremental solving scenarios.",
      "description_length": 593,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms within a Bitwuzla SMT session. It supports creating constant arrays, reading from and writing to array elements, and retrieving model assignments for array values. These operations are used when modeling memory, registers, or other indexed data structures in formal verification tasks.",
      "description_length": 357,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bl",
      "library": "bitwuzla",
      "description": "This module provides operations for creating and manipulating boolean terms represented as 1-bit bit-vectors. It includes logical operations such as and, or, xor, not, implies, and equality checks, along with utilities to convert boolean values to and from bit-vector terms. These functions are used to construct and evaluate boolean expressions within an SMT session, particularly for modeling and solving logical constraints.",
      "description_length": 427,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Bl",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate boolean terms represented as 1-bit bit-vectors. It includes functions for logical operations such as and, or, xor, not, and their n-ary and negated variants, along with conversions from booleans and bit-vectors. These operations are used to build and evaluate boolean expressions within an incremental SMT solving session.",
      "description_length": 382,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bl",
      "library": "bitwuzla",
      "description": "This module represents boolean terms as 1-bit bit-vectors and provides logical operations including and, or, xor, nand, nor, xnor, not, implication, and equivalence. It supports conversion from boolean values and bit-vectors, and allows evaluation of term assignments in the current model. Use cases include constructing and manipulating boolean expressions within an SMT solver session for constraint solving and model checking.",
      "description_length": 429,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Fp",
      "library": "bitwuzla",
      "description": "This module enables precise modeling of IEEE 754 floating-point arithmetic within an SMT solver, offering operations to create and manipulate floating-point terms with support for special values (NaN, infinity), arithmetic (addition, multiplication, square root), and classification predicates (zero, subnormal). It works with `Term.Fp.t` for floating-point values, `rm term` for rounding modes, and `bv term` for boolean results, facilitating bit-precise conversions to bitvectors and model extraction. It is particularly useful for verifying numerical software, analyzing floating-point error propagation, and solving constraints involving mixed-precision arithmetic in formal verification workflows.",
      "description_length": 702,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding-mode terms used in floating-point operations. It provides specific values for standard rounding modes (rne, rna, rtn, rtp, rtz) and a function to construct rounding-mode terms from operators. These terms are used when encoding floating-point computations in SMT problems.",
      "description_length": 316,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sort types used to represent Boolean, bit-vector, floating-point, rounding mode, array, and function types in an SMT solver. It provides operations to construct and inspect these sorts, including retrieving sizes, exponents, significands, index and element types, and domain and codomain information. Concrete use cases include defining variable and function signatures for SMT queries, and extracting structural details of sorts for analysis or debugging.",
      "description_length": 492,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term",
      "library": "bitwuzla",
      "description": "This module creates and manipulates terms within a Bitwuzla SMT session, supporting constant creation, equality, disequality, and conditional expressions across sorts like bitvectors, floating-points, arrays, and uninterpreted functions. It enables symbolic expression building for verification tasks such as value comparison, constant definition, and logical condition construction. Submodules handle rounding modes for floating-point operations, uninterpreted function modeling with lambda and apply, bit-vector arithmetic with overflow detection, IEEE 754 floating-point operations, array term manipulation, and boolean term construction using 1-bit bitvectors. Examples include encoding precise floating-point rounding, verifying bit-level arithmetic with overflow checks, modeling memory with arrays, and constructing logical expressions using boolean operations.",
      "description_length": 868,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sorts for bit-vectors, floating-point numbers, rounding modes, arrays, and functions within an incremental SMT solving context. It provides operations to create and inspect sorts, including retrieving sizes, exponents, significands, index and element types, and domain and codomain types. These capabilities are used to define the types of terms and expressions when building and solving logical formulas involving bit-vectors, floating-point arithmetic, and arrays.",
      "description_length": 502,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sort types used to represent Boolean, bit-vector, floating-point, array, function, and rounding mode data in SMT formulas. It provides operations to construct and inspect these sorts, including retrieving sizes, exponents, significands, domains, and codomains. Concrete use cases include defining variable and function signatures for SMT problems involving bit-level operations, floating-point arithmetic, and array manipulations.",
      "description_length": 466,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term",
      "library": "bitwuzla",
      "description": "This module constructs and operates on terms representing logical expressions for SMT solving, supporting bitvectors, floating-points, arrays, and boolean values. It enables equality checks, conditionals, and arithmetic and logical operations, allowing precise modeling of low-level data types and constraints for formal verification. Submodules extend this with uninterpreted functions for abstraction and model extraction, array operations for memory modeling, and bit-vector and floating-point arithmetic with overflow and rounding support. Specific uses include verifying arithmetic properties, symbolic execution with arrays, and analyzing floating-point computations in software validation tasks.",
      "description_length": 702,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term",
      "library": "bitwuzla",
      "description": "This module manages the construction and manipulation of terms in an incremental SMT solving session, supporting symbolic reasoning over multiple sorts including bitvectors, floating-points, and arrays. It provides core operations for equality, disequality, and conditionals, while submodules handle domain-specific tasks such as rounding-mode control, uninterpreted functions, boolean logic, and array operations. For example, you can build bitvector expressions with overflow checks, model IEEE 754 floating-point arithmetic with precise rounding, or represent memory using array terms. These capabilities enable verification tasks like constraint solving, program invariant checking, and hardware validation with concrete model extraction.",
      "description_length": 742,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once",
      "library": "bitwuzla",
      "description": "This module orchestrates a single SMT solving session, allowing users to assert constraints, check satisfiability, and query models, with support for timeouts on operations like `check_sat`. It works in tandem with term and sort modules to build and manipulate logical expressions over bitvectors, floating-points, arrays, and functions. Users can encode problems such as verifying arithmetic with overflow detection, modeling memory using arrays, or analyzing floating-point rounding behavior. Key operations include creating terms, defining sorts, asserting constraints, and retrieving values under a solved model.",
      "description_length": 616,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core",
      "library": "bitwuzla",
      "description": "This module manages incremental satisfiability checks and unsat core generation for constraint systems involving bitvectors, floating-points, and terms, enabling precise analysis of low-level program properties. It provides direct access to solver sessions that track unsatisfiable subsets of constraints, while integrating sort definitions and term constructions to model complex data types and operations such as arithmetic, conditionals, and array manipulations. With support for uninterpreted functions and model extraction, it facilitates tasks like debugging infeasible constraints, verifying arithmetic properties, and performing symbolic execution with detailed memory models.",
      "description_length": 684,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental",
      "library": "bitwuzla",
      "description": "This module enables incremental SMT solving with support for push/pop context management, satisfiability checks, and model value retrieval. It operates on bitvector, floating-point, and term-level data through its core API and submodules, which provide precise sort and term construction for complex expressions. You can build and solve constraints iteratively, perform bounded model checking with assumptions, or explore formulas using symbolic terms for bitvectors with overflow detection, IEEE 754 floating-point arithmetic, and array-based memory models. The module supports verification tasks such as program invariant checking and hardware validation with concrete model extraction.",
      "description_length": 688,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla",
      "library": "bitwuzla",
      "description": "This module orchestrates SMT solving sessions for problems involving bitvectors, floating-points, arrays, and functions, supporting constraint assertion, satisfiability checks, and model queries with timeouts. It provides data types for terms and sorts, enabling precise expression of arithmetic, conditionals, and memory models, with operations like `check_sat`, model extraction, and unsat core generation. Users can verify low-level arithmetic, debug infeasible constraints, perform symbolic execution, and validate hardware or program invariants using incremental solving and context management. Examples include detecting overflow in bitvector arithmetic, analyzing floating-point rounding, and modeling memory with arrays.",
      "description_length": 728,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 28,
    "meaningful_modules": 28,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 868,
    "min_description_length": 316,
    "avg_description_length": 519.5,
    "embedding_file_size_mb": 0.10212039947509766
  }
}