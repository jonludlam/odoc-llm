{
  "package": "bitwuzla",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 28,
  "creation_timestamp": "2025-06-18T16:39:28.569486",
  "modules": [
    {
      "module_path": "Bitwuzla.Incremental.Term.Bl",
      "description": "Converts boolean values and bit-vectors to and from boolean terms, supports logical operations like AND, OR, XOR, and their reductions, and provides implication and equivalence checks. Works with bit-vector terms and boolean values, enabling symbolic logic manipulation. Used to construct and evaluate boolean expressions in SMT solvers or formal verification contexts.",
      "description_length": 369,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Bv",
      "description": "The module provides arithmetic and bitwise operations on bit-vector terms, including addition, subtraction, multiplication, shifts, and logical operations like AND, OR, XOR, along with conversions from integers and strings. It manipulates fixed-width binary data through types such as `t` and binary operators, supporting tasks like signed/unsigned division, rotations, and comparisons. This functionality is tailored for SMT-LIB implementations, hardware modeling, and low-level binary data processing.",
      "description_length": 503,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Rm",
      "description": "Creates rounding-mode terms for specific arithmetic operations, including round-to-nearest-even, round-to-nearest-away, round-toward-zero, and others. Operates on a polymorphic operator type to define the rounding behavior. Used to configure floating-point operations with precise control over rounding strategies in numerical computations.",
      "description_length": 340,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Ar",
      "description": "Creates one-dimensional arrays with elements of specified sorts, allowing indexed access and modification. Supports operations to select and store values at specific indices, using terms representing array, index, and element values. Retrieves model assignments for arrays, returning index-value pairs and a default value for unspecified elements.",
      "description_length": 347,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Uf",
      "description": "Creates function definitions from lambda expressions and applies them to argument terms. Operates on variadic parameter types and bitvector-based terms. Used to model and evaluate uninterpreted functions in symbolic execution contexts.",
      "description_length": 235,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bl",
      "description": "Converts boolean values and bit-vectors to and from SMT boolean terms, supports logical operations like AND, OR, XOR, and their reductions, and provides mechanisms to evaluate boolean terms in a model. Works with bit-vector terms and boolean values, enabling symbolic logic manipulation in verification contexts. Used to construct and evaluate logical expressions in constraint solving and formal verification tasks.",
      "description_length": 416,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bv",
      "description": "The module offers arithmetic operations (addition, multiplication, division), bitwise logical operations (AND, OR, XOR), and structural manipulations (concatenation, extraction) on bit-vector terms, supporting both signed and unsigned interpretations with overflow tracking. It works with bit-vector data types to enable precise control over binary representations, conversions, and low-level logical transformations. Use cases include cryptographic algorithms, hardware modeling, and systems requiring explicit overflow handling or bit-level data processing.",
      "description_length": 559,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Rm",
      "description": "Creates rounding-mode terms based on specified operator kinds, such as round-to-nearest, round-to-away, round-to-zero, and others. Operates on a polymorphic operator type and returns a typed term representing the rounding mode. Used to configure numerical operations requiring precise control over rounding behavior in arithmetic computations.",
      "description_length": 343,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Fp",
      "description": "This module enables manipulation of floating-point terms through arithmetic operations, comparisons, and classification, working with IEEE 754 representations, bitvectors, and rounding modes. It supports conversions between floats, rationals, and real strings, along with low-level value assignment and retrieval for SMT solver model analysis. Specific use cases include precise arithmetic validation, handling edge cases like NaN/infinity, and enforcing SMT-LIB semantics in formal verification tasks.",
      "description_length": 502,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Ar",
      "description": "Creates one-dimensional arrays with specified element types and provides operations to access and modify elements using index terms. Supports array selection, storage, and retrieval of model values for symbolic execution. Works with boolean, floating-point, and real number sorts in SMT-LIB contexts.",
      "description_length": 300,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Uf",
      "description": "Creates function definitions from lambda expressions and applies them to argument terms. Operates on variadic argument types and bitvector-based terms. Used to model and evaluate uninterpreted functions in symbolic execution contexts.",
      "description_length": 234,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bl",
      "description": "Provides bitwise logical operations and conversions for 1-bit boolean terms, including AND, OR, XOR, NOT, and their n-ary variants. Works with `bv term` type, converting between boolean values and bit-vector terms. Enables creation of SMT-LIB expressions for boolean logic and model value extraction.",
      "description_length": 300,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bv",
      "description": "This module offers arithmetic and bitwise operations on bit-vectors, including addition, multiplication, shifts, and logical functions like AND, OR, and XOR, alongside conversions between integers, strings, and bit-vector representations. It handles signed/unsigned comparisons, extensions, rotations, and extraction, adhering to SMT-LIB conventions for precise manipulation of binary data. Use cases include low-level binary processing, formal verification, and scenarios requiring overflow-aware arithmetic.",
      "description_length": 509,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Term.Rm",
      "description": "Creates rounding-mode terms for specific arithmetic operations, including round-to-nearest-even, round-to-nearest-away, round-toward-zero, and others. Operates on a polymorphic operator type to define the rounding behavior. Used to configure precision control in numerical computations requiring explicit rounding strategies.",
      "description_length": 325,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Fp",
      "description": "This module offers arithmetic operations like fused multiply-add, square roots, and rounding, along with comparisons and classification tests for floating-point terms, bitvectors, and IEEE 754 representations. It supports constructing special values (infinity, NaN) and converting between floats, rationals, and string representations, while handling precise rounding modes. Use cases include SMT-LIB compliant verification, numerical analysis, and manipulating model values in symbolic execution.",
      "description_length": 497,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Ar",
      "description": "Creates one-dimensional arrays with a specified sort and initializes them with a given value. Retrieves and updates array elements using index terms, and extracts model values for array terms, including default values for unspecified indices. Works with array terms built from index and element sorts, supporting SMT-LIB operations for array manipulation.",
      "description_length": 355,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Uf",
      "description": "Creates function definitions from lambda expressions and applies them to argument terms. Operates on variadic sorts and function terms with associated values. Used to model and evaluate uninterpreted functions in symbolic execution or theorem proving contexts.",
      "description_length": 260,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Sort",
      "description": "Provides operations to create and inspect bit-vector, floating-point, and rounding-mode sorts, along with array and function sorts. Works with types like bit-vector sizes, exponent and significand sizes, and array index and element sorts. Used to define and manipulate symbolic representations of data types in formal verification or constraint solving contexts.",
      "description_length": 362,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term",
      "description": "manipulates symbolic terms for logical, arithmetic, and floating-point operations, array structures, and function definitions. It handles boolean, bit-vector, and floating-point data types, supporting logical operations, arithmetic computations, rounding modes, array indexing, and function application. Users can construct complex expressions, perform bitwise manipulations, define custom functions, and manage array models with precise control over term evaluation. Examples include evaluating boolean logic, performing signed division, configuring rounding modes for floating-point calculations, and accessing array elements in symbolic execution.",
      "description_length": 650,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Sort",
      "description": "Provides operations to create and inspect bit-vector, floating-point, rounding-mode, array, and function sorts. Works with types like bit-vectors, floating-points, arrays, and functions, each with specific size and structure attributes. Enables checking equality, hashing, and extracting components such as exponent, significand, or domain of a sort.",
      "description_length": 350,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term",
      "description": "combines boolean, bit-vector, rounding-mode, and floating-point operations with array and function handling, enabling symbolic manipulation of logical, arithmetic, and structured data in SMT-based verification. it supports logical operations, arithmetic and bitwise manipulations, rounding-mode configuration, floating-point arithmetic, array indexing, and function application, all working with bit-vectors, booleans, and floats. users can construct complex logical expressions, perform precise arithmetic with overflow tracking, manage floating-point precision, and model array and function behaviors in symbolic execution. examples include verifying cryptographic algorithms, analyzing floating-point edge cases, and modeling array-based data structures in formal verification.",
      "description_length": 780,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Sort",
      "description": "Provides operations to create and inspect bit-vector, floating-point, rounding-mode, array, and function sorts. Works with types like bit-vector sizes, floating-point formats, array indices, and function domains/codomains. Used to define and manipulate data structures in formal verification or symbolic execution contexts.",
      "description_length": 323,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Term",
      "description": "combines bitwise, arithmetic, rounding, and floating-point operations with array and function handling, all operating on bit-vector, rounding-mode, and floating-point terms. It supports logical and arithmetic manipulations, rounding strategies, IEEE 754 conversions, array indexing, and function application. Users can construct SMT-LIB expressions for boolean logic, perform precise binary operations, manage floating-point precision, and model symbolic functions. Examples include creating boolean expressions, performing bit-vector arithmetic, configuring rounding modes, and manipulating array elements in formal verification tasks.",
      "description_length": 636,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once",
      "description": "Manages bit-vector, floating-point, array, and function types, enabling construction and manipulation of complex data structures and operations. Supports bitwise, arithmetic, and logical expressions, rounding strategies, IEEE 754 conversions, and symbolic function application. Users can create boolean logic expressions, perform precise bit-vector arithmetic, and model array and function behaviors. Examples include defining floating-point operations, configuring rounding modes, and generating SMT-LIB expressions for formal verification.",
      "description_length": 541,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental",
      "description": "Manages symbolic data types and expressions for formal verification, enabling creation of bit-vectors, floats, arrays, and functions with precise control over their structure and behavior. Supports operations like logical evaluation, arithmetic computations, array indexing, and function application, with explicit handling of rounding modes and data sort definitions. Users can construct complex expressions, perform bitwise operations, and manage symbolic models in constraint-solving scenarios. Examples include evaluating boolean conditions, executing signed division, configuring floating-point rounding, and accessing symbolic array elements.",
      "description_length": 648,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core",
      "description": "Manages symbolic reasoning and verification by supporting creation and manipulation of complex data types including bit-vectors, floats, arrays, and functions, along with logical and arithmetic operations. Enables construction of intricate expressions, extraction of sort components, and tracking of overflow and rounding modes during computations. Supports tasks such as verifying cryptographic protocols, analyzing floating-point precision, and modeling array behaviors in formal proofs. Provides tools to inspect and utilize unsatisfiable cores during SMT-based validation.",
      "description_length": 576,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "bitwuzla",
      "description": "Provides bitwise operations, bit-vector manipulation, and conversion functions for handling fixed-size bit-vectors and floating-point values. Works with custom data types representing SMT terms, formulas, and solver configurations. Used to construct and solve constraints in formal verification and automated reasoning tasks.",
      "description_length": 325,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla",
      "description": "handles bit-vector, floating-point, array, and function types, enabling construction of complex expressions with precise control over operations, rounding, and data structures. it supports logical evaluation, arithmetic computations, array indexing, and function application, while tracking overflow and rounding modes during execution. users can define floating-point operations, configure rounding strategies, and generate SMT-LIB expressions for formal verification tasks. examples include verifying cryptographic protocols, analyzing precision in floating-point calculations, and modeling symbolic array behaviors.",
      "description_length": 618,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 29,
    "meaningful_modules": 28,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9655172413793104
  },
  "statistics": {
    "max_description_length": 780,
    "min_description_length": 234,
    "avg_description_length": 435.82142857142856,
    "embedding_file_size_mb": 0.10215187072753906
  }
}