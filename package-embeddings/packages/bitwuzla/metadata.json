{
  "package": "bitwuzla",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 28,
  "creation_timestamp": "2025-08-15T12:22:12.077738",
  "modules": [
    {
      "module_path": "Bitwuzla.Once.Term.Fp",
      "library": "bitwuzla",
      "description": "This module enables the construction and manipulation of floating-point terms within an SMT session, adhering to IEEE 754 semantics. It supports arithmetic operations (addition, multiplication, fused multiply-add, etc.), comparisons, and classification predicates (e.g., checking for NaN or infinity) on floating-point terms, while allowing conversions to bitvector representations and extraction of model values as floats. These capabilities are used to verify properties of programs involving floating-point arithmetic, such as numerical algorithms or safety-critical systems requiring precise IEEE 754 compliance.",
      "description_length": 616,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Uf",
      "library": "bitwuzla",
      "description": "This module defines and manipulates uninterpreted functions within an incremental SMT solving context. It supports creating function abstractions with `lambda`, applying functions to arguments with `apply`, and retrieving model assignments with `assignment`. These operations work with bitvector terms and variadic sorts, enabling precise modeling of function behavior during constraint solving.",
      "description_length": 395,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bl",
      "library": "bitwuzla",
      "description": "This module provides operations for creating and manipulating boolean terms represented as 1-bit bit-vectors. It supports logical operations such as AND, OR, XOR, NAND, NOR, XNOR, negation, implication, and bi-implication, along with conversion from boolean values and bit-vector terms. These functions are used to construct and evaluate boolean expressions within an SMT session.",
      "description_length": 380,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding mode terms for floating-point operations in an SMT session. It supports specific rounding modes like round-to-nearest, round-to-zero, and directed rounds, represented as `t` values. These terms are used directly in constructing floating-point expressions that require precise rounding behavior during constraint solving.",
      "description_length": 365,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding-mode terms for floating-point operations in an SMT solver. It provides specific values for rounding modes such as `rne`, `rtn`, and `rtz`, which correspond to standard floating-point rounding behaviors. These terms are used directly in constructing floating-point expressions that require precise rounding control.",
      "description_length": 359,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Bl",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate boolean terms as 1-bit bit-vectors, including logical connectives such as and, or, xor, not, and their n-ary and negated forms. It supports conversion from boolean values and bit-vectors to boolean terms, and extracting model assignments. It is used to express propositional logic constraints in an incremental SMT solving context.",
      "description_length": 391,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bv",
      "library": "bitwuzla",
      "description": "This module provides bit-vector term creation, arithmetic operations (addition, multiplication with overflow checks), bitwise operations (AND, OR, XOR, shifts), and bit-level manipulations (rotations, concatenations, extractions) for constructing SMT expressions. It operates on fixed-size bit-vector terms (`Term.Bv.t`) and supports retrieving model values as big integers (`Z.t`). These capabilities are used in verification tasks requiring precise bit-level reasoning, such as hardware circuit validation or low-level software analysis.",
      "description_length": 539,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms in the context of SMT solving, specifically supporting array creation, element access, and updates. It works with array terms where indices and elements can be bitvectors, floating-points, or rounding modes. Concrete use cases include modeling memory states, register files, or any indexed data structures in formal verification tasks.",
      "description_length": 407,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Uf",
      "library": "bitwuzla",
      "description": "This module defines and manipulates uninterpreted functions within a single-session SMT solving context. It supports creating function abstractions with `lambda`, applying functions to arguments with `apply`, and retrieving model assignments with `assignment`. These operations are used to represent and query function terms in the solver's logical context.",
      "description_length": 357,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Fp",
      "library": "bitwuzla",
      "description": "This module enables precise IEEE 754 floating-point reasoning through operations like creating special values (NaN, infinity), arithmetic (addition, multiplication, fused operations), comparisons (ordered, min/max), and classification (zero, normal/subnormal checks) on `Term.Fp.t` values. It supports conversions between floating-point and bitvector representations using customizable rounding modes (`rm term`), alongside extracting concrete floating-point assignments from models. These capabilities are designed for verifying floating-point computations in SMT problems, handling edge cases like rounding errors or exceptional values in numerical code.",
      "description_length": 656,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Bl",
      "library": "bitwuzla",
      "description": "This module represents Boolean terms as 1-bit bit-vectors and provides logical operations such as conjunction, disjunction, negation, and implication. It supports creating Boolean terms from bit-vectors and converting Boolean values to 1-bit terms. Use cases include constructing and manipulating Boolean expressions within an SMT solver session for formal verification tasks.",
      "description_length": 376,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms in an SMT solver session. It supports creating constant arrays, reading from and writing to array elements, and retrieving model values of arrays. These operations work with array terms where indices and elements can be bitvectors, floating-points, or rounding modes. Use cases include modeling memory states, managing symbolic arrays in program verification, and handling array-based constraints in formal proofs.",
      "description_length": 486,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Incremental.Term.Bv",
      "library": "bitwuzla",
      "description": "This module enables bit-vector term creation and manipulation with arithmetic operations (including overflow detection), bitwise logic, shifts, rotations, and concatenation on `Term.Bv.t` values. It supports comparisons, bit extractions, and sign/zero extensions, while allowing retrieval of evaluated bit-vector values as arbitrary-precision integers. These capabilities are used for incrementally modeling hardware circuits, low-level software constructs, and constraint-solving scenarios requiring bit-precise reasoning.",
      "description_length": 523,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Rm",
      "library": "bitwuzla",
      "description": "This module creates and manipulates rounding-mode terms used in floating-point operations. It supports specific rounding modes like round-to-nearest, round-to-zero, and directed roundings. These terms are essential for encoding floating-point computations in SMT problems that require precise control over rounding behavior.",
      "description_length": 324,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Fp",
      "library": "bitwuzla",
      "description": "This module enables constructing and manipulating floating-point terms with IEEE 754-compliant arithmetic, comparisons, and classification predicates, supporting operations like addition, multiplication, rounding, and conversion to/from bitvectors. It works with `fp term` values for floating-point representations, `rm term` for rounding modes, and `bv term` for bitvector outputs, aligning with SMT-LIB's floating-point theory. Specific use cases include formal verification of numerical algorithms, safety-critical systems requiring precise floating-point behavior analysis, and debugging arithmetic constraints in hardware/software designs through unsatisfiable core extraction.",
      "description_length": 682,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term.Uf",
      "library": "bitwuzla",
      "description": "This module represents uninterpreted functions within an SMT session, supporting function definition via lambda abstraction and application of functions to arguments. It works with terms and sorts, particularly bitvector types, enabling precise modeling of function behavior. Use this module to define and manipulate functions whose semantics are determined entirely by the constraints in the problem, such as modeling program functions during verification.",
      "description_length": 457,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once.Term.Ar",
      "library": "bitwuzla",
      "description": "This module provides operations to construct and manipulate array terms within a Bitwuzla SMT session. It supports creating constant arrays, reading from and writing to array elements, and retrieving array model values. These operations are used when modeling memory or data structures in formal verification tasks involving arrays.",
      "description_length": 332,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term.Bv",
      "library": "bitwuzla",
      "description": "This module supports creating bit-vector terms and performing arithmetic (including overflow-checked addition, subtraction, multiplication, and division), bitwise operations (AND, OR, XOR, shifts), and structural manipulations (concatenation, extraction, rotation). It operates on `Term.Bv.t` values, which represent bit-vector terms in the SMT solver, and can retrieve concrete bit-vector assignments as arbitrary-precision integers. It is particularly useful for formal verification tasks involving hardware circuits, binary arithmetic, or low-level system code where precise bit-level reasoning is required within a single SMT solving session.",
      "description_length": 646,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Term",
      "library": "bitwuzla",
      "description": "This module creates and manipulates SMT terms across multiple theories including bit-vectors, floating-points, arrays, and uninterpreted functions. It supports equality and disequality checks, conditional expressions, term hashing, sort retrieval, pretty printing, and term inspection. It is used to build and query symbolic expressions in an incremental SMT solving session for verifying low-level code, hardware designs, and numerical algorithms.",
      "description_length": 448,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sorts for bit-vectors, floating-point numbers, rounding modes, arrays, and functions within an SMT solver session. It provides operations to construct and inspect these sorts, such as creating bit-vector and floating-point types with specified sizes, extracting index and element types from array sorts, and retrieving function domain and codomain sorts. Concrete use cases include defining variable and expression types when formulating SMT problems involving bit-level operations, floating-point arithmetic, and array manipulations.",
      "description_length": 570,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Term",
      "library": "bitwuzla",
      "description": "This module creates and manipulates SMT terms across multiple theories including booleans, bit-vectors, floating-point numbers, arrays, and uninterpreted functions. It supports logical and arithmetic operations, term construction, equality checks, conditional expressions, and term inspection via views. Concrete use cases include building and analyzing SMT formulas for formal verification of hardware designs, low-level code, and numerical algorithms requiring precise bit-level or floating-point reasoning.",
      "description_length": 509,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Once.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sorts for bit-vectors, floating-point numbers, arrays, and functions within a single SMT solving session. It provides operations to construct and inspect sorts, including retrieving sizes, exponents, significands, and domain or codomain components. Concrete use cases include modeling fixed-size bit-vectors, specifying floating-point precision, and defining array and function types for SMT assertions.",
      "description_length": 439,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Sort",
      "library": "bitwuzla",
      "description": "This module defines and manipulates sorts for bit-vectors, floating-points, rounding modes, arrays, and functions within an SMT solver context. It provides operations to construct and inspect these sorts, including retrieving sizes, exponents, significands, domains, and codomains. Concrete use cases include modeling data types in formal verification tasks, such as specifying bit-vector operations, floating-point arithmetic, and array manipulations in SMT problems.",
      "description_length": 468,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core.Term",
      "library": "bitwuzla",
      "description": "This module creates and manipulates SMT terms across multiple theories, including Boolean logic, bit-vectors, floating-points, arrays, and uninterpreted functions. It supports operations like equality, disequality, conditional expressions, term hashing, and type inspection, working with terms that represent variables, constants, and expressions in these theories. Concrete use cases include building and analyzing SMT formulas for formal verification of hardware, software, and numerical algorithms.",
      "description_length": 501,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Incremental",
      "library": "bitwuzla",
      "description": "This module supports incremental SMT solving with context stack operations (`push`, `pop`), satisfiability checks (`check_sat`, `check_sat_assuming`), and model extraction (`get_value`). It works with bit-vector, floating-point, and term data types to enable stepwise constraint solving and backtracking. Concrete use cases include verifying hardware designs and low-level code with iterative refinement of constraints and model-based analysis.",
      "description_length": 444,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla.Unsat_core",
      "library": "bitwuzla",
      "description": "This module supports incremental SMT solving with unsatisfiable core generation, enabling users to identify conflicting constraints through `check_sat_assuming`, `get_unsat_assumptions`, and `get_unsat_core`. It operates on bit-vector terms and integrates with the `Term` module for constructing and evaluating SMT formulas. Concrete use cases include debugging infeasible configurations in hardware verification and pinpointing inconsistencies in software model checking.",
      "description_length": 472,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bitwuzla.Once",
      "library": "bitwuzla",
      "description": "This module manages a single SMT solving session, enabling assertion setup, satisfiability checks, and model extraction. It operates on terms and sorts from the Term and Sort modules, supporting bit-vectors, floating-point numbers, arrays, and functions. Concrete use cases include verifying properties of low-level code, analyzing numerical algorithms with precise rounding behavior, and solving constraints over fixed-size data types.",
      "description_length": 436,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Bitwuzla",
      "library": "bitwuzla",
      "description": "This module provides functions for solving SMT problems in the QF_AUFBVFP theory, including operations for asserting constraints, querying satisfiability, and managing solver configurations. It works with bitvector, array, and floating-point data types to model and solve complex logical formulas. Concrete use cases include formal verification of hardware designs, software analysis, and constraint solving for security applications.",
      "description_length": 434,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 28,
    "meaningful_modules": 28,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 682,
    "min_description_length": 324,
    "avg_description_length": 464.7142857142857,
    "embedding_file_size_mb": 0.4063577651977539
  }
}