{
  "package": "lib_parsing",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 9,
  "creation_timestamp": "2025-08-14T23:07:55.766501",
  "modules": [
    {
      "module_path": "Meta_parse_info",
      "library": "lib_parsing",
      "description": "This module converts parse information into OCaml values, offering adjustable precision for dumping fields like full, token, and type info. It works with `Parse_info.t` and exposes a dumper precision type to control output detail. Concrete use cases include serializing parse metadata for debugging or analysis with configurable verbosity.",
      "description_length": 339,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib_ast_fuzzy",
      "library": "lib_parsing",
      "description": "This module constructs and transforms abstract syntax trees and token lists using customizable hooks. It processes lists of tokens into fuzzy ASTs and provides traversal mechanisms via visitors that can inspect or modify tree nodes, tokens, and nested structures. Concrete use cases include parsing incomplete or malformed code, analyzing code structure with partial information, and implementing custom AST traversals for refactoring or linting tools.",
      "description_length": 452,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parse_info",
      "library": "lib_parsing",
      "description": "This module offers operations to track and manipulate token metadata during parsing, such as location details, origins, and transformations. It handles source code location metadata (via `Parse_info.t`) and `token_location` structures, enabling tasks like splitting metadata at specific positions, generating synthetic locations, and managing bracketed constructs with contextual information. These capabilities are used in lexical analysis, error reporting, positional comparisons, and extracting token origins for code analysis or transformation workflows.",
      "description_length": 558,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Skip_code",
      "library": "lib_parsing",
      "description": "This module handles file and directory skipping logic for processing codebases. It provides operations to load skip rules from a file, filter and split file lists based on those rules, and reorder files to prioritize error-free directories. It works directly with file and directory names using custom skip types to represent exclusion rules. Concrete use cases include selectively skipping files during analysis or test execution based on predefined rules.",
      "description_length": 457,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing_helpers",
      "library": "lib_parsing",
      "description": "This module handles tokenization and position adjustment for parsing, providing functions to create token streams, manipulate lex buffers, and correct token locations during or after parsing. It works with lex buffers, token lists, and location information types like `Parse_info.t` and `Parse_info.token_location`. Concrete uses include adjusting token positions when parsing fragments inserted into temporary files, generating accurate error messages with file positions, and integrating lexer and parser stages by managing token streams and location tracking.",
      "description_length": 562,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Loc",
      "library": "lib_parsing",
      "description": "This module handles location tracking by combining start and end tokens into a single location range. It supports operations like creating locations from token lists, merging ranges, adjusting start/end tokens, and checking if a location is fake. It is used to manage source code positions for parsing and error reporting, enabling precise location-based manipulations.",
      "description_length": 369,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ast_fuzzy",
      "library": "lib_parsing",
      "description": "This module represents a simplified abstract syntax tree (AST) structure for pattern matching and code transformation tasks. It provides variants for common syntactic constructs like parentheses, braces, and brackets, along with support for metavariables and ellipses (dots) used in code templates. The module is used to model and manipulate incomplete or approximate code fragments, particularly in code search and refactoring tools.",
      "description_length": 434,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flag_parsing",
      "library": "lib_parsing",
      "description": "This module manages parsing and lexing behavior through mutable flags that control verbosity, error handling, and debugging. It provides functions to configure command-line options for controlling these behaviors and a conditional execution function for sgrep-specific logic. Concrete use cases include enabling detailed parsing logs, toggling error recovery, and activating debug output for lexers and parsers.",
      "description_length": 411,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsing_stat",
      "library": "lib_parsing",
      "description": "This module tracks and analyzes the results of parsing operations, including counts of nodes, errors, and problematic lines. It works with abstract syntax tree statistics and file-level parsing data to identify recurring issues and measure parsing accuracy. Concrete use cases include generating summaries of parsing outcomes, highlighting frequently problematic tokens, and aggregating statistics across multiple files for regression analysis.",
      "description_length": 444,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 10,
    "meaningful_modules": 9,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9
  },
  "statistics": {
    "max_description_length": 562,
    "min_description_length": 339,
    "avg_description_length": 447.3333333333333,
    "embedding_file_size_mb": 0.13084793090820312
  }
}